[
    {
        "title": "Most Profit Assigning Work",
        "question_content": "You have n jobs and m workers. You are given three arrays: difficulty, profit, and worker where:\n\n\tdifficulty[i] and profit[i] are the difficulty and the profit of the ith job, and\n\tworker[j] is the ability of jth worker (i.e., the jth worker can only complete a job with difficulty at most worker[j]).\n\nEvery worker can be assigned at most one job, but one job can be completed multiple times.\n\n\tFor example, if three workers attempt the same job that pays $1, then the total profit will be $3. If a worker cannot complete any job, their profit is $0.\n\nReturn the maximum profit we can achieve after assigning the workers to the jobs.\n&nbsp;\nExample 1:\n\nInput: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7]\nOutput: 100\nExplanation: Workers are assigned jobs of difficulty [4,4,6,6] and they get a profit of [20,20,30,30] separately.\n\nExample 2:\n\nInput: difficulty = [85,47,57], profit = [24,66,99], worker = [40,25,25]\nOutput: 0\n\n&nbsp;\nConstraints:\n\n\tn == difficulty.length\n\tn == profit.length\n\tm == worker.length\n\t1 <= n, m <= 104\n\t1 <= difficulty[i], profit[i], worker[i] <= 105",
        "solutions": [
            {
                "id": 127031,
                "title": "c-java-python-sort-and-two-pointer",
                "content": "# Solution 1\\n1. zip `difficulty` and `profit` as jobs.\\n2. sort `jobs` and sort \\'worker\\'.\\n3. Use 2 pointers. For each worker, find his maximum profit `best` he can make under his ability.\\n<br>\\n\\nBecause we have sorted `jobs` and `worker`,\\nwe will go through two lists only once.\\nthis will be only `O(D + W)`.\\n`O(DlogD + WlogW)`, as we sort jobs.\\n<br>\\n\\n**C++**\\n```cpp\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int, int>> jobs;\\n        int N = profit.size(), res = 0, i = 0, best = 0;\\n        for (int j = 0; j < N; ++j)\\n            jobs.push_back(make_pair(difficulty[j], profit[j]));\\n        sort(jobs.begin(), jobs.end());\\n        sort(worker.begin(), worker.end());\\n        for (int & ability : worker) {\\n            while (i < N && ability >= jobs[i].first)\\n                best = max(jobs[i++].second, best);\\n            res += best;\\n        }\\n        return res;\\n    }\\n```\\n\\n**Java:**\\n```java\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        List<Pair<Integer, Integer>> jobs = new ArrayList<>();\\n        int N = profit.length, res = 0, i = 0, best = 0;\\n        for (int j = 0; j < N; ++j)\\n            jobs.add(new Pair<Integer, Integer>(difficulty[j], profit[j]));\\n        Collections.sort(jobs, Comparator.comparing(Pair::getKey));\\n        Arrays.sort(worker);\\n        for (int ability : worker) {\\n            while (i < N && ability >= jobs.get(i).getKey())\\n                best = Math.max(jobs.get(i++).getValue(), best);\\n            res += best;\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python:**\\n```python\\n    def maxProfitAssignment(self, difficulty, profit, worker):\\n        jobs = sorted(zip(difficulty, profit))\\n        res = i = best = 0\\n        for ability in sorted(worker):\\n            while i < len(jobs) and ability >= jobs[i][0]:\\n                best = max(jobs[i][1], best)\\n                i += 1\\n            res += best\\n        return res\\n\\n```\\n<br>\\n\\n# Solution 2\\n1. Use a treemap<difficulty, profit>\\n2. Go through the treemap once, find the max profit `best` for each difficulty.\\nTime `O(DlogD + WlogD)`\\n<br>\\n\\n**Java**\\n```java\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        map.put(0, 0);\\n        for (int i = 0; i < difficulty.length; i++) {\\n            map.put(difficulty[i], Math.max(profit[i], map.getOrDefault(difficulty[i], 0)));\\n        }\\n        int best = 0, res = 0;\\n        for (Integer key : map.keySet()) {\\n            best = Math.max(map.get(key), best);\\n            map.put(key, best);\\n        }\\n        for (int i = 0; i < worker.length; i++) {\\n            res += map.floorEntry(worker[i]).getValue();\\n        }\\n        return res;\\n    }\\n```\\n**C++**\\n```cpp\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int N = profit.size(), res = 0, i = 0, best = 0;\\n        map<int, int> jobs;\\n        jobs[0] = 0;\\n        for (int j = 0; j < N; ++j)\\n            jobs[difficulty[j]] = max(jobs[difficulty[j]], profit[j]);\\n        for (auto &it: jobs)\\n            it.second = best = max(best, it.second);\\n        for (int & ability : worker)\\n            res += (--jobs.upper_bound(ability))->second;\\n        return res;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```cpp\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int, int>> jobs;\\n        int N = profit.size(), res = 0, i = 0, best = 0;\\n        for (int j = 0; j < N; ++j)\\n            jobs.push_back(make_pair(difficulty[j], profit[j]));\\n        sort(jobs.begin(), jobs.end());\\n        sort(worker.begin(), worker.end());\\n        for (int & ability : worker) {\\n            while (i < N && ability >= jobs[i].first)\\n                best = max(jobs[i++].second, best);\\n            res += best;\\n        }\\n        return res;\\n    }\\n```\n```java\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        List<Pair<Integer, Integer>> jobs = new ArrayList<>();\\n        int N = profit.length, res = 0, i = 0, best = 0;\\n        for (int j = 0; j < N; ++j)\\n            jobs.add(new Pair<Integer, Integer>(difficulty[j], profit[j]));\\n        Collections.sort(jobs, Comparator.comparing(Pair::getKey));\\n        Arrays.sort(worker);\\n        for (int ability : worker) {\\n            while (i < N && ability >= jobs.get(i).getKey())\\n                best = Math.max(jobs.get(i++).getValue(), best);\\n            res += best;\\n        }\\n        return res;\\n    }\\n```\n```python\\n    def maxProfitAssignment(self, difficulty, profit, worker):\\n        jobs = sorted(zip(difficulty, profit))\\n        res = i = best = 0\\n        for ability in sorted(worker):\\n            while i < len(jobs) and ability >= jobs[i][0]:\\n                best = max(jobs[i][1], best)\\n                i += 1\\n            res += best\\n        return res\\n\\n```\n```java\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        map.put(0, 0);\\n        for (int i = 0; i < difficulty.length; i++) {\\n            map.put(difficulty[i], Math.max(profit[i], map.getOrDefault(difficulty[i], 0)));\\n        }\\n        int best = 0, res = 0;\\n        for (Integer key : map.keySet()) {\\n            best = Math.max(map.get(key), best);\\n            map.put(key, best);\\n        }\\n        for (int i = 0; i < worker.length; i++) {\\n            res += map.floorEntry(worker[i]).getValue();\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int N = profit.size(), res = 0, i = 0, best = 0;\\n        map<int, int> jobs;\\n        jobs[0] = 0;\\n        for (int j = 0; j < N; ++j)\\n            jobs[difficulty[j]] = max(jobs[difficulty[j]], profit[j]);\\n        for (auto &it: jobs)\\n            it.second = best = max(best, it.second);\\n        for (int & ability : worker)\\n            res += (--jobs.upper_bound(ability))->second;\\n        return res;\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 127133,
                "title": "java-solution-with-treemap",
                "content": "```\\npublic int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n       \\n        TreeMap<Integer, Integer> tmap = new TreeMap<>();\\n        // in case two jobs have same difficulty but different profit, we want to count\\n        // the higher profit\\n        for (int i = 0; i < difficulty.length; i++) {\\n            tmap.put(difficulty[i], Math.max(profit[i], tmap.getOrDefault(difficulty[i], 0)));\\n        }\\n\\n        int max = 0, res = 0;\\n        // maximum profit at this difficulty or below in case\\n        // lower difficulty job offers higher profit\\n        for (Integer key : tmap.keySet()) {\\n            max = Math.max(tmap.get(key), max);\\n            tmap.put(key, max);\\n        }\\n        \\n        Map.Entry<Integer, Integer> entry = null;\\n        for (int i = 0; i < worker.length; i++) {\\n            if (tmap.containsKey(worker[i])) {\\n                res += tmap.get(worker[i]);\\n            } else {\\n                entry = tmap.floorEntry(worker[i]);            \\n                if (entry != null) {\\n                    res += entry.getValue();\\n                }\\n            }  \\n        }\\n        return res;  \\n}",
                "solutionTags": [],
                "code": "```\\npublic int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n       \\n        TreeMap<Integer, Integer> tmap = new TreeMap<>();\\n        // in case two jobs have same difficulty but different profit, we want to count\\n        // the higher profit\\n        for (int i = 0; i < difficulty.length; i++) {\\n            tmap.put(difficulty[i], Math.max(profit[i], tmap.getOrDefault(difficulty[i], 0)));\\n        }\\n\\n        int max = 0, res = 0;\\n        // maximum profit at this difficulty or below in case\\n        // lower difficulty job offers higher profit\\n        for (Integer key : tmap.keySet()) {\\n            max = Math.max(tmap.get(key), max);\\n            tmap.put(key, max);\\n        }\\n        \\n        Map.Entry<Integer, Integer> entry = null;\\n        for (int i = 0; i < worker.length; i++) {\\n            if (tmap.containsKey(worker[i])) {\\n                res += tmap.get(worker[i]);\\n            } else {\\n                entry = tmap.floorEntry(worker[i]);            \\n                if (entry != null) {\\n                    res += entry.getValue();\\n                }\\n            }  \\n        }\\n        return res;  \\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 175676,
                "title": "java-memorization-without-sort-beat-99-85",
                "content": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        int[] dp = new int[100001];\\n        for (int i = 0; i < difficulty.length; i++) {\\n            dp[difficulty[i]] = Math.max(dp[difficulty[i]], profit[i]);\\n        }\\n        for (int i = 0; i < dp.length; i++) {\\n            if (i > 0) {\\n                dp[i] = Math.max(dp[i - 1], dp[i]);\\n            }\\n        }\\n        int sum = 0;\\n        for (int i : worker) {\\n            sum += dp[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        int[] dp = new int[100001];\\n        for (int i = 0; i < difficulty.length; i++) {\\n            dp[difficulty[i]] = Math.max(dp[difficulty[i]], profit[i]);\\n        }\\n        for (int i = 0; i < dp.length; i++) {\\n            if (i > 0) {\\n                dp[i] = Math.max(dp[i - 1], dp[i]);\\n            }\\n        }\\n        int sum = 0;\\n        for (int i : worker) {\\n            sum += dp[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 126964,
                "title": "c-4-lines-sort-bucket-sort-and-bucked-sort-with-two-pointers",
                "content": "This solution sorts levels and assigns the maximum profit among all jobs with equal or lower level:\\n\\n1. Load levels and profits into a sorted map.\\n2. Update the map so that each level has the maximum possible profit. Practically, if the previous level has higher profit, we assign that profit to the current level.\\n3. For each worker, search the map to get the maximum profit for the worker\\'s level.\\n\\nThe complexity is O((n + m) log n), where n and m is the number of jobs and workers respectfully.\\n```\\nint maxProfitAssignment(vector<int>& lv, vector<int>& profit, vector<int>& worker) {\\n  map<int, int> m = { { 0, 0 } };\\n  for (auto i = 0; i < lv.size(); ++i) m[lv[i]] = max(m[lv[i]], profit[i]);\\n  for (auto it = next(m.begin()); it != m.end(); ++it) it->second = max(it->second, prev(it)->second);\\n  return accumulate(begin(worker), end(worker), 0, [&](int s, int w) {return s + prev(m.upper_bound(w))->second;});\\n}\\n```\\nAs a bonus, below is the solution that uses bucket sort. It requires, however, additional memory but the runtime complexity is O(N + m), where N is the number of levels (100,000 in our case). The second solution is only slightly faster in OJ (100 vs. 110 ms), probably because n is signifficantly smaller than N in the test cases.\\n```\\nint maxProfitAssignment(vector<int>& lv, vector<int>& profit, vector<int>& worker) {\\n  int m[100001] = {};\\n  for (auto i = 0; i < lv.size(); ++i) m[lv[i]] = max(m[lv[i]], profit[i]);\\n  for (auto i = 1; i < 100001; ++i) m[i] = max(m[i], m[i - 1]);\\n  return accumulate(begin(worker), end(worker), 0, [&](int s, int w) { return s + m[w]; });\\n}\\n```\\nI also checked the sort and two-pointer solution by @lee215. That solution requires two sorts, that\\'s why my preference was to sort once and fix profits in the linear time. Anyway, I adopted the two-pointer solution to use the bucket sort. Note that I store the number of workers with a given level in the second array.\\n```\\nint maxProfitAssignment(vector<int>& lv, vector<int>& profit, vector<int>& worker) {\\n  int m[100001] = {}, w[100001] = {}, p = 0, max_p = 0;\\n  for (auto i = 0; i < lv.size(); ++w[worker[i++]]) m[lv[i]] = max(m[lv[i]], profit[i]);\\n  return accumulate(begin(w), end(w), 0, [&](int s, int w) { max_p = max(max_p, m[p++]); return s + max_p * w; });\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint maxProfitAssignment(vector<int>& lv, vector<int>& profit, vector<int>& worker) {\\n  map<int, int> m = { { 0, 0 } };\\n  for (auto i = 0; i < lv.size(); ++i) m[lv[i]] = max(m[lv[i]], profit[i]);\\n  for (auto it = next(m.begin()); it != m.end(); ++it) it->second = max(it->second, prev(it)->second);\\n  return accumulate(begin(worker), end(worker), 0, [&](int s, int w) {return s + prev(m.upper_bound(w))->second;});\\n}\\n```\n```\\nint maxProfitAssignment(vector<int>& lv, vector<int>& profit, vector<int>& worker) {\\n  int m[100001] = {};\\n  for (auto i = 0; i < lv.size(); ++i) m[lv[i]] = max(m[lv[i]], profit[i]);\\n  for (auto i = 1; i < 100001; ++i) m[i] = max(m[i], m[i - 1]);\\n  return accumulate(begin(worker), end(worker), 0, [&](int s, int w) { return s + m[w]; });\\n}\\n```\n```\\nint maxProfitAssignment(vector<int>& lv, vector<int>& profit, vector<int>& worker) {\\n  int m[100001] = {}, w[100001] = {}, p = 0, max_p = 0;\\n  for (auto i = 0; i < lv.size(); ++w[worker[i++]]) m[lv[i]] = max(m[lv[i]], profit[i]);\\n  return accumulate(begin(w), end(w), 0, [&](int s, int w) { max_p = max(max_p, m[p++]); return s + max_p * w; });\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 438559,
                "title": "short-simple-binary-search-java",
                "content": "```\\npublic int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        int n = difficulty.length;\\n        List<int[]> list = new ArrayList<>();\\n        for(int i=0;i<n;i++) {\\n            list.add(new int[]{difficulty[i],profit[i]});\\n        }\\n        list.sort((a,b)->(a[0]-b[0]!=0?a[0]-b[0]:b[1]-a[1]));\\n        int[] max = new int[n];\\n        max[0]=list.get(0)[1];// Maximum Value till a given index.\\n        for (int i=1;i<n;i++) {\\n            max[i]=Math.max(list.get(i)[1],max[i-1]); \\n        }\\n        int ans=0;\\n        for(int w: worker) {\\n            int res = bs(w,list);\\n            ans+=res==-1?0:max[res];\\n        }\\n        return ans;\\n    }\\n\\t// Smallest index which is less than or equal to the given target.\\n    private int bs(int target,List<int[]> list) {\\n        int lo = 0;\\n        int hi = list.size()-1;\\n        if(target>=list.get(hi)[0]) {\\n            return hi;\\n        }\\n        int ans = -1;\\n        while (lo<hi) {\\n            int mid = (lo)+(hi-lo)/2;\\n            int val = list.get(mid)[0];\\n            if(target>=val) {\\n                ans=mid;\\n                lo=mid+1;\\n            } else {\\n                hi=mid;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        int n = difficulty.length;\\n        List<int[]> list = new ArrayList<>();\\n        for(int i=0;i<n;i++) {\\n            list.add(new int[]{difficulty[i],profit[i]});\\n        }\\n        list.sort((a,b)->(a[0]-b[0]!=0?a[0]-b[0]:b[1]-a[1]));\\n        int[] max = new int[n];\\n        max[0]=list.get(0)[1];// Maximum Value till a given index.\\n        for (int i=1;i<n;i++) {\\n            max[i]=Math.max(list.get(i)[1],max[i-1]); \\n        }\\n        int ans=0;\\n        for(int w: worker) {\\n            int res = bs(w,list);\\n            ans+=res==-1?0:max[res];\\n        }\\n        return ans;\\n    }\\n\\t// Smallest index which is less than or equal to the given target.\\n    private int bs(int target,List<int[]> list) {\\n        int lo = 0;\\n        int hi = list.size()-1;\\n        if(target>=list.get(hi)[0]) {\\n            return hi;\\n        }\\n        int ans = -1;\\n        while (lo<hi) {\\n            int mid = (lo)+(hi-lo)/2;\\n            int val = list.get(mid)[0];\\n            if(target>=val) {\\n                ans=mid;\\n                lo=mid+1;\\n            } else {\\n                hi=mid;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 126994,
                "title": "concise-c-solution-using-map-as-a-bst",
                "content": "```\\nint maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n    map<int, int> m{{0,0}};\\n    for (int i = 0; i < difficulty.size(); i++) // create the difficulty-maximum-profit BST\\n        m[difficulty[i]] = max(m[difficulty[i]], profit[i]);\\n    int mx = 0, res = 0;\\n    for (auto &p : m) // update the BST to reflect the maximum profit for a job\\n        mx = p.second = max(p.second, mx);\\n    for (int w : worker) // look up the BST to find the maximum profit for each worker\\n        res += prev(m.upper_bound(w))->second;\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n    map<int, int> m{{0,0}};\\n    for (int i = 0; i < difficulty.size(); i++) // create the difficulty-maximum-profit BST\\n        m[difficulty[i]] = max(m[difficulty[i]], profit[i]);\\n    int mx = 0, res = 0;\\n    for (auto &p : m) // update the BST to reflect the maximum profit for a job\\n        mx = p.second = max(p.second, mx);\\n    for (int w : worker) // look up the BST to find the maximum profit for each worker\\n        res += prev(m.upper_bound(w))->second;\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1288704,
                "title": "simple-java-solution",
                "content": "**Approach** : \\n1. bind profit & difficulty array together using a simple 2d-array \\'pair\\'.\\n2.  sort pair array on basis of difficulty column.\\n3.  sort worker array.\\n3.  for each worker, find his maximum profit best he can make under his ability.\\n\\n**Doubt** :\\nWhat is the need to sort worker[ ] ???\\n**Reason** :\\nIf current worker has more capacity than his previous ones, then his minimum bestPay should be equal to, maximum bestPaySoFar of workers with less capacity.\\nIf he\\'s able to do more-tougher-job, but less-tougher-job pays more, then he\\'s automatically entitled to benefits of that less-tougher-job.\\nNow because he has more ability as compared to previous workers, he can explore more tougher-high-paying-jobs.\\n\\nDue to this, we need to traverse pair[ ] only once.\\nthough we have nested for-while loop, but complexity will become o[worker.length] + o[pair.length].\\n\\nOverall time complexity:\\ndue to sorting of both worker & pair : O(PlogP + WlogW).\\n\\n**Java**:\\n```\\npublic int maxProfitAssignment(int[] diff, int[] profit, int[] worker) {`\\n\\n\\tint pair[][] = new int[diff.length][2];\\n\\tfor(int i = 0; i < diff.length; i++){\\n\\t\\tpair[i][0] = diff[i];\\n\\t\\tpair[i][1] = profit[i];\\n\\t}\\n\\t// sorting 2d array on basis of difficulty colmn\\n\\tArrays.sort(pair, new Comparator<int[]>() {\\n\\t\\t@Override\\n\\t\\tpublic int compare(int o1[], int o2[]){\\n\\t\\t\\treturn Integer.valueOf(o1[0]).compareTo(o2[0]);\\n\\t\\t}\\n\\t});\\n\\n\\tint totalProfit = 0;\\n\\n\\t//MAGIC begins HERE\\n\\tArrays.sort(worker);\\n\\tint bestPaySoFar = 0;\\n\\tint i = 0;      // declaring globally creates MAGIC!!\\n\\n\\tfor(int k = 0; k < worker.length; k++){\\n\\t\\tint ability = worker[k];\\n\\n\\t\\twhile(i < pair.length && ability >= pair[i][0]){\\n\\t\\t\\tif(bestPaySoFar < pair[i][1])\\n\\t\\t\\t\\tbestPaySoFar = pair[i][1];\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\n\\t\\ttotalProfit += bestPaySoFar;\\n\\t}\\n\\n\\treturn totalProfit;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\npublic int maxProfitAssignment(int[] diff, int[] profit, int[] worker) {`\\n\\n\\tint pair[][] = new int[diff.length][2];\\n\\tfor(int i = 0; i < diff.length; i++){\\n\\t\\tpair[i][0] = diff[i];\\n\\t\\tpair[i][1] = profit[i];\\n\\t}\\n\\t// sorting 2d array on basis of difficulty colmn\\n\\tArrays.sort(pair, new Comparator<int[]>() {\\n\\t\\t@Override\\n\\t\\tpublic int compare(int o1[], int o2[]){\\n\\t\\t\\treturn Integer.valueOf(o1[0]).compareTo(o2[0]);\\n\\t\\t}\\n\\t});\\n\\n\\tint totalProfit = 0;\\n\\n\\t//MAGIC begins HERE\\n\\tArrays.sort(worker);\\n\\tint bestPaySoFar = 0;\\n\\tint i = 0;      // declaring globally creates MAGIC!!\\n\\n\\tfor(int k = 0; k < worker.length; k++){\\n\\t\\tint ability = worker[k];\\n\\n\\t\\twhile(i < pair.length && ability >= pair[i][0]){\\n\\t\\t\\tif(bestPaySoFar < pair[i][1])\\n\\t\\t\\t\\tbestPaySoFar = pair[i][1];\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\n\\t\\ttotalProfit += bestPaySoFar;\\n\\t}\\n\\n\\treturn totalProfit;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 126932,
                "title": "python-sort-based",
                "content": "The idea is to sort the profits and difficulty,  based on difficulty.\\nAlso the profits array can be modified to store the max_profits till that index.\\n\\nAfter that, its just a matter of finding the correct position for each worker in the difficulty array and adding the max_profit from the profit array.\\n\\n```\\n    def maxProfitAssignment(self, difficulty, profit, worker):\\n        difficulty, profit = zip(*sorted(zip(difficulty, profit)))\\n        max_profit = -math.inf\\n        profit = list(profit)\\n        for i in range(len(profit)):\\n            if max_profit < profit[i]:\\n                max_profit = profit[i]\\n            else:\\n                profit[i] = max_profit\\n        res = 0\\n        for w in worker:\\n            i = bisect_right(difficulty, w)\\n            if i != 0: res += profit[i-1]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def maxProfitAssignment(self, difficulty, profit, worker):\\n        difficulty, profit = zip(*sorted(zip(difficulty, profit)))\\n        max_profit = -math.inf\\n        profit = list(profit)\\n        for i in range(len(profit)):\\n            if max_profit < profit[i]:\\n                max_profit = profit[i]\\n            else:\\n                profit[i] = max_profit\\n        res = 0\\n        for w in worker:\\n            i = bisect_right(difficulty, w)\\n            if i != 0: res += profit[i-1]\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 510197,
                "title": "c-very-easy-to-understand",
                "content": "class Solution {\\npublic:\\n    \\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<int> diff_pro(100001,0);\\n        int res=0;\\n        for(int i=0;i<difficulty.size();i++){\\n            diff_pro[difficulty[i]]=max(diff_pro[difficulty[i]],profit[i]);\\n        }\\n        for(int i=1;i<100001;i++){\\n            diff_pro[i]=max(diff_pro[i],diff_pro[i-1]);\\n        }\\n        for(int i=0;i<worker.size();i++){\\n            res+=diff_pro[worker[i]];\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<int> diff_pro(100001,0);\\n        int res=0;\\n        for(int i=0;i<difficulty.size();i++){\\n            diff_pro[difficulty[i]]=max(diff_pro[difficulty[i]],profit[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 126977,
                "title": "java-ac-sort-and-binary-search-o-nlogn",
                "content": "```\\nclass Solution {\\n    class Pair {\\n        int d;\\n        int p;\\n        public Pair(int d, int p) {\\n            this.d = d;\\n            this.p = p;\\n        }\\n    }\\n\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        List<Pair> list = new ArrayList<>();\\n        for (int i = 0; i < profit.length; i++) {\\n            list.add(new Pair(difficulty[i], profit[i]));\\n        }\\n\\n        // sort d from small to large and if d is the same, put smaller p in the front\\n        Collections.sort(list, (a, b) -> (a.d == b.d) ? a.p - b.p : a.d - b.d);\\n\\n        for (int i = 1; i < list.size(); i++) {\\n            // assign the max profit from 0 to current location\\n            list.get(i).p = Math.max(list.get(i).p, list.get(i - 1).p);\\n        }\\n\\n        int count = 0;\\n        for (int w : worker) {\\n            count += binarySearch(list, w);\\n        }\\n\\n        return count;\\n    }\\n\\n    // find the last number <= w in list.d, and return that index\\'s profit, if not available return 0.\\n    private int binarySearch(List<Pair> list, int w) {\\n        int start = 0;\\n        int end = list.size() - 1;\\n        while (start + 1 < end) {\\n            int mid = (end - start) / 2 + start;\\n            if (list.get(mid).d <= w) {\\n                start = mid;\\n            } else {\\n                end = mid;\\n            }\\n        }\\n\\n        if (list.get(end).d <= w) {\\n            return list.get(end).p;\\n        }\\n        if (list.get(start).d <= w) {\\n            return list.get(start).p;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class Pair {\\n        int d;\\n        int p;\\n        public Pair(int d, int p) {\\n            this.d = d;\\n            this.p = p;\\n        }\\n    }\\n\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        List<Pair> list = new ArrayList<>();\\n        for (int i = 0; i < profit.length; i++) {\\n            list.add(new Pair(difficulty[i], profit[i]));\\n        }\\n\\n        // sort d from small to large and if d is the same, put smaller p in the front\\n        Collections.sort(list, (a, b) -> (a.d == b.d) ? a.p - b.p : a.d - b.d);\\n\\n        for (int i = 1; i < list.size(); i++) {\\n            // assign the max profit from 0 to current location\\n            list.get(i).p = Math.max(list.get(i).p, list.get(i - 1).p);\\n        }\\n\\n        int count = 0;\\n        for (int w : worker) {\\n            count += binarySearch(list, w);\\n        }\\n\\n        return count;\\n    }\\n\\n    // find the last number <= w in list.d, and return that index\\'s profit, if not available return 0.\\n    private int binarySearch(List<Pair> list, int w) {\\n        int start = 0;\\n        int end = list.size() - 1;\\n        while (start + 1 < end) {\\n            int mid = (end - start) / 2 + start;\\n            if (list.get(mid).d <= w) {\\n                start = mid;\\n            } else {\\n                end = mid;\\n            }\\n        }\\n\\n        if (list.get(end).d <= w) {\\n            return list.get(end).p;\\n        }\\n        if (list.get(start).d <= w) {\\n            return list.get(start).p;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 861065,
                "title": "c-sorting-solution-o-wlogw-dlogd-dp-solution-o-w-d",
                "content": "**Sorting Solution: O(WLogW + DLogD)**\\n\\nRuntime: 172 ms, faster than 83.27% of C++ online submissions for Most Profit Assigning Work.\\nMemory Usage: 38 MB, less than 47.43% of C++ online submissions for Most Profit Assigning Work.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        \\n        // Make difficult and profit pair vector jobs\\n        vector<pair<int,int>>jobs;\\n        \\n        int d_size = difficulty.size();\\n        for(int i=0;i<d_size;i++)\\n            jobs.push_back(make_pair(difficulty[i],profit[i]));\\n        \\n        // sort jobs difficulty => O ( DLogD )\\n        sort(jobs.begin(),jobs.end());\\n        \\n        // sort workers array difficulty => O ( WLogW ) \\n        sort(worker.begin(),worker.end());\\n        \\n        int w_size = worker.size();\\n        int maxProfit = 0;\\n        int cprofit = 0;\\n        int cjob = 0;\\n        \\n        // Loop through workers array to find profit for each worker => O ( W + D )\\n        for(int i=0;i<w_size;i++)\\n        {\\n            // find max profit for worker[i] which is cprofit\\n            // As jobs and workers are sorted, cprofit is always max for any difficulty range\\n            while(cjob<d_size && jobs[cjob].first<=worker[i])\\n            {\\n                cprofit = max(cprofit,jobs[cjob].second);\\n                cjob++;\\n            }\\n            \\n            // update total max profit\\n            maxProfit+= cprofit;\\n        }\\n        \\n        return maxProfit;\\n    }\\n};\\n```\\n.\\n.\\n.\\n**DP Solution: O( W + D )**\\n\\nRuntime: 140 ms, faster than 97.43% of C++ online submissions for Most Profit Assigning Work.\\nMemory Usage: 35.7 MB, less than 97.24% of C++ online submissions for Most Profit Assigning Work.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        \\n        int dp[100001] = {};\\n        int p_size = profit.size();\\n        \\n        for(int i=0;i<p_size;i++)\\n            dp[difficulty[i]] = max(profit[i],dp[difficulty[i]]);\\n        \\n        for(int i=1;i<=100000;i++)\\n            dp[i] = max(dp[i],dp[i-1]);\\n        \\n        int maxProfit = 0;\\n        int w_size = worker.size();\\n        \\n        for(int i=0;i<w_size;i++)\\n            maxProfit+=dp[worker[i]];\\n        \\n        return maxProfit;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        \\n        // Make difficult and profit pair vector jobs\\n        vector<pair<int,int>>jobs;\\n        \\n        int d_size = difficulty.size();\\n        for(int i=0;i<d_size;i++)\\n            jobs.push_back(make_pair(difficulty[i],profit[i]));\\n        \\n        // sort jobs difficulty => O ( DLogD )\\n        sort(jobs.begin(),jobs.end());\\n        \\n        // sort workers array difficulty => O ( WLogW ) \\n        sort(worker.begin(),worker.end());\\n        \\n        int w_size = worker.size();\\n        int maxProfit = 0;\\n        int cprofit = 0;\\n        int cjob = 0;\\n        \\n        // Loop through workers array to find profit for each worker => O ( W + D )\\n        for(int i=0;i<w_size;i++)\\n        {\\n            // find max profit for worker[i] which is cprofit\\n            // As jobs and workers are sorted, cprofit is always max for any difficulty range\\n            while(cjob<d_size && jobs[cjob].first<=worker[i])\\n            {\\n                cprofit = max(cprofit,jobs[cjob].second);\\n                cjob++;\\n            }\\n            \\n            // update total max profit\\n            maxProfit+= cprofit;\\n        }\\n        \\n        return maxProfit;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        \\n        int dp[100001] = {};\\n        int p_size = profit.size();\\n        \\n        for(int i=0;i<p_size;i++)\\n            dp[difficulty[i]] = max(profit[i],dp[difficulty[i]]);\\n        \\n        for(int i=1;i<=100000;i++)\\n            dp[i] = max(dp[i],dp[i-1]);\\n        \\n        int maxProfit = 0;\\n        int w_size = worker.size();\\n        \\n        for(int i=0;i<w_size;i++)\\n            maxProfit+=dp[worker[i]];\\n        \\n        return maxProfit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 126955,
                "title": "extremely-simple-using-priority-queue",
                "content": "Sort the class Work in ascending order of difficulty. If difficulty is the same, sort according to descending order of profit. Sort the worker as per ascending order of their ability. \\n\\nNow you just need to match the work with the worker and store the max profit seen until now and add it to the total profit. \\n\\n```\\npublic class Solution {\\n    class Work{\\n        int d; \\n        int p; \\n        Work(int d, int p){\\n            this.d = d; \\n            this.p = p; \\n        }\\n    }\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        PriorityQueue<Work> pq = new PriorityQueue<Work>((a, b)->(a.d==b.d)?b.p-a.p:a.d-b.d);\\n        for(int i = 0; i < profit.length; ++i){\\n            pq.offer(new Work(difficulty[i], profit[i])); \\n        }\\n        Arrays.sort(worker); \\n        int i = 0; \\n        int cprofit = 0; \\n        int max = 0; \\n        while(!pq.isEmpty() && i < worker.length){\\n            Work w = pq.poll(); \\n            if(w.d <= worker[i]){\\n                max = Math.max(max, w.p); \\n            }else{\\n                i++; \\n                cprofit+=max; \\n                pq.offer(w); \\n            }\\n        }\\n        while(i < worker.length){\\n            cprofit+=max; \\n            i++; \\n        }\\n        return cprofit; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    class Work{\\n        int d; \\n        int p; \\n        Work(int d, int p){\\n            this.d = d; \\n            this.p = p; \\n        }\\n    }\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        PriorityQueue<Work> pq = new PriorityQueue<Work>((a, b)->(a.d==b.d)?b.p-a.p:a.d-b.d);\\n        for(int i = 0; i < profit.length; ++i){\\n            pq.offer(new Work(difficulty[i], profit[i])); \\n        }\\n        Arrays.sort(worker); \\n        int i = 0; \\n        int cprofit = 0; \\n        int max = 0; \\n        while(!pq.isEmpty() && i < worker.length){\\n            Work w = pq.poll(); \\n            if(w.d <= worker[i]){\\n                max = Math.max(max, w.p); \\n            }else{\\n                i++; \\n                cprofit+=max; \\n                pq.offer(w); \\n            }\\n        }\\n        while(i < worker.length){\\n            cprofit+=max; \\n            i++; \\n        }\\n        return cprofit; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471974,
                "title": "much-intuitive-binary-search-greedy-simple-and-easy-to-understand-c-solution",
                "content": "# Intuition\\nWe Can Sort The Difficulty - Profit Pair And Use Binary Search For Assigning Jobs TO Workers\\n# Approach\\nWhy Sorting Based ON Difficulty but Not on Profit, Because In The Given Problem Workers Difficulty Level  Capability Is Provided Based On these Data We Should Assign The Jobs To Workers.\\nNow After Sorting Difficulty And Profit Pair , we Should Observe ONE Important Point Here\\nConsider The Example\\n Difficulty : [68,35,52,47,86]\\n Profit:[67,17,1,81,3]\\nWorkers :[92,10,85,84,82]\\nIf We Sort Difficulty And Profit Pair We Get \\nDifficulty :[35,47,52,68,86]\\nProfit : [17,81,1,67,3]\\n**Important Observation\\nIf A Worker Can Do A Job At difficulty Level X then he can do all Jobs With difficulty level less than or Equal to X**\\nNow if X=52 , What is The Maximum Profit ,we Can Get it is 81 .\\nAt difficulty level 81 we have maxprofit 81.\\nSo we should Update The Profit Values With Maximum Values From Previous Ones \\nie; \\nat i=1 profit[i]=max(profit[i],profit[i-1])=(81,17)=81\\n    at i=2 profit[i]=max(profit[i],profit[i-1])=(1,81)=81\\n    at i=3 profit[i]=max(profit[i],profit[i-1])=(67,81)=81\\n    at i=4 profit[i]=max(profit[i],profit[i-1])=(3,81)=81\\nThe Profit Array Becomes [17,81,81,81,81]\\nNow We Can Apply Binary Search (Upper Bound) For Every Worker Individually And Assign Jobs Finally Get The Max Profit.\\n\\n**PLEASE UPVOTE IF UNDERSTAND THE SOLUTION**\\n\\n\\n# Complexity\\n- Time complexity:\\nO(NLOGN+MLOGN)\\n- Space complexity:\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int,int>>arr;\\n         int n=difficulty.size();\\n     \\n         for(int i=0;i<n;i++)\\n         {\\n             arr.push_back({difficulty[i],profit[i]});\\n         }       \\n           sort(arr.begin(),arr.end());\\n\\n             for(int i=1;i<n;i++) arr[i].second=max(arr[i].second,arr[i-1].second);\\n         long long maxprofit=0;\\n         int low,high,mid,temprofit;\\n         for(auto i:worker)\\n         {\\n             low=0,high=n-1,temprofit=0;\\n             while(low<=high)\\n             {\\n                 mid=(low+high)/2;\\n                 if(arr[mid].first<=i)        low=mid+1;\\n                 else high=mid-1;\\n             }\\n          if(high>=0)   maxprofit=(long long)maxprofit+arr[high].second;\\n         }\\n         return maxprofit;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int,int>>arr;\\n         int n=difficulty.size();\\n     \\n         for(int i=0;i<n;i++)\\n         {\\n             arr.push_back({difficulty[i],profit[i]});\\n         }       \\n           sort(arr.begin(),arr.end());\\n\\n             for(int i=1;i<n;i++) arr[i].second=max(arr[i].second,arr[i-1].second);\\n         long long maxprofit=0;\\n         int low,high,mid,temprofit;\\n         for(auto i:worker)\\n         {\\n             low=0,high=n-1,temprofit=0;\\n             while(low<=high)\\n             {\\n                 mid=(low+high)/2;\\n                 if(arr[mid].first<=i)        low=mid+1;\\n                 else high=mid-1;\\n             }\\n          if(high>=0)   maxprofit=(long long)maxprofit+arr[high].second;\\n         }\\n         return maxprofit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3222137,
                "title": "c-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& d, vector<int>& p, vector<int>& w) {\\n        vector<pair<int,int>>v;\\n        for(int i=0;i<d.size();i++){\\n            v.push_back({d[i],p[i]});\\n        }\\n        sort(v.begin(),v.end());\\n        int n=d.size();\\n        vector<int>dp(n+1);\\n        dp[0]=v[0].second;\\n        for(int i=1;i<n;i++){\\n            dp[i]=max(dp[i-1],v[i].second);\\n        }\\n        sort(d.begin(),d.end());\\n        int s=0;\\n        for(int i=0;i<w.size();i++){\\n           int in=upper_bound(d.begin(),d.end(),w[i])-d.begin();\\n           if(in!=0){\\n               in--;\\n               s+=dp[in];\\n           }\\n        }\\n        return s;\\n    }\\n};\\n```\\n![upvote (3).jpg](https://assets.leetcode.com/users/images/44d7abb5-b520-4d81-b589-567c12aa2091_1677164915.7858884.jpeg)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& d, vector<int>& p, vector<int>& w) {\\n        vector<pair<int,int>>v;\\n        for(int i=0;i<d.size();i++){\\n            v.push_back({d[i],p[i]});\\n        }\\n        sort(v.begin(),v.end());\\n        int n=d.size();\\n        vector<int>dp(n+1);\\n        dp[0]=v[0].second;\\n        for(int i=1;i<n;i++){\\n            dp[i]=max(dp[i-1],v[i].second);\\n        }\\n        sort(d.begin(),d.end());\\n        int s=0;\\n        for(int i=0;i<w.size();i++){\\n           int in=upper_bound(d.begin(),d.end(),w[i])-d.begin();\\n           if(in!=0){\\n               in--;\\n               s+=dp[in];\\n           }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2603913,
                "title": "python3-solved-using-binary-search-w-sorting-o-n-m-logn-runtime-solution",
                "content": "```\\nclass Solution:\\n    #Time-Complexity: O(n + nlogn + n + mlog(n)) -> O((n+m) *logn)\\n    #Space-Complexity: O(n)\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        #Approach: First of all, linearly traverse each and every corresponding index\\n        #position of first two input arrays: difficulty and profit to group each\\n        #item by 1-d array and put it in separate 2-d array. Then, sort the 2-d array\\n        #by increasing difficulty of the job! Then, for each worker, perform binary\\n        #search and consistently update the max profit the current worker can work and\\n        #earn! Add this value to answer variable, which is cumulative for all workers!\\n        #this will be the result returned at the end!\\n        arr = []\\n        for i in range(len(difficulty)):\\n            arr.append([difficulty[i], profit[i]])\\n        #sort by difficulty!\\n        arr.sort(key = lambda x: x[0])\\n        #then, I need to update the maximum profit up to each and every item!\\n        maximum = float(-inf)\\n        for j in range(len(arr)):\\n            maximum = max(maximum, arr[j][1])\\n            arr[j][1] = maximum\\n        ans = 0\\n        #iterate through each and every worker!\\n        for w in worker:\\n            bestProfit = 0\\n            #define search space to perform binary search!\\n            L, R = 0, len(arr) - 1\\n            #as long as search space has at least one element to consider or one job,\\n            #continue iterations of binary search!\\n            while L <= R:\\n                mid = (L + R) // 2\\n                mid_e = arr[mid]\\n                #check if current job has difficulty that is manageable!\\n                if(mid_e[0] <= w):\\n                    bestProfit = max(bestProfit, mid_e[1])\\n                    #we still need to search right and try higher difficulty\\n                    #jobs that might yield higher profit!\\n                    L = mid + 1\\n                    continue\\n                else:\\n                    R = mid - 1\\n                    continue\\n            #once we break from while loop and end binary search, we should have\\n            #found bestProfit for current worker performing task that is manageable!\\n            ans += bestProfit\\n        return ans",
                "solutionTags": [
                    "Python3",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    #Time-Complexity: O(n + nlogn + n + mlog(n)) -> O((n+m) *logn)\\n    #Space-Complexity: O(n)\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        #Approach: First of all, linearly traverse each and every corresponding index\\n        #position of first two input arrays: difficulty and profit to group each\\n        #item by 1-d array and put it in separate 2-d array. Then, sort the 2-d array\\n        #by increasing difficulty of the job! Then, for each worker, perform binary\\n        #search and consistently update the max profit the current worker can work and\\n        #earn! Add this value to answer variable, which is cumulative for all workers!\\n        #this will be the result returned at the end!\\n        arr = []\\n        for i in range(len(difficulty)):\\n            arr.append([difficulty[i], profit[i]])\\n        #sort by difficulty!\\n        arr.sort(key = lambda x: x[0])\\n        #then, I need to update the maximum profit up to each and every item!\\n        maximum = float(-inf)\\n        for j in range(len(arr)):\\n            maximum = max(maximum, arr[j][1])\\n            arr[j][1] = maximum\\n        ans = 0\\n        #iterate through each and every worker!\\n        for w in worker:\\n            bestProfit = 0\\n            #define search space to perform binary search!\\n            L, R = 0, len(arr) - 1\\n            #as long as search space has at least one element to consider or one job,\\n            #continue iterations of binary search!\\n            while L <= R:\\n                mid = (L + R) // 2\\n                mid_e = arr[mid]\\n                #check if current job has difficulty that is manageable!\\n                if(mid_e[0] <= w):\\n                    bestProfit = max(bestProfit, mid_e[1])\\n                    #we still need to search right and try higher difficulty\\n                    #jobs that might yield higher profit!\\n                    L = mid + 1\\n                    continue\\n                else:\\n                    R = mid - 1\\n                    continue\\n            #once we break from while loop and end binary search, we should have\\n            #found bestProfit for current worker performing task that is manageable!\\n            ans += bestProfit\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 1228765,
                "title": "easiest-c-soln-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& dif, vector<int>& pr, vector<int>& wo) {\\n        int n=dif.size();\\n        vector<pair<int,int>> v;\\n        for(int i=0;i<n;i++){\\n            v.push_back({dif[i],pr[i]});\\n        }\\n        sort(v.begin(),v.end());\\n        int maxpro=v[0].second;\\n        for(int i=1;i<v.size();i++){\\n            maxpro=max(maxpro,v[i].second);\\n            v[i].second=maxpro;\\n        }\\n        int ans=0;\\n        for(auto &w:wo){\\n            int tmp=0;\\n            int i=0,j=n-1;\\n            while(i<=j){\\n                int m=(i+j)>>1;\\n                if(v[m].first<=w){\\n                    tmp=max(tmp,v[m].second);\\n                    i=m+1;\\n                }\\n                else j=m-1;\\n            }\\n            ans+=tmp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& dif, vector<int>& pr, vector<int>& wo) {\\n        int n=dif.size();\\n        vector<pair<int,int>> v;\\n        for(int i=0;i<n;i++){\\n            v.push_back({dif[i],pr[i]});\\n        }\\n        sort(v.begin(),v.end());\\n        int maxpro=v[0].second;\\n        for(int i=1;i<v.size();i++){\\n            maxpro=max(maxpro,v[i].second);\\n            v[i].second=maxpro;\\n        }\\n        int ans=0;\\n        for(auto &w:wo){\\n            int tmp=0;\\n            int i=0,j=n-1;\\n            while(i<=j){\\n                int m=(i+j)>>1;\\n                if(v[m].first<=w){\\n                    tmp=max(tmp,v[m].second);\\n                    i=m+1;\\n                }\\n                else j=m-1;\\n            }\\n            ans+=tmp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1055712,
                "title": "beat-99-71-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& d, vector<int>& p, vector<int>& w) {\\n        int mp[100001] = {0}, res = 0;\\n        for(int i = 0; i < d.size(); i++)\\n            mp[d[i]] = max(mp[d[i]], p[i]);\\n        for(int i = 1; i < 100001; i++)\\n            mp[i] = max(mp[i], mp[i - 1]);\\n        for(auto n : w)\\n            res += mp[n];\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& d, vector<int>& p, vector<int>& w) {\\n        int mp[100001] = {0}, res = 0;\\n        for(int i = 0; i < d.size(); i++)\\n            mp[d[i]] = max(mp[d[i]], p[i]);\\n        for(int i = 1; i < 100001; i++)\\n            mp[i] = max(mp[i], mp[i - 1]);\\n        for(auto n : w)\\n            res += mp[n];\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 388263,
                "title": "java-hashmap-two-pointer-sort",
                "content": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        if (difficulty == null || profit == null || worker == null) {\\n            return 0;\\n        }\\n        \\n        int res = 0;\\n        Map<Integer, Integer> dict = new HashMap<>();\\n        for (int i = 0; i < difficulty.length; i++) {\\n            // duplicate difficulty may have different profits\\n            dict.put(difficulty[i], Math.max(dict.getOrDefault(difficulty[i], 0), profit[i]));\\n        }\\n        \\n        Arrays.sort(difficulty);\\n        Arrays.sort(worker);\\n        \\n        int j = 0;\\n        int max = 0;\\n        for (int i = 0; i < worker.length; i++) {\\n            while (j < difficulty.length && worker[i] >= difficulty[j]) {\\n                max = Math.max(max, dict.get(difficulty[j]));\\n                j++;\\n            }\\n            res += max;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        if (difficulty == null || profit == null || worker == null) {\\n            return 0;\\n        }\\n        \\n        int res = 0;\\n        Map<Integer, Integer> dict = new HashMap<>();\\n        for (int i = 0; i < difficulty.length; i++) {\\n            // duplicate difficulty may have different profits\\n            dict.put(difficulty[i], Math.max(dict.getOrDefault(difficulty[i], 0), profit[i]));\\n        }\\n        \\n        Arrays.sort(difficulty);\\n        Arrays.sort(worker);\\n        \\n        int j = 0;\\n        int max = 0;\\n        for (int i = 0; i < worker.length; i++) {\\n            while (j < difficulty.length && worker[i] >= difficulty[j]) {\\n                max = Math.max(max, dict.get(difficulty[j]));\\n                j++;\\n            }\\n            res += max;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3612171,
                "title": "greedy-c-simple-approach",
                "content": "# **if it Helps You, Please Upvote Me......!**\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nApproach is simple, just try to understand the following conditions:-\\n\\n**worker 5 can get all the jobs with difficulty 5,4,3,2,1  but in all of the Jobs worker will choose the job with Maximum Profit.**\\n\\nby using this approach we can easily solve this problem let\\'s take an Example:-\\n**Difficulty: [1,5,4] ,Profit: [5,3,7] ,  worker [4,6]**\\n\\n**for 1st worker(4):- this worker can get the job 1,4 but he will choose the job that has maximum profit( that is 7)**\\n\\n**for 2nd worker(6):- this worker can get all the job 1,4,5 but he will choose the job that has maximum profit( that is 7)**\\n\\n**in this way the answer will be 7+7 = 14**\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n   \\n    int maxProfitAssignment(vector<int>& d, vector<int>& p, vector<int>& w) {\\n\\n        vector<int> pos(100005,0);\\n    \\n        for(int i = 0;i<d.size();i++)\\n        pos[d[i]] = max(p[i],pos[d[i]]); \\n        \\n        int maxprofit = 0,ans = 0;\\n        for(int i = 0;i<pos.size();i++)\\n        {\\n            maxprofit = max(maxprofit,pos[i]);\\n            pos[i] = maxprofit;\\n        }\\n        for(int i = 0;i<w.size();i++)\\n        ans+=pos[w[i]];\\n\\n        return ans;\\n        \\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/2729c740-f688-4f96-980e-3cb24d75cdfa_1686205157.029114.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n   \\n    int maxProfitAssignment(vector<int>& d, vector<int>& p, vector<int>& w) {\\n\\n        vector<int> pos(100005,0);\\n    \\n        for(int i = 0;i<d.size();i++)\\n        pos[d[i]] = max(p[i],pos[d[i]]); \\n        \\n        int maxprofit = 0,ans = 0;\\n        for(int i = 0;i<pos.size();i++)\\n        {\\n            maxprofit = max(maxprofit,pos[i]);\\n            pos[i] = maxprofit;\\n        }\\n        for(int i = 0;i<w.size();i++)\\n        ans+=pos[w[i]];\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3440958,
                "title": "binary-search-approach-c-intuition-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nObviously, for ith worker we\\'ll try to maximize the profit. So whatever tasks that can be done by this worker we\\'ll choose the max profit.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf a worker can do tasks with difficulty i then he can do every task having difficulty <=i so if I somehow know the max profit among all such tasks that\\'ll be the ans for that worker. This leads us to the binary search approach. Suppose I sort the tasks wrt to their difficulty and I know the max profit I can get from tasks having <=i diffculty that\\'ll be the answer. Make a vector pair of {difficulty,profit}\\ndo binary search on difficulty and take maximum of profit till that index which can be maintained by prefix maximum;\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n + mlog(n));\\n- Space complexity:\\n- O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& dif, vector<int>& profit, vector<int>& worker) {\\n        \\n        vector<pair<int,int>> a;\\n        int n = dif.size();\\n        for(int i = 0; i < n; i++) {\\n            a.push_back( { dif[i], profit[i] } );\\n        }\\n        \\n        sort(a.begin(), a.end());\\n        vector<int> preMax(n);\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            preMax[i] = (i-1>=0) ? max(preMax[i-1],a[i].second) : a[i].second;\\n\\n        }\\n        \\n        int ans = 0;\\n        int m = worker.size();\\n        for(int i = 0; i < m; i++)\\n        {\\n            pair<int,int> se = {worker[i],1e9};\\n            int ind = upper_bound(a.begin(),a.end(),se) - a.begin();\\n            if(ind==0) continue;\\n            --ind;\\n            \\n            ans += preMax[ind];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& dif, vector<int>& profit, vector<int>& worker) {\\n        \\n        vector<pair<int,int>> a;\\n        int n = dif.size();\\n        for(int i = 0; i < n; i++) {\\n            a.push_back( { dif[i], profit[i] } );\\n        }\\n        \\n        sort(a.begin(), a.end());\\n        vector<int> preMax(n);\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            preMax[i] = (i-1>=0) ? max(preMax[i-1],a[i].second) : a[i].second;\\n\\n        }\\n        \\n        int ans = 0;\\n        int m = worker.size();\\n        for(int i = 0; i < m; i++)\\n        {\\n            pair<int,int> se = {worker[i],1e9};\\n            int ind = upper_bound(a.begin(),a.end(),se) - a.begin();\\n            if(ind==0) continue;\\n            --ind;\\n            \\n            ans += preMax[ind];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371795,
                "title": "c-easy-to-understand-sorting-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSort\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. make **vector{profit,difficulty}** and sort it \\n2. sort worker array \\n3. keep index at last of sorted vector{profit,difficulty}\\n4. **start from last of sorted worker array** and check for worker[i]>=difficulty of sorted array{profit,difficulty} \\n4,1. If not greater, do index-- till greater found and add that profit to final ans **because profits beyond that cannot be acquired by other workers futher in iteration** \\n4,2. Else add vector{profit,difficulty}[index] to finalAns\\n5. Return final Answer\\n \\n\\n\\n# Complexity\\nlength of difficulty array=n\\nlength of worker array=m\\n- Time complexity:O(nlogn+mlogm+n+m) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker){\\n        int n=difficulty.size();\\n        vector<pair<int,int>> nums;\\n\\n        for(int i=0;i<n;i++){\\n            nums.push_back({profit[i],difficulty[i]});\\n        }\\n        sort(nums.begin(),nums.end());\\n        int index=n-1;\\n        int ans=0;\\n        sort(worker.begin(),worker.end());\\n        \\n        for(int i=worker.size()-1;i>=0;i--){\\n            while(index>=0 && nums[index].second>worker[i]) index--;\\n            if(index==-1) continue;\\n            ans+=nums[index].first;\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker){\\n        int n=difficulty.size();\\n        vector<pair<int,int>> nums;\\n\\n        for(int i=0;i<n;i++){\\n            nums.push_back({profit[i],difficulty[i]});\\n        }\\n        sort(nums.begin(),nums.end());\\n        int index=n-1;\\n        int ans=0;\\n        sort(worker.begin(),worker.end());\\n        \\n        for(int i=worker.size()-1;i>=0;i--){\\n            while(index>=0 && nums[index].second>worker[i]) index--;\\n            if(index==-1) continue;\\n            ans+=nums[index].first;\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3242537,
                "title": "for-rust-geeks",
                "content": "# Complexity\\n- Time complexity: $$O(nlog(n) + mlog(m))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m + n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn max_profit_assignment(difficulty: Vec<i32>, profit: Vec<i32>, mut worker: Vec<i32>) -> i32 {\\n        let (n, m) = (profit.len(), worker.len());\\n        worker.sort_unstable();\\n\\n        let mut pos = (0..n).collect::<Vec<usize>>();\\n        pos.sort_unstable_by(|&a, &b| difficulty[a].cmp(&difficulty[b]));\\n\\n        let (mut i, mut j) = (0, 0);\\n        let mut ans = 0;\\n        let mut max = 0;\\n\\n        while j < m {\\n            while i < n && difficulty[pos[i]] <= worker[j] {\\n                max = i32::max(max, profit[pos[i]]);\\n                i += 1;\\n            }\\n\\n            ans += max;\\n            j += 1;\\n        }\\n\\n        ans   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn max_profit_assignment(difficulty: Vec<i32>, profit: Vec<i32>, mut worker: Vec<i32>) -> i32 {\\n        let (n, m) = (profit.len(), worker.len());\\n        worker.sort_unstable();\\n\\n        let mut pos = (0..n).collect::<Vec<usize>>();\\n        pos.sort_unstable_by(|&a, &b| difficulty[a].cmp(&difficulty[b]));\\n\\n        let (mut i, mut j) = (0, 0);\\n        let mut ans = 0;\\n        let mut max = 0;\\n\\n        while j < m {\\n            while i < n && difficulty[pos[i]] <= worker[j] {\\n                max = i32::max(max, profit[pos[i]]);\\n                i += 1;\\n            }\\n\\n            ans += max;\\n            j += 1;\\n        }\\n\\n        ans   \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3141689,
                "title": "beats-100-java-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n       int[] dp = new int[100001];\\n        for (int i = 0; i < difficulty.length; i++) {\\n            dp[difficulty[i]] = Math.max(dp[difficulty[i]], profit[i]);\\n        }\\n        for (int i = 0; i < dp.length; i++) {\\n            if (i > 0) {\\n                dp[i] = Math.max(dp[i - 1], dp[i]);\\n            }\\n        }\\n        int sum = 0;\\n        for (int i : worker) {\\n            sum += dp[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n       int[] dp = new int[100001];\\n        for (int i = 0; i < difficulty.length; i++) {\\n            dp[difficulty[i]] = Math.max(dp[difficulty[i]], profit[i]);\\n        }\\n        for (int i = 0; i < dp.length; i++) {\\n            if (i > 0) {\\n                dp[i] = Math.max(dp[i - 1], dp[i]);\\n            }\\n        }\\n        int sum = 0;\\n        for (int i : worker) {\\n            sum += dp[i];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085557,
                "title": "simple-solution-using-heap",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        priority_queue<vector<int>>p;\\n        priority_queue<int>q(worker.begin(),worker.end());\\n\\n        for(int i=0;i<profit.size();i++){\\n            p.push({profit[i],difficulty[i]});\\n        }\\n        int val=0;\\n        while(!p.empty() && !q.empty()){\\n            if(p.top()[1]>q.top())p.pop();\\n            else{\\n                val+=p.top()[0];\\n                q.pop();\\n            }\\n        }\\n        return val;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        priority_queue<vector<int>>p;\\n        priority_queue<int>q(worker.begin(),worker.end());\\n\\n        for(int i=0;i<profit.size();i++){\\n            p.push({profit[i],difficulty[i]});\\n        }\\n        int val=0;\\n        while(!p.empty() && !q.empty()){\\n            if(p.top()[1]>q.top())p.pop();\\n            else{\\n                val+=p.top()[0];\\n                q.pop();\\n            }\\n        }\\n        return val;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2857961,
                "title": "python-sorting-bisect",
                "content": "# Intuition\\nThe main idea is to get maximum profit for current worker ability.\\nFirst of all we need to mix together difficulty and profit, sort them and initialize dp variable with maximum value with at least current difficulty. \\n\\n# Complexity\\n- Time complexity:\\nO(N*LogN) for sorting and bisect\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nimport bisect\\n\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        difficultyProfit = list(zip(difficulty, profit))\\n        difficultyProfit.sort()\\n\\n        difficulty, profit = zip(*difficultyProfit)\\n\\n        n = len(profit)\\n        dp = [0] * n\\n        for i in range(n):\\n            dp[i] = max(profit[i], dp[i - 1])\\n\\n        result = 0\\n        for w in worker:\\n            index = bisect.bisect_right(difficulty, w) - 1\\n            if index < 0:\\n                continue\\n            \\n            result += dp[index]\\n        \\n        return result\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport bisect\\n\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        difficultyProfit = list(zip(difficulty, profit))\\n        difficultyProfit.sort()\\n\\n        difficulty, profit = zip(*difficultyProfit)\\n\\n        n = len(profit)\\n        dp = [0] * n\\n        for i in range(n):\\n            dp[i] = max(profit[i], dp[i - 1])\\n\\n        result = 0\\n        for w in worker:\\n            index = bisect.bisect_right(difficulty, w) - 1\\n            if index < 0:\\n                continue\\n            \\n            result += dp[index]\\n        \\n        return result\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1397464,
                "title": "o-nlogn-lower-bound-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker){\\n        unordered_map<int,int>mp;  \\n        int m=0,ans=0;\\n        vector<vector<int>>v;\\n        \\n        for(int i=0;i<difficulty.size();i++)\\n            v.push_back({difficulty[i],profit[i]});\\n        \\n        sort(v.begin(),v.end());\\n        \\n        for(int i=0;i<difficulty.size();i++)\\n            mp[v[i][0]]=m=max(m,v[i][1]);\\n        \\n        sort(difficulty.begin(),difficulty.end());\\n        \\n        for(int a:worker){\\n            int j=lower_bound(difficulty.begin(),difficulty.end(),a)-difficulty.begin();\\n            \\n            if(difficulty[j]>a || j==difficulty.size())\\n                j--;\\n            if(j>=0)\\n                ans+=mp[difficulty[j]];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker){\\n        unordered_map<int,int>mp;  \\n        int m=0,ans=0;\\n        vector<vector<int>>v;\\n        \\n        for(int i=0;i<difficulty.size();i++)\\n            v.push_back({difficulty[i],profit[i]});\\n        \\n        sort(v.begin(),v.end());\\n        \\n        for(int i=0;i<difficulty.size();i++)\\n            mp[v[i][0]]=m=max(m,v[i][1]);\\n        \\n        sort(difficulty.begin(),difficulty.end());\\n        \\n        for(int a:worker){\\n            int j=lower_bound(difficulty.begin(),difficulty.end(),a)-difficulty.begin();\\n            \\n            if(difficulty[j]>a || j==difficulty.size())\\n                j--;\\n            if(j>=0)\\n                ans+=mp[difficulty[j]];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1168333,
                "title": "java-sol-beats-100-submission",
                "content": "``` \\npublic int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        \\n        int max1 = 0, max2 = 0, maxDp = 0;\\n        int maxProfit = 0;\\n        for (int i = 0 ; i < worker.length ; i++) {\\n           max1 = Math.max(worker[i], max1); \\n        }\\n        \\n        for (int j = 0 ; j < difficulty.length ; j++) {\\n           max2 = Math.max(difficulty[j], max2); \\n        }\\n        \\n        maxDp = Math.max(max1 + 1, max2 +1) ;\\n        \\n        int[] dp = new int[maxDp];\\n        \\n        for (int i = 0 ; i < difficulty.length ; i++) {\\n            dp[difficulty[i]] = Math.max(dp[difficulty[i]], profit[i]);\\n        }\\n        \\n        for (int i = 1 ; i < dp.length ; i++) {\\n            dp[i] = Math.max(dp[i], dp[i-1]);\\n        }\\n        \\n        for (int work: worker) {\\n            maxProfit += dp[work];\\n        }\\n        \\n        return maxProfit;\\n    }",
                "solutionTags": [],
                "code": "``` \\npublic int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        \\n        int max1 = 0, max2 = 0, maxDp = 0;\\n        int maxProfit = 0;\\n        for (int i = 0 ; i < worker.length ; i++) {\\n           max1 = Math.max(worker[i], max1); \\n        }\\n        \\n        for (int j = 0 ; j < difficulty.length ; j++) {\\n           max2 = Math.max(difficulty[j], max2); \\n        }\\n        \\n        maxDp = Math.max(max1 + 1, max2 +1) ;\\n        \\n        int[] dp = new int[maxDp];\\n        \\n        for (int i = 0 ; i < difficulty.length ; i++) {\\n            dp[difficulty[i]] = Math.max(dp[difficulty[i]], profit[i]);\\n        }\\n        \\n        for (int i = 1 ; i < dp.length ; i++) {\\n            dp[i] = Math.max(dp[i], dp[i-1]);\\n        }\\n        \\n        for (int work: worker) {\\n            maxProfit += dp[work];\\n        }\\n        \\n        return maxProfit;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1156464,
                "title": "c-faster-than-94-clear-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int,int>> vc;\\n        for(int i = 0; i < difficulty.size(); i++) vc.push_back(make_pair(difficulty[i], profit[i]));   \\n        sort(vc.begin(), vc.end());\\n        for(int i = 1; i < vc.size(); i++) vc[i].second=max(vc[i].second, vc[i-1].second);\\n         \\n        sort(worker.begin(), worker.end());\\n        int  x = 0, ans=0;\\n        for(int i = 0; i < worker.size(); i++){\\n            while(vc[x].first<=worker[i] && vc.size()>x){\\n                x++;\\n            }\\n            ans+=x==0?0:vc[x-1].second;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int,int>> vc;\\n        for(int i = 0; i < difficulty.size(); i++) vc.push_back(make_pair(difficulty[i], profit[i]));   \\n        sort(vc.begin(), vc.end());\\n        for(int i = 1; i < vc.size(); i++) vc[i].second=max(vc[i].second, vc[i-1].second);\\n         \\n        sort(worker.begin(), worker.end());\\n        int  x = 0, ans=0;\\n        for(int i = 0; i < worker.size(); i++){\\n            while(vc[x].first<=worker[i] && vc.size()>x){\\n                x++;\\n            }\\n            ans+=x==0?0:vc[x-1].second;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 769072,
                "title": "python3-solution-using-dp-o-max-n-max-difficulty",
                "content": "```\\n# Written with love by atm1504\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        n=len(profit)\\n        maxm=max(difficulty)\\n        dp=[0]*(1+maxm)\\n        for i in range(n):\\n            dp[difficulty[i]]=max(dp[difficulty[i]],profit[i])\\n        for i in range(1,maxm+1):\\n            dp[i]=max(dp[i],dp[i-1])\\n        res=0\\n\\n        for x in worker:\\n            if x>maxm:\\n                res+=dp[maxm]\\n            else:\\n                res+=dp[x]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n# Written with love by atm1504\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        n=len(profit)\\n        maxm=max(difficulty)\\n        dp=[0]*(1+maxm)\\n        for i in range(n):\\n            dp[difficulty[i]]=max(dp[difficulty[i]],profit[i])\\n        for i in range(1,maxm+1):\\n            dp[i]=max(dp[i],dp[i-1])\\n        res=0\\n\\n        for x in worker:\\n            if x>maxm:\\n                res+=dp[maxm]\\n            else:\\n                res+=dp[x]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 227554,
                "title": "js-solution-beats-100-with-156-ms-where-existing-solution-takes-at-least-1088ms",
                "content": "```js\\n/**\\n * @param {number[]} difficulty\\n * @param {number[]} profit\\n * @param {number[]} worker\\n * @return {number}\\n */\\nvar maxProfitAssignment = function(difficulty, profit, worker) {\\n    const meta = profit.map((p, i) => ({ profit: p, difficulty: difficulty[i] })).sort((m1, m2) => m2.profit - m1.profit);\\n    const sortedWorker = worker.slice().sort((a, b) => b - a);\\n    let result = 0;\\n    let j = 0;\\n    for (let i = 0; i < meta.length; i++) {\\n        while (sortedWorker[j] >= meta[i].difficulty) {\\n            result += meta[i].profit;\\n            j++;\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\n/**\\n * @param {number[]} difficulty\\n * @param {number[]} profit\\n * @param {number[]} worker\\n * @return {number}\\n */\\nvar maxProfitAssignment = function(difficulty, profit, worker) {\\n    const meta = profit.map((p, i) => ({ profit: p, difficulty: difficulty[i] })).sort((m1, m2) => m2.profit - m1.profit);\\n    const sortedWorker = worker.slice().sort((a, b) => b - a);\\n    let result = 0;\\n    let j = 0;\\n    for (let i = 0; i < meta.length; i++) {\\n        while (sortedWorker[j] >= meta[i].difficulty) {\\n            result += meta[i].profit;\\n            j++;\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3659167,
                "title": "c-easy-to-understand-solution",
                "content": "# Intuition\\nThe workers have to perform the task with the maximum profit under the given difficulty. So 2 cases arise:- either difficulty of the task is greater than the worker\\'s ability or it is less than or equal to worker\\'s ability.The worker should always perform the most profitable task under the given difficulty range.\\n# Approach\\nFirst the worker\\'s ability is sorted in ascending order.The `difficulty` and `profit` arrays are directly related and difficulty should be in an ascending order. So a pair is formed and the maximum profit that could be achieved upto that difficulty level is calculated.Now iteration is performed using 2 pointers. If the `worker` array\\'s pointer reaches end first, it means all workers have been traversed. Otherwise some workers remain for whom maximum profitable task was being searched. But now we have to assign all of them the maximum profitable task we have obtained so far. In the end we return the result. \\n\\n# Complexity\\n- Time complexity:\\nO(M+N) `N`:- size of difficulty array, `M` :- size of worker array\\n- Space complexity:\\nO(M+N) \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int profits = 0;\\n        int n = difficulty.size();\\n        int m = worker.size();\\n        sort(worker.begin(),worker.end());\\n        vector<pair<int,int>> v;\\n        for(int i = 0; i < n; i++){\\n            v.push_back({difficulty[i],profit[i]});\\n        }\\n        sort(v.begin(),v.end());\\n        int maxm = INT_MIN,prev = 0;\\n        auto it = v.begin();\\n        int j = 0;\\n        while(it != v.end() && j < m){\\n            maxm = max(maxm,it->second);\\n            if(it->first <= worker[j]){\\n                it++;\\n                prev = maxm;\\n            }\\n            else{\\n                profits+=prev;\\n                j++;\\n            }\\n        }\\n        while(j != m){\\n            profits+= prev;\\n            j++;\\n        }\\n        return profits;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int profits = 0;\\n        int n = difficulty.size();\\n        int m = worker.size();\\n        sort(worker.begin(),worker.end());\\n        vector<pair<int,int>> v;\\n        for(int i = 0; i < n; i++){\\n            v.push_back({difficulty[i],profit[i]});\\n        }\\n        sort(v.begin(),v.end());\\n        int maxm = INT_MIN,prev = 0;\\n        auto it = v.begin();\\n        int j = 0;\\n        while(it != v.end() && j < m){\\n            maxm = max(maxm,it->second);\\n            if(it->first <= worker[j]){\\n                it++;\\n                prev = maxm;\\n            }\\n            else{\\n                profits+=prev;\\n                j++;\\n            }\\n        }\\n        while(j != m){\\n            profits+= prev;\\n            j++;\\n        }\\n        return profits;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3551451,
                "title": "all-kind-of-solution-with-explanation",
                "content": "### All These Solutions except the very last one are inspired by @lee215 and @votrubac\\n## Solution 1\\n```\\n1.Create a vector where each element is a pair comprised difficulty[i] and profit[i] for each i.\\n2.Sort it and it will be sorted by difficulty[i] by default.\\n3.Also sort the \\'worker\\', now for each worker[i] traverse \\'jobs\\' till jobs[j].first <= worker[i].\\n   We don\\'t need to traverse \\'j always from the beginning as \\n   \"one job can be completed multiple times\" means \\n   \\n   10 20 10 5   - profit     \\n   4  5  7  9   - difficulty \\n   2  4  8  10  - worker\\n\\n   for worker[2] = 8, I can do difficulty : 4,5,7 but 5 pay me highest(20) so I\\'ll take 5\\n   because I can do any job which difficulty level <= my difficulty level.\\n   So using max() we can easily find high paid level as we have \"sorted jobs\". \\n   \\n   Of course in pair difficult[i] is the first one cause we need to compare worker[i] with \\n   difficulty[i] and both denotes \\'difficulty level\\'.\\n```\\n\\n```CPP []\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int,int>> jobs;\\n        for(int i=0; i<difficulty.size(); i++)\\n            jobs.push_back({difficulty[i],profit[i]});\\n\\n        sort(begin(jobs),end(jobs));\\n        sort(begin(worker),end(worker));\\n\\n        int j = 0, best = 0, sum = 0;\\n        for(int & it : worker)\\n        {\\n            while(j<jobs.size() && jobs[j].first<=it)\\n                best = max(best, jobs[j].second), j++;\\n            sum += best;\\n        }\\n        return sum;\\n    }\\n};\\n```\\n```Python []\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        jobs = sorted(zip(difficulty, profit))\\n        j = best = ans = 0\\n        for ability in sorted(worker):\\n            while j < len(jobs) and jobs[j][0] <= ability:\\n                best = max(best, jobs[j][1])\\n                j += 1\\n            ans += best\\n        \\n        return ans\\n```\\n```\\nTime complexity  : O(nlogn)\\nSpace complexity : O(n)\\n```\\n## Solution 2 :\\n```\\nmax(m[difficulty[i]], profit[i]) had done because there can be duplicate in \\'difficulty\\'.\\n\\nDifficulty      Profit                                     Profit\\n----------     --------         ___________               --------\\n    4             20           |            |                20\\n    6             10    ---->  |    Second  |  ----->        20\\n    8             30           |    For     |                30\\n    10            20           |    Loop    |                30\\n\\nreturn accumulate(begin(worker), end(worker), 0, [m](int sum, int value)...\\n                                              |\\n              sum = -------------------------\\n              and value = each value in worker\\n          \\n              1 2 4 5 8 9\\n              upper_bound(5) = 8 \\n              lower_bound(5) = 5 but\\n              1 2 4 8 9\\n              lower_bound(5) = 8. Upper_bound = 1 variation where lower_bound = 2 variation.\\nThat\\'s why upper_bound chosen. prev(upper_bound(iterator)) is the iterator we need here always.\\n```\\n```CPP []\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) \\n    {\\n        map<int, int> m;\\n        for(int i=0; i<difficulty.size(); i++)\\n            m[difficulty[i]] = max(m[difficulty[i]], profit[i]);\\n        \\n        for(auto it = next(m.begin()); it!= m.end(); it++)\\n            it->second = max(prev(it)->second, it->second);\\n        \\n        return accumulate(begin(worker), end(worker), 0, [m](int sum, int value){ return sum + prev(m.upper_bound(value))->second; });\\n    }\\n};\\n```\\n```\\nTime  Complexity : O(nlogn) as we took map.\\nSpace Complexity : O(n)\\n```\\n## Solution 3 :\\n```\\nHere difficulty[i] = index and profit[i] = value of the \" counting sort \\'jobs\\' \"\\n\\ndifficulty = [2,4,6,8,10], profit = [20,10,15,40,30], worker = [4,5,6,7]\\n\\n0  0  20  0   10  0   15  0   40  0   50 ............. (profit)\\n0  1  2   3   4   5   6   7   8   9   10 ............. (difficulty)\\n                  \\n                    * After the second for loop *\\n                     \\n0  0  20  20  20  20  20  20  40  40  40 ............. (profit)\\n0  1  2   3   4   5   6   7   8   9   10 ............. (difficulty)\\n\\nIn the map solution when we \"accumulate\"d for each worker[i] say for 5 we had to go for \\nprev(upper_bound) = prev(5) =  4 here, but here in counting sort we have 5 to access directly, \\n\\n                          \\'   20 (profit)\\n                            5  (difficulty)   \\'\\n\\nwe don\\'t need any upper bound or traversing the array to get the value. So this solution is fast.\\n```\\n```CPP []\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) \\n    {\\n        int jobs[100001] = {0};\\n        for(int i=0; i<difficulty.size(); i++)\\n                jobs[difficulty[i]] = max(jobs[difficulty[i]], profit[i]);\\n\\n        for(int i=1; i<100001; i++)\\n            jobs[i] = max(jobs[i], jobs[i-1]);\\n\\n        return accumulate(begin(worker), end(worker), 0, [jobs](int s, int v){ return s + jobs[v]; });\\n    }\\n};\\n```\\n```\\nYou can also optimize it by below. We only need the maximum element of \\'worker\\'.\\n                2 4 6 8 9 10 (difficulty)\\n                2 3 5 7      (worker)\\nas we need till \\'7\\', so we don\\'t care values > 7 in \\'difficulty\\'. \\nMake sure the value in \\'difficulty\\' is <= the maximum in \\'worker\\'.\\n```\\n```CPP []\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) \\n    {\\n        int m = *max_element(begin(worker), end(worker)) + 1;\\n        vector<int> jobs(m, 0);\\n        for(int i=0; i<difficulty.size(); i++)\\n            if(difficulty[i] < m)\\n                jobs[difficulty[i]] = max(jobs[difficulty[i]], profit[i]);\\n\\n        for(int i=1; i<m ;i++)\\n            jobs[i] = max(jobs[i], jobs[i-1]);\\n\\n        return accumulate(begin(worker), end(worker), 0, [jobs](int s, int v){ return s + jobs[v]; });\\n    }\\n};\\n```\\n```\\nTime  Complexity : O(n + m)\\nSpace Complexity : O(m)\\n```\\n## If the post was helpful an upvote will really make me happy:)",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```\\n1.Create a vector where each element is a pair comprised difficulty[i] and profit[i] for each i.\\n2.Sort it and it will be sorted by difficulty[i] by default.\\n3.Also sort the \\'worker\\', now for each worker[i] traverse \\'jobs\\' till jobs[j].first <= worker[i].\\n   We don\\'t need to traverse \\'j always from the beginning as \\n   \"one job can be completed multiple times\" means \\n   \\n   10 20 10 5   - profit     \\n   4  5  7  9   - difficulty \\n   2  4  8  10  - worker\\n\\n   for worker[2] = 8, I can do difficulty : 4,5,7 but 5 pay me highest(20) so I\\'ll take 5\\n   because I can do any job which difficulty level <= my difficulty level.\\n   So using max() we can easily find high paid level as we have \"sorted jobs\". \\n   \\n   Of course in pair difficult[i] is the first one cause we need to compare worker[i] with \\n   difficulty[i] and both denotes \\'difficulty level\\'.\\n```\n```CPP []\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int,int>> jobs;\\n        for(int i=0; i<difficulty.size(); i++)\\n            jobs.push_back({difficulty[i],profit[i]});\\n\\n        sort(begin(jobs),end(jobs));\\n        sort(begin(worker),end(worker));\\n\\n        int j = 0, best = 0, sum = 0;\\n        for(int & it : worker)\\n        {\\n            while(j<jobs.size() && jobs[j].first<=it)\\n                best = max(best, jobs[j].second), j++;\\n            sum += best;\\n        }\\n        return sum;\\n    }\\n};\\n```\n```Python []\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        jobs = sorted(zip(difficulty, profit))\\n        j = best = ans = 0\\n        for ability in sorted(worker):\\n            while j < len(jobs) and jobs[j][0] <= ability:\\n                best = max(best, jobs[j][1])\\n                j += 1\\n            ans += best\\n        \\n        return ans\\n```\n```\\nTime complexity  : O(nlogn)\\nSpace complexity : O(n)\\n```\n```\\nmax(m[difficulty[i]], profit[i]) had done because there can be duplicate in \\'difficulty\\'.\\n\\nDifficulty      Profit                                     Profit\\n----------     --------         ___________               --------\\n    4             20           |            |                20\\n    6             10    ---->  |    Second  |  ----->        20\\n    8             30           |    For     |                30\\n    10            20           |    Loop    |                30\\n\\nreturn accumulate(begin(worker), end(worker), 0, [m](int sum, int value)...\\n                                              |\\n              sum = -------------------------\\n              and value = each value in worker\\n          \\n              1 2 4 5 8 9\\n              upper_bound(5) = 8 \\n              lower_bound(5) = 5 but\\n              1 2 4 8 9\\n              lower_bound(5) = 8. Upper_bound = 1 variation where lower_bound = 2 variation.\\nThat\\'s why upper_bound chosen. prev(upper_bound(iterator)) is the iterator we need here always.\\n```\n```CPP []\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) \\n    {\\n        map<int, int> m;\\n        for(int i=0; i<difficulty.size(); i++)\\n            m[difficulty[i]] = max(m[difficulty[i]], profit[i]);\\n        \\n        for(auto it = next(m.begin()); it!= m.end(); it++)\\n            it->second = max(prev(it)->second, it->second);\\n        \\n        return accumulate(begin(worker), end(worker), 0, [m](int sum, int value){ return sum + prev(m.upper_bound(value))->second; });\\n    }\\n};\\n```\n```\\nTime  Complexity : O(nlogn) as we took map.\\nSpace Complexity : O(n)\\n```\n```\\nHere difficulty[i] = index and profit[i] = value of the \" counting sort \\'jobs\\' \"\\n\\ndifficulty = [2,4,6,8,10], profit = [20,10,15,40,30], worker = [4,5,6,7]\\n\\n0  0  20  0   10  0   15  0   40  0   50 ............. (profit)\\n0  1  2   3   4   5   6   7   8   9   10 ............. (difficulty)\\n                  \\n                    * After the second for loop *\\n                     \\n0  0  20  20  20  20  20  20  40  40  40 ............. (profit)\\n0  1  2   3   4   5   6   7   8   9   10 ............. (difficulty)\\n\\nIn the map solution when we \"accumulate\"d for each worker[i] say for 5 we had to go for \\nprev(upper_bound) = prev(5) =  4 here, but here in counting sort we have 5 to access directly, \\n\\n                          \\'   20 (profit)\\n                            5  (difficulty)   \\'\\n\\nwe don\\'t need any upper bound or traversing the array to get the value. So this solution is fast.\\n```\n```CPP []\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) \\n    {\\n        int jobs[100001] = {0};\\n        for(int i=0; i<difficulty.size(); i++)\\n                jobs[difficulty[i]] = max(jobs[difficulty[i]], profit[i]);\\n\\n        for(int i=1; i<100001; i++)\\n            jobs[i] = max(jobs[i], jobs[i-1]);\\n\\n        return accumulate(begin(worker), end(worker), 0, [jobs](int s, int v){ return s + jobs[v]; });\\n    }\\n};\\n```\n```\\nYou can also optimize it by below. We only need the maximum element of \\'worker\\'.\\n                2 4 6 8 9 10 (difficulty)\\n                2 3 5 7      (worker)\\nas we need till \\'7\\', so we don\\'t care values > 7 in \\'difficulty\\'. \\nMake sure the value in \\'difficulty\\' is <= the maximum in \\'worker\\'.\\n```\n```CPP []\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) \\n    {\\n        int m = *max_element(begin(worker), end(worker)) + 1;\\n        vector<int> jobs(m, 0);\\n        for(int i=0; i<difficulty.size(); i++)\\n            if(difficulty[i] < m)\\n                jobs[difficulty[i]] = max(jobs[difficulty[i]], profit[i]);\\n\\n        for(int i=1; i<m ;i++)\\n            jobs[i] = max(jobs[i], jobs[i-1]);\\n\\n        return accumulate(begin(worker), end(worker), 0, [jobs](int s, int v){ return s + jobs[v]; });\\n    }\\n};\\n```\n```\\nTime  Complexity : O(n + m)\\nSpace Complexity : O(m)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372099,
                "title": "simple-priority-queue-east-to-understand-and-intuitive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf we want to maximize the profit then we will try to assign the work having maximum profit to maximum workers.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We use a priority queue to store the profits alongwith the difficulty level corresponding to the profit.\\n2. Now we sort the worker array, so that we can start traversing from larget element i.e worker having the greatest ability.\\n3. We keep popping from the heap if the difficulty level of the job is greater than the ability of the worker.\\n\\n# Complexity\\n- Time complexity:\\nO(NlogN)\\n\\n- Space complexity:\\nO(N) \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        priority_queue<pair<int,int>> pq;\\n        \\n        for(int i=0;i<profit.size();i++){\\n            pq.push({profit[i],difficulty[i]});\\n        }\\n        sort(worker.begin(),worker.end());\\n        int i=worker.size()-1;\\n        int ans=0;\\n        while(i>=0 && !pq.empty()){\\n             if(worker[i]>=pq.top().second){\\n                    ans+=pq.top().first;\\n                    i--;\\n             } \\n             else{\\n                 pq.pop();\\n             }  \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        priority_queue<pair<int,int>> pq;\\n        \\n        for(int i=0;i<profit.size();i++){\\n            pq.push({profit[i],difficulty[i]});\\n        }\\n        sort(worker.begin(),worker.end());\\n        int i=worker.size()-1;\\n        int ans=0;\\n        while(i>=0 && !pq.empty()){\\n             if(worker[i]>=pq.top().second){\\n                    ans+=pq.top().first;\\n                    i--;\\n             } \\n             else{\\n                 pq.pop();\\n             }  \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3054184,
                "title": "c-fastest-priority-queue",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        priority_queue<pair<int, int>> pq;\\n        for(int i = 0; i < profit.size(); i++){\\n            pq.push({profit[i], difficulty[i]});\\n        }\\n        int ans = 0;\\n        sort(worker.begin(), worker.end());\\n        int i = worker.size()-1;\\n        while(!pq.empty() && i >= 0){\\n            pair<int, int> p = pq.top();\\n            if(worker[i] >= p.second){\\n                ans += p.first;\\n                i--;\\n            }\\n            else pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        priority_queue<pair<int, int>> pq;\\n        for(int i = 0; i < profit.size(); i++){\\n            pq.push({profit[i], difficulty[i]});\\n        }\\n        int ans = 0;\\n        sort(worker.begin(), worker.end());\\n        int i = worker.size()-1;\\n        while(!pq.empty() && i >= 0){\\n            pair<int, int> p = pq.top();\\n            if(worker[i] >= p.second){\\n                ans += p.first;\\n                i--;\\n            }\\n            else pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2917295,
                "title": "sort-binary-search-prefix-array-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int n = profit.size(), ans = 0, mx = INT_MIN;\\n        vector<pair<int, int>> v;\\n        for(int i=0; i<n; i++) v.push_back({difficulty[i], profit[i]});\\n        sort(v.begin(), v.end());\\n        \\n        vector<int> pre;\\n        for(auto i : v) pre.push_back(mx = max(i.second, mx));\\n\\n        for(int w : worker) {\\n            int s = 0, e = n - 1, val = 0;\\n            while(s <= e) {\\n                int m = (s + e) / 2;\\n                if(v[m].first <= w) val = max(val, pre[m]), s = m + 1;\\n                else e = m - 1;\\n            }\\n            ans += val;\\n        }\\n        return ans;\\n    }\\n};\\n/*\\n((2, 10), (4, 20), (6, 30), (8, 40), (10, 50))\\n10       20        30        40       50\\n\\n20 + 20 + 30 + 30 = 100\\n*/\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Greedy",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int n = profit.size(), ans = 0, mx = INT_MIN;\\n        vector<pair<int, int>> v;\\n        for(int i=0; i<n; i++) v.push_back({difficulty[i], profit[i]});\\n        sort(v.begin(), v.end());\\n        \\n        vector<int> pre;\\n        for(auto i : v) pre.push_back(mx = max(i.second, mx));\\n\\n        for(int w : worker) {\\n            int s = 0, e = n - 1, val = 0;\\n            while(s <= e) {\\n                int m = (s + e) / 2;\\n                if(v[m].first <= w) val = max(val, pre[m]), s = m + 1;\\n                else e = m - 1;\\n            }\\n            ans += val;\\n        }\\n        return ans;\\n    }\\n};\\n/*\\n((2, 10), (4, 20), (6, 30), (8, 40), (10, 50))\\n10       20        30        40       50\\n\\n20 + 20 + 30 + 30 = 100\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2762294,
                "title": "python-o-n-2-o-nlogn-explained",
                "content": "## **1. BRUTE FORCE - O(N^2)**\\n\\nIn the Brute Force approach, for every worker, we go through every difficulty and if the worker can do that job, we check if it can give him a profit greater than previous job. If yes, update the maximum profit for that worker.\\n\\nIn the end, we add this maximum profit to the final output that we have to return.\\n\\nThe issue is that the arrays can be of up to 10^4 length. So, an O(N^2) solution will fail for large inputs and will show TLE.\\n\\nBut from this solution, we can start thinking about the Optimized Approach.\\n\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        \\n        maxProfit = 0\\n        \\n        m = len(worker)\\n        n = len(difficulty)\\n        \\n        # For every worker, find the maximum profit that he can get (if possible)\\n        for j in range (m):\\n            maxWorkerProfit = 0\\n            # Go through each job difficulty\\n            for i in range(n):\\n                # And if we find a difficulty <= ability of worker\\n                # Then we need to update the profit \\n                # if this job gives a higher profit than previous job\\n                if difficulty[i] <= worker[j]:\\n                    maxWorkerProfit = max(maxWorkerProfit, profit[i])\\n            \\n            # And when we found the maximum profit for this worker, just add it to the output that we need to return\\n            maxProfit += maxWorkerProfit\\n        \\n        \\n        return maxProfit\\n\\t\\t\\n## **2. BINARY SEARCH APPROACH - O(NLogN)**\\n\\nThe reason of O(N^2) complexity in Brute Force approach is that inner loop. For every worker, we have to iterate from the beginning to the end to find the maximum profit. \\n\\n\\tBut what if the difficulties were in sorted order already?\\n\\nIn that case, if a worker is able to do any job with difficulty[i], then we can say that he can also do any job that has a lower difficulty right? In other words, in that case, we don\\'t worry about the difficulties on left side as they will all be valid as the array is sorted. And that\\'s the idea of Binary Search. \\n\\nSo using Binary Search, all we have to do is find the rightmost valid difficulty out of the sorted difficulty list. Once we can find that, then all we need to find is what is the maximum profit that we can get in the [0, rightmost valid difficulty index] range. And to avoid calculating this for every worker, we can precomute this before we even apply Binary Search. \\n\\nBut there is one issue with this approach and I was stuck at this for almost half an hour before I realised that I made a dumb mistake.\\n\\nNotice that \"difficulty\" and \"profit\" are in sync. That means, ith difficulty has profit[i] profit. So if we only sort difficulty list, the profit list remains unchanged and that will not give us correct result. We cannot sort these two lists separately as well. Because profit of a job with a higher difficulty might be less than profit of a job with lower difficulty. So sorting them separately will also give wrong results.\\n\\nAnd so, we want a way such that when we sort the \"difficulty\" list, the \"profit\" list is still in sync. And for that, we can make a new list in which at every index, we have a pair of (difficulty, profit). So now, even if we sort this new list based on difficulty value, the profit value will always stay with its correct corresponding difficulty, just as it was initially in the input lists.\\n\\n*You will find a lot of questions that have a similar pattern and they might differ in only the way we precompute max value. For some problems, you have to find maximum on right side whereas for some you have to find maximum on left side of each index. That depends on the problem statement. For example here, we know that if one difficulty is valid, all difficulties less than it are also valid. Hence we precomputed the maximum value on left side of each index.*\\n\\n```\\ndef maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        \\n        maxProfit = 0\\n        \\n        m = len(worker)\\n        n = len(difficulty)\\n        \\n        # We cannot just sort difficulty array\\n        # We also need to make sure profit array is in same order as difficulty array\\n        # So what we can do is at each index, we can keep what is the difficulty of a job and what is its profit\\n        jobs = []\\n        for i in range(n): jobs.append((difficulty[i], profit[i]))\\n            \\n        # Now we can sort this new list we made and since difficulty is the first value in each tuple\\n        # this list will be sorted based on difficulty\\n        jobs.sort()\\n        \\n        # Precompute maximum profit on left for each index\\n        maxProfitSoFar = [0] * n\\n        \\n        # For first index, maximum profit on left will be profit at its index only\\n        maxProfitSoFar[0] = jobs[0][1]\\n        for i in range(1, n): maxProfitSoFar[i] = max(maxProfitSoFar[i - 1], jobs[i][1])           \\n\\n        # For every worker, find the maximum profit that he can get (if possible)\\n        for j in range(m):\\n            maxWorkerProfit = 0\\n            \\n            # Instead of linear search, we can now apply Binary Search here\\n            # As we have sorted the difficulty\\n            # Since difficulty is sorted, all we want to find is the rightmost valid index in difficulty array\\n            # That is the rightmost index at which difficulty is <= ability of the worker\\n            \\n            start = 0\\n            end = n - 1\\n            rightmostIndex = -1\\n            \\n            \\n            while start <= end:\\n                mid = start + (end - start) // 2\\n                \\n                # If job at mid can be done by worker\\n                # Then this is one possible solution\\n                # But we want rightmost valid difficulty\\n                # So we keep searching on right side of mid\\n                if jobs[mid][0] <= worker[j]:\\n                    rightmostIndex = mid\\n                    start = mid + 1 \\n                # If job at mid cannot be done by the worker\\n                # That means, no job after mid can be done as well\\n                # Since array is now sorted\\n                else: end = mid - 1\\n            \\n            # Now, as we have precomputed maximum profit till each index already\\n            # We can find the maximum profit till rightmostIndex in O(1) time\\n            if rightmostIndex != -1: maxWorkerProfit = maxProfitSoFar[rightmostIndex]\\n                \\n            # And append that to the final output that we need to return\\n            maxProfit += maxWorkerProfit\\n            \\n        \\n        return maxProfit\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\ndef maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        \\n        maxProfit = 0\\n        \\n        m = len(worker)\\n        n = len(difficulty)\\n        \\n        # We cannot just sort difficulty array\\n        # We also need to make sure profit array is in same order as difficulty array\\n        # So what we can do is at each index, we can keep what is the difficulty of a job and what is its profit\\n        jobs = []\\n        for i in range(n): jobs.append((difficulty[i], profit[i]))\\n            \\n        # Now we can sort this new list we made and since difficulty is the first value in each tuple\\n        # this list will be sorted based on difficulty\\n        jobs.sort()\\n        \\n        # Precompute maximum profit on left for each index\\n        maxProfitSoFar = [0] * n\\n        \\n        # For first index, maximum profit on left will be profit at its index only\\n        maxProfitSoFar[0] = jobs[0][1]\\n        for i in range(1, n): maxProfitSoFar[i] = max(maxProfitSoFar[i - 1], jobs[i][1])           \\n\\n        # For every worker, find the maximum profit that he can get (if possible)\\n        for j in range(m):\\n            maxWorkerProfit = 0\\n            \\n            # Instead of linear search, we can now apply Binary Search here\\n            # As we have sorted the difficulty\\n            # Since difficulty is sorted, all we want to find is the rightmost valid index in difficulty array\\n            # That is the rightmost index at which difficulty is <= ability of the worker\\n            \\n            start = 0\\n            end = n - 1\\n            rightmostIndex = -1\\n            \\n            \\n            while start <= end:\\n                mid = start + (end - start) // 2\\n                \\n                # If job at mid can be done by worker\\n                # Then this is one possible solution\\n                # But we want rightmost valid difficulty\\n                # So we keep searching on right side of mid\\n                if jobs[mid][0] <= worker[j]:\\n                    rightmostIndex = mid\\n                    start = mid + 1 \\n                # If job at mid cannot be done by the worker\\n                # That means, no job after mid can be done as well\\n                # Since array is now sorted\\n                else: end = mid - 1\\n            \\n            # Now, as we have precomputed maximum profit till each index already\\n            # We can find the maximum profit till rightmostIndex in O(1) time\\n            if rightmostIndex != -1: maxWorkerProfit = maxProfitSoFar[rightmostIndex]\\n                \\n            # And append that to the final output that we need to return\\n            maxProfit += maxWorkerProfit\\n            \\n        \\n        return maxProfit\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2566859,
                "title": "cpp-easy-two-pointer",
                "content": "class Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker)\\n    {\\n        vector<pair<int,int>> v;\\n        int n=profit.size(),m=worker.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            v.push_back({profit[i],difficulty[i]});\\n        }\\n        sort(v.begin(),v.end());\\n        int ans=0;\\n        \\n        int j=n-1,i=m-1;\\n        while(j>=0 and i>=0)\\n        {\\n            int p=v[j].first;\\n            int d=v[j].second;\\n            int k=j;\\n            while(k>0 and worker[k]<d)\\n            {\\n                k--;\\n                d=v[k].second;\\n            }\\n            if(k>=0 and worker[k]>=d)\\n            {\\n                i--;\\n                ans+=profit[k];\\n            }\\n            else\\n                j--;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker)\\n    {\\n        vector<pair<int,int>> v;\\n        int n=profit.size(),m=worker.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            v.push_back({profit[i],difficulty[i]}",
                "codeTag": "Java"
            },
            {
                "id": 2478003,
                "title": "python-commented-code-greedy",
                "content": "\\tclass Solution:\\n\\t\\tdef maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n\\t\\t\\tjobs=[]\\n\\t\\t\\tfor dif,pro in zip(difficulty, profit):\\n\\t\\t\\t\\tjobs.append([dif,pro])\\n\\t\\t\\tjobs = sorted(jobs, key=lambda x:x[0]) #sort it based on the difficulty level\\n\\t\\t\\tans = i = best = 0\\n\\t\\t\\tfor skill in sorted(worker):\\n\\t\\t\\t\\twhile i < len(jobs) and skill >= jobs[i][0]:\\n\\t\\t\\t\\t\\tbest = max(best, jobs[i][1]) #doing this because even a low difficulty task can have a higher profit than a high difficulty task                                              \\n\\t\\t\\t\\t\\ti += 1\\n\\t\\t\\t\\tans += best\\n\\t\\t\\treturn ans\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n\\t\\t\\tjobs=[]\\n\\t\\t\\tfor dif,pro in zip(difficulty, profit):\\n\\t\\t\\t\\tjobs.append([dif,pro])\\n\\t\\t\\tjobs = sorted(jobs, key=lambda x:x[0]) #sort it based on the difficulty level\\n\\t\\t\\tans = i = best = 0\\n\\t\\t\\tfor skill in sorted(worker):\\n\\t\\t\\t\\twhile i < len(jobs) and skill >= jobs[i][0]:\\n\\t\\t\\t\\t\\tbest = max(best, jobs[i][1]) #doing this because even a low difficulty task can have a higher profit than a high difficulty task                                              \\n\\t\\t\\t\\t\\ti += 1\\n\\t\\t\\t\\tans += best\\n\\t\\t\\treturn ans\\n\\n\\n\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 2444367,
                "title": "my-c-solution-easy-approach-by-using-priority-queue",
                "content": "****Please upvote if you like****\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        priority_queue<pair<int,int>>pq;\\n        int n=profit.size();\\n        for(int i=0;i<n;i++){\\n            pq.push({profit[i],difficulty[i]});\\n        }\\n        int ans=0;\\n        sort(worker.rbegin(),worker.rend());\\n        for(auto u:worker)\\n        {\\n            while(!pq.empty()){\\n                if(pq.top().second>u)\\n                    pq.pop();\\n                else{\\n                    ans+=pq.top().first;\\n                    break;\\n                }\\n            }\\n            if(pq.empty())\\n                break;\\n        }\\n        return ans;\\n       \\n    }\\n};\\n```\\n****If you have any trouble to understand my code then please comment billow I will reply very soon****",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        priority_queue<pair<int,int>>pq;\\n        int n=profit.size();\\n        for(int i=0;i<n;i++){\\n            pq.push({profit[i],difficulty[i]});\\n        }\\n        int ans=0;\\n        sort(worker.rbegin(),worker.rend());\\n        for(auto u:worker)\\n        {\\n            while(!pq.empty()){\\n                if(pq.top().second>u)\\n                    pq.pop();\\n                else{\\n                    ans+=pq.top().first;\\n                    break;\\n                }\\n            }\\n            if(pq.empty())\\n                break;\\n        }\\n        return ans;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2163409,
                "title": "most-profit-assigning-work",
                "content": "# **Brute force gives TLE\\n**\\n\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        \\n        if min(difficulty) > max(worker):\\n            return 0\\n        \\n        max_profit = 0\\n        work_assigned = 0\\n        \\n        for i in range(len(worker)):\\n            max_money = 0\\n            for j in range(len(difficulty)):\\n                if profit[j] >= max_money:\\n                    if worker[i]>=difficulty[j]: \\n                        max_money = max(max_money,profit[j])\\n                        work_assigned = difficulty[j]\\n            max_profit += max_money\\n        return max_profit\\n\\t\\t\\n# \\t\\tTwo pointers\\n\\t\\t\\n\\t\\tclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        \\n        jobs = sorted(zip(difficulty,profit))\\n        n = len(jobs)\\n        \\n        res = i = best = 0\\n        \\n        for ability in sorted(worker):\\n            while i < n and ability >= jobs[i][0]:\\n                best = max(best,jobs[i][1])\\n                i+=1\\n            res+=best\\n        \\n        return res\\n\\t\\t\\n# \\t\\tBinary search and Map\\n\\t\\t\\n\\t\\tclass Solution:\\n    def search_ceil(self,arr,k):\\n        low = 0\\n        high = len(arr) - 1\\n        res = -1                        #binary search\\n\\n        while low <= high:\\n            mid = low + (high - low)//2\\n\\n            if arr[mid] <= k:\\n                res = mid\\n                low = mid+1\\n            else:\\n                high = mid-1\\n        if res != -1:\\n            return arr[res]\\n        else:\\n            return -1\\n        \\n    def make_a_map_as_per_max_profit(self,difficulty, profit):\\n        dp = sorted(zip(difficulty,profit))     #nested list\\n\\n        map = {}\\n\\n        max_p = dp[0][1]\\n        map[dp[0][0]] = dp[0][1]   \\n\\n        for i in range(1,len(dp)):\\n            if dp[i][1] < max_p:\\n                   map[dp[i][0]] = max_p         #hash_map\\n            else:\\n                max_p = max(max_p,dp[i][1])\\n                map[dp[i][0]] = max_p\\n        return map\\n        \\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        \\n        map = self.make_a_map_as_per_max_profit(difficulty, profit)\\n        max_profit = 0\\n        difficulty.sort()\\n        for i in worker:\\n            if self.search_ceil(difficulty,i) > 0:\\n                max_profit += map[self.search_ceil(difficulty,i)]        #calculate prfit\\n        return max_profit\\n\\t\\t",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        \\n        if min(difficulty) > max(worker):\\n            return 0\\n        \\n        max_profit = 0\\n        work_assigned = 0\\n        \\n        for i in range(len(worker)):\\n            max_money = 0\\n            for j in range(len(difficulty)):\\n                if profit[j] >= max_money:\\n                    if worker[i]>=difficulty[j]: \\n                        max_money = max(max_money,profit[j])\\n                        work_assigned = difficulty[j]\\n            max_profit += max_money\\n        return max_profit\\n\\t\\t\\n# \\t\\tTwo pointers\\n\\t\\t\\n\\t\\tclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        \\n        jobs = sorted(zip(difficulty,profit))\\n        n = len(jobs)\\n        \\n        res = i = best = 0\\n        \\n        for ability in sorted(worker):\\n            while i < n and ability >= jobs[i][0]:\\n                best = max(best,jobs[i][1])\\n                i+=1\\n            res+=best\\n        \\n        return res\\n\\t\\t\\n# \\t\\tBinary search and Map\\n\\t\\t\\n\\t\\tclass Solution:\\n    def search_ceil(self,arr,k):\\n        low = 0\\n        high = len(arr) - 1\\n        res = -1                        #binary search\\n\\n        while low <= high:\\n            mid = low + (high - low)//2\\n\\n            if arr[mid] <= k:\\n                res = mid\\n                low = mid+1\\n            else:\\n                high = mid-1\\n        if res != -1:\\n            return arr[res]\\n        else:\\n            return -1\\n        \\n    def make_a_map_as_per_max_profit(self,difficulty, profit):\\n        dp = sorted(zip(difficulty,profit))     #nested list\\n\\n        map = {}",
                "codeTag": "Java"
            },
            {
                "id": 2010143,
                "title": "python3-sort-binary-search-prefix-sum",
                "content": "```\\ndef maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n\\tn = len(difficulty)\\n\\tarr = [(difficulty[i], profit[i]) for i in range(n)]\\n\\tarr.sort()\\n\\tmax_profit = [n[1] for n in arr]\\n\\tcur = 0\\n\\tfor i in range(n):\\n\\t\\tcur = max(max_profit[i], cur)\\n\\t\\tmax_profit[i] = cur\\n\\tprofit = 0\\n\\n\\tfor diff in worker:\\n\\t\\tl, r = 0, n - 1\\n\\t\\twhile l < r:\\n\\t\\t\\tm = (l + r + 1) >> 1\\n\\t\\t\\tif arr[m][0] <= diff:\\n\\t\\t\\t\\tl = m\\n\\t\\t\\telse:\\n\\t\\t\\t\\tr = m - 1\\n\\t\\tprofit += max_profit[l] if arr[l][0] <= diff else 0\\n\\treturn profit\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\ndef maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n\\tn = len(difficulty)\\n\\tarr = [(difficulty[i], profit[i]) for i in range(n)]\\n\\tarr.sort()\\n\\tmax_profit = [n[1] for n in arr]\\n\\tcur = 0\\n\\tfor i in range(n):\\n\\t\\tcur = max(max_profit[i], cur)\\n\\t\\tmax_profit[i] = cur\\n\\tprofit = 0\\n\\n\\tfor diff in worker:\\n\\t\\tl, r = 0, n - 1\\n\\t\\twhile l < r:\\n\\t\\t\\tm = (l + r + 1) >> 1\\n\\t\\t\\tif arr[m][0] <= diff:\\n\\t\\t\\t\\tl = m\\n\\t\\t\\telse:\\n\\t\\t\\t\\tr = m - 1\\n\\t\\tprofit += max_profit[l] if arr[l][0] <= diff else 0\\n\\treturn profit\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1947836,
                "title": "javascript-subproblems-and-preprocessing",
                "content": "Sort the difficulties and workers, then get the maximum profit you can get at that difficulty (which includes any lower difficulties).\\nUse i,j counter to find the maximum difficulty each worker can take on. Since each difficulty is already pre-calculated to be the maximum profit, then just adding the profit should give you the total profit.\\n\\n```\\nvar maxProfitAssignment = function(difficulty, profit, worker) {\\n    const profitD = [];\\n    \\n    // create difficulty and profit array\\n    for (let i = 0; i < difficulty.length; i++) {\\n        profitD.push({d: difficulty[i], p: profit[i]});\\n    }\\n    \\n    // sort on difficulty\\n    profitD.sort((a, b) => a.d - b.d);\\n    // sort worker\\n    worker.sort((a, b) => a - b);\\n    \\n    \\n    // process to the array to get maxProfit So Far\\n    let maxSoFar = -Infinity;\\n    for (let i = 0; i < profitD.length; i++) {\\n        maxSoFar = Math.max(profitD[i].p, maxSoFar);\\n        profitD[i].p = maxSoFar;\\n    }\\n    \\n    \\n    let i = 0;\\n    let j = 0;\\n    let total = 0;\\n    while (i <= profitD.length && j < worker.length) {\\n        // use the last profit and assign it to all the remaining workers\\n        // can do this in another for loop\\n        if (i === profitD.length) {\\n            total += profitD[i - 1].p;\\n            j++;\\n            continue;\\n        }\\n          \\n        const {p, d} = profitD[i];\\n        // increment i if too difficult\\n        if (d <= worker[j]) {\\n            i++;\\n        } else {\\n            if (i - 1 >= 0) {\\n                total += profitD[i - 1].p;\\n            }\\n            j++;\\n        }\\n    }\\n    return total;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nvar maxProfitAssignment = function(difficulty, profit, worker) {\\n    const profitD = [];\\n    \\n    // create difficulty and profit array\\n    for (let i = 0; i < difficulty.length; i++) {\\n        profitD.push({d: difficulty[i], p: profit[i]});\\n    }\\n    \\n    // sort on difficulty\\n    profitD.sort((a, b) => a.d - b.d);\\n    // sort worker\\n    worker.sort((a, b) => a - b);\\n    \\n    \\n    // process to the array to get maxProfit So Far\\n    let maxSoFar = -Infinity;\\n    for (let i = 0; i < profitD.length; i++) {\\n        maxSoFar = Math.max(profitD[i].p, maxSoFar);\\n        profitD[i].p = maxSoFar;\\n    }\\n    \\n    \\n    let i = 0;\\n    let j = 0;\\n    let total = 0;\\n    while (i <= profitD.length && j < worker.length) {\\n        // use the last profit and assign it to all the remaining workers\\n        // can do this in another for loop\\n        if (i === profitD.length) {\\n            total += profitD[i - 1].p;\\n            j++;\\n            continue;\\n        }\\n          \\n        const {p, d} = profitD[i];\\n        // increment i if too difficult\\n        if (d <= worker[j]) {\\n            i++;\\n        } else {\\n            if (i - 1 >= 0) {\\n                total += profitD[i - 1].p;\\n            }\\n            j++;\\n        }\\n    }\\n    return total;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1795402,
                "title": "priorityqueue-treemap",
                "content": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        \\n        PriorityQueue<Job> pq = new PriorityQueue<>((a, b) -> {\\n            \\n            if (a.profit == b.profit) {\\n                return a.difficulty - b.difficulty;\\n            } else {\\n                return b.profit - a.profit;\\n            }\\n        });\\n        \\n        int n = difficulty.length;\\n        for (int i = 0; i < n; i++) {\\n            pq.add(new Job(difficulty[i], profit[i]));\\n        }\\n        \\n        TreeMap<Integer, List<Integer>> treeMap = new TreeMap<>();\\n        for (int i = 0; i < worker.length; i++) {\\n            treeMap.computeIfAbsent(worker[i], v -> new ArrayList<>()).add(i);\\n        }\\n        \\n        int ret = 0;\\n        \\n        Set<Integer> visited = new HashSet<>();\\n        while (!pq.isEmpty() && visited.size() != worker.length) {\\n            \\n            Job cur = pq.poll();\\n            int d = cur.difficulty;\\n            \\n            Map.Entry<Integer, List<Integer>> e = treeMap.ceilingEntry(d);\\n            if (e != null) {\\n                \\n                for (int w : e.getValue()) {\\n                    visited.add(w);\\n                }\\n                \\n                ret += e.getValue().size() * cur.profit;\\n                \\n                treeMap.remove(e.getKey());\\n                pq.add(cur);\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n    \\n    class Job {\\n        \\n        int difficulty;\\n        int profit;\\n        \\n        public Job(int difficulty, int profit) {\\n            this.difficulty = difficulty;\\n            this.profit = profit;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        \\n        PriorityQueue<Job> pq = new PriorityQueue<>((a, b) -> {\\n            \\n            if (a.profit == b.profit) {\\n                return a.difficulty - b.difficulty;\\n            } else {\\n                return b.profit - a.profit;\\n            }\\n        });\\n        \\n        int n = difficulty.length;\\n        for (int i = 0; i < n; i++) {\\n            pq.add(new Job(difficulty[i], profit[i]));\\n        }\\n        \\n        TreeMap<Integer, List<Integer>> treeMap = new TreeMap<>();\\n        for (int i = 0; i < worker.length; i++) {\\n            treeMap.computeIfAbsent(worker[i], v -> new ArrayList<>()).add(i);\\n        }\\n        \\n        int ret = 0;\\n        \\n        Set<Integer> visited = new HashSet<>();\\n        while (!pq.isEmpty() && visited.size() != worker.length) {\\n            \\n            Job cur = pq.poll();\\n            int d = cur.difficulty;\\n            \\n            Map.Entry<Integer, List<Integer>> e = treeMap.ceilingEntry(d);\\n            if (e != null) {\\n                \\n                for (int w : e.getValue()) {\\n                    visited.add(w);\\n                }\\n                \\n                ret += e.getValue().size() * cur.profit;\\n                \\n                treeMap.remove(e.getKey());\\n                pq.add(cur);\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n    \\n    class Job {\\n        \\n        int difficulty;\\n        int profit;\\n        \\n        public Job(int difficulty, int profit) {\\n            this.difficulty = difficulty;\\n            this.profit = profit;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1622126,
                "title": "java-solutions-with-optimization-steps-explained",
                "content": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        int n = worker.length, m = difficulty.length;\\n        // O(n * (log n + n))\\n        // sort job by difficulty \\n        // binary search for index of max difficulty worker[i] can afford\\n        // loop from 0 to that index, checking one by one to find max profit for that worker \\n        work[] job = new work[m];\\n        for (int i = 0; i<m; i++) {\\n            job[i] = new work(difficulty[i], profit[i]);\\n        }\\n        Arrays.sort(job);\\n        int ans = 0;\\n        for (int i = 0; i<n; i++) {\\n            int idx = binarySearch(worker[i], job);\\n            int max = 0;\\n            for (int j = 0; j<=idx; j++) {\\n                max = Math.max(job[j].profit, max);\\n            }\\n            ans+=max;\\n        }\\n        return ans;\\n    }\\n    public int binarySearch(int v, work[] jobs) {\\n        int lo = 0, hi = jobs.length - 1, res = -1;\\n        while (lo<=hi) {\\n            int mid = (lo+hi)/2;\\n            work cur = jobs[mid];\\n            if (cur.dif<=v) {\\n                lo = mid+1;\\n                res = mid;\\n            }\\n            else hi = mid-1;\\n        }       \\n        return res;\\n    }\\n    public class work implements Comparable<work> {\\n        int dif, profit;\\n        work(int d, int p) { dif = d; profit = p; }\\n        \\n        public int compareTo(work nxt) {\\n            return Integer.compare(dif, nxt.dif);\\n        }\\n    }\\n}\\n```\\nWay 2: Optimize maximum finding using segment tree, without loops\\n```\\nclass Solution {\\n    int MM = (int)1e5;\\n    int seg[] = new int[3*MM];\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        int n = worker.length, m = difficulty.length;\\n        // O(n * (log n + log n)) or can be simplified to O(n log n)\\n        // sort job by difficulty \\n\\t\\t// build segment tree\\n        // binary search for index of max difficulty worker[i] can afford\\n        // query seg tree for the range [0, index] to find the max profit for that worker \\n        work[] job = new work[m];\\n        for (int i = 0; i<m; i++) {\\n            job[i] = new work(difficulty[i], profit[i]);\\n        }\\n        Arrays.sort(job); // Sort requires O(n log n) \\n        build(0, m-1, 1, job); // Build tree requires O(n)\\n        int ans = 0;\\n        for (int i = 0; i<n; i++) {\\n            int idx = binarySearch(worker[i], job); // binary search takes O(log n)\\n            int max = queryMax(0, m-1, 0, idx, 1); // query takes O(log n)\\n            ans+=max;\\n        }\\n        return ans;\\n    }\\n    public void build(int l, int r, int idx, work[] jobs) {\\n        if (l == r) {\\n            seg[idx] = jobs[l].profit;\\n            return;\\n        }\\n        int m = (l+r)/2;\\n        build(l , m, idx*2, jobs); build(m+1, r, idx*2+1, jobs);\\n        seg[idx] = Math.max(seg[2*idx], seg[2*idx+1]);\\n    }\\n    public int queryMax(int l, int r, int ql, int qr, int idx) {\\n        if (ql>qr) return 0; \\n        if (l == ql && r == qr)return seg[idx];\\n        int m = (l+r)/2;\\n        if (ql > m) return queryMax(m+1, r, ql, qr, 2*idx+1);\\n        else if (qr<=m) return queryMax(l, m, ql, qr, 2*idx);\\n        else return Math.max(queryMax(l, m, ql, m, 2*idx), queryMax(m+1, r, m+1, qr, 2*idx+1));\\n    }\\n    public int binarySearch(int v, work[] jobs) {\\n        int lo = 0, hi = jobs.length - 1, res = -1;\\n        while (lo<=hi) {\\n            int mid = (lo+hi)/2;\\n            work cur = jobs[mid];\\n            if (cur.dif<=v) {\\n                lo = mid+1;\\n                res = mid;\\n            }\\n            else hi = mid-1;\\n        }       \\n        return res;\\n    }\\n    public class work implements Comparable<work> {\\n        int dif, profit;\\n        work(int d, int p) { dif = d; profit = p; }\\n        \\n        public int compareTo(work nxt) {\\n            return Integer.compare(dif, nxt.dif);\\n        }\\n    }\\n}\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        int n = worker.length, m = difficulty.length;\\n        // O(n * (log n + n))\\n        // sort job by difficulty \\n        // binary search for index of max difficulty worker[i] can afford\\n        // loop from 0 to that index, checking one by one to find max profit for that worker \\n        work[] job = new work[m];\\n        for (int i = 0; i<m; i++) {\\n            job[i] = new work(difficulty[i], profit[i]);\\n        }\\n        Arrays.sort(job);\\n        int ans = 0;\\n        for (int i = 0; i<n; i++) {\\n            int idx = binarySearch(worker[i], job);\\n            int max = 0;\\n            for (int j = 0; j<=idx; j++) {\\n                max = Math.max(job[j].profit, max);\\n            }\\n            ans+=max;\\n        }\\n        return ans;\\n    }\\n    public int binarySearch(int v, work[] jobs) {\\n        int lo = 0, hi = jobs.length - 1, res = -1;\\n        while (lo<=hi) {\\n            int mid = (lo+hi)/2;\\n            work cur = jobs[mid];\\n            if (cur.dif<=v) {\\n                lo = mid+1;\\n                res = mid;\\n            }\\n            else hi = mid-1;\\n        }       \\n        return res;\\n    }\\n    public class work implements Comparable<work> {\\n        int dif, profit;\\n        work(int d, int p) { dif = d; profit = p; }\\n        \\n        public int compareTo(work nxt) {\\n            return Integer.compare(dif, nxt.dif);\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int MM = (int)1e5;\\n    int seg[] = new int[3*MM];\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        int n = worker.length, m = difficulty.length;\\n        // O(n * (log n + log n)) or can be simplified to O(n log n)\\n        // sort job by difficulty \\n\\t\\t// build segment tree\\n        // binary search for index of max difficulty worker[i] can afford\\n        // query seg tree for the range [0, index] to find the max profit for that worker \\n        work[] job = new work[m];\\n        for (int i = 0; i<m; i++) {\\n            job[i] = new work(difficulty[i], profit[i]);\\n        }\\n        Arrays.sort(job); // Sort requires O(n log n) \\n        build(0, m-1, 1, job); // Build tree requires O(n)\\n        int ans = 0;\\n        for (int i = 0; i<n; i++) {\\n            int idx = binarySearch(worker[i], job); // binary search takes O(log n)\\n            int max = queryMax(0, m-1, 0, idx, 1); // query takes O(log n)\\n            ans+=max;\\n        }\\n        return ans;\\n    }\\n    public void build(int l, int r, int idx, work[] jobs) {\\n        if (l == r) {\\n            seg[idx] = jobs[l].profit;\\n            return;\\n        }\\n        int m = (l+r)/2;\\n        build(l , m, idx*2, jobs); build(m+1, r, idx*2+1, jobs);\\n        seg[idx] = Math.max(seg[2*idx], seg[2*idx+1]);\\n    }\\n    public int queryMax(int l, int r, int ql, int qr, int idx) {\\n        if (ql>qr) return 0; \\n        if (l == ql && r == qr)return seg[idx];\\n        int m = (l+r)/2;\\n        if (ql > m) return queryMax(m+1, r, ql, qr, 2*idx+1);\\n        else if (qr<=m) return queryMax(l, m, ql, qr, 2*idx);\\n        else return Math.max(queryMax(l, m, ql, m, 2*idx), queryMax(m+1, r, m+1, qr, 2*idx+1));\\n    }\\n    public int binarySearch(int v, work[] jobs) {\\n        int lo = 0, hi = jobs.length - 1, res = -1;\\n        while (lo<=hi) {\\n            int mid = (lo+hi)/2;\\n            work cur = jobs[mid];\\n            if (cur.dif<=v) {\\n                lo = mid+1;\\n                res = mid;\\n            }\\n            else hi = mid-1;\\n        }       \\n        return res;\\n    }\\n    public class work implements Comparable<work> {\\n        int dif, profit;\\n        work(int d, int p) { dif = d; profit = p; }\\n        \\n        public int compareTo(work nxt) {\\n            return Integer.compare(dif, nxt.dif);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1324179,
                "title": "with-explaination-faster-than-98-dp-java-easy-to-understand",
                "content": "Basically we have to find what maximum profit a worker could earn knowing that he is only able to do work of certain level of difficulty. For this we are creating a dp array and in that we are storing the max profit for each level.\\nFirst we are assigning values in dp from the profit array.After that maximum profit for any difficulty is the MAX profit of difficulty from level 0 difficulty to that level of difficulty.So value of that difficulty will be\\ndp[i]=Math.max(dp[0],dp[1],dp[2].......dp[i])\\nWe are doing this because a person can earn money by doing work of any difficulty level below tham it\\'s level.\\n\\n```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        int max=-1;\\n        for(int val:difficulty)\\n            max=Math.max(val,max);\\n        int [] dp=new int[max+1];\\n        \\n        for(int i=0;i<difficulty.length;i++){\\n            dp[difficulty[i]]=Math.max(dp[difficulty[i]],profit[i]);\\n        }\\n        for(int i=1;i<dp.length;i++){\\n            dp[i]=Math.max(dp[i],dp[i-1]);\\n        }\\n        int ans=0;\\n        for(int val:worker){\\n            if(val<dp.length)\\n                ans+=dp[val];\\n            else\\n                ans+=dp[dp.length-1];\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        int max=-1;\\n        for(int val:difficulty)\\n            max=Math.max(val,max);\\n        int [] dp=new int[max+1];\\n        \\n        for(int i=0;i<difficulty.length;i++){\\n            dp[difficulty[i]]=Math.max(dp[difficulty[i]],profit[i]);\\n        }\\n        for(int i=1;i<dp.length;i++){\\n            dp[i]=Math.max(dp[i],dp[i-1]);\\n        }\\n        int ans=0;\\n        for(int val:worker){\\n            if(val<dp.length)\\n                ans+=dp[val];\\n            else\\n                ans+=dp[dp.length-1];\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1018819,
                "title": "c-sort-then-greedy-beats-100-time-72-89-space",
                "content": "Greedy\\nSort profit array\\nAssign as many of the highest paying jobs to workers as you can.\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int ans = 0;\\n        vector<pair<int,int>> jobs;\\n        for(int i = 0; i < profit.size(); i++) jobs.push_back({profit[i], difficulty[i]});\\n        sort(jobs.begin(),jobs.end());\\n        sort(worker.begin(), worker.end());\\n        int i = worker.size()-1;\\n        int j = profit.size()-1;\\n        for(; i >= 0; i--) {\\n            while(j >= 0 && jobs[j].second > worker[i]) j--;\\n            if(j < 0) break;\\n            ans += jobs[j].first;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int ans = 0;\\n        vector<pair<int,int>> jobs;\\n        for(int i = 0; i < profit.size(); i++) jobs.push_back({profit[i], difficulty[i]});\\n        sort(jobs.begin(),jobs.end());\\n        sort(worker.begin(), worker.end());\\n        int i = worker.size()-1;\\n        int j = profit.size()-1;\\n        for(; i >= 0; i--) {\\n            while(j >= 0 && jobs[j].second > worker[i]) j--;\\n            if(j < 0) break;\\n            ans += jobs[j].first;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 776586,
                "title": "java-sorting-and-two-pointer-approach-using-hashmap",
                "content": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] diff, int[] pro, int[] work) {\\n        int maxProfit=0;\\n        Map<Integer,Integer> map=new HashMap<>(); \\n        for(int i=0;i<pro.length;i++){\\n            if(map.get(pro[i])!=null && map.get(pro[i])<diff[i]){\\n                continue;\\n            }\\n            map.put(pro[i],diff[i]);\\n        }\\n        Arrays.sort(pro);\\n        Arrays.sort(work);\\n        int w=work.length-1;\\n        int p=pro.length-1;\\n        while(w>=0 && p>=0) {\\n            if(map.get(pro[p])<=work[w]){\\n                maxProfit+=pro[p];\\n                w--;\\n            } else{\\n                p--;\\n            }\\n        }\\n        return maxProfit;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] diff, int[] pro, int[] work) {\\n        int maxProfit=0;\\n        Map<Integer,Integer> map=new HashMap<>(); \\n        for(int i=0;i<pro.length;i++){\\n            if(map.get(pro[i])!=null && map.get(pro[i])<diff[i]){\\n                continue;\\n            }\\n            map.put(pro[i],diff[i]);\\n        }\\n        Arrays.sort(pro);\\n        Arrays.sort(work);\\n        int w=work.length-1;\\n        int p=pro.length-1;\\n        while(w>=0 && p>=0) {\\n            if(map.get(pro[p])<=work[w]){\\n                maxProfit+=pro[p];\\n                w--;\\n            } else{\\n                p--;\\n            }\\n        }\\n        return maxProfit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 756765,
                "title": "python-sort-and-binary-search",
                "content": "Code is very descriptive, just read up.\\n\\n```\\ndef maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n\\tdif_profit_hm = defaultdict(int)\\n\\tn = len(difficulty)\\n\\n\\t# Create a hash map to remember original values order\\n\\tfor dif, profit in zip(difficulty, profit):\\n\\t\\tdif_profit_hm[dif] = max(dif_profit_hm[dif], profit)\\n\\n\\t# Sorting to work with binary search\\n\\tsorted_dif = sorted(difficulty)\\n\\n\\t# dp that knows maximum for every index worker can have\\n\\tmax_profit_per_diff = [0] * n\\n\\tmax_profit_per_diff[0] = dif_profit_hm[sorted_dif[0]]\\n\\n\\tfor i in range(1, len(sorted_dif)):\\n\\t\\tval = sorted_dif[i]\\n\\t\\tmax_profit_per_diff[i] = max(dif_profit_hm[val], max_profit_per_diff[i - 1])\\n\\n\\tdef find_worker_index(worker_dif):\\n\\t\\tindex = bisect_right(sorted_dif, worker_dif)\\n\\t\\tif index == n: return n -1 # we are bigger than all indexes\\n\\t\\tif sorted_dif[index] == worker_dif:\\n\\t\\t\\treturn index\\n\\t\\treturn index - 1\\n\\n\\tmax_profit = 0\\n\\tfor w in worker:\\n\\t\\tworker_max_index = find_worker_index(w)\\n\\t\\tif worker_max_index == -1: continue\\n\\t\\tmax_profit += max_profit_per_diff[worker_max_index]\\n\\n\\treturn max_profit\\n```",
                "solutionTags": [],
                "code": "```\\ndef maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n\\tdif_profit_hm = defaultdict(int)\\n\\tn = len(difficulty)\\n\\n\\t# Create a hash map to remember original values order\\n\\tfor dif, profit in zip(difficulty, profit):\\n\\t\\tdif_profit_hm[dif] = max(dif_profit_hm[dif], profit)\\n\\n\\t# Sorting to work with binary search\\n\\tsorted_dif = sorted(difficulty)\\n\\n\\t# dp that knows maximum for every index worker can have\\n\\tmax_profit_per_diff = [0] * n\\n\\tmax_profit_per_diff[0] = dif_profit_hm[sorted_dif[0]]\\n\\n\\tfor i in range(1, len(sorted_dif)):\\n\\t\\tval = sorted_dif[i]\\n\\t\\tmax_profit_per_diff[i] = max(dif_profit_hm[val], max_profit_per_diff[i - 1])\\n\\n\\tdef find_worker_index(worker_dif):\\n\\t\\tindex = bisect_right(sorted_dif, worker_dif)\\n\\t\\tif index == n: return n -1 # we are bigger than all indexes\\n\\t\\tif sorted_dif[index] == worker_dif:\\n\\t\\t\\treturn index\\n\\t\\treturn index - 1\\n\\n\\tmax_profit = 0\\n\\tfor w in worker:\\n\\t\\tworker_max_index = find_worker_index(w)\\n\\t\\tif worker_max_index == -1: continue\\n\\t\\tmax_profit += max_profit_per_diff[worker_max_index]\\n\\n\\treturn max_profit\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 641854,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        priority_queue<pair<int, int>> pq;\\n        for (int i=0; i<profit.size(); i++){\\n            pq.push(make_pair(profit[i], difficulty[i]));\\n        }\\n        sort(worker.begin(), worker.end());\\n        int total = 0;\\n        for (int i=worker.size()-1; i>=0; i--){\\n            while (!pq.empty() && pq.top().second > worker[i]){\\n                pq.pop();\\n            }\\n            if (!pq.empty()){\\n                total += pq.top().first;\\n            }else{\\n                break;\\n            }\\n        }\\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        priority_queue<pair<int, int>> pq;\\n        for (int i=0; i<profit.size(); i++){\\n            pq.push(make_pair(profit[i], difficulty[i]));\\n        }\\n        sort(worker.begin(), worker.end());\\n        int total = 0;\\n        for (int i=worker.size()-1; i>=0; i--){\\n            while (!pq.empty() && pq.top().second > worker[i]){\\n                pq.pop();\\n            }\\n            if (!pq.empty()){\\n                total += pq.top().first;\\n            }else{\\n                break;\\n            }\\n        }\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 548935,
                "title": "python-o-n-log-n-sort-and-binary-search",
                "content": "Simple idea: sort the jobs by difficulty, then find the most profit that can be made up to each difficulty level. For each worker, do a binary search to determine the most difficult job they can complete, and hence the most profit.\\n\\n```python\\nclass Solution:\\n    \\n    def maxProfitAssignment(self, difficulties, profits, workers):\\n        \\n        # Sort difficulties and profits, with difficulties as the key:\\n        difficulties, profits = zip(*sorted(zip(difficulties, profits)))\\n        \\n        # Find the corresponding maximum profit for each difficulty level:\\n        max_profits = list(itertools.accumulate(profits, max))\\n        \\n        min_difficulty = min(difficulties)\\n        \\n        def max_profit(worker):\\n            if worker < min_difficulty:\\n                return 0\\n            return max_profits[bisect.bisect(difficulties, worker) - 1]\\n        \\n        return sum(map(max_profit, workers))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    \\n    def maxProfitAssignment(self, difficulties, profits, workers):\\n        \\n        # Sort difficulties and profits, with difficulties as the key:\\n        difficulties, profits = zip(*sorted(zip(difficulties, profits)))\\n        \\n        # Find the corresponding maximum profit for each difficulty level:\\n        max_profits = list(itertools.accumulate(profits, max))\\n        \\n        min_difficulty = min(difficulties)\\n        \\n        def max_profit(worker):\\n            if worker < min_difficulty:\\n                return 0\\n            return max_profits[bisect.bisect(difficulties, worker) - 1]\\n        \\n        return sum(map(max_profit, workers))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 347627,
                "title": "python-2-pointer-greedy",
                "content": "Run time O(NlogN + KlogK + N)\\n```\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        for i in range(len(difficulty)):\\n            difficulty[i] = (difficulty[i], profit[i])\\n        difficulty.sort(key = lambda x:x[0]) # O(NlogN)\\n        i, L = 0, len(difficulty)\\n        ans, most = 0, 0\\n        for wker in sorted(worker):\\n            while i < L and difficulty[i][0] <= wker:\\n                most = max(most, difficulty[i][1])\\n                i += 1\\n            ans += most\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        for i in range(len(difficulty)):\\n            difficulty[i] = (difficulty[i], profit[i])\\n        difficulty.sort(key = lambda x:x[0]) # O(NlogN)\\n        i, L = 0, len(difficulty)\\n        ans, most = 0, 0\\n        for wker in sorted(worker):\\n            while i < L and difficulty[i][0] <= wker:\\n                most = max(most, difficulty[i][1])\\n                i += 1\\n            ans += most\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 251244,
                "title": "why-does-my-solution-fail-the-last-testcase",
                "content": "I used Nlog(N) sort + binary search solution:\\nIt fails on this testcase:\\n[66,1,28,73,53,35,45,60,100,44,59,94,27,88,7,18,83,18,72,63]\\n[66,20,84,81,56,40,37,82,53,45,43,96,67,27,12,54,98,19,47,77]\\n[61,33,68,38,63,45,1,10,53,23,66,70,14,51,94,18,28,78,100,16]\\noutput should be:  1392\\nbut i am getting: 1324\\n\\n```\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        dif_to_profit_map = {difficulty[i]:profit[i] for i in range(len(difficulty))}\\n        difficulty = sorted(difficulty)\\n        max_ = 0\\n        for i in difficulty:\\n            max_ = max(max_, dif_to_profit_map[i])\\n            dif_to_profit_map[i] = max_\\n\\n        def bs(arr, s, e, t):\\n            if s > e:\\n                return -1\\n            \\n            mid = (s + e) // 2\\n            \\n            if arr[mid] > t:\\n                return bs(arr, s, mid-1, t)\\n            \\n            elif arr[mid] <= t:\\n                if mid == len(arr)-1: return mid\\n                \\n                elif arr[mid+1] > t: return mid\\n                \\n                else: return bs(arr, mid+1, e, t) \\n                \\n        sol = 0\\n        for i in worker:\\n            ind = bs(difficulty, 0, len(difficulty), i)\\n            if ind != -1:\\n                sol += dif_to_profit_map[difficulty[ind]]\\n        \\n        return sol\\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        dif_to_profit_map = {difficulty[i]:profit[i] for i in range(len(difficulty))}",
                "codeTag": "Java"
            },
            {
                "id": 4013864,
                "title": "c-solution-using-sorting",
                "content": "# Intuition\\n- Here a worker can perform any task whose difficulty is less than or equal to the ability of our worker\\n- So we need to sort the array and find the max profit that we can get for a worker with ability worker[i]\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int n = worker.size();\\n        sort(worker.begin(),worker.end());\\n        vector<pair<int,int>> nums(n);\\n        for(int i=0;i<n;i++){\\n            nums[i] = {difficulty[i],profit[i]};\\n        }\\n        sort(nums.begin(),nums.end());\\n\\n        int maxProfit = 0;\\n        int tempprofit = 0;\\n        for( int i = 0 , j = 0 ; i < n ; i++ ){\\n            while(j<n && nums[j].first <= worker[i]){\\n                tempprofit = max(nums[j].second,tempprofit);    // stores max profit for all tasks having dificilty <= worker[i]\\n                j++;\\n            }\\n            if(j>0 && nums[j-1].first<=worker[i])\\n                maxProfit += tempprofit;\\n        }\\n\\n        return maxProfit;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int n = worker.size();\\n        sort(worker.begin(),worker.end());\\n        vector<pair<int,int>> nums(n);\\n        for(int i=0;i<n;i++){\\n            nums[i] = {difficulty[i],profit[i]};\\n        }\\n        sort(nums.begin(),nums.end());\\n\\n        int maxProfit = 0;\\n        int tempprofit = 0;\\n        for( int i = 0 , j = 0 ; i < n ; i++ ){\\n            while(j<n && nums[j].first <= worker[i]){\\n                tempprofit = max(nums[j].second,tempprofit);    // stores max profit for all tasks having dificilty <= worker[i]\\n                j++;\\n            }\\n            if(j>0 && nums[j-1].first<=worker[i])\\n                maxProfit += tempprofit;\\n        }\\n\\n        return maxProfit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3918050,
                "title": "java-17ms-execution-time-beats-80-in-time-and-97-in-space-taken",
                "content": "# Intuition\\n- sorting\\n- binary search for getting max difficult work\\n\\n# Approach\\n- sort according to difficulty level of work\\n- get index what maximum difficulty level work user can do using binary search\\n- maintain maxProfit possible at a difficulty level(cover less difficult level profit as well because less difficult work can also have more profilt compare to higher difficulties)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    static class Pair implements Comparable<Pair> {\\n            int dif;\\n            int pro;\\n            Pair (int dif, int pro) //constructor \\n            {\\n                this.dif = dif;\\n                this.pro = pro;\\n            }\\n            public int compareTo(Pair other) //making it only compare dif values\\n            {\\n                return this.dif - other.dif;\\n            }\\n    }\\n\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        \\n        int len = difficulty.length;\\n        Pair[] pairs = new Pair[len];\\n        for (int i=0; i< len; i++){\\n            pairs[i] = new Pair(difficulty[i], profit[i]);\\n        }\\n        Arrays.sort(pairs);\\n        \\n        int maxProfit = 0;\\n        //get max profit from possible difficulty work\\n        int maxSoFar[] = new int[len];\\n        maxSoFar[0] = pairs[0].pro;\\n        for(int i = 1; i < len; i++) {\\n            if (pairs[i].pro > maxSoFar[i-1]) {\\n                maxSoFar[i] = pairs[i].pro;\\n            } else {\\n                maxSoFar[i] = maxSoFar[i-1];\\n            }\\n        }\\n\\n        //System.out.println(\"checking workers cap now....\");\\n\\n        for(int i = 0; i<worker.length; i++) {\\n            int index = getIndex(worker[i], pairs, len);\\n            //System.out.println(\"index: \" + index + \" for item: \" + worker[i]);\\n\\n            if(index != -1) {\\n                 maxProfit += maxSoFar[index];;\\n            }\\n           \\n        }\\n        return maxProfit;\\n    }\\n\\n    private int getIndex(int cap, Pair []pair, int len) {\\n        int low = 0;\\n        int high = len-1;\\n        while (low <= high) {\\n            int mid = (high+low)/2;\\n            if (pair[mid].dif == cap ) {\\n                //Check for same items\\n                while(mid < high && pair[mid+1].dif == cap) mid ++;\\n                return mid;\\n            } else if (pair[mid].dif < cap) {\\n                low = mid+1 ;\\n            } else if (pair[mid].dif > cap) {\\n                high = mid-1 ;\\n            }\\n        }\\n        return high;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static class Pair implements Comparable<Pair> {\\n            int dif;\\n            int pro;\\n            Pair (int dif, int pro) //constructor \\n            {\\n                this.dif = dif;\\n                this.pro = pro;\\n            }\\n            public int compareTo(Pair other) //making it only compare dif values\\n            {\\n                return this.dif - other.dif;\\n            }\\n    }\\n\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        \\n        int len = difficulty.length;\\n        Pair[] pairs = new Pair[len];\\n        for (int i=0; i< len; i++){\\n            pairs[i] = new Pair(difficulty[i], profit[i]);\\n        }\\n        Arrays.sort(pairs);\\n        \\n        int maxProfit = 0;\\n        //get max profit from possible difficulty work\\n        int maxSoFar[] = new int[len];\\n        maxSoFar[0] = pairs[0].pro;\\n        for(int i = 1; i < len; i++) {\\n            if (pairs[i].pro > maxSoFar[i-1]) {\\n                maxSoFar[i] = pairs[i].pro;\\n            } else {\\n                maxSoFar[i] = maxSoFar[i-1];\\n            }\\n        }\\n\\n        //System.out.println(\"checking workers cap now....\");\\n\\n        for(int i = 0; i<worker.length; i++) {\\n            int index = getIndex(worker[i], pairs, len);\\n            //System.out.println(\"index: \" + index + \" for item: \" + worker[i]);\\n\\n            if(index != -1) {\\n                 maxProfit += maxSoFar[index];;\\n            }\\n           \\n        }\\n        return maxProfit;\\n    }\\n\\n    private int getIndex(int cap, Pair []pair, int len) {\\n        int low = 0;\\n        int high = len-1;\\n        while (low <= high) {\\n            int mid = (high+low)/2;\\n            if (pair[mid].dif == cap ) {\\n                //Check for same items\\n                while(mid < high && pair[mid+1].dif == cap) mid ++;\\n                return mid;\\n            } else if (pair[mid].dif < cap) {\\n                low = mid+1 ;\\n            } else if (pair[mid].dif > cap) {\\n                high = mid-1 ;\\n            }\\n        }\\n        return high;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581906,
                "title": "java-javascript-c-c-solution",
                "content": "**Java**\\n```\\nimport java.util.Arrays;\\n\\npublic class Solution {\\n\\n    private record Job(int difficulty, int profit) {}\\n\\n    public int maxProfitAssignment(int[] jobDifficulty, int[] jobProfit, int[] maxDifficultyPerWorker) {\\n        int totalJobs = jobDifficulty.length;\\n        Job[] jobs = new Job[totalJobs];\\n        for (int i = 0; i < totalJobs; ++i) {\\n            jobs[i] = new Job(jobDifficulty[i], jobProfit[i]);\\n        }\\n\\n        Arrays.sort(jobs, (x, y) -> x.difficulty - y.difficulty);\\n        Arrays.sort(maxDifficultyPerWorker);\\n\\n        int index = 0;\\n        int totalMaxProfit = 0;\\n        int currentMaxProfit = 0;\\n\\n        for (int difficulty : maxDifficultyPerWorker) {\\n            while (index < totalJobs && jobs[index].difficulty <= difficulty) {\\n                currentMaxProfit = Math.max(currentMaxProfit, jobs[index].profit);\\n                ++index;\\n            }\\n            totalMaxProfit += currentMaxProfit;\\n        }\\n\\n        return totalMaxProfit;\\n    }\\n}\\n```\\n**JavaScript**\\n```\\n/**\\n * @param {number[]} jobDifficulty\\n * @param {number[]} jobProfit\\n * @param {number[]} maxDifficultyPerWorker\\n * @return {number}\\n */\\nvar maxProfitAssignment = function (jobDifficulty, jobProfit, maxDifficultyPerWorker) {\\n    const totalJobs = jobDifficulty.length;\\n    const jobs = new Array(totalJobs);\\n    for (let i = 0; i < totalJobs; ++i) {\\n        jobs[i] = new Job(jobDifficulty[i], jobProfit[i]);\\n    }\\n\\n    jobs.sort((x, y) => x.difficulty - y.difficulty);\\n    maxDifficultyPerWorker.sort((x, y) => x - y);\\n\\n    let index = 0;\\n    let totalMaxProfit = 0;\\n    let currentMaxProfit = 0;\\n\\n    for (let difficulty of maxDifficultyPerWorker) {\\n        while (index < totalJobs && jobs[index].difficulty <= difficulty) {\\n            currentMaxProfit = Math.max(currentMaxProfit, jobs[index].profit);\\n            ++index;\\n        }\\n        totalMaxProfit += currentMaxProfit;\\n    }\\n\\n    return totalMaxProfit;\\n};\\n\\nfunction Job(difficulty, profit) {\\n    this.difficulty = difficulty;\\n    this.profit = profit;\\n}\\n```\\n**C++**\\n```\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\n\\n    struct Job {\\n        int difficulty;\\n        int profit;\\n        Job() = default;\\n        Job(int difficulty, int profit) : difficulty {difficulty}, profit {profit}{}\\n    };\\n\\npublic:\\n    int maxProfitAssignment(vector<int>& jobDifficulty, vector<int>& jobProfit, vector<int>& maxDifficultyPerWorker) const {\\n        int totalJobs = jobDifficulty.size();\\n        vector<Job>jobs(totalJobs);\\n        for (int i = 0; i < totalJobs; ++i) {\\n            jobs[i].difficulty = jobDifficulty[i];\\n            jobs[i].profit = jobProfit[i];\\n        }\\n        const auto compare = [](const Job& first, const Job& second) {return first.difficulty < second.difficulty;};\\n        //C++20: std::ranages::sort(jobs, compare) \\n        //       std::ranages::sort(maxDifficultyPerWorker)  \\n        sort(jobs.begin(), jobs.end(), compare);\\n        sort(maxDifficultyPerWorker.begin(), maxDifficultyPerWorker.end());\\n\\n        int index = 0;\\n        int totalMaxProfit = 0;\\n        int currentMaxProfit = 0;\\n\\n        for (const auto& difficulty : maxDifficultyPerWorker) {\\n            while (index < totalJobs && jobs[index].difficulty <= difficulty) {\\n                currentMaxProfit = max(currentMaxProfit, jobs[index].profit);\\n                ++index;\\n            }\\n            totalMaxProfit += currentMaxProfit;\\n        }\\n\\n        return totalMaxProfit;\\n    }\\n};\\n```\\n**C#**\\n```\\nusing System;\\n\\npublic class Solution\\n{\\n    private struct Job\\n    {\\n        public int difficulty;\\n        public int profit;\\n        public Job(int difficulty, int profit)\\n        {\\n            this.difficulty = difficulty;\\n            this.profit = profit;\\n        }\\n    }\\n    public int MaxProfitAssignment(int[] jobDifficulty, int[] jobProfit, int[] maxDifficultyPerWorker)\\n    {\\n        int totalJobs = jobDifficulty.Length;\\n        Job[] jobs = new Job[totalJobs];\\n        for (int i = 0; i < totalJobs; ++i)\\n        {\\n            jobs[i] = new Job(jobDifficulty[i], jobProfit[i]);\\n        }\\n\\n        Array.Sort(jobs, (x, y) => x.difficulty - y.difficulty);\\n        Array.Sort(maxDifficultyPerWorker);\\n\\n        int index = 0;\\n        int totalMaxProfit = 0;\\n        int currentMaxProfit = 0;\\n\\n        foreach (var difficulty in maxDifficultyPerWorker)\\n        {\\n            while (index < totalJobs && jobs[index].difficulty <= difficulty)\\n            {\\n                currentMaxProfit = Math.Max(currentMaxProfit, jobs[index].profit);\\n                ++index;\\n            }\\n            totalMaxProfit += currentMaxProfit;\\n        }\\n\\n        return totalMaxProfit;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C#",
                    "JavaScript",
                    "Sorting"
                ],
                "code": "```\\nimport java.util.Arrays;\\n\\npublic class Solution {\\n\\n    private record Job(int difficulty, int profit) {}\\n\\n    public int maxProfitAssignment(int[] jobDifficulty, int[] jobProfit, int[] maxDifficultyPerWorker) {\\n        int totalJobs = jobDifficulty.length;\\n        Job[] jobs = new Job[totalJobs];\\n        for (int i = 0; i < totalJobs; ++i) {\\n            jobs[i] = new Job(jobDifficulty[i], jobProfit[i]);\\n        }\\n\\n        Arrays.sort(jobs, (x, y) -> x.difficulty - y.difficulty);\\n        Arrays.sort(maxDifficultyPerWorker);\\n\\n        int index = 0;\\n        int totalMaxProfit = 0;\\n        int currentMaxProfit = 0;\\n\\n        for (int difficulty : maxDifficultyPerWorker) {\\n            while (index < totalJobs && jobs[index].difficulty <= difficulty) {\\n                currentMaxProfit = Math.max(currentMaxProfit, jobs[index].profit);\\n                ++index;\\n            }\\n            totalMaxProfit += currentMaxProfit;\\n        }\\n\\n        return totalMaxProfit;\\n    }\\n}\\n```\n```\\n/**\\n * @param {number[]} jobDifficulty\\n * @param {number[]} jobProfit\\n * @param {number[]} maxDifficultyPerWorker\\n * @return {number}\\n */\\nvar maxProfitAssignment = function (jobDifficulty, jobProfit, maxDifficultyPerWorker) {\\n    const totalJobs = jobDifficulty.length;\\n    const jobs = new Array(totalJobs);\\n    for (let i = 0; i < totalJobs; ++i) {\\n        jobs[i] = new Job(jobDifficulty[i], jobProfit[i]);\\n    }\\n\\n    jobs.sort((x, y) => x.difficulty - y.difficulty);\\n    maxDifficultyPerWorker.sort((x, y) => x - y);\\n\\n    let index = 0;\\n    let totalMaxProfit = 0;\\n    let currentMaxProfit = 0;\\n\\n    for (let difficulty of maxDifficultyPerWorker) {\\n        while (index < totalJobs && jobs[index].difficulty <= difficulty) {\\n            currentMaxProfit = Math.max(currentMaxProfit, jobs[index].profit);\\n            ++index;\\n        }\\n        totalMaxProfit += currentMaxProfit;\\n    }\\n\\n    return totalMaxProfit;\\n};\\n\\nfunction Job(difficulty, profit) {\\n    this.difficulty = difficulty;\\n    this.profit = profit;\\n}\\n```\n```\\n#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\n\\n    struct Job {\\n        int difficulty;\\n        int profit;\\n        Job() = default;\\n        Job(int difficulty, int profit) : difficulty {difficulty}, profit {profit}{}\\n    };\\n\\npublic:\\n    int maxProfitAssignment(vector<int>& jobDifficulty, vector<int>& jobProfit, vector<int>& maxDifficultyPerWorker) const {\\n        int totalJobs = jobDifficulty.size();\\n        vector<Job>jobs(totalJobs);\\n        for (int i = 0; i < totalJobs; ++i) {\\n            jobs[i].difficulty = jobDifficulty[i];\\n            jobs[i].profit = jobProfit[i];\\n        }\\n        const auto compare = [](const Job& first, const Job& second) {return first.difficulty < second.difficulty;};\\n        //C++20: std::ranages::sort(jobs, compare) \\n        //       std::ranages::sort(maxDifficultyPerWorker)  \\n        sort(jobs.begin(), jobs.end(), compare);\\n        sort(maxDifficultyPerWorker.begin(), maxDifficultyPerWorker.end());\\n\\n        int index = 0;\\n        int totalMaxProfit = 0;\\n        int currentMaxProfit = 0;\\n\\n        for (const auto& difficulty : maxDifficultyPerWorker) {\\n            while (index < totalJobs && jobs[index].difficulty <= difficulty) {\\n                currentMaxProfit = max(currentMaxProfit, jobs[index].profit);\\n                ++index;\\n            }\\n            totalMaxProfit += currentMaxProfit;\\n        }\\n\\n        return totalMaxProfit;\\n    }\\n};\\n```\n```\\nusing System;\\n\\npublic class Solution\\n{\\n    private struct Job\\n    {\\n        public int difficulty;\\n        public int profit;\\n        public Job(int difficulty, int profit)\\n        {\\n            this.difficulty = difficulty;\\n            this.profit = profit;\\n        }\\n    }\\n    public int MaxProfitAssignment(int[] jobDifficulty, int[] jobProfit, int[] maxDifficultyPerWorker)\\n    {\\n        int totalJobs = jobDifficulty.Length;\\n        Job[] jobs = new Job[totalJobs];\\n        for (int i = 0; i < totalJobs; ++i)\\n        {\\n            jobs[i] = new Job(jobDifficulty[i], jobProfit[i]);\\n        }\\n\\n        Array.Sort(jobs, (x, y) => x.difficulty - y.difficulty);\\n        Array.Sort(maxDifficultyPerWorker);\\n\\n        int index = 0;\\n        int totalMaxProfit = 0;\\n        int currentMaxProfit = 0;\\n\\n        foreach (var difficulty in maxDifficultyPerWorker)\\n        {\\n            while (index < totalJobs && jobs[index].difficulty <= difficulty)\\n            {\\n                currentMaxProfit = Math.Max(currentMaxProfit, jobs[index].profit);\\n                ++index;\\n            }\\n            totalMaxProfit += currentMaxProfit;\\n        }\\n\\n        return totalMaxProfit;\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3481572,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int n = profit.size(), res = 0, l = 0, p = 0;\\n        vector<pair<int, int>> pairs;\\n        for(int i = 0; i < n; i++) pairs.emplace_back(difficulty[i], profit[i]);\\n        sort(pairs.begin(), pairs.end());\\n        sort(worker.begin(), worker.end());\\n        for(int &w: worker){\\n            while(l < n && w >= pairs[l].first){\\n                p = max(p, pairs[l++].second);\\n            }\\n            res += p;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        jobs = sorted(zip(profit, difficulty), reverse=True)\\n        worker.sort()\\n        total_profit = 0\\n\\n        for prof, diff in jobs:\\n            while worker and diff <= worker[-1]:\\n                total_profit += prof\\n                worker.pop()\\n            if not worker:\\n                break\\n\\n        return total_profit\\n```\\n\\n```Java []\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        int max=0;\\n        for(int d:difficulty)\\n            max = Math.max(max, d);\\n        int[] dp = new int[max+1];\\n        for(int i=0;i<difficulty.length;i++) \\n            dp[difficulty[i]] = Math.max(dp[difficulty[i]], profit[i]);\\n        for(int i=1;i<=max;i++)\\n            dp[i] = Math.max(dp[i-1], dp[i]);\\n        int ans=0;\\n        for(int w:worker)\\n        {\\n            if(w>max) ans+=dp[max];\\n            else ans+=dp[w];\\n        }\\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int n = profit.size(), res = 0, l = 0, p = 0;\\n        vector<pair<int, int>> pairs;\\n        for(int i = 0; i < n; i++) pairs.emplace_back(difficulty[i], profit[i]);\\n        sort(pairs.begin(), pairs.end());\\n        sort(worker.begin(), worker.end());\\n        for(int &w: worker){\\n            while(l < n && w >= pairs[l].first){\\n                p = max(p, pairs[l++].second);\\n            }\\n            res += p;\\n        }\\n        return res;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        jobs = sorted(zip(profit, difficulty), reverse=True)\\n        worker.sort()\\n        total_profit = 0\\n\\n        for prof, diff in jobs:\\n            while worker and diff <= worker[-1]:\\n                total_profit += prof\\n                worker.pop()\\n            if not worker:\\n                break\\n\\n        return total_profit\\n```\n```Java []\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        int max=0;\\n        for(int d:difficulty)\\n            max = Math.max(max, d);\\n        int[] dp = new int[max+1];\\n        for(int i=0;i<difficulty.length;i++) \\n            dp[difficulty[i]] = Math.max(dp[difficulty[i]], profit[i]);\\n        for(int i=1;i<=max;i++)\\n            dp[i] = Math.max(dp[i-1], dp[i]);\\n        int ans=0;\\n        for(int w:worker)\\n        {\\n            if(w>max) ans+=dp[max];\\n            else ans+=dp[w];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481270,
                "title": "no-binary-search-python-3-explainedd",
                "content": "Sort the array on the basis of profit (desc order) instead of difficulty after zipping them togther\\nAlso sort the worker array in descending order\\nNow if a task difficulty > worker[i] -> this task cant be done by any other worker too so j + 1\\nif difficulty < worker[i] => this task can be done i + 1.\\n`why not j + 1 here?` Because one task can be done by multiple workers\\n# Code\\n```\\nclass Solution:\\n    def maxProfitAssignment(self, d: List[int], p: List[int], w: List[int]) -> int:\\n        task = list(zip(d, p))\\n        t = sorted(task, key=lambda x:-x[1])\\n        w.sort(reverse=True)\\n        profit = 0\\n        i = 0\\n        j = 0\\n        while i < len(w) and j < len(t):\\n            if w[i] < t[j][0]:\\n                j += 1\\n            else:\\n                profit += t[j][1]\\n                i += 1 \\n        return profit\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfitAssignment(self, d: List[int], p: List[int], w: List[int]) -> int:\\n        task = list(zip(d, p))\\n        t = sorted(task, key=lambda x:-x[1])\\n        w.sort(reverse=True)\\n        profit = 0\\n        i = 0\\n        j = 0\\n        while i < len(w) and j < len(t):\\n            if w[i] < t[j][0]:\\n                j += 1\\n            else:\\n                profit += t[j][1]\\n                i += 1 \\n        return profit\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370476,
                "title": "sort-binary-search-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int n = difficulty.size() , m = worker.size();\\n        vector<pair<int,int>> arr(n);   \\n        for(int i=0;i<n;i++) {\\n            arr[i] = {difficulty[i] , profit[i]};\\n        }\\n        sort(arr.begin() , arr.end());\\n        int ans = 0;\\n        // for(auto &i : arr) {\\n        //     cout<<i.first<<\" \"<<i.second<<endl;\\n        // }\\n        for(int i=0;i<m;i++) {\\n            int low = 0, high = n-1;\\n            int res = -1;\\n            while(low <= high) {\\n                int mid = low + (high-low) / 2;\\n                if(arr[mid].first <= worker[i]) {\\n                    res = mid;\\n                    low = mid+1;\\n                }\\n                else high = mid - 1;\\n            }\\n            if(res != -1) {\\n                int mx = 0;\\n                for(int i=0;i<=res;i++) {\\n                    mx = max(mx,arr[i].second);\\n                }\\n                ans += mx;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int n = difficulty.size() , m = worker.size();\\n        vector<pair<int,int>> arr(n);   \\n        for(int i=0;i<n;i++) {\\n            arr[i] = {difficulty[i] , profit[i]};\\n        }\\n        sort(arr.begin() , arr.end());\\n        int ans = 0;\\n        // for(auto &i : arr) {\\n        //     cout<<i.first<<\" \"<<i.second<<endl;\\n        // }\\n        for(int i=0;i<m;i++) {\\n            int low = 0, high = n-1;\\n            int res = -1;\\n            while(low <= high) {\\n                int mid = low + (high-low) / 2;\\n                if(arr[mid].first <= worker[i]) {\\n                    res = mid;\\n                    low = mid+1;\\n                }\\n                else high = mid - 1;\\n            }\\n            if(res != -1) {\\n                int mx = 0;\\n                for(int i=0;i<=res;i++) {\\n                    mx = max(mx,arr[i].second);\\n                }\\n                ans += mx;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3369923,
                "title": "python-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        d = {}\\n        # mapping the difficulty with the corresponding profit and then storing it in the dictionary\\n        for x in range(len(difficulty)) :\\n            if difficulty[x] in d :\\n                d[difficulty[x]] = max( d[difficulty[x]] , profit[x])  # overwriting with highest value\\n            else:\\n                d[difficulty[x]] = profit[x]\\n\\n        # sorting the dictionary with respect to key\\n        dic = dict(sorted(d.items()))\\n        # sorting the difficulty also\\n        difficulty.sort()\\n    \\n        # now reassigning the profit with the max profit so far after sorting \\n        maxi = 0\\n        for x in dic.keys():\\n            maxi = max(maxi , dic[x] )\\n            dic[x] = maxi\\n            \\n        # calculating the total profit\\n        tot = 0\\n        for i in range(len(worker)) : \\n            # calculate the right position for the difficulty level of the workers\\n            r = bisect.bisect_left(difficulty,worker[i]) \\n            # if the position is at 0 then add the 0th profit only if the difficulty is equal \\n            if r==0: \\n                if difficulty[r] == worker[i] :\\n                    tot += dic[difficulty[r]]\\n                else:\\n                    tot += 0\\n            # if the difficulty is equal then add that profit \\n            elif r<len(difficulty) and difficulty[r] == worker[i] :\\n                tot += dic[difficulty[r]]\\n            # if the difficulty is not equal then add the previous profit \\n            else:\\n                tot += dic[difficulty[r-1]]\\n        return tot\\n```",
                "solutionTags": [
                    "Python3",
                    "Sort"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        d = {}\\n        # mapping the difficulty with the corresponding profit and then storing it in the dictionary\\n        for x in range(len(difficulty)) :\\n            if difficulty[x] in d :\\n                d[difficulty[x]] = max( d[difficulty[x]] , profit[x])  # overwriting with highest value\\n            else:\\n                d[difficulty[x]] = profit[x]\\n\\n        # sorting the dictionary with respect to key\\n        dic = dict(sorted(d.items()))\\n        # sorting the difficulty also\\n        difficulty.sort()\\n    \\n        # now reassigning the profit with the max profit so far after sorting \\n        maxi = 0\\n        for x in dic.keys():\\n            maxi = max(maxi , dic[x] )\\n            dic[x] = maxi\\n            \\n        # calculating the total profit\\n        tot = 0\\n        for i in range(len(worker)) : \\n            # calculate the right position for the difficulty level of the workers\\n            r = bisect.bisect_left(difficulty,worker[i]) \\n            # if the position is at 0 then add the 0th profit only if the difficulty is equal \\n            if r==0: \\n                if difficulty[r] == worker[i] :\\n                    tot += dic[difficulty[r]]\\n                else:\\n                    tot += 0\\n            # if the difficulty is equal then add that profit \\n            elif r<len(difficulty) and difficulty[r] == worker[i] :\\n                tot += dic[difficulty[r]]\\n            # if the difficulty is not equal then add the previous profit \\n            else:\\n                tot += dic[difficulty[r-1]]\\n        return tot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316606,
                "title": "binary-search-easy-to-understand-must-see",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n     vector<int>prefix;\\n    int maxProfitAssignment(vector<int>& diff, vector<int>& profit, vector<int>& worker) {\\n        \\n        int n = diff.size();\\n        vector<pair<int,int>>v;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            int difficulty = diff[i];\\n            int prof = profit[i];\\n            v.push_back(make_pair(difficulty,prof));\\n        }\\n        sort(v.begin(),v.end());\\n\\n        prefix.push_back(v[0].second);\\n        for(int i=1;i<v.size();i++)\\n        {\\n            int val = max(prefix[i-1],v[i].second);\\n            prefix.push_back(val);\\n        }\\n        \\n        int ans = 0;\\n        for(int i=0;i<worker.size();i++)\\n        {\\n            int target = worker[i];\\n            binary_search_(v,0,v.size()-1,target,ans);\\n        }\\n        return ans;\\n    }\\n    void binary_search_(vector<pair<int,int>>&v,int start,int end,int targetdiff,int &ans)\\n    {\\n        int val = 0;\\n        while(start<=end)\\n        {\\n            int mid = (start + ((end - start)/2));\\n\\n            if(targetdiff == v[mid].first)\\n            {\\n               val = max(val,prefix[mid]);\\n               start = mid+1;        \\n            }\\n            else if(targetdiff > v[mid].first)\\n            {\\n                val = max(val,prefix[mid]);\\n                start = mid+1;\\n            }\\n            else\\n            {\\n                end = mid-1;\\n            }\\n        }\\n        if(start>=0 and start<v.size() and v[start].first <= targetdiff)\\n        val = max(val,prefix[start]);\\n\\n        if(end>=0 and end<v.size() and v[end].first <= targetdiff)\\n        val = max(val,prefix[end]);\\n\\n        ans = ans + val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     vector<int>prefix;\\n    int maxProfitAssignment(vector<int>& diff, vector<int>& profit, vector<int>& worker) {\\n        \\n        int n = diff.size();\\n        vector<pair<int,int>>v;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            int difficulty = diff[i];\\n            int prof = profit[i];\\n            v.push_back(make_pair(difficulty,prof));\\n        }\\n        sort(v.begin(),v.end());\\n\\n        prefix.push_back(v[0].second);\\n        for(int i=1;i<v.size();i++)\\n        {\\n            int val = max(prefix[i-1],v[i].second);\\n            prefix.push_back(val);\\n        }\\n        \\n        int ans = 0;\\n        for(int i=0;i<worker.size();i++)\\n        {\\n            int target = worker[i];\\n            binary_search_(v,0,v.size()-1,target,ans);\\n        }\\n        return ans;\\n    }\\n    void binary_search_(vector<pair<int,int>>&v,int start,int end,int targetdiff,int &ans)\\n    {\\n        int val = 0;\\n        while(start<=end)\\n        {\\n            int mid = (start + ((end - start)/2));\\n\\n            if(targetdiff == v[mid].first)\\n            {\\n               val = max(val,prefix[mid]);\\n               start = mid+1;        \\n            }\\n            else if(targetdiff > v[mid].first)\\n            {\\n                val = max(val,prefix[mid]);\\n                start = mid+1;\\n            }\\n            else\\n            {\\n                end = mid-1;\\n            }\\n        }\\n        if(start>=0 and start<v.size() and v[start].first <= targetdiff)\\n        val = max(val,prefix[start]);\\n\\n        if(end>=0 and end<v.size() and v[end].first <= targetdiff)\\n        val = max(val,prefix[end]);\\n\\n        ans = ans + val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2955918,
                "title": "easy-and-understandable-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs per question we have to maximize the profit \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo just make a pair of profit and it\\'s difficulty arrange the pair in ascending order take an iterator and put it in the last index of the pair and do the same thing for worker apply the condition as I have applied in my solution and you will get the required output, If you like this kindly Upvote.     \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)+O(mlogm)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker)\\n    {\\n        int n=difficulty.size(),m=worker.size();\\n        vector<pair<int,int>>jobs(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            jobs[i].first=profit[i];\\n            jobs[i].second=difficulty[i];\\n        }\\n        sort(jobs.begin(),jobs.end());\\n        sort(worker.begin(),worker.end());\\n        int j=m-1,i=n-1,sum=0;\\n        while(j>=0&&i>=0)\\n        {\\n          if(worker[j]>=jobs[i].second)\\n          {\\n              sum+=jobs[i].first;\\n              j--;\\n          }\\n          else\\n          {\\n              i--;\\n          }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker)\\n    {\\n        int n=difficulty.size(),m=worker.size();\\n        vector<pair<int,int>>jobs(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            jobs[i].first=profit[i];\\n            jobs[i].second=difficulty[i];\\n        }\\n        sort(jobs.begin(),jobs.end());\\n        sort(worker.begin(),worker.end());\\n        int j=m-1,i=n-1,sum=0;\\n        while(j>=0&&i>=0)\\n        {\\n          if(worker[j]>=jobs[i].second)\\n          {\\n              sum+=jobs[i].first;\\n              j--;\\n          }\\n          else\\n          {\\n              i--;\\n          }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2761062,
                "title": "python-binary-search-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        \"\"\"\\n        idea: \\n        - zip difficulty and profit\\n        -   sort by difficulty \\n        \\n        - iterate through each worker\\'s ability (worker)\\n        - find the greatest difficulty using binary search , returning the high (bisect right)\\n        -    max_profit += profit_of_worker[index found with binary search]\\n        \"\"\"\\n        diff_prof = [list(i) for i in zip(difficulty, profit)]\\n        diff_prof.sort(key = lambda x: x[0])\\n\\t\\t\\n        # need to make profit be the max up to i\\n        prev = diff_prof[0][1]\\n        for i in range(len(diff_prof)):\\n            diff_prof[i][1] = max(diff_prof[i][1], prev)\\n            prev = diff_prof[i][1]\\n\\n        max_profit = 0\\n        for ability in worker:\\n            index = self.binary_search(diff_prof, ability)\\n            if index >= 0 and index < len(diff_prof):\\n                max_profit += diff_prof[index][1]\\n        return max_profit\\n                \\n            \\n    def binary_search(self, diff_prof: List, ability: int) -> int:\\n        lo, hi = 0 , len(diff_prof) - 1\\n        index = -1\\n        while lo <= hi:\\n            mid = (lo + (hi - lo)//2)\\n            #mid = (hi + lo) // 2\\n            if diff_prof[mid][0] <= ability:\\n                # save index of what a worker can do up to\\n                index = mid \\n                lo = mid + 1\\n            else:\\n                hi = mid - 1\\n        return index\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        \"\"\"\\n        idea: \\n        - zip difficulty and profit\\n        -   sort by difficulty \\n        \\n        - iterate through each worker\\'s ability (worker)\\n        - find the greatest difficulty using binary search , returning the high (bisect right)\\n        -    max_profit += profit_of_worker[index found with binary search]\\n        \"\"\"\\n        diff_prof = [list(i) for i in zip(difficulty, profit)]\\n        diff_prof.sort(key = lambda x: x[0])\\n\\t\\t\\n        # need to make profit be the max up to i\\n        prev = diff_prof[0][1]\\n        for i in range(len(diff_prof)):\\n            diff_prof[i][1] = max(diff_prof[i][1], prev)\\n            prev = diff_prof[i][1]\\n\\n        max_profit = 0\\n        for ability in worker:\\n            index = self.binary_search(diff_prof, ability)\\n            if index >= 0 and index < len(diff_prof):\\n                max_profit += diff_prof[index][1]\\n        return max_profit\\n                \\n            \\n    def binary_search(self, diff_prof: List, ability: int) -> int:\\n        lo, hi = 0 , len(diff_prof) - 1\\n        index = -1\\n        while lo <= hi:\\n            mid = (lo + (hi - lo)//2)\\n            #mid = (hi + lo) // 2\\n            if diff_prof[mid][0] <= ability:\\n                # save index of what a worker can do up to\\n                index = mid \\n                lo = mid + 1\\n            else:\\n                hi = mid - 1\\n        return index\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758748,
                "title": "c-prefixsum-sorting-binarysearch-tc-o-m-n-logn-sc-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int, int>> v;\\n        int n = profit.size();\\n        int m = worker.size();\\n        for(int i = 0; i<n; i++) {\\n            v.push_back({difficulty[i], profit[i]});\\n        }\\n        // Sort the arrays according to lowest difficulty\\n        sort(v.begin(), v.end());\\n       // Now, we will find the job max difficulty which each worker can perform.\\n\\t   // Lets say, in this sortedArray, it comes out to be index 5.\\n\\t   // Since, we do not have the array sorted by profit, we cannot know what is the maxProfit achievable from job with atmost this difficulty.\\n\\t  // Hence, we find the max of Profits at this point. Kind of like how we maintain the prefix Sum.\\n\\t   vector<int> maxProfit(n);\\n        maxProfit[0] = v[0].second;\\n        for(int i = 1; i<n; i++)\\n            maxProfit[i] = max(maxProfit[i-1], v[i].second);\\n       \\n        int output = 0;\\n        \\n        for(int i = 0; i<m; i++) {\\n            int lo = 0, hi = n;\\n\\t\\t\\t// Finding the max index which has difficulty less than equal to worker\\'s calibre.\\\\\\n\\t\\t\\t// Classical maximisation problem of Binary Search.\\n            while(hi - lo > 1) {\\n                int mid = lo + (hi-lo)/2;\\n                if(v[mid].first <= worker[i]) {\\n                    lo = mid;\\n                } else {\\n                    hi = mid;\\n                }\\n            }\\n            int idx = hi-1;\\n            if(v[idx].first <= worker[i])\\n                output += maxProfit[idx];\\n        }\\n        return output;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int, int>> v;\\n        int n = profit.size();\\n        int m = worker.size();\\n        for(int i = 0; i<n; i++) {\\n            v.push_back({difficulty[i], profit[i]});\\n        }\\n        // Sort the arrays according to lowest difficulty\\n        sort(v.begin(), v.end());\\n       // Now, we will find the job max difficulty which each worker can perform.\\n\\t   // Lets say, in this sortedArray, it comes out to be index 5.\\n\\t   // Since, we do not have the array sorted by profit, we cannot know what is the maxProfit achievable from job with atmost this difficulty.\\n\\t  // Hence, we find the max of Profits at this point. Kind of like how we maintain the prefix Sum.\\n\\t   vector<int> maxProfit(n);\\n        maxProfit[0] = v[0].second;\\n        for(int i = 1; i<n; i++)\\n            maxProfit[i] = max(maxProfit[i-1], v[i].second);\\n       \\n        int output = 0;\\n        \\n        for(int i = 0; i<m; i++) {\\n            int lo = 0, hi = n;\\n\\t\\t\\t// Finding the max index which has difficulty less than equal to worker\\'s calibre.\\\\\\n\\t\\t\\t// Classical maximisation problem of Binary Search.\\n            while(hi - lo > 1) {\\n                int mid = lo + (hi-lo)/2;\\n                if(v[mid].first <= worker[i]) {\\n                    lo = mid;\\n                } else {\\n                    hi = mid;\\n                }\\n            }\\n            int idx = hi-1;\\n            if(v[idx].first <= worker[i])\\n                output += maxProfit[idx];\\n        }\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2634281,
                "title": "java-solution-95-faster-method-1-prefix-sum-counting-sort-method-2-treemap",
                "content": "### **Method 1 - Counting-Sort & Prefix-Sum (Faster than 95percent)**\\n\\n```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        \\n        int max=0;\\n        for(int x:difficulty)\\n        {\\n            if(x>max)\\n                max=x;\\n        }\\n        \\n        int[] a = new int[max+1];\\n        \\n        for(int i=0;i<difficulty.length;i++)\\n        {\\n            if(a[difficulty[i]]<profit[i])\\n            a[difficulty[i]] = profit[i];\\n        }\\n        \\n        max=0;\\n        for(int i=0;i<a.length;i++)\\n        {\\n            if(a[i]>max)\\n                max=a[i];\\n            else\\n                a[i]=max;\\n        }\\n        \\n        int sum=0;\\n        for(int x:worker)\\n        {\\n            if(x>=a.length)\\n                x=a.length-1;\\n            sum+=a[x];\\n        }\\n        return sum;\\n    }\\n}\\n```\\n###  **Method 2 - Binary Search using TreeMap**\\n\\n```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        Map<Integer,Integer> map  = new TreeMap<>();\\n       \\n        for(int i=0;i<difficulty.length;i++)\\n        {\\n            if(map.get(difficulty[i])==null || map.get(difficulty[i])<profit[i])\\n            map.put(difficulty[i],profit[i]);\\n        }\\n        \\n        ArrayList<Integer> keys = new ArrayList<>(map.keySet());\\n        \\n        int max=0;\\n        for(var entry: map.entrySet())\\n        {\\n            int key = entry.getKey();\\n            int value = entry.getValue();\\n            \\n            if(value>max)\\n            {\\n                max = value;\\n            }\\n            else{\\n                map.put(key,max);\\n            }\\n        }\\n        \\n        int sum=0;\\n        for(int x:worker)\\n        {\\n            int idx = Collections.binarySearch(keys,x);\\n            if(idx<0)\\n            {\\n                idx = -1*(idx+1);\\n                idx--;\\n            }\\n            if(idx>=0)\\n            sum+=map.get(keys.get(idx));\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        \\n        int max=0;\\n        for(int x:difficulty)\\n        {\\n            if(x>max)\\n                max=x;\\n        }\\n        \\n        int[] a = new int[max+1];\\n        \\n        for(int i=0;i<difficulty.length;i++)\\n        {\\n            if(a[difficulty[i]]<profit[i])\\n            a[difficulty[i]] = profit[i];\\n        }\\n        \\n        max=0;\\n        for(int i=0;i<a.length;i++)\\n        {\\n            if(a[i]>max)\\n                max=a[i];\\n            else\\n                a[i]=max;\\n        }\\n        \\n        int sum=0;\\n        for(int x:worker)\\n        {\\n            if(x>=a.length)\\n                x=a.length-1;\\n            sum+=a[x];\\n        }\\n        return sum;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        Map<Integer,Integer> map  = new TreeMap<>();\\n       \\n        for(int i=0;i<difficulty.length;i++)\\n        {\\n            if(map.get(difficulty[i])==null || map.get(difficulty[i])<profit[i])\\n            map.put(difficulty[i],profit[i]);\\n        }\\n        \\n        ArrayList<Integer> keys = new ArrayList<>(map.keySet());\\n        \\n        int max=0;\\n        for(var entry: map.entrySet())\\n        {\\n            int key = entry.getKey();\\n            int value = entry.getValue();\\n            \\n            if(value>max)\\n            {\\n                max = value;\\n            }\\n            else{\\n                map.put(key,max);\\n            }\\n        }\\n        \\n        int sum=0;\\n        for(int x:worker)\\n        {\\n            int idx = Collections.binarySearch(keys,x);\\n            if(idx<0)\\n            {\\n                idx = -1*(idx+1);\\n                idx--;\\n            }\\n            if(idx>=0)\\n            sum+=map.get(keys.get(idx));\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2497557,
                "title": "cpp-binary-search-lowerbound-greedy",
                "content": "```\\n//time complexity-mlogn\\n//first we wiil sort the array according to difficulty and store max profit according to diificulty\\n//find the lowerbound of capacity of current worker and add max profit to the answer\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n    \\n        int n=profit.size();\\n        vector<pair<int,int>> v;\\n        for(int i=0;i<n;i++) v.push_back({difficulty[i],profit[i]});\\n        \\n        sort(v.begin(),v.end());\\n        \\n        vector<int> mx(n);\\n        mx[0]=(v[0].second);\\n        //storin max profit at ith index\\n        for(int i=1;i<n;i++)\\n            mx[i]=max(mx[i-1],v[i].second);\\n        \\n        int m=worker.size();\\n        int ans(0);\\n        for(int i=0;i<m;i++){\\n            int key=worker[i];\\n            int l(0),h(n-1),mid;\\n            while(h-l>1){\\n                mid=l+(h-l)/2;\\n                if(v[mid].first<key) l=mid+1;\\n                else h=mid;\\n            }\\n            int ind=-1;\\n            if(v[l].first>=key) ind=l;\\n            else if(v[h].first>=key) ind=h;\\n            \\n            //if there is no lowerbound then worker can work at any capacity then we will take maximum profit\\n            if(ind==-1) ans+=mx[n-1];\\n            else if(v[ind].first==key){\\n                while(ind<n && v[ind].first==key) ind++;\\n                ans+=mx[ind-1];\\n            } \\n            else if(v[ind].first>key) ans+=(ind-1>=0)?mx[ind-1]:0;\\n        }\\n        return ans;\\n    }\\n};\\nif you like the solution please upvote and like it.\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Binary Tree"
                ],
                "code": "```\\n//time complexity-mlogn\\n//first we wiil sort the array according to difficulty and store max profit according to diificulty\\n//find the lowerbound of capacity of current worker and add max profit to the answer\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n    \\n        int n=profit.size();\\n        vector<pair<int,int>> v;\\n        for(int i=0;i<n;i++) v.push_back({difficulty[i],profit[i]});\\n        \\n        sort(v.begin(),v.end());\\n        \\n        vector<int> mx(n);\\n        mx[0]=(v[0].second);\\n        //storin max profit at ith index\\n        for(int i=1;i<n;i++)\\n            mx[i]=max(mx[i-1],v[i].second);\\n        \\n        int m=worker.size();\\n        int ans(0);\\n        for(int i=0;i<m;i++){\\n            int key=worker[i];\\n            int l(0),h(n-1),mid;\\n            while(h-l>1){\\n                mid=l+(h-l)/2;\\n                if(v[mid].first<key) l=mid+1;\\n                else h=mid;\\n            }\\n            int ind=-1;\\n            if(v[l].first>=key) ind=l;\\n            else if(v[h].first>=key) ind=h;\\n            \\n            //if there is no lowerbound then worker can work at any capacity then we will take maximum profit\\n            if(ind==-1) ans+=mx[n-1];\\n            else if(v[ind].first==key){\\n                while(ind<n && v[ind].first==key) ind++;\\n                ans+=mx[ind-1];\\n            } \\n            else if(v[ind].first>key) ans+=(ind-1>=0)?mx[ind-1]:0;\\n        }\\n        return ans;\\n    }\\n};\\nif you like the solution please upvote and like it.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2328533,
                "title": "segment-tree-c-solution",
                "content": "**Prerequisite -> Segment trees theory.** \\n[**This**](https://www.youtube.com/watch?v=2FShdqn-Oz8&t=2355s) video greatly helped me understand segment trees. Errichto is awesome :)\\n\\n**C++**\\n```\\nclass Solution {\\n    vector<int> tree;\\n    int getMax(int i, int l, int r, int ql, int qr){\\n        if(ql<=l && r<=qr) return tree[i];\\n        if(qr<l || ql>r) return -1;\\n        int midl=l+((r-l)>>1);\\n        return max(getMax(i<<1, l, midl, ql, qr), getMax((i<<1)+1, midl+1, r, ql, qr));\\n    }\\n    inline int countOnes(int n){ //count total set bits in an integer\\n        int c=0;\\n        while(n) c+=1, n=n&(n-1);\\n        return c;\\n    }\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int n=difficulty.size(), cost=0;\\n        vector<pair<int, int>> p;\\n        for(int i=0; i<n; i++)\\n            p.push_back({difficulty[i], profit[i]});\\n        sort(p.begin(), p.end());\\n        while(countOnes(n)!=1){ //while n is not a power of 2 (we are basically padding the vector p with zeroes to have a size thats a power of 2).\\n            p.push_back({(int)1000000, 0});\\n            n++;\\n        }\\n        tree=vector<int>(n<<1); //n<<1 means n*2\\n        for(int i=0; i<n; i++) tree[i+n]=p[i].second;\\n        for(int i=n-1; i>=1; i--) tree[i]=max(tree[i<<1],tree[(i<<1)+1]);\\n        for(auto &i: worker) if(i>=p[0].first){\\n            int a=0, b=n-1;\\n            while(a<b){\\n                int mid=b+(a-b)/2;\\n                p[mid].first>i?\\n                    b=mid-1:\\n                    a=mid;\\n            }\\n            cost+=getMax(1, 0, n-1, 0, a); //getMax() will give max values in the range [0,a].\\n        }\\n        return cost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> tree;\\n    int getMax(int i, int l, int r, int ql, int qr){\\n        if(ql<=l && r<=qr) return tree[i];\\n        if(qr<l || ql>r) return -1;\\n        int midl=l+((r-l)>>1);\\n        return max(getMax(i<<1, l, midl, ql, qr), getMax((i<<1)+1, midl+1, r, ql, qr));\\n    }\\n    inline int countOnes(int n){ //count total set bits in an integer\\n        int c=0;\\n        while(n) c+=1, n=n&(n-1);\\n        return c;\\n    }\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int n=difficulty.size(), cost=0;\\n        vector<pair<int, int>> p;\\n        for(int i=0; i<n; i++)\\n            p.push_back({difficulty[i], profit[i]});\\n        sort(p.begin(), p.end());\\n        while(countOnes(n)!=1){ //while n is not a power of 2 (we are basically padding the vector p with zeroes to have a size thats a power of 2).\\n            p.push_back({(int)1000000, 0});\\n            n++;\\n        }\\n        tree=vector<int>(n<<1); //n<<1 means n*2\\n        for(int i=0; i<n; i++) tree[i+n]=p[i].second;\\n        for(int i=n-1; i>=1; i--) tree[i]=max(tree[i<<1],tree[(i<<1)+1]);\\n        for(auto &i: worker) if(i>=p[0].first){\\n            int a=0, b=n-1;\\n            while(a<b){\\n                int mid=b+(a-b)/2;\\n                p[mid].first>i?\\n                    b=mid-1:\\n                    a=mid;\\n            }\\n            cost+=getMax(1, 0, n-1, 0, a); //getMax() will give max values in the range [0,a].\\n        }\\n        return cost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2272936,
                "title": "java-solution-using-priorityqueue",
                "content": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        PriorityQueue<int[]> pq=new PriorityQueue<>((a,b)->(b[1]-a[1]));\\n        for(int i=0;i<profit.length;i++)\\n        {\\n            pq.add(new int[]{difficulty[i],profit[i]});\\n        }\\n        Arrays.sort(worker);\\n        int p=0;\\n        for(int i=worker.length-1;i>=0 && !pq.isEmpty();i--)\\n        {\\n            if(worker[i]>=pq.peek()[0])\\n                p=p+pq.peek()[1];\\n            else\\n            {\\n                while(!pq.isEmpty() && worker[i]<pq.peek()[0])\\n                    pq.poll();\\n                if(!pq.isEmpty())\\n                  p=p+pq.peek()[1];\\n            }\\n        }\\n        return p;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        PriorityQueue<int[]> pq=new PriorityQueue<>((a,b)->(b[1]-a[1]));\\n        for(int i=0;i<profit.length;i++)\\n        {\\n            pq.add(new int[]{difficulty[i],profit[i]});\\n        }\\n        Arrays.sort(worker);\\n        int p=0;\\n        for(int i=worker.length-1;i>=0 && !pq.isEmpty();i--)\\n        {\\n            if(worker[i]>=pq.peek()[0])\\n                p=p+pq.peek()[1];\\n            else\\n            {\\n                while(!pq.isEmpty() && worker[i]<pq.peek()[0])\\n                    pq.poll();\\n                if(!pq.isEmpty())\\n                  p=p+pq.peek()[1];\\n            }\\n        }\\n        return p;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2203850,
                "title": "c-binary-search-sorting-approach",
                "content": "```\\n// This is the Simple Binary Search Solution.\\n// First I am Sort Difficulty Vector and then after sorting I need to take Care of the Respective values.\\n// And For that I need map to store the corresponding values of profit vector.\\n// Now After Storing Values I just need to perform the upper bound for each value of worker vector and then ind-- \\n// I did because I need less than aur equal to value but upper bound does opposite.\\n// and then From beginning upto that index i am searching maximum value present in profit vector adding that to my ans will give me Result.\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int ans = 0;\\n        map<int,int>seen;\\n        int m = profit.size();\\n        for(int i = 0 ; i < m ; i++)\\n        {\\n            seen[difficulty[i]] = max(seen[difficulty[i]],profit[i]);\\n        }\\n        sort(difficulty.begin(),difficulty.end());\\n        int i = 0;\\n        for(auto it : difficulty)\\n        {\\n            profit[i] = seen[it];\\n            i++;\\n        }\\n        int n = worker.size();\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            int ind = upper_bound(difficulty.begin(),difficulty.end(),worker[i]) - difficulty.begin();\\n            ind--;\\n            if(ind<0)\\n                continue;\\n            int max1 = *max_element(profit.begin(),profit.begin()+ind+1);\\n            ans+=max1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please Upvote If you Like The Solution......**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\n// This is the Simple Binary Search Solution.\\n// First I am Sort Difficulty Vector and then after sorting I need to take Care of the Respective values.\\n// And For that I need map to store the corresponding values of profit vector.\\n// Now After Storing Values I just need to perform the upper bound for each value of worker vector and then ind-- \\n// I did because I need less than aur equal to value but upper bound does opposite.\\n// and then From beginning upto that index i am searching maximum value present in profit vector adding that to my ans will give me Result.\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int ans = 0;\\n        map<int,int>seen;\\n        int m = profit.size();\\n        for(int i = 0 ; i < m ; i++)\\n        {\\n            seen[difficulty[i]] = max(seen[difficulty[i]],profit[i]);\\n        }\\n        sort(difficulty.begin(),difficulty.end());\\n        int i = 0;\\n        for(auto it : difficulty)\\n        {\\n            profit[i] = seen[it];\\n            i++;\\n        }\\n        int n = worker.size();\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            int ind = upper_bound(difficulty.begin(),difficulty.end(),worker[i]) - difficulty.begin();\\n            ind--;\\n            if(ind<0)\\n                continue;\\n            int max1 = *max_element(profit.begin(),profit.begin()+ind+1);\\n            ans+=max1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2186392,
                "title": "c-code-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(int x,vector<int> &diff,vector<int> &pro,vector<int> &worker){\\n        int i;\\n        int curr=0;\\n        \\n        for (i=0; i<worker.size(); i++){\\n            auto it=upper_bound(diff.begin(),diff.end(),worker[i]);\\n            \\n            if (it!=diff.end() && it!=diff.begin()){\\n                int idx=it-diff.begin()-1;\\n                curr+=pro[idx];\\n            }\\n            if (it==diff.end()){\\n                curr+=pro.back();\\n            }\\n        }\\n        \\n     return curr>=x;\\n    }\\n    \\n    int maxProfitAssignment(vector<int>& diff, vector<int>& pro, vector<int>& worker) {\\n        int l=0;\\n        int r=1e9+5;\\n        \\n        int i;\\n        vector<pair<int,int>> v;\\n        \\n        for (i=0; i<pro.size(); i++){\\n            v.push_back({diff[i],pro[i]});\\n        }\\n        \\n        sort(v.begin(),v.end());\\n        \\n        for (i=1; i<v.size(); i++){\\n            v[i].second=max(v[i].second,v[i-1].second);\\n        }\\n        for (i=0; i<v.size(); i++){\\n            diff[i]=v[i].first;\\n            pro[i]=v[i].second;\\n        }\\n        \\n        while (r-l>1){\\n            int mid=l+(r-l)/2;\\n            if (check(mid,diff,pro,worker)){\\n                l=mid;\\n            }\\n            else{\\n                r=mid-1;\\n            }\\n        }\\n        \\n        if (check(r,diff,pro,worker)){\\n            return r;\\n        }\\n        else{\\n            return l;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(int x,vector<int> &diff,vector<int> &pro,vector<int> &worker){\\n        int i;\\n        int curr=0;\\n        \\n        for (i=0; i<worker.size(); i++){\\n            auto it=upper_bound(diff.begin(),diff.end(),worker[i]);\\n            \\n            if (it!=diff.end() && it!=diff.begin()){\\n                int idx=it-diff.begin()-1;\\n                curr+=pro[idx];\\n            }\\n            if (it==diff.end()){\\n                curr+=pro.back();\\n            }\\n        }\\n        \\n     return curr>=x;\\n    }\\n    \\n    int maxProfitAssignment(vector<int>& diff, vector<int>& pro, vector<int>& worker) {\\n        int l=0;\\n        int r=1e9+5;\\n        \\n        int i;\\n        vector<pair<int,int>> v;\\n        \\n        for (i=0; i<pro.size(); i++){\\n            v.push_back({diff[i],pro[i]});\\n        }\\n        \\n        sort(v.begin(),v.end());\\n        \\n        for (i=1; i<v.size(); i++){\\n            v[i].second=max(v[i].second,v[i-1].second);\\n        }\\n        for (i=0; i<v.size(); i++){\\n            diff[i]=v[i].first;\\n            pro[i]=v[i].second;\\n        }\\n        \\n        while (r-l>1){\\n            int mid=l+(r-l)/2;\\n            if (check(mid,diff,pro,worker)){\\n                l=mid;\\n            }\\n            else{\\n                r=mid-1;\\n            }\\n        }\\n        \\n        if (check(r,diff,pro,worker)){\\n            return r;\\n        }\\n        else{\\n            return l;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2166941,
                "title": "c-solution-using-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int n=difficulty.size();\\n        vector<pair<int,int>> vec(n);\\n        for(int i=0;i<n;i++) vec[i]={difficulty[i],profit[i]};\\n        sort(vec.begin(),vec.end());\\n        for(int i=1;i<n;i++) vec[i].second=max(vec[i].second,vec[i-1].second);\\n        int cost=0;\\n        for(auto it:worker){\\n            int low=0,high=n-1;\\n            while(low<=high){\\n                int mid=(low+high)/2;\\n                if(vec[mid].first<=it) low=mid+1;\\n                else high=mid-1;\\n            }\\n            if(high>=0) cost+=vec[low-1].second;\\n        }\\n        return cost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int n=difficulty.size();\\n        vector<pair<int,int>> vec(n);\\n        for(int i=0;i<n;i++) vec[i]={difficulty[i],profit[i]};\\n        sort(vec.begin(),vec.end());\\n        for(int i=1;i<n;i++) vec[i].second=max(vec[i].second,vec[i-1].second);\\n        int cost=0;\\n        for(auto it:worker){\\n            int low=0,high=n-1;\\n            while(low<=high){\\n                int mid=(low+high)/2;\\n                if(vec[mid].first<=it) low=mid+1;\\n                else high=mid-1;\\n            }\\n            if(high>=0) cost+=vec[low-1].second;\\n        }\\n        return cost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2166157,
                "title": "golang-sorting",
                "content": "Pretty much the same answer as the one in the solution section.\\n\\n```\\n\\ntype job struct {\\n\\tdifficulty int\\n\\tprofit     int\\n}\\n\\nfunc maxProfitAssignment(difficulty []int, profit []int, worker []int) int {\\n\\tjobs := []job{}\\n\\n\\tfor i := 0; i < len(difficulty); i++ {\\n\\t\\ttemp := job{difficulty[i], profit[i]}\\n\\t\\tjobs = append(jobs, temp)\\n\\t}\\n\\n\\tsort.Slice(jobs, func(i int, j int) bool {\\n\\t\\treturn jobs[i].difficulty < jobs[j].difficulty\\n\\t})\\n\\n\\tsort.Sort(sort.IntSlice(worker))\\n\\n\\tans, i, best := 0, 0, 0\\n\\n\\tfor _, single_worker := range worker {\\n\\n\\t\\tfor i < len(worker) && single_worker >= jobs[i].difficulty {\\n\\t\\t\\tbest = int(math.Max(float64(best), float64(jobs[i].profit)))\\n\\t\\t\\ti++\\n\\t\\t}\\n\\n\\t\\tans += best\\n\\t}\\n\\n\\treturn ans\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n\\ntype job struct {\\n\\tdifficulty int\\n\\tprofit     int\\n}\\n\\nfunc maxProfitAssignment(difficulty []int, profit []int, worker []int) int {\\n\\tjobs := []job{}\\n\\n\\tfor i := 0; i < len(difficulty); i++ {\\n\\t\\ttemp := job{difficulty[i], profit[i]}\\n\\t\\tjobs = append(jobs, temp)\\n\\t}\\n\\n\\tsort.Slice(jobs, func(i int, j int) bool {\\n\\t\\treturn jobs[i].difficulty < jobs[j].difficulty\\n\\t})\\n\\n\\tsort.Sort(sort.IntSlice(worker))\\n\\n\\tans, i, best := 0, 0, 0\\n\\n\\tfor _, single_worker := range worker {\\n\\n\\t\\tfor i < len(worker) && single_worker >= jobs[i].difficulty {\\n\\t\\t\\tbest = int(math.Max(float64(best), float64(jobs[i].profit)))\\n\\t\\t\\ti++\\n\\t\\t}\\n\\n\\t\\tans += best\\n\\t}\\n\\n\\treturn ans\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2151309,
                "title": "c-sort-and-binary-search",
                "content": "```\\nusing pii=pair<int,int>;\\n    int solve(int x,vector<pii> &v){\\n        int l=0,r=size(v)-1,ans=-1;\\n        while(l<=r){\\n            int m=(l+r)/2;\\n            if(v[m].first<=x) ans=m,l=m+1; //finding largest difficulty that is lesser than or equal to ability of worker\\n            else r=m-1;\\n        }\\n        if(ans==-1) return 0;\\n        return v[ans].second;\\n    }\\n    int maxProfitAssignment(vector<int>& a, vector<int>& b, vector<int>& c) {\\n        vector<pii> v;\\n        int n=size(a),maxi=INT_MIN;\\n        for(int i=0;i<n;i++) v.push_back({a[i],b[i]});\\n        sort(begin(v),end(v));\\n        for(int i=0;i<n;i++){\\n            maxi=max(maxi,v[i].second); // for perticular difficulty maximum possible profit\\n            v[i].second=maxi;\\n        }\\n        int res=0;\\n        for(auto &x:c) res+=solve(x,v);\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nusing pii=pair<int,int>;\\n    int solve(int x,vector<pii> &v){\\n        int l=0,r=size(v)-1,ans=-1;\\n        while(l<=r){\\n            int m=(l+r)/2;\\n            if(v[m].first<=x) ans=m,l=m+1; //finding largest difficulty that is lesser than or equal to ability of worker\\n            else r=m-1;\\n        }\\n        if(ans==-1) return 0;\\n        return v[ans].second;\\n    }\\n    int maxProfitAssignment(vector<int>& a, vector<int>& b, vector<int>& c) {\\n        vector<pii> v;\\n        int n=size(a),maxi=INT_MIN;\\n        for(int i=0;i<n;i++) v.push_back({a[i],b[i]});\\n        sort(begin(v),end(v));\\n        for(int i=0;i<n;i++){\\n            maxi=max(maxi,v[i].second); // for perticular difficulty maximum possible profit\\n            v[i].second=maxi;\\n        }\\n        int res=0;\\n        for(auto &x:c) res+=solve(x,v);\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2142170,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Sorting && Binary Search***\\n\\n* ***Time Complexity : O(NlogN)***\\n\\n* ***Space Complexity : O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        \\n        int n = difficulty.size();\\n        \\n        int m = worker.size();\\n        \\n        // make pair of difficulty[i] and profit[i]\\n        \\n        vector<pair<int, int>> arr(n);\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            arr[i] = {difficulty[i], profit[i]};\\n        }\\n        \\n        // sort the array\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        sort(difficulty.begin(), difficulty.end());\\n        \\n        // update the profit with maximum profit till ith index\\n        \\n        // so that we can choose a work with maximum profit in constant time\\n        \\n        int maxi = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            maxi = max(maxi, arr[i].second);\\n            \\n            arr[i].second = maxi;\\n        }\\n        \\n        // find the max_profit\\n        \\n        int max_profit = 0;\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            int idx = upper_bound(difficulty.begin(), difficulty.end(), worker[i]) - difficulty.begin();\\n            \\n            idx--;\\n    \\n            if(idx >= 0)\\n            {\\n                max_profit += arr[idx].second;\\n            }\\n        }\\n        \\n        return max_profit;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        \\n        int n = difficulty.size();\\n        \\n        int m = worker.size();\\n        \\n        // make pair of difficulty[i] and profit[i]\\n        \\n        vector<pair<int, int>> arr(n);\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            arr[i] = {difficulty[i], profit[i]};\\n        }\\n        \\n        // sort the array\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        sort(difficulty.begin(), difficulty.end());\\n        \\n        // update the profit with maximum profit till ith index\\n        \\n        // so that we can choose a work with maximum profit in constant time\\n        \\n        int maxi = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            maxi = max(maxi, arr[i].second);\\n            \\n            arr[i].second = maxi;\\n        }\\n        \\n        // find the max_profit\\n        \\n        int max_profit = 0;\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            int idx = upper_bound(difficulty.begin(), difficulty.end(), worker[i]) - difficulty.begin();\\n            \\n            idx--;\\n    \\n            if(idx >= 0)\\n            {\\n                max_profit += arr[idx].second;\\n            }\\n        }\\n        \\n        return max_profit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2010515,
                "title": "easy-sorting-solution-c",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        \\n        int ans = 0;\\n        vector<pair<int,int>> jobs;\\n        \\n        for(int i = 0; i < profit.size(); i++) \\n        {\\n            jobs.push_back({profit[i], difficulty[i]});\\n        }\\n        sort(jobs.begin(),jobs.end());\\n        sort(worker.begin(), worker.end());\\n        //sorting both arrays\\n        int j = profit.size()-1;\\n        for(int worker.size()-1; i >= 0; i--) {\\n            while(j >= 0 && jobs[j].second > worker[i]) {\\n                j--;\\n            }\\n            if(j < 0) break;\\n            ans = ans+jobs[j].first;\\n            \\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1976691,
                "title": "c-easy-explaination",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int,int>> v;//make pair on difficulty and profit\\n        sort(worker.begin(),worker.end());//sort worker, later will depend on it to avoid more difficult than worker\\'s ability put in the vector\\n        for(int i=0;i<difficulty.size();i++)\\n        {\\n            if(difficulty[i]>worker[worker.size()-1])//if difficulty is more then worker\\'s ability\\n                continue;\\n            v.push_back({difficulty[i],profit[i]});//make pair on difficulty and profit\\n        }\\n        sort(v.begin(),v.end());//sort, later will use to make boundary\\n        \\n        int res=0;\\n        int lower=0;//the lower boundary(last worker\\'s most profit)\\n        for(int i=0;i<worker.size();i++)\\n        {\\n            int mmax=0;\\n            for(int j=lower;j<v.size();j++)//start with lower boundary\\n            {\\n                if(v[j].first>worker[i])//if now is more difficult than worker\\'s ability\\n                    break;\\n                if(mmax<v[j].second)//record the most profit\\n                {\\n                    lower=j;//the next worker\\'s lower boundary is here\\n                    mmax=v[j].second;\\n                }\\n            }\\n            res+=mmax;\\n        }\\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int,int>> v;//make pair on difficulty and profit\\n        sort(worker.begin(),worker.end());//sort worker, later will depend on it to avoid more difficult than worker\\'s ability put in the vector\\n        for(int i=0;i<difficulty.size();i++)\\n        {\\n            if(difficulty[i]>worker[worker.size()-1])//if difficulty is more then worker\\'s ability\\n                continue;\\n            v.push_back({difficulty[i],profit[i]}",
                "codeTag": "Java"
            },
            {
                "id": 1945986,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& diff, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int,int>> v{};\\n        int n=diff.size();\\n        for(int i=0;i<n;i++){\\n            v.push_back({diff[i],profit[i]});\\n        }\\n        sort(v.begin(),v.end());\\n        int maxi=0,ans=0;\\n        for(int i=0;i<n;i++){\\n            maxi=max(maxi,v[i].second);\\n            profit[i] = maxi;\\n            diff[i] = v[i].first;\\n        }\\n        for(auto w:worker){\\n            int ub = upper_bound(diff.begin(),diff.end(),w)-diff.begin()-1;\\n            if(ub>=0) ans+=profit[ub];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& diff, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int,int>> v{};\\n        int n=diff.size();\\n        for(int i=0;i<n;i++){\\n            v.push_back({diff[i],profit[i]});\\n        }\\n        sort(v.begin(),v.end());\\n        int maxi=0,ans=0;\\n        for(int i=0;i<n;i++){\\n            maxi=max(maxi,v[i].second);\\n            profit[i] = maxi;\\n            diff[i] = v[i].first;\\n        }\\n        for(auto w:worker){\\n            int ub = upper_bound(diff.begin(),diff.end(),w)-diff.begin()-1;\\n            if(ub>=0) ans+=profit[ub];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1926631,
                "title": "c-binary-search-map-sort-three-simple-solution-with-explanation",
                "content": "# Solution 1 (R)\\n\\nWe construct `idx[i]` and sort `idx` based on `difficulty`. Also, use `maxv[idx[i]]` as best profit we have from `idx[0]`  to `idx[i]`. This is the best value that is based on sorted `difficulty`.\\n\\nThen for each value `w` in `worker`, use binary search to get the index of largest value that is \\u2264 `w` using `idx` and `difficulty` , `res += maxv[idx[right]]` .\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<int> idx;\\n        int n = profit.size();\\n        for (int i = 0; i < n; ++i) {\\n            idx.push_back(i);\\n        }\\n        sort(idx.begin(), idx.end(), [&difficulty](const int &a, const int &b){\\n            return difficulty[a] < difficulty[b];\\n        });\\n        vector<int> maxv;\\n        int m = 0;\\n        for (int i = 0; i < n; ++i) {\\n            m = max(m, profit[idx[i]]);\\n            maxv.push_back(m);\\n        }\\n        int res = 0;\\n        for (auto &w: worker) {\\n            int left = 0, right = n-1;\\n            while (left <= right) {\\n                int mid = left + (right-left)/2;\\n                if (difficulty[idx[mid]] <= w) {\\n                    left = mid+1;\\n                } else {\\n                    right = mid-1;\\n                }\\n            }\\n            if (right >= 0) {\\n                res += maxv[right];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n`n` : size of `difficulty` , `m` : size of `worker`\\n\\n**Time:** `O(nlogn + mlogn)` \\n**Space:** `O(n)` \\n\\n# Solution 2 (R)\\n\\nWe can also sort `data` , which is constructed by `difficulty` and `profit` , as well as `worker` .\\n\\nThen for each worker that is sorted, we maintain `best` as best profit we have until now and try to traverse `data` until its difficulty > the effort of the worker and update `best` at the same time.\\n\\nAfter that, `res += best` .\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int n = profit.size();\\n        vector<array<int,2>> data;\\n        for (int i = 0; i < n; ++i) {\\n            data.push_back({difficulty[i], profit[i]});\\n        }\\n        sort(worker.begin(), worker.end());\\n        sort(data.begin(), data.end());\\n        int i = 0, res = 0, best = 0;\\n        for (auto &w: worker) {\\n            while (i < n && data[i][0] <= w) {\\n                best = max(best, data[i++][1]);\\n            }\\n            res += best;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n`n` : size of `difficulty` , `m` : size of `worker`\\n\\n**Time:** `O(nlogn + mlogm)`   \\n**Space:** `O(n)`  \\n\\n# Solution 3 (R)\\n\\nWe use `map` to sort `difficulty` and since there might be multiple profit for same difficulty, need to pick max value.\\n\\nAfter that, traverse `map` again to fill each value with best value we have until now.\\n\\nLast, traverse `worker` and use upper_bound to get last largest value \\u2264 `worker` and find its value.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int n = profit.size(), res = 0, best = 0;\\n        map<int,int> data;\\n        for (int i = 0; i < n; ++i) {\\n            data[difficulty[i]] = max(data[difficulty[i]], profit[i]);\\n        }\\n        for (auto &[d, p]: data) {\\n            best = max(best, p);\\n            p = best;\\n        }\\n        for (auto &w: worker) {\\n            res += prev(data.upper_bound(w))->second;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n`n` : size of `difficulty` , `m` : size of `worker`\\n\\n**Time:** `O(nlogn + mlogn)`   \\n**Space:** `O(n)`",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<int> idx;\\n        int n = profit.size();\\n        for (int i = 0; i < n; ++i) {\\n            idx.push_back(i);\\n        }\\n        sort(idx.begin(), idx.end(), [&difficulty](const int &a, const int &b){\\n            return difficulty[a] < difficulty[b];\\n        });\\n        vector<int> maxv;\\n        int m = 0;\\n        for (int i = 0; i < n; ++i) {\\n            m = max(m, profit[idx[i]]);\\n            maxv.push_back(m);\\n        }\\n        int res = 0;\\n        for (auto &w: worker) {\\n            int left = 0, right = n-1;\\n            while (left <= right) {\\n                int mid = left + (right-left)/2;\\n                if (difficulty[idx[mid]] <= w) {\\n                    left = mid+1;\\n                } else {\\n                    right = mid-1;\\n                }\\n            }\\n            if (right >= 0) {\\n                res += maxv[right];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int n = profit.size();\\n        vector<array<int,2>> data;\\n        for (int i = 0; i < n; ++i) {\\n            data.push_back({difficulty[i], profit[i]});\\n        }\\n        sort(worker.begin(), worker.end());\\n        sort(data.begin(), data.end());\\n        int i = 0, res = 0, best = 0;\\n        for (auto &w: worker) {\\n            while (i < n && data[i][0] <= w) {\\n                best = max(best, data[i++][1]);\\n            }\\n            res += best;\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int n = profit.size(), res = 0, best = 0;\\n        map<int,int> data;\\n        for (int i = 0; i < n; ++i) {\\n            data[difficulty[i]] = max(data[difficulty[i]], profit[i]);\\n        }\\n        for (auto &[d, p]: data) {\\n            best = max(best, p);\\n            p = best;\\n        }\\n        for (auto &w: worker) {\\n            res += prev(data.upper_bound(w))->second;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1871898,
                "title": "java-simple-solution-using-priorityqueue",
                "content": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        PriorityQueue<int[]> task = new PriorityQueue<>((a,b) -> b[1] - a[1]);\\n        \\n        for(int i=0; i<profit.length; i++)\\n            task.offer(new int[]{difficulty[i], profit[i]});\\n        \\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        \\n        for(int i: worker)\\n            pq.offer(i);\\n        \\n        int sum = 0;\\n        \\n        while(!pq.isEmpty() && !task.isEmpty()){\\n            if(pq.peek() >= task.peek()[0]){\\n                while(!pq.isEmpty() && task.peek()[0] <= pq.peek()){\\n                    sum += task.peek()[1];\\n                    pq.poll();\\n                }\\n            }\\n            else{\\n                while(!task.isEmpty() && task.peek()[0] > pq.peek())\\n                    task.poll();\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        PriorityQueue<int[]> task = new PriorityQueue<>((a,b) -> b[1] - a[1]);\\n        \\n        for(int i=0; i<profit.length; i++)\\n            task.offer(new int[]{difficulty[i], profit[i]});\\n        \\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        \\n        for(int i: worker)\\n            pq.offer(i);\\n        \\n        int sum = 0;\\n        \\n        while(!pq.isEmpty() && !task.isEmpty()){\\n            if(pq.peek() >= task.peek()[0]){\\n                while(!pq.isEmpty() && task.peek()[0] <= pq.peek()){\\n                    sum += task.peek()[1];\\n                    pq.poll();\\n                }\\n            }\\n            else{\\n                while(!task.isEmpty() && task.peek()[0] > pq.peek())\\n                    task.poll();\\n            }\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1843630,
                "title": "java-with-treemap-neatly-bubbling-up-maximum",
                "content": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        List<Job> jobs = new ArrayList<>();\\n        int n = difficulty.length;\\n        for(int i=0; i<n; i++){\\n            jobs.add(new Job(difficulty[i], profit[i]));\\n        }\\n\\t\\t// sort based on difficulty (max profit in case of same difficulty)\\n        Collections.sort(jobs, new Comparator<>(){\\n            public int compare(Job j1, Job j2){\\n                if(j1.d == j2.d){\\n                    return j2.p - j1.p;\\n                }\\n                return j1.d - j2.d;\\n            }\\n        });\\n        int maxProfitSoFar = 0;\\n\\t\\t// bubble up the max profit seen so far from left to right \\n        for(Job j : jobs){\\n            maxProfitSoFar = Math.max(maxProfitSoFar, j.p);\\n            j.p = maxProfitSoFar;\\n        }\\n        \\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        for(Job j : jobs){\\n            map.put(j.d, j.p);\\n        }\\n        \\n        int res = 0;\\n        for(int m : worker){\\n            Integer difficultyKey = map.floorKey(m);\\n            if(difficultyKey != null){\\n                res += map.get(difficultyKey);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\nclass Job {\\n    int d;\\n    int p;\\n    Job(int _d, int _p){\\n        d = _d;\\n        p = _p;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        List<Job> jobs = new ArrayList<>();\\n        int n = difficulty.length;\\n        for(int i=0; i<n; i++){\\n            jobs.add(new Job(difficulty[i], profit[i]));\\n        }\\n\\t\\t// sort based on difficulty (max profit in case of same difficulty)\\n        Collections.sort(jobs, new Comparator<>(){\\n            public int compare(Job j1, Job j2){\\n                if(j1.d == j2.d){\\n                    return j2.p - j1.p;\\n                }\\n                return j1.d - j2.d;\\n            }\\n        });\\n        int maxProfitSoFar = 0;\\n\\t\\t// bubble up the max profit seen so far from left to right \\n        for(Job j : jobs){\\n            maxProfitSoFar = Math.max(maxProfitSoFar, j.p);\\n            j.p = maxProfitSoFar;\\n        }\\n        \\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        for(Job j : jobs){\\n            map.put(j.d, j.p);\\n        }\\n        \\n        int res = 0;\\n        for(int m : worker){\\n            Integer difficultyKey = map.floorKey(m);\\n            if(difficultyKey != null){\\n                res += map.get(difficultyKey);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\nclass Job {\\n    int d;\\n    int p;\\n    Job(int _d, int _p){\\n        d = _d;\\n        p = _p;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1836385,
                "title": "most-profit-assigning-work",
                "content": "```\\n  make difficulty and profit pair that will give you help in finding workers profit according to their strength.\\n  sort worker and difficulty\\n  search worker[i]\\'s floor in difficulty\\n```\\nclass Solution \\n{\\n public:\\n    //Searching worker strength in difficulty\\n    int binary(vector<int>&nums,int k)\\n    {\\n      int n = nums.size()-1;\\n      int l= 0;\\n      //speacial case if worker is not even able to do a least difficult task  \\n      if(nums[0]>k)\\n        return -1;\\n      //searching floor element\\n      int ans=0;\\n      while(l<=n)\\n      {\\n          int mid = (l+n)/2;\\n          if(nums[mid]<=k)\\n          {\\n            ans=mid;\\n            l=mid+1;\\n          }\\n          else\\n            n=mid -1 ;\\n        }\\n       return ans;\\n    }\\n    int maxProfitAssignment(vector<int>& d, vector<int>& pr, vector<int>& w) \\n    {\\n        int n = d.size();\\n        vector<pair<int,int>> p(n);\\n        for(int i=0;i<n;i++)\\n             p[i] = {d[i],pr[i]};\\n        // sorting in difficulty it will help to find the index easily \\n        sort(d.begin(),d.end());\\n         //sort it in difficulty and profit pairs it will give us workers difficulty strength and profit accordingly\\n        sort(p.begin(),p.end());\\n        for(int i=1;i<n;i++)\\n            p[i].second = max(p[i].second,p[i-1].second);\\n        int res =0;\\n        for(int i =0;i<w.size();i++)\\n        {\\n           int it = binary(d,w[i]);\\n           if(it>=0)\\n             res += p[it].second;\\n        }\\n       return res;\\n    }\\n};``",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\n  make difficulty and profit pair that will give you help in finding workers profit according to their strength.\\n  sort worker and difficulty\\n  search worker[i]\\'s floor in difficulty\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1803075,
                "title": "binary-search-cpp-simple-solution",
                "content": "int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n      \\n        vector<vector<int>>ds;\\n        \\n        for(int i=0; i<difficulty.size(); i++)\\n        {\\n            vector<int>arr;\\n            arr.push_back(difficulty[i]);\\n            arr.push_back(profit[i]);\\n            ds.push_back(arr);\\n        }\\n        \\n        // sortint by difficulty level\\n        sort(ds.begin(), ds.end());\\n        \\n        for(int i=1; i<ds.size(); i++)\\n        {\\n            ds[i][1] = max(ds[i-1][1], ds[i][1]);\\n\\t\\t\\n        }\\n        int sum = 0;\\n        for(int i=0;i<worker.size();i++)\\n        {\\n            int start = 0;\\n            int end = ds.size()-1;\\n            int target = worker[i];\\n            int ind  = -1;\\n            \\n            while(start <= end)\\n            {\\n                int mid = start + (end-start)/2;\\n                int midval = ds[mid][0];\\n                \\n                if(target>= midval)\\n                {\\n                    ind = mid;\\n                    start = mid + 1;\\n                }\\n                else{\\n                    end = mid -1;\\n                }\\n            }\\n            \\n            sum += ind>-1 ? ds[ind][1] : 0;\\n        }\\n        return sum;\\n    }",
                "solutionTags": [],
                "code": "int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n      \\n        vector<vector<int>>ds;\\n        \\n        for(int i=0; i<difficulty.size(); i++)\\n        {\\n            vector<int>arr;\\n            arr.push_back(difficulty[i]);\\n            arr.push_back(profit[i]);\\n            ds.push_back(arr);\\n        }\\n        \\n        // sortint by difficulty level\\n        sort(ds.begin(), ds.end());\\n        \\n        for(int i=1; i<ds.size(); i++)\\n        {\\n            ds[i][1] = max(ds[i-1][1], ds[i][1]);\\n\\t\\t\\n        }\\n        int sum = 0;\\n        for(int i=0;i<worker.size();i++)\\n        {\\n            int start = 0;\\n            int end = ds.size()-1;\\n            int target = worker[i];\\n            int ind  = -1;\\n            \\n            while(start <= end)\\n            {\\n                int mid = start + (end-start)/2;\\n                int midval = ds[mid][0];\\n                \\n                if(target>= midval)\\n                {\\n                    ind = mid;\\n                    start = mid + 1;\\n                }\\n                else{\\n                    end = mid -1;\\n                }\\n            }\\n            \\n            sum += ind>-1 ? ds[ind][1] : 0;\\n        }\\n        return sum;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1721292,
                "title": "easy-to-understand-java-29ms",
                "content": "```\\nclass Pair{\\n    public int first,second;\\n    Pair(int first,int second){\\n        this.first = first; this.second = second;\\n    }\\n}\\n\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        ArrayList<Pair> lst = new ArrayList<Pair>();\\n        for(int i=0;i<profit.length;i++){\\n            lst.add(new Pair(difficulty[i],profit[i]));\\n        }\\n        Collections.sort(lst,(Pair p1,Pair p2)->{\\n            return (p1.first==p2.first)?(p1.second-p2.second):(p1.first-p2.first);\\n        });\\n        Arrays.sort(worker);\\n        int res = 0,j = 0,temp = 0;\\n        for(int i=0;i<worker.length;i++){\\n            for(;j<lst.size();j++){\\n                if(lst.get(j).first>worker[i]){\\n                    break;\\n                }\\n                temp = Math.max(temp,lst.get(j).second);\\n            }res+=temp;\\n        }return res;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Pair{\\n    public int first,second;\\n    Pair(int first,int second){\\n        this.first = first; this.second = second;\\n    }\\n}\\n\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        ArrayList<Pair> lst = new ArrayList<Pair>();\\n        for(int i=0;i<profit.length;i++){\\n            lst.add(new Pair(difficulty[i],profit[i]));\\n        }\\n        Collections.sort(lst,(Pair p1,Pair p2)->{\\n            return (p1.first==p2.first)?(p1.second-p2.second):(p1.first-p2.first);\\n        });\\n        Arrays.sort(worker);\\n        int res = 0,j = 0,temp = 0;\\n        for(int i=0;i<worker.length;i++){\\n            for(;j<lst.size();j++){\\n                if(lst.get(j).first>worker[i]){\\n                    break;\\n                }\\n                temp = Math.max(temp,lst.get(j).second);\\n            }res+=temp;\\n        }return res;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1594681,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def maxProfitAssignment(self, D: List[int], P: List[int], W: List[int]) -> int:\\n        n = len(D)\\n        \\n        # will be used to get sorted profits. sorted as per elements of difficulty\\n        indexes = sorted(range(n), key=lambda x:D[x])\\n        D.sort()\\n        \\n        # max prefix array\\n        max_profit = []\\n        mx = 0\\n        for i in range(n):\\n            mx = max(mx, P[indexes[i]])\\n            max_profit.append(mx)\\n            \\n        res = 0\\n        for w in W:\\n            idx = bisect.bisect(D, w) - 1\\n            if idx < 0:   continue\\n            res += max_profit[idx]\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfitAssignment(self, D: List[int], P: List[int], W: List[int]) -> int:\\n        n = len(D)\\n        \\n        # will be used to get sorted profits. sorted as per elements of difficulty\\n        indexes = sorted(range(n), key=lambda x:D[x])\\n        D.sort()\\n        \\n        # max prefix array\\n        max_profit = []\\n        mx = 0\\n        for i in range(n):\\n            mx = max(mx, P[indexes[i]])\\n            max_profit.append(mx)\\n            \\n        res = 0\\n        for w in W:\\n            idx = bisect.bisect(D, w) - 1\\n            if idx < 0:   continue\\n            res += max_profit[idx]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1524028,
                "title": "python-3-solution-using-sort-hashmap-binary-search",
                "content": "```\\ndef maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n\\tpd = defaultdict(int)\\n\\tl = len(difficulty)\\n\\n\\tfor i in range(0, l):\\n\\t\\t#there might be different profit for same difficulty level\\n\\t\\t#so we pick the maximum one\\n\\t\\tpd[difficulty[i]] = max(pd[difficulty[i]], profit[i])\\n\\n\\tdifficulty = sorted(set(difficulty))\\n\\tl = len(difficulty)\\n\\n\\tfor i in range(1, l):\\n\\t\\t#task with less difficulty might be more profitable\\n\\t\\tpd[difficulty[i]] = max(pd[difficulty[i]], pd[difficulty[i-1]])\\n\\t\\n\\t#since the array is sorted and everything is done as stated above\\n\\t# we can just perform binary search and find the task with proper difficulty (equal or the nearest smaller)\\n\\t\\n\\tdef binary_search(w):\\n\\t\\ts, e = 0, l-1\\n\\t\\tpos = -1\\n\\t\\twhile s<=e:\\n\\t\\t\\tmid = s+(e-s)//2\\n\\t\\t\\tif difficulty[mid]==w:\\n\\t\\t\\t\\treturn mid\\n\\t\\t\\telif difficulty[mid]<w:\\n\\t\\t\\t\\tpos = mid\\n\\t\\t\\t\\ts = mid+1\\n\\t\\t\\telse:\\n\\t\\t\\t\\te = mid-1\\n\\t\\treturn pos\\n\\n\\tres = 0\\n\\tfor w in worker:\\n\\t\\tpos = binary_search(w)\\n\\t\\tif pos>=0:\\n\\t\\t\\tres+=pd[difficulty[pos]]\\n\\treturn res\\n```",
                "solutionTags": [
                    "Python3",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\ndef maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n\\tpd = defaultdict(int)\\n\\tl = len(difficulty)\\n\\n\\tfor i in range(0, l):\\n\\t\\t#there might be different profit for same difficulty level\\n\\t\\t#so we pick the maximum one\\n\\t\\tpd[difficulty[i]] = max(pd[difficulty[i]], profit[i])\\n\\n\\tdifficulty = sorted(set(difficulty))\\n\\tl = len(difficulty)\\n\\n\\tfor i in range(1, l):\\n\\t\\t#task with less difficulty might be more profitable\\n\\t\\tpd[difficulty[i]] = max(pd[difficulty[i]], pd[difficulty[i-1]])\\n\\t\\n\\t#since the array is sorted and everything is done as stated above\\n\\t# we can just perform binary search and find the task with proper difficulty (equal or the nearest smaller)\\n\\t\\n\\tdef binary_search(w):\\n\\t\\ts, e = 0, l-1\\n\\t\\tpos = -1\\n\\t\\twhile s<=e:\\n\\t\\t\\tmid = s+(e-s)//2\\n\\t\\t\\tif difficulty[mid]==w:\\n\\t\\t\\t\\treturn mid\\n\\t\\t\\telif difficulty[mid]<w:\\n\\t\\t\\t\\tpos = mid\\n\\t\\t\\t\\ts = mid+1\\n\\t\\t\\telse:\\n\\t\\t\\t\\te = mid-1\\n\\t\\treturn pos\\n\\n\\tres = 0\\n\\tfor w in worker:\\n\\t\\tpos = binary_search(w)\\n\\t\\tif pos>=0:\\n\\t\\t\\tres+=pd[difficulty[pos]]\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1509325,
                "title": "javascript-solution-sort-and-two-pointers",
                "content": "```\\nvar maxProfitAssignment = function(difficulties, profits, workers) {\\n    const n = difficulties.length;\\n    const m = workers.length;\\n\\n    const jobs = [];\\n\\n    for (let i = 0; i < n; i++) {\\n        const difficulty = difficulties[i];\\n        const profit = profits[i];\\n\\n        jobs[i] = { difficulty, profit };\\n    }\\n\\n    jobs.sort((a, b) => a.difficulty - b.difficulty); // sort the jobs by their difficulties\\n    workers.sort((a, b) => a - b); // sort the workers by their abilities\\n\\n    let jobIdx = 0; // pointer for the jobs array\\n    let workerIdx = 0; // pointer for the workers array\\n\\n    let totMaxProfit = 0;\\n    let bestIdx = 0;\\n\\n    while (workerIdx < m) {\\n        const workerAbility = workers[workerIdx];\\n        \\n        while (jobIdx < n && jobs[jobIdx].difficulty <= workerAbility) {\\n            if (jobs[jobIdx].profit > jobs[bestIdx].profit) {\\n                bestIdx = jobIdx;\\n            }\\n            jobIdx++;\\n        }\\n        \\n        if (jobs[bestIdx].difficulty <= workerAbility) {\\n            totMaxProfit += jobs[bestIdx].profit;\\n        }\\n        workerIdx++;\\n    }\\n    \\n    return totMaxProfit;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nvar maxProfitAssignment = function(difficulties, profits, workers) {\\n    const n = difficulties.length;\\n    const m = workers.length;\\n\\n    const jobs = [];\\n\\n    for (let i = 0; i < n; i++) {\\n        const difficulty = difficulties[i];\\n        const profit = profits[i];\\n\\n        jobs[i] = { difficulty, profit };\\n    }\\n\\n    jobs.sort((a, b) => a.difficulty - b.difficulty); // sort the jobs by their difficulties\\n    workers.sort((a, b) => a - b); // sort the workers by their abilities\\n\\n    let jobIdx = 0; // pointer for the jobs array\\n    let workerIdx = 0; // pointer for the workers array\\n\\n    let totMaxProfit = 0;\\n    let bestIdx = 0;\\n\\n    while (workerIdx < m) {\\n        const workerAbility = workers[workerIdx];\\n        \\n        while (jobIdx < n && jobs[jobIdx].difficulty <= workerAbility) {\\n            if (jobs[jobIdx].profit > jobs[bestIdx].profit) {\\n                bestIdx = jobIdx;\\n            }\\n            jobIdx++;\\n        }\\n        \\n        if (jobs[bestIdx].difficulty <= workerAbility) {\\n            totMaxProfit += jobs[bestIdx].profit;\\n        }\\n        workerIdx++;\\n    }\\n    \\n    return totMaxProfit;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1494625,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& diff, vector<int>& pro, vector<int>& worker)\\n    {\\n        vector<pair<int,int>>v;\\n        for(int i=0;i<diff.size();i++)\\n        {\\n            v.push_back({diff[i],pro[i]});\\n        }\\n        sort(worker.begin(),worker.end());\\n        sort(v.begin(),v.end());\\n        int best=0;\\n        int cost=0;\\n        for(int i=0,j=0;i<worker.size();i++)\\n        {\\n            int wt=worker[i];\\n            while(j<diff.size()&&wt>=v[j].first)\\n            {\\n                best=max(best,v[j].second);\\n                j++;\\n            }\\n            cost+=best;\\n        }\\n        return cost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& diff, vector<int>& pro, vector<int>& worker)\\n    {\\n        vector<pair<int,int>>v;\\n        for(int i=0;i<diff.size();i++)\\n        {\\n            v.push_back({diff[i],pro[i]});\\n        }\\n        sort(worker.begin(),worker.end());\\n        sort(v.begin(),v.end());\\n        int best=0;\\n        int cost=0;\\n        for(int i=0,j=0;i<worker.size();i++)\\n        {\\n            int wt=worker[i];\\n            while(j<diff.size()&&wt>=v[j].first)\\n            {\\n                best=max(best,v[j].second);\\n                j++;\\n            }\\n            cost+=best;\\n        }\\n        return cost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1461056,
                "title": "java-51-faster-solution-using-binary-search",
                "content": "```\\nclass Pair{ // class to store the pair of difficulty and profit together\\n    int d;\\n    int p;\\n    Pair(int d,int p)\\n    {\\n        this.d=d;\\n        this.p=p;\\n    }\\n}\\nclass Solution {\\n    public static int binarysearch(ArrayList<Pair> arr,int val,int s,int e) // binary search function to find the maximum possible difficulty that can be done by the worker\\n    {\\n        if(s>e)\\n            return -1;\\n        int m=s+(e-s)/2;\\n        if(arr.get(m).d>val)\\n         return binarysearch(arr,val,s,m-1);\\n        else\\n        {\\n            int t=binarysearch(arr,val,m+1,e);\\n            return t==-1?m:t;\\n        }\\n    }\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        ArrayList<Pair> arr=new ArrayList<>(); // list to store the pairs of difficulty and profit together\\n        for(int i=0;i<profit.length;i++)\\n            arr.add(new Pair(difficulty[i],profit[i]));\\n        Collections.sort(arr , new Comparator<Pair>(){ \\n            public int compare(Pair p1,Pair p2) // custom sort the list w.r.t difficulty\\n            {\\n                if(p1.d>p2.d)\\n                    return 1;\\n                if(p1.d==p2.d)\\n                    return 0;\\n                return -1;\\n            }\\n        });\\n        ArrayList<Integer> maxsofar=new ArrayList<>(); // list to store the maximum profit from 0 to ith index in the difficulty wise sorted list\\n        int maxx=0;\\n        for(Pair pr : arr)\\n        {\\n            maxx=Math.max(maxx,pr.p);\\n            maxsofar.add(maxx);\\n        }\\n        int sum=0;\\n        for(int i : worker)\\n        {\\n            int t=binarysearch(arr,i,0,arr.size()-1);\\n            if(t==-1)\\n                continue;\\n            sum+=maxsofar.get(t);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Pair{ // class to store the pair of difficulty and profit together\\n    int d;\\n    int p;\\n    Pair(int d,int p)\\n    {\\n        this.d=d;\\n        this.p=p;\\n    }\\n}\\nclass Solution {\\n    public static int binarysearch(ArrayList<Pair> arr,int val,int s,int e) // binary search function to find the maximum possible difficulty that can be done by the worker\\n    {\\n        if(s>e)\\n            return -1;\\n        int m=s+(e-s)/2;\\n        if(arr.get(m).d>val)\\n         return binarysearch(arr,val,s,m-1);\\n        else\\n        {\\n            int t=binarysearch(arr,val,m+1,e);\\n            return t==-1?m:t;\\n        }\\n    }\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        ArrayList<Pair> arr=new ArrayList<>(); // list to store the pairs of difficulty and profit together\\n        for(int i=0;i<profit.length;i++)\\n            arr.add(new Pair(difficulty[i],profit[i]));\\n        Collections.sort(arr , new Comparator<Pair>(){ \\n            public int compare(Pair p1,Pair p2) // custom sort the list w.r.t difficulty\\n            {\\n                if(p1.d>p2.d)\\n                    return 1;\\n                if(p1.d==p2.d)\\n                    return 0;\\n                return -1;\\n            }\\n        });\\n        ArrayList<Integer> maxsofar=new ArrayList<>(); // list to store the maximum profit from 0 to ith index in the difficulty wise sorted list\\n        int maxx=0;\\n        for(Pair pr : arr)\\n        {\\n            maxx=Math.max(maxx,pr.p);\\n            maxsofar.add(maxx);\\n        }\\n        int sum=0;\\n        for(int i : worker)\\n        {\\n            int t=binarysearch(arr,i,0,arr.size()-1);\\n            if(t==-1)\\n                continue;\\n            sum+=maxsofar.get(t);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1434903,
                "title": "c-priority-queue-8-lines",
                "content": "```\\n\\n```public:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int i,ans=0;\\n       priority_queue<pair<int,int>>pq;\\n        for(i=0;i<profit.size();i++)\\n        {\\n            pq.push({profit[i],difficulty[i]});\\n        }\\n        sort(worker.begin(),worker.end(),greater<int>());\\n        for(i=0;i<worker.size();i++)\\n        {\\n            while(!pq.empty()&&pq.top().second>worker[i])\\n            {\\n                pq.pop();\\n            }\\n            if(!pq.empty())\\n            {\\n                ans=ans+pq.top().first;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1409945,
                "title": "simple-python-o-nlogn-mlogm-sort-greedy-solution",
                "content": "If the ability of worker 1 is at least that of worker 2, worker1 can make a profit of at least that of worker 2 as well. We can start from the least skilled worker and increase max profit when we can. This way the total complexity is O(nlogn) for sorting difficulty and profit, O(mlogm) for sorting worker skills, and O(n) for scanning through difficulties.\\n\\n```\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        # sort difficulty and profit together as a tuple\\n        difficulty, profit = zip(*sorted(zip(difficulty, profit)))\\n        ret = max_profit = idx = 0\\n        for ability in sorted(worker):\\n            # if ability is smaller than the smallest difficulty\\n            # it\\'s smaller than all difficulties\\n            if ability < difficulty[0]: continue\\n            # try to find a larger profit than the current one\\n            # this while loop will be run for at most len(difficulty) times\\n            # as idx is not reset at the end\\n            while idx < len(difficulty) and ability >= difficulty[idx]:\\n                max_profit = max(max_profit, profit[idx])\\n                idx += 1\\n            # increment total profit\\n            ret += max_profit\\n        return ret\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        # sort difficulty and profit together as a tuple\\n        difficulty, profit = zip(*sorted(zip(difficulty, profit)))\\n        ret = max_profit = idx = 0\\n        for ability in sorted(worker):\\n            # if ability is smaller than the smallest difficulty\\n            # it\\'s smaller than all difficulties\\n            if ability < difficulty[0]: continue\\n            # try to find a larger profit than the current one\\n            # this while loop will be run for at most len(difficulty) times\\n            # as idx is not reset at the end\\n            while idx < len(difficulty) and ability >= difficulty[idx]:\\n                max_profit = max(max_profit, profit[idx])\\n                idx += 1\\n            # increment total profit\\n            ret += max_profit\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1378443,
                "title": "c-faster-than-50-easiest-solution-insertion-sort",
                "content": "\\'\\'\\'\\n\\n\\tint maxProfitAssignment(int* difficulty, int difficultySize, int* profit, int profitSize, int* worker, int workerSize){\\n    int i, j, tempval, tempval2, pr=0;\\n\\t\\n\\t// Example - difficulty = [10,8,6,4,2], profit = [50,40,30,20,10], worker = [7,6,5,4]\\n\\t\\n\\t/* Sorting difficulty array based on profit array\\n\\tSince we want to maximize profit so we figure out how can we get maximum profit and what is the \\n\\tdifficulty associated with it (Insertion sort as it it Stable)\\n\\t*/\\n    for(i=1; i<profitSize; ++i){\\n        if(profit[i]<profit[i-1]){\\n            tempval=profit[i];\\n            tempval2=difficulty[i];\\n            j=i-1;\\n            while(j>=0 && profit[j]>tempval){\\n                profit[j+1]=profit[j];\\n                difficulty[j+1]=difficulty[j];\\n                --j;\\n            } \\n            profit[j+1]=tempval;\\n            difficulty[j+1]=tempval2;\\n        }\\n    }\\n\\t// After sorting - difficulty = [2,4,6,8,10], profit = [10,20,30,40,50]\\n\\t\\n\\t// Now we Sort worker array \\n    for(i=1; i<workerSize; ++i){\\n        if(worker[i]<worker[i-1]){\\n            tempval=worker[i];\\n            j=i-1;\\n            while(j>=0 && worker[j]>tempval){\\n                worker[j+1]=worker[j];\\n                --j;\\n            } \\n            worker[j+1]=tempval;\\n        }\\n    }\\n\\t\\n\\t// After sorting -  worker = [4,5,6,7]\\n\\t\\n    // Main Logic\\n    int x=difficultySize-1; // last index of difficulty array (x=4)\\n    for(i=workerSize-1; i>=0; --i){\\n\\t\\t// we decrement x till we figure out an index where difficulty[x] <= worker [i]\\n\\t\\t// This goes on till difficulty[x]=6 or x=2\\n        while(x>-1 && difficulty[x]>worker[i]){\\n            --x;\\n        }\\n        if(x==-1) break;\\n        pr+=profit[x]; // difficulty[x]=6  and worker[i]=7 so we get maximum profit out of it\\n    }\\n    return pr;\\n\\t}\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n\\n\\tint maxProfitAssignment(int* difficulty, int difficultySize, int* profit, int profitSize, int* worker, int workerSize){\\n    int i, j, tempval, tempval2, pr=0;\\n\\t\\n\\t// Example - difficulty = [10,8,6,4,2], profit = [50,40,30,20,10], worker = [7,6,5,4]\\n\\t\\n\\t/* Sorting difficulty array based on profit array\\n\\tSince we want to maximize profit so we figure out how can we get maximum profit and what is the \\n\\tdifficulty associated with it (Insertion sort as it it Stable)\\n\\t*/\\n    for(i=1; i<profitSize; ++i){\\n        if(profit[i]<profit[i-1]){\\n            tempval=profit[i];\\n            tempval2=difficulty[i];\\n            j=i-1;\\n            while(j>=0 && profit[j]>tempval){\\n                profit[j+1]=profit[j];\\n                difficulty[j+1]=difficulty[j];\\n                --j;\\n            } \\n            profit[j+1]=tempval;\\n            difficulty[j+1]=tempval2;\\n        }\\n    }\\n\\t// After sorting - difficulty = [2,4,6,8,10], profit = [10,20,30,40,50]\\n\\t\\n\\t// Now we Sort worker array \\n    for(i=1; i<workerSize; ++i){\\n        if(worker[i]<worker[i-1]){\\n            tempval=worker[i];\\n            j=i-1;\\n            while(j>=0 && worker[j]>tempval){\\n                worker[j+1]=worker[j];\\n                --j;\\n            } \\n            worker[j+1]=tempval;\\n        }\\n    }\\n\\t\\n\\t// After sorting -  worker = [4,5,6,7]\\n\\t\\n    // Main Logic\\n    int x=difficultySize-1; // last index of difficulty array (x=4)\\n    for(i=workerSize-1; i>=0; --i){\\n\\t\\t// we decrement x till we figure out an index where difficulty[x] <= worker [i]\\n\\t\\t// This goes on till difficulty[x]=6 or x=2\\n        while(x>-1 && difficulty[x]>worker[i]){\\n            --x;\\n        }\\n        if(x==-1) break;\\n        pr+=profit[x]; // difficulty[x]=6  and worker[i]=7 so we get maximum profit out of it\\n    }\\n    return pr;\\n\\t}\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1353377,
                "title": "sorting-binary-search",
                "content": "```\\nclass Solution {\\nprivate:\\n    int bs(vector<pair<int, int>>& job, int workerCap, int start, int end){\\n        // cout<<\"Got workerCap: \"<<workerCap<<\"\\\\n\";\\n        while(start<end){\\n            int mid = start + (end-start+1)/2;\\n            // cout<<\"Mid Diff Job: \"<<job[mid].first<<\"\\\\n\";\\n            if(job[mid].first > workerCap){\\n                // cout<<\"Shrinking End to: \"<<job[mid-1].first<<\"\\\\n\";\\n                end = mid-1;\\n            } else if(job[mid].first <= workerCap){\\n                // cout<<\"Shrinking start to: \"<<job[mid].first<<\"\\\\n\";\\n                start = mid;\\n            }\\n        }\\n        if(job[start].first > workerCap){\\n            // cout<<\"LowerBound not found!\\\\n\\\\n\";\\n            return -1;\\n        }\\n        // cout<<\"Referring job with difficulty: \"<< job[start].first<<\"\\\\n\\\\n\";\\n        return start;\\n    }\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int n = difficulty.size();\\n        int m = worker.size();\\n        int res = 0;\\n        vector<pair<int, int>> job(n);\\n        for(int i=0;i<n;i++){\\n            job[i] = {difficulty[i], profit[i]};\\n        }\\n        sort(job.begin(), job.end());\\n        vector<int> jobWithMaxProfitUntilNow(n);\\n        int maxProfitJob = job[0].second;\\n        int maxProfitJobId = 0;\\n        for(int i=0;i<n;i++){\\n            if(job[i].second > maxProfitJob){\\n                maxProfitJob = job[i].second;\\n                maxProfitJobId = i;\\n            }\\n            jobWithMaxProfitUntilNow[i] = maxProfitJobId;\\n        }\\n        for(int i = m-1;i>=0;i--){\\n            int workerCap = worker[i];\\n            int bsid = bs(job, workerCap, 0, n-1);\\n            if(bsid==-1){\\n                continue;\\n            }\\n            res += job[jobWithMaxProfitUntilNow[bsid]].second;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    int bs(vector<pair<int, int>>& job, int workerCap, int start, int end){\\n        // cout<<\"Got workerCap: \"<<workerCap<<\"\\\\n\";\\n        while(start<end){\\n            int mid = start + (end-start+1)/2;\\n            // cout<<\"Mid Diff Job: \"<<job[mid].first<<\"\\\\n\";\\n            if(job[mid].first > workerCap){\\n                // cout<<\"Shrinking End to: \"<<job[mid-1].first<<\"\\\\n\";\\n                end = mid-1;\\n            } else if(job[mid].first <= workerCap){\\n                // cout<<\"Shrinking start to: \"<<job[mid].first<<\"\\\\n\";\\n                start = mid;\\n            }\\n        }\\n        if(job[start].first > workerCap){\\n            // cout<<\"LowerBound not found!\\\\n\\\\n\";\\n            return -1;\\n        }\\n        // cout<<\"Referring job with difficulty: \"<< job[start].first<<\"\\\\n\\\\n\";\\n        return start;\\n    }\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int n = difficulty.size();\\n        int m = worker.size();\\n        int res = 0;\\n        vector<pair<int, int>> job(n);\\n        for(int i=0;i<n;i++){\\n            job[i] = {difficulty[i], profit[i]};\\n        }\\n        sort(job.begin(), job.end());\\n        vector<int> jobWithMaxProfitUntilNow(n);\\n        int maxProfitJob = job[0].second;\\n        int maxProfitJobId = 0;\\n        for(int i=0;i<n;i++){\\n            if(job[i].second > maxProfitJob){\\n                maxProfitJob = job[i].second;\\n                maxProfitJobId = i;\\n            }\\n            jobWithMaxProfitUntilNow[i] = maxProfitJobId;\\n        }\\n        for(int i = m-1;i>=0;i--){\\n            int workerCap = worker[i];\\n            int bsid = bs(job, workerCap, 0, n-1);\\n            if(bsid==-1){\\n                continue;\\n            }\\n            res += job[jobWithMaxProfitUntilNow[bsid]].second;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1344821,
                "title": "c-easy-priority-queue-solution",
                "content": "```\\nclass Solution {\\n    static bool compare(const int&a , const int &b)\\n    {\\n        return a>b;\\n    }\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        priority_queue<pair<int,int>>pq;\\n        for(int i=0;i<profit.size();i++)\\n        {\\n            pq.push({profit[i],difficulty[i]});\\n        }\\n        sort(worker.begin(),worker.end(),compare);\\n        int i=0;\\n        int ans=0;\\n        while(i<worker.size())\\n        {\\n            while(!pq.empty() && pq.top().second>worker[i])\\n            {\\n                pq.pop();\\n            }\\n            if(!pq.empty())\\n            {\\n                ans+=pq.top().first;\\n                i++;\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    static bool compare(const int&a , const int &b)\\n    {\\n        return a>b;\\n    }\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        priority_queue<pair<int,int>>pq;\\n        for(int i=0;i<profit.size();i++)\\n        {\\n            pq.push({profit[i],difficulty[i]});\\n        }\\n        sort(worker.begin(),worker.end(),compare);\\n        int i=0;\\n        int ans=0;\\n        while(i<worker.size())\\n        {\\n            while(!pq.empty() && pq.top().second>worker[i])\\n            {\\n                pq.pop();\\n            }\\n            if(!pq.empty())\\n            {\\n                ans+=pq.top().first;\\n                i++;\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343418,
                "title": "c-two-pointer-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int,int>> check(difficulty.size());\\n        for(int i=0;i<difficulty.size();i++){\\n            check[i]={difficulty[i],profit[i]};\\n        }\\n        sort(check.begin(),check.end());\\n        sort(worker.begin(),worker.end());\\n        int ans=0;\\n        int ptr1=0,ptr2=0;\\n        int maxProfit=0;\\n        int flag=0;\\n        while(ptr1<worker.size() && ptr2<check.size()){  \\n            \\n            if( worker[ptr1]>=check[ptr2].first){\\n                maxProfit=max(maxProfit,check[ptr2].second);\\n                ptr2++;\\n            }else{\\n                ans+=maxProfit;\\n                ptr1++;\\n                flag++;\\n            }\\n        }\\n        if(flag<worker.size())\\n            ans+=maxProfit * (worker.size()-flag);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int,int>> check(difficulty.size());\\n        for(int i=0;i<difficulty.size();i++){\\n            check[i]={difficulty[i],profit[i]};\\n        }\\n        sort(check.begin(),check.end());\\n        sort(worker.begin(),worker.end());\\n        int ans=0;\\n        int ptr1=0,ptr2=0;\\n        int maxProfit=0;\\n        int flag=0;\\n        while(ptr1<worker.size() && ptr2<check.size()){  \\n            \\n            if( worker[ptr1]>=check[ptr2].first){\\n                maxProfit=max(maxProfit,check[ptr2].second);\\n                ptr2++;\\n            }else{\\n                ans+=maxProfit;\\n                ptr1++;\\n                flag++;\\n            }\\n        }\\n        if(flag<worker.size())\\n            ans+=maxProfit * (worker.size()-flag);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1081349,
                "title": "c-short-solution-88",
                "content": "Run-time is `O(NlogN + MlogM)`, space is `O(N)`, where `N` is size of `difficulty` and `M` size of `worker`.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        std::vector<std::pair<int,int>> dnp;\\n        int size{(int)difficulty.size()};\\n        for(int i{0}; i < size; ++i) dnp.emplace_back(difficulty[i], profit[i]);\\n        std::sort(dnp.begin(), dnp.end(), [](const auto& a, const auto& b){return a.first < b.first;});\\n        for(int i{0}, max_{0}; i < size; ++i) {\\n            max_ = std::max(max_, dnp[i].second);\\n            dnp[i].second = max_;\\n        }\\n\\n        int sum{0};\\n        for(const auto &w: worker) {\\n            int tmp = sum;\\n            auto it{std::upper_bound(dnp.begin(), dnp.end(), std::pair(w, 0), [](const auto& a, const auto& b){return a.first < b.first;})};\\n            if(it != dnp.begin()) sum += (--it)->second;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        std::vector<std::pair<int,int>> dnp;\\n        int size{(int)difficulty.size()};\\n        for(int i{0}; i < size; ++i) dnp.emplace_back(difficulty[i], profit[i]);\\n        std::sort(dnp.begin(), dnp.end(), [](const auto& a, const auto& b){return a.first < b.first;});\\n        for(int i{0}, max_{0}; i < size; ++i) {\\n            max_ = std::max(max_, dnp[i].second);\\n            dnp[i].second = max_;\\n        }\\n\\n        int sum{0};\\n        for(const auto &w: worker) {\\n            int tmp = sum;\\n            auto it{std::upper_bound(dnp.begin(), dnp.end(), std::pair(w, 0), [](const auto& a, const auto& b){return a.first < b.first;})};\\n            if(it != dnp.begin()) sum += (--it)->second;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1069376,
                "title": "python-sort-binary-search",
                "content": "```\\nfrom bisect import bisect_left\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty, profit, worker):\\n        D = collections.defaultdict(list)\\n        for i in range(len(profit)):\\n            D[difficulty[i]].append(profit[i])\\n        dif = sorted(set(difficulty))\\n        prof = [None] * len(dif)\\n        maxGlobal = 0\\n        for i, n in enumerate(dif):\\n            maxLocal = max(D[n])\\n            if maxLocal > maxGlobal:\\n                maxGlobal = maxLocal\\n                prof[i] = maxGlobal\\n            else:\\n                prof[i] = maxGlobal\\n        res = 0\\n        for w in worker:\\n            idx = bisect_left(dif, w)\\n            flag = False\\n            if idx >= len(dif): \\n                idx -= 1\\n                flag = True\\n            if dif[idx] == w:\\n                res += prof[idx]\\n            else:\\n                if flag:\\n                    res += prof[idx]\\n                else:\\n                    idx -= 1\\n                    if idx < 0: continue\\n                    res += prof[idx]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nfrom bisect import bisect_left\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty, profit, worker):\\n        D = collections.defaultdict(list)\\n        for i in range(len(profit)):\\n            D[difficulty[i]].append(profit[i])\\n        dif = sorted(set(difficulty))\\n        prof = [None] * len(dif)\\n        maxGlobal = 0\\n        for i, n in enumerate(dif):\\n            maxLocal = max(D[n])\\n            if maxLocal > maxGlobal:\\n                maxGlobal = maxLocal\\n                prof[i] = maxGlobal\\n            else:\\n                prof[i] = maxGlobal\\n        res = 0\\n        for w in worker:\\n            idx = bisect_left(dif, w)\\n            flag = False\\n            if idx >= len(dif): \\n                idx -= 1\\n                flag = True\\n            if dif[idx] == w:\\n                res += prof[idx]\\n            else:\\n                if flag:\\n                    res += prof[idx]\\n                else:\\n                    idx -= 1\\n                    if idx < 0: continue\\n                    res += prof[idx]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1060394,
                "title": "java-memorization-very-easy-to-understand",
                "content": "```\\npublic int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        int [] temp = new int[100000];\\n        for(int i=0; i<difficulty.length; i++) {\\n          temp[difficulty[i]] =  Math.max(profit[i], temp[difficulty[i]]);    \\n        }\\n        \\n        for(int i=1; i<temp.length; i++) {\\n          temp[i] = Math.max(temp[i-1], temp[i]);\\n          \\n        }\\n        int result =0;\\n        for(int i=0; i<worker.length; i++) {\\n            result += temp[worker[i]];\\n        }\\n        return result;\\n    }\\n\\t\\n\\t\\nRuntime: 11 ms, faster than 96.37% of Java online submissions for Most Profit Assigning Work.\\nMemory Usage: 40.1 MB, less than 83.69% of Java online submissions for Most Profit Assigning Work.",
                "solutionTags": [],
                "code": "```\\npublic int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        int [] temp = new int[100000];\\n        for(int i=0; i<difficulty.length; i++) {\\n          temp[difficulty[i]] =  Math.max(profit[i], temp[difficulty[i]]);    \\n        }\\n        \\n        for(int i=1; i<temp.length; i++) {\\n          temp[i] = Math.max(temp[i-1], temp[i]);\\n          \\n        }\\n        int result =0;\\n        for(int i=0; i<worker.length; i++) {\\n            result += temp[worker[i]];\\n        }\\n        return result;\\n    }\\n\\t\\n\\t\\nRuntime: 11 ms, faster than 96.37% of Java online submissions for Most Profit Assigning Work.\\nMemory Usage: 40.1 MB, less than 83.69% of Java online submissions for Most Profit Assigning Work.",
                "codeTag": "Unknown"
            },
            {
                "id": 1015778,
                "title": "java-super-easy-sort-by-profit",
                "content": "1. Sort by profit\\n2. Two pointers: count backwards, to make sure better worker gets better profit. If the better worker can\\'t do job[i], the worse one can\\'t either. \\n\\n```\\nclass Solution {\\n    \\n    class Job {\\n        public int d;\\n        public int p;\\n        Job(int difficulty, int profit) {\\n            this.d = difficulty;\\n            this.p = profit;\\n        }\\n    }\\n    \\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        // Edge case\\n        if(difficulty.length == 0 || profit.length == 0 || worker.length == 0) return 0;\\n        \\n        // Translate to job\\n        Job[] jobs = new Job[difficulty.length];\\n        for(int i = 0; i < jobs.length; i++) {\\n            jobs[i] = new Job(difficulty[i], profit[i]);\\n        }\\n        \\n        // Sort \\n        Arrays.sort(jobs, (Job a, Job b) -> (a.p - b.p));\\n        Arrays.sort(worker);\\n        \\n        // Two pointers\\n        int res = 0;\\n        int i = jobs.length - 1, j = worker.length - 1;\\n        while(j >= 0 && i >= 0) {\\n            if(jobs[i].d > worker[j]) i--;\\n            else if(jobs[i].d <= worker[j]) {\\n                res += jobs[i].p;\\n                j--;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    class Job {\\n        public int d;\\n        public int p;\\n        Job(int difficulty, int profit) {\\n            this.d = difficulty;\\n            this.p = profit;\\n        }\\n    }\\n    \\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        // Edge case\\n        if(difficulty.length == 0 || profit.length == 0 || worker.length == 0) return 0;\\n        \\n        // Translate to job\\n        Job[] jobs = new Job[difficulty.length];\\n        for(int i = 0; i < jobs.length; i++) {\\n            jobs[i] = new Job(difficulty[i], profit[i]);\\n        }\\n        \\n        // Sort \\n        Arrays.sort(jobs, (Job a, Job b) -> (a.p - b.p));\\n        Arrays.sort(worker);\\n        \\n        // Two pointers\\n        int res = 0;\\n        int i = jobs.length - 1, j = worker.length - 1;\\n        while(j >= 0 && i >= 0) {\\n            if(jobs[i].d > worker[j]) i--;\\n            else if(jobs[i].d <= worker[j]) {\\n                res += jobs[i].p;\\n                j--;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1002260,
                "title": "c-map-and-two-pointers-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        map<int, int> myMap;\\n        \\n        for (int i = 0; i < difficulty.size(); i++)\\n            myMap[difficulty[i]] = max(myMap[difficulty[i]], profit[i]);\\n        \\n        sort(worker.begin(), worker.end());\\n        \\n        auto it = myMap.begin();\\n        int i = 0;\\n        int curMaxProfit = 0, totalProfit = 0;\\n        \\n        while (i < worker.size()) {\\n            if (it == myMap.end() or worker[i] < it->first) {\\n                totalProfit += curMaxProfit;\\n                i++;\\n            }\\n            else {\\n                curMaxProfit = max(curMaxProfit, it->second);\\n                it++; \\n            }              \\n        }\\n        \\n        return totalProfit;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        map<int, int> myMap;\\n        \\n        for (int i = 0; i < difficulty.size(); i++)\\n            myMap[difficulty[i]] = max(myMap[difficulty[i]], profit[i]);\\n        \\n        sort(worker.begin(), worker.end());\\n        \\n        auto it = myMap.begin();\\n        int i = 0;\\n        int curMaxProfit = 0, totalProfit = 0;\\n        \\n        while (i < worker.size()) {\\n            if (it == myMap.end() or worker[i] < it->first) {\\n                totalProfit += curMaxProfit;\\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 934864,
                "title": "python3-two-approaches",
                "content": "Approach 1 - binary search \\nMaintain a mapping from (sorted) difficulty to max profit within this category. Given `worker`, binary search the max profit so that `difficulty <= worker`. \\n\\nImplementation \\n```\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        mp = {}\\n        mx = 0\\n        for x, y in sorted(zip(difficulty, profit)):\\n            mp[x] = max(mp.get(x, 0), mx := max(mx, y))\\n        arr = list(mp.keys()) # ordered since 3.6\\n        \\n        ans = 0 \\n        for x in worker: \\n            i = bisect_right(arr, x) - 1\\n            if 0 <= i < len(arr): ans += mp[arr[i]]\\n        return ans \\n```\\n\\nApproach 2 - sorting \\nA smarter implementation of similar idea given by @lee215 in this [post](https://leetcode.com/problems/most-profit-assigning-work/discuss/127031/C%2B%2BJavaPython-Sort-and-Two-pointer). \\n\\n```\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        job = sorted(zip(difficulty, profit))\\n        ans = i = mx = 0 \\n        for w in sorted(worker): \\n            while i < len(job) and job[i][0] <= w: \\n                mx = max(mx, job[i][1])\\n                i += 1\\n            ans += mx \\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        mp = {}\\n        mx = 0\\n        for x, y in sorted(zip(difficulty, profit)):\\n            mp[x] = max(mp.get(x, 0), mx := max(mx, y))\\n        arr = list(mp.keys()) # ordered since 3.6\\n        \\n        ans = 0 \\n        for x in worker: \\n            i = bisect_right(arr, x) - 1\\n            if 0 <= i < len(arr): ans += mp[arr[i]]\\n        return ans \\n```\n```\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        job = sorted(zip(difficulty, profit))\\n        ans = i = mx = 0 \\n        for w in sorted(worker): \\n            while i < len(job) and job[i][0] <= w: \\n                mx = max(mx, job[i][1])\\n                i += 1\\n            ans += mx \\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 912152,
                "title": "c-easy-solution-using-sorting-and-two-pointer-technique",
                "content": "we divide the problem into two processes: 1.sort work, difficulty and profit. 2. two-pointer technique traversing to find result\\n```\\nint maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n    int res = 0, curMax = 0, m = (int)worker.size(), n = (int)difficulty.size();\\n    // sort difficuty-profit and worker\\n    sort(worker.begin(), worker.end());\\n    vector<pair<int, int>> diffProf(n);\\n    for (int i = 0; i < n; i++){\\n        diffProf[i].first = difficulty[i];\\n        diffProf[i].second = profit[i];\\n    }\\n    sort(diffProf.begin(), diffProf.end());\\n    // two-pointer traversing, i for worker, j for diffProf\\n    int i = 0, j = 0;\\n    while (i < m) {\\n        while (j < n && worker[i] >= diffProf[j].first)\\n        {\\n            curMax = max(curMax, diffProf[j].second);\\n            j++;\\n        }\\n        res += curMax;\\n        i++;\\n    }\\n    return res;\\n}",
                "solutionTags": [],
                "code": "we divide the problem into two processes: 1.sort work, difficulty and profit. 2. two-pointer technique traversing to find result\\n```\\nint maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n    int res = 0, curMax = 0, m = (int)worker.size(), n = (int)difficulty.size();\\n    // sort difficuty-profit and worker\\n    sort(worker.begin(), worker.end());\\n    vector<pair<int, int>> diffProf(n);\\n    for (int i = 0; i < n; i++){\\n        diffProf[i].first = difficulty[i];\\n        diffProf[i].second = profit[i];\\n    }\\n    sort(diffProf.begin(), diffProf.end());\\n    // two-pointer traversing, i for worker, j for diffProf\\n    int i = 0, j = 0;\\n    while (i < m) {\\n        while (j < n && worker[i] >= diffProf[j].first)\\n        {\\n            curMax = max(curMax, diffProf[j].second);\\n            j++;\\n        }\\n        res += curMax;\\n        i++;\\n    }\\n    return res;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 906712,
                "title": "java-treemap-solution",
                "content": "```\\npublic int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        TreeMap<Integer,Integer> treemap = new TreeMap<>();\\n        for(int i = 0; i < difficulty.length; i++) {\\n            treemap.put(difficulty[i], Math.max(profit[i], treemap.getOrDefault(difficulty[i], 0)));\\n        }\\n        \\n        int max = 0, res = 0;\\n        for(Integer key : treemap.keySet()) {\\n            max = Math.max(treemap.get(key), max);\\n            treemap.put(key, max);\\n        }\\n       \\n        for(int i = 0; i < worker.length; i++){\\n            Integer key = treemap.floorKey(worker[i]);\\n             if(key != null)\\n                 res += treemap.get(key);\\n               }\\n            \\n        \\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\npublic int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        TreeMap<Integer,Integer> treemap = new TreeMap<>();\\n        for(int i = 0; i < difficulty.length; i++) {\\n            treemap.put(difficulty[i], Math.max(profit[i], treemap.getOrDefault(difficulty[i], 0)));\\n        }\\n        \\n        int max = 0, res = 0;\\n        for(Integer key : treemap.keySet()) {\\n            max = Math.max(treemap.get(key), max);\\n            treemap.put(key, max);\\n        }\\n       \\n        for(int i = 0; i < worker.length; i++){\\n            Integer key = treemap.floorKey(worker[i]);\\n             if(key != null)\\n                 res += treemap.get(key);\\n               }\\n            \\n        \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 808144,
                "title": "c",
                "content": "` ` `\\nclass Solution {\\npublic:\\n    \\n    int binary_search(vector<int>&p, int w){\\n        \\n        int n = p.size()-1;\\n        int l= 0;\\n        if(p[0]> w)\\n            return -1;\\n        int ans = 0;\\n        while(l<=n){\\n            int mid = (l+n)/2;\\n            \\n            if(p[mid]<=w){\\n                ans = mid;\\n                l = mid+1;\\n            }\\n            else\\n                n = mid -1 ;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    int maxProfitAssignment(vector<int>& d, vector<int>& pr, vector<int>& w) {\\n        \\n        int n = d.size();\\n        vector<pair<int,int>> p(n);\\n        \\n        for(int i=0;i<n;i++){\\n            p[i] = {d[i],pr[i]};\\n        }\\n        \\n        sort(d.begin(),d.end());\\n        \\n        sort(p.begin(),p.end());\\n        for(int i=1;i<n;i++){\\n            p[i].second = max(p[i].second,p[i-1].second);\\n        }\\n        \\n        int res =0;\\n        \\n        for(int i =0;i<w.size();i++){\\n            int it = binary_search(d,w[i]);\\n            //cout<<it<<\" \";\\n            if(it>=0){\\n                //cout<<p[it].second<<\" \";\\n                res += p[it].second;\\n            }\\n                \\n        }\\n        \\n        return res;\\n                \\n    }\\n};\\n` ` `",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int binary_search(vector<int>&p, int w){\\n        \\n        int n = p.size()-1;\\n        int l= 0;\\n        if(p[0]> w)\\n            return -1;\\n        int ans = 0;\\n        while(l<=n){\\n            int mid = (l+n)/2;\\n            \\n            if(p[mid]<=w){\\n                ans = mid;\\n                l = mid+1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 754240,
                "title": "c-simle-sort-and-run",
                "content": "Just sort by profit and try to gain as much profit as possible\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& dif, vector<int>& pro, vector<int>& worker) \\n    {\\n        int n=dif.size();\\n        vector<pair<int,int>> v(n);\\n        for(int i=0;i<n;i++) v[i]={pro[i],dif[i]};\\n        // sort by profit descending\\n        sort(v.begin(),v.end(),greater<pair<int,int>>());\\n        // sort ability in descending\\n        sort(worker.begin(),worker.end(),greater<int>());\\n        // ans is final answer, j is current worker\\'s index\\n        int j=0,ans=0;\\n\\t\\t// iterate over jobs\\n        for(int i=0;i<n;)\\n        {\\n            // no more workers left\\n            if(j>=worker.size()) break;\\n            // worker j can do task i\\n            if(worker[j]>=v[i].second) {ans+=v[i].first; j++;}\\n            // else goto next task\\n            else i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& dif, vector<int>& pro, vector<int>& worker) \\n    {\\n        int n=dif.size();\\n        vector<pair<int,int>> v(n);\\n        for(int i=0;i<n;i++) v[i]={pro[i],dif[i]};\\n        // sort by profit descending\\n        sort(v.begin(),v.end(),greater<pair<int,int>>());\\n        // sort ability in descending\\n        sort(worker.begin(),worker.end(),greater<int>());\\n        // ans is final answer, j is current worker\\'s index\\n        int j=0,ans=0;\\n\\t\\t// iterate over jobs\\n        for(int i=0;i<n;)\\n        {\\n            // no more workers left\\n            if(j>=worker.size()) break;\\n            // worker j can do task i\\n            if(worker[j]>=v[i].second) {ans+=v[i].first; j++;}\\n            // else goto next task\\n            else i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 680822,
                "title": "python-an-o-n-logn-solution",
                "content": "We sort both the works and the workers in decreasing order of profit and difficulty. Then for each worker, we try to pick the most profitable work he can take. Since we already sort the workers and the profit in terms of profit and difficulty, if worker i can take work j, then every worker coming after i can only at best take work j, or some work k with k > j. So, we can use two-pointer techniques to accumulate the result in O(N). Overall complexity: O(N logN).\\n\\n```\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        pd = list(zip(profit, difficulty))\\n        pd = sorted(pd, key = lambda x: -x[0])\\n        worker = sorted(worker, key = lambda x: -x)\\n        j, res = 0, 0\\n        for i, e in enumerate(worker):\\n            while j < len(pd) and e < pd[j][1]:\\n                j += 1\\n            if j == len(pd):\\n                return res\\n            res += pd[j][0]\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        pd = list(zip(profit, difficulty))\\n        pd = sorted(pd, key = lambda x: -x[0])\\n        worker = sorted(worker, key = lambda x: -x)\\n        j, res = 0, 0\\n        for i, e in enumerate(worker):\\n            while j < len(pd) and e < pd[j][1]:\\n                j += 1\\n            if j == len(pd):\\n                return res\\n            res += pd[j][0]\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 615597,
                "title": "fast-concise-javascript-solution",
                "content": "\\n```\\nconst maxProfitAssignment = (difficultyArr, profitArr, workerArr) => {\\n    let jobMap = Array.from(difficultyArr, (x,i) => [profitArr[i], x])\\n    jobMap.sort((a,b) => b[0] - a[0]); workerArr.sort((a,b) => b - a)\\n    let totalProfit = 0\\n    let j = 0, w = 0\\n    while(j < jobMap.length && w < workerArr.length){\\n        let [profit, difficulty] = jobMap[j],\\n            worker = workerArr[w]\\n        if(difficulty > worker)j++\\n        else{\\n            totalProfit += profit\\n            w++\\n        }\\n        \\n    }\\n    return totalProfit\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst maxProfitAssignment = (difficultyArr, profitArr, workerArr) => {\\n    let jobMap = Array.from(difficultyArr, (x,i) => [profitArr[i], x])\\n    jobMap.sort((a,b) => b[0] - a[0]); workerArr.sort((a,b) => b - a)\\n    let totalProfit = 0\\n    let j = 0, w = 0\\n    while(j < jobMap.length && w < workerArr.length){\\n        let [profit, difficulty] = jobMap[j],\\n            worker = workerArr[w]\\n        if(difficulty > worker)j++\\n        else{\\n            totalProfit += profit\\n            w++\\n        }\\n        \\n    }\\n    return totalProfit\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 520905,
                "title": "java-using-array-to-store-profit-for-each-difficulty",
                "content": "class Solution {\\n\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        int[] allProfit = new int[100000];\\n        int lOfJobs = difficulty.length;\\n        for(int i = 0; i < lOfJobs; i++) {\\n            if(profit[i] > allProfit[difficulty[i]]) {\\n                allProfit[difficulty[i]] = profit[i];\\n            }\\n        }\\n        \\n        int lOfAllProfit = allProfit.length;\\n        int max = allProfit[0];\\n        for(int i = 1; i < lOfAllProfit; i++) {\\n            max = Math.max(max, allProfit[i]);\\n\\t\\t\\tallProfit[i] = max;\\n        }\\n        \\n        int res = 0;\\n        int numOfWorker = worker.length;\\n        for(int i = 0; i < numOfWorker; i++) {\\n            res += allProfit[worker[i]];\\n        }\\n        return res;\\n    }\\n\\t\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        int[] allProfit = new int[100000];\\n        int lOfJobs = difficulty.length;\\n        for(int i = 0; i < lOfJobs; i++) {\\n            if(profit[i] > allProfit[difficulty[i]]) {\\n                allProfit[difficulty[i]] = profit[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 449522,
                "title": "java-priority-queue-solution",
                "content": "```\\nclass Solution \\n{\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) \\n    {\\n        PriorityQueue<Data> pq = new PriorityQueue<>();\\n        for(int i = 0; i < difficulty.length; i++) \\n            pq.offer(new Data(difficulty[i], profit[i]));\\n        int max = 0, sum = 0;\\n        Arrays.sort(worker);\\n        for(int i = 0; i < worker.length; i++)\\n        {\\n            int ability = worker[i];\\n            while(!pq.isEmpty())\\n            {\\n                Data data = pq.peek();\\n                if(data.difficulty > ability) break;\\n                if(data.profit > max) max = data.profit;\\n                pq.poll();\\n            }\\n            sum += max;\\n        }\\n        return sum;\\n    }\\n    \\n    private class Data implements Comparable<Data>\\n    {\\n        int difficulty, profit;\\n        \\n        Data(int difficulty, int profit)\\n        {\\n            this.difficulty = difficulty;\\n            this.profit = profit;\\n        }\\n        \\n        public int compareTo(Data data)\\n        {\\n            return this.difficulty - data.difficulty;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) \\n    {\\n        PriorityQueue<Data> pq = new PriorityQueue<>();\\n        for(int i = 0; i < difficulty.length; i++) \\n            pq.offer(new Data(difficulty[i], profit[i]));\\n        int max = 0, sum = 0;\\n        Arrays.sort(worker);\\n        for(int i = 0; i < worker.length; i++)\\n        {\\n            int ability = worker[i];\\n            while(!pq.isEmpty())\\n            {\\n                Data data = pq.peek();\\n                if(data.difficulty > ability) break;\\n                if(data.profit > max) max = data.profit;\\n                pq.poll();\\n            }\\n            sum += max;\\n        }\\n        return sum;\\n    }\\n    \\n    private class Data implements Comparable<Data>\\n    {\\n        int difficulty, profit;\\n        \\n        Data(int difficulty, int profit)\\n        {\\n            this.difficulty = difficulty;\\n            this.profit = profit;\\n        }\\n        \\n        public int compareTo(Data data)\\n        {\\n            return this.difficulty - data.difficulty;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 321714,
                "title": "java-solution-using-treemap",
                "content": "```\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        TreeMap<Integer, Integer> map = new TreeMap();\\n        map.put(0, 0);\\n        for(int i = 0; i < difficulty.length; i++) {\\n            map.put(difficulty[i], Math.max(map.getOrDefault(difficulty[i], 0), profit[i]));\\n        }\\n        \\n        int max = 0;\\n        for(int key: map.keySet()) {\\n            max = Math.max(max, map.get(key));\\n            map.put(key, max);\\n        }\\n        \\n        int res = 0;\\n        for(int i = 0; i < worker.length; i++) {\\n            res += map.floorEntry(worker[i]).getValue();\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        TreeMap<Integer, Integer> map = new TreeMap();\\n        map.put(0, 0);\\n        for(int i = 0; i < difficulty.length; i++) {\\n            map.put(difficulty[i], Math.max(map.getOrDefault(difficulty[i], 0), profit[i]));\\n        }\\n        \\n        int max = 0;\\n        for(int key: map.keySet()) {\\n            max = Math.max(max, map.get(key));\\n            map.put(key, max);\\n        }\\n        \\n        int res = 0;\\n        for(int i = 0; i < worker.length; i++) {\\n            res += map.floorEntry(worker[i]).getValue();\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 267878,
                "title": "super-simple-kotlin-solution-faster-then-100",
                "content": "```\\nclass Solution {\\n    fun maxProfitAssignment(difficulty: IntArray, profit: IntArray, worker: IntArray): Int {\\n\\n        val diffProfit =\\n            difficulty\\n                .zip(profit)\\n                .sortedByDescending { it.second }\\n\\n        return worker\\n            .map { workerMax ->\\n                diffProfit.find { it.first <= workerMax }\\n                    ?.second ?: 0\\n            }.sum()\\n\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun maxProfitAssignment(difficulty: IntArray, profit: IntArray, worker: IntArray): Int {\\n\\n        val diffProfit =\\n            difficulty\\n                .zip(profit)\\n                .sortedByDescending { it.second }\\n\\n        return worker\\n            .map { workerMax ->\\n                diffProfit.find { it.first <= workerMax }\\n                    ?.second ?: 0\\n            }.sum()\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 254762,
                "title": "treemap-simple-solution",
                "content": "```\\npublic int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n\\t//initialize difficult to profit map\\n\\tTreeMap<Integer, Integer> map = new TreeMap<>();\\n\\tfor(int i=0;i<difficulty.length;i++){\\n\\t\\tmap.put(difficulty[i], Math.max(profit[i], map.getOrDefault(difficulty[i],0)));\\n\\t}\\n\\t//difficult jobs should have at least easier job\\'s profit \\n\\tint max =0;\\n\\tfor(Integer sortedDifficulty:map.keySet()){\\n\\t\\tmap.put(sortedDifficulty, Math.max(max, map.get(sortedDifficulty)));\\n\\t\\tmax = map.get(sortedDifficulty);\\n\\t}\\n\\t//add each profit to the result\\n\\tint result = 0;\\n\\tfor(int i=0;i<worker.length;i++){\\n\\t\\tif(map.floorKey(worker[i]) != null){\\n\\t\\t\\tresult += map.get(map.floorKey(worker[i]));\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n\\t//initialize difficult to profit map\\n\\tTreeMap<Integer, Integer> map = new TreeMap<>();\\n\\tfor(int i=0;i<difficulty.length;i++){\\n\\t\\tmap.put(difficulty[i], Math.max(profit[i], map.getOrDefault(difficulty[i],0)));\\n\\t}\\n\\t//difficult jobs should have at least easier job\\'s profit \\n\\tint max =0;\\n\\tfor(Integer sortedDifficulty:map.keySet()){\\n\\t\\tmap.put(sortedDifficulty, Math.max(max, map.get(sortedDifficulty)));\\n\\t\\tmax = map.get(sortedDifficulty);\\n\\t}\\n\\t//add each profit to the result\\n\\tint result = 0;\\n\\tfor(int i=0;i<worker.length;i++){\\n\\t\\tif(map.floorKey(worker[i]) != null){\\n\\t\\t\\tresult += map.get(map.floorKey(worker[i]));\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 205773,
                "title": "python-sorting-and-two-pointers",
                "content": "```\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty, profit, worker):\\n        \"\"\"\\n        :type difficulty: List[int]\\n        :type profit: List[int]\\n        :type worker: List[int]\\n        :rtype: int\\n        \"\"\"\\n        job = sorted(list(zip(profit, difficulty)), reverse = True)\\n        worker.sort(reverse = True)\\n        \\n        i = j = 0\\n        total = 0\\n        while i < len(worker) and j < len(job):\\n            if worker[i] >= job[j][1]:\\n                total += job[j][0]\\n                i += 1\\n            else:\\n                j += 1\\n        return total\\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty, profit, worker):\\n        \"\"\"\\n        :type difficulty: List[int]\\n        :type profit: List[int]\\n        :type worker: List[int]\\n        :rtype: int\\n        \"\"\"\\n        job = sorted(list(zip(profit, difficulty)), reverse = True)\\n        worker.sort(reverse = True)\\n        \\n        i = j = 0\\n        total = 0\\n        while i < len(worker) and j < len(job):\\n            if worker[i] >= job[j][1]:\\n                total += job[j][0]\\n                i += 1\\n            else:\\n                j += 1\\n        return total\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 202734,
                "title": "c-javascript-two-pointer-binary-search-solution",
                "content": "C++ Binary Search\\n```\\nclass Solution {\\npublic:\\n    int findProfit(vector<pair<int,int> >& jobs,int target){\\n        \\n        int low=0;\\n        int high=jobs.size()-1;\\n       \\n        while(low+1<high){\\n            int mid=low+((high-low)>>1);\\n    \\n            if(target>=jobs[mid].first){\\n                low=mid;\\n            }else{\\n                high=mid;\\n            }\\n        }\\n        if(target>=jobs[high].first) return jobs[high].second;\\n        if(target>=jobs[low].first) return jobs[low].second;\\n        \\n        return 0;\\n    }\\n    \\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int out=0;\\n        vector<pair<int,int>> jobs(difficulty.size());\\n        for(int i=0;i<difficulty.size();i++){\\n            jobs[i]=(make_pair(difficulty[i],profit[i]));\\n        }\\n        \\n        sort(jobs.begin(),jobs.end(),[](const pair<int,int> &a,const pair<int,int> &b){\\n            return a.first<b.first || ((a.first==b.first)&&(a.second<b.second));\\n        });\\n        for(int i=1;i<jobs.size();i++){\\n            jobs[i].second=max(jobs[i].second,jobs[i-1].second);\\n        }\\n        for(auto work:worker){\\n            out+=findProfit(jobs,work);\\n        }\\n        return out;\\n    }\\n};\\n```\\n\\nC++ Two Pointers Solution\\n```\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int out=0;\\n        vector<pair<int,int>> jobs(difficulty.size());\\n        for(int i=0;i<difficulty.size();i++){\\n            jobs[i]=(make_pair(difficulty[i],profit[i]));\\n        }\\n        \\n        sort(jobs.begin(),jobs.end(),[](const pair<int,int> &a,const pair<int,int> &b){\\n            return a.first<b.first || ((a.first==b.first)&&(a.second<b.second));\\n        });\\n        sort(worker.begin(),worker.end());\\n        int i=0,maxP=0;\\n        for(auto work:worker){\\n            while(i<jobs.size() && work>=jobs[i].first) maxP=max(maxP,jobs[i++].second);\\n            out+=maxP;\\n        }\\n        return out;\\n    }\\n```\\n\\nJavaScript Two Pointers Solution\\n```\\nvar maxProfitAssignment = function(difficulty, profit, worker) {\\n\\n    let out=0;\\n    let p=new Array(difficulty.length).fill(0).map(() => new Array(2).fill(0));\\n    difficulty.forEach(function(value,index){\\n        p[index]=[difficulty[index],profit[index]];\\n    });\\n\\n    p.sort((a,b)=> a[0]-b[0] || ((a[0]==b[0])&&(a[1]-b[1])));\\n    \\n    let i=0,maxP=0;\\n    worker.sort((a,b)=>a-b);\\n    for(let work of worker){\\n        while(i<p.length && work>=p[i][0])maxP=Math.max(p[i++][1],maxP)\\n        out+=maxP;\\n        \\n    }\\n    return out;\\n};\\n```\\n\\nJavaScript Binary Search\\n```\\nlet findProfit= function(difficulty,target){\\n\\n    let low=0;\\n    let high=difficulty.length-1;\\n\\n    while(low+1<high){\\n        let mid=low+((high-low)>>1);\\n\\n        if(target>=difficulty[mid][0]){\\n            low=mid;\\n        }else{\\n            high=mid;\\n        }\\n    }\\n    if(target>=difficulty[high][0]) return difficulty[high][1];\\n    if(target>=difficulty[low][0]) return difficulty[low][1];\\n\\n    return 0;\\n}\\n    \\nvar maxProfitAssignment = function(difficulty, profit, worker) {\\n\\n    let out=0;\\n    let p=new Array(difficulty.length).fill(0).map(() => new Array(2).fill(0));\\n    for(let i=0;i<difficulty.length;i++){\\n        p[i]=[difficulty[i],profit[i]];\\n    }\\n\\n    p.sort((a,b)=> a[0]-b[0] || ((a[0]==b[0])&&(a[1]-b[1])));\\n    for(let i=1;i<p.length;i++){\\n        p[i][1]=Math.max(p[i][1],p[i-1][1]);\\n    }\\n    for(let work of worker){\\n        out+=findProfit(p,work);\\n    }\\n    return out;\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findProfit(vector<pair<int,int> >& jobs,int target){\\n        \\n        int low=0;\\n        int high=jobs.size()-1;\\n       \\n        while(low+1<high){\\n            int mid=low+((high-low)>>1);\\n    \\n            if(target>=jobs[mid].first){\\n                low=mid;\\n            }else{\\n                high=mid;\\n            }\\n        }\\n        if(target>=jobs[high].first) return jobs[high].second;\\n        if(target>=jobs[low].first) return jobs[low].second;\\n        \\n        return 0;\\n    }\\n    \\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int out=0;\\n        vector<pair<int,int>> jobs(difficulty.size());\\n        for(int i=0;i<difficulty.size();i++){\\n            jobs[i]=(make_pair(difficulty[i],profit[i]));\\n        }\\n        \\n        sort(jobs.begin(),jobs.end(),[](const pair<int,int> &a,const pair<int,int> &b){\\n            return a.first<b.first || ((a.first==b.first)&&(a.second<b.second));\\n        });\\n        for(int i=1;i<jobs.size();i++){\\n            jobs[i].second=max(jobs[i].second,jobs[i-1].second);\\n        }\\n        for(auto work:worker){\\n            out+=findProfit(jobs,work);\\n        }\\n        return out;\\n    }\\n};\\n```\n```\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int out=0;\\n        vector<pair<int,int>> jobs(difficulty.size());\\n        for(int i=0;i<difficulty.size();i++){\\n            jobs[i]=(make_pair(difficulty[i],profit[i]));\\n        }\\n        \\n        sort(jobs.begin(),jobs.end(),[](const pair<int,int> &a,const pair<int,int> &b){\\n            return a.first<b.first || ((a.first==b.first)&&(a.second<b.second));\\n        });\\n        sort(worker.begin(),worker.end());\\n        int i=0,maxP=0;\\n        for(auto work:worker){\\n            while(i<jobs.size() && work>=jobs[i].first) maxP=max(maxP,jobs[i++].second);\\n            out+=maxP;\\n        }\\n        return out;\\n    }\\n```\n```\\nvar maxProfitAssignment = function(difficulty, profit, worker) {\\n\\n    let out=0;\\n    let p=new Array(difficulty.length).fill(0).map(() => new Array(2).fill(0));\\n    difficulty.forEach(function(value,index){\\n        p[index]=[difficulty[index],profit[index]];\\n    });\\n\\n    p.sort((a,b)=> a[0]-b[0] || ((a[0]==b[0])&&(a[1]-b[1])));\\n    \\n    let i=0,maxP=0;\\n    worker.sort((a,b)=>a-b);\\n    for(let work of worker){\\n        while(i<p.length && work>=p[i][0])maxP=Math.max(p[i++][1],maxP)\\n        out+=maxP;\\n        \\n    }\\n    return out;\\n};\\n```\n```\\nlet findProfit= function(difficulty,target){\\n\\n    let low=0;\\n    let high=difficulty.length-1;\\n\\n    while(low+1<high){\\n        let mid=low+((high-low)>>1);\\n\\n        if(target>=difficulty[mid][0]){\\n            low=mid;\\n        }else{\\n            high=mid;\\n        }\\n    }\\n    if(target>=difficulty[high][0]) return difficulty[high][1];\\n    if(target>=difficulty[low][0]) return difficulty[low][1];\\n\\n    return 0;\\n}\\n    \\nvar maxProfitAssignment = function(difficulty, profit, worker) {\\n\\n    let out=0;\\n    let p=new Array(difficulty.length).fill(0).map(() => new Array(2).fill(0));\\n    for(let i=0;i<difficulty.length;i++){\\n        p[i]=[difficulty[i],profit[i]];\\n    }\\n\\n    p.sort((a,b)=> a[0]-b[0] || ((a[0]==b[0])&&(a[1]-b[1])));\\n    for(let i=1;i<p.length;i++){\\n        p[i][1]=Math.max(p[i][1],p[i-1][1]);\\n    }\\n    for(let work of worker){\\n        out+=findProfit(p,work);\\n    }\\n    return out;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 188589,
                "title": "kotlin-solution",
                "content": "```\\nclass Solution {\\n    fun maxProfitAssignment(difficulty: IntArray, profit: IntArray, worker: IntArray): Int {\\n        val costAndProfit = (0 until difficulty.size)\\n                .map { Pair(difficulty[it], profit[it]) }\\n                .sortedBy { it.first }\\n                .groupBy { it.first }\\n                .map { it -> Pair(it.key, it.value.maxBy { it.second }!!.second) }\\n        \\n        val prefixMaxProfit = IntArray(costAndProfit.size)\\n        (0 until prefixMaxProfit.size).forEach {\\n            when (it) {\\n                0 -> prefixMaxProfit[it] = costAndProfit[0].second\\n                else -> prefixMaxProfit[it] = Math.max(prefixMaxProfit[it - 1], costAndProfit[it].second)\\n            }\\n        }\\n        \\n        return worker.sumBy { ability ->\\n            val insertAt = costAndProfit.binarySearchBy(ability, 0, costAndProfit.size) { it.first }\\n            when {\\n                insertAt >= 0 -> prefixMaxProfit[insertAt]\\n                insertAt == -1 -> 0\\n                else -> prefixMaxProfit[-insertAt - 2]\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun maxProfitAssignment(difficulty: IntArray, profit: IntArray, worker: IntArray): Int {\\n        val costAndProfit = (0 until difficulty.size)\\n                .map { Pair(difficulty[it], profit[it]) }\\n                .sortedBy { it.first }\\n                .groupBy { it.first }\\n                .map { it -> Pair(it.key, it.value.maxBy { it.second }!!.second) }\\n        \\n        val prefixMaxProfit = IntArray(costAndProfit.size)\\n        (0 until prefixMaxProfit.size).forEach {\\n            when (it) {\\n                0 -> prefixMaxProfit[it] = costAndProfit[0].second\\n                else -> prefixMaxProfit[it] = Math.max(prefixMaxProfit[it - 1], costAndProfit[it].second)\\n            }\\n        }\\n        \\n        return worker.sumBy { ability ->\\n            val insertAt = costAndProfit.binarySearchBy(ability, 0, costAndProfit.size) { it.first }\\n            when {\\n                insertAt >= 0 -> prefixMaxProfit[insertAt]\\n                insertAt == -1 -> 0\\n                else -> prefixMaxProfit[-insertAt - 2]\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 164351,
                "title": "simple-java-solution-using-priority-queue",
                "content": "```\\n    public static int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((a,b) -> (a[0]-b[0]));\\n        int n = profit.length, t=0, cur=0;\\n        Arrays.sort(worker);\\n        \\n        for(int i=0;i<n;i++){\\n            pq.add(new int[]{difficulty[i],profit[i]});\\n        }\\n        \\n        for(int i=0;i<worker.length;i++){\\n            while(!pq.isEmpty() && worker[i] >= pq.peek()[0]){\\n                cur = Math.max(cur, pq.poll()[1]);\\n            }\\n            t += cur;\\n        }\\n        \\n        return t;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public static int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((a,b) -> (a[0]-b[0]));\\n        int n = profit.length, t=0, cur=0;\\n        Arrays.sort(worker);\\n        \\n        for(int i=0;i<n;i++){\\n            pq.add(new int[]{difficulty[i],profit[i]});\\n        }\\n        \\n        for(int i=0;i<worker.length;i++){\\n            while(!pq.isEmpty() && worker[i] >= pq.peek()[0]){\\n                cur = Math.max(cur, pq.poll()[1]);\\n            }\\n            t += cur;\\n        }\\n        \\n        return t;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 130307,
                "title": "c-nlogn-solution-greedy-using-map-and-sort",
                "content": "```\\n#include <vector>\\n#include <algorithm>\\n#include <vector>\\n#include <algorithm>\\n#include <functional>\\n#include <map>\\nusing namespace std;\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        map<int,int,greater<int>> m;\\n        for(int i = 0 ; i < difficulty.size() ; i++)\\n                {\\n                  m[profit[i]] =( m[profit[i]] > difficulty[i] ) ||  m[profit[i]] == 0 ? difficulty[i] : m[profit[i]];\\n                }\\n        sort(worker.begin(),worker.end(),greater<int>());\\n        int ans = 0;\\n        auto iter = m.begin();\\n        for(int i = 0 ; i < worker.size() ; i++)\\n        {\\n          while(iter != m.end() && worker[i] < iter->second ) iter =  m.erase(iter);\\n                ans += iter == m.end() ? 0 : iter->first;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nThe key thought is sort and \\n1.if worker_i.ablity > worker_j.ablity && worker_i cannot finish job_k , the work_j cannot finish job_k either.\\n2.if job_m.profit == job_n.profit && job_m.difficulty < job_n.difficulty , then no one will select job_n.\\nSo use sort is a very good way .",
                "solutionTags": [],
                "code": "```\\n#include <vector>\\n#include <algorithm>\\n#include <vector>\\n#include <algorithm>\\n#include <functional>\\n#include <map>\\nusing namespace std;\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        map<int,int,greater<int>> m;\\n        for(int i = 0 ; i < difficulty.size() ; i++)\\n                {\\n                  m[profit[i]] =( m[profit[i]] > difficulty[i] ) ||  m[profit[i]] == 0 ? difficulty[i] : m[profit[i]];\\n                }\\n        sort(worker.begin(),worker.end(),greater<int>());\\n        int ans = 0;\\n        auto iter = m.begin();\\n        for(int i = 0 ; i < worker.size() ; i++)\\n        {\\n          while(iter != m.end() && worker[i] < iter->second ) iter =  m.erase(iter);\\n                ans += iter == m.end() ? 0 : iter->first;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 129241,
                "title": "c-sort-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int res = 0;\\n        vector<vector<int>>v;\\n        for(int i = 0; i < difficulty.size(); i++) v.push_back({difficulty[i], profit[i]});\\n        sort(v.begin(), v.end(), [](vector<int>& v1, vector<int>& v2){ return v1[0] < v2[0]; });\\n        int maxProfit = 0;\\n        for(auto& x: v){\\n            maxProfit = max(maxProfit, x[1]);\\n            x[1] = maxProfit;\\n        }\\n        for(auto& x: worker){\\n            int pos = upper_bound(v.begin(), v.end(), x, [](int v1, vector<int>& v2){ return v1 < v2[0]; }) - v.begin() - 1;\\n            if(pos >= 0) res += v[pos][1];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int res = 0;\\n        vector<vector<int>>v;\\n        for(int i = 0; i < difficulty.size(); i++) v.push_back({difficulty[i], profit[i]});\\n        sort(v.begin(), v.end(), [](vector<int>& v1, vector<int>& v2){ return v1[0] < v2[0]; });\\n        int maxProfit = 0;\\n        for(auto& x: v){\\n            maxProfit = max(maxProfit, x[1]);\\n            x[1] = maxProfit;\\n        }\\n        for(auto& x: worker){\\n            int pos = upper_bound(v.begin(), v.end(), x, [](int v1, vector<int>& v2){ return v1 < v2[0]; }) - v.begin() - 1;\\n            if(pos >= 0) res += v[pos][1];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 127873,
                "title": "c-o-n-using-map",
                "content": "using map to remove possible same level with different profit, and then sort according to the difficulty.\\nsort the worker and using two pointer method to loop. The complxity is O(n+m)\\nThe max_profit is the max profit so far at difficulty level. This is to handle the case when the difficulty is higher, but profit is lower.\\nI add a INT_MAX diffcult at the map so that we can handle the worker>the max difficulty case.\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        map<int,int> vp;\\n        for(int i=0;i<profit.size();i++) vp[difficulty[i]]=max(vp[difficulty[i]],profit[i]);\\n        vp[INT_MAX]=0;//add one as the end so worker>max can work\\n        sort(worker.begin(),worker.end());\\n        int i=0,max_profit=0,total=0; //max shall be 0\\n        for(auto it=vp.begin();it!=vp.end();it++)\\n        {\\n            while(it->first>worker[i])\\n            {\\n                total+=max_profit;i++;\\n                if(i>=worker.size()) break;\\n            }\\n            if(i>=worker.size()) break;\\n            max_profit=max(max_profit,it->second);\\n        }\\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        map<int,int> vp;\\n        for(int i=0;i<profit.size();i++) vp[difficulty[i]]=max(vp[difficulty[i]],profit[i]);\\n        vp[INT_MAX]=0;//add one as the end so worker>max can work\\n        sort(worker.begin(),worker.end());\\n        int i=0,max_profit=0,total=0; //max shall be 0\\n        for(auto it=vp.begin();it!=vp.end();it++)\\n        {\\n            while(it->first>worker[i])\\n            {\\n                total+=max_profit;i++;\\n                if(i>=worker.size()) break;\\n            }\\n            if(i>=worker.size()) break;\\n            max_profit=max(max_profit,it->second);\\n        }\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 127151,
                "title": "java-accepted-solution",
                "content": "Sort and assign.\\n\\n```\\nclass Solution {\\n    private class Task {\\n        int diff;\\n        int pro;\\n        public Task(int d, int p) {\\n            diff = d;\\n            pro = p;\\n        }\\n    }\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        List<Task> tasks = new ArrayList<>();\\n        for (int i = 0; i < profit.length; i++) {\\n            tasks.add(new Task(difficulty[i], profit[i]));\\n        }\\n        \\n        Collections.sort(tasks, (a, b) -> b.pro - a.pro);\\n        int res = 0;\\n        for (int i = 0; i < worker.length; i++) {\\n            for (Task t : tasks) {\\n                if (t.diff <= worker[i]) {\\n                    res += t.pro;\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private class Task {\\n        int diff;\\n        int pro;\\n        public Task(int d, int p) {\\n            diff = d;\\n            pro = p;\\n        }\\n    }\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        List<Task> tasks = new ArrayList<>();\\n        for (int i = 0; i < profit.length; i++) {\\n            tasks.add(new Task(difficulty[i], profit[i]));\\n        }\\n        \\n        Collections.sort(tasks, (a, b) -> b.pro - a.pro);\\n        int res = 0;\\n        for (int i = 0; i < worker.length; i++) {\\n            for (Task t : tasks) {\\n                if (t.diff <= worker[i]) {\\n                    res += t.pro;\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 127114,
                "title": "concise-java-solution-using-map",
                "content": "```\\n public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        HashMap<Integer,Integer> map = new HashMap();\\n        int maxD = 0;\\n        for(int i = 0;i<difficulty.length;++i){\\n            if(!map.containsKey(difficulty[i])) map.put(difficulty[i],profit[i]);   \\n            else map.put(difficulty[i],Math.max(map.get(difficulty[i]),profit[i])); \\n            maxD = Math.max(maxD,difficulty[i]);     \\n        }    \\n        int[] p =  new int[maxD + 1];\\n        for(int i=1;i<p.length;++i){\\n            p[i] = Math.max(p[i-1],map.getOrDefault(i,0));  // max profit for difficulty in [1,maxD]\\n        }\\n        \\n        int maxP = 0;\\n        for(int i=0;i<worker.length;++i){\\n            maxP+= worker[i] > maxD? p[maxD] : p[worker[i]];\\n        }\\n        return maxP;\\n    }",
                "solutionTags": [],
                "code": "```\\n public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        HashMap<Integer,Integer> map = new HashMap();\\n        int maxD = 0;\\n        for(int i = 0;i<difficulty.length;++i){\\n            if(!map.containsKey(difficulty[i])) map.put(difficulty[i],profit[i]);   \\n            else map.put(difficulty[i],Math.max(map.get(difficulty[i]),profit[i])); \\n            maxD = Math.max(maxD,difficulty[i]);     \\n        }    \\n        int[] p =  new int[maxD + 1];\\n        for(int i=1;i<p.length;++i){\\n            p[i] = Math.max(p[i-1],map.getOrDefault(i,0));  // max profit for difficulty in [1,maxD]\\n        }\\n        \\n        int maxP = 0;\\n        for(int i=0;i<worker.length;++i){\\n            maxP+= worker[i] > maxD? p[maxD] : p[worker[i]];\\n        }\\n        return maxP;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 127028,
                "title": "java-solution-o-m-n-log-m-n-time-and-o-n-space-with-explanation-easily-understand",
                "content": "```\\n/** O O((m + n)log(m + n)) time complexity and O(n) space complexity, m is the length of workers, n is length of jobs;\\n *  sort jobs according to the profit, and sort workers\\n *  scan jobs and workers both from the end, for worker[i], decrement j if jobs[j].level is higher than worker[i];\\n *  otherwise, the current profit is highest one worker[i] can achieve, add it to the maxprofit;\\n *  for worker[i - 1], since worker[i - 1] can only complete work with difficulty less than worker[i]\\n *  so all the previous jobs pass by worker[i] will also be passed by worker[i - 1], so we don\\'t need to back up pointer j to recheck\\n */\\nclass Solution {\\n    private class Job implements Comparable<Job>{\\n        int level;\\n        int prof;\\n        \\n        public Job(int level, int prof) {\\n            this.level = level;\\n            this.prof = prof;\\n        }\\n        \\n        public int compareTo(Job that) {\\n            return this.prof - that.prof;\\n        }\\n    }\\n    \\n            \\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        Arrays.sort(worker);\\n        int n = difficulty.length;\\n        Job[] jobs = new Job[n];\\n        for (int i = 0; i < n; i++) {\\n            jobs[i] = new Job(difficulty[i], profit[i]);\\n        }\\n        Arrays.sort(jobs);\\n        int max = 0;\\n        \\n        int i = worker.length - 1, j = jobs.length - 1;\\n        while (i >= 0 && j >= 0) {\\n            if (jobs[j].level > worker[i]) j--;\\n            else {\\n                max += jobs[j].prof;\\n                i--;\\n            }\\n        }\\n        return max;     \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    private class Job implements Comparable<Job>{\\n        int level;\\n        int prof;\\n        \\n        public Job(int level, int prof) {\\n            this.level = level;\\n            this.prof = prof;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 126988,
                "title": "o-m-n-solution-based-on-preprocessing",
                "content": "Just keep a preprocess array for max profit until difficulty[index]\\n\\n```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        int [] diff = new int[100000 + 1]; //10^5\\n        //diff[i] = maxProfit until difficulty i (inclusive)\\n        for(int i = 0; i < difficulty.length; ++i){\\n            diff[difficulty[i]] = Math.max(diff[difficulty[i]], profit[i]);\\n        }\\n        \\n        for(int i = 1; i < diff.length; ++i){\\n            diff[i] = Math.max(diff[i], diff[i - 1]);\\n        }\\n        int sol = 0;\\n        \\n        for(int x : worker) sol += diff[x];\\n        return sol;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        int [] diff = new int[100000 + 1]; //10^5\\n        //diff[i] = maxProfit until difficulty i (inclusive)\\n        for(int i = 0; i < difficulty.length; ++i){\\n            diff[difficulty[i]] = Math.max(diff[difficulty[i]], profit[i]);\\n        }\\n        \\n        for(int i = 1; i < diff.length; ++i){\\n            diff[i] = Math.max(diff[i], diff[i - 1]);\\n        }\\n        int sol = 0;\\n        \\n        for(int x : worker) sol += diff[x];\\n        return sol;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 126987,
                "title": "easy-to-understand-java-solution-with-priorityqueue-detail-explanation",
                "content": "This problem seems easy at first glance, but it does not provide too much details. Now consider, if a lower difficulty task has a higher profit, or two same difficulty tasks have different profits, then simply sorting the arrays and putting them into a map will not yield the most profit (sometimes it may work?). So I used a PriorityQueue to sort based on the profit (descending), and if there are same profits, then sort by their corresponding difficulties (descending). \\nNow sort the workers array. Check if their abilities are sufficient to do the work (pq.peek()). This way, it will certainly yield the highest profit.\\n```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n\\t\\t// sort the profit and difficulty arrays based on profit value and then difficulty values.\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(new Comparator<int[]>() {\\n            public int compare(int[] a, int[] b) {\\n                if (a[0] > b[0]) return -1;\\n                else if (a[0] < b[0]) return 1;\\n                else return b[1] - a[1];\\n            }\\n        });\\n        for (int i = 0; i < profit.length; i++) {\\n            pq.offer(new int[]{profit[i], difficulty[i]});\\n        }\\n        Arrays.sort(worker);\\n        int res = 0;\\n\\t\\t\\t\\t// check workers ability, if it does not match, the next object in the pq will give next highest profit with less difficulty \\n        for (int i = worker.length - 1; i >= 0; i--) {\\n            while (!pq.isEmpty() && worker[i] < pq.peek()[1]) pq.poll();\\n            if (!pq.isEmpty()) res += pq.peek()[0];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n\\t\\t// sort the profit and difficulty arrays based on profit value and then difficulty values.\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(new Comparator<int[]>() {\\n            public int compare(int[] a, int[] b) {\\n                if (a[0] > b[0]) return -1;\\n                else if (a[0] < b[0]) return 1;\\n                else return b[1] - a[1];\\n            }\\n        });\\n        for (int i = 0; i < profit.length; i++) {\\n            pq.offer(new int[]{profit[i], difficulty[i]});\\n        }\\n        Arrays.sort(worker);\\n        int res = 0;\\n\\t\\t\\t\\t// check workers ability, if it does not match, the next object in the pq will give next highest profit with less difficulty \\n        for (int i = worker.length - 1; i >= 0; i--) {\\n            while (!pq.isEmpty() && worker[i] < pq.peek()[1]) pq.poll();\\n            if (!pq.isEmpty()) res += pq.peek()[0];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 126983,
                "title": "python-solution",
                "content": "```\\n    def maxProfitAssignment(self, difficulty, profit, worker):\\n        \"\"\"\\n        :type difficulty: List[int]\\n        :type profit: List[int]\\n        :type worker: List[int]\\n        :rtype: int\\n        \"\"\"\\n        import bisect\\n        \\n        sum_=0\\n        \\n        diff_profit = [(a,b) for a,b in zip(difficulty,profit)]\\n        \\n        diff_profit=sorted(diff_profit, key=lambda a:a[0])\\n                \\n        new_diffs=[0]\\n        new_profits=[0]\\n        \\n        for i in range(len(diff_profit)):\\n            if diff_profit[i][1]>new_profits[-1]:\\n                new_profits.append(diff_profit[i][1])\\n                new_diffs.append(diff_profit[i][0])\\n\\n        \\n        for i in range(len(worker)):\\n            index= bisect.bisect(new_diffs, worker[i])\\n            # print index, worker[i]\\n            if index-1<0:\\n                continue\\n            sum_+=new_profits[index-1]\\n        return sum_\\n```",
                "solutionTags": [],
                "code": "```\\n    def maxProfitAssignment(self, difficulty, profit, worker):\\n        \"\"\"\\n        :type difficulty: List[int]\\n        :type profit: List[int]\\n        :type worker: List[int]\\n        :rtype: int\\n        \"\"\"\\n        import bisect\\n        \\n        sum_=0\\n        \\n        diff_profit = [(a,b) for a,b in zip(difficulty,profit)]\\n        \\n        diff_profit=sorted(diff_profit, key=lambda a:a[0])\\n                \\n        new_diffs=[0]\\n        new_profits=[0]\\n        \\n        for i in range(len(diff_profit)):\\n            if diff_profit[i][1]>new_profits[-1]:\\n                new_profits.append(diff_profit[i][1])\\n                new_diffs.append(diff_profit[i][0])\\n\\n        \\n        for i in range(len(worker)):\\n            index= bisect.bisect(new_diffs, worker[i])\\n            # print index, worker[i]\\n            if index-1<0:\\n                continue\\n            sum_+=new_profits[index-1]\\n        return sum_\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 126956,
                "title": "easy-java-solution-with-treemap-sorting",
                "content": "```\\npublic int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        int[][] arr = new int[difficulty.length][2];\\n        for(int i=0; i < difficulty.length; i++){\\n\\t\\t\\tarr[i][0] = difficulty[i];\\n\\t\\t\\tarr[i][1] = profit[i];\\n\\t\\t}\\n        Arrays.sort(arr, new Comparator<int[]>(){\\n\\t\\t\\t@Override\\n\\t\\t\\tpublic int compare(int[] a1, int[] a2){\\n\\t\\t\\t\\treturn a1[0]<a2[0]? -1: a1[0] == a2[0]? 0:1;\\n\\t\\t\\t}\\n\\t\\t});\\n        for(int i=1; i<arr.length; i++){\\n\\t\\t\\tarr[i][1] = Math.max(arr[i-1][1], arr[i][1]);\\n\\t\\t}\\n\\t\\tfor(int i=0; i<arr.length; i++){\\n\\t\\t\\tmap.put(arr[i][0], arr[i][1]);\\n\\t\\t}\\n        int ans = 0;\\n\\t\\tfor(int i=0; i<worker.length; i++){\\n\\t\\t\\tint ability = worker[i];\\n\\t\\t\\tInteger index = map.floorKey(ability);\\n\\t\\t\\tif(index != null){\\n                ans+=map.get(index);\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        int[][] arr = new int[difficulty.length][2];\\n        for(int i=0; i < difficulty.length; i++){\\n\\t\\t\\tarr[i][0] = difficulty[i];\\n\\t\\t\\tarr[i][1] = profit[i];\\n\\t\\t}\\n        Arrays.sort(arr, new Comparator<int[]>(){\\n\\t\\t\\t@Override\\n\\t\\t\\tpublic int compare(int[] a1, int[] a2){\\n\\t\\t\\t\\treturn a1[0]<a2[0]? -1: a1[0] == a2[0]? 0:1;\\n\\t\\t\\t}\\n\\t\\t});\\n        for(int i=1; i<arr.length; i++){\\n\\t\\t\\tarr[i][1] = Math.max(arr[i-1][1], arr[i][1]);\\n\\t\\t}\\n\\t\\tfor(int i=0; i<arr.length; i++){\\n\\t\\t\\tmap.put(arr[i][0], arr[i][1]);\\n\\t\\t}\\n        int ans = 0;\\n\\t\\tfor(int i=0; i<worker.length; i++){\\n\\t\\t\\tint ability = worker[i];\\n\\t\\t\\tInteger index = map.floorKey(ability);\\n\\t\\t\\tif(index != null){\\n                ans+=map.get(index);\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 126941,
                "title": "python-binary-search-solution-with-comments",
                "content": "```\\nclass Solution(object):\\n    def maxProfitAssignment(self, diff, pro, worker):\\n        N = len(diff)\\n        # Record max profit for each difficulty\\n        dic = {}\\n        for i in range(N):\\n            if diff[i] not in dic or pro[i]>dic[diff[i]]:\\n                dic[diff[i]] = pro[i]\\n        # Sort difficult and record max profit with diff[i] in pre\\n        diff = list(set(diff))\\n        diff.sort()\\n        pre = [0]*(len(diff)+1)\\n        \\n        for i in range(len(diff)):\\n            pre[i] = max(pre[i-1], dic[diff[i]])\\n        \\n        ret = 0\\n        for w in worker:\\n            # Use binary seach for each worker\\n            idx = bisect.bisect_left(diff, w)\\n            if idx==len(diff) or w<diff[idx]:\\n                idx -= 1\\n            ret += pre[idx]\\n        return ret\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxProfitAssignment(self, diff, pro, worker):\\n        N = len(diff)\\n        # Record max profit for each difficulty\\n        dic = {}\\n        for i in range(N):\\n            if diff[i] not in dic or pro[i]>dic[diff[i]]:\\n                dic[diff[i]] = pro[i]\\n        # Sort difficult and record max profit with diff[i] in pre\\n        diff = list(set(diff))\\n        diff.sort()\\n        pre = [0]*(len(diff)+1)\\n        \\n        for i in range(len(diff)):\\n            pre[i] = max(pre[i-1], dic[diff[i]])\\n        \\n        ret = 0\\n        for w in worker:\\n            # Use binary seach for each worker\\n            idx = bisect.bisect_left(diff, w)\\n            if idx==len(diff) or w<diff[idx]:\\n                idx -= 1\\n            ret += pre[idx]\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4096222,
                "title": "easiest-way-to-solve-using-matrix-and-greedy-approch",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} difficulty\\n * @param {number[]} profit\\n * @param {number[]} worker\\n * @return {number}\\n */\\nvar maxProfitAssignment = function(difficulty, profit, worker) {\\n    // //brute force\\n    // let resprofit=0,map=new Map();\\n    // for(let i=0;i<difficulty.length;i++){\\n    //     map.set(difficulty[i],profit[i]);\\n    // }\\n    // const getMaxProfit=(target)=>{\\n    //     let maxprofit=0;\\n    //  for(let i=0;i<difficulty.length;i++){\\n    //   if(difficulty[i]<=target){\\n    //   maxprofit=Math.max(maxprofit,map.get(difficulty[i]))\\n    //   }\\n    //   else break;\\n    //  }\\n    //  return maxprofit;\\n    // }\\n    // for(let i=0;i<worker.length;i++){\\n    //     let currworker=worker[i];\\n    //     resprofit+=getMaxProfit(currworker);\\n    // }\\n    // return resprofit;\\n\\n    //greedy approch\\n    let jobs=[];\\n    for(let i=0;i<difficulty.length;i++){\\n        jobs.push([difficulty[i],profit[i]]);\\n    }\\n    jobs.sort((a,b)=>a[0]-b[0]);\\n    worker.sort((a,b)=>a-b);\\n\\n    let maxprofit=0,jobindex=0,bestprofit=0;\\n    for(let i=0;i<worker.length;i++){\\n        let ability=worker[i];\\n        while(jobindex < difficulty.length && jobs[jobindex][0] <=ability){\\n            bestprofit=Math.max(bestprofit,jobs[jobindex][1]);\\n            jobindex++;\\n        }\\n        maxprofit+=bestprofit;\\n    }\\n    return maxprofit;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} difficulty\\n * @param {number[]} profit\\n * @param {number[]} worker\\n * @return {number}\\n */\\nvar maxProfitAssignment = function(difficulty, profit, worker) {\\n    // //brute force\\n    // let resprofit=0,map=new Map();\\n    // for(let i=0;i<difficulty.length;i++){\\n    //     map.set(difficulty[i],profit[i]);\\n    // }\\n    // const getMaxProfit=(target)=>{\\n    //     let maxprofit=0;\\n    //  for(let i=0;i<difficulty.length;i++){\\n    //   if(difficulty[i]<=target){\\n    //   maxprofit=Math.max(maxprofit,map.get(difficulty[i]))\\n    //   }\\n    //   else break;\\n    //  }\\n    //  return maxprofit;\\n    // }\\n    // for(let i=0;i<worker.length;i++){\\n    //     let currworker=worker[i];\\n    //     resprofit+=getMaxProfit(currworker);\\n    // }\\n    // return resprofit;\\n\\n    //greedy approch\\n    let jobs=[];\\n    for(let i=0;i<difficulty.length;i++){\\n        jobs.push([difficulty[i],profit[i]]);\\n    }\\n    jobs.sort((a,b)=>a[0]-b[0]);\\n    worker.sort((a,b)=>a-b);\\n\\n    let maxprofit=0,jobindex=0,bestprofit=0;\\n    for(let i=0;i<worker.length;i++){\\n        let ability=worker[i];\\n        while(jobindex < difficulty.length && jobs[jobindex][0] <=ability){\\n            bestprofit=Math.max(bestprofit,jobs[jobindex][1]);\\n            jobindex++;\\n        }\\n        maxprofit+=bestprofit;\\n    }\\n    return maxprofit;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4090525,
                "title": "c-sorting",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n\\\\log{n})$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int res = 0;\\n        vector<vector<int>> v;\\n        for (int i = 0; i < profit.size(); ++ i) v.push_back({difficulty[i], profit[i]});\\n        sort(v.begin(), v.end(), [] (const vector<int>& l, const vector<int>& r) {\\n            return l[0] == r[0] ? l[1] < r[1] : l[0] < r[0];\\n        });\\n        for (int i = 1; i < v.size(); ++ i) v[i][1] = max(v[i][1], v[i - 1][1]);\\n        sort(worker.begin(), worker.end());\\n        int k = 0;\\n        for (int w : worker) {\\n            while (k < v.size() && v[k][0] <= w) ++ k;\\n            if (k) -- k;\\n            if (v[k][0] <= w) res += v[k][1];\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Please upvote if u like the solution :)**",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int res = 0;\\n        vector<vector<int>> v;\\n        for (int i = 0; i < profit.size(); ++ i) v.push_back({difficulty[i], profit[i]});\\n        sort(v.begin(), v.end(), [] (const vector<int>& l, const vector<int>& r) {\\n            return l[0] == r[0] ? l[1] < r[1] : l[0] < r[0];\\n        });\\n        for (int i = 1; i < v.size(); ++ i) v[i][1] = max(v[i][1], v[i - 1][1]);\\n        sort(worker.begin(), worker.end());\\n        int k = 0;\\n        for (int w : worker) {\\n            while (k < v.size() && v[k][0] <= w) ++ k;\\n            if (k) -- k;\\n            if (v[k][0] <= w) res += v[k][1];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055585,
                "title": "c-o-nlogn-easy-solution",
                "content": "# Complexity\\n# - Time complexity:**O(nlogn)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# - Space complexity:**O(n)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& d, vector<int>& p, vector<int>& w){\\n        vector<pair<int,int>>vp;\\n        for(int i =0 ;i<(int)d.size();i++){\\n            vp.push_back(make_pair(d[i],p[i]));\\n        }\\n        sort(d.begin(),d.end()),sort(vp.begin(),vp.end());\\n        int res = 0;\\n        for(int i = 1;i<(int)vp.size();i++){\\n            vp[i].second = max(vp[i].second,vp[i-1].second);\\n        }\\n        for(int i = 0;i<(int)w.size();i++){\\n            int idx = upper_bound(d.begin(),d.end(),w[i]) - d.begin();\\n            if(idx){\\n                idx--;\\n                res+=vp[idx].second;\\n            }\\n\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& d, vector<int>& p, vector<int>& w){\\n        vector<pair<int,int>>vp;\\n        for(int i =0 ;i<(int)d.size();i++){\\n            vp.push_back(make_pair(d[i],p[i]));\\n        }\\n        sort(d.begin(),d.end()),sort(vp.begin(),vp.end());\\n        int res = 0;\\n        for(int i = 1;i<(int)vp.size();i++){\\n            vp[i].second = max(vp[i].second,vp[i-1].second);\\n        }\\n        for(int i = 0;i<(int)w.size();i++){\\n            int idx = upper_bound(d.begin(),d.end(),w[i]) - d.begin();\\n            if(idx){\\n                idx--;\\n                res+=vp[idx].second;\\n            }\\n\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4024965,
                "title": "easiest-solution",
                "content": "\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n     int totalProfit = 0;\\n\\n    TreeMap<Integer, Integer> jobMap = new TreeMap<>();\\n    for (int i = 0; i < difficulty.length; i++) {\\n        jobMap.put(difficulty[i], Math.max(jobMap.getOrDefault(difficulty[i], 0), profit[i]));\\n    }\\n\\n    int maxProfit = 0;\\n    int res = 0;\\n    int max = 0;\\n\\n    for(Integer key: jobMap.keySet()){\\n        max = Math.max(jobMap.get(key),max);\\n        jobMap.put(key,max);\\n    }\\n\\n    for (int w : worker) {\\n        Integer bestDifficulty = jobMap.floorKey(w); // Find the best job difficulty\\n        if (bestDifficulty != null) {\\n            maxProfit = jobMap.get(bestDifficulty);\\n        }\\n        if(bestDifficulty != null) {\\n            totalProfit += maxProfit;\\n        }\\n    }\\n\\n    return totalProfit;\\n    }\\n}\\n```\\n```c++ []\\nclass Solution {\\npublic:\\n    \\n   \\n    int maxProfitAssignment(vector<int>& d, vector<int>& p, vector<int>& w) {\\n\\n        vector<int> pos(100005,0);\\n    \\n        for(int i = 0;i<d.size();i++)\\n        pos[d[i]] = max(p[i],pos[d[i]]); \\n        \\n        int maxprofit = 0,ans = 0;\\n        for(int i = 0;i<pos.size();i++)\\n        {\\n            maxprofit = max(maxprofit,pos[i]);\\n            pos[i] = maxprofit;\\n        }\\n        for(int i = 0;i<w.size();i++)\\n        ans+=pos[w[i]];\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n     int totalProfit = 0;\\n\\n    TreeMap<Integer, Integer> jobMap = new TreeMap<>();\\n    for (int i = 0; i < difficulty.length; i++) {\\n        jobMap.put(difficulty[i], Math.max(jobMap.getOrDefault(difficulty[i], 0), profit[i]));\\n    }\\n\\n    int maxProfit = 0;\\n    int res = 0;\\n    int max = 0;\\n\\n    for(Integer key: jobMap.keySet()){\\n        max = Math.max(jobMap.get(key),max);\\n        jobMap.put(key,max);\\n    }\\n\\n    for (int w : worker) {\\n        Integer bestDifficulty = jobMap.floorKey(w); // Find the best job difficulty\\n        if (bestDifficulty != null) {\\n            maxProfit = jobMap.get(bestDifficulty);\\n        }\\n        if(bestDifficulty != null) {\\n            totalProfit += maxProfit;\\n        }\\n    }\\n\\n    return totalProfit;\\n    }\\n}\\n```\n```c++ []\\nclass Solution {\\npublic:\\n    \\n   \\n    int maxProfitAssignment(vector<int>& d, vector<int>& p, vector<int>& w) {\\n\\n        vector<int> pos(100005,0);\\n    \\n        for(int i = 0;i<d.size();i++)\\n        pos[d[i]] = max(p[i],pos[d[i]]); \\n        \\n        int maxprofit = 0,ans = 0;\\n        for(int i = 0;i<pos.size();i++)\\n        {\\n            maxprofit = max(maxprofit,pos[i]);\\n            pos[i] = maxprofit;\\n        }\\n        for(int i = 0;i<w.size();i++)\\n        ans+=pos[w[i]];\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012095,
                "title": "simple-sorting-for-loop-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& d,vector<int>& p,vector<int>& w) \\n    {\\n        int ans=0;\\n        vector<pair<int,int>>v;\\n        for(int i=0;i<d.size();i++)\\n        {\\n            v.push_back(make_pair(p[i],d[i]));\\n        }\\n        sort(v.rbegin(),v.rend());\\n        sort(w.rbegin(),w.rend());\\n        int j=0;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            if(w[j]>=v[i].second)\\n            {\\n                ans+=v[i].first;\\n                j++;\\n                i--;\\n            }\\n            if(j==w.size()) break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& d,vector<int>& p,vector<int>& w) \\n    {\\n        int ans=0;\\n        vector<pair<int,int>>v;\\n        for(int i=0;i<d.size();i++)\\n        {\\n            v.push_back(make_pair(p[i],d[i]));\\n        }\\n        sort(v.rbegin(),v.rend());\\n        sort(w.rbegin(),w.rend());\\n        int j=0;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            if(w[j]>=v[i].second)\\n            {\\n                ans+=v[i].first;\\n                j++;\\n                i--;\\n            }\\n            if(j==w.size()) break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4007709,
                "title": "most-profit-assigning-work",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} difficulty\\n * @param {number[]} profit\\n * @param {number[]} worker\\n * @return {number}\\n */\\nvar maxProfitAssignment = function(difficulty, profit, worker) {\\n    let Ability = new Map();\\n    for(let i=0;i<worker.length;i++){\\n        for(let j=0;j<difficulty.length;j++){\\n        if(worker[i]>=difficulty[j]){\\n            if(Ability.has(i)){\\n                Ability.set(i,Math.max(Math.max(Ability.get(i),profit[j])))\\n            }\\n            else{\\n                Ability.set(i,profit[j])\\n            }\\n        }\\n        }\\n    }\\n   return Array.from(Ability.values()).reduce((acc,cur)=>{return acc+=cur},0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} difficulty\\n * @param {number[]} profit\\n * @param {number[]} worker\\n * @return {number}\\n */\\nvar maxProfitAssignment = function(difficulty, profit, worker) {\\n    let Ability = new Map();\\n    for(let i=0;i<worker.length;i++){\\n        for(let j=0;j<difficulty.length;j++){\\n        if(worker[i]>=difficulty[j]){\\n            if(Ability.has(i)){\\n                Ability.set(i,Math.max(Math.max(Ability.get(i),profit[j])))\\n            }\\n            else{\\n                Ability.set(i,profit[j])\\n            }\\n        }\\n        }\\n    }\\n   return Array.from(Ability.values()).reduce((acc,cur)=>{return acc+=cur},0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4005645,
                "title": "javascript-compact-solution",
                "content": "```javascript\\nconst maxProfitAssignment = (dif, prof, workers) => {\\n  const tasks = dif.map((d, i) => [d, prof[i]]);\\n  tasks.sort(([d1, p1], [d2, p2]) => d1 - d2);\\n\\n  workers = workers.filter((w) => w >= tasks[0][0]);\\n  if (!workers.length) return 0; // strongest worker < easiest job\\n\\n  let maxProf = 0;\\n  const balancedTasks = tasks.map(([d, p]) => {\\n    if (p > maxProf) maxProf = p;\\n    return [d, maxProf];\\n  });\\n\\n  workers.sort((a, b) => a - b);\\n  const len = balancedTasks.length;\\n  let i = 0;\\n\\n  return workers.reduce((tot, worker) => {\\n    while (i < len && balancedTasks[i][0] <= worker) i++;\\n    return tot + balancedTasks[i - 1][1];\\n  }, 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nconst maxProfitAssignment = (dif, prof, workers) => {\\n  const tasks = dif.map((d, i) => [d, prof[i]]);\\n  tasks.sort(([d1, p1], [d2, p2]) => d1 - d2);\\n\\n  workers = workers.filter((w) => w >= tasks[0][0]);\\n  if (!workers.length) return 0; // strongest worker < easiest job\\n\\n  let maxProf = 0;\\n  const balancedTasks = tasks.map(([d, p]) => {\\n    if (p > maxProf) maxProf = p;\\n    return [d, maxProf];\\n  });\\n\\n  workers.sort((a, b) => a - b);\\n  const len = balancedTasks.length;\\n  let i = 0;\\n\\n  return workers.reduce((tot, worker) => {\\n    while (i < len && balancedTasks[i][0] <= worker) i++;\\n    return tot + balancedTasks[i - 1][1];\\n  }, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3992366,
                "title": "greedy-static-comparator",
                "content": "# Intuition\\nFirst arrange the difficulty array according to the profit array in descending order so that we can select closest difficulty with max profit.\\n\\nFor all the elements of worker check if the max profit difficulty is lesser than or equal to and if not keep decreasing difficulty.\\n\\nif correct difficulty is found add subsequent profit to the profit(total)\\n\\nreturn total profit\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool static cmp(const pair<int,int>& p1,const pair<int,int>& p2)\\n    {\\n        return p1.second>p2.second;\\n    }\\n    int maxProfitAssignment(vector<int>& d, vector<int>& p, vector<int>& w) \\n    {\\n        vector<pair<int,int>> m;//difficulty and profit\\n        for(int i=0;i<d.size();i++)\\n        {\\n            m.push_back({d[i],p[i]});\\n        }\\n        int n=w.size();\\n        int profit=0;\\n        sort(m.begin(),m.end(),cmp);\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m.size();j++)\\n            {\\n                if(m[j].first<=w[i])\\n                {\\n                    profit+=m[j].second;\\n                    break;\\n                }\\n            }\\n        }\\n        return profit;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool static cmp(const pair<int,int>& p1,const pair<int,int>& p2)\\n    {\\n        return p1.second>p2.second;\\n    }\\n    int maxProfitAssignment(vector<int>& d, vector<int>& p, vector<int>& w) \\n    {\\n        vector<pair<int,int>> m;//difficulty and profit\\n        for(int i=0;i<d.size();i++)\\n        {\\n            m.push_back({d[i],p[i]});\\n        }\\n        int n=w.size();\\n        int profit=0;\\n        sort(m.begin(),m.end(),cmp);\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m.size();j++)\\n            {\\n                if(m[j].first<=w[i])\\n                {\\n                    profit+=m[j].second;\\n                    break;\\n                }\\n            }\\n        }\\n        return profit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975311,
                "title": "dry-run-it-is-easiest-solution-begineer-friendly",
                "content": "# easy solution ...  :)\\n# HAPPY LEETCODING\\n```\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        worker.sort()\\n        arr=[]\\n        for i in range(len(profit)):\\n            arr.append([difficulty[i],profit[i]])\\n        arr.sort()\\n        ans=0\\n        max_score=0\\n        l=0\\n        for i in range(len(worker)):\\n            while l<len(arr) and arr[l][0]<=worker[i]:\\n                max_score=max(max_score,arr[l][1])\\n                l+=1\\n            ans+=max_score\\n        return ans\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n        worker.sort()\\n        arr=[]\\n        for i in range(len(profit)):\\n            arr.append([difficulty[i],profit[i]])\\n        arr.sort()\\n        ans=0\\n        max_score=0\\n        l=0\\n        for i in range(len(worker)):\\n            while l<len(arr) and arr[l][0]<=worker[i]:\\n                max_score=max(max_score,arr[l][1])\\n                l+=1\\n            ans+=max_score\\n        return ans\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938170,
                "title": "kotlin-2-pointers",
                "content": "# Intuition\\nSort both the workers (descending) and the jobs by profit (descending). Start from the first job (most profitable) and try to assign it to as many capable workers as you can.\\n\\nSince the workers array is decendengly sorted by difficulty, the most capable worker is the one at hand. If that worker can not handle the job at hand, then no other worker will. We can safley discard the job in that case and pickup the next job in line.\\n\\nKeep matching jobs with workers as long as we still have jobs and workers remaining.\\n\\n# Code\\n```\\nclass Solution {\\n\\n    data class Job(val difficulty: Int, val profit: Int)\\n\\n    fun maxProfitAssignment(difficulty: IntArray, profit: IntArray, worker: IntArray): Int {\\n       // Most capable worker is the first.\\n       worker.sortDescending()\\n\\n       val jobs = mutableListOf<Job>()\\n       for(i in difficulty.indices) {\\n           jobs.add(Job(difficulty[i], profit[i]))\\n       }\\n       // Most profitable job is the first.\\n       // Try to assign it to as many workers as we can.\\n       jobs.sortWith(Comparator { x, y -> y.profit.compareTo(x.profit) })\\n\\n       var w = 0\\n       var j = 0\\n       var sum = 0\\n       // We still have workers and jobs left.\\n       while(w < worker.size && j < jobs.size) {\\n           // The most profitable job can be handled by the most capable worker.\\n           if(jobs[j].difficulty <= worker[w]) \\n               sum += jobs[j].profit\\n               // Assign the job to the worker and pickup the next worker in line. \\n               // We\\'ll keep the same job since it is the most profitable so far.\\n               // We\\'ll try to assign it to the next worker in the next iteration.\\n               w += 1\\n           } else {\\n               // The most capable worker so far can not handle this job. No one else can.\\n               // Discard the job and pickup the next one in line.\\n               j += 1\\n           }\\n       }\\n\\n       return sum\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n\\n    data class Job(val difficulty: Int, val profit: Int)\\n\\n    fun maxProfitAssignment(difficulty: IntArray, profit: IntArray, worker: IntArray): Int {\\n       // Most capable worker is the first.\\n       worker.sortDescending()\\n\\n       val jobs = mutableListOf<Job>()\\n       for(i in difficulty.indices) {\\n           jobs.add(Job(difficulty[i], profit[i]))\\n       }\\n       // Most profitable job is the first.\\n       // Try to assign it to as many workers as we can.\\n       jobs.sortWith(Comparator { x, y -> y.profit.compareTo(x.profit) })\\n\\n       var w = 0\\n       var j = 0\\n       var sum = 0\\n       // We still have workers and jobs left.\\n       while(w < worker.size && j < jobs.size) {\\n           // The most profitable job can be handled by the most capable worker.\\n           if(jobs[j].difficulty <= worker[w]) \\n               sum += jobs[j].profit\\n               // Assign the job to the worker and pickup the next worker in line. \\n               // We\\'ll keep the same job since it is the most profitable so far.\\n               // We\\'ll try to assign it to the next worker in the next iteration.\\n               w += 1\\n           } else {\\n               // The most capable worker so far can not handle this job. No one else can.\\n               // Discard the job and pickup the next one in line.\\n               j += 1\\n           }\\n       }\\n\\n       return sum\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929649,
                "title": "java-treemap-solution-o-n",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n     int totalProfit = 0;\\n\\n    TreeMap<Integer, Integer> jobMap = new TreeMap<>();\\n    for (int i = 0; i < difficulty.length; i++) {\\n        jobMap.put(difficulty[i], Math.max(jobMap.getOrDefault(difficulty[i], 0), profit[i]));\\n    }\\n\\n    int maxProfit = 0;\\n    int res = 0;\\n    int max = 0;\\n\\n    for(Integer key: jobMap.keySet()){\\n        max = Math.max(jobMap.get(key),max);\\n        jobMap.put(key,max);\\n    }\\n\\n    for (int w : worker) {\\n        Integer bestDifficulty = jobMap.floorKey(w); // Find the best job difficulty\\n        if (bestDifficulty != null) {\\n            maxProfit = jobMap.get(bestDifficulty);\\n        }\\n        if(bestDifficulty != null) {\\n            totalProfit += maxProfit;\\n        }\\n    }\\n\\n    return totalProfit;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n     int totalProfit = 0;\\n\\n    TreeMap<Integer, Integer> jobMap = new TreeMap<>();\\n    for (int i = 0; i < difficulty.length; i++) {\\n        jobMap.put(difficulty[i], Math.max(jobMap.getOrDefault(difficulty[i], 0), profit[i]));\\n    }\\n\\n    int maxProfit = 0;\\n    int res = 0;\\n    int max = 0;\\n\\n    for(Integer key: jobMap.keySet()){\\n        max = Math.max(jobMap.get(key),max);\\n        jobMap.put(key,max);\\n    }\\n\\n    for (int w : worker) {\\n        Integer bestDifficulty = jobMap.floorKey(w); // Find the best job difficulty\\n        if (bestDifficulty != null) {\\n            maxProfit = jobMap.get(bestDifficulty);\\n        }\\n        if(bestDifficulty != null) {\\n            totalProfit += maxProfit;\\n        }\\n    }\\n\\n    return totalProfit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924278,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int maxProfitAssignment(vector<int>& diff, vector<int>& prof, vector<int>& worker) \\n    {\\n        int j,ans;\\n        j=0;\\n        ans=0;\\n\\n        vector<pair<int,int>> v;\\n\\n        for(int i=0;i<diff.size();i++)\\n        {\\n            v.push_back({diff[i],prof[i]});\\n        }    \\n\\n        sort(v.begin(),v.end());\\n        sort(worker.begin(),worker.end());\\n\\n        //for(int i=0;i<worker.size();i++)\\n        //{\\n        //    cout<<worker[i]<<\" \";\\n        //}\\n        //cout<<endl;\\n//\\n        //for(int i=0;i<v.size();i++)\\n        //{\\n        //    cout<<v[i].first<<\" \"<<v[i].second<<endl;\\n        //}\\n\\n        for(int i=0;i<worker.size();i++)\\n        {\\n            while(j<v.size() && v[j].first<=worker[i])\\n            {\\n                j++;\\n                v[j].second=max(v[j-1].second,v[j].second);\\n            }\\n\\n            if(j!=0)\\n            {\\n                ans+=v[j-1].second;\\n            }    \\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int maxProfitAssignment(vector<int>& diff, vector<int>& prof, vector<int>& worker) \\n    {\\n        int j,ans;\\n        j=0;\\n        ans=0;\\n\\n        vector<pair<int,int>> v;\\n\\n        for(int i=0;i<diff.size();i++)\\n        {\\n            v.push_back({diff[i],prof[i]});\\n        }    \\n\\n        sort(v.begin(),v.end());\\n        sort(worker.begin(),worker.end());\\n\\n        //for(int i=0;i<worker.size();i++)\\n        //{\\n        //    cout<<worker[i]<<\" \";\\n        //}\\n        //cout<<endl;\\n//\\n        //for(int i=0;i<v.size();i++)\\n        //{\\n        //    cout<<v[i].first<<\" \"<<v[i].second<<endl;\\n        //}\\n\\n        for(int i=0;i<worker.size();i++)\\n        {\\n            while(j<v.size() && v[j].first<=worker[i])\\n            {\\n                j++;\\n                v[j].second=max(v[j-1].second,v[j].second);\\n            }\\n\\n            if(j!=0)\\n            {\\n                ans+=v[j-1].second;\\n            }    \\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3872181,
                "title": "c-two-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        Array.Sort(difficulty, profit);\\n        Array.Sort(worker);\\n        \\n        int i = 0, j = 0, maxpro = 0, res = 0;\\n        \\n        while(j < worker.Length)\\n        {\\n            if(i < difficulty.Length && difficulty[i] <= worker[j])\\n            {\\n                maxpro = Math.Max(maxpro, profit[i]);\\n                i++;\\n            }\\n            else\\n            {\\n                res += maxpro;\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n        Array.Sort(difficulty, profit);\\n        Array.Sort(worker);\\n        \\n        int i = 0, j = 0, maxpro = 0, res = 0;\\n        \\n        while(j < worker.Length)\\n        {\\n            if(i < difficulty.Length && difficulty[i] <= worker[j])\\n            {\\n                maxpro = Math.Max(maxpro, profit[i]);\\n                i++;\\n            }\\n            else\\n            {\\n                res += maxpro;\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865355,
                "title": "easy-and-fast-max-heap-sorting-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1.) Use of Priority queue to obtain the maximum profit job every time.\\n2.) sort the worker array and traverse it from right side to check for the maximum skill with maximum profit from priority queue.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(NLogN)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n           \\n             priority_queue< pair<int,int>  > pq;\\n\\n             for(int i=0;i<profit.size();i++){\\n                   pq.push({profit[i],difficulty[i]});\\n             }\\n\\n             sort(worker.begin(),worker.end());\\n             int ans=0;\\n             int i=worker.size()-1;\\n\\n             while(i>=0 && !pq.empty()){\\n\\n                 int skill=worker[i];\\n\\n                 if(skill < pq.top().second)\\n                      pq.pop();\\n                 \\n                 else\\n                     ans += pq.top().first,i--;\\n\\n                     \\n\\n             }\\n\\n             \\n\\n\\n                return ans;\\n\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n           \\n             priority_queue< pair<int,int>  > pq;\\n\\n             for(int i=0;i<profit.size();i++){\\n                   pq.push({profit[i],difficulty[i]});\\n             }\\n\\n             sort(worker.begin(),worker.end());\\n             int ans=0;\\n             int i=worker.size()-1;\\n\\n             while(i>=0 && !pq.empty()){\\n\\n                 int skill=worker[i];\\n\\n                 if(skill < pq.top().second)\\n                      pq.pop();\\n                 \\n                 else\\n                     ans += pq.top().first,i--;\\n\\n                     \\n\\n             }\\n\\n             \\n\\n\\n                return ans;\\n\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3857231,
                "title": "using-maxheap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n\\n        maxHeap = []\\n        for d, p in zip(difficulty, profit):\\n            heappush(maxHeap, (-p, d))\\n\\n        sorted_worker = sorted(worker)\\n        maxProfit = 0\\n\\n        for w in sorted_worker[::-1]:\\n\\n            while maxHeap and w < maxHeap[0][1]:\\n                heappop(maxHeap)\\n            if not maxHeap:\\n                return maxProfit\\n            maxProfit += -maxHeap[0][0]\\n\\n        return maxProfit\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\\n\\n        maxHeap = []\\n        for d, p in zip(difficulty, profit):\\n            heappush(maxHeap, (-p, d))\\n\\n        sorted_worker = sorted(worker)\\n        maxProfit = 0\\n\\n        for w in sorted_worker[::-1]:\\n\\n            while maxHeap and w < maxHeap[0][1]:\\n                heappop(maxHeap)\\n            if not maxHeap:\\n                return maxProfit\\n            maxProfit += -maxHeap[0][0]\\n\\n        return maxProfit\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853608,
                "title": "c-solution-in-o-w",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int, int>> dif;\\n        for(int i=0;i<difficulty.size();i++){\\n            dif.push_back({profit[i], difficulty[i]});\\n        }\\n        sort(dif.rbegin(), dif.rend());\\n        sort(worker.rbegin(), worker.rend());\\n        int i=0, j=0,ans=0;\\n        while(i<worker.size() && j<dif.size()){\\n            if(worker[i]>=dif[j].second){\\n                ans+=dif[j].first;\\n                i++;\\n            }\\n            else j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int, int>> dif;\\n        for(int i=0;i<difficulty.size();i++){\\n            dif.push_back({profit[i], difficulty[i]});\\n        }\\n        sort(dif.rbegin(), dif.rend());\\n        sort(worker.rbegin(), worker.rend());\\n        int i=0, j=0,ans=0;\\n        while(i<worker.size() && j<dif.size()){\\n            if(worker[i]>=dif[j].second){\\n                ans+=dif[j].first;\\n                i++;\\n            }\\n            else j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3847464,
                "title": "c-sorting",
                "content": "# Complexity\\n- Time complexity:\\n$$O(nlogn(n) + mlog(m))$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int n = difficulty.size();\\n        int m = worker.size();\\n        vector<pair<int,int>> v(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            v[i].first = profit[i];\\n            v[i].second = difficulty[i];\\n        }\\n        sort(v.begin(),v.end());\\n        int i = n - 1;\\n        sort(worker.begin(),worker.end());\\n        int j = m - 1;\\n        int ans = 0;\\n        while(i >= 0)\\n        {\\n            while(j >= 0 && worker[j] >= v[i].second)\\n            {\\n                ans += v[i].first;\\n                j--;\\n            }\\n            i--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        int n = difficulty.size();\\n        int m = worker.size();\\n        vector<pair<int,int>> v(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            v[i].first = profit[i];\\n            v[i].second = difficulty[i];\\n        }\\n        sort(v.begin(),v.end());\\n        int i = n - 1;\\n        sort(worker.begin(),worker.end());\\n        int j = m - 1;\\n        int ans = 0;\\n        while(i >= 0)\\n        {\\n            while(j >= 0 && worker[j] >= v[i].second)\\n            {\\n                ans += v[i].first;\\n                j--;\\n            }\\n            i--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3828435,
                "title": "easy-to-understand-easy-solution-better-approach",
                "content": "# Intuition\\nYou have to sort the difficulty and worker array if you want to complete in one iteration.\\n\\n\\n# Complexity\\n- Time complexity: O(N logN) + O(M logM)\\n\\n- Space complexity: O(N) \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& diff, vector<int>& pro, vector<int>& wor) {\\n        int n = diff.size() , m = wor.size();\\n        vector<int> map(100001 , 0);       \\n        for(int i = 0 ; i < n ; i++){\\n            map[diff[i]] = max(map[diff[i]] , pro[i]);\\n        }\\n        sort(diff.begin() , diff.end());  \\n        sort(wor.begin() , wor.end());\\n        int i = 0 , j = 0 , ans = 0 , maxi = 0;\\n        while(i<m){\\n            while(j < n && wor[i] >= diff[j]){\\n                maxi = max(maxi , map[diff[j]]) ; j++;\\n            }\\n            ans += maxi;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& diff, vector<int>& pro, vector<int>& wor) {\\n        int n = diff.size() , m = wor.size();\\n        vector<int> map(100001 , 0);       \\n        for(int i = 0 ; i < n ; i++){\\n            map[diff[i]] = max(map[diff[i]] , pro[i]);\\n        }\\n        sort(diff.begin() , diff.end());  \\n        sort(wor.begin() , wor.end());\\n        int i = 0 , j = 0 , ans = 0 , maxi = 0;\\n        while(i<m){\\n            while(j < n && wor[i] >= diff[j]){\\n                maxi = max(maxi , map[diff[j]]) ; j++;\\n            }\\n            ans += maxi;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3812917,
                "title": "c-simple-solution-sorting-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        \\n        int n = profit.size(), ans = 0;\\n        vector<pair<int, int>> v;\\n\\n        for(int i = 0; i < n; i++)\\n            v.push_back({difficulty[i], profit[i]});\\n\\n        sort(v.begin(), v.end());\\n        for(int i = 1; i < n; i++)\\n            v[i].second = max(v[i].second, v[i - 1].second);\\n\\n        for(auto &i : worker)\\n            ans += helper(i, v);\\n\\n        return ans;\\n    }\\n\\n    int helper(int x, vector<pair<int, int>> &v)\\n    {\\n        int i = 0, j = v.size() - 1;\\n        int ans = -1;\\n        while(i <= j)\\n        {\\n            int mid = i + (j - i) / 2;\\n\\n            if(v[mid].first <= x)\\n                ans = mid, i = mid + 1;\\n            else\\n                j = mid - 1;\\n        }\\n\\n        return ans == -1 ? 0 : v[ans].second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        \\n        int n = profit.size(), ans = 0;\\n        vector<pair<int, int>> v;\\n\\n        for(int i = 0; i < n; i++)\\n            v.push_back({difficulty[i], profit[i]});\\n\\n        sort(v.begin(), v.end());\\n        for(int i = 1; i < n; i++)\\n            v[i].second = max(v[i].second, v[i - 1].second);\\n\\n        for(auto &i : worker)\\n            ans += helper(i, v);\\n\\n        return ans;\\n    }\\n\\n    int helper(int x, vector<pair<int, int>> &v)\\n    {\\n        int i = 0, j = v.size() - 1;\\n        int ans = -1;\\n        while(i <= j)\\n        {\\n            int mid = i + (j - i) / 2;\\n\\n            if(v[mid].first <= x)\\n                ans = mid, i = mid + 1;\\n            else\\n                j = mid - 1;\\n        }\\n\\n        return ans == -1 ? 0 : v[ans].second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3811314,
                "title": "easy-c-linear-tc",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int, int>> dif;\\n        for(int i=0;i<difficulty.size();i++){\\n            dif.push_back({profit[i], difficulty[i]});\\n        }\\n        sort(dif.rbegin(), dif.rend());\\n        sort(worker.rbegin(), worker.rend());\\n        int i=0, j=0,ans=0;\\n        while(i<worker.size() && j<dif.size()){\\n            if(worker[i]>=dif[j].second){\\n                ans+=dif[j].first;\\n                i++;\\n            }\\n            else j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int, int>> dif;\\n        for(int i=0;i<difficulty.size();i++){\\n            dif.push_back({profit[i], difficulty[i]});\\n        }\\n        sort(dif.rbegin(), dif.rend());\\n        sort(worker.rbegin(), worker.rend());\\n        int i=0, j=0,ans=0;\\n        while(i<worker.size() && j<dif.size()){\\n            if(worker[i]>=dif[j].second){\\n                ans+=dif[j].first;\\n                i++;\\n            }\\n            else j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3797057,
                "title": "using-greedy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    class Pair{\\n        int def;\\n        int pro;\\n        Pair(int def, int pro)\\n        {\\n           this.def = def;\\n           this.pro = pro;\\n        }\\n    }\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n          int len = difficulty.length;\\n          Pair arr[] = new Pair[len];\\n          for(int i = 0;i<len;i++)\\n          {\\n              arr[i] = new Pair(difficulty[i], profit[i]);\\n          }\\n\\n          Arrays.sort(arr, (a, b)-> a.def-b.def);\\n          Arrays.sort(worker);\\n          int curMax = 0;\\n          int totalMax = 0;\\n          int index = 0;\\n          for(int i = 0;i<worker.length;i++)\\n          {\\n              int wk = worker[i];\\n              while(index < len && arr[index].def <= wk)\\n              {\\n                  curMax = Math.max(curMax, arr[index].pro);\\n                  index++;\\n              }\\n              totalMax += curMax;\\n          }\\n\\n          return totalMax;\\n\\n    } \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    class Pair{\\n        int def;\\n        int pro;\\n        Pair(int def, int pro)\\n        {\\n           this.def = def;\\n           this.pro = pro;\\n        }\\n    }\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n          int len = difficulty.length;\\n          Pair arr[] = new Pair[len];\\n          for(int i = 0;i<len;i++)\\n          {\\n              arr[i] = new Pair(difficulty[i], profit[i]);\\n          }\\n\\n          Arrays.sort(arr, (a, b)-> a.def-b.def);\\n          Arrays.sort(worker);\\n          int curMax = 0;\\n          int totalMax = 0;\\n          int index = 0;\\n          for(int i = 0;i<worker.length;i++)\\n          {\\n              int wk = worker[i];\\n              while(index < len && arr[index].def <= wk)\\n              {\\n                  curMax = Math.max(curMax, arr[index].pro);\\n                  index++;\\n              }\\n              totalMax += curMax;\\n          }\\n\\n          return totalMax;\\n\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3787328,
                "title": "make-pair-of-diff-profit-then-sort-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int,int>> diffPro;\\n        for(int i=0;i<difficulty.size();i++) diffPro.push_back({difficulty[i],profit[i]});\\n        sort(diffPro.begin(),diffPro.end());\\n        vector<int> MaxArr; int maxi = 0;\\n        for(int i=0;i<diffPro.size();i++){\\n            maxi = max(maxi,diffPro[i].second);\\n            MaxArr.push_back(maxi);\\n        }\\n        int ans = 0;\\n        for(int i=0;i<worker.size();i++){\\n            auto it = upper_bound(diffPro.begin(),diffPro.end(),make_pair(worker[i], numeric_limits<int>::max()));\\n            if(it==diffPro.end()){\\n                ans += MaxArr[MaxArr.size()-1];\\n                continue;\\n            }\\n            int idx = it - diffPro.begin();\\n            idx--;\\n            if(idx<0) continue;\\n            if(idx==0 && worker[i]<diffPro[idx].first){\\n                continue;\\n            }\\n            ans += MaxArr[idx];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int,int>> diffPro;\\n        for(int i=0;i<difficulty.size();i++) diffPro.push_back({difficulty[i],profit[i]});\\n        sort(diffPro.begin(),diffPro.end());\\n        vector<int> MaxArr; int maxi = 0;\\n        for(int i=0;i<diffPro.size();i++){\\n            maxi = max(maxi,diffPro[i].second);\\n            MaxArr.push_back(maxi);\\n        }\\n        int ans = 0;\\n        for(int i=0;i<worker.size();i++){\\n            auto it = upper_bound(diffPro.begin(),diffPro.end(),make_pair(worker[i], numeric_limits<int>::max()));\\n            if(it==diffPro.end()){\\n                ans += MaxArr[MaxArr.size()-1];\\n                continue;\\n            }\\n            int idx = it - diffPro.begin();\\n            idx--;\\n            if(idx<0) continue;\\n            if(idx==0 && worker[i]<diffPro[idx].first){\\n                continue;\\n            }\\n            ans += MaxArr[idx];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785630,
                "title": "easy-sol-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int,int>>items;int n=profit.size();\\n        for(int i=0;i<n;i++)items.push_back({difficulty[i],profit[i]});\\n        sort(items.begin(),items.end());\\n        for(int i=0;i<n;i++)difficulty[i]=items[i].first;\\n        profit[0]=items[0].second;\\n        for(int i=1;i<n;i++)profit[i]=max(profit[i-1],items[i].second);\\n        int ans=0;\\n        for(int i=0;i<worker.size();i++)\\n        {\\n            int ind=upper_bound(difficulty.begin(),difficulty.end(),worker[i])-difficulty.begin();\\n            if(ind==0)ans+=0;\\n            else\\n            {\\n                ans+=profit[ind-1];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\\n        vector<pair<int,int>>items;int n=profit.size();\\n        for(int i=0;i<n;i++)items.push_back({difficulty[i],profit[i]});\\n        sort(items.begin(),items.end());\\n        for(int i=0;i<n;i++)difficulty[i]=items[i].first;\\n        profit[0]=items[0].second;\\n        for(int i=1;i<n;i++)profit[i]=max(profit[i-1],items[i].second);\\n        int ans=0;\\n        for(int i=0;i<worker.size();i++)\\n        {\\n            int ind=upper_bound(difficulty.begin(),difficulty.end(),worker[i])-difficulty.begin();\\n            if(ind==0)ans+=0;\\n            else\\n            {\\n                ans+=profit[ind-1];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785537,
                "title": "simple-java-self-explaining-two-pointers-without-using-map",
                "content": "\\n\\n# Approach\\n1. Sort jobs with reverse profit \\n2. Sort worker with ability\\n3. Maximze profit by assign all capable worker to high profit job, iterating from high -> low\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n\\n        int[][] jobs = new int[profit.length][2]; \\n        for (int i = 0; i < profit.length; i++) {\\n            jobs[i][0] = difficulty[i];\\n            jobs[i][1] = profit[i]; \\n        }\\n        Arrays.sort(jobs, (a, b) -> b[1] - a[1]); \\n        Arrays.sort(worker); \\n\\n        int a = 0; \\n        int b = worker.length - 1; \\n        int max = 0; \\n\\n        for (int i = 0; i < jobs.length; i++) {\\n            int diff = jobs[i][0]; \\n            \\n            while ( b >= 0 && worker[b] >= diff) {\\n                max += jobs[i][1]; \\n                b--; \\n            }\\n        }\\n\\n        return max; \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\\n\\n        int[][] jobs = new int[profit.length][2]; \\n        for (int i = 0; i < profit.length; i++) {\\n            jobs[i][0] = difficulty[i];\\n            jobs[i][1] = profit[i]; \\n        }\\n        Arrays.sort(jobs, (a, b) -> b[1] - a[1]); \\n        Arrays.sort(worker); \\n\\n        int a = 0; \\n        int b = worker.length - 1; \\n        int max = 0; \\n\\n        for (int i = 0; i < jobs.length; i++) {\\n            int diff = jobs[i][0]; \\n            \\n            while ( b >= 0 && worker[b] >= diff) {\\n                max += jobs[i][1]; \\n                b--; \\n            }\\n        }\\n\\n        return max; \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3780633,
                "title": "a-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaxProfitAssignment(int[] d, int[] p, int[] w) {\\n        var dict = new Dictionary<int, int>();\\n        for (int i = 0; i < d.Length; i++)\\n        {\\n            if (dict.ContainsKey(d[i]))\\n                dict[d[i]] = Math.Max(p[i], dict[d[i]]);\\n            else dict[d[i]] = p[i];\\n        }\\n        dict = dict.OrderByDescending(x => x.Value).ToDictionary(x => x.Key, x => x.Value);\\n        int res = 0;\\n        foreach(var worker in w)\\n        {\\n            foreach(var item in dict)\\n            {\\n                if (worker >= item.Key) \\n                {\\n                    res += item.Value; break;\\n                }\\n            }\\n        } \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxProfitAssignment(int[] d, int[] p, int[] w) {\\n        var dict = new Dictionary<int, int>();\\n        for (int i = 0; i < d.Length; i++)\\n        {\\n            if (dict.ContainsKey(d[i]))\\n                dict[d[i]] = Math.Max(p[i], dict[d[i]]);\\n            else dict[d[i]] = p[i];\\n        }\\n        dict = dict.OrderByDescending(x => x.Value).ToDictionary(x => x.Key, x => x.Value);\\n        int res = 0;\\n        foreach(var worker in w)\\n        {\\n            foreach(var item in dict)\\n            {\\n                if (worker >= item.Key) \\n                {\\n                    res += item.Value; break;\\n                }\\n            }\\n        } \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1717060,
                "content": [
                    {
                        "username": "ttk999",
                        "content": "Broken test imo\\n\\nInput\\ndifficulty =\\n[2,17,19,20,24,29,33,43,50,51,57,67,70,72,73,75,80,82,87,90]\\nprofit =\\n[6,7,10,17,18,29,30,31,34,39,40,42,48,54,57,78,78,78,83,88]\\nworker =\\n[12,9,11,41,11,87,48,6,48,93,76,73,7,50,55,97,47,33,46,10]\\n41 / 57 testcases passed\\nOutput\\n672\\nExpected\\n693\\n"
                    },
                    {
                        "username": "Omar_Nabil",
                        "content": "in profit array we have 3 elements with the same profit you have to handle it"
                    },
                    {
                        "username": "c4tdog",
                        "content": "harder work doesn't mean it is more profitable, meaning junior could earn more than senior :D"
                    },
                    {
                        "username": "layyy",
                        "content": "a testcase to try (profit does not increase with difficulty)\\ndifficulty - [68,35,52,47,86]\\nprofit - [67,17,1,81,3]\\nworker - [92,10,85,84,82]"
                    },
                    {
                        "username": "rkrux",
                        "content": "Very good question!"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "passing large DS by value as the argument can cause TLE, \\nIn my case, I passed the vector of pairs by the value that caused TLE at the last TC, then I tried to pass it by reference and got accepted. "
                    },
                    {
                        "username": "sayanpatel",
                        "content": "Something wrong with this testcase? I am getting my answer as 1324, while the expected is 1392.\\n\\ndifficulty = [66,1,28,73,53,35,45,60,100,44,59,94,27,88,7,18,83,18,72,63]\\n\\nprofit = [66,20,84,81,56,40,37,82,53,45,43,96,67,27,12,54,98,19,47,77]\\n\\nworker = [61,33,68,38,63,45,1,10,53,23,66,70,14,51,94,18,28,78,100,16]"
                    },
                    {
                        "username": "deskowl",
                        "content": "Me too. I'm not sure\nEDIT:\nI think perhaps you aren't accounting for this situation:\nThere are 2 difficulty 18 jobs in difficulty in this example (18,19) and (18,54). Perhaps in your code you have something like:\n        for i in range(len(difficulty)):\n            profit_and_difficulty[difficulty[i]] = profit[i]\n\nHowever, if the minimum profit of the 2 pairs occurs AFTER the maximum, then the minimum will override the max in your array (I assume that's what you're doing since we got exactly the same error on the same testcase).\n\nIf you instead change that block of code to something like:\n\tfor i in range(len(difficulty)):\n\t\tprofit_and_difficulty[difficulty[i]] = max(profit[i], profit_and_difficulty[difficulty[i]])\n\nI hope this is what you had, because I got the same error on the same testcase by the same amount."
                    },
                    {
                        "username": "shivani3",
                        "content": "Not sure What I missed, one test case failing out of 57\n \n`var maxProfitAssignment = function(difficulty, profit, worker) {\n\n   \n    let maps = new Map();\n    for(let i=0;i<difficulty.length;i++){\n        maps.set(difficulty[i],profit[i]);\n    }\n    let sortedArray = Array.from(maps.entries()).sort((a,b)=> {return a[0] - b[0]});\n    worker = worker.sort((a,b)=> a-b);\n    let maxprofitForWorker = 0;\n    let i=0;\n\n    return worker.reduce((total,skillLevel)=>{\n        while(i<sortedArray.length && skillLevel >= sortedArray[i][0]){\n            maxprofitForWorker = Math.max(maxprofitForWorker, sortedArray[i++][1]);\n        }\n        return total + maxprofitForWorker\n    }, 0)\n};`"
                    },
                    {
                        "username": "killerraj369",
                        "content": "in the solution why are we using a prefix array and why can not we directly do sum = max(sum, jobs[mid].second) ? \\n\\n int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) \\n    {\\n        int ans=0;\\n        vector<pair<int,int>> jobs;\\n        \\n        int n= profit.size();\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            jobs.push_back({difficulty[i],profit[i]});\\n        }\\n\\n        sort(jobs.begin(),jobs.end());\\n\\n        int mx=INT_MIN;\\n        vector<int> pre;\\n        for(auto i : jobs) pre.push_back(mx = max(i.second, mx));\\n\\n        for(auto i:worker)\\n        {\\n            int sum=0;\\n\\n            // Use Binay search to find the maximum profit from the sorted jobs vector\\n            int low=0;\\n            int high=n-1;\\n\\n            while(low<=high)\\n            {\\n                int mid = low +(high-low)/2;\\n\\n                if(jobs[mid].first<=i)\\n                {\\n                    sum= max(pre[mid],sum);\\n                    low=mid+1;\\n                }\\n                else\\n                {\\n                    // try to find a job with lower difficulty\\n                    high=mid-1;\\n                }\\n            }\\n\\n            cout<<sum<<\" \";\\n            ans+=sum; \\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Aparajita-Suman",
                        "content": "How to optimize this code? please suggest me!\n\n `\n\nclass Solution {\npublic:\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\n        int workhard = *max_element(worker.begin(), worker.end());\n        int mindiff = *min_element(difficulty.begin(), difficulty.end());\n\n        if (workhard < mindiff) return 0;\n        \n        vector<pair<int, int>> dp;\n\n        for (int i=0; i<profit.size(); i++) {\n            dp.emplace_back(difficulty[i], profit[i]);\n        }\n\n        sort(dp.begin(), dp.end());\n        int ans=0, maxi=0;\n        for (int i=0; i<worker.size(); i++) {\n            maxi = 0;\n            for (int j=0; j<profit.size(); j++) {\n                if (dp[j].first > worker[i]) break;\n                maxi = max(maxi, dp[j].second);\n            }\n            ans += maxi;\n        }\n\n        return ans;\n    }\n};\n`"
                    },
                    {
                        "username": "srk696772",
                        "content": "Try To use binary search inside workers loop bro as you are sorting difficulties , binary search will help you to reduce the time complexity."
                    }
                ]
            },
            {
                "id": 1947375,
                "content": [
                    {
                        "username": "ttk999",
                        "content": "Broken test imo\\n\\nInput\\ndifficulty =\\n[2,17,19,20,24,29,33,43,50,51,57,67,70,72,73,75,80,82,87,90]\\nprofit =\\n[6,7,10,17,18,29,30,31,34,39,40,42,48,54,57,78,78,78,83,88]\\nworker =\\n[12,9,11,41,11,87,48,6,48,93,76,73,7,50,55,97,47,33,46,10]\\n41 / 57 testcases passed\\nOutput\\n672\\nExpected\\n693\\n"
                    },
                    {
                        "username": "Omar_Nabil",
                        "content": "in profit array we have 3 elements with the same profit you have to handle it"
                    },
                    {
                        "username": "c4tdog",
                        "content": "harder work doesn't mean it is more profitable, meaning junior could earn more than senior :D"
                    },
                    {
                        "username": "layyy",
                        "content": "a testcase to try (profit does not increase with difficulty)\\ndifficulty - [68,35,52,47,86]\\nprofit - [67,17,1,81,3]\\nworker - [92,10,85,84,82]"
                    },
                    {
                        "username": "rkrux",
                        "content": "Very good question!"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "passing large DS by value as the argument can cause TLE, \\nIn my case, I passed the vector of pairs by the value that caused TLE at the last TC, then I tried to pass it by reference and got accepted. "
                    },
                    {
                        "username": "sayanpatel",
                        "content": "Something wrong with this testcase? I am getting my answer as 1324, while the expected is 1392.\\n\\ndifficulty = [66,1,28,73,53,35,45,60,100,44,59,94,27,88,7,18,83,18,72,63]\\n\\nprofit = [66,20,84,81,56,40,37,82,53,45,43,96,67,27,12,54,98,19,47,77]\\n\\nworker = [61,33,68,38,63,45,1,10,53,23,66,70,14,51,94,18,28,78,100,16]"
                    },
                    {
                        "username": "deskowl",
                        "content": "Me too. I'm not sure\nEDIT:\nI think perhaps you aren't accounting for this situation:\nThere are 2 difficulty 18 jobs in difficulty in this example (18,19) and (18,54). Perhaps in your code you have something like:\n        for i in range(len(difficulty)):\n            profit_and_difficulty[difficulty[i]] = profit[i]\n\nHowever, if the minimum profit of the 2 pairs occurs AFTER the maximum, then the minimum will override the max in your array (I assume that's what you're doing since we got exactly the same error on the same testcase).\n\nIf you instead change that block of code to something like:\n\tfor i in range(len(difficulty)):\n\t\tprofit_and_difficulty[difficulty[i]] = max(profit[i], profit_and_difficulty[difficulty[i]])\n\nI hope this is what you had, because I got the same error on the same testcase by the same amount."
                    },
                    {
                        "username": "shivani3",
                        "content": "Not sure What I missed, one test case failing out of 57\n \n`var maxProfitAssignment = function(difficulty, profit, worker) {\n\n   \n    let maps = new Map();\n    for(let i=0;i<difficulty.length;i++){\n        maps.set(difficulty[i],profit[i]);\n    }\n    let sortedArray = Array.from(maps.entries()).sort((a,b)=> {return a[0] - b[0]});\n    worker = worker.sort((a,b)=> a-b);\n    let maxprofitForWorker = 0;\n    let i=0;\n\n    return worker.reduce((total,skillLevel)=>{\n        while(i<sortedArray.length && skillLevel >= sortedArray[i][0]){\n            maxprofitForWorker = Math.max(maxprofitForWorker, sortedArray[i++][1]);\n        }\n        return total + maxprofitForWorker\n    }, 0)\n};`"
                    },
                    {
                        "username": "killerraj369",
                        "content": "in the solution why are we using a prefix array and why can not we directly do sum = max(sum, jobs[mid].second) ? \\n\\n int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) \\n    {\\n        int ans=0;\\n        vector<pair<int,int>> jobs;\\n        \\n        int n= profit.size();\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            jobs.push_back({difficulty[i],profit[i]});\\n        }\\n\\n        sort(jobs.begin(),jobs.end());\\n\\n        int mx=INT_MIN;\\n        vector<int> pre;\\n        for(auto i : jobs) pre.push_back(mx = max(i.second, mx));\\n\\n        for(auto i:worker)\\n        {\\n            int sum=0;\\n\\n            // Use Binay search to find the maximum profit from the sorted jobs vector\\n            int low=0;\\n            int high=n-1;\\n\\n            while(low<=high)\\n            {\\n                int mid = low +(high-low)/2;\\n\\n                if(jobs[mid].first<=i)\\n                {\\n                    sum= max(pre[mid],sum);\\n                    low=mid+1;\\n                }\\n                else\\n                {\\n                    // try to find a job with lower difficulty\\n                    high=mid-1;\\n                }\\n            }\\n\\n            cout<<sum<<\" \";\\n            ans+=sum; \\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Aparajita-Suman",
                        "content": "How to optimize this code? please suggest me!\n\n `\n\nclass Solution {\npublic:\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\n        int workhard = *max_element(worker.begin(), worker.end());\n        int mindiff = *min_element(difficulty.begin(), difficulty.end());\n\n        if (workhard < mindiff) return 0;\n        \n        vector<pair<int, int>> dp;\n\n        for (int i=0; i<profit.size(); i++) {\n            dp.emplace_back(difficulty[i], profit[i]);\n        }\n\n        sort(dp.begin(), dp.end());\n        int ans=0, maxi=0;\n        for (int i=0; i<worker.size(); i++) {\n            maxi = 0;\n            for (int j=0; j<profit.size(); j++) {\n                if (dp[j].first > worker[i]) break;\n                maxi = max(maxi, dp[j].second);\n            }\n            ans += maxi;\n        }\n\n        return ans;\n    }\n};\n`"
                    },
                    {
                        "username": "srk696772",
                        "content": "Try To use binary search inside workers loop bro as you are sorting difficulties , binary search will help you to reduce the time complexity."
                    }
                ]
            },
            {
                "id": 2018415,
                "content": [
                    {
                        "username": "ttk999",
                        "content": "Broken test imo\\n\\nInput\\ndifficulty =\\n[2,17,19,20,24,29,33,43,50,51,57,67,70,72,73,75,80,82,87,90]\\nprofit =\\n[6,7,10,17,18,29,30,31,34,39,40,42,48,54,57,78,78,78,83,88]\\nworker =\\n[12,9,11,41,11,87,48,6,48,93,76,73,7,50,55,97,47,33,46,10]\\n41 / 57 testcases passed\\nOutput\\n672\\nExpected\\n693\\n"
                    },
                    {
                        "username": "Omar_Nabil",
                        "content": "in profit array we have 3 elements with the same profit you have to handle it"
                    },
                    {
                        "username": "c4tdog",
                        "content": "harder work doesn't mean it is more profitable, meaning junior could earn more than senior :D"
                    },
                    {
                        "username": "layyy",
                        "content": "a testcase to try (profit does not increase with difficulty)\\ndifficulty - [68,35,52,47,86]\\nprofit - [67,17,1,81,3]\\nworker - [92,10,85,84,82]"
                    },
                    {
                        "username": "rkrux",
                        "content": "Very good question!"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "passing large DS by value as the argument can cause TLE, \\nIn my case, I passed the vector of pairs by the value that caused TLE at the last TC, then I tried to pass it by reference and got accepted. "
                    },
                    {
                        "username": "sayanpatel",
                        "content": "Something wrong with this testcase? I am getting my answer as 1324, while the expected is 1392.\\n\\ndifficulty = [66,1,28,73,53,35,45,60,100,44,59,94,27,88,7,18,83,18,72,63]\\n\\nprofit = [66,20,84,81,56,40,37,82,53,45,43,96,67,27,12,54,98,19,47,77]\\n\\nworker = [61,33,68,38,63,45,1,10,53,23,66,70,14,51,94,18,28,78,100,16]"
                    },
                    {
                        "username": "deskowl",
                        "content": "Me too. I'm not sure\nEDIT:\nI think perhaps you aren't accounting for this situation:\nThere are 2 difficulty 18 jobs in difficulty in this example (18,19) and (18,54). Perhaps in your code you have something like:\n        for i in range(len(difficulty)):\n            profit_and_difficulty[difficulty[i]] = profit[i]\n\nHowever, if the minimum profit of the 2 pairs occurs AFTER the maximum, then the minimum will override the max in your array (I assume that's what you're doing since we got exactly the same error on the same testcase).\n\nIf you instead change that block of code to something like:\n\tfor i in range(len(difficulty)):\n\t\tprofit_and_difficulty[difficulty[i]] = max(profit[i], profit_and_difficulty[difficulty[i]])\n\nI hope this is what you had, because I got the same error on the same testcase by the same amount."
                    },
                    {
                        "username": "shivani3",
                        "content": "Not sure What I missed, one test case failing out of 57\n \n`var maxProfitAssignment = function(difficulty, profit, worker) {\n\n   \n    let maps = new Map();\n    for(let i=0;i<difficulty.length;i++){\n        maps.set(difficulty[i],profit[i]);\n    }\n    let sortedArray = Array.from(maps.entries()).sort((a,b)=> {return a[0] - b[0]});\n    worker = worker.sort((a,b)=> a-b);\n    let maxprofitForWorker = 0;\n    let i=0;\n\n    return worker.reduce((total,skillLevel)=>{\n        while(i<sortedArray.length && skillLevel >= sortedArray[i][0]){\n            maxprofitForWorker = Math.max(maxprofitForWorker, sortedArray[i++][1]);\n        }\n        return total + maxprofitForWorker\n    }, 0)\n};`"
                    },
                    {
                        "username": "killerraj369",
                        "content": "in the solution why are we using a prefix array and why can not we directly do sum = max(sum, jobs[mid].second) ? \\n\\n int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) \\n    {\\n        int ans=0;\\n        vector<pair<int,int>> jobs;\\n        \\n        int n= profit.size();\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            jobs.push_back({difficulty[i],profit[i]});\\n        }\\n\\n        sort(jobs.begin(),jobs.end());\\n\\n        int mx=INT_MIN;\\n        vector<int> pre;\\n        for(auto i : jobs) pre.push_back(mx = max(i.second, mx));\\n\\n        for(auto i:worker)\\n        {\\n            int sum=0;\\n\\n            // Use Binay search to find the maximum profit from the sorted jobs vector\\n            int low=0;\\n            int high=n-1;\\n\\n            while(low<=high)\\n            {\\n                int mid = low +(high-low)/2;\\n\\n                if(jobs[mid].first<=i)\\n                {\\n                    sum= max(pre[mid],sum);\\n                    low=mid+1;\\n                }\\n                else\\n                {\\n                    // try to find a job with lower difficulty\\n                    high=mid-1;\\n                }\\n            }\\n\\n            cout<<sum<<\" \";\\n            ans+=sum; \\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Aparajita-Suman",
                        "content": "How to optimize this code? please suggest me!\n\n `\n\nclass Solution {\npublic:\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\n        int workhard = *max_element(worker.begin(), worker.end());\n        int mindiff = *min_element(difficulty.begin(), difficulty.end());\n\n        if (workhard < mindiff) return 0;\n        \n        vector<pair<int, int>> dp;\n\n        for (int i=0; i<profit.size(); i++) {\n            dp.emplace_back(difficulty[i], profit[i]);\n        }\n\n        sort(dp.begin(), dp.end());\n        int ans=0, maxi=0;\n        for (int i=0; i<worker.size(); i++) {\n            maxi = 0;\n            for (int j=0; j<profit.size(); j++) {\n                if (dp[j].first > worker[i]) break;\n                maxi = max(maxi, dp[j].second);\n            }\n            ans += maxi;\n        }\n\n        return ans;\n    }\n};\n`"
                    },
                    {
                        "username": "srk696772",
                        "content": "Try To use binary search inside workers loop bro as you are sorting difficulties , binary search will help you to reduce the time complexity."
                    }
                ]
            },
            {
                "id": 1805295,
                "content": [
                    {
                        "username": "ttk999",
                        "content": "Broken test imo\\n\\nInput\\ndifficulty =\\n[2,17,19,20,24,29,33,43,50,51,57,67,70,72,73,75,80,82,87,90]\\nprofit =\\n[6,7,10,17,18,29,30,31,34,39,40,42,48,54,57,78,78,78,83,88]\\nworker =\\n[12,9,11,41,11,87,48,6,48,93,76,73,7,50,55,97,47,33,46,10]\\n41 / 57 testcases passed\\nOutput\\n672\\nExpected\\n693\\n"
                    },
                    {
                        "username": "Omar_Nabil",
                        "content": "in profit array we have 3 elements with the same profit you have to handle it"
                    },
                    {
                        "username": "c4tdog",
                        "content": "harder work doesn't mean it is more profitable, meaning junior could earn more than senior :D"
                    },
                    {
                        "username": "layyy",
                        "content": "a testcase to try (profit does not increase with difficulty)\\ndifficulty - [68,35,52,47,86]\\nprofit - [67,17,1,81,3]\\nworker - [92,10,85,84,82]"
                    },
                    {
                        "username": "rkrux",
                        "content": "Very good question!"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "passing large DS by value as the argument can cause TLE, \\nIn my case, I passed the vector of pairs by the value that caused TLE at the last TC, then I tried to pass it by reference and got accepted. "
                    },
                    {
                        "username": "sayanpatel",
                        "content": "Something wrong with this testcase? I am getting my answer as 1324, while the expected is 1392.\\n\\ndifficulty = [66,1,28,73,53,35,45,60,100,44,59,94,27,88,7,18,83,18,72,63]\\n\\nprofit = [66,20,84,81,56,40,37,82,53,45,43,96,67,27,12,54,98,19,47,77]\\n\\nworker = [61,33,68,38,63,45,1,10,53,23,66,70,14,51,94,18,28,78,100,16]"
                    },
                    {
                        "username": "deskowl",
                        "content": "Me too. I'm not sure\nEDIT:\nI think perhaps you aren't accounting for this situation:\nThere are 2 difficulty 18 jobs in difficulty in this example (18,19) and (18,54). Perhaps in your code you have something like:\n        for i in range(len(difficulty)):\n            profit_and_difficulty[difficulty[i]] = profit[i]\n\nHowever, if the minimum profit of the 2 pairs occurs AFTER the maximum, then the minimum will override the max in your array (I assume that's what you're doing since we got exactly the same error on the same testcase).\n\nIf you instead change that block of code to something like:\n\tfor i in range(len(difficulty)):\n\t\tprofit_and_difficulty[difficulty[i]] = max(profit[i], profit_and_difficulty[difficulty[i]])\n\nI hope this is what you had, because I got the same error on the same testcase by the same amount."
                    },
                    {
                        "username": "shivani3",
                        "content": "Not sure What I missed, one test case failing out of 57\n \n`var maxProfitAssignment = function(difficulty, profit, worker) {\n\n   \n    let maps = new Map();\n    for(let i=0;i<difficulty.length;i++){\n        maps.set(difficulty[i],profit[i]);\n    }\n    let sortedArray = Array.from(maps.entries()).sort((a,b)=> {return a[0] - b[0]});\n    worker = worker.sort((a,b)=> a-b);\n    let maxprofitForWorker = 0;\n    let i=0;\n\n    return worker.reduce((total,skillLevel)=>{\n        while(i<sortedArray.length && skillLevel >= sortedArray[i][0]){\n            maxprofitForWorker = Math.max(maxprofitForWorker, sortedArray[i++][1]);\n        }\n        return total + maxprofitForWorker\n    }, 0)\n};`"
                    },
                    {
                        "username": "killerraj369",
                        "content": "in the solution why are we using a prefix array and why can not we directly do sum = max(sum, jobs[mid].second) ? \\n\\n int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) \\n    {\\n        int ans=0;\\n        vector<pair<int,int>> jobs;\\n        \\n        int n= profit.size();\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            jobs.push_back({difficulty[i],profit[i]});\\n        }\\n\\n        sort(jobs.begin(),jobs.end());\\n\\n        int mx=INT_MIN;\\n        vector<int> pre;\\n        for(auto i : jobs) pre.push_back(mx = max(i.second, mx));\\n\\n        for(auto i:worker)\\n        {\\n            int sum=0;\\n\\n            // Use Binay search to find the maximum profit from the sorted jobs vector\\n            int low=0;\\n            int high=n-1;\\n\\n            while(low<=high)\\n            {\\n                int mid = low +(high-low)/2;\\n\\n                if(jobs[mid].first<=i)\\n                {\\n                    sum= max(pre[mid],sum);\\n                    low=mid+1;\\n                }\\n                else\\n                {\\n                    // try to find a job with lower difficulty\\n                    high=mid-1;\\n                }\\n            }\\n\\n            cout<<sum<<\" \";\\n            ans+=sum; \\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Aparajita-Suman",
                        "content": "How to optimize this code? please suggest me!\n\n `\n\nclass Solution {\npublic:\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\n        int workhard = *max_element(worker.begin(), worker.end());\n        int mindiff = *min_element(difficulty.begin(), difficulty.end());\n\n        if (workhard < mindiff) return 0;\n        \n        vector<pair<int, int>> dp;\n\n        for (int i=0; i<profit.size(); i++) {\n            dp.emplace_back(difficulty[i], profit[i]);\n        }\n\n        sort(dp.begin(), dp.end());\n        int ans=0, maxi=0;\n        for (int i=0; i<worker.size(); i++) {\n            maxi = 0;\n            for (int j=0; j<profit.size(); j++) {\n                if (dp[j].first > worker[i]) break;\n                maxi = max(maxi, dp[j].second);\n            }\n            ans += maxi;\n        }\n\n        return ans;\n    }\n};\n`"
                    },
                    {
                        "username": "srk696772",
                        "content": "Try To use binary search inside workers loop bro as you are sorting difficulties , binary search will help you to reduce the time complexity."
                    }
                ]
            },
            {
                "id": 1786439,
                "content": [
                    {
                        "username": "ttk999",
                        "content": "Broken test imo\\n\\nInput\\ndifficulty =\\n[2,17,19,20,24,29,33,43,50,51,57,67,70,72,73,75,80,82,87,90]\\nprofit =\\n[6,7,10,17,18,29,30,31,34,39,40,42,48,54,57,78,78,78,83,88]\\nworker =\\n[12,9,11,41,11,87,48,6,48,93,76,73,7,50,55,97,47,33,46,10]\\n41 / 57 testcases passed\\nOutput\\n672\\nExpected\\n693\\n"
                    },
                    {
                        "username": "Omar_Nabil",
                        "content": "in profit array we have 3 elements with the same profit you have to handle it"
                    },
                    {
                        "username": "c4tdog",
                        "content": "harder work doesn't mean it is more profitable, meaning junior could earn more than senior :D"
                    },
                    {
                        "username": "layyy",
                        "content": "a testcase to try (profit does not increase with difficulty)\\ndifficulty - [68,35,52,47,86]\\nprofit - [67,17,1,81,3]\\nworker - [92,10,85,84,82]"
                    },
                    {
                        "username": "rkrux",
                        "content": "Very good question!"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "passing large DS by value as the argument can cause TLE, \\nIn my case, I passed the vector of pairs by the value that caused TLE at the last TC, then I tried to pass it by reference and got accepted. "
                    },
                    {
                        "username": "sayanpatel",
                        "content": "Something wrong with this testcase? I am getting my answer as 1324, while the expected is 1392.\\n\\ndifficulty = [66,1,28,73,53,35,45,60,100,44,59,94,27,88,7,18,83,18,72,63]\\n\\nprofit = [66,20,84,81,56,40,37,82,53,45,43,96,67,27,12,54,98,19,47,77]\\n\\nworker = [61,33,68,38,63,45,1,10,53,23,66,70,14,51,94,18,28,78,100,16]"
                    },
                    {
                        "username": "deskowl",
                        "content": "Me too. I'm not sure\nEDIT:\nI think perhaps you aren't accounting for this situation:\nThere are 2 difficulty 18 jobs in difficulty in this example (18,19) and (18,54). Perhaps in your code you have something like:\n        for i in range(len(difficulty)):\n            profit_and_difficulty[difficulty[i]] = profit[i]\n\nHowever, if the minimum profit of the 2 pairs occurs AFTER the maximum, then the minimum will override the max in your array (I assume that's what you're doing since we got exactly the same error on the same testcase).\n\nIf you instead change that block of code to something like:\n\tfor i in range(len(difficulty)):\n\t\tprofit_and_difficulty[difficulty[i]] = max(profit[i], profit_and_difficulty[difficulty[i]])\n\nI hope this is what you had, because I got the same error on the same testcase by the same amount."
                    },
                    {
                        "username": "shivani3",
                        "content": "Not sure What I missed, one test case failing out of 57\n \n`var maxProfitAssignment = function(difficulty, profit, worker) {\n\n   \n    let maps = new Map();\n    for(let i=0;i<difficulty.length;i++){\n        maps.set(difficulty[i],profit[i]);\n    }\n    let sortedArray = Array.from(maps.entries()).sort((a,b)=> {return a[0] - b[0]});\n    worker = worker.sort((a,b)=> a-b);\n    let maxprofitForWorker = 0;\n    let i=0;\n\n    return worker.reduce((total,skillLevel)=>{\n        while(i<sortedArray.length && skillLevel >= sortedArray[i][0]){\n            maxprofitForWorker = Math.max(maxprofitForWorker, sortedArray[i++][1]);\n        }\n        return total + maxprofitForWorker\n    }, 0)\n};`"
                    },
                    {
                        "username": "killerraj369",
                        "content": "in the solution why are we using a prefix array and why can not we directly do sum = max(sum, jobs[mid].second) ? \\n\\n int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) \\n    {\\n        int ans=0;\\n        vector<pair<int,int>> jobs;\\n        \\n        int n= profit.size();\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            jobs.push_back({difficulty[i],profit[i]});\\n        }\\n\\n        sort(jobs.begin(),jobs.end());\\n\\n        int mx=INT_MIN;\\n        vector<int> pre;\\n        for(auto i : jobs) pre.push_back(mx = max(i.second, mx));\\n\\n        for(auto i:worker)\\n        {\\n            int sum=0;\\n\\n            // Use Binay search to find the maximum profit from the sorted jobs vector\\n            int low=0;\\n            int high=n-1;\\n\\n            while(low<=high)\\n            {\\n                int mid = low +(high-low)/2;\\n\\n                if(jobs[mid].first<=i)\\n                {\\n                    sum= max(pre[mid],sum);\\n                    low=mid+1;\\n                }\\n                else\\n                {\\n                    // try to find a job with lower difficulty\\n                    high=mid-1;\\n                }\\n            }\\n\\n            cout<<sum<<\" \";\\n            ans+=sum; \\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Aparajita-Suman",
                        "content": "How to optimize this code? please suggest me!\n\n `\n\nclass Solution {\npublic:\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\n        int workhard = *max_element(worker.begin(), worker.end());\n        int mindiff = *min_element(difficulty.begin(), difficulty.end());\n\n        if (workhard < mindiff) return 0;\n        \n        vector<pair<int, int>> dp;\n\n        for (int i=0; i<profit.size(); i++) {\n            dp.emplace_back(difficulty[i], profit[i]);\n        }\n\n        sort(dp.begin(), dp.end());\n        int ans=0, maxi=0;\n        for (int i=0; i<worker.size(); i++) {\n            maxi = 0;\n            for (int j=0; j<profit.size(); j++) {\n                if (dp[j].first > worker[i]) break;\n                maxi = max(maxi, dp[j].second);\n            }\n            ans += maxi;\n        }\n\n        return ans;\n    }\n};\n`"
                    },
                    {
                        "username": "srk696772",
                        "content": "Try To use binary search inside workers loop bro as you are sorting difficulties , binary search will help you to reduce the time complexity."
                    }
                ]
            },
            {
                "id": 2071436,
                "content": [
                    {
                        "username": "ttk999",
                        "content": "Broken test imo\\n\\nInput\\ndifficulty =\\n[2,17,19,20,24,29,33,43,50,51,57,67,70,72,73,75,80,82,87,90]\\nprofit =\\n[6,7,10,17,18,29,30,31,34,39,40,42,48,54,57,78,78,78,83,88]\\nworker =\\n[12,9,11,41,11,87,48,6,48,93,76,73,7,50,55,97,47,33,46,10]\\n41 / 57 testcases passed\\nOutput\\n672\\nExpected\\n693\\n"
                    },
                    {
                        "username": "Omar_Nabil",
                        "content": "in profit array we have 3 elements with the same profit you have to handle it"
                    },
                    {
                        "username": "c4tdog",
                        "content": "harder work doesn't mean it is more profitable, meaning junior could earn more than senior :D"
                    },
                    {
                        "username": "layyy",
                        "content": "a testcase to try (profit does not increase with difficulty)\\ndifficulty - [68,35,52,47,86]\\nprofit - [67,17,1,81,3]\\nworker - [92,10,85,84,82]"
                    },
                    {
                        "username": "rkrux",
                        "content": "Very good question!"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "passing large DS by value as the argument can cause TLE, \\nIn my case, I passed the vector of pairs by the value that caused TLE at the last TC, then I tried to pass it by reference and got accepted. "
                    },
                    {
                        "username": "sayanpatel",
                        "content": "Something wrong with this testcase? I am getting my answer as 1324, while the expected is 1392.\\n\\ndifficulty = [66,1,28,73,53,35,45,60,100,44,59,94,27,88,7,18,83,18,72,63]\\n\\nprofit = [66,20,84,81,56,40,37,82,53,45,43,96,67,27,12,54,98,19,47,77]\\n\\nworker = [61,33,68,38,63,45,1,10,53,23,66,70,14,51,94,18,28,78,100,16]"
                    },
                    {
                        "username": "deskowl",
                        "content": "Me too. I'm not sure\nEDIT:\nI think perhaps you aren't accounting for this situation:\nThere are 2 difficulty 18 jobs in difficulty in this example (18,19) and (18,54). Perhaps in your code you have something like:\n        for i in range(len(difficulty)):\n            profit_and_difficulty[difficulty[i]] = profit[i]\n\nHowever, if the minimum profit of the 2 pairs occurs AFTER the maximum, then the minimum will override the max in your array (I assume that's what you're doing since we got exactly the same error on the same testcase).\n\nIf you instead change that block of code to something like:\n\tfor i in range(len(difficulty)):\n\t\tprofit_and_difficulty[difficulty[i]] = max(profit[i], profit_and_difficulty[difficulty[i]])\n\nI hope this is what you had, because I got the same error on the same testcase by the same amount."
                    },
                    {
                        "username": "shivani3",
                        "content": "Not sure What I missed, one test case failing out of 57\n \n`var maxProfitAssignment = function(difficulty, profit, worker) {\n\n   \n    let maps = new Map();\n    for(let i=0;i<difficulty.length;i++){\n        maps.set(difficulty[i],profit[i]);\n    }\n    let sortedArray = Array.from(maps.entries()).sort((a,b)=> {return a[0] - b[0]});\n    worker = worker.sort((a,b)=> a-b);\n    let maxprofitForWorker = 0;\n    let i=0;\n\n    return worker.reduce((total,skillLevel)=>{\n        while(i<sortedArray.length && skillLevel >= sortedArray[i][0]){\n            maxprofitForWorker = Math.max(maxprofitForWorker, sortedArray[i++][1]);\n        }\n        return total + maxprofitForWorker\n    }, 0)\n};`"
                    },
                    {
                        "username": "killerraj369",
                        "content": "in the solution why are we using a prefix array and why can not we directly do sum = max(sum, jobs[mid].second) ? \\n\\n int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) \\n    {\\n        int ans=0;\\n        vector<pair<int,int>> jobs;\\n        \\n        int n= profit.size();\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            jobs.push_back({difficulty[i],profit[i]});\\n        }\\n\\n        sort(jobs.begin(),jobs.end());\\n\\n        int mx=INT_MIN;\\n        vector<int> pre;\\n        for(auto i : jobs) pre.push_back(mx = max(i.second, mx));\\n\\n        for(auto i:worker)\\n        {\\n            int sum=0;\\n\\n            // Use Binay search to find the maximum profit from the sorted jobs vector\\n            int low=0;\\n            int high=n-1;\\n\\n            while(low<=high)\\n            {\\n                int mid = low +(high-low)/2;\\n\\n                if(jobs[mid].first<=i)\\n                {\\n                    sum= max(pre[mid],sum);\\n                    low=mid+1;\\n                }\\n                else\\n                {\\n                    // try to find a job with lower difficulty\\n                    high=mid-1;\\n                }\\n            }\\n\\n            cout<<sum<<\" \";\\n            ans+=sum; \\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Aparajita-Suman",
                        "content": "How to optimize this code? please suggest me!\n\n `\n\nclass Solution {\npublic:\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\n        int workhard = *max_element(worker.begin(), worker.end());\n        int mindiff = *min_element(difficulty.begin(), difficulty.end());\n\n        if (workhard < mindiff) return 0;\n        \n        vector<pair<int, int>> dp;\n\n        for (int i=0; i<profit.size(); i++) {\n            dp.emplace_back(difficulty[i], profit[i]);\n        }\n\n        sort(dp.begin(), dp.end());\n        int ans=0, maxi=0;\n        for (int i=0; i<worker.size(); i++) {\n            maxi = 0;\n            for (int j=0; j<profit.size(); j++) {\n                if (dp[j].first > worker[i]) break;\n                maxi = max(maxi, dp[j].second);\n            }\n            ans += maxi;\n        }\n\n        return ans;\n    }\n};\n`"
                    },
                    {
                        "username": "srk696772",
                        "content": "Try To use binary search inside workers loop bro as you are sorting difficulties , binary search will help you to reduce the time complexity."
                    }
                ]
            },
            {
                "id": 2054711,
                "content": [
                    {
                        "username": "ttk999",
                        "content": "Broken test imo\\n\\nInput\\ndifficulty =\\n[2,17,19,20,24,29,33,43,50,51,57,67,70,72,73,75,80,82,87,90]\\nprofit =\\n[6,7,10,17,18,29,30,31,34,39,40,42,48,54,57,78,78,78,83,88]\\nworker =\\n[12,9,11,41,11,87,48,6,48,93,76,73,7,50,55,97,47,33,46,10]\\n41 / 57 testcases passed\\nOutput\\n672\\nExpected\\n693\\n"
                    },
                    {
                        "username": "Omar_Nabil",
                        "content": "in profit array we have 3 elements with the same profit you have to handle it"
                    },
                    {
                        "username": "c4tdog",
                        "content": "harder work doesn't mean it is more profitable, meaning junior could earn more than senior :D"
                    },
                    {
                        "username": "layyy",
                        "content": "a testcase to try (profit does not increase with difficulty)\\ndifficulty - [68,35,52,47,86]\\nprofit - [67,17,1,81,3]\\nworker - [92,10,85,84,82]"
                    },
                    {
                        "username": "rkrux",
                        "content": "Very good question!"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "passing large DS by value as the argument can cause TLE, \\nIn my case, I passed the vector of pairs by the value that caused TLE at the last TC, then I tried to pass it by reference and got accepted. "
                    },
                    {
                        "username": "sayanpatel",
                        "content": "Something wrong with this testcase? I am getting my answer as 1324, while the expected is 1392.\\n\\ndifficulty = [66,1,28,73,53,35,45,60,100,44,59,94,27,88,7,18,83,18,72,63]\\n\\nprofit = [66,20,84,81,56,40,37,82,53,45,43,96,67,27,12,54,98,19,47,77]\\n\\nworker = [61,33,68,38,63,45,1,10,53,23,66,70,14,51,94,18,28,78,100,16]"
                    },
                    {
                        "username": "deskowl",
                        "content": "Me too. I'm not sure\nEDIT:\nI think perhaps you aren't accounting for this situation:\nThere are 2 difficulty 18 jobs in difficulty in this example (18,19) and (18,54). Perhaps in your code you have something like:\n        for i in range(len(difficulty)):\n            profit_and_difficulty[difficulty[i]] = profit[i]\n\nHowever, if the minimum profit of the 2 pairs occurs AFTER the maximum, then the minimum will override the max in your array (I assume that's what you're doing since we got exactly the same error on the same testcase).\n\nIf you instead change that block of code to something like:\n\tfor i in range(len(difficulty)):\n\t\tprofit_and_difficulty[difficulty[i]] = max(profit[i], profit_and_difficulty[difficulty[i]])\n\nI hope this is what you had, because I got the same error on the same testcase by the same amount."
                    },
                    {
                        "username": "shivani3",
                        "content": "Not sure What I missed, one test case failing out of 57\n \n`var maxProfitAssignment = function(difficulty, profit, worker) {\n\n   \n    let maps = new Map();\n    for(let i=0;i<difficulty.length;i++){\n        maps.set(difficulty[i],profit[i]);\n    }\n    let sortedArray = Array.from(maps.entries()).sort((a,b)=> {return a[0] - b[0]});\n    worker = worker.sort((a,b)=> a-b);\n    let maxprofitForWorker = 0;\n    let i=0;\n\n    return worker.reduce((total,skillLevel)=>{\n        while(i<sortedArray.length && skillLevel >= sortedArray[i][0]){\n            maxprofitForWorker = Math.max(maxprofitForWorker, sortedArray[i++][1]);\n        }\n        return total + maxprofitForWorker\n    }, 0)\n};`"
                    },
                    {
                        "username": "killerraj369",
                        "content": "in the solution why are we using a prefix array and why can not we directly do sum = max(sum, jobs[mid].second) ? \\n\\n int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) \\n    {\\n        int ans=0;\\n        vector<pair<int,int>> jobs;\\n        \\n        int n= profit.size();\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            jobs.push_back({difficulty[i],profit[i]});\\n        }\\n\\n        sort(jobs.begin(),jobs.end());\\n\\n        int mx=INT_MIN;\\n        vector<int> pre;\\n        for(auto i : jobs) pre.push_back(mx = max(i.second, mx));\\n\\n        for(auto i:worker)\\n        {\\n            int sum=0;\\n\\n            // Use Binay search to find the maximum profit from the sorted jobs vector\\n            int low=0;\\n            int high=n-1;\\n\\n            while(low<=high)\\n            {\\n                int mid = low +(high-low)/2;\\n\\n                if(jobs[mid].first<=i)\\n                {\\n                    sum= max(pre[mid],sum);\\n                    low=mid+1;\\n                }\\n                else\\n                {\\n                    // try to find a job with lower difficulty\\n                    high=mid-1;\\n                }\\n            }\\n\\n            cout<<sum<<\" \";\\n            ans+=sum; \\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Aparajita-Suman",
                        "content": "How to optimize this code? please suggest me!\n\n `\n\nclass Solution {\npublic:\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\n        int workhard = *max_element(worker.begin(), worker.end());\n        int mindiff = *min_element(difficulty.begin(), difficulty.end());\n\n        if (workhard < mindiff) return 0;\n        \n        vector<pair<int, int>> dp;\n\n        for (int i=0; i<profit.size(); i++) {\n            dp.emplace_back(difficulty[i], profit[i]);\n        }\n\n        sort(dp.begin(), dp.end());\n        int ans=0, maxi=0;\n        for (int i=0; i<worker.size(); i++) {\n            maxi = 0;\n            for (int j=0; j<profit.size(); j++) {\n                if (dp[j].first > worker[i]) break;\n                maxi = max(maxi, dp[j].second);\n            }\n            ans += maxi;\n        }\n\n        return ans;\n    }\n};\n`"
                    },
                    {
                        "username": "srk696772",
                        "content": "Try To use binary search inside workers loop bro as you are sorting difficulties , binary search will help you to reduce the time complexity."
                    }
                ]
            },
            {
                "id": 1851627,
                "content": [
                    {
                        "username": "ttk999",
                        "content": "Broken test imo\\n\\nInput\\ndifficulty =\\n[2,17,19,20,24,29,33,43,50,51,57,67,70,72,73,75,80,82,87,90]\\nprofit =\\n[6,7,10,17,18,29,30,31,34,39,40,42,48,54,57,78,78,78,83,88]\\nworker =\\n[12,9,11,41,11,87,48,6,48,93,76,73,7,50,55,97,47,33,46,10]\\n41 / 57 testcases passed\\nOutput\\n672\\nExpected\\n693\\n"
                    },
                    {
                        "username": "Omar_Nabil",
                        "content": "in profit array we have 3 elements with the same profit you have to handle it"
                    },
                    {
                        "username": "c4tdog",
                        "content": "harder work doesn't mean it is more profitable, meaning junior could earn more than senior :D"
                    },
                    {
                        "username": "layyy",
                        "content": "a testcase to try (profit does not increase with difficulty)\\ndifficulty - [68,35,52,47,86]\\nprofit - [67,17,1,81,3]\\nworker - [92,10,85,84,82]"
                    },
                    {
                        "username": "rkrux",
                        "content": "Very good question!"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "passing large DS by value as the argument can cause TLE, \\nIn my case, I passed the vector of pairs by the value that caused TLE at the last TC, then I tried to pass it by reference and got accepted. "
                    },
                    {
                        "username": "sayanpatel",
                        "content": "Something wrong with this testcase? I am getting my answer as 1324, while the expected is 1392.\\n\\ndifficulty = [66,1,28,73,53,35,45,60,100,44,59,94,27,88,7,18,83,18,72,63]\\n\\nprofit = [66,20,84,81,56,40,37,82,53,45,43,96,67,27,12,54,98,19,47,77]\\n\\nworker = [61,33,68,38,63,45,1,10,53,23,66,70,14,51,94,18,28,78,100,16]"
                    },
                    {
                        "username": "deskowl",
                        "content": "Me too. I'm not sure\nEDIT:\nI think perhaps you aren't accounting for this situation:\nThere are 2 difficulty 18 jobs in difficulty in this example (18,19) and (18,54). Perhaps in your code you have something like:\n        for i in range(len(difficulty)):\n            profit_and_difficulty[difficulty[i]] = profit[i]\n\nHowever, if the minimum profit of the 2 pairs occurs AFTER the maximum, then the minimum will override the max in your array (I assume that's what you're doing since we got exactly the same error on the same testcase).\n\nIf you instead change that block of code to something like:\n\tfor i in range(len(difficulty)):\n\t\tprofit_and_difficulty[difficulty[i]] = max(profit[i], profit_and_difficulty[difficulty[i]])\n\nI hope this is what you had, because I got the same error on the same testcase by the same amount."
                    },
                    {
                        "username": "shivani3",
                        "content": "Not sure What I missed, one test case failing out of 57\n \n`var maxProfitAssignment = function(difficulty, profit, worker) {\n\n   \n    let maps = new Map();\n    for(let i=0;i<difficulty.length;i++){\n        maps.set(difficulty[i],profit[i]);\n    }\n    let sortedArray = Array.from(maps.entries()).sort((a,b)=> {return a[0] - b[0]});\n    worker = worker.sort((a,b)=> a-b);\n    let maxprofitForWorker = 0;\n    let i=0;\n\n    return worker.reduce((total,skillLevel)=>{\n        while(i<sortedArray.length && skillLevel >= sortedArray[i][0]){\n            maxprofitForWorker = Math.max(maxprofitForWorker, sortedArray[i++][1]);\n        }\n        return total + maxprofitForWorker\n    }, 0)\n};`"
                    },
                    {
                        "username": "killerraj369",
                        "content": "in the solution why are we using a prefix array and why can not we directly do sum = max(sum, jobs[mid].second) ? \\n\\n int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) \\n    {\\n        int ans=0;\\n        vector<pair<int,int>> jobs;\\n        \\n        int n= profit.size();\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            jobs.push_back({difficulty[i],profit[i]});\\n        }\\n\\n        sort(jobs.begin(),jobs.end());\\n\\n        int mx=INT_MIN;\\n        vector<int> pre;\\n        for(auto i : jobs) pre.push_back(mx = max(i.second, mx));\\n\\n        for(auto i:worker)\\n        {\\n            int sum=0;\\n\\n            // Use Binay search to find the maximum profit from the sorted jobs vector\\n            int low=0;\\n            int high=n-1;\\n\\n            while(low<=high)\\n            {\\n                int mid = low +(high-low)/2;\\n\\n                if(jobs[mid].first<=i)\\n                {\\n                    sum= max(pre[mid],sum);\\n                    low=mid+1;\\n                }\\n                else\\n                {\\n                    // try to find a job with lower difficulty\\n                    high=mid-1;\\n                }\\n            }\\n\\n            cout<<sum<<\" \";\\n            ans+=sum; \\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Aparajita-Suman",
                        "content": "How to optimize this code? please suggest me!\n\n `\n\nclass Solution {\npublic:\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\n        int workhard = *max_element(worker.begin(), worker.end());\n        int mindiff = *min_element(difficulty.begin(), difficulty.end());\n\n        if (workhard < mindiff) return 0;\n        \n        vector<pair<int, int>> dp;\n\n        for (int i=0; i<profit.size(); i++) {\n            dp.emplace_back(difficulty[i], profit[i]);\n        }\n\n        sort(dp.begin(), dp.end());\n        int ans=0, maxi=0;\n        for (int i=0; i<worker.size(); i++) {\n            maxi = 0;\n            for (int j=0; j<profit.size(); j++) {\n                if (dp[j].first > worker[i]) break;\n                maxi = max(maxi, dp[j].second);\n            }\n            ans += maxi;\n        }\n\n        return ans;\n    }\n};\n`"
                    },
                    {
                        "username": "srk696772",
                        "content": "Try To use binary search inside workers loop bro as you are sorting difficulties , binary search will help you to reduce the time complexity."
                    }
                ]
            },
            {
                "id": 1829082,
                "content": [
                    {
                        "username": "ttk999",
                        "content": "Broken test imo\\n\\nInput\\ndifficulty =\\n[2,17,19,20,24,29,33,43,50,51,57,67,70,72,73,75,80,82,87,90]\\nprofit =\\n[6,7,10,17,18,29,30,31,34,39,40,42,48,54,57,78,78,78,83,88]\\nworker =\\n[12,9,11,41,11,87,48,6,48,93,76,73,7,50,55,97,47,33,46,10]\\n41 / 57 testcases passed\\nOutput\\n672\\nExpected\\n693\\n"
                    },
                    {
                        "username": "Omar_Nabil",
                        "content": "in profit array we have 3 elements with the same profit you have to handle it"
                    },
                    {
                        "username": "c4tdog",
                        "content": "harder work doesn't mean it is more profitable, meaning junior could earn more than senior :D"
                    },
                    {
                        "username": "layyy",
                        "content": "a testcase to try (profit does not increase with difficulty)\\ndifficulty - [68,35,52,47,86]\\nprofit - [67,17,1,81,3]\\nworker - [92,10,85,84,82]"
                    },
                    {
                        "username": "rkrux",
                        "content": "Very good question!"
                    },
                    {
                        "username": "devvartkumarkumar",
                        "content": "passing large DS by value as the argument can cause TLE, \\nIn my case, I passed the vector of pairs by the value that caused TLE at the last TC, then I tried to pass it by reference and got accepted. "
                    },
                    {
                        "username": "sayanpatel",
                        "content": "Something wrong with this testcase? I am getting my answer as 1324, while the expected is 1392.\\n\\ndifficulty = [66,1,28,73,53,35,45,60,100,44,59,94,27,88,7,18,83,18,72,63]\\n\\nprofit = [66,20,84,81,56,40,37,82,53,45,43,96,67,27,12,54,98,19,47,77]\\n\\nworker = [61,33,68,38,63,45,1,10,53,23,66,70,14,51,94,18,28,78,100,16]"
                    },
                    {
                        "username": "deskowl",
                        "content": "Me too. I'm not sure\nEDIT:\nI think perhaps you aren't accounting for this situation:\nThere are 2 difficulty 18 jobs in difficulty in this example (18,19) and (18,54). Perhaps in your code you have something like:\n        for i in range(len(difficulty)):\n            profit_and_difficulty[difficulty[i]] = profit[i]\n\nHowever, if the minimum profit of the 2 pairs occurs AFTER the maximum, then the minimum will override the max in your array (I assume that's what you're doing since we got exactly the same error on the same testcase).\n\nIf you instead change that block of code to something like:\n\tfor i in range(len(difficulty)):\n\t\tprofit_and_difficulty[difficulty[i]] = max(profit[i], profit_and_difficulty[difficulty[i]])\n\nI hope this is what you had, because I got the same error on the same testcase by the same amount."
                    },
                    {
                        "username": "shivani3",
                        "content": "Not sure What I missed, one test case failing out of 57\n \n`var maxProfitAssignment = function(difficulty, profit, worker) {\n\n   \n    let maps = new Map();\n    for(let i=0;i<difficulty.length;i++){\n        maps.set(difficulty[i],profit[i]);\n    }\n    let sortedArray = Array.from(maps.entries()).sort((a,b)=> {return a[0] - b[0]});\n    worker = worker.sort((a,b)=> a-b);\n    let maxprofitForWorker = 0;\n    let i=0;\n\n    return worker.reduce((total,skillLevel)=>{\n        while(i<sortedArray.length && skillLevel >= sortedArray[i][0]){\n            maxprofitForWorker = Math.max(maxprofitForWorker, sortedArray[i++][1]);\n        }\n        return total + maxprofitForWorker\n    }, 0)\n};`"
                    },
                    {
                        "username": "killerraj369",
                        "content": "in the solution why are we using a prefix array and why can not we directly do sum = max(sum, jobs[mid].second) ? \\n\\n int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) \\n    {\\n        int ans=0;\\n        vector<pair<int,int>> jobs;\\n        \\n        int n= profit.size();\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            jobs.push_back({difficulty[i],profit[i]});\\n        }\\n\\n        sort(jobs.begin(),jobs.end());\\n\\n        int mx=INT_MIN;\\n        vector<int> pre;\\n        for(auto i : jobs) pre.push_back(mx = max(i.second, mx));\\n\\n        for(auto i:worker)\\n        {\\n            int sum=0;\\n\\n            // Use Binay search to find the maximum profit from the sorted jobs vector\\n            int low=0;\\n            int high=n-1;\\n\\n            while(low<=high)\\n            {\\n                int mid = low +(high-low)/2;\\n\\n                if(jobs[mid].first<=i)\\n                {\\n                    sum= max(pre[mid],sum);\\n                    low=mid+1;\\n                }\\n                else\\n                {\\n                    // try to find a job with lower difficulty\\n                    high=mid-1;\\n                }\\n            }\\n\\n            cout<<sum<<\" \";\\n            ans+=sum; \\n        }\\n\\n        return ans;\\n    }"
                    },
                    {
                        "username": "Aparajita-Suman",
                        "content": "How to optimize this code? please suggest me!\n\n `\n\nclass Solution {\npublic:\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker) {\n        int workhard = *max_element(worker.begin(), worker.end());\n        int mindiff = *min_element(difficulty.begin(), difficulty.end());\n\n        if (workhard < mindiff) return 0;\n        \n        vector<pair<int, int>> dp;\n\n        for (int i=0; i<profit.size(); i++) {\n            dp.emplace_back(difficulty[i], profit[i]);\n        }\n\n        sort(dp.begin(), dp.end());\n        int ans=0, maxi=0;\n        for (int i=0; i<worker.size(); i++) {\n            maxi = 0;\n            for (int j=0; j<profit.size(); j++) {\n                if (dp[j].first > worker[i]) break;\n                maxi = max(maxi, dp[j].second);\n            }\n            ans += maxi;\n        }\n\n        return ans;\n    }\n};\n`"
                    },
                    {
                        "username": "srk696772",
                        "content": "Try To use binary search inside workers loop bro as you are sorting difficulties , binary search will help you to reduce the time complexity."
                    }
                ]
            }
        ]
    },
    {
        "title": "Ugly Number III",
        "question_content": "<p>An <strong>ugly number</strong> is a positive integer that is divisible by <code>a</code>, <code>b</code>, or <code>c</code>.</p>\n\n<p>Given four integers <code>n</code>, <code>a</code>, <code>b</code>, and <code>c</code>, return the <code>n<sup>th</sup></code> <strong>ugly number</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 3, a = 2, b = 3, c = 5\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> The ugly numbers are 2, 3, 4, 5, 6, 8, 9, 10... The 3<sup>rd</sup> is 4.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 4, a = 2, b = 3, c = 4\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> The ugly numbers are 2, 3, 4, 6, 8, 9, 10, 12... The 4<sup>th</sup> is 6.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 5, a = 2, b = 11, c = 13\n<strong>Output:</strong> 10\n<strong>Explanation:</strong> The ugly numbers are 2, 4, 6, 8, 10, 11, 12, 13... The 5<sup>th</sup> is 10.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n, a, b, c &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= a * b * c &lt;= 10<sup>18</sup></code></li>\n\t<li>It is guaranteed that the result will be in range <code>[1, 2 * 10<sup>9</sup>]</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 387539,
                "title": "cpp-binary-search-with-picture-binary-search-template",
                "content": "For every integer N, `F(N) = (total number of positive integers <= N which are divisible by a or b or c.).`\\n![image](https://assets.leetcode.com/users/insomniacat/image_1569133734.png)\\n\\n`The left-top circle stands for numbers <= N that are divisible by a` \\nothers the same idea, and the intersection of two/three circles is the total number of positive integers  <= N which are divisible by the` least common multiple` of them.\\n`F(N) =  a + b + c -  a \\u2229 c - a \\u2229 b - b \\u2229 c + a \\u2229 b \\u2229 c `\\n`F(N) =    N/a  + N/b +  N/c - N/lcm(a, c) -  N/lcm(a, b) -   N/lcm(b, c) + N/lcm(a, b, c) `(lcm = least common multiple)\\nFind the least integer `N` that satisfies the condition `F(N) >= K` \\n```\\nclass Solution {\\npublic:    \\n   int nthUglyNumber(int k, int A, int B, int C) {\\n        int lo = 1, hi = 2 * (int) 1e9;\\n        long a = long(A), b = long(B), c = long(C);\\n        long ab = a * b / __gcd(a, b);\\n        long bc = b * c / __gcd(b, c);\\n        long ac = a * c / __gcd(a, c);\\n        long abc = a * bc / __gcd(a, bc);\\n        while(lo < hi) {\\n            int mid = lo + (hi - lo)/2;\\n            int cnt = mid/a + mid/b + mid/c - mid/ab - mid/bc - mid/ac + mid/abc;\\n            if(cnt < k) \\n                lo = mid + 1;\\n            else\\n\\t\\t\\t   //the condition: F(N) >= k\\n                hi = mid;\\n        }\\n        return lo;\\n    }\\n};\\n```\\nComplexity\\n* Time: O(log(2* 1e9))\\n* Space: O(1)\\n\\nUpdate: \\nI used to solve the Binary Search problems with this template:\\n```\\nwhile(lo < hi) {\\nint mid = lo + (hi - lo) / 2;\\nif(Special condition passed)(optional):\\n\\treturn mid; \\nif(condition passed)\\n  hi = mid;\\nelse \\n  lo = mid + 1;\\n}\\nreturn lo;\\n```\\nThe key idea is that the range of searching is monotonic, i.e., `If F(a) == true, then for every b > a, F(b) = true`. So our goal is to find the leftmost point a that `F(a) == true`, which can be solved by binary search. In order to find the leftmost point which satisfies the condition, do not break the loop immediately when u find a valid point (There may exist some valid points on the left side). Instead, what u can do is to `narrow the searching range`, and the `lo` point will be the answer. In some cases there\\'s no answer and `lo` will return as the initial `hi` value, check that case too.\\nMost of binary search problems can be solved by the template above.\\nTry [875](https://leetcode.com/problems/koko-eating-bananas/)\\n[1011](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/)\\n[668](https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/)\\n[719](https://leetcode.com/problems/find-k-th-smallest-pair-distance/)\\nHope it helps.\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:    \\n   int nthUglyNumber(int k, int A, int B, int C) {\\n        int lo = 1, hi = 2 * (int) 1e9;\\n        long a = long(A), b = long(B), c = long(C);\\n        long ab = a * b / __gcd(a, b);\\n        long bc = b * c / __gcd(b, c);\\n        long ac = a * c / __gcd(a, c);\\n        long abc = a * bc / __gcd(a, bc);\\n        while(lo < hi) {\\n            int mid = lo + (hi - lo)/2;\\n            int cnt = mid/a + mid/b + mid/c - mid/ab - mid/bc - mid/ac + mid/abc;\\n            if(cnt < k) \\n                lo = mid + 1;\\n            else\\n\\t\\t\\t   //the condition: F(N) >= k\\n                hi = mid;\\n        }\\n        return lo;\\n    }\\n};\\n```\n```\\nwhile(lo < hi) {\\nint mid = lo + (hi - lo) / 2;\\nif(Special condition passed)(optional):\\n\\treturn mid; \\nif(condition passed)\\n  hi = mid;\\nelse \\n  lo = mid + 1;\\n}\\nreturn lo;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 387780,
                "title": "java-c-binary-search-with-venn-diagram-explain-math-formula",
                "content": "**Formula**\\nCalculate how many numbers from `1` to `num` are divisible by either `a`, `b` or `c` by using below formula:\\n`num/a + num/b + num/c \\u2013 num/lcm(a, b) \\u2013 num/lcm(b, c) \\u2013 num/lcm(a, c) + num/lcm(a, b, c)`\\n\\n**Explain**\\n![image](https://assets.leetcode.com/users/hiepit/image_1569139496.png)\\n\\n**Complexity**\\n- Time: `O(log(MAX_ANS))`, MAX_ANS = 2*10^9\\n- Space: `O(1)`\\n\\n**Java**\\n```java\\npublic class Solution {\\n    int MAX_ANS = (int) 2e9; // 2*10^9\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        int left = 0, right = MAX_ANS, result = 0;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (count(mid, a, b, c) >= n) {\\n                result = mid;\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return result;\\n    }\\n    int count(long num, long a, long b, long c) {\\n        return (int) (num / a + num / b + num / c\\n                - num / lcm(a, b)\\n                - num / lcm(b, c)\\n                - num / lcm(a, c)\\n                + num / (lcm(a, lcm(b, c))));\\n    }\\n    long gcd(long a, long b) {\\n        if (a == 0) return b;\\n        return gcd(b % a, a);\\n    }\\n    long lcm(long a, long b) {\\n        return a * b / gcd(a, b);\\n    }\\n}\\n```\\n\\n**C++**\\n```c++\\ntypedef long long ll;\\n#define MAX_ANS 2e9 // 2 * 10^9\\n\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int left = 0, right = MAX_ANS, result = 0;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (count(mid, a, b, c) >= n) { // find mid as small as possible that count == n\\n                result = mid;\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return result;\\n    }\\n    int count(ll num, ll a, ll b, ll c) {\\n        return (int)(num / a + num / b + num / c\\n            - num / lcm(a, b)\\n            - num / lcm(b, c)\\n            - num / lcm(a, c)\\n            + num / (lcm(a, lcm(b, c))));\\n    }\\n    ll gcd(ll a, ll b) {\\n        if (a == 0) return b;\\n        return gcd(b % a, a);\\n    }\\n    ll lcm(ll a, ll b) {\\n        return a * b / gcd(a, b);\\n    }\\n};\\n```\\n\\nThanks for watching. If you have any question, feel free to comment below. :D",
                "solutionTags": [],
                "code": "```java\\npublic class Solution {\\n    int MAX_ANS = (int) 2e9; // 2*10^9\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        int left = 0, right = MAX_ANS, result = 0;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (count(mid, a, b, c) >= n) {\\n                result = mid;\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return result;\\n    }\\n    int count(long num, long a, long b, long c) {\\n        return (int) (num / a + num / b + num / c\\n                - num / lcm(a, b)\\n                - num / lcm(b, c)\\n                - num / lcm(a, c)\\n                + num / (lcm(a, lcm(b, c))));\\n    }\\n    long gcd(long a, long b) {\\n        if (a == 0) return b;\\n        return gcd(b % a, a);\\n    }\\n    long lcm(long a, long b) {\\n        return a * b / gcd(a, b);\\n    }\\n}\\n```\n```c++\\ntypedef long long ll;\\n#define MAX_ANS 2e9 // 2 * 10^9\\n\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int left = 0, right = MAX_ANS, result = 0;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (count(mid, a, b, c) >= n) { // find mid as small as possible that count == n\\n                result = mid;\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return result;\\n    }\\n    int count(ll num, ll a, ll b, ll c) {\\n        return (int)(num / a + num / b + num / c\\n            - num / lcm(a, b)\\n            - num / lcm(b, c)\\n            - num / lcm(a, c)\\n            + num / (lcm(a, lcm(b, c))));\\n    }\\n    ll gcd(ll a, ll b) {\\n        if (a == 0) return b;\\n        return gcd(b % a, a);\\n    }\\n    ll lcm(ll a, ll b) {\\n        return a * b / gcd(a, b);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 769707,
                "title": "python-clear-explanation-powerful-ultimate-binary-search-template-solved-many-problems",
                "content": "First thing first, here is the code:\\n\\n```python\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        def enough(num) -> bool:\\n            total = mid//a + mid//b + mid//c - mid//ab - mid//ac - mid//bc + mid//abc\\n            return total >= n\\n\\n        ab = a * b // math.gcd(a, b)\\n        ac = a * c // math.gcd(a, c)\\n        bc = b * c // math.gcd(b, c)\\n        abc = a * bc // math.gcd(a, bc)\\n        left, right = 1, 10 ** 10\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if enough(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```\\n\\nI have built a powerful generalized binary search template and used it to solve many problems easily. Below is the detailed and clear introduction to this template. I believe it will be worth your time :)\\n\\n****\\n\\n# Intro\\n\\nBinary Search is quite easy to understand conceptually. Basically, it splits the search space into two halves and only keep the half that probably has the search target and throw away the other half that would not possibly have the answer. In this manner, we reduce the search space to half the size at every step, until we find the target. Binary Search helps us reduce the search time from linear O(n) to logarithmic O(log n). But when it comes to implementation, it\\'s rather difficult to write a bug-free code in just a few minutes. Some of the most common problems include:\\n\\n- When to exit the loop? Should we use `left < right` or `left <= right` as the while loop condition?\\n- How to initialize the boundary variable `left` and `right`?\\n- How to update the boundary? How to choose the appropriate combination from `left = mid `, `left = mid + 1` and  `right = mid`, `right = mid - 1`?\\n\\nA rather common misunderstanding of binary search is that people often think this technique could only be used in simple scenario like \"Given a sorted array, find a specific value in it\". As a matter of fact, it can be applied to much more complicated situations.\\n\\nAfter a lot of practice in LeetCode, I\\'ve made a powerful binary search template and solved many Hard problems by just slightly twisting this template. I\\'ll share the template with you guys in this post. I don\\'t want to just show off the code and leave. Most importantly, I want to share the logical thinking: how to apply this general template to all sorts of problems. Hopefully, after reading this post, people wouldn\\'t be pissed off any more when LeetCoding, \"Holy sh*t! This problem could be solved with binary search! Why didn\\'t I think of that before!\"\\n\\n\\n\\n****\\n\\n\\n\\n# Most Generalized Binary Search\\n\\nSuppose we have a search space. It could be an array, a range, etc. Usually it\\'s sorted in ascend order. For most tasks, we can transform the requirement into the following generalized form:\\n\\n**Minimize k ,    s.t.  condition(k) is True**\\n\\nThe following code is the most generalized binary search template:\\n\\n```python\\ndef binary_search(array) -> int:\\n    def condition(value) -> bool:\\n        pass\\n\\n    left, right = 0, len(array)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if condition(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\\n\\nWhat\\'s really nice of this template is that, for most of the binary search problems, we only need to modify three parts after copy-pasting this template, and never need to worry about corner cases and bugs in code any more:\\n\\n- Correctly initialize the boundary variables `left` and `right`. Only one rule: set up the boundary to **include all possible elements**;\\n- Decide return value. Is it `return left` or `return left - 1`? Remember this: **after exiting the while loop, `left` is the minimal k\\u200B satisfying the `condition ` function**;\\n- Design the `condition` function. This is the most difficult and most beautiful part. Needs lots of practice.\\n\\nBelow I\\'ll show you guys how to apply this powerful template to many LeetCode problems.\\n\\n\\n\\n****\\n\\n\\n\\n# Basic Application\\n\\n## [278. First Bad Version [Easy]](https://leetcode.com/problems/first-bad-version/)\\n\\nYou are a product manager and currently leading a team to develop a new product. Since each version is developed based on the previous version, all the versions after a bad version are also bad. Suppose you have `n` versions `[1, 2, ..., n]` and you want to find out the first bad one, which causes all the following ones to be bad. You are given an API `bool isBadVersion(version)` which will return whether `version` is bad.\\n\\n**Example:**\\n\\n```scala\\nGiven n = 5, and version = 4 is the first bad version.\\n\\ncall isBadVersion(3) -> false\\ncall isBadVersion(5) -> true\\ncall isBadVersion(4) -> true\\n\\nThen 4 is the first bad version. \\n```\\n\\nFirst, we initialize `left = 1` and `right = n` to include all possible values. Then we notice that we don\\'t even need to design the `condition` function. It\\'s already given by the `isBadVersion` API. Finding the first bad version is equivalent to finding the minimal k satisfying `isBadVersion(k) is True`. Our template can fit in very nicely:\\n\\n```python\\nclass Solution:\\n    def firstBadVersion(self, n) -> int:\\n        left, right = 1, n\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```\\n\\n****\\n\\n\\n\\n## [69. Sqrt(x) [Easy]](https://leetcode.com/problems/sqrtx/)\\n\\nImplement `int sqrt(int x)`. Compute and return the square root of *x*, where *x* is guaranteed to be a non-negative integer. Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.\\n\\n**Example:**\\n\\n```scala\\nInput: 4\\nOutput: 2\\n```\\n\\n```scala\\nInput: 8\\nOutput: 2\\n```\\n\\nQuite an easy problem. We need to search for maximal k satisfying `k^2 <= x`, so we can easily come up with the solution:\\n\\n```python\\ndef mySqrt(x: int) -> int:\\n    left, right = 0, x\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if mid * mid <= x:\\n            left = mid + 1\\n        else:\\n            right = mid\\n    return left - 1\\n```\\n\\nThere\\'s one thing I\\'d like to point out. Remember I say that **we usually look for the minimal k value satisfying certain condition**? But in this problem we are searching for maximal k value instead. Feeling confused? Don\\'t be. Actually, the maximal k satisfying `condition(k) is False` is just equal to the minimal k satisfying `condition(k) is True` minus one. This is why I mentioned earlier that we need to decide which value to return, `left` or `left - 1`.\\n\\n\\n\\n****\\n\\n\\n\\n## [35. Search Insert Position [Easy]](https://leetcode.com/problems/search-insert-position/)\\n\\nGiven a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array.\\n\\n**Example:**\\n\\n```scala\\nInput: [1,3,5,6], 5\\nOutput: 2\\n```\\n\\n```scala\\nInput: [1,3,5,6], 2\\nOutput: 1\\n```\\n\\nVery classic application of binary search. We are looking for the minimal k value satisfying `nums[k] >= target`, and we can just copy-paste our template. Notice that our solution is correct regardless of whether the input array `nums` has duplicates. Also notice that the input  `target` might be larger than all elements in `nums` and therefore needs to placed at the end of the array. That\\'s why we should initialize `right = len(nums)` instead of `right = len(nums) - 1`.\\n\\n```python\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        left, right = 0, len(nums)\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if nums[mid] >= target:\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```\\n\\n\\n\\n****\\n\\n\\n\\n# Advanced Application\\n\\nThe above problems are quite easy to solve, because they already give us the array to be searched. We\\'d know that we should use binary search to solve them at first glance.  However, more often are the situations where the search space and search target are not so readily available. Sometimes we won\\'t even realize that the problem should be solved with binary search -- we might just turn to dynamic programming or DFS and get stuck for a very long time.\\n\\nAs for the question \"When can we use binary search?\", my answer is that, **If we can discover some kind of monotonicity, for example, if `condition(k) is True` then `condition(k + 1) is True`, then we can consider binary search**.\\n\\n## [1011. Capacity To Ship Packages Within D Days [Medium]](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/)\\n\\ndays. The `i`-th package on the conveyor belt has a weight of `weights[i]`. Each day, we load the ship with packages on the conveyor belt (in the order given by `weights`). We may not load more weight than the maximum weight capacity of the ship. \\n\\nReturn the least weight capacity of the ship that will result in all the packages on the conveyor belt being shipped within `D` days.\\n\\n**Example :**\\n\\n```scala\\nInput: weights = [1,2,3,4,5,6,7,8,9,10], D = 5\\nOutput: 15\\nExplanation: \\nA ship capacity of 15 is the minimum to ship all the packages in 5 days like this:\\n1st day: 1, 2, 3, 4, 5\\n2nd day: 6, 7\\n3rd day: 8\\n4th day: 9\\n5th day: 10\\n\\nNote that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed. \\n```\\n\\nBinary search probably would not come to our mind when we first meet this problem. We might automatically treat `weights` as search space and then realize we\\'ve entered a dead end after wasting lots of time. In fact, we are looking for the minimal one among all feasible capacities. We dig out the monotonicity of this problem: if we can successfully ship all packages within `D` days with capacity `m`, then we can definitely ship them all with any capacity larger than `m`. Now we can design a `condition` function, let\\'s call it `feasible`, given an input `capacity`, it returns whether it\\'s possible to ship all packages within `D` days. This can run in a greedy way: if there\\'s still room for the current package, we put this package onto the conveyor belt, otherwise we wait for the next day to place this package. If the total days needed exceeds `D`, we return `False`, otherwise we return `True`.\\n\\nNext, we need to initialize our boundary correctly. Obviously `capacity` should be at least `max(weights)`, otherwise the conveyor belt couldn\\'t ship the heaviest package. On the other hand, `capacity` need not be more than`sum(weights)`, because then we can ship all packages in just one day.\\n\\nNow we\\'ve got all we need to apply our binary search template:\\n\\n```python\\ndef shipWithinDays(weights: List[int], D: int) -> int:\\n    def feasible(capacity) -> bool:\\n        days = 1\\n        total = 0\\n        for weight in weights:\\n            total += weight\\n            if total > capacity:  # too heavy, wait for the next day\\n                total = weight\\n                days += 1\\n                if days > D:  # cannot ship within D days\\n                    return False\\n        return True\\n\\n    left, right = max(weights), sum(weights)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if feasible(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\\n\\n\\n\\n****\\n\\n\\n\\n## [410. Split Array Largest Sum [Hard]](https://leetcode.com/problems/split-array-largest-sum/)\\n\\nGiven an array which consists of non-negative integers and an integer *m*, you can split the array into *m* non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these *m* subarrays.\\n\\n**Example:**\\n\\n```scala\\nInput:\\nnums = [7,2,5,10,8]\\nm = 2\\n\\nOutput:\\n18\\n\\nExplanation:\\nThere are four ways to split nums into two subarrays. The best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18.\\n```\\n\\nIf you take a close look, you would probably see how similar this problem is with LC 1011 above. Similarly, we can design a `feasible` function: given an input `threshold`, then decide if we can split the array into several subarrays such that every subarray-sum is less than or equal to `threshold`. In this way, we discover the monotonicity of the problem: if `feasible(m)` is `True`, then all inputs larger than `m` can satisfy `feasible` function. You can see that the solution code is exactly the same as LC 1011.\\n\\n```python\\ndef splitArray(nums: List[int], m: int) -> int:        \\n    def feasible(threshold) -> bool:\\n        count = 1\\n        total = 0\\n        for num in nums:\\n            total += num\\n            if total > threshold:\\n                total = num\\n                count += 1\\n                if count > m:\\n                    return False\\n        return True\\n\\n    left, right = max(nums), sum(nums)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if feasible(mid):\\n            right = mid     \\n        else:\\n            left = mid + 1\\n    return left\\n```\\n\\nBut we probably would have doubts: It\\'s true that `left` returned by our solution is the minimal value satisfying `feasible`, but how can we know that we can split the original array to **actually get this subarray-sum**? For example, let\\'s say `nums = [7,2,5,10,8]` and `m = 2`. We have 4 different ways to split the array to get 4 different largest subarray-sum correspondingly: `25:[[7], [2,5,10,8]]`, `23:[[7,2], [5,10,8]]`, `18:[[7,2,5], [10,8]]`, `24:[[7,2,5,10], [8]]`. Only 4 values. But our search space `[max(nums), sum(nums)] = [10, 32]` has much more that just 4 values. That is, no matter how we split the input array, we cannot get most of the values in our search space.\\n\\nLet\\'s say `k` is the minimal value satisfying `feasible` function. We can prove the correctness of our solution with proof by contradiction. Assume that no subarray\\'s sum is equal to `k`, that is, every subarray sum is less than `k`. The variable `total` inside `feasible` function keeps track of the total weights of current load. If our assumption is correct, then `total` would always be less than `k`. As a result, `feasible(k - 1)` must be `True`, because `total` would at most be equal to `k - 1` and would never trigger the if-clause `if total > threshold`, therefore `feasible(k - 1)` must have the same output as `feasible(k)`, which is `True`. But we already know that `k`  is the minimal value satisfying `feasible` function, so `feasible(k - 1)` has to be `False`, which is a contradiction. So our assumption is incorrect. Now we\\'ve proved that our algorithm is correct.\\n\\n\\n\\n****\\n\\n\\n\\n## [875. Koko Eating Bananas [Medium]](https://leetcode.com/problems/koko-eating-bananas/)\\n\\nKoko loves to eat bananas. There are `N` piles of bananas, the `i`-th pile has `piles[i]` bananas. The guards have gone and will come back in `H` hours. Koko can decide her bananas-per-hour eating speed of `K`. Each hour, she chooses some pile of bananas, and eats K bananas from that pile. If the pile has less than `K` bananas, she eats all of them instead, and won\\'t eat any more bananas during this hour. \\n\\nKoko likes to eat slowly, but still wants to finish eating all the bananas before the guards come back. **Return the minimum integer `K` such that she can eat all the bananas within `H` hours**.\\n\\n**Example :**\\n\\n```scala\\nInput: piles = [3,6,7,11], H = 8\\nOutput: 4\\n```\\n\\n```scala\\nInput: piles = [30,11,23,4,20], H = 5\\nOutput: 30\\n```\\n\\n```scala\\nInput: piles = [30,11,23,4,20], H = 6\\nOutput: 23\\n```\\n\\nVery similar to LC 1011 and LC 410 mentioned above. Let\\'s design a `feasible` function, given an input `speed`, determine whether Koko can finish all bananas within `H` hours with hourly eating speed `speed`. Obviously, the lower bound of the search space is 1, and upper bound is `max(piles)`, because Koko can only choose one pile of bananas to eat every hour.\\n\\n```python\\ndef minEatingSpeed(piles: List[int], H: int) -> int:\\n    def feasible(speed) -> bool:\\n        # return sum(math.ceil(pile / speed) for pile in piles) <= H  # slower        \\n        return sum((pile - 1) / speed + 1 for pile in piles) <= H  # faster\\n\\n    left, right = 1, max(piles)\\n    while left < right:\\n        mid = left  + (right - left) // 2\\n        if feasible(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\\n\\n\\n\\n****\\n\\n\\n\\n## [1482. Minimum Number of Days to Make m Bouquets [Medium]](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/)\\n\\nGiven an integer array `bloomDay`, an integer `m` and an integer `k`. We need to make `m` bouquets. To make a bouquet, you need to use `k` **adjacent flowers** from the garden. The garden consists of `n` flowers, the `ith` flower will bloom in the `bloomDay[i]` and then can be used in **exactly one** bouquet. Return *the minimum number of days* you need to wait to be able to make `m` bouquets from the garden. If it is impossible to make `m` bouquets return **-1**.\\n\\n**Examples:**\\n\\n```scala\\nInput: bloomDay = [1,10,3,10,2], m = 3, k = 1\\nOutput: 3\\nExplanation: Let\\'s see what happened in the first three days. x means flower bloomed and _ means flower didn\\'t bloom in the garden.\\nWe need 3 bouquets each should contain 1 flower.\\nAfter day 1: [x, _, _, _, _]   // we can only make one bouquet.\\nAfter day 2: [x, _, _, _, x]   // we can only make two bouquets.\\nAfter day 3: [x, _, x, _, x]   // we can make 3 bouquets. The answer is 3.\\n```\\n\\n```scala\\nInput: bloomDay = [1,10,3,10,2], m = 3, k = 2\\nOutput: -1\\nExplanation: We need 3 bouquets each has 2 flowers, that means we need 6 flowers. We only have 5 flowers so it is impossible to get the needed bouquets and we return -1.\\n```\\n\\nNow that we\\'ve solved three advanced problems above, this one should be pretty easy to do. The monotonicity of this problem is very clear: if we can make `m` bouquets after waiting for `d` days, then we can definitely finish that as well if we wait more than `d` days.\\n\\n```python\\ndef minDays(bloomDay: List[int], m: int, k: int) -> int:\\n    def feasible(days) -> bool:\\n        bonquets, flowers = 0, 0\\n        for bloom in bloomDay:\\n            if bloom > days:\\n                flowers = 0\\n            else:\\n                bonquets += (flowers + 1) // k\\n                flowers = (flowers + 1) % k\\n        return bonquets >= m\\n\\n    if len(bloomDay) < m * k:\\n        return -1\\n    left, right = 1, max(bloomDay)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if feasible(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\\n\\n\\n\\n****\\n\\n\\n\\n## [668. Kth Smallest Number in Multiplication Table [Hard]](https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/description/)\\n\\nNearly every one have used the [Multiplication Table](https://en.wikipedia.org/wiki/Multiplication_table). But could you find out the `k-th` smallest number quickly from the multiplication table? Given the height `m` and the length `n` of a `m * n` Multiplication Table, and a positive integer `k`, you need to return the `k-th` smallest number in this table.\\n\\n**Example :**\\n\\n```scala\\nInput: m = 3, n = 3, k = 5\\nOutput: 3\\nExplanation: \\nThe Multiplication Table:\\n1\\t2\\t3\\n2\\t4\\t6\\n3\\t6\\t9\\n\\nThe 5-th smallest number is 3 (1, 2, 2, 3, 3).\\n```\\n\\nFor Kth-Smallest problems like this, what comes to our mind first is Heap. Usually we can  maintain a Min-Heap and just pop the top of the Heap for k times. However, that doesn\\'t work out in this problem. We don\\'t have every single number in the entire Multiplication Table, instead, we only have the height and the length of the table. If we are to apply Heap method, we need to explicitly calculate these `m * n` values and save them to a heap. The time complexity and space complexity of this process are both O(mn), which is quite inefficient. This is when binary search comes in. Remember we say that designing `condition` function is the most difficult part? In order to find the k-th smallest value in the table, we can design an `enough` function, given an input `num`, determine whether there\\'re at least k values less than or equal to `num`. **The minimal `num` satisfying `enough` function is the answer we\\'re looking for**. Recall that the key to binary search is discovering monotonicity. In this problem, if `num` satisfies `enough`, then of course any value larger than `num` can satisfy. This monotonicity is the fundament of our binary search algorithm.\\n\\nLet\\'s consider search space. Obviously the lower bound should be 1, and the upper bound should be the largest value in the Multiplication Table, which is `m * n`, then we have search space `[1, m * n]`. The overwhelming advantage of binary search solution to heap solution is that it doesn\\'t need to explicitly calculate all numbers in that table, all it needs is just picking up one value out of the search space and apply `enough` function to this value, to determine should we keep the left half or the right half of the search space. In this way, binary search solution only requires constant space complexity, much better than heap solution.\\n\\nNext let\\'s consider how to implement `enough` function. It can be observed that every row in the Multiplication Table is just multiples of its index. For example, all numbers in 3rd row `[3,6,9,12,15...]` are multiples of 3. Therefore, we can just go row by row to count the total number of entries less than or equal to input `num`. Following is the complete solution.\\n\\n```python\\ndef findKthNumber(m: int, n: int, k: int) -> int:\\n    def enough(num) -> bool:\\n        count = 0\\n        for val in range(1, m + 1):  # count row by row\\n            add = min(num // val, n)\\n            if add == 0:  # early exit\\n                break\\n            count += add\\n        return count >= k                \\n\\n    left, right = 1, n * m\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if enough(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left \\n```\\n\\nIn LC 410 above, we have doubt \"Is the result from binary search actually a subarray sum?\". Here we have a similar doubt: \"Is the result from binary search actually in the Multiplication Table?\". The answer is yes, and we also can apply proof by contradiction. Denote `num` as the minimal input that satisfies `enough` function. Let\\'s assume that `num` is not in the table, which means that `num` is not divisible by any `val` in `[1, m]`, that is, `num % val > 0`. Therefore, changing the input from `num` to `num - 1` doesn\\'t have any effect on the expression `add = min(num // val, n)`. So `enough(num)` would also return `True`,  just like `enough(num)`. But we already know `num` is the minimal input satisfying `enough` function, so `enough(num - 1)` has to be `False`. Contradiction! The opposite of our original assumption is true: `num` is actually in the table.\\n\\n\\n\\n****\\n\\n\\n\\n## [719. Find K-th Smallest Pair Distance [Hard]](https://leetcode.com/problems/find-k-th-smallest-pair-distance/)\\n\\nGiven an integer array, return the k-th smallest **distance** among all the pairs. The distance of a pair (A, B) is defined as the absolute difference between A and B.\\n\\n**Example :**\\n\\n```scala\\nInput:\\nnums = [1,3,1]\\nk = 1\\nOutput: 0 \\nExplanation:\\nFollowing are all the pairs. The 1st smallest distance pair is (1,1), and its distance is 0.\\n(1,3) -> 2\\n(1,1) -> 0\\n(3,1) -> 2\\n```\\n\\nVery similar to LC 668 above, both are about finding Kth-Smallest. Just like LC 668, We can design an `enough` function, given an input `distance`, determine whether there\\'re at least k pairs whose distances are less than or equal to `distance`. We can sort the input array and use two pointers (fast pointer and slow pointer, pointed at a pair) to scan it. Both pointers go from leftmost end. If the current pair pointed at has a distance less than or equal to `distance`, all pairs between these pointers are valid (since the array is already sorted), we move forward the fast pointer. Otherwise, we move forward the slow pointer. By the time both pointers reach the rightmost end, we finish our scan and see if total counts exceed k. Here is the implementation:\\n\\n```python\\ndef enough(distance) -> bool:  # two pointers\\n    count, i, j = 0, 0, 0\\n    while i < n or j < n:\\n        while j < n and nums[j] - nums[i] <= distance:  # move fast pointer\\n            j += 1\\n        count += j - i - 1  # count pairs\\n        i += 1  # move slow pointer\\n    return count >= k\\n```\\n\\nObviously, our search space should be `[0, max(nums) - min(nums)]`. Now we are ready to copy-paste our template:\\n\\n```python\\ndef smallestDistancePair(nums: List[int], k: int) -> int:\\n    nums.sort()\\n    n = len(nums)\\n    left, right = 0, nums[-1] - nums[0]\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if enough(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\\n\\n\\n\\n****\\n\\n\\n\\n## [1201. Ugly Number III [Medium]](https://leetcode.com/problems/ugly-number-iii/)\\n\\nWrite a program to find the `n`-th ugly number. Ugly numbers are **positive integers** which are divisible by `a` **or** `b` **or** `c`.\\n\\n**Example :**\\n\\n```scala\\nInput: n = 3, a = 2, b = 3, c = 5\\nOutput: 4\\nExplanation: The ugly numbers are 2, 3, 4, 5, 6, 8, 9, 10... The 3rd is 4.\\n```\\n\\n```scala\\nInput: n = 4, a = 2, b = 3, c = 4\\nOutput: 6\\nExplanation: The ugly numbers are 2, 3, 4, 6, 8, 9, 10, 12... The 4th is 6.\\n```\\n\\nNothing special. Still finding the Kth-Smallest. We need to design an `enough` function, given an input `num`, determine whether there are at least n ugly numbers less than or equal to `num`. Since `a` might be a multiple of `b` or `c`, or the other way round, we need the help of greatest common divisor to avoid counting duplicate numbers.\\n\\n```python\\ndef nthUglyNumber(n: int, a: int, b: int, c: int) -> int:\\n    def enough(num) -> bool:\\n        total = mid//a + mid//b + mid//c - mid//ab - mid//ac - mid//bc + mid//abc\\n        return total >= n\\n\\n    ab = a * b // math.gcd(a, b)\\n    ac = a * c // math.gcd(a, c)\\n    bc = b * c // math.gcd(b, c)\\n    abc = a * bc // math.gcd(a, bc)\\n    left, right = 1, 10 ** 10\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if enough(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\\n\\n\\n\\n****\\n\\n\\n\\n## [1283. Find the Smallest Divisor Given a Threshold [Medium]](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/)\\n\\nGiven an array of integers `nums` and an integer `threshold`, we will choose a positive integer divisor and divide all the array by it and sum the result of the division. Find the **smallest** divisor such that the result mentioned above is less than or equal to `threshold`.\\n\\nEach result of division is rounded to the nearest integer greater than or equal to that element. (For example: 7/3 = 3 and 10/2 = 5). It is guaranteed that there will be an answer.\\n\\n**Example :**\\n\\n```scala\\nInput: nums = [1,2,5,9], threshold = 6\\nOutput: 5\\nExplanation: We can get a sum to 17 (1+2+5+9) if the divisor is 1. \\nIf the divisor is 4 we can get a sum to 7 (1+1+2+3) and if the divisor is 5 the sum will be 5 (1+1+1+2). \\n```\\n\\nAfter so many problems introduced above, this one should be a piece of cake. We don\\'t even need to bother to design a `condition` function, because the problem has already told us explicitly what condition we need to satisfy.\\n\\n```python\\ndef smallestDivisor(nums: List[int], threshold: int) -> int:\\n    def condition(divisor) -> bool:\\n        return sum((num - 1) // divisor + 1 for num in nums) <= threshold\\n\\n    left, right = 1, max(nums)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if condition(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\\n\\n\\n\\n****\\n\\n\\n\\n# End\\n\\nWow, thank you so much for making it to the end, really appreciate that. As you can see from the python codes above, they all look very similar to each other. That\\'s because I copy-pasted my template all the time. No exception. This is the strong proof of my template\\'s powerfulness. I believe everyone can acquire this binary search template to solve many problems. All we need is just more practice to build up our ability to discover the monotonicity of the problem and to design a beautiful `condition` function.\\n\\nHope this helps.\\n\\n**Reference**\\n\\n- [[C++ / Fast / Very clear explanation / Clean Code] Solution with Greedy Algorithm and Binary Search](https://leetcode.com/problems/split-array-largest-sum/discuss/89819/C%2B%2B-Fast-Very-clear-explanation-Clean-Code-Solution-with-Greedy-Algorithm-and-Binary-Search)\\n- [Approach the problem using the \"trial and error\" algorithm](https://leetcode.com/problems/find-k-th-smallest-pair-distance/discuss/109082/Approach-the-problem-using-the-\"trial-and-error\"-algorithm)\\n- [Binary Search 101 The-Ultimate-Binary-Search-Handbook - LeetCode](https://leetcode.com/problems/binary-search/discuss/423162/Binary-Search-101-The-Ultimate-Binary-Search-Handbook)\\n- [ugly-number-iii Binary Search with picture & Binary Search Template - LeetCode](https://leetcode.com/problems/ugly-number-iii/discuss/387539/cpp-Binary-Search-with-picture-and-Binary-Search-Template)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        def enough(num) -> bool:\\n            total = mid//a + mid//b + mid//c - mid//ab - mid//ac - mid//bc + mid//abc\\n            return total >= n\\n\\n        ab = a * b // math.gcd(a, b)\\n        ac = a * c // math.gcd(a, c)\\n        bc = b * c // math.gcd(b, c)\\n        abc = a * bc // math.gcd(a, bc)\\n        left, right = 1, 10 ** 10\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if enough(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```\n```python\\ndef binary_search(array) -> int:\\n    def condition(value) -> bool:\\n        pass\\n\\n    left, right = 0, len(array)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if condition(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\n```scala\\nGiven n = 5, and version = 4 is the first bad version.\\n\\ncall isBadVersion(3) -> false\\ncall isBadVersion(5) -> true\\ncall isBadVersion(4) -> true\\n\\nThen 4 is the first bad version. \\n```\n```python\\nclass Solution:\\n    def firstBadVersion(self, n) -> int:\\n        left, right = 1, n\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```\n```scala\\nInput: 4\\nOutput: 2\\n```\n```scala\\nInput: 8\\nOutput: 2\\n```\n```python\\ndef mySqrt(x: int) -> int:\\n    left, right = 0, x\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if mid * mid <= x:\\n            left = mid + 1\\n        else:\\n            right = mid\\n    return left - 1\\n```\n```scala\\nInput: [1,3,5,6], 5\\nOutput: 2\\n```\n```scala\\nInput: [1,3,5,6], 2\\nOutput: 1\\n```\n```python\\nclass Solution:\\n    def searchInsert(self, nums: List[int], target: int) -> int:\\n        left, right = 0, len(nums)\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if nums[mid] >= target:\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```\n```scala\\nInput: weights = [1,2,3,4,5,6,7,8,9,10], D = 5\\nOutput: 15\\nExplanation: \\nA ship capacity of 15 is the minimum to ship all the packages in 5 days like this:\\n1st day: 1, 2, 3, 4, 5\\n2nd day: 6, 7\\n3rd day: 8\\n4th day: 9\\n5th day: 10\\n\\nNote that the cargo must be shipped in the order given, so using a ship of capacity 14 and splitting the packages into parts like (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) is not allowed. \\n```\n```python\\ndef shipWithinDays(weights: List[int], D: int) -> int:\\n    def feasible(capacity) -> bool:\\n        days = 1\\n        total = 0\\n        for weight in weights:\\n            total += weight\\n            if total > capacity:  # too heavy, wait for the next day\\n                total = weight\\n                days += 1\\n                if days > D:  # cannot ship within D days\\n                    return False\\n        return True\\n\\n    left, right = max(weights), sum(weights)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if feasible(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\n```scala\\nInput:\\nnums = [7,2,5,10,8]\\nm = 2\\n\\nOutput:\\n18\\n\\nExplanation:\\nThere are four ways to split nums into two subarrays. The best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18.\\n```\n```python\\ndef splitArray(nums: List[int], m: int) -> int:        \\n    def feasible(threshold) -> bool:\\n        count = 1\\n        total = 0\\n        for num in nums:\\n            total += num\\n            if total > threshold:\\n                total = num\\n                count += 1\\n                if count > m:\\n                    return False\\n        return True\\n\\n    left, right = max(nums), sum(nums)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if feasible(mid):\\n            right = mid     \\n        else:\\n            left = mid + 1\\n    return left\\n```\n```scala\\nInput: piles = [3,6,7,11], H = 8\\nOutput: 4\\n```\n```scala\\nInput: piles = [30,11,23,4,20], H = 5\\nOutput: 30\\n```\n```scala\\nInput: piles = [30,11,23,4,20], H = 6\\nOutput: 23\\n```\n```python\\ndef minEatingSpeed(piles: List[int], H: int) -> int:\\n    def feasible(speed) -> bool:\\n        # return sum(math.ceil(pile / speed) for pile in piles) <= H  # slower        \\n        return sum((pile - 1) / speed + 1 for pile in piles) <= H  # faster\\n\\n    left, right = 1, max(piles)\\n    while left < right:\\n        mid = left  + (right - left) // 2\\n        if feasible(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\n```scala\\nInput: bloomDay = [1,10,3,10,2], m = 3, k = 1\\nOutput: 3\\nExplanation: Let\\'s see what happened in the first three days. x means flower bloomed and _ means flower didn\\'t bloom in the garden.\\nWe need 3 bouquets each should contain 1 flower.\\nAfter day 1: [x, _, _, _, _]   // we can only make one bouquet.\\nAfter day 2: [x, _, _, _, x]   // we can only make two bouquets.\\nAfter day 3: [x, _, x, _, x]   // we can make 3 bouquets. The answer is 3.\\n```\n```scala\\nInput: bloomDay = [1,10,3,10,2], m = 3, k = 2\\nOutput: -1\\nExplanation: We need 3 bouquets each has 2 flowers, that means we need 6 flowers. We only have 5 flowers so it is impossible to get the needed bouquets and we return -1.\\n```\n```python\\ndef minDays(bloomDay: List[int], m: int, k: int) -> int:\\n    def feasible(days) -> bool:\\n        bonquets, flowers = 0, 0\\n        for bloom in bloomDay:\\n            if bloom > days:\\n                flowers = 0\\n            else:\\n                bonquets += (flowers + 1) // k\\n                flowers = (flowers + 1) % k\\n        return bonquets >= m\\n\\n    if len(bloomDay) < m * k:\\n        return -1\\n    left, right = 1, max(bloomDay)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if feasible(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\n```scala\\nInput: m = 3, n = 3, k = 5\\nOutput: 3\\nExplanation: \\nThe Multiplication Table:\\n1\\t2\\t3\\n2\\t4\\t6\\n3\\t6\\t9\\n\\nThe 5-th smallest number is 3 (1, 2, 2, 3, 3).\\n```\n```python\\ndef findKthNumber(m: int, n: int, k: int) -> int:\\n    def enough(num) -> bool:\\n        count = 0\\n        for val in range(1, m + 1):  # count row by row\\n            add = min(num // val, n)\\n            if add == 0:  # early exit\\n                break\\n            count += add\\n        return count >= k                \\n\\n    left, right = 1, n * m\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if enough(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left \\n```\n```scala\\nInput:\\nnums = [1,3,1]\\nk = 1\\nOutput: 0 \\nExplanation:\\nFollowing are all the pairs. The 1st smallest distance pair is (1,1), and its distance is 0.\\n(1,3) -> 2\\n(1,1) -> 0\\n(3,1) -> 2\\n```\n```python\\ndef enough(distance) -> bool:  # two pointers\\n    count, i, j = 0, 0, 0\\n    while i < n or j < n:\\n        while j < n and nums[j] - nums[i] <= distance:  # move fast pointer\\n            j += 1\\n        count += j - i - 1  # count pairs\\n        i += 1  # move slow pointer\\n    return count >= k\\n```\n```python\\ndef smallestDistancePair(nums: List[int], k: int) -> int:\\n    nums.sort()\\n    n = len(nums)\\n    left, right = 0, nums[-1] - nums[0]\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if enough(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\n```scala\\nInput: n = 3, a = 2, b = 3, c = 5\\nOutput: 4\\nExplanation: The ugly numbers are 2, 3, 4, 5, 6, 8, 9, 10... The 3rd is 4.\\n```\n```scala\\nInput: n = 4, a = 2, b = 3, c = 4\\nOutput: 6\\nExplanation: The ugly numbers are 2, 3, 4, 6, 8, 9, 10, 12... The 4th is 6.\\n```\n```python\\ndef nthUglyNumber(n: int, a: int, b: int, c: int) -> int:\\n    def enough(num) -> bool:\\n        total = mid//a + mid//b + mid//c - mid//ab - mid//ac - mid//bc + mid//abc\\n        return total >= n\\n\\n    ab = a * b // math.gcd(a, b)\\n    ac = a * c // math.gcd(a, c)\\n    bc = b * c // math.gcd(b, c)\\n    abc = a * bc // math.gcd(a, bc)\\n    left, right = 1, 10 ** 10\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if enough(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```\n```scala\\nInput: nums = [1,2,5,9], threshold = 6\\nOutput: 5\\nExplanation: We can get a sum to 17 (1+2+5+9) if the divisor is 1. \\nIf the divisor is 4 we can get a sum to 7 (1+1+2+3) and if the divisor is 5 the sum will be 5 (1+1+1+2). \\n```\n```python\\ndef smallestDivisor(nums: List[int], threshold: int) -> int:\\n    def condition(divisor) -> bool:\\n        return sum((num - 1) // divisor + 1 for num in nums) <= threshold\\n\\n    left, right = 1, max(nums)\\n    while left < right:\\n        mid = left + (right - left) // 2\\n        if condition(mid):\\n            right = mid\\n        else:\\n            left = mid + 1\\n    return left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 387561,
                "title": "short-and-concise-c-solution-binary-search-with-explanation",
                "content": "This problem can easily solved by binary-search by defining the predicate: \"Given N, how many numbers upto N are divisible by A or B or C\"\\n\\nThe predicate can be evaluated by inclusion-exclusion principle:\\n\\n\\tNo. of numbers upto N divisible by A = N/A;\\n\\tNo. of numbers upto N divisible by B = N/B;\\n\\tNo. of numbers upto N divisible by C = N/C;\\n\\t\\n\\tNo. of numbers upto N divisible by both A and B = N / lcm(A, B);\\n\\tNo. of numbers upto N divisible by both B and C = N / lcm(B, C);\\n\\tNo. of numbers upto N divisible by both A and C = N / lcm(A, C);\\n\\t\\n\\tNo. of numbers upto N divisible by all A, B and C = N / lcm(A, B, C);\\n\\t\\nFurthermore LCM(A, B) can be computed as LCM(A, B) = (A*B) / GCD(A, B)\\n\\nFor problem solving technique using binary search predicate, refer to the following awesome article:\\n\\thttps://www.topcoder.com/community/competitive-programming/tutorials/binary-search\\n\\n```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    ll lcm(ll a, ll b) {\\n        return a*b / __gcd(a, b);\\n    }\\n    \\n    int nthUglyNumber(int n, int a, int b, int c) \\n    {\\n        ll N = (ll)n, A = ll(a), B = ll(b), C = ll(c);\\n        ll lo = 1, hi = 2000000000, mid, ans;\\n        \\n        while(lo <= hi)\\n        {\\n            mid = lo + (hi - lo)/2;\\n            ll cnt = 0;\\n            cnt += mid/A;\\n            cnt += mid/B;\\n            cnt += mid/C;\\n            cnt -= mid / lcm(A, B);\\n            cnt -= mid / lcm(B, C);\\n            cnt -= mid / lcm(C, A);\\n            cnt += mid / lcm(a, lcm(b, c));\\n            \\n            if(cnt >= N)\\n            {\\n                ans = mid;\\n                hi = mid-1;\\n            }\\n            else\\n                lo = mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    ll lcm(ll a, ll b) {\\n        return a*b / __gcd(a, b);\\n    }\\n    \\n    int nthUglyNumber(int n, int a, int b, int c) \\n    {\\n        ll N = (ll)n, A = ll(a), B = ll(b), C = ll(c);\\n        ll lo = 1, hi = 2000000000, mid, ans;\\n        \\n        while(lo <= hi)\\n        {\\n            mid = lo + (hi - lo)/2;\\n            ll cnt = 0;\\n            cnt += mid/A;\\n            cnt += mid/B;\\n            cnt += mid/C;\\n            cnt -= mid / lcm(A, B);\\n            cnt -= mid / lcm(B, C);\\n            cnt -= mid / lcm(C, A);\\n            cnt += mid / lcm(a, lcm(b, c));\\n            \\n            if(cnt >= N)\\n            {\\n                ans = mid;\\n                hi = mid-1;\\n            }\\n            else\\n                lo = mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 723589,
                "title": "python3-inconsistent-definition-of-ugly-numbers",
                "content": "The term \"ugly number\" seems to reflect a poorly-defined concept. Upon Googling it, I can only find it in a few places such as LC, GFG, etc. Even in the few posts on LC, the concept varies. For example, in [263. Ugly Number](https://leetcode.com/problems/ugly-number/), an ugly number is a positive integer whose only factors are 2, 3 and 5, but 1 is treated as an ugly number. This definition is consistent with that of [264. Ugly Number II](https://leetcode.com/problems/ugly-number-ii/). But in [1201. Ugly Number III](https://leetcode.com/problems/ugly-number-iii/), ugly number becomes positive integers divisible by given factors (let\\'s still use 2, 3, 5 unless stated otherwise), and 1 is not considered ugly any more. \\n\\nLet\\'s refer to the definition in 263 and 264 \"Def 1\" and the definition in 1201 \"Def 2\". Under Def 1, the first few ugly numbers are 1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, ... while under Def 2 the first few ugly numbers are 2, 3, 4, 5, 6, 8, 9, 10, 12, 14, 15, ... . The similarity is obvious at first glance. But if you look deeper, a fundamental difference can be revealed. Namely, under Def 1, ugly number is self-generated, i.e. large ugly numbers are generated by multiplying factors with small ugly numbers. Because of this, ugly numbers become rarer as number becomes larger. However, under Def 2, ugly numbers are periodic. The pattern repeats when least common multiple is reached. \\n\\nTo reflect the \"self-generating\" property of ugly number under Def 1, 263 and 264 can be solved using dynamic programming. For example, this [post](https://leetcode.com/problems/ugly-number/discuss/719320/Python3-4-line-concise) and this [post](https://leetcode.com/problems/ugly-number-ii/discuss/720034/Python3-7-line-dp) implement the solution using top-down approach. But 1201 needs to be solved in a completely different way. In the spirit of this difference, I think it is more confusing than helpful to put 1201 in the ugly number series. It is probably clearer if this is treated as a completely independent problem. \\n\\n```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        # inclusion-exclusion principle\\n        ab = a*b//gcd(a, b)\\n        bc = b*c//gcd(b, c)\\n        ca = c*a//gcd(c, a)\\n        abc = ab*c//gcd(ab, c)\\n        \\n        lo, hi = 1, n*min(a, b, c)\\n        while lo < hi: \\n            mid = lo + hi >> 1\\n            if mid//a + mid//b + mid//c - mid//ab - mid//bc - mid//ca + mid//abc < n: lo = mid + 1\\n            else: hi = mid \\n        return lo \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        # inclusion-exclusion principle\\n        ab = a*b//gcd(a, b)\\n        bc = b*c//gcd(b, c)\\n        ca = c*a//gcd(c, a)\\n        abc = ab*c//gcd(ab, c)\\n        \\n        lo, hi = 1, n*min(a, b, c)\\n        while lo < hi: \\n            mid = lo + hi >> 1\\n            if mid//a + mid//b + mid//c - mid//ab - mid//bc - mid//ca + mid//abc < n: lo = mid + 1\\n            else: hi = mid \\n        return lo \\n```",
                "codeTag": "Java"
            },
            {
                "id": 387587,
                "title": "math-binarysearch-solution-java",
                "content": "Calculate how many numbers from 1 to num are divisible by either a, b or c by using the formula: \\n`(num / a) + (num / b) + (num / c) \\u2013 (num / lcm(a, b)) \\u2013 (num / lcm(b, c)) \\u2013 (num / lcm(a, c)) + (num / lcm(a, b, c))`\\n```\\n private long gcd(long a, long b) {\\n        if (a == 0)\\n            return b;\\n\\n        return gcd(b % a, a);\\n    }\\n\\n    private long lcm(long a, long b) {\\n        return (a * b) / gcd(a, b);\\n    }\\n\\n    private int count(long a, long b, long c, long num) {\\n        return (int) ((num / a) + (num / b) + (num / c)\\n                - (num / lcm(a, b))\\n                - (num / lcm(b, c))\\n                - (num / lcm(a, c))\\n                + (num / lcm(a, lcm(b, c)))); // lcm(a,b,c) = lcm(a,lcm(b,c))\\n    }\\n\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        int low = 1, high = Integer.MAX_VALUE, mid;\\n\\n        while (low < high) {\\n            mid = low + (high - low) / 2;\\n\\n            if (count((a), b, c, mid) < n)\\n                low = mid + 1;\\n            else\\n                high = mid;\\n        }\\n\\n        return high;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n private long gcd(long a, long b) {\\n        if (a == 0)\\n            return b;\\n\\n        return gcd(b % a, a);\\n    }\\n\\n    private long lcm(long a, long b) {\\n        return (a * b) / gcd(a, b);\\n    }\\n\\n    private int count(long a, long b, long c, long num) {\\n        return (int) ((num / a) + (num / b) + (num / c)\\n                - (num / lcm(a, b))\\n                - (num / lcm(b, c))\\n                - (num / lcm(a, c))\\n                + (num / lcm(a, lcm(b, c)))); // lcm(a,b,c) = lcm(a,lcm(b,c))\\n    }\\n\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        int low = 1, high = Integer.MAX_VALUE, mid;\\n\\n        while (low < high) {\\n            mid = low + (high - low) / 2;\\n\\n            if (count((a), b, c, mid) < n)\\n                low = mid + 1;\\n            else\\n                high = mid;\\n        }\\n\\n        return high;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 390530,
                "title": "simple-python-binary-search",
                "content": "Please see my solutions for these similar problems.\\n\\nFor these problems, it\\'s relatively easy to solve the subproblem:\\ngiven a specific guess, determine whether it\\'s possible to xxx?\\nFurthermore, the range of guess is limited, and the boolean answer of the above subproblem has the pattern\\nF...FT...T or T..TF...F.\\nThus, we can use binary search to find the minimal/maximal value such that the boolean answer is True.\\n[378. Kth Smallest Element in a Sorted Matrix](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/discuss/1004232/Python-solution-with-thinking-process)\\n[668. Kth Smallest Number in Multiplication Table](https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/discuss/1714072/Simple-Python-Binary-Search-(similar-problem-listed))\\n[410. Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/discuss/326747/Python-solutions-with-thinking-process)\\n[1011. Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/discuss/390359/Simple-Python-Binary-Search)\\n[1231. Divide Chocolate](https://leetcode.com/problems/divide-chocolate/discuss/409956/Simple-Python-Binary-Search-(similar-problem-listed))\\n[875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/discuss/390523/Simple-Python-Binary-Search)\\n[774. Minimize Max Distance to Gas Station](https://leetcode.com/problems/minimize-max-distance-to-gas-station/discuss/390526/Simple-Python-Binary-Search)\\n[1201. Ugly Number III](https://leetcode.com/problems/ugly-number-iii/discuss/390530/Simple-Python-Binary-Search)\\n[1482. Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/discuss/1714075/Simple-Python-Binary-Search-(similar-problem-listed))\\n[1891. Cutting Ribbons](https://leetcode.com/problems/cutting-ribbons/discuss/2361972/Python-Binary-search-solution-(similar-problems-listed))\\n[2141. Maximum Running Time of N Computers](https://leetcode.com/problems/maximum-running-time-of-n-computers/discuss/1698346/Python-Binary-search-solution-(similar-problems-listed))\\n\\n\\nFor every integer A, F(A) = (total number of positive integers <= A which are divisible by a or b or c.).\\nF(A) = A/a + A/b + A/c - A/lcm(a, c) - A/lcm(a, b) - A/lcm(a, c) + A/lcm(a, b, c)(lcm = least common multiple)\\nFind the least integer A that satisfies the condition F(A) == n.\\n\\n```\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        def lcm(x, y):\\n            return x * y // math.gcd(x, y)\\n        \\n        def count_ugly(n, a, b, c, ab, bc, ca, abc):\\n            answer = n // a + n // b + n // c\\n            answer -= n // ab + n // bc + n // ca\\n            answer += n // abc\\n            return answer\\n        \\n        ab, bc, ca = lcm(a, b), lcm(b, c), lcm(c, a)\\n        abc = lcm(ab, c)\\n        low = 1\\n        high = 2 * 10 ** 9\\n        while low < high:\\n            mid = low + (high - low) // 2\\n            if count_ugly(mid, a, b, c, ab, bc, ca, abc) < n:\\n                low = mid + 1\\n            else:\\n                high = mid\\n        return low\\n```",
                "solutionTags": [],
                "code": "```\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        def lcm(x, y):\\n            return x * y // math.gcd(x, y)\\n        \\n        def count_ugly(n, a, b, c, ab, bc, ca, abc):\\n            answer = n // a + n // b + n // c\\n            answer -= n // ab + n // bc + n // ca\\n            answer += n // abc\\n            return answer\\n        \\n        ab, bc, ca = lcm(a, b), lcm(b, c), lcm(c, a)\\n        abc = lcm(ab, c)\\n        low = 1\\n        high = 2 * 10 ** 9\\n        while low < high:\\n            mid = low + (high - low) // 2\\n            if count_ugly(mid, a, b, c, ab, bc, ca, abc) < n:\\n                low = mid + 1\\n            else:\\n                high = mid\\n        return low\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1790736,
                "title": "some-basic-math-we-need-for-this-problem",
                "content": "One of the nice solutions for this problem involves writing a function that counts the number of ugly numbers that are smaller than or equal to a given number, so then we can use binary search to find the *n*th ugly number. I want to talk a bit about the math behind designing a such a function.\\n\\nFor positive integers *a &le; b*, there exist unique integers *q* and *r* such that *b = a &times; q + r*, with *0 &le; r < a*. Note that *q* is the number of multiples of *a* that are smaller than or equal to *b*. Since *r < a*, we can easily compute *q* by doing `q = floor(b / a)`.\\n\\nIn this problem we are interested not only in the multiples of an integer *a*, but in the mutiples of three integers *a*, *b*, and *c*. We want to be careful not to overcount numbers when there is some overlap in the sets of multiples of each. For this purpose we can use **PIE**, the *Principle of Inclusion and Exclusion*. This is a really useful combinatorics technique to count the number of elements in the union of two or more sets.\\n\\n<strong>PIE:</strong> Let *A*, *B*, and *C* be three sets with *n(A)*, *n(B)*, and *n(C)* elements, respectively. Then the number of elements in the union of all three, *A &cup; B &cup; C*, is given by\\n<center><i>\\nn(A &cup; B &cup; C) = n(A) + n(B) + n(C) - n(A &cap; B) - n(A &cap; C) - n(B &cap; C) + n(A &cap; B &cap; C)\\n</i></center>\\n\\n<strong> Proof (ish): </strong> When we add the number of elements of each set in *n(A) + n(B) + n(C)*, since *A &cap; B &#8838; A,  B*, all elements in *A &cap; B* are being counted twice. Similary all elements of *A &cap; C* and *B &cap; C* are being counted twice as well. To remedy this, we subtract *n(A &cap; B) + n(A &cap; C) + n(B &cap; C)*. Now, *n(A &cap; B &cap; C)* was added three times and then subtracted three times, so it is missing. Thus, we add *n(A &cap; B &cap; C)*. &#8718;\\n\\nNote: This result can be easily generalized to count the number of elements in the union of any finite collection of sets.\\n\\nGiven integers *a*,*b*, *c*, and *k*, let *A*, *B*, and *C* be the sets of multiples of *a*, *b*, and *c*, respectively, that are less than or equal to *k*. Then there are exactly *n(A &cup; B &cup; C)* numbers smaller than or equal to *k* that are divisible by *a*, *b*, or *c* (the ugly numbers smaller than or equal to *k*). Since a number is a multiple of *a* and *b* if and only if it is a multiple of *LCM(a, b)*, we have that *n(A &cap; B) =* `floor(k / lcm(a, b))`. Similarly, a number is a multiple of all *a*, *b*, and *c* if and only if it is a multiple of *LCM(a, b, c)*, so *n(A &cap; B &cap; C) =* `floor(k / lcm(a, b, c))`.\\n\\nTherefore, the number of ugly numbers that are less than or equal to *k* is given by\\n```\\nfloor(k / a) + floor(k / b) + floor(k / c) - floor(k / lcm(a, b)) - floor(k / lcm(a, c)) - floor(k / lcm(b, c)) + floor(k / lcm(a, b, c))\\n```\\n\\nSince *a &times; b = LCM(a, b) &times; GCD(a, b)*, and GCD is already available (based on Euclid\\'s algorithm), we can compute the LCM of two numbers as `a * b / gcd(a, b)`.\\n**Careful:** It is not always true that *a &times; b &times; c = LCM(a, b, c) &times; GCD(a, b, c)*. However, it is true that *LCM(a, b, c) = LCM(LCM(a, b), c)*.",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nfloor(k / a) + floor(k / b) + floor(k / c) - floor(k / lcm(a, b)) - floor(k / lcm(a, c)) - floor(k / lcm(b, c)) + floor(k / lcm(a, b, c))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 387673,
                "title": "java-binary-search-solution-with-illustration-explanation-video",
                "content": "<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/Rl4PznQDz3o\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>",
                "solutionTags": [],
                "code": "<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/Rl4PznQDz3o\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 387568,
                "title": "easy-python-binary-search-no-need-to-consider-conner-cases",
                "content": "```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        def lcm(a, b):\\n            return abs(a*b) // math.gcd(a, b)\\n        def count(val,a,b,c):\\n            return val//a + val//b + val//c -val//lcm(a, b)-val//lcm(a, c)-val//lcm(c, b) + val//lcm(lcm(a, b),c)\\n        l = 1\\n        r = min([a,b,c]) * n\\n        tmp = (l+r)//2\\n        while count(tmp,a,b,c) != n-1:\\n            if count(tmp,a,b,c) > n-1:\\n                r = tmp\\n            else:\\n                l = tmp\\n            tmp = (l+r)//2\\n        while count(tmp,a,b,c) != n:\\n            tmp += 1\\n        return tmp\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        def lcm(a, b):\\n            return abs(a*b) // math.gcd(a, b)\\n        def count(val,a,b,c):\\n            return val//a + val//b + val//c -val//lcm(a, b)-val//lcm(a, c)-val//lcm(c, b) + val//lcm(lcm(a, b),c)\\n        l = 1\\n        r = min([a,b,c]) * n\\n        tmp = (l+r)//2\\n        while count(tmp,a,b,c) != n-1:\\n            if count(tmp,a,b,c) > n-1:\\n                r = tmp\\n            else:\\n                l = tmp\\n            tmp = (l+r)//2\\n        while count(tmp,a,b,c) != n:\\n            tmp += 1\\n        return tmp\\n```",
                "codeTag": "Java"
            },
            {
                "id": 843224,
                "title": "my-java-solution-binary-search",
                "content": "The main note to remind in this problem is:\\nn(AUBUC) = n(A)+n(B)+n(C)-n(A\\u2229B)-n(A\\u2229C)-n(B\\u2229C)+n(A\\u2229B\\u2229C)\\n\\nnumber / lcm(a, b) is equivalent ot n(A\\u2229B)........\\n\\nI was stuck to get this equation and the template about binary search helped me with this idea.\\nhttps://leetcode.com/discuss/general-discussion/786126/python-powerful-ultimate-binary-search-template-solved-many-problems\\n\\n```\\nclass Solution {\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        int left = 1;\\n        int right = Integer.MAX_VALUE;\\n        int count = 0;\\n        while (left < right) {\\n            int middle = left + (right - left) / 2;\\n            if (isUgly(middle, a, b, c, n)) {\\n                right = middle;\\n            }\\n            else\\n                left = middle + 1;\\n        }\\n        return left;\\n    }\\n    public boolean isUgly(long middle, long a, long b, long c, long n) {\\n        return (int) (middle/a + middle/b + middle/c - middle/lcm(a, b) - middle/lcm(b, c) - middle/lcm(c, a) + middle/lcm(a, lcm(b, c))) >= n;\\n    }\\n    public long gcd(long a, long b) {\\n        if (a == 0)\\n            return b;\\n        else return gcd(b%a, a);\\n    }\\n    public long lcm(long a, long b) {\\n        return a * b / (gcd(a, b)); \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        int left = 1;\\n        int right = Integer.MAX_VALUE;\\n        int count = 0;\\n        while (left < right) {\\n            int middle = left + (right - left) / 2;\\n            if (isUgly(middle, a, b, c, n)) {\\n                right = middle;\\n            }\\n            else\\n                left = middle + 1;\\n        }\\n        return left;\\n    }\\n    public boolean isUgly(long middle, long a, long b, long c, long n) {\\n        return (int) (middle/a + middle/b + middle/c - middle/lcm(a, b) - middle/lcm(b, c) - middle/lcm(c, a) + middle/lcm(a, lcm(b, c))) >= n;\\n    }\\n    public long gcd(long a, long b) {\\n        if (a == 0)\\n            return b;\\n        else return gcd(b%a, a);\\n    }\\n    public long lcm(long a, long b) {\\n        return a * b / (gcd(a, b)); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 569006,
                "title": "c-explaination-with-code-100-time-and-space",
                "content": "There are three numbers a, b and c.\\nNow Suppose all multiples of a are represented by set A, B represents same for b and C does for c;\\nNow it is possible that one or more members of set A are present in B(i.e. A \\u2229 B) and some menbers are present C(A\\u2229C).\\nSimilarly for B and C some member(B\\u2229C) and some are present in all 3 (A\\u2229B\\u2229C). \\nNow we aim to find the lowest number for which A U B U C (i.e. with no repetition) = n. This lowest number represents the nth number. \\nUsing set theory, \\n\\tA U B U C = A + B + C - A\\u2229B - B\\u2229C - A\\u2229C + A\\u2229B\\u2229C\\n\\nWe use lcm of the numbers to find the number of multiples for that set i.e. A = m/A, B\\u2229C = M / LCM(B,C). We can find lcm using LCM (A,B) = A*B / GCD(A,B).\\n\\nWe use Binary Search technique to find the lowest number.\\nlowerBound = 2, upperBound =1e18\\n```\\n\\n#define lli long long int\\n#define mod 1e9 + 7\\nclass Solution {\\n    int gcd(lli a, lli b){\\n        if(a<b)\\n            return gcd(b,a);\\n        if(b==0)\\n            return a;\\n        return gcd(b, a%b);\\n    }\\n    \\npublic:\\n    int nthUglyNumber(int n, lli a, lli b, lli c) {\\n        lli lAB = (a*b)/gcd(a,b);\\n        lli lBC = (b*c)/gcd(b,c);\\n        lli lAC = (a*c)/gcd(a,c); \\n        lli lABC = lAB*c/gcd(lAB, c);\\n        lli l = 2;\\n        lli r = 1e18;\\n        while(l<r){\\n            lli m = (l+r)/2;\\n            if(m/a + m/b + m/c + m/lABC -m/lAB -m/lBC -m/lAC < n)\\n                l = m+1;\\n            else\\n                r = m;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\n#define lli long long int\\n#define mod 1e9 + 7\\nclass Solution {\\n    int gcd(lli a, lli b){\\n        if(a<b)\\n            return gcd(b,a);\\n        if(b==0)\\n            return a;\\n        return gcd(b, a%b);\\n    }\\n    \\npublic:\\n    int nthUglyNumber(int n, lli a, lli b, lli c) {\\n        lli lAB = (a*b)/gcd(a,b);\\n        lli lBC = (b*c)/gcd(b,c);\\n        lli lAC = (a*c)/gcd(a,c); \\n        lli lABC = lAB*c/gcd(lAB, c);\\n        lli l = 2;\\n        lli r = 1e18;\\n        while(l<r){\\n            lli m = (l+r)/2;\\n            if(m/a + m/b + m/c + m/lABC -m/lAB -m/lBC -m/lAC < n)\\n                l = m+1;\\n            else\\n                r = m;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 514893,
                "title": "python-sol-by-binary-search-and-set-theory-80-with-hint-and-comment",
                "content": "Python sol. by **binary-search** and **set-theory**.\\n\\n---\\n\\n**Hint**:\\n\\n#1.\\nThink of **multiple counting** and **set theory**\\n\\nBy **set theory**, we can know **total number of multiples** in within given range within positive integer *k*.\\n\\n---\\n\\nTake *a*, *b*, *c* = 2, 3, 5, *k*=50 for example\\n\\nTotal number of multiple on *a*=2, *b*=3, *c*=5, from 1 to k = 50\\n\\n= ( k // 2 + k // 3 + k // 5 ) - ( k // lcm(2,3) - k // lcm(2, 5) - k // lcm(3, 5) ) + k // lcm( 2, 3, 5 )\\n\\n= 50 // 2 + 50 // 3 + 50 // 5 - 50 // 6 - 50 // 10 - 50 // 15 + 50 // 30\\n\\n= #Mutiple of 2 + #Multiple of 3 + #Multiple of 5 - #Multiple of 6 - #Multiple of 10 - #Multiple of 15+ #Multiple of 30\\n\\n= 25 + 16 + 10 - 8 - 5 - 3 + 1\\n\\n= 36 = **n**\\n\\nTherefore, we can say k=50 is the n = 36th ug1y number of 2, 3, 5.\\n\\n---\\n\\n#2.\\nThink of the **framework of Binary search**.\\n\\nUse **binary search** to compute the **smallest k** such that there are **n multiples of a, b, c**.\\nThat also means, k is the nth u-number of a, b, c.\\n\\n---\\n\\n**Implementation**:\\n\\n```\\nfrom math import gcd\\n\\nclass Solution:\\n    \\n\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n\\n        \\n        def lcm( x, y):\\n            \\n            # From number theory,\\n            # gcd(x,y) * lcm(x,y) = x * y\\n            \\n            return  x * y  // gcd(x,y)        \\n        \\n        # -----------------------------------\\n        \\n        def total_num_of_multiples( number, a, b, c):\\n            \\n            # From set theory,\\n            # count the total number of mutiples of a, b, c, range from 1 to number.\\n            ab = lcm(a,b)\\n            bc = lcm(b,c)\\n            ac = lcm(a,c)\\n\\n            abc = lcm(a, bc)\\n\\n            result = number // a + number // b + number // c \\n            result -= number // ab + number // bc + number // ac\\n            result += number // abc\\n\\n            return result        \\n        \\n        # -----------------------------------\\n        \\n        # Goal:\\n        # Find the smallest number k, such that k has n multiples of a, b, or c.\\n        \\n        # Binary search approach\\n        lower = 1\\n        upper = 2 * (10 ** 9)\\n        \\n        while lower < upper:\\n            \\n            mid = lower + (upper - lower) // 2\\n            \\n            count_of_u_number = total_num_of_multiples(mid, a, b, c)\\n\\n            if count_of_u_number >= n:\\n                upper = mid\\n                \\n            else:\\n                lower = mid+1\\n            \\n        return lower\\n        \\n```\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[Leetcode #263 Ugly Number](https://leetcode.com/problems/ugly-number)\\n\\n[Leetcode #264 Ugly Number II](https://leetcode.com/problems/ugly-number-ii)\\n\\n[Leetcode #313 Super Ugly Number](https://leetcode.com/problems/super-ugly-number/)\\n\\n\\n---\\n\\nReference:\\n\\n[1] [GfG: Count of Multiples of A ,B or C less than or equal to N](https://www.geeksforgeeks.org/count-of-multiples-of-a-b-or-c-less-than-or-equal-to-n/)",
                "solutionTags": [
                    "Python",
                    "Math",
                    "Binary Tree"
                ],
                "code": "```\\nfrom math import gcd\\n\\nclass Solution:\\n    \\n\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n\\n        \\n        def lcm( x, y):\\n            \\n            # From number theory,\\n            # gcd(x,y) * lcm(x,y) = x * y\\n            \\n            return  x * y  // gcd(x,y)        \\n        \\n        # -----------------------------------\\n        \\n        def total_num_of_multiples( number, a, b, c):\\n            \\n            # From set theory,\\n            # count the total number of mutiples of a, b, c, range from 1 to number.\\n            ab = lcm(a,b)\\n            bc = lcm(b,c)\\n            ac = lcm(a,c)\\n\\n            abc = lcm(a, bc)\\n\\n            result = number // a + number // b + number // c \\n            result -= number // ab + number // bc + number // ac\\n            result += number // abc\\n\\n            return result        \\n        \\n        # -----------------------------------\\n        \\n        # Goal:\\n        # Find the smallest number k, such that k has n multiples of a, b, or c.\\n        \\n        # Binary search approach\\n        lower = 1\\n        upper = 2 * (10 ** 9)\\n        \\n        while lower < upper:\\n            \\n            mid = lower + (upper - lower) // 2\\n            \\n            count_of_u_number = total_num_of_multiples(mid, a, b, c)\\n\\n            if count_of_u_number >= n:\\n                upper = mid\\n                \\n            else:\\n                lower = mid+1\\n            \\n        return lower\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 387582,
                "title": "1ms-java-binary-search",
                "content": "https://www.geeksforgeeks.org/find-the-nth-term-divisible-by-a-or-b-or-c/\\nto understand it better read this post of GFG\\n\\nOur range ~ 10^9\\nso replace int to long \\n\\n```\\npublic static int nthUglyNumber(int n, int a, int b, int c) {\\n        int low = 1, high = Integer.MAX_VALUE, mid;\\n\\n        while (low < high) {\\n            mid = low + (high - low) / 2;\\n            if (divTermCount(a, b, c, mid) < n)\\n                low = mid + 1;\\n            else\\n                high = mid;\\n        }\\n        return low;\\n    }\\n\\n    static long gcd(long a, long b) {\\n        if (a == 0)\\n            return b;\\n        return gcd(b % a, a);\\n    }\\n\\n    static long lcm(long a, long b) {\\n        return (a * b) / gcd(a, b);\\n    }\\n\\n    static long divTermCount(long a, long b, long c, long num) {\\n        return ((num / a) + (num / b) + (num / c)\\n                - (num / lcm(a, b))\\n                - (num / lcm(b, c))\\n                - (num / lcm(a, c))\\n                + (num / lcm(a, lcm(b, c))));\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\npublic static int nthUglyNumber(int n, int a, int b, int c) {\\n        int low = 1, high = Integer.MAX_VALUE, mid;\\n\\n        while (low < high) {\\n            mid = low + (high - low) / 2;\\n            if (divTermCount(a, b, c, mid) < n)\\n                low = mid + 1;\\n            else\\n                high = mid;\\n        }\\n        return low;\\n    }\\n\\n    static long gcd(long a, long b) {\\n        if (a == 0)\\n            return b;\\n        return gcd(b % a, a);\\n    }\\n\\n    static long lcm(long a, long b) {\\n        return (a * b) / gcd(a, b);\\n    }\\n\\n    static long divTermCount(long a, long b, long c, long num) {\\n        return ((num / a) + (num / b) + (num / c)\\n                - (num / lcm(a, b))\\n                - (num / lcm(b, c))\\n                - (num / lcm(a, c))\\n                + (num / lcm(a, lcm(b, c))));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 388652,
                "title": "clear-python-solution",
                "content": "```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        def gcd(a,b):\\n            return a if b == 0 else gcd(b,a%b)\\n            \\n        def lcm(a,b):\\n            return a*b//gcd(a,b)\\n        \\n        def count(n,a,b,c):\\n            # count ugly number n\\'s position\\n            return n//a + n//b + n//c - n//lcm(a,b) - n//lcm(a,c) - n//lcm(b,c) + n//lcm(lcm(a,b),c)\\n        \\n        l = 1\\n        r = n*min(a,b,c)\\n        while l<r:\\n            mid = (l+r)//2\\n            if count(mid,a,b,c) < n:\\n                l = mid + 1\\n            else:\\n                r = mid\\n        \\n        return r\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        def gcd(a,b):\\n            return a if b == 0 else gcd(b,a%b)\\n            \\n        def lcm(a,b):\\n            return a*b//gcd(a,b)\\n        \\n        def count(n,a,b,c):\\n            # count ugly number n\\'s position\\n            return n//a + n//b + n//c - n//lcm(a,b) - n//lcm(a,c) - n//lcm(b,c) + n//lcm(lcm(a,b),c)\\n        \\n        l = 1\\n        r = n*min(a,b,c)\\n        while l<r:\\n            mid = (l+r)//2\\n            if count(mid,a,b,c) < n:\\n                l = mid + 1\\n            else:\\n                r = mid\\n        \\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 387526,
                "title": "python-binary-search-o-log-n",
                "content": "```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        # basic function for LCM\\n        import math\\n        def lcm(x, y):\\n            return (x * y) // math.gcd(x, y)\\n\\n        lcm1 = lcm(a, b)\\n        lcm2 = lcm(b, c)\\n        lcm3 = lcm(c, a)\\n        lcm4 = lcm(lcm1, lcm2)\\n\\n        # count how many ugly numbers exist below x\\n        def count_below(x):\\n            return x // a + x // b + x // c + x // lcm4 - (x // lcm1 + x // lcm2 + x // lcm3)\\n\\n        # binary search\\n        lb = 0\\n        ub = 2 * 10 ** 9\\n        while (ub - lb > 1):\\n            mid = (lb + ub) // 2\\n            if count_below(mid) >= n:\\n                ub = mid\\n            else:\\n                lb = mid\\n\\n        return ub\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        # basic function for LCM\\n        import math\\n        def lcm(x, y):\\n            return (x * y) // math.gcd(x, y)\\n\\n        lcm1 = lcm(a, b)\\n        lcm2 = lcm(b, c)\\n        lcm3 = lcm(c, a)\\n        lcm4 = lcm(lcm1, lcm2)\\n\\n        # count how many ugly numbers exist below x\\n        def count_below(x):\\n            return x // a + x // b + x // c + x // lcm4 - (x // lcm1 + x // lcm2 + x // lcm3)\\n\\n        # binary search\\n        lb = 0\\n        ub = 2 * 10 ** 9\\n        while (ub - lb > 1):\\n            mid = (lb + ub) // 2\\n            if count_below(mid) >= n:\\n                ub = mid\\n            else:\\n                lb = mid\\n\\n        return ub\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2867599,
                "title": "100-faster-binary-search-easy-understand-c-solution",
                "content": "```\\ntypedef long long ll;\\n#define MAX_ANS 2e9 \\n\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int left = 0, right = MAX_ANS, result = 0;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (count(mid, a, b, c) >= n) { \\n                result = mid;\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return result;\\n    }\\n    int count(ll num, ll a, ll b, ll c) {\\n        return (int)(num / a + num / b + num / c\\n            - num / lcm(a, b)\\n            - num / lcm(b, c)\\n            - num / lcm(a, c)\\n            + num / (lcm(a, lcm(b, c))));\\n    }\\n    ll gcd(ll a, ll b) {\\n        if (a == 0) return b;\\n        return gcd(b % a, a);\\n    }\\n    ll lcm(ll a, ll b) {\\n        return a * b / gcd(a, b);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\ntypedef long long ll;\\n#define MAX_ANS 2e9 \\n\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int left = 0, right = MAX_ANS, result = 0;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (count(mid, a, b, c) >= n) { \\n                result = mid;\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return result;\\n    }\\n    int count(ll num, ll a, ll b, ll c) {\\n        return (int)(num / a + num / b + num / c\\n            - num / lcm(a, b)\\n            - num / lcm(b, c)\\n            - num / lcm(a, c)\\n            + num / (lcm(a, lcm(b, c))));\\n    }\\n    ll gcd(ll a, ll b) {\\n        if (a == 0) return b;\\n        return gcd(b % a, a);\\n    }\\n    ll lcm(ll a, ll b) {\\n        return a * b / gcd(a, b);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2012626,
                "title": "java-binary-search-w-gcd-lcm",
                "content": "The total area of this graph is `A + B + C - AB - AC - BC + ABC`, and that\\'s what we will use to solve this problem. \\nFor example, A = 3, B = 5, C = 2, then 6 belong to AC, and 30 belong to ABC.\\n\\nBe careful about overflowing.\\n\\n![image](https://assets.leetcode.com/users/images/3874e36d-da07-4a95-bfa7-84e1f92d3428_1651814281.0619926.png)\\n\\n\\n```Java\\nclass Solution {\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        int lo = 1, hi = (int)2e9;\\n        long ab = lcm(a, b), ac = lcm(a, c), bc = lcm(b, c), abc = lcm(ab, c);\\n        while(lo < hi){\\n            int mid = lo + (hi - lo)/2;\\n            long count = 0L + mid / a + mid / b + mid / c - mid / ab - mid / ac - mid / bc + mid / abc;\\n            if (count >= n)\\n                hi = mid;\\n            else\\n                lo = mid + 1;\\n        }\\n        return lo;\\n    }\\n\\n    private long gcd(long a, long b){\\n        return b == 0? a : gcd(b, a % b);\\n    }\\n\\n    private long lcm(long a, long b){\\n        return a * b / gcd(a, b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        int lo = 1, hi = (int)2e9;\\n        long ab = lcm(a, b), ac = lcm(a, c), bc = lcm(b, c), abc = lcm(ab, c);\\n        while(lo < hi){\\n            int mid = lo + (hi - lo)/2;\\n            long count = 0L + mid / a + mid / b + mid / c - mid / ab - mid / ac - mid / bc + mid / abc;\\n            if (count >= n)\\n                hi = mid;\\n            else\\n                lo = mid + 1;\\n        }\\n        return lo;\\n    }\\n\\n    private long gcd(long a, long b){\\n        return b == 0? a : gcd(b, a % b);\\n    }\\n\\n    private long lcm(long a, long b){\\n        return a * b / gcd(a, b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1828662,
                "title": "1201-ugly-number-iii",
                "content": "### ***ALERTT\\n### FIRST SEE THE LOG![image](https://assets.leetcode.com/users/images/62337ea0-5bb9-4c8f-a25f-6f2e51083c9c_1646671980.7753525.jpeg)\\nIC THEN GO TO CODE \\n### PLZZZ LIKE IT*\\n```\\nclass Solution {\\npublic:\\n        using ll=long long int;\\n        ll lcm(ll a,ll b)\\n        {\\n                return (a*b)/(__gcd(a,b));\\n        }\\n        ll solve(ll a,ll b, ll c,ll mid)\\n        {\\n                return (mid/a)+(mid/b)+(mid/c)-(mid/lcm(a,b))-(mid/lcm(a,c))-(mid/lcm(b,c))+(mid/(lcm(a,lcm(b,c))));\\n        }\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        ll start=min({a,b,c});\\n            ll end=INT_MAX;\\n            ll ans;\\n            while(start<=end)\\n            {\\n                    ll mid=start+(end-start)/2;\\n                    if(solve(a,b,c,mid)<n)\\n                    {\\n                            start=mid+1;\\n                    }\\n                    else\\n                    {\\n                            ans=mid;\\n                            end=mid-1;\\n                    }\\n            }\\n            return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        using ll=long long int;\\n        ll lcm(ll a,ll b)\\n        {\\n                return (a*b)/(__gcd(a,b));\\n        }\\n        ll solve(ll a,ll b, ll c,ll mid)\\n        {\\n                return (mid/a)+(mid/b)+(mid/c)-(mid/lcm(a,b))-(mid/lcm(a,c))-(mid/lcm(b,c))+(mid/(lcm(a,lcm(b,c))));\\n        }\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        ll start=min({a,b,c});\\n            ll end=INT_MAX;\\n            ll ans;\\n            while(start<=end)\\n            {\\n                    ll mid=start+(end-start)/2;\\n                    if(solve(a,b,c,mid)<n)\\n                    {\\n                            start=mid+1;\\n                    }\\n                    else\\n                    {\\n                            ans=mid;\\n                            end=mid-1;\\n                    }\\n            }\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 742578,
                "title": "java-o-n-vs-binary-search-o-lgn",
                "content": "Version 1, brutal force, O(N), TLE\\nActually I gave this version while my FB phone screen and passed the interview. \\nI don\\'t think it is a bad solution, though.\\nIt is concise, clean and straightforward.\\n```\\n        int am = 1, bm = 1, cm = 1, cnt = 0, min = 1;\\n        while (cnt++ < n) {\\n            int an = am * a, bn = bm * b, cn = cm * c;\\n            min = Math.min(an, Math.min(bn, cn));\\n            if (an == min) am++;\\n            if (bn == min) bm++;\\n            if (cn == min) cm++;\\n        }\\n        return min;\\n```\\n\\nversion 2 \\nBinary Search O(lgN);\\nref https://leetcode.com/problems/ugly-number-iii/discuss/387539/cpp-Binary-Search-with-picture-and-Binary-Search-Template\\n```\\nclass Solution {\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        long l = 0, r = 2_000_000_000, res = 0;\\n        long ab = lcm((long) a, (long) b), ac = lcm((long) a, (long) c), bc = lcm((long) b, (long) c), abc = lcm(a, bc);\\n        while (l < r) {\\n            long mid = l + (r - l) / 2;\\n            if (count(mid, a, b, c, ab, ac, bc, abc) < n) l = mid + 1;\\n            else r = mid;\\n        }\\n        return (int) l;\\n    }\\n    \\n    private long count(long num, int a, int b, int c, long ab, long ac, long bc, long abc) {\\n        return num / a + num / b + num / c \\n            - num / ab - num /ac - num / bc\\n            + num / abc;\\n    } \\n    \\n    private long lcm(long a, long b) {\\n        return a * b / gcd(a, b);\\n    }\\n    \\n    private long gcd(long a, long b) {\\n        if (a < b) return gcd(b, a);\\n        while (b > 0) {\\n            long tmp = a % b;\\n            a = b;\\n            b = tmp;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n        int am = 1, bm = 1, cm = 1, cnt = 0, min = 1;\\n        while (cnt++ < n) {\\n            int an = am * a, bn = bm * b, cn = cm * c;\\n            min = Math.min(an, Math.min(bn, cn));\\n            if (an == min) am++;\\n            if (bn == min) bm++;\\n            if (cn == min) cm++;\\n        }\\n        return min;\\n```\n```\\nclass Solution {\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        long l = 0, r = 2_000_000_000, res = 0;\\n        long ab = lcm((long) a, (long) b), ac = lcm((long) a, (long) c), bc = lcm((long) b, (long) c), abc = lcm(a, bc);\\n        while (l < r) {\\n            long mid = l + (r - l) / 2;\\n            if (count(mid, a, b, c, ab, ac, bc, abc) < n) l = mid + 1;\\n            else r = mid;\\n        }\\n        return (int) l;\\n    }\\n    \\n    private long count(long num, int a, int b, int c, long ab, long ac, long bc, long abc) {\\n        return num / a + num / b + num / c \\n            - num / ab - num /ac - num / bc\\n            + num / abc;\\n    } \\n    \\n    private long lcm(long a, long b) {\\n        return a * b / gcd(a, b);\\n    }\\n    \\n    private long gcd(long a, long b) {\\n        if (a < b) return gcd(b, a);\\n        while (b > 0) {\\n            long tmp = a % b;\\n            a = b;\\n            b = tmp;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 696041,
                "title": "python-binary-search-and-math-with-detailed-explanation-and-complexity",
                "content": "The idea is, we search for the smallest K such that the number of numbers divisible by a or b or c in [1, K] is exactly N.\\nWe know the number of numbers divisible by x in [1, K] is K div x (or K // x, in Python).\\nThe number of numbers divisible by a or b or c in [1, K]:\\n= #(divisible by a) + #(divisible by b) + #(divisible by c) - #(divisible by a, b) - #(divisible by (b, c)) - #(divisible by a, c) + #(divisible by a, b, c)\\n= (K//a + K// b + K//c) - (K//lcm(a,b) + K//lcm(b, c) + K//lcm(c, a)) + K//lcm(a, b, c)\\n\\nwhere lcm is lowest common multiplier of the inside numeric arguments.\\nTime Complexity: Note that the time complexity of computing lcm or gcd is O(log N). Thus, the overall time complexity is O((logN)^2)\\n```\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        def lcm(a, b):\\n            prod = a*b\\n            if a < b:\\n                a, b = b, a\\n            while b > 0:\\n                a = a % b\\n                a, b = b, a\\n            return prod//a\\n        def count(k):\\n            #how many numbers divisible by a or b or c in [1, k]\\n            na = k // a\\n            nb = k // b\\n            nc = k // c\\n            nab = k // lcm(a, b)\\n            nac = k // lcm(a, c)\\n            nbc = k // lcm(b, c)\\n            nabc = k // lcm(lcm(a, b), c)\\n            return na + nb + nc - nab - nac - nbc + nabc\\n        l, r = 0, 2*10**9\\n        while l <= r:\\n            mid = l + (r - l)//2\\n            if count(mid) >= n:\\n                if count(mid) == n and (mid % a == 0 or mid % b == 0 or mid % c == 0):\\n                    return mid\\n                r = mid - 1\\n            else:\\n                l = mid + 1\\n        return l\\n```",
                "solutionTags": [],
                "code": "```\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        def lcm(a, b):\\n            prod = a*b\\n            if a < b:\\n                a, b = b, a\\n            while b > 0:\\n                a = a % b\\n                a, b = b, a\\n            return prod//a\\n        def count(k):\\n            #how many numbers divisible by a or b or c in [1, k]\\n            na = k // a\\n            nb = k // b\\n            nc = k // c\\n            nab = k // lcm(a, b)\\n            nac = k // lcm(a, c)\\n            nbc = k // lcm(b, c)\\n            nabc = k // lcm(lcm(a, b), c)\\n            return na + nb + nc - nab - nac - nbc + nabc\\n        l, r = 0, 2*10**9\\n        while l <= r:\\n            mid = l + (r - l)//2\\n            if count(mid) >= n:\\n                if count(mid) == n and (mid % a == 0 or mid % b == 0 or mid % c == 0):\\n                    return mid\\n                r = mid - 1\\n            else:\\n                l = mid + 1\\n        return l\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 388429,
                "title": "wrong-test-case",
                "content": "Run the last given case in the description:\\n```\\n1000000000\\n2\\n217983653\\n336916467\\n```\\nThe expected answer is `1999999984`, which is the same as in the description.\\n\\nBut when run this case, moving `2` to the last line, switching `a`,`b`,`c`:\\n```\\n1000000000\\n217983653\\n336916467\\n2\\n```\\nThe expected answer becomes `1999999982`, which is wrong.",
                "solutionTags": [],
                "code": "```\\n1000000000\\n2\\n217983653\\n336916467\\n```\n```\\n1000000000\\n217983653\\n336916467\\n2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3274620,
                "title": "math",
                "content": "Here we count the occurence of number which are multiple of a,b,c which are less than equal to val. \\nThe main principle used here is\\n> **The principle of inclusion and exclusion (PIE)** is a counting technique that computes the number of elements that satisfy at least one of several properties while guaranteeing that elements satisfying more than one property are not counted twice.\\n\\nAn underlying idea behind PIE is that summing the number of elements that satisfy at least one of two categories and subtracting the overlap prevents double counting.\\n\\nSimple Formula is $$ n(A \\u222A B \\u222A C) = n(A) + n(B) + n(C) - n(A \\u2229 B) - n(A \\u2229 C) - n(B \\u2229 C) + n(A \\u2229 B \\u2229 C) $$\\n\\nIt is visually easy to prove this point (See the image ) - \\n![Screenshot_20230309_094721.png](https://assets.leetcode.com/users/images/1149e415-5fd7-40fb-9fc8-f6df083f91d7_1678335798.192373.png)\\n\\nA+B+C = (a+d+g+f) + (d+b+g+e) + (f+g+e+c) - (d+g) - (f+g) - (g+e) + (g)\\n\\nHere we have to add common part of A,B,C (i.e g) because g is added 3 times and is also subtracted 3 times \\n\\n>Tip: LCM(a,b) = GCD(a,b) / (a*b) is True but it is not guranteed that\\nLCM(a,b,c) = GCD(a,b,c) / (a*b*c). But it is guranteed that LCM(a,b,c)=LCM(a, LCM(b,c) ) !!\\n\\n# Code\\n```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        low = min(a,b,c)\\n        high = 2*10**9\\n\\n        def feasible(val):\\n            result = val//a + val//b + val//c - val//lcm(a,b) - val//lcm(b,c) - val//lcm(a,c) + val//lcm(a,b,c)\\n            return result>=n\\n        \\n        while low<high:\\n            mid = low+high>>1\\n            if feasible(mid):\\n                high = mid\\n            else:\\n                low= mid+1\\n        return low\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        low = min(a,b,c)\\n        high = 2*10**9\\n\\n        def feasible(val):\\n            result = val//a + val//b + val//c - val//lcm(a,b) - val//lcm(b,c) - val//lcm(a,c) + val//lcm(a,b,c)\\n            return result>=n\\n        \\n        while low<high:\\n            mid = low+high>>1\\n            if feasible(mid):\\n                high = mid\\n            else:\\n                low= mid+1\\n        return low\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2443538,
                "title": "an-important-pitfall-that-most-of-the-posts-didn-t-mention",
                "content": "Most posts didn\\'t cover why we can not simply return the value when that matched to n, which is an important part we need to clarify during an interview.\\n\\nThe answer is that the binary search can pass non-ugly numbers when calculating the current value\\'s ranking. \\nJust because we found the nth number doesn\\'t mean it\\'s a valid answer.\\n\\nI hope the following code will help to understand the detail of the exit condition.\\n\\n\\n```\\nfrom math import lcm\\n\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n\\n        def ranking_of(value): \\n\\t\\t# Input value can be a non-ugly number.\\n\\t\\t# In that case, this can return the same value toward different inputs due to its floor div operations.\\n\\t\\t# i.e. Smallest input that provides the same answer is the valid number.\\n            return (value // a) + (value // b) + (value // c) - (value // lcm(a, b)) - (value // lcm(b, c)) - (value // lcm(c, a)) + (value // lcm(a, b, c))\\n        \\n  \\n        l = 1\\n        r = 2 * (10 ** 9)\\n        \\n        smallest_satisifed = None\\n        while l <= r:\\n            value = (l + r) // 2\\n            rank = ranking_of(value)\\n            if rank < n:\\n                l = value + 1\\n            else: # rank >= n\\n                # We can not return the rank immediately when we face n == rank, since the value provoded this binary search can be a \"non-ugly\" number. \\n                smallest_satisifed = value\\n                r = value - 1\\n        return smallest_satisifed\\n```\\n",
                "solutionTags": [],
                "code": "```\\nfrom math import lcm\\n\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n\\n        def ranking_of(value): \\n\\t\\t# Input value can be a non-ugly number.\\n\\t\\t# In that case, this can return the same value toward different inputs due to its floor div operations.\\n\\t\\t# i.e. Smallest input that provides the same answer is the valid number.\\n            return (value // a) + (value // b) + (value // c) - (value // lcm(a, b)) - (value // lcm(b, c)) - (value // lcm(c, a)) + (value // lcm(a, b, c))\\n        \\n  \\n        l = 1\\n        r = 2 * (10 ** 9)\\n        \\n        smallest_satisifed = None\\n        while l <= r:\\n            value = (l + r) // 2\\n            rank = ranking_of(value)\\n            if rank < n:\\n                l = value + 1\\n            else: # rank >= n\\n                # We can not return the rank immediately when we face n == rank, since the value provoded this binary search can be a \"non-ugly\" number. \\n                smallest_satisifed = value\\n                r = value - 1\\n        return smallest_satisifed\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2299901,
                "title": "python-brute-force-to-optimzied-sol-full-detailed-explanation",
                "content": "\\n# EXPLANATION BRUTE FORCE\\n```\\nBrute force is trying each number from 1 untill we get our nth ugly number\\nNow we can improve this approach by using the idea that we need to get the nth ugly number which is divisible  by a,b,or c\\n\\nSo we make a list of size 3 \"times = [1,1,1]\" having all values as 1 indicating the current number \\nusing number a,b,c, respectively\\n\\nNow we find the smallest number  which will be minimum of \\n( times[0] * a, times[1] * b , times[c] * c )\\n\\nTHE smallest one can also occur by more than 1 source that is 2,3 may collide at 6\\nso we traverse the list and compare the smallest with times[0]*a , times[1]*b and times[2]*c and if smallest is equal to it we increment times[i] by 1 making the number its next occurence\\n\\n```\\n\\n\\n# CODE ( UNOPTIMIZED / BRUTE FORCE + )\\n```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        times = [1,1,1]\\n        smallest = inf\\n        while n != 0:\\n            smallest = min ( times[0]*a,times[1]*b,times[2]*c)\\n            if times[0]*a == smallest: times[0] += 1\\n            if times[1]*b == smallest: times[1] += 1\\n            if times[2]*c == smallest: times[2] += 1\\n            n -= 1\\n        return smallest\\n```\\n\\n# EXPLANATION BINARY SEARCH + VENN DIAGRAM\\n![image](https://assets.leetcode.com/users/images/67651342-d4fc-4076-8c46-27fc7f840b35_1658155062.1077657.png)\\n\\na \\u2229 b \\u2229 c = a \\u222A b + a \\u222A c + b \\u222A c - a \\u2229 b - a \\u2229 c - b \\u2229 c + a \\u2229 b \\u2229 c\\n\\n```\\nLets say we have a = 2 , b = 3, c  = 5 , n = 10\\nNow the number must lie between the first occurence = min(a,b,c) i.e. 2\\nand the n th occurence in case of no collision = min(a,b,c) * n i.e. 20\\nas 2 , 4, 6 , 8 ,10 ,12 , 14 , 16 18 ,20 will lead to 10th ugly number is b,c do not collide\\n\\nNow since we know the range ... how can we decide to choose the left half or the right half\\n... The main logic of binary search\\n\\nSee if we get to know the count of ugly numbers till mid we can decide which way to walk\\n\\nSO the question is how to find the count\\n\\n\\nSay numbers a = 2 , b = 3 , c = 5 , n = 10\\nlow = 2\\nhigh = 20\\nmid = 11\\n\\nNow we need to find the count of ugly numbers till 11........\\nremember the formula\\na \\u2229 b \\u2229 c = a \\u222A b + a \\u222A c + b \\u222A c - a \\u2229 b - a \\u2229 c - b \\u2229 c + a \\u2229 b \\u2229 c\\n\\nhow many 2s will occur till 11 = 11 // 2 = 5 ( 2,4,6,8,10)\\nhow many 3s will occur till 11 = 11 // 3 = 3 ( 3,6,9)\\nhow many 5s will occur till 11 = 11 // 5 = 2 ( 5,10)\\nnow 2,3 may collide so we count them as\\n11 // (lcm 2,3) = 11 // 6 = 1 (6)\\nnow 2,5 may collide so we count them as\\n11 // (lcm 2,5) = 11 // 10 = 1(10)\\nnow 3,5 may collide so we count them as\\n11 // (lcm 3,5) = 11 // 15  = 0 \\nnow we may have count collision of (2,3) and (2,5) but it should be counted once as (2,3,5)\\nso we have to add 11 // (lcm 2,3,5) = 11// 30 = 0\\n\\nSo according to our formula total count  = 5 + 3 + 2 - 1 - 1 - 0 + 0  =  8\\n(2,4,6,8,10) + ( 3,6,9) + (5,10) - (6) - (10) - ( )  + ( ) =  (2,3,4,5,6,8,9,10)\\n\\nNow since the count is 8 and we need 10th ugly number we should go right\\n\\n\\n\\n\\nTO GET LCM of two numbers:\\n\\tLCM(a,b) * HCF(a,b)   =  a*b\\n\\t\\nTO GET LCM of three numbers:\\n\\tLCM(a,b,c) = a*b*c*HCF(a,b,c) //  HCF(a,b) * HCF(b,c) * HCF(a,c)\\n```\\n# CODE ( BINARY SEARCH )\\n```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        a,b,c = sorted((a,b,c))\\n        ans = inf\\n        def hcf(a,b):\\n            if a %b == 0: return b\\n            return hcf(b , a % b)\\n        p,q,r= hcf(a,b),hcf(b,c),hcf(a,c)\\n        s = hcf(r,b)\\n        x1 = (a*b) // p\\n        x2 = (b*c) // q \\n        x3 = (a*c) // r\\n        x4 = (a * b * c * s)// (p * q * r )\\n        low,high = a , a *n\\n        while low <= high:\\n            mid = (low + high)//2\\n            times = mid//a + mid//b + mid//c - mid//x1 - mid//x2 - mid//x3 + mid//x4\\n            if times < n : low = mid + 1\\n            elif times == n:\\n                ans = min(ans,mid)\\n                high = mid - 1\\n            else: high = mid - 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nBrute force is trying each number from 1 untill we get our nth ugly number\\nNow we can improve this approach by using the idea that we need to get the nth ugly number which is divisible  by a,b,or c\\n\\nSo we make a list of size 3 \"times = [1,1,1]\" having all values as 1 indicating the current number \\nusing number a,b,c, respectively\\n\\nNow we find the smallest number  which will be minimum of \\n( times[0] * a, times[1] * b , times[c] * c )\\n\\nTHE smallest one can also occur by more than 1 source that is 2,3 may collide at 6\\nso we traverse the list and compare the smallest with times[0]*a , times[1]*b and times[2]*c and if smallest is equal to it we increment times[i] by 1 making the number its next occurence\\n\\n```\n```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        times = [1,1,1]\\n        smallest = inf\\n        while n != 0:\\n            smallest = min ( times[0]*a,times[1]*b,times[2]*c)\\n            if times[0]*a == smallest: times[0] += 1\\n            if times[1]*b == smallest: times[1] += 1\\n            if times[2]*c == smallest: times[2] += 1\\n            n -= 1\\n        return smallest\\n```\n```\\nLets say we have a = 2 , b = 3, c  = 5 , n = 10\\nNow the number must lie between the first occurence = min(a,b,c) i.e. 2\\nand the n th occurence in case of no collision = min(a,b,c) * n i.e. 20\\nas 2 , 4, 6 , 8 ,10 ,12 , 14 , 16 18 ,20 will lead to 10th ugly number is b,c do not collide\\n\\nNow since we know the range ... how can we decide to choose the left half or the right half\\n... The main logic of binary search\\n\\nSee if we get to know the count of ugly numbers till mid we can decide which way to walk\\n\\nSO the question is how to find the count\\n\\n\\nSay numbers a = 2 , b = 3 , c = 5 , n = 10\\nlow = 2\\nhigh = 20\\nmid = 11\\n\\nNow we need to find the count of ugly numbers till 11........\\nremember the formula\\na \\u2229 b \\u2229 c = a \\u222A b + a \\u222A c + b \\u222A c - a \\u2229 b - a \\u2229 c - b \\u2229 c + a \\u2229 b \\u2229 c\\n\\nhow many 2s will occur till 11 = 11 // 2 = 5 ( 2,4,6,8,10)\\nhow many 3s will occur till 11 = 11 // 3 = 3 ( 3,6,9)\\nhow many 5s will occur till 11 = 11 // 5 = 2 ( 5,10)\\nnow 2,3 may collide so we count them as\\n11 // (lcm 2,3) = 11 // 6 = 1 (6)\\nnow 2,5 may collide so we count them as\\n11 // (lcm 2,5) = 11 // 10 = 1(10)\\nnow 3,5 may collide so we count them as\\n11 // (lcm 3,5) = 11 // 15  = 0 \\nnow we may have count collision of (2,3) and (2,5) but it should be counted once as (2,3,5)\\nso we have to add 11 // (lcm 2,3,5) = 11// 30 = 0\\n\\nSo according to our formula total count  = 5 + 3 + 2 - 1 - 1 - 0 + 0  =  8\\n(2,4,6,8,10) + ( 3,6,9) + (5,10) - (6) - (10) - ( )  + ( ) =  (2,3,4,5,6,8,9,10)\\n\\nNow since the count is 8 and we need 10th ugly number we should go right\\n\\n\\n\\n\\nTO GET LCM of two numbers:\\n\\tLCM(a,b) * HCF(a,b)   =  a*b\\n\\t\\nTO GET LCM of three numbers:\\n\\tLCM(a,b,c) = a*b*c*HCF(a,b,c) //  HCF(a,b) * HCF(b,c) * HCF(a,c)\\n```\n```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        a,b,c = sorted((a,b,c))\\n        ans = inf\\n        def hcf(a,b):\\n            if a %b == 0: return b\\n            return hcf(b , a % b)\\n        p,q,r= hcf(a,b),hcf(b,c),hcf(a,c)\\n        s = hcf(r,b)\\n        x1 = (a*b) // p\\n        x2 = (b*c) // q \\n        x3 = (a*c) // r\\n        x4 = (a * b * c * s)// (p * q * r )\\n        low,high = a , a *n\\n        while low <= high:\\n            mid = (low + high)//2\\n            times = mid//a + mid//b + mid//c - mid//x1 - mid//x2 - mid//x3 + mid//x4\\n            if times < n : low = mid + 1\\n            elif times == n:\\n                ans = min(ans,mid)\\n                high = mid - 1\\n            else: high = mid - 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1569253,
                "title": "javascript-binary-search-with-with-lcm-76ms",
                "content": "```\\nconst gcd = (a, b) => b == 0 ? a : gcd(b, a % b);\\nconst lcm = (a, b) => (a / gcd(a, b)) * b;\\nconst ll = BigInt;\\n\\nconst nthUglyNumber = (n, a, b, c) => {\\n    let low = 0n, high = ll(2e9);\\n    let ab = lcm(a, b), bc = lcm(b, c), ac = lcm(a, c), abc = lcm(a, bc);\\n    a = ll(a), b = ll(b), c = ll(c), ab = ll(ab), bc = ll(bc), ac = ll(ac), abc = ll(abc);\\n    while (low < high) {\\n        let mid = low + high >> 1n;\\n        let cnt = mid / a + mid / b + mid / c - mid / ab - mid / bc - mid / ac + mid / abc;\\n        cnt < n ? low = mid + 1n : high = mid;\\n    }\\n    return low;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\nconst gcd = (a, b) => b == 0 ? a : gcd(b, a % b);\\nconst lcm = (a, b) => (a / gcd(a, b)) * b;\\nconst ll = BigInt;\\n\\nconst nthUglyNumber = (n, a, b, c) => {\\n    let low = 0n, high = ll(2e9);\\n    let ab = lcm(a, b), bc = lcm(b, c), ac = lcm(a, c), abc = lcm(a, bc);\\n    a = ll(a), b = ll(b), c = ll(c), ab = ll(ab), bc = ll(bc), ac = ll(ac), abc = ll(abc);\\n    while (low < high) {\\n        let mid = low + high >> 1n;\\n        let cnt = mid / a + mid / b + mid / c - mid / ab - mid / bc - mid / ac + mid / abc;\\n        cnt < n ? low = mid + 1n : high = mid;\\n    }\\n    return low;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1289614,
                "title": "binary-search-template-just-figure-out-the-math-visualised",
                "content": "# [1201. Ugly Number III](https://leetcode.com/problems/ugly-number-iii/)\\n\\n---\\n\\n### Hints :\\n\\n-   Topics :\\n    -   #medium\\n    -   #math\\n    -   #binarysearch\\n        -   #seachonans/[Template](https://leetcode.com/discuss/general-discussion/786126/Python-Powerful-Ultimate-Binary-Search-Template.-Solved-many-problems)\\n\\n---\\n\\n## Explanation :\\n\\n-   **Key observations**:\\n\\n    -   > Apply template but figure out the math part\\n    -   > **let A be set of multiples of A that are smaller than equal to the given key**...B be ...C be..\\n    -   > ==Our ans will lie in the set of (A + B + C) merged set with unique elements==\\n    -   > we know : ![image](https://assets.leetcode.com/users/hiepit/image_1569139496.png)\\n    -   > _we are taking set as cardinality of the set rather than its elements since we dont need the actual elements_\\n\\n---\\n\\n## Solution :\\n\\n```python\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        def isans(key) -> bool:\\n            return int(key // a + key // b + key // c       # A + B + C\\n                       - key // math.lcm(a, b)              # (A U B)\\n                       - key // math.lcm(b, c)              # (B U C)\\n                       - key // math.lcm(a, c)              # (A U C)\\n                       + key // (math.lcm(a, b, c))) >= n   # (A U B U C)\\n\\n        l, r = 1, 10 ** 10  # r is specified in the leetcode constraints\\n        while l < r:\\n            mid = l + (r - l) // 2\\n            if isans(mid):\\n                r = mid\\n            else:\\n                l = mid + 1\\n        return l  # = the least index which satisifies isans()\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```python\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        def isans(key) -> bool:\\n            return int(key // a + key // b + key // c       # A + B + C\\n                       - key // math.lcm(a, b)              # (A U B)\\n                       - key // math.lcm(b, c)              # (B U C)\\n                       - key // math.lcm(a, c)              # (A U C)\\n                       + key // (math.lcm(a, b, c))) >= n   # (A U B U C)\\n\\n        l, r = 1, 10 ** 10  # r is specified in the leetcode constraints\\n        while l < r:\\n            mid = l + (r - l) // 2\\n            if isans(mid):\\n                r = mid\\n            else:\\n                l = mid + 1\\n        return l  # = the least index which satisifies isans()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1586169,
                "title": "java-100-0ms-binary-search-with-lcm-explained",
                "content": "The approach I used is called [Inclusion-Exclusion Principle](https://en.wikipedia.org/wiki/Inclusion%E2%80%93exclusion_principle) . I explain the idea behind this principle below;\\n\\nLet a, b, and c be three numbers, also, let A, B, C respectively be the set of numbers that a, b, c can divide between 1 and M (M integer greater or equal to 1).\\nNotice that there is possibility of A, B, C containing same elements. In such case,  what do you think would be the cardinality of (i.e. number of elements in ) the union of A, B, C? \\n\\nWith [Inclusion-Exclusion Principle](https://en.wikipedia.org/wiki/Inclusion%E2%80%93exclusion_principle), you can calculate the cardinality of the union of A, B, and C, while avoiding double counting elements that appear in more that one set. Thus\\n\\n![image](https://assets.leetcode.com/users/images/abb8b579-bdc1-4332-a7df-c089d9e1ad30_1640536477.23598.png)\\n\\nThen  how can we get the following sets A, B, C, A\\u2229B, B\\u2229C, A\\u2229C, A\\u2229B\\u2229C?\\nLet us consider an example;\\n\\nLet a = 6, b = 3, c = 4,  M = 30\\nThen between 1 and 30;\\n\\nNumbers divisible by a = 6, i.e. A = {6, 12, 18, 24, 30},   |A| = 5\\n\\nNumbers divisible by b = 3, i.e. B = {3, 6, 9, 12, 15, 18, 21, 24, 27, 30}, |B| = 10\\n\\nNumbers divisible by c = 4, i.e. C = {4, 8, 12, 16, 20, 24, 28}, |C| = 7\\n\\nNotice the followings about the sets A,B, and C;\\n|A| = 5 corresponds to 30/6\\n|B| = 10 corresponds to 30/3\\n|C| = 7 corresponds to 30/4 (integer division)\\n\\nNotice also that \\n|A\\u2229B| = |{6,12,18,24,30}| = 5  corresponds to 30/lcm(6,3) = 30/6 = 5\\n\\n|A\\u2229C| = |{12,24}| = 2 corresponds to 30/lcm(6,4) = 30/12 = 2 (integer division)\\n\\n|B\\u2229C| = |{12,24}| = 2 corresponds to 30/lcm(3,4) = 30/12 = 2 (integer division)\\n\\n|A\\u2229B\\u2229C| = |{12,24}| = 2 corresponds to 30/lcm(6,3,4} = 30/12 = 2 (integer division)\\n\\nNB: the question is simply asking for the number of elements in the union of A,B, and C\\ni.e. |A\\u222AB\\u222AC| = |{3,4,6,8,9,12,15,16,18,20,21,24,27,28,30}| = 15.\\nNotice that it is wrong to simply add the cardinality of A, B, and C (i.e. |A| + |B| + |C| = 22) since there are duplicates between sets. This is why the inclusion-exclusion principle is used. Thus, putting everything together, we have\\n\\n|A\\u222AB\\u222AC| = 5 + 10 + 7 - 5 - 2 - 2 + 2 = 15\\n\\nThe best way to understand the problem is to take time and consider some examples. It\\'ll definitely sink in.\\n```\\n/*\\nSo, given a,b,c. Let M be a positive integer, the number of positive integers between 1 and M (inclusive) that a, b, or c divides can be calculated as follows\\n\\nM/a + M/b + M/c - M/lcm(a,b) - M/lcm(a,c) - M/lcm(b,c) + M/lcm(a,b,c)\\n\\nSince we can easily calculate the number of ulgly numbers between 1 and any positive integer M, then we can perform a binary search until we found M such that ulgly numbers is equal to n.\\nWhat would be the upper bound of the binary search?\\nFor me, I believe the nth ulgly number cannot exceed  min(a,b,c)*n. You probably know lower upper bound.\\n\\nThus, we can perform a binary search over the range  [1,  min(a,b,c)*n] to find nth ulgly number \\n*/\\nclass Solution {\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n       \\n        long aa = Math.min(a,Math.min(b,c));\\n        long cc = Math.max(a,Math.max(b,c));\\n        long bb = a + b + c - aa - cc;\\n        long LCMabc = lcm( lcm(a,b), c);\\n        long LCMab = lcm(a,b);\\n        long LCMac = lcm(a,c);\\n        long LCMbc = lcm(b,c);\\n        \\n        long left = 1, right = n * aa;\\n        while(left < right){\\n            long mid = left + (right - left)/2;\\n            long count = mid/a + mid/b + mid/c - mid/LCMab - mid/LCMbc - mid/LCMac + mid/LCMabc;\\n    \\n            if(n > count)\\n                left = mid+1;\\n            else\\n                right = mid;\\n        }\\n        return Long.valueOf(left).intValue();\\n    }\\n    private long lcm(long a, long b){\\n        return (a*b)/gcd(a,b);\\n    }\\n    private long gcd(long a, long b){\\n        if(b == 0)return a;\\n        return gcd(b, a%b);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nSo, given a,b,c. Let M be a positive integer, the number of positive integers between 1 and M (inclusive) that a, b, or c divides can be calculated as follows\\n\\nM/a + M/b + M/c - M/lcm(a,b) - M/lcm(a,c) - M/lcm(b,c) + M/lcm(a,b,c)\\n\\nSince we can easily calculate the number of ulgly numbers between 1 and any positive integer M, then we can perform a binary search until we found M such that ulgly numbers is equal to n.\\nWhat would be the upper bound of the binary search?\\nFor me, I believe the nth ulgly number cannot exceed  min(a,b,c)*n. You probably know lower upper bound.\\n\\nThus, we can perform a binary search over the range  [1,  min(a,b,c)*n] to find nth ulgly number \\n*/\\nclass Solution {\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n       \\n        long aa = Math.min(a,Math.min(b,c));\\n        long cc = Math.max(a,Math.max(b,c));\\n        long bb = a + b + c - aa - cc;\\n        long LCMabc = lcm( lcm(a,b), c);\\n        long LCMab = lcm(a,b);\\n        long LCMac = lcm(a,c);\\n        long LCMbc = lcm(b,c);\\n        \\n        long left = 1, right = n * aa;\\n        while(left < right){\\n            long mid = left + (right - left)/2;\\n            long count = mid/a + mid/b + mid/c - mid/LCMab - mid/LCMbc - mid/LCMac + mid/LCMabc;\\n    \\n            if(n > count)\\n                left = mid+1;\\n            else\\n                right = mid;\\n        }\\n        return Long.valueOf(left).intValue();\\n    }\\n    private long lcm(long a, long b){\\n        return (a*b)/gcd(a,b);\\n    }\\n    private long gcd(long a, long b){\\n        if(b == 0)return a;\\n        return gcd(b, a%b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1554087,
                "title": "binary-search-python-solution-with-explanation",
                "content": "```\\nimport math\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n\\n        # define boolean function to do binary search\\n        # fulfill(num) check if there at least n ugly numbers that are <= num\\n        def fulfill(num) -> bool:\\n            total = num//a + num//b + num//c - num//ab - num//ac - num//bc + num//abc\\n            return total >= n\\n        \\n        # define variables that are to be consumed by fulfill function\\n        # ab, ac, bc are the Least Common Multiple (\\u6700\\u5C0F\\u516C\\u500D\\u6570:LCM) of (a, b), (a, c), (b, c) \\n        # respectively, similarly abc is the LCM of a, b, c.\\n        ab = a * b // math.gcd(a, b)\\n        ac = a * c // math.gcd(a, c)\\n        bc = b * c // math.gcd(b, c)\\n        abc = a * bc // math.gcd(a, bc)\\n        \\n        # find min x s.t. fulfill(x) is True\\n        # the x is what we want\\n        left, right = 1, 2 * 10 ** 9 + 1\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if fulfill(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```",
                "solutionTags": [],
                "code": "```\\nimport math\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n\\n        # define boolean function to do binary search\\n        # fulfill(num) check if there at least n ugly numbers that are <= num\\n        def fulfill(num) -> bool:\\n            total = num//a + num//b + num//c - num//ab - num//ac - num//bc + num//abc\\n            return total >= n\\n        \\n        # define variables that are to be consumed by fulfill function\\n        # ab, ac, bc are the Least Common Multiple (\\u6700\\u5C0F\\u516C\\u500D\\u6570:LCM) of (a, b), (a, c), (b, c) \\n        # respectively, similarly abc is the LCM of a, b, c.\\n        ab = a * b // math.gcd(a, b)\\n        ac = a * c // math.gcd(a, c)\\n        bc = b * c // math.gcd(b, c)\\n        abc = a * bc // math.gcd(a, bc)\\n        \\n        # find min x s.t. fulfill(x) is True\\n        # the x is what we want\\n        left, right = 1, 2 * 10 ** 9 + 1\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if fulfill(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1396645,
                "title": "binary-search-c-with-approach-faster-than-100",
                "content": "The idea behind this solution is that, for some number **num** we are finding number of ugly numbers that are less than or equal to **num**.\\n\\tThis can be done using the formula: **num / a + num / b + num / c - num / lcm(a, b) - num / lcm(b, c) - num / lcm(a, c) + num / lcm(a, b, c)**\\n\\tHere num / a gives number of integers that are <= num and multiples of a\\n\\tnum / b gives number of integers that are <= num and multiples of b\\n\\tnum / c gives number of integers that are <= num and multiples of c\\n\\tbut directly adding these will not give us the answer as some numbers have been counted multiple times\\n\\tWe need to check for double counting:\\n\\ttake 2, 3 and 6 for example \\n\\t6 will be added for 2 and 3 both, similarly 12, 18, 24 ....\\n\\tso we need to subtract these numbers once\\n\\tnow for the last term in formula take a = 2, b = 3, c = 5 \\n\\twe will check how many times 30 will be counted\\n\\tfor 2, 30 will be counted once similarly for 3 and 5\\n\\tit will be subtracted for lcm(a, b), lcm(a, c) and lcm(b, c) \\n\\tSo total count becomes 0, hence we will need to add numbers that are multiples of lcm(a, b, c) once.\\n\\t\\n```\\ntypedef long long ull;\\nclass Solution {\\npublic:\\n\\t//function to find gcd [lcm(a, b) = (a * b)/gcd(a, b))\\n    ull gcd(ull a, ull b){\\n        if(a % b == 0) return b;\\n        return gcd(b, a % b);\\n    }\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        ull high = 1e18;\\n        ull low = 1;\\n        int answer = 0;\\n\\t\\t//lcm of a, b\\n        ull a_b = (ull(a) * b) / gcd(a, b);\\n\\t\\t//lcm of b, c\\n        ull b_c = (ull(b) * c) / gcd(b, c);\\n\\t\\t//lcm of a, c\\n        ull a_c = (ull(a) * c) / gcd(a, c);\\n\\t\\t//lcm of a, b, c\\n        ull a_b_c = (a_b * c) /gcd(a_b, c);\\n        while(low <= high){\\n            ull mid = (low + high) / 2;\\n            ull temp = mid / a + mid / b + mid / c - mid / a_b - mid / a_c - mid / b_c + mid / a_b_c;\\n            if(temp >= n){\\n                answer = mid;\\n                high = mid - 1;\\n            }\\n            else{\\n                low = mid + 1;\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\t//function to find gcd [lcm(a, b) = (a * b)/gcd(a, b))\\n    ull gcd(ull a, ull b){\\n        if(a % b == 0) return b;\\n        return gcd(b, a % b);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 905775,
                "title": "100-faster-100-memory-efficient-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        long long int  left = min(min(a,b),c), right = 1e18;\\n        cout<<left <<\"\\\\n\";\\n        while(left < right ){\\n            long long int mid = left + (right - left )/2;\\n            if(condition(mid,n,a,b,c)){\\n                right = mid;\\n            }\\n            else left = mid+1;\\n        }\\n        return left;\\n    }\\n    bool condition(long long int num,int n,int a,int b,int c){\\n    \\n        long long int ab = (a)/__gcd(a,b),bc  = (c)/__gcd(c,b),ca = (a)/__gcd(a,c);\\n        ab *=b;\\n        ca *=c;\\n        bc *=b;\\n        \\n        long long int abc = (ab)/(__gcd(ab,bc));\\n        abc *= bc;\\n        long long int count = 0;\\n       \\n        count = num/a + num/b + num/c - num/ab - num/bc - num/ca +num/abc;\\n\\n        if(count >=n ) return true;\\n        else return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        long long int  left = min(min(a,b),c), right = 1e18;\\n        cout<<left <<\"\\\\n\";\\n        while(left < right ){\\n            long long int mid = left + (right - left )/2;\\n            if(condition(mid,n,a,b,c)){\\n                right = mid;\\n            }\\n            else left = mid+1;\\n        }\\n        return left;\\n    }\\n    bool condition(long long int num,int n,int a,int b,int c){\\n    \\n        long long int ab = (a)/__gcd(a,b),bc  = (c)/__gcd(c,b),ca = (a)/__gcd(a,c);\\n        ab *=b;\\n        ca *=c;\\n        bc *=b;\\n        \\n        long long int abc = (ab)/(__gcd(ab,bc));\\n        abc *= bc;\\n        long long int count = 0;\\n       \\n        count = num/a + num/b + num/c - num/ab - num/bc - num/ca +num/abc;\\n\\n        if(count >=n ) return true;\\n        else return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 553029,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int nthUglyNumber(int n, int A, int B, int C) {\\n        if(A==1||B==1||C==1)return n;\\n        long res=0;\\n        long a=A;\\n        long b=B;\\n        long c=C;\\n        long ab=a*b/gcd(a,b);\\n        long ac=a*c/gcd(a,c);\\n        long bc=b*c/gcd(b,c);\\n        long abc=a*bc/gcd(a,bc);\\n        long left=0;long right=2000000000;\\n        while(left<=right){\\n            long mid=left+(right-left)/2;\\n            long cnt=mid/a+mid/b+mid/c-mid/ab-mid/ac-mid/bc+mid/abc;\\n            if(cnt==n){\\n                res=mid;\\n                right=mid-1;\\n            }\\n            else if(cnt>n){\\n                right=mid-1;\\n            }else{\\n                left=mid+1;\\n            }\\n        }\\n        return (int)res;\\n    }\\n    \\n    public long gcd( long a, long b) {\\n        if( a < b) return gcd(b,a);\\n        if( b == 0 ) return a;\\n        return gcd(b,a%b);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int nthUglyNumber(int n, int A, int B, int C) {\\n        if(A==1||B==1||C==1)return n;\\n        long res=0;\\n        long a=A;\\n        long b=B;\\n        long c=C;\\n        long ab=a*b/gcd(a,b);\\n        long ac=a*c/gcd(a,c);\\n        long bc=b*c/gcd(b,c);\\n        long abc=a*bc/gcd(a,bc);\\n        long left=0;long right=2000000000;\\n        while(left<=right){\\n            long mid=left+(right-left)/2;\\n            long cnt=mid/a+mid/b+mid/c-mid/ab-mid/ac-mid/bc+mid/abc;\\n            if(cnt==n){\\n                res=mid;\\n                right=mid-1;\\n            }\\n            else if(cnt>n){\\n                right=mid-1;\\n            }else{\\n                left=mid+1;\\n            }\\n        }\\n        return (int)res;\\n    }\\n    \\n    public long gcd( long a, long b) {\\n        if( a < b) return gcd(b,a);\\n        if( b == 0 ) return a;\\n        return gcd(b,a%b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 542464,
                "title": "c-solution-100-in-time-and-space-with-explanation",
                "content": "The idea is to keep tracking the multiples of a, b and c. We can use integer p, q and r for that, each time when we caculate the next ugly number, we get the minimum from `p*a`, `q*b` and `r*c`, and increment p, q or r accordingly. So the first version looks like this:\\n```cpp\\n     int nthUglyNumber(int n, int a, int b, int c) {\\n        int p = 1, q = 1, r = 1, last;\\n        for (int i=0; i<n; i++) {\\n            last = min(min(a*p, b*q), c*r);\\n            if (last == a*p) p++;\\n            if (last == b*q) q++;\\n            if (last == c*r) r++;\\n        }\\n        return last;\\n    }\\n```\\nUnfortunately, this will fail for some case due to timeout, such as\\n```\\n1000000000\\n2\\n217983653\\n336916467\\n```\\n\\nSo, the following code is to optimise for this kind of scenario, we try to increment the multiple` p` for `a` in bulk, it works very well.\\n```cpp\\n    using INT=int64_t;\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        INT p = 1, q = 1, r = 1, last, step, middle, s;\\n        for (int i=0; i<n;) {\\n            s = a*p + b*q + c*r; \\n            last = min(c * r, min(a * p, b * q));\\n            middle = s - last - max(c * r, max(a * p, b * q));\\n            step = 1;\\n            if (last == c*r) { r++;}\\n            if (last == b*q) { q++;}\\n            if (last == a*p) {\\n                INT k = (middle - last)/a - 1;\\n                if (k > 0 && k + i >= n) {\\n                    k = n - i - 2;\\n                }\\n                step = max(step, k);\\n                p += step; \\n            }\\n            i += step;\\n        }\\n        return last;\\n    }\\n```",
                "solutionTags": [],
                "code": "```cpp\\n     int nthUglyNumber(int n, int a, int b, int c) {\\n        int p = 1, q = 1, r = 1, last;\\n        for (int i=0; i<n; i++) {\\n            last = min(min(a*p, b*q), c*r);\\n            if (last == a*p) p++;\\n            if (last == b*q) q++;\\n            if (last == c*r) r++;\\n        }\\n        return last;\\n    }\\n```\n```\\n1000000000\\n2\\n217983653\\n336916467\\n```\n```cpp\\n    using INT=int64_t;\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        INT p = 1, q = 1, r = 1, last, step, middle, s;\\n        for (int i=0; i<n;) {\\n            s = a*p + b*q + c*r; \\n            last = min(c * r, min(a * p, b * q));\\n            middle = s - last - max(c * r, max(a * p, b * q));\\n            step = 1;\\n            if (last == c*r) { r++;}\\n            if (last == b*q) { q++;}\\n            if (last == a*p) {\\n                INT k = (middle - last)/a - 1;\\n                if (k > 0 && k + i >= n) {\\n                    k = n - i - 2;\\n                }\\n                step = max(step, k);\\n                p += step; \\n            }\\n            i += step;\\n        }\\n        return last;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 440495,
                "title": "c-solution",
                "content": "```\\npublic class Solution \\n{\\n    public int NthUglyNumber(int n, int a, int b, int c) \\n    {\\n        int start = 0, end = int.MaxValue;\\n        long ab = LCM(a, b), bc = LCM(b, c), ca = LCM(c, a), abc = LCM(a, bc);\\n        while(start < end)\\n        {\\n            int mid = start + (end - start) / 2;\\n            int count = (int) (mid/a + mid/b + mid/c - mid/ab - mid/bc - mid/ca + mid/abc);\\n            if(count < n)\\n                start = mid + 1;\\n            else\\n                end = mid;\\n        }\\n        \\n        return start;\\n    }\\n    \\n    private long GCD(long x, long y)\\n    {\\n        return y == 0 ? x : GCD(y, x % y);\\n    }\\n    \\n    private long LCM(long x, long y)\\n    {\\n        return (x * y) / GCD(x, y);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int NthUglyNumber(int n, int a, int b, int c) \\n    {\\n        int start = 0, end = int.MaxValue;\\n        long ab = LCM(a, b), bc = LCM(b, c), ca = LCM(c, a), abc = LCM(a, bc);\\n        while(start < end)\\n        {\\n            int mid = start + (end - start) / 2;\\n            int count = (int) (mid/a + mid/b + mid/c - mid/ab - mid/bc - mid/ca + mid/abc);\\n            if(count < n)\\n                start = mid + 1;\\n            else\\n                end = mid;\\n        }\\n        \\n        return start;\\n    }\\n    \\n    private long GCD(long x, long y)\\n    {\\n        return y == 0 ? x : GCD(y, x % y);\\n    }\\n    \\n    private long LCM(long x, long y)\\n    {\\n        return (x * y) / GCD(x, y);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3838180,
                "title": "easy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long mab,mbc,mac,mabc;\\n    long long  gcd(long long  a, long long  b)\\n    {\\n        if(b==0) \\n        return a;\\n        if(a<b) \\n        return gcd(b,a);\\n        return gcd(b,a%b);\\n    }\\n    long long  lcm(long long  a, long long  b)\\n    {\\n        return (a*b)/gcd(a,b);\\n    }\\n    long long  before(long long  x, long long  a, long long  b, long long  c)\\n    {\\n        return (x/a)+(x/b)+(x/c)-(x/mab)-(x/mbc)-(x/mac)+(x/mabc);\\n    }\\n    int nthUglyNumber(int n, int a, int b, int c) \\n    {\\n        mab=lcm(a,b);\\n        mbc=lcm(b,c);\\n        mac=lcm(a,c);\\n        mabc=lcm(mab,c);\\n        long long  lo=1;\\n        long long  hi=2e9;\\n        while(lo<hi){\\n            long long  x=lo+(hi-lo)/2;\\n            if(before(x,a,b,c)>=n) hi=x;\\n            else lo=x+1;\\n        }\\n        return hi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long mab,mbc,mac,mabc;\\n    long long  gcd(long long  a, long long  b)\\n    {\\n        if(b==0) \\n        return a;\\n        if(a<b) \\n        return gcd(b,a);\\n        return gcd(b,a%b);\\n    }\\n    long long  lcm(long long  a, long long  b)\\n    {\\n        return (a*b)/gcd(a,b);\\n    }\\n    long long  before(long long  x, long long  a, long long  b, long long  c)\\n    {\\n        return (x/a)+(x/b)+(x/c)-(x/mab)-(x/mbc)-(x/mac)+(x/mabc);\\n    }\\n    int nthUglyNumber(int n, int a, int b, int c) \\n    {\\n        mab=lcm(a,b);\\n        mbc=lcm(b,c);\\n        mac=lcm(a,c);\\n        mabc=lcm(mab,c);\\n        long long  lo=1;\\n        long long  hi=2e9;\\n        while(lo<hi){\\n            long long  x=lo+(hi-lo)/2;\\n            if(before(x,a,b,c)>=n) hi=x;\\n            else lo=x+1;\\n        }\\n        return hi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456765,
                "title": "simple-solution-using-binary-search-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long GCD(long long x, long long y){\\n        if(y==0){\\n            return x;\\n        }\\n        return GCD(y, x%y);\\n    }\\n    long long bin(long long st, long long end, int& target, long long& a, long long& b, long long&d){\\n        if(st<=end){\\n            long long mid=(st+end)/2;\\n            long long val=(mid/a) + (mid/b) - (mid/(a*b/d));\\n            if(val==target){\\n                if(mid%a==0 or mid%b==0){\\n                    return mid;\\n                }\\n                else{\\n                    return bin(st,mid-1,target,a,b,d);\\n                }\\n            }\\n            else if(val<target){\\n                return bin(mid+1,end,target,a,b,d);\\n            }\\n            else{\\n                return bin(st,mid-1,target,a,b,d);\\n            }\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n    long long binary(long long st, long long end, int& target,long long& a, long long& b, long long& c, long long& d, long long& e, long long& f, long long& g){\\n        if(st<=end){\\n            long long mid=(st+end)/2;\\n            long long ans=(mid/a)+(mid/b)+(mid/c)-(mid/(a*b/d))-(mid/(b*c/e))-(mid/(a*c/f))+(mid/(g));\\n            if(ans==target){\\n                if(mid%a==0 or mid%b==0 or mid%c==0){\\n                    return mid;\\n                }\\n                else{\\n                    return binary(st,mid-1,target,a,b,c,d,e,f,g);\\n                }\\n            }\\n            else if(ans<target){\\n                return binary(mid+1,end,target,a,b,c,d,e,f,g);\\n            }\\n            else{\\n                return binary(st,mid-1,target,a,b,c,d,e,f,g);\\n            }\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        if(a==b and b==c){\\n            return a*n;\\n        }\\n        else if(a==b or b==c or a==c){\\n            a=min(a,min(b,c));\\n            b=max(a,max(b,c));\\n            long long a1=a;\\n            long long b1=b;\\n            long long d=GCD(a1,b1);\\n            long long end=2000000000;\\n            long long val=bin(1,end,n,a1,b1,d);\\n            return val;\\n        }\\n        else{\\n            long long end=2000000000;\\n            long long a1=a;\\n            long long b1=b;\\n            long long c1=c;\\n            long long d=GCD(a1,b1);\\n            long long e=GCD(b1,c1);\\n            long long f=GCD(a1,c1);\\n            long long g=(a1*b1/d)*c1/GCD(a1*b1/d,c1);\\n            long long val=binary(1,end,n,a1,b1,c1,d,e,f,g);\\n            return val;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long GCD(long long x, long long y){\\n        if(y==0){\\n            return x;\\n        }\\n        return GCD(y, x%y);\\n    }\\n    long long bin(long long st, long long end, int& target, long long& a, long long& b, long long&d){\\n        if(st<=end){\\n            long long mid=(st+end)/2;\\n            long long val=(mid/a) + (mid/b) - (mid/(a*b/d));\\n            if(val==target){\\n                if(mid%a==0 or mid%b==0){\\n                    return mid;\\n                }\\n                else{\\n                    return bin(st,mid-1,target,a,b,d);\\n                }\\n            }\\n            else if(val<target){\\n                return bin(mid+1,end,target,a,b,d);\\n            }\\n            else{\\n                return bin(st,mid-1,target,a,b,d);\\n            }\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n    long long binary(long long st, long long end, int& target,long long& a, long long& b, long long& c, long long& d, long long& e, long long& f, long long& g){\\n        if(st<=end){\\n            long long mid=(st+end)/2;\\n            long long ans=(mid/a)+(mid/b)+(mid/c)-(mid/(a*b/d))-(mid/(b*c/e))-(mid/(a*c/f))+(mid/(g));\\n            if(ans==target){\\n                if(mid%a==0 or mid%b==0 or mid%c==0){\\n                    return mid;\\n                }\\n                else{\\n                    return binary(st,mid-1,target,a,b,c,d,e,f,g);\\n                }\\n            }\\n            else if(ans<target){\\n                return binary(mid+1,end,target,a,b,c,d,e,f,g);\\n            }\\n            else{\\n                return binary(st,mid-1,target,a,b,c,d,e,f,g);\\n            }\\n        }\\n        else{\\n            return -1;\\n        }\\n    }\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        if(a==b and b==c){\\n            return a*n;\\n        }\\n        else if(a==b or b==c or a==c){\\n            a=min(a,min(b,c));\\n            b=max(a,max(b,c));\\n            long long a1=a;\\n            long long b1=b;\\n            long long d=GCD(a1,b1);\\n            long long end=2000000000;\\n            long long val=bin(1,end,n,a1,b1,d);\\n            return val;\\n        }\\n        else{\\n            long long end=2000000000;\\n            long long a1=a;\\n            long long b1=b;\\n            long long c1=c;\\n            long long d=GCD(a1,b1);\\n            long long e=GCD(b1,c1);\\n            long long f=GCD(a1,c1);\\n            long long g=(a1*b1/d)*c1/GCD(a1*b1/d,c1);\\n            long long val=binary(1,end,n,a1,b1,c1,d,e,f,g);\\n            return val;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3179363,
                "title": "java-solution-0-ms-beats-100",
                "content": "# Java Code\\n```\\nclass Solution {\\n    long a, b, c, ab, bc, ac, abc;\\n\\n    public long countMultiples(long mid) {\\n        return (mid / a) + (mid / b) + (mid / c) - (mid / ab) - (mid / bc) - (mid / ac) + (mid / abc);\\n    }\\n\\n    public int gcd(int a, int b) {\\n        return (b == 0) ? a : gcd(b, a % b);\\n    }\\n\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        this.a = a;\\n        this.b = b;\\n        this.c = c;\\n\\n        ab = ((long) a * b) / gcd(a, b);\\n        bc = ((long) b * c) / gcd(b, c);\\n        ac = ((long) a * c) / gcd(a, c);\\n        abc = ((long) a * bc) / gcd(a, (int) bc);\\n\\n        long left = 0, right = Long.MAX_VALUE;\\n\\n        while (left <= right) {\\n            long mid = left + (right - left) / 2;\\n            if (countMultiples(mid) < n) left = mid + 1;\\n            else right = mid - 1;\\n        }\\n\\n        return (int) left;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Binary Search",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\n    long a, b, c, ab, bc, ac, abc;\\n\\n    public long countMultiples(long mid) {\\n        return (mid / a) + (mid / b) + (mid / c) - (mid / ab) - (mid / bc) - (mid / ac) + (mid / abc);\\n    }\\n\\n    public int gcd(int a, int b) {\\n        return (b == 0) ? a : gcd(b, a % b);\\n    }\\n\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        this.a = a;\\n        this.b = b;\\n        this.c = c;\\n\\n        ab = ((long) a * b) / gcd(a, b);\\n        bc = ((long) b * c) / gcd(b, c);\\n        ac = ((long) a * c) / gcd(a, c);\\n        abc = ((long) a * bc) / gcd(a, (int) bc);\\n\\n        long left = 0, right = Long.MAX_VALUE;\\n\\n        while (left <= right) {\\n            long mid = left + (right - left) / 2;\\n            if (countMultiples(mid) < n) left = mid + 1;\\n            else right = mid - 1;\\n        }\\n\\n        return (int) left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2989598,
                "title": "easy-binary-searching",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntypedef long long ll;\\n#define MAX_ANS 2e9 \\n\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int left = 0, right = MAX_ANS, result = 0;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (count(mid, a, b, c) >= n) { \\n                result = mid;\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return result;\\n    }\\n    int count(ll num, ll a, ll b, ll c) {\\n        return (int)(num / a + num / b + num / c\\n            - num / lcm(a, b)\\n            - num / lcm(b, c)\\n            - num / lcm(a, c)\\n            + num / (lcm(a, lcm(b, c))));\\n    }\\n    ll gcd(ll a, ll b) {\\n        if (a == 0) return b;\\n        return gcd(b % a, a);\\n    }\\n    ll lcm(ll a, ll b) {\\n        return a * b / gcd(a, b);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ntypedef long long ll;\\n#define MAX_ANS 2e9 \\n\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int left = 0, right = MAX_ANS, result = 0;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (count(mid, a, b, c) >= n) { \\n                result = mid;\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return result;\\n    }\\n    int count(ll num, ll a, ll b, ll c) {\\n        return (int)(num / a + num / b + num / c\\n            - num / lcm(a, b)\\n            - num / lcm(b, c)\\n            - num / lcm(a, c)\\n            + num / (lcm(a, lcm(b, c))));\\n    }\\n    ll gcd(ll a, ll b) {\\n        if (a == 0) return b;\\n        return gcd(b % a, a);\\n    }\\n    ll lcm(ll a, ll b) {\\n        return a * b / gcd(a, b);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2568523,
                "title": "python-binary-search-solution-do-878-first",
                "content": "[878. Nth Magical Number](https://leetcode.com/problems/nth-magical-number/)\\n```\\nclass Solution:\\n    # an extended problem as Leetcode 878. Nth Magical Number\\n    # n could be as large as 10^9, so we cannot use a heap as in Ugly Number II\\n    # Because we do not need to know every ugly number up to n, instead we could use binary search to find the answer\\n    # The lower limit is 1, the upper limit is 2*10^9\\n    # if any of a or b or c equals 1, just return n\\n    # We use a function ugly to return number of ugly numbers smaller than the certain number x\\n    # It is given by (x // a) + (x // b) + (x // c) - (x // lcm(a,b)) - x // lcm(b,c) - x // lcm(a,c) + x // lcm(a, lcm(b,c))\\n    \\n    def gcd(self, a, b):\\n        if a < b:\\n            a,b = b,a\\n        if b == 0:\\n            return a\\n        else:\\n            return self.gcd(b, a%b)\\n    \\n    def lcm(self, a, b):\\n        return a*b // self.gcd(a,b)\\n    \\n    def ugly(self, x, a, b, c):\\n        return (x // a) + (x // b) + (x // c) - (x // self.lcm(a,b)) - (x // self.lcm(b,c)) - (x // self.lcm(a,c)) + (x // self.lcm(a, self.lcm(b,c)))\\n\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        left, right = 1, 2*pow(10,9)\\n        while left < right:\\n            mid = (left + right) // 2\\n            if self.ugly(mid, a, b, c) >= n:\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # an extended problem as Leetcode 878. Nth Magical Number\\n    # n could be as large as 10^9, so we cannot use a heap as in Ugly Number II\\n    # Because we do not need to know every ugly number up to n, instead we could use binary search to find the answer\\n    # The lower limit is 1, the upper limit is 2*10^9\\n    # if any of a or b or c equals 1, just return n\\n    # We use a function ugly to return number of ugly numbers smaller than the certain number x\\n    # It is given by (x // a) + (x // b) + (x // c) - (x // lcm(a,b)) - x // lcm(b,c) - x // lcm(a,c) + x // lcm(a, lcm(b,c))\\n    \\n    def gcd(self, a, b):\\n        if a < b:\\n            a,b = b,a\\n        if b == 0:\\n            return a\\n        else:\\n            return self.gcd(b, a%b)\\n    \\n    def lcm(self, a, b):\\n        return a*b // self.gcd(a,b)\\n    \\n    def ugly(self, x, a, b, c):\\n        return (x // a) + (x // b) + (x // c) - (x // self.lcm(a,b)) - (x // self.lcm(b,c)) - (x // self.lcm(a,c)) + (x // self.lcm(a, self.lcm(b,c)))\\n\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        left, right = 1, 2*pow(10,9)\\n        while left < right:\\n            mid = (left + right) // 2\\n            if self.ugly(mid, a, b, c) >= n:\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2370905,
                "title": "binary-search-solution-with-overflow-handled-without-long",
                "content": "```\\nclass Solution {\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        int low = 1, high =2*(int)1e9;\\n        \\n        int ab = lcm(a,b), bc = lcm(b,c), ca = lcm(c,a), abc = lcm(a,bc);\\n        \\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            \\n            int count = mid/a + mid/b + mid/c - mid/ab - mid/bc - mid/ca + mid/abc;\\n            if(count>=n){\\n                high = mid - 1;\\n            }\\n            else low = mid + 1;\\n        }\\n        return low;\\n    }\\n    private int lcm(int x,int y){\\n        int a = x, b = y; \\n        while(a!=0){\\n            int t = a;\\n            a = b%a;\\n            b = t;\\n        }\\n        int ans = 0;\\n        try{\\n            ans = (x>y) ? Math.multiplyExact(y,(x/b)) : Math.multiplyExact(x,(y/b));  // x*y/gcd(x,y)\\n        }catch(Exception e){\\n            ans = Integer.MAX_VALUE;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        int low = 1, high =2*(int)1e9;\\n        \\n        int ab = lcm(a,b), bc = lcm(b,c), ca = lcm(c,a), abc = lcm(a,bc);\\n        \\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            \\n            int count = mid/a + mid/b + mid/c - mid/ab - mid/bc - mid/ca + mid/abc;\\n            if(count>=n){\\n                high = mid - 1;\\n            }\\n            else low = mid + 1;\\n        }\\n        return low;\\n    }\\n    private int lcm(int x,int y){\\n        int a = x, b = y; \\n        while(a!=0){\\n            int t = a;\\n            a = b%a;\\n            b = t;\\n        }\\n        int ans = 0;\\n        try{\\n            ans = (x>y) ? Math.multiplyExact(y,(x/b)) : Math.multiplyExact(x,(y/b));  // x*y/gcd(x,y)\\n        }catch(Exception e){\\n            ans = Integer.MAX_VALUE;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2217473,
                "title": "c-clear-explanation-you-will-get-it-binary-search",
                "content": "```\\n// This is a typical Binary Search Problem Here I did Binary Search and Optimized my lcm function a lot.\\n// Here Number of Ugly numbers for any number is \\n// that number/a + that number/b + that number/c + that number/lcm(a,b,c) - that number/lcm(a,b) - that number/lcm(b,c) - that number/(a,c) and howzz that??\\n//     See Lets suppose that number is 17 for which you are checking values and a = 2 , b=3 and c= 4 now figure out \\n//     all the possible values for a = 2,4,6,8,10,12,14,16\\n//         b = 3,6,9,12,15\\n//         c = 4,8,12,16\\n//         Now if we add them all we can see 4,6,8,16 are coming twice and 12 is coming thrice so we do lcm(2,3) = 6\\n//             then we are basically multiple occurance of numbers divisible by 6 simlarly for lcm(2,4) & lcm(3,4)\\n//                 but any number which is divisble by all three of them we have deleted it 3 times we  need at least so we are adding numbers which are divisble by lcm(2,3,4) which is 12 here So if suppose we are countering more numbers than n then h = mid-1 we need to move backward else we need to forward.\\nclass Solution {\\npublic:\\n    #define ll long long\\n     ll gcd(ll a, ll b)\\n     {\\n       if (b == 0)\\n        return a;\\n      return gcd(b, a % b);\\n      }\\n      ll lcm(ll a, ll b)\\n     {\\n         return (a / gcd(a, b)) * b;\\n     }\\n    bool check(ll mid , int a , int b , int c, int n)\\n    {\\n        ll j1 = lcm(a,b);\\n        ll j2 = lcm(a,c);\\n        ll j3 = lcm(b,c);\\n        ll j4 = lcm(j1,c);\\n        ll k = mid/a + mid/b + mid/c + mid/j4 - (mid/j1 + mid/j2 + mid/j3);\\n        return k==n;\\n    }\\n    bool check1(ll mid , int a , int b , int c, int n)\\n    {\\n        ll j1 = lcm(a,b);\\n        ll j2 = lcm(a,c);\\n        ll j3 = lcm(b,c);\\n        ll j4 = lcm(j1,c);\\n        ll k = mid/a + mid/b + mid/c + mid/j4 - (mid/j1 + mid/j2 + mid/j3);\\n        return k>=n;\\n    }\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        ll l = min(a,min(b,c));\\n        ll h = INT_MAX;\\n        while(l<=h)\\n        {\\n             ll  mid = l + (h-l)/2;\\n             if(check(mid,a,b,c,n) && (mid%a==0 || mid%b==0 || mid%c==0))\\n             {\\n                 return mid;\\n             }\\n             else\\n             {\\n                 if(check1(mid,a,b,c,n))\\n                 {\\n                     h = mid-1;\\n                 }\\n                 else\\n                 {\\n                     l = mid+1;\\n                 }\\n             }\\n        }\\n        return 1;\\n    }\\n};\\n```\\n**Please Upvote it...**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\n// This is a typical Binary Search Problem Here I did Binary Search and Optimized my lcm function a lot.\\n// Here Number of Ugly numbers for any number is \\n// that number/a + that number/b + that number/c + that number/lcm(a,b,c) - that number/lcm(a,b) - that number/lcm(b,c) - that number/(a,c) and howzz that??\\n//     See Lets suppose that number is 17 for which you are checking values and a = 2 , b=3 and c= 4 now figure out \\n//     all the possible values for a = 2,4,6,8,10,12,14,16\\n//         b = 3,6,9,12,15\\n//         c = 4,8,12,16\\n//         Now if we add them all we can see 4,6,8,16 are coming twice and 12 is coming thrice so we do lcm(2,3) = 6\\n//             then we are basically multiple occurance of numbers divisible by 6 simlarly for lcm(2,4) & lcm(3,4)\\n//                 but any number which is divisble by all three of them we have deleted it 3 times we  need at least so we are adding numbers which are divisble by lcm(2,3,4) which is 12 here So if suppose we are countering more numbers than n then h = mid-1 we need to move backward else we need to forward.\\nclass Solution {\\npublic:\\n    #define ll long long\\n     ll gcd(ll a, ll b)\\n     {\\n       if (b == 0)\\n        return a;\\n      return gcd(b, a % b);\\n      }\\n      ll lcm(ll a, ll b)\\n     {\\n         return (a / gcd(a, b)) * b;\\n     }\\n    bool check(ll mid , int a , int b , int c, int n)\\n    {\\n        ll j1 = lcm(a,b);\\n        ll j2 = lcm(a,c);\\n        ll j3 = lcm(b,c);\\n        ll j4 = lcm(j1,c);\\n        ll k = mid/a + mid/b + mid/c + mid/j4 - (mid/j1 + mid/j2 + mid/j3);\\n        return k==n;\\n    }\\n    bool check1(ll mid , int a , int b , int c, int n)\\n    {\\n        ll j1 = lcm(a,b);\\n        ll j2 = lcm(a,c);\\n        ll j3 = lcm(b,c);\\n        ll j4 = lcm(j1,c);\\n        ll k = mid/a + mid/b + mid/c + mid/j4 - (mid/j1 + mid/j2 + mid/j3);\\n        return k>=n;\\n    }\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        ll l = min(a,min(b,c));\\n        ll h = INT_MAX;\\n        while(l<=h)\\n        {\\n             ll  mid = l + (h-l)/2;\\n             if(check(mid,a,b,c,n) && (mid%a==0 || mid%b==0 || mid%c==0))\\n             {\\n                 return mid;\\n             }\\n             else\\n             {\\n                 if(check1(mid,a,b,c,n))\\n                 {\\n                     h = mid-1;\\n                 }\\n                 else\\n                 {\\n                     l = mid+1;\\n                 }\\n             }\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2096817,
                "title": "c-binary-search-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, int A, int B, int C) \\n    {\\n        int low=1,high=2*int(1e9);\\n        long a=long(A), b=long(B), c=long(C);\\n        long ab=a*b/__gcd(a,b);\\n        long bc=b*c/__gcd(b,c);\\n        long ac=a*c/__gcd(a,c);\\n        long abc=a*bc/__gcd(a,bc);\\n        while(low<high)\\n        {\\n            int mid=low+(high-low)/2;\\n            int cnt=mid/a+mid/b+mid/c-mid/ab-mid/bc-mid/ac+mid/abc;\\n            if(cnt<n)\\n            {\\n                low=mid+1;\\n            }\\n            else\\n            {\\n                high=mid;\\n            }\\n        }\\n        return low;\\n        \\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    int nthUglyNumber(int n, int A, int B, int C) \\n    {\\n        int low=1,high=2*int(1e9);\\n        long a=long(A), b=long(B), c=long(C);\\n        long ab=a*b/__gcd(a,b);\\n        long bc=b*c/__gcd(b,c);\\n        long ac=a*c/__gcd(a,c);\\n        long abc=a*bc/__gcd(a,bc);\\n        while(low<high)\\n        {\\n            int mid=low+(high-low)/2;\\n            int cnt=mid/a+mid/b+mid/c-mid/ab-mid/bc-mid/ac+mid/abc;\\n            if(cnt<n)\\n            {\\n                low=mid+1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2015286,
                "title": "c-solution-with-binary-search",
                "content": "```\\nlong gcd(long a, long b) {\\n    return a ? gcd(b % a, a) : b;\\n}\\n\\nlong lcm(long a, long b) {\\n    return a * b / gcd(a, b);\\n}\\n\\nint uglyNumbers(long m, long a, long b, long c) {\\n    long lcmab = lcm(a, b);\\n    long lcmac = lcm(a, c);\\n    long lcmbc = lcm(b, c);\\n    long lcmabc = lcm(lcmab, c);\\n    return (int)(m / a + m / b + m /c - m / lcmab - m / lcmac - m / lcmbc + m / lcmabc);\\n}\\n\\nint nthUglyNumber(int n, int a, int b, int c){\\n    int left = 1, right = 2e9;\\n    while(left < right) \\n    {\\n        int mid = left + (right - left) / 2;\\n        if (uglyNumbers(mid, a, b, c) >= n)\\n            right = mid;\\n        else\\n            left = mid + 1;\\n    }\\n    return left;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nlong gcd(long a, long b) {\\n    return a ? gcd(b % a, a) : b;\\n}\\n\\nlong lcm(long a, long b) {\\n    return a * b / gcd(a, b);\\n}\\n\\nint uglyNumbers(long m, long a, long b, long c) {\\n    long lcmab = lcm(a, b);\\n    long lcmac = lcm(a, c);\\n    long lcmbc = lcm(b, c);\\n    long lcmabc = lcm(lcmab, c);\\n    return (int)(m / a + m / b + m /c - m / lcmab - m / lcmac - m / lcmbc + m / lcmabc);\\n}\\n\\nint nthUglyNumber(int n, int a, int b, int c){\\n    int left = 1, right = 2e9;\\n    while(left < right) \\n    {\\n        int mid = left + (right - left) / 2;\\n        if (uglyNumbers(mid, a, b, c) >= n)\\n            right = mid;\\n        else\\n            left = mid + 1;\\n    }\\n    return left;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1997183,
                "title": "100-0ms-easy-simple-concise",
                "content": "```\\npublic class Solution {\\n    int MAX_ANS = (int) 2e9; // 2*10^9\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        int left = 0, right = MAX_ANS, result = 0;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (count(mid, a, b, c) >= n) {\\n                result = mid;\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return result;\\n    }\\n    int count(long num, long a, long b, long c) {\\n        return (int) (num / a + num / b + num / c\\n                - num / lcm(a, b)\\n                - num / lcm(b, c)\\n                - num / lcm(a, c)\\n                + num / (lcm(a, lcm(b, c))));\\n    }\\n    long gcd(long a, long b) {\\n        if (a == 0) return b;\\n        return gcd(b % a, a);\\n    }\\n    long lcm(long a, long b) {\\n        return a * b / gcd(a, b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Go",
                    "PHP"
                ],
                "code": "```\\npublic class Solution {\\n    int MAX_ANS = (int) 2e9; // 2*10^9\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        int left = 0, right = MAX_ANS, result = 0;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (count(mid, a, b, c) >= n) {\\n                result = mid;\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return result;\\n    }\\n    int count(long num, long a, long b, long c) {\\n        return (int) (num / a + num / b + num / c\\n                - num / lcm(a, b)\\n                - num / lcm(b, c)\\n                - num / lcm(a, c)\\n                + num / (lcm(a, lcm(b, c))));\\n    }\\n    long gcd(long a, long b) {\\n        if (a == 0) return b;\\n        return gcd(b % a, a);\\n    }\\n    long lcm(long a, long b) {\\n        return a * b / gcd(a, b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1940748,
                "title": "0ms-java-simple-clear-explaination-in-code-binary-search",
                "content": "``` \\n//just tried to explain as much as I can. Upvote if it helped. thanks\\nclass Solution {\\n  \\n    long lcmOfAC;\\n    long lcmOfAB;\\n    long lcmOfBC;\\n    long lcmOfABC;\\n  \\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        \\n      lcmOfAC  = lcm(a,c);\\n      lcmOfAB  = lcm(a,b);\\n      lcmOfBC  = lcm(b,c);\\n      lcmOfABC = lcm(a,lcmOfBC);\\n      \\n      int left = 1;\\n      int right = Integer.MAX_VALUE;\\n      \\n      \\n      //how BS works here: If our count of ugly numbers before the value of \\'mid\\'\\n      //is greater or equal we decrease right. \\n      //And when we have exactly \\'n-1\\' on the left side, our answer is \\'left\\', \\n      //meaning that left is the number which is at ((n-1)+1) th position.\\n      \\n      \\n      /// MOST IMPORTANT THING TO UNDERSTAND HERE IS: HOW DOES HOW MANY UGLY NUMBERS ARE THERE BEFORE \\'MID\\' GIVES THE NTH UGLY NUMBER??? WE ARE JUST COUNTING NUMBERS RIGHT?? HOW DOES IT EVEN WORK??\\n      /*\\n        LET ME EXPLAIN: FOR EXAMPLE TEST-CASE 1: \\n        \\n        N = 3, A = 2, B = 3, C = 5. CLEAR HERE.\\n        \\n        NOW TAKE A SERIES OF N NATURAL NUMBERS. LIKE:\\n        \\n        1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21...\\n        \\n        NOW FOR 2 IT\\'S: 2 4 6 8 10 12 14 16...\\n                 FOR 3: 3 6 9 12 15 18\\n                 FOR 5: 5 10 15 20 25.....\\n                 \\n        //WITH THIS LINE: long total = mid/a + mid/b + mid/c - mid/lcmOfAB - mid/lcmOfBC - mid/lcmOfAC + mid/lcmOfABC;        \\n        //WE ARE ADDING EVERY UNIQUE MULTIPLE OF ALL OF THE THREE ONLY ONE TIME.\\n        \\n        //SO OUR FINAL N-NATURAL NUMBER SERIES BECOMES:  //EVERY DUPLICATE IS REMOVED.\\n          1, 2, 3, 4, 5, 6, 8, 9, 10... (SAME AS PROVIDED IN TEST CASE) //EVERY NUMBER IS UNIQUE AND INCREASING. //ONE IS INCLUDED BECAUSE LEFT = 1.\\n          \\n        //KEEP-IN-MIND, BY COUNTING WE ARE SAYING - HOW MANY UGLY NUMBERS APPEAR BEFORE THIS \\'MID\\'\\n        // WE ARE SAYING IF THERE ARE \"n-1\" UGLY NUMBERS BEFORE THAN \"n\" IS OUR ANSWER. HERE \"LEFT\" IS THAT \"N\"\\n\\n        // SO IF OUR MID IS FINALLY AT LET SAY \\'5\\', WE DECREASE OUR RIGHT TO \\'MID\\' (RIGHT = MID),\\n        // BECAUSE TOTAL NUMBERS BEFORE 5 ARE 3 (1,2,3,4).\\n        \\n        //THIS PROCESS KEEPS GOING UNTIL MID IS AT 3, AND COUNT < N WHICH MEANS LEFT = MID+1 (3+1) = 4;\\n        \\n        //TRY TO THINK IN YOUR WAY A LITTLE MORE IF YOU STILL DON\\'T GET IT.\\n          \\n      */\\n      \\n      \\n      \\n      while(left<right){\\n        \\n        int mid = left+(right-left)/2;\\n\\n        if(count(mid, a, b, c, n)){\\n          right = mid;\\n        }\\n        \\n        else\\n          left = mid+1;        \\n      }\\n      \\n      return left;      \\n    }\\n  \\n   \\n    \\n    boolean count(long mid, long a, long b, long c, long n){\\n      \\n      \\n\\t\\t/*\\n\\t\\t*   mid/a = total number of multiples \\'a\\' till chosen \\'mid\\'. //same for \\'b\\' and \\'c\\'.\\n\\t\\t*  \\n\\t\\t*   mid/lcm(a,b) = total number of duplicate multiples that appear for series of \\'a\\' and \\'b\\'  // same for (b,c) & (c,a)      \\n\\t\\t*   \\n\\t\\t*   now because we subtract all the common mulitples  that appear for all three \\'a\\' & \\'b\\' & \\'c\\'\\n\\n\\t\\t*   we\\'ll have to again add those who appear in all three series again (check below comment)\\n\\t\\t*/      \\n\\t\\t /* example: \\n\\n\\t\\t\\t\\tfor 2:- 2 4 6 8 10 12 14\\n\\t\\t\\t\\tfor 3:- 3 9 12 15 18 21\\n\\t\\t\\t\\tfor 4:- 4 8 12\\n\\n\\t\\t\\t\\t//now notice that \\'12\\' is common in all of them, it should be counted only \\'once\\', not \\'thrice\\'.\\n\\t\\t\\t\\t// same goes for \\'4\\', it appeared 2 times, we want to count only \\'one\\' time.\\n\\n\\t\\t\\t\\t// this is why we subtracted  all common duplicates first, then lastly add the lcm(a,lcm(b,c)) //simply say -  lcm(a,b,c)\\n\\t\\t\\t\\t// we do this last \\'add\\' step because we have already subtracted all duplicates that are common.\\n\\t\\t\\t\\t// so to add those who are common in \"all three series\" (like 12 here), we do this last  \\'+ lcm(a,b,c)\\' step.\\n\\t\\t*/\\n\\t\\t\\n     \\n      long total = mid/a + mid/b + mid/c - mid/lcmOfAB - mid/lcmOfBC - mid/lcmOfAC + mid/lcmOfABC;\\n      \\n      return total >= n;\\n      \\n    }\\n  \\n  \\n    static long gcd(long a,long b){\\n      while(b>0){\\n        a%=b;\\n        //swap\\n        long temp = a;\\n        a = b;\\n        b = temp;\\n      }\\n      return a;\\n    }\\n\\n    static long lcm(long a, long b){\\n      \\n      return a/gcd(a,b)*b;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "``` \\n//just tried to explain as much as I can. Upvote if it helped. thanks\\nclass Solution {\\n  \\n    long lcmOfAC;\\n    long lcmOfAB;\\n    long lcmOfBC;\\n    long lcmOfABC;\\n  \\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        \\n      lcmOfAC  = lcm(a,c);\\n      lcmOfAB  = lcm(a,b);\\n      lcmOfBC  = lcm(b,c);\\n      lcmOfABC = lcm(a,lcmOfBC);\\n      \\n      int left = 1;\\n      int right = Integer.MAX_VALUE;\\n      \\n      \\n      //how BS works here: If our count of ugly numbers before the value of \\'mid\\'\\n      //is greater or equal we decrease right. \\n      //And when we have exactly \\'n-1\\' on the left side, our answer is \\'left\\', \\n      //meaning that left is the number which is at ((n-1)+1) th position.\\n      \\n      \\n      /// MOST IMPORTANT THING TO UNDERSTAND HERE IS: HOW DOES HOW MANY UGLY NUMBERS ARE THERE BEFORE \\'MID\\' GIVES THE NTH UGLY NUMBER??? WE ARE JUST COUNTING NUMBERS RIGHT?? HOW DOES IT EVEN WORK??\\n      /*\\n        LET ME EXPLAIN: FOR EXAMPLE TEST-CASE 1: \\n        \\n        N = 3, A = 2, B = 3, C = 5. CLEAR HERE.\\n        \\n        NOW TAKE A SERIES OF N NATURAL NUMBERS. LIKE:\\n        \\n        1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21...\\n        \\n        NOW FOR 2 IT\\'S: 2 4 6 8 10 12 14 16...\\n                 FOR 3: 3 6 9 12 15 18\\n                 FOR 5: 5 10 15 20 25.....\\n                 \\n        //WITH THIS LINE: long total = mid/a + mid/b + mid/c - mid/lcmOfAB - mid/lcmOfBC - mid/lcmOfAC + mid/lcmOfABC;        \\n        //WE ARE ADDING EVERY UNIQUE MULTIPLE OF ALL OF THE THREE ONLY ONE TIME.\\n        \\n        //SO OUR FINAL N-NATURAL NUMBER SERIES BECOMES:  //EVERY DUPLICATE IS REMOVED.\\n          1, 2, 3, 4, 5, 6, 8, 9, 10... (SAME AS PROVIDED IN TEST CASE) //EVERY NUMBER IS UNIQUE AND INCREASING. //ONE IS INCLUDED BECAUSE LEFT = 1.\\n          \\n        //KEEP-IN-MIND, BY COUNTING WE ARE SAYING - HOW MANY UGLY NUMBERS APPEAR BEFORE THIS \\'MID\\'\\n        // WE ARE SAYING IF THERE ARE \"n-1\" UGLY NUMBERS BEFORE THAN \"n\" IS OUR ANSWER. HERE \"LEFT\" IS THAT \"N\"\\n\\n        // SO IF OUR MID IS FINALLY AT LET SAY \\'5\\', WE DECREASE OUR RIGHT TO \\'MID\\' (RIGHT = MID),\\n        // BECAUSE TOTAL NUMBERS BEFORE 5 ARE 3 (1,2,3,4).\\n        \\n        //THIS PROCESS KEEPS GOING UNTIL MID IS AT 3, AND COUNT < N WHICH MEANS LEFT = MID+1 (3+1) = 4;\\n        \\n        //TRY TO THINK IN YOUR WAY A LITTLE MORE IF YOU STILL DON\\'T GET IT.\\n          \\n      */\\n      \\n      \\n      \\n      while(left<right){\\n        \\n        int mid = left+(right-left)/2;\\n\\n        if(count(mid, a, b, c, n)){\\n          right = mid;\\n        }\\n        \\n        else\\n          left = mid+1;        \\n      }\\n      \\n      return left;      \\n    }\\n  \\n   \\n    \\n    boolean count(long mid, long a, long b, long c, long n){\\n      \\n      \\n\\t\\t/*\\n\\t\\t*   mid/a = total number of multiples \\'a\\' till chosen \\'mid\\'. //same for \\'b\\' and \\'c\\'.\\n\\t\\t*  \\n\\t\\t*   mid/lcm(a,b) = total number of duplicate multiples that appear for series of \\'a\\' and \\'b\\'  // same for (b,c) & (c,a)      \\n\\t\\t*   \\n\\t\\t*   now because we subtract all the common mulitples  that appear for all three \\'a\\' & \\'b\\' & \\'c\\'\\n\\n\\t\\t*   we\\'ll have to again add those who appear in all three series again (check below comment)\\n\\t\\t*/      \\n\\t\\t /* example: \\n\\n\\t\\t\\t\\tfor 2:- 2 4 6 8 10 12 14\\n\\t\\t\\t\\tfor 3:- 3 9 12 15 18 21\\n\\t\\t\\t\\tfor 4:- 4 8 12\\n\\n\\t\\t\\t\\t//now notice that \\'12\\' is common in all of them, it should be counted only \\'once\\', not \\'thrice\\'.\\n\\t\\t\\t\\t// same goes for \\'4\\', it appeared 2 times, we want to count only \\'one\\' time.\\n\\n\\t\\t\\t\\t// this is why we subtracted  all common duplicates first, then lastly add the lcm(a,lcm(b,c)) //simply say -  lcm(a,b,c)\\n\\t\\t\\t\\t// we do this last \\'add\\' step because we have already subtracted all duplicates that are common.\\n\\t\\t\\t\\t// so to add those who are common in \"all three series\" (like 12 here), we do this last  \\'+ lcm(a,b,c)\\' step.\\n\\t\\t*/\\n\\t\\t\\n     \\n      long total = mid/a + mid/b + mid/c - mid/lcmOfAB - mid/lcmOfBC - mid/lcmOfAC + mid/lcmOfABC;\\n      \\n      return total >= n;\\n      \\n    }\\n  \\n  \\n    static long gcd(long a,long b){\\n      while(b>0){\\n        a%=b;\\n        //swap\\n        long temp = a;\\n        a = b;\\n        b = temp;\\n      }\\n      return a;\\n    }\\n\\n    static long lcm(long a, long b){\\n      \\n      return a/gcd(a,b)*b;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1622570,
                "title": "c-textbook-binary-search-beat-100",
                "content": "```\\n//https://leetcode.com/problems/ugly-number-iii/discuss/387539/cpp-Binary-Search-with-picture-and-Binary-Search-Template\\n#define ll long long \\nclass Solution {\\npublic:\\n    // Binary search \\n    int nthUglyNumber(int N, int A, int B, int C) {\\n        \\n        ll n = N; ll a = A; ll b = B; ll c = C;\\n        \\n        ll low = 1;\\n        ll high = INT_MAX;\\n        \\n        while(low <= high){\\n            \\n            ll mid = (low + high) >> 1;\\n            \\n            // Find the number of ugly numbers upto and including \\'mid\\'\\n            ll uglies = mid/a + mid/b + mid/c - mid/lcm(a,b) - mid/lcm(a,c) - mid/lcm(b,c) + mid/lcm(a,lcm(b,c));\\n            \\n\\t\\t\\t// if uglies >= n, then for all numbers >= mid, uglies will always be >= n \\n            if(uglies >= n) \\n                high = mid-1;\\n\\t\\t\\t\\n\\t\\t\\t// if uglies < n, then for all numbers<= mid, uglies will always be < n\\n            else \\n                low = mid+1;\\n\\t\\t\\t\\t\\n\\t\\t/*\\n\\t\\tHere, the predicate function F(mid)  = True if uglies >= n\\n\\t\\tHence the search space will be like\\n\\t\\t\\n\\t\\tF F F F F F F F T T T T T T T T\\n\\t\\t\\n\\t\\tHence we apply binary search\\n\\t\\t*/\\n        }\\n        \\n        return low; \\n            \\n    }\\n    \\n    \\n    ll lcm(ll x, ll y){\\n        //finds the lcm of x and y\\n        // LCM(x,y) = (x*y) / GCD(x,y)\\n        \\n        return (x*y) / __gcd(x,y);\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//https://leetcode.com/problems/ugly-number-iii/discuss/387539/cpp-Binary-Search-with-picture-and-Binary-Search-Template\\n#define ll long long \\nclass Solution {\\npublic:\\n    // Binary search \\n    int nthUglyNumber(int N, int A, int B, int C) {\\n        \\n        ll n = N; ll a = A; ll b = B; ll c = C;\\n        \\n        ll low = 1;\\n        ll high = INT_MAX;\\n        \\n        while(low <= high){\\n            \\n            ll mid = (low + high) >> 1;\\n            \\n            // Find the number of ugly numbers upto and including \\'mid\\'\\n            ll uglies = mid/a + mid/b + mid/c - mid/lcm(a,b) - mid/lcm(a,c) - mid/lcm(b,c) + mid/lcm(a,lcm(b,c));\\n            \\n\\t\\t\\t// if uglies >= n, then for all numbers >= mid, uglies will always be >= n \\n            if(uglies >= n) \\n                high = mid-1;\\n\\t\\t\\t\\n\\t\\t\\t// if uglies < n, then for all numbers<= mid, uglies will always be < n\\n            else \\n                low = mid+1;\\n\\t\\t\\t\\t\\n\\t\\t/*\\n\\t\\tHere, the predicate function F(mid)  = True if uglies >= n\\n\\t\\tHence the search space will be like\\n\\t\\t\\n\\t\\tF F F F F F F F T T T T T T T T\\n\\t\\t\\n\\t\\tHence we apply binary search\\n\\t\\t*/\\n        }\\n        \\n        return low; \\n            \\n    }\\n    \\n    \\n    ll lcm(ll x, ll y){\\n        //finds the lcm of x and y\\n        // LCM(x,y) = (x*y) / GCD(x,y)\\n        \\n        return (x*y) / __gcd(x,y);\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1622523,
                "title": "binary-search-with-venn-diagram-in-python-time-o-log-n-min-a-b-c-space-o-1",
                "content": "https://leetcode.com/problems/nth-magical-number/solution/\\nThere is a similar problem and you can see the solution in the problem above to deepen your understanding.\\n\\nget_lcm is a self-made function to get the least common multiple of all the arguments.\\n\\n```\\nfrom math import gcd\\n\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        def num_of_ugly_below(val):\\n            return (val // a) + (val // b) + (val // c) - (val // lcm_ab) - (val // lcm_bc) - (val // lcm_ca) + (val // lcm_abc)\\n        \\n        def get_lcm(*vals):\\n            res = vals[0]\\n            for i in range(1, len(vals)):\\n                res = res * vals[i] // gcd(res, vals[i])\\n            return res\\n        \\n        lcm_ab, lcm_bc, lcm_ca, lcm_abc = get_lcm(a, b), get_lcm(b, c), get_lcm(c, a), get_lcm(a, b, c)\\n        \\n        #binary search\\n        l, r = 1, min(a, b, c) * n\\n        while l < r:\\n            mid = (l + r) // 2\\n            if num_of_ugly_below(mid) < n:\\n                l = mid + 1\\n            else:\\n                r = mid\\n        return l\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nfrom math import gcd\\n\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        def num_of_ugly_below(val):\\n            return (val // a) + (val // b) + (val // c) - (val // lcm_ab) - (val // lcm_bc) - (val // lcm_ca) + (val // lcm_abc)\\n        \\n        def get_lcm(*vals):\\n            res = vals[0]\\n            for i in range(1, len(vals)):\\n                res = res * vals[i] // gcd(res, vals[i])\\n            return res\\n        \\n        lcm_ab, lcm_bc, lcm_ca, lcm_abc = get_lcm(a, b), get_lcm(b, c), get_lcm(c, a), get_lcm(a, b, c)\\n        \\n        #binary search\\n        l, r = 1, min(a, b, c) * n\\n        while l < r:\\n            mid = (l + r) // 2\\n            if num_of_ugly_below(mid) < n:\\n                l = mid + 1\\n            else:\\n                r = mid\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1159919,
                "title": "easy-python-solution",
                "content": "```\\nimport math\\n\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        minimum = min(a, b, c)\\n        left = minimum; right = n*minimum\\n        l1 = (a*b)//math.gcd(a, b)\\n        l2 = (b*c)//math.gcd(b, c)\\n        l3 = (c*a)//math.gcd(c, a)\\n        l4 = l1*c//math.gcd(l1, c)\\n        while left <= right:\\n            mid = left + (right-left)//2\\n            pos = mid//a + mid//b + mid//c - mid//l1 - mid//l2 - mid//l3 + mid//l4\\n            if pos > n:\\n                right = mid - 1\\n            elif pos < n:\\n                left = mid + 1\\n            else:\\n                if mid%a == 0 or mid%b == 0 or mid%c == 0:\\n                    return mid\\n                else:\\n                    right = mid - 1 \\n ```",
                "solutionTags": [],
                "code": "```\\nimport math\\n\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        minimum = min(a, b, c)\\n        left = minimum; right = n*minimum\\n        l1 = (a*b)//math.gcd(a, b)\\n        l2 = (b*c)//math.gcd(b, c)\\n        l3 = (c*a)//math.gcd(c, a)\\n        l4 = l1*c//math.gcd(l1, c)\\n        while left <= right:\\n            mid = left + (right-left)//2\\n            pos = mid//a + mid//b + mid//c - mid//l1 - mid//l2 - mid//l3 + mid//l4\\n            if pos > n:\\n                right = mid - 1\\n            elif pos < n:\\n                left = mid + 1\\n            else:\\n                if mid%a == 0 or mid%b == 0 or mid%c == 0:\\n                    return mid\\n                else:\\n                    right = mid - 1 \\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1128338,
                "title": "python3-using-binary-search-100-memory-and-70-faster",
                "content": "```\\nclass Solution:\\n    def gcd(self, m, n):\\n        if m == n:\\n            return m\\n        \\n        if n == 0:\\n            return m\\n        \\n        result = 0\\n        while 1:\\n            r = m % n\\n            if r == 0:\\n                result = n\\n                break\\n            m = n\\n            n = r\\n        return result\\n    \\n    def lcm(self, a, b):\\n        return (a * b) // self.gcd(a, b)\\n    \\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:   \\n        def count_ugly(mid):\\n            \"\"\"Using set theory\\n            C -> count;\\n            Formula: C(a \\u222A b \\u222A c) = (C(a) + C(b) + C(c)) - (C(a \\u2229 b) + C(a \\u2229 c) + C(b \\u2229 c)) + C(a \\u2229 b \\u2229 c)\\n            \"\"\"\\n            single = ((mid // a) + (mid // b) + (mid // c))\\n            double = ((mid // self.lcm(a, b)) + (mid // self.lcm(a, c)) + (mid // self.lcm(b, c)))\\n            tripple = mid // self.lcm(self.lcm(a, b), c)\\n            return single - double + tripple\\n            \\n        def binary_search():\\n            \"\"\"use binary search to find the nth count\"\"\"\\n            low = 1\\n            high = 2**31 - 1 # set it as high as possible\\n            \\n            while low < high:\\n                mid = (low + high) >> 1\\n                count = count_ugly(mid)\\n\\n                if count < n:\\n                    low = mid + 1\\n                elif count > n:\\n                    high = mid - 1\\n                else:\\n                    if mid % a != 0 and mid % b != 0 and mid % c != 0:\\n                        high = mid - 1\\n                    else:\\n                        return mid\\n            return low\\n        return binary_search()\\n\\t\\t\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def gcd(self, m, n):\\n        if m == n:\\n            return m\\n        \\n        if n == 0:\\n            return m\\n        \\n        result = 0\\n        while 1:\\n            r = m % n\\n            if r == 0:\\n                result = n\\n                break\\n            m = n\\n            n = r\\n        return result\\n    \\n    def lcm(self, a, b):\\n        return (a * b) // self.gcd(a, b)\\n    \\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:   \\n        def count_ugly(mid):\\n            \"\"\"Using set theory\\n            C -> count;\\n            Formula: C(a \\u222A b \\u222A c) = (C(a) + C(b) + C(c)) - (C(a \\u2229 b) + C(a \\u2229 c) + C(b \\u2229 c)) + C(a \\u2229 b \\u2229 c)\\n            \"\"\"\\n            single = ((mid // a) + (mid // b) + (mid // c))\\n            double = ((mid // self.lcm(a, b)) + (mid // self.lcm(a, c)) + (mid // self.lcm(b, c)))\\n            tripple = mid // self.lcm(self.lcm(a, b), c)\\n            return single - double + tripple\\n            \\n        def binary_search():\\n            \"\"\"use binary search to find the nth count\"\"\"\\n            low = 1\\n            high = 2**31 - 1 # set it as high as possible\\n            \\n            while low < high:\\n                mid = (low + high) >> 1\\n                count = count_ugly(mid)\\n\\n                if count < n:\\n                    low = mid + 1\\n                elif count > n:\\n                    high = mid - 1\\n                else:\\n                    if mid % a != 0 and mid % b != 0 and mid % c != 0:\\n                        high = mid - 1\\n                    else:\\n                        return mid\\n            return low\\n        return binary_search()\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 698709,
                "title": "c-100-fast-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    long long int gcdFind(long long int a, long long int b)\\n    {\\n        if(b == 0)\\n            return a;\\n        return gcdFind(b, a % b);\\n    }\\n    \\n    long long int lcm(long long int a, long long int b)\\n    {\\n        long long int gcd = gcdFind(a, b);\\n        return (a*b) / gcd;\\n    }\\n    \\n    long long int find(int a, int b, int c, long long int no)\\n    {\\n        long long int individuals = 0;\\n        individuals += no/a;\\n        individuals += no/b;\\n        individuals += no/c;\\n        \\n        long long int doubles = 0;\\n        doubles += (no /lcm(a,b));\\n        doubles += (no /lcm(b,c));\\n        doubles += (no /lcm(c,a));\\n        \\n        long long int triples = 0;\\n        triples += (no/lcm(lcm(a,b),c));\\n        \\n        return individuals - doubles + triples;\\n    }\\n    \\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        long long int l, r, mid;\\n        l = 1;\\n        r = 2 * 1e9;\\n        \\n        while(l < r)\\n        {\\n            mid = (l+r)/2;\\n            long long int res = find(a, b, c, mid);\\n            if(find(a, b, c, mid) >= n)\\n            {\\n               r = mid;\\n            }\\n            else\\n            {\\n               l = mid+1;\\n            }\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long int gcdFind(long long int a, long long int b)\\n    {\\n        if(b == 0)\\n            return a;\\n        return gcdFind(b, a % b);\\n    }\\n    \\n    long long int lcm(long long int a, long long int b)\\n    {\\n        long long int gcd = gcdFind(a, b);\\n        return (a*b) / gcd;\\n    }\\n    \\n    long long int find(int a, int b, int c, long long int no)\\n    {\\n        long long int individuals = 0;\\n        individuals += no/a;\\n        individuals += no/b;\\n        individuals += no/c;\\n        \\n        long long int doubles = 0;\\n        doubles += (no /lcm(a,b));\\n        doubles += (no /lcm(b,c));\\n        doubles += (no /lcm(c,a));\\n        \\n        long long int triples = 0;\\n        triples += (no/lcm(lcm(a,b),c));\\n        \\n        return individuals - doubles + triples;\\n    }\\n    \\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        long long int l, r, mid;\\n        l = 1;\\n        r = 2 * 1e9;\\n        \\n        while(l < r)\\n        {\\n            mid = (l+r)/2;\\n            long long int res = find(a, b, c, mid);\\n            if(find(a, b, c, mid) >= n)\\n            {\\n               r = mid;\\n            }\\n            else\\n            {\\n               l = mid+1;\\n            }\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 550836,
                "title": "the-question-is-similar-to-lc-878",
                "content": "The question is similar to LC[878](https://leetcode.com/problems/nth-magical-number/)\\n```cpp\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, int A, int B, int C) {\\n        long left = 1, right = 2*1e9;\\n        long a = long(A), b = long(B), c = long(C);\\n        long ab = a*b/__gcd(a, b);\\n        long ac = a*c/__gcd(a, c);\\n        long bc = b*c/__gcd(b, c);\\n        long abc = a*bc/__gcd(a, bc);\\n        while(left < right)\\n        {\\n            long mid = left + (right - left)/2;\\n            int cnt = mid/a+mid/b+mid/c+mid/abc-mid/ab-mid/ac-mid/bc;\\n            if(cnt < n)left = mid+1;\\n            else right = mid;\\n        }\\n        return left;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int nthUglyNumber(int n, int A, int B, int C) {\\n        long left = 1, right = 2*1e9;\\n        long a = long(A), b = long(B), c = long(C);\\n        long ab = a*b/__gcd(a, b);\\n        long ac = a*c/__gcd(a, c);\\n        long bc = b*c/__gcd(b, c);\\n        long abc = a*bc/__gcd(a, bc);\\n        while(left < right)\\n        {\\n            long mid = left + (right - left)/2;\\n            int cnt = mid/a+mid/b+mid/c+mid/abc-mid/ab-mid/ac-mid/bc;\\n            if(cnt < n)left = mid+1;\\n            else right = mid;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 523246,
                "title": "java-o-logn-solution-from-the-view-of-set-0ms-beats-100",
                "content": "Explain from the view of sets union and intersection.\\n\\n# Structure of the problem\\nThis ulgy number problem actually has a beautiful math structure.\\n\\nLet `A`,`B`,`C` denote the 3 base integers, then for any number `N>=1`, it is an ugly number if and only if `N%A==0`, `N%B==0` or `N%C==0`, here `%` means taking the modulus.\\n\\nNow let\\'s consider given a number `N>=1`, how many **unique** ugly number is there in range `[1,N]`. Let\\'s try to write all possible ugly numbers:\\n\\n`SA = {A  2A 3A  .... r*A}...N`\\n\\n`SB = {B  2B 3B .... p*B}...N`\\n\\n`SC = {C  2C  3C .... q*C}...N`\\n\\nIn the above representation, we use `r*A`,`p*B`,`q*C` to denote the biggest number nearest to N(less than or equals to N), and `SA`, `SB`, `SC` to denote three sets for each base integer.\\n\\n\\nThen the count of unique ugly number is `|SA\\u222ASB\\u222ASC|`, which expands to \\n\\n`|SA\\u222ASB\\u222ASC|=|SA| + |SB| + |SC| - |SA \\u2229 SB| - |SA \\u2229 SC| - |SB \\u2229 SC| + |SA \\u2229 SB \\u2229 SC|`.\\n\\n# Calculation of |SA|\\nWe know that `|SA| = r = floor(N/A)`, `|SB| = p = floor(N/B)`,`|SC| = q = floor(N/C)`.\\n\\n\\n# Calculation of |SA \\u2229 SB|\\nNow lets consider how to calculate `|SA \\u2229 SB|`. Let `e \\u2208 (SA \\u2229 SB)`, then `e` can be both divided by `A` and `B`, let `e=i*A=j*B`, our task is to find how many `i` is there in `[1,r]`. \\n\\nlet `d` be the biggest common factor for `A` and `B`, i.e. `d=gcd(A,B)`, and let `Ax=A/d`, `Bx=B/d`, then we divide `d` in both sides, getting the following equation: `i*Ax=j*Bx`.\\n\\nBecause `Ax`,`Bx` have no common factor except `1`, then must `i` be multiple of `Bx` to make the equation true.\\n\\nThen we known that `i%Bx==0`.Let `i=h*Bx`, thus `1<= (e==h*Bx*A)  <=N`,\\n\\ni.e.  \\n\\n`1/(Bx*A) <= h <= N/(Bx*A)`,  \\n\\nwe know that there is `floor(N/(Bx*A))` possible values for `h`, thus `|SA \\u2229 SB| = floor(N/(Bx*A)) = floor(N/(B/gcd(A,B)*A))`.\\n\\nAnd similarly `|SA \\u2229 SC| = floor(N/(C/gcd(A,C)*A))`,  `|SB \\u2229 SC| = floor(N/(C/gcd(B,C)*B))`.\\n\\n# Calculation of |SA \\u2229 SB \\u2229 SC|\\nSimilarly lets consider `e \\u2208 (SA \\u2229 SB \\u2229 SC)`, then there exists some `i`,`j`,`k` such that `e=i*A=j*B=k*C`.\\n\\nLet `Bx = B/gcd(A,B)`, `Cx = C/gcd(A,C)`, then divide `gcd(A,B)`,`gcd(A,C)` in each side,we know that `i` is a multiple of `Bx`, and also a multiple of `Cx`, which means `i` is minimal common multiple of `Bx`,`Cx`, which is `Bx*Cx/gcd(Bx,Cx)`, let `i = h*Bx*Cx/gcd(Bx,Cx)`.\\n\\nThen we know that `1 <= (e==A*i==A*h*Bx*Cx/gcd(Bx,Cx)) <= N`, then `|SA \\u2229 SB \\u2229 SC| = floor(N*gcd(Bx,Cx)/(A*Bx*Cx)) = floor(N*gcd(gcd(A,B),gcd(B,C))/(A*gcd(A,B)*gcd(A,C)))`.\\n\\nAnd because `|SA \\u2229 SB| = |SA \\u2229 SB \\u2229 SA|`, it can also be epxressed in this form.\\n\\n\\n# Binary Search to Find the Nearest Number `N`\\nOur task is to find the `n`th ugly number, we known `n` must exist, so we search from `1` to `n*a`, this could be done by a binary search.\\n\\n# Code(0ms,beats 100%)\\n```java\\nclass Solution {\\n    public int nthUglyNumber(int n,int a,int b,int c) {\\n        long  min=Math.min(Math.min(a,b),c);\\n        long r=1;\\n        long p=min*n;\\n        \\n        while(r<=p){\\n            long m=r+((p-r)/2);\\n            long s=count(m,a,b,c);\\n            if(s==n)return (int)Math.max(Math.max(m/a*a,m/b*b),m/c*c);\\n            else if(s<n) r=m+1;\\n            else p=m-1;\\n\\n        }\\n        throw new IllegalArgumentException(\"n is too large\");\\n    }\\n\\n    long count(long N,int A,int B,int C){\\n        return N/A+N/B+N/C-countIntersection(N,A,B,A)-countIntersection(N,A,C,A)-countIntersection(N,B,C,B)+countIntersection(N,A,B,C);\\n    }\\n\\n    // |SA \\u2229 SB \\u2229 SC|, when A==C,|SA \\u2229 SB \\u2229 SC| = |SA \\u2229 SB|\\n    long countIntersection(long N,int A,int B,int C){\\n        int Bx=B/gcd(A,B);\\n        int Cx=C/gcd(A,C);\\n        int Dx=gcd(Bx,Cx);\\n        long F=(long)A*Bx*Cx;\\n        return Dx*N/F;\\n    }\\n\\n    int gcd(int x,int y){\\n        return y==0?x:gcd(y,x%y);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int nthUglyNumber(int n,int a,int b,int c) {\\n        long  min=Math.min(Math.min(a,b),c);\\n        long r=1;\\n        long p=min*n;\\n        \\n        while(r<=p){\\n            long m=r+((p-r)/2);\\n            long s=count(m,a,b,c);\\n            if(s==n)return (int)Math.max(Math.max(m/a*a,m/b*b),m/c*c);\\n            else if(s<n) r=m+1;\\n            else p=m-1;\\n\\n        }\\n        throw new IllegalArgumentException(\"n is too large\");\\n    }\\n\\n    long count(long N,int A,int B,int C){\\n        return N/A+N/B+N/C-countIntersection(N,A,B,A)-countIntersection(N,A,C,A)-countIntersection(N,B,C,B)+countIntersection(N,A,B,C);\\n    }\\n\\n    // |SA \\u2229 SB \\u2229 SC|, when A==C,|SA \\u2229 SB \\u2229 SC| = |SA \\u2229 SB|\\n    long countIntersection(long N,int A,int B,int C){\\n        int Bx=B/gcd(A,B);\\n        int Cx=C/gcd(A,C);\\n        int Dx=gcd(Bx,Cx);\\n        long F=(long)A*Bx*Cx;\\n        return Dx*N/F;\\n    }\\n\\n    int gcd(int x,int y){\\n        return y==0?x:gcd(y,x%y);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2686976,
                "title": "binary-search-with-simple-maths-logic-of-sets-and-union-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\nlong long check(long long mid, vector<long long> v, long long n)\\n{\\n    // lcm of a, b;\\n    long long a = v[0], b = v[1], c = v[2];\\n    long long lcmAB = a * b / __gcd(a, b);\\n    long long lcmBC = b * c / __gcd(b, c);\\n    long long lcmAC = a * c / __gcd(a, c);\\n    long long lcmABC = lcmAB * c / __gcd(lcmAB, c);\\n    long long cnt = mid / a;\\n    cnt += mid / b;\\n    cnt += mid / c;\\n    cnt -= mid / lcmAB;\\n    cnt -= mid / lcmBC;\\n    cnt -= mid / lcmAC;\\n    cnt += mid / lcmABC;\\n\\n    return cnt;\\n}\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n          vector<long long> v = {a, b, c};\\n    sort(v.begin(), v.end());\\n    long long st = 1, end = 1e18;\\n    // long long ans = end;\\n    long long ans = -1;\\n    while (st <= end)\\n    {\\n        long long mid = st + (end - st) / 2;\\n        long long pos = check(mid, v, n);\\n        if (pos == n)\\n        {\\n            ans = mid;\\n            break;\\n        }\\n        else if (pos > n)\\n            end = mid;\\n        else\\n            st = mid + 1;\\n    }\\n\\n    if (ans % a == 0 or ans % b == 0 or ans % c == 0)\\n        return ans;\\n    while (ans % a != 0 and ans % b != 0 and ans % c != 0)\\n        ans--;\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\nlong long check(long long mid, vector<long long> v, long long n)\\n{\\n    // lcm of a, b;\\n    long long a = v[0], b = v[1], c = v[2];\\n    long long lcmAB = a * b / __gcd(a, b);\\n    long long lcmBC = b * c / __gcd(b, c);\\n    long long lcmAC = a * c / __gcd(a, c);\\n    long long lcmABC = lcmAB * c / __gcd(lcmAB, c);\\n    long long cnt = mid / a;\\n    cnt += mid / b;\\n    cnt += mid / c;\\n    cnt -= mid / lcmAB;\\n    cnt -= mid / lcmBC;\\n    cnt -= mid / lcmAC;\\n    cnt += mid / lcmABC;\\n\\n    return cnt;\\n}\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n          vector<long long> v = {a, b, c};\\n    sort(v.begin(), v.end());\\n    long long st = 1, end = 1e18;\\n    // long long ans = end;\\n    long long ans = -1;\\n    while (st <= end)\\n    {\\n        long long mid = st + (end - st) / 2;\\n        long long pos = check(mid, v, n);\\n        if (pos == n)\\n        {\\n            ans = mid;\\n            break;\\n        }\\n        else if (pos > n)\\n            end = mid;\\n        else\\n            st = mid + 1;\\n    }\\n\\n    if (ans % a == 0 or ans % b == 0 or ans % c == 0)\\n        return ans;\\n    while (ans % a != 0 and ans % b != 0 and ans % c != 0)\\n        ans--;\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2634300,
                "title": "kotlin-explained-with-comments",
                "content": "**Problem**: find **n<sup>th</sup>** positive integer that is divisible by either **a**, **b** or **c**\\n\\nWhat if we can quickly calculate how many numbers are divisible by either **a**, **b** or **c** and less or equal to some number **k**? It is said that answer is not greater than `2 * 10^9` and we can do binary search in this range. Awesome! \\n\\nHow can we calculate for any **k**? Let\\'s build intuition step-by-step:\\n1. How many numbers divisible only by **a**? It\\'s **k / a**\\n2. How many numbers divisible by **a** or **b**? \\n2.1 For **a** it is **k / a**. \\n2.2 For **b** it is **k / b**. \\n2.3 Are there any numbers that can be calculated twice if we sum up **k / a** and **k / b**? Yes!\\n2.4 What numbers can be calculated twice? The ones divisible by **a** and **b** at the same time. For example, **a * b**, **2 * a * b**, **3 * a * b** and etc\\n2.5 Is **a * b** the smallest number divible by a and b at the same time? Not always!\\n2.6 What number is the smallest one? It is known as **[Least Common Multiple](https://en.wikipedia.org/wiki/Least_common_multiple)**. Let\\'s call it **lcm** so that least common multiple for **a** and **b** will be **lcm(a, b)**. It has properties like **lcm(a, b)** divides **a * b** and less or equal to** a * b**.\\n2.7 Any other numbers not counted or counted more than once? No. \\n2.8 Final count is **(k / a) + (k / b) - (k / lcm(a, b))**\\n3. How many numbers divisible by **a**, **b** or **c**?\\n3.1 Based on previous steps: **(k / a) + (k / b) + (k / c) - (k / lcm(a, b)) - (k / lcm(a, c)) - (k / lcm(b, c))**\\n3.2 Are there any numbers that not counted or counted more than once? Yes.\\n3.3 What numbers? For example, the ones divisible by **a**, **b** and **c** at the same time?\\n3.4 Why is it so? Let\\'s assume **k** is big enough so that **a * b * c** is equal or smaller then **k**: \\n3.4.1 Every multiple of **a** included into **k / a**. Since **a * (b * c)** is a **(b * c)-th** mutliple of **a**, **a * b * c** will be included into **(k / a)** if **k** big enough. This true for **b** with **(k / b)** and **c** with **(k / c)**. As a result of that **a * b * c** will be counted 3 times! \\n3.4.2 Since **lcm(a, b)** divides **a * b** then **a * b * c** is also divisible by **lcm(a, b)**. Since **k** is big enough, then **a * b * c** also counted in **k / lcm(a, b)** part of formula above. The same holds true to **k / lcm(a, c)** and **k / lcm(b, c)** parts. As a result of that, **a * b * c** will be subtracted 3 times and not counted at all!\\n3.4.3 Is **a * b * c** is the smallest number divisible by **a**, **b** and **c** at the same time? From the case for **a** and **b** only, it is [least common multiple](https://en.wikipedia.org/wiki/Least_common_multiple) for **a**, **b**, and **c**. Let\\'s call it **lcm(a, b, c)**. It has the same properties as in the case of 2 numbers: **lcm(a, b, c)** is smaller or equal to **a * b * c** and divides **a * b * c**. As a result of that, conclusions for **a * b * c** above holds true to **lcm(a, b, c)**\\n\\nFinal formula: **(k / a) + (k / b) + (k / c) - (k / lcm(a, b)) - (k / lcm(a, c)) - (k / lcm(b, c)) + (k / lcm(a, b, c))**\\n\\nComplexity: `O(log(range))`\\n```\\nclass Solution {\\n\\tfun nthUglyNumber(n: Int, _a: Int, _b: Int, _c: Int): Int {\\n\\t\\t// intermediate results can be bigger than `Int.MAX_VALUE`\\n\\t\\t// let\\'s convert to `Long`\\n\\t\\tval a = _a.toLong()\\n\\t\\tval b = _b.toLong()\\n\\t\\tval c = _c.toLong()\\n\\n\\t\\t// greatest common divisor\\n\\t\\tfun gcd(a: Long, b: Long): Long = if (a == 0L) b else gcd(b % a, a)\\n\\n\\t\\t// least common multiple\\n\\t\\tfun lcm(a: Long, b: Long): Long {\\n\\t\\t\\treturn a * b / gcd(a, b)\\n\\t\\t}\\n\\n\\t\\tval ab = lcm(a, b)\\n\\t\\tval bc = lcm(b, c)\\n\\t\\tval ac = lcm(a, c)\\n\\t\\t// lcm(a, b, c) = lcm(lcm(a, b), c)\\n\\t\\tval abc = lcm(ab, c)\\n\\n\\t\\tfun calc(n: Long): Long = n / a + n / b + n / c - n / ab - n / ac - n / bc + n / abc\\n\\n\\t\\tvar l = 1L\\n\\t\\t// Fact 1. As per description, result will fit into 2*10^9\\n\\t\\t// Fact 2. We need n-th number which is divisible by either a, b or c. n * minOf(a, b, c) is guarantee to be \\n\\t\\t// equal or bigger than the result we are looking for.\\n\\t\\t// Let\\'s grab minimum out of those values to decrease range for search \\n\\t\\tvar r = minOf(2_000_000_000L, n * minOf(a, b, c))\\n\\n\\t\\twhile (l < r) {\\n\\t\\t\\tval mid = (l + r) / 2\\n\\t\\t\\tif (calc(mid) >= n) r = mid else l = mid + 1\\n\\t\\t}\\n\\n\\t\\treturn l.toInt()\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n\\tfun nthUglyNumber(n: Int, _a: Int, _b: Int, _c: Int): Int {\\n\\t\\t// intermediate results can be bigger than `Int.MAX_VALUE`\\n\\t\\t// let\\'s convert to `Long`\\n\\t\\tval a = _a.toLong()\\n\\t\\tval b = _b.toLong()\\n\\t\\tval c = _c.toLong()\\n\\n\\t\\t// greatest common divisor\\n\\t\\tfun gcd(a: Long, b: Long): Long = if (a == 0L) b else gcd(b % a, a)\\n\\n\\t\\t// least common multiple\\n\\t\\tfun lcm(a: Long, b: Long): Long {\\n\\t\\t\\treturn a * b / gcd(a, b)\\n\\t\\t}\\n\\n\\t\\tval ab = lcm(a, b)\\n\\t\\tval bc = lcm(b, c)\\n\\t\\tval ac = lcm(a, c)\\n\\t\\t// lcm(a, b, c) = lcm(lcm(a, b), c)\\n\\t\\tval abc = lcm(ab, c)\\n\\n\\t\\tfun calc(n: Long): Long = n / a + n / b + n / c - n / ab - n / ac - n / bc + n / abc\\n\\n\\t\\tvar l = 1L\\n\\t\\t// Fact 1. As per description, result will fit into 2*10^9\\n\\t\\t// Fact 2. We need n-th number which is divisible by either a, b or c. n * minOf(a, b, c) is guarantee to be \\n\\t\\t// equal or bigger than the result we are looking for.\\n\\t\\t// Let\\'s grab minimum out of those values to decrease range for search \\n\\t\\tvar r = minOf(2_000_000_000L, n * minOf(a, b, c))\\n\\n\\t\\twhile (l < r) {\\n\\t\\t\\tval mid = (l + r) / 2\\n\\t\\t\\tif (calc(mid) >= n) r = mid else l = mid + 1\\n\\t\\t}\\n\\n\\t\\treturn l.toInt()\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2468756,
                "title": "python-binary-search-thoroughly-explained-in-code",
                "content": "Main idea:\\n- Guess a number, check its ugly rank\\n- Adjust your guess using binary search\\n\\n```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        \\n        def get_nth_ugly(x, a, b, c):\\n            \"\"\"Returns the ugly rank of number x based on divisors a b and c\"\"\"\\n            a_divisors = x // a\\n            b_divisors = x // b\\n            c_divisors = x // c\\n\\n            ab_divisors = x // math.lcm(a, b)\\n            ac_divisors = x // math.lcm(a, c)\\n            bc_divisors = x // math.lcm(b, c)\\n\\n            abc_divisors = x // math.lcm(a, b, c)\\n\\n            return a_divisors + b_divisors + c_divisors - ab_divisors - ac_divisors - bc_divisors + abc_divisors\\n        \\n        def is_ugly(x, a, b, c):\\n            \"\"\"Checks whether the current number is an ugly number\"\"\"\\n            return x % a == 0 or x % b == 0 or x % c == 0\\n        \\n        # binary search\\n        # initialize at min and max results\\n        left = 1\\n        right = 2_000_000_000\\n        \\n        while left <= right:\\n            # set the mid point to look at\\n            target = (left + right) // 2\\n            \\n            # check the ugly rank\\n            nth_ugly = get_nth_ugly(target, a, b, c)\\n            \\n            # was this the number we were looking for?\\n            if nth_ugly == n:\\n                \\n                # correct rank AND is ugly\\n                if is_ugly(target, a, b, c):\\n                    return target\\n                else:\\n                    \\n                    # correct rank but not ugly, a lower number with the same rank exists that IS ugly\\n                    right = target - 1\\n                \\n                # not found, move the boundary accordingly\\n            elif nth_ugly < n:\\n                left = target + 1\\n            else:\\n                right = target - 1\\n        \\n        # code is guaranteed to have a solution, no ending return is needed\\n        ```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        \\n        def get_nth_ugly(x, a, b, c):\\n            \"\"\"Returns the ugly rank of number x based on divisors a b and c\"\"\"\\n            a_divisors = x // a\\n            b_divisors = x // b\\n            c_divisors = x // c\\n\\n            ab_divisors = x // math.lcm(a, b)\\n            ac_divisors = x // math.lcm(a, c)\\n            bc_divisors = x // math.lcm(b, c)\\n\\n            abc_divisors = x // math.lcm(a, b, c)\\n\\n            return a_divisors + b_divisors + c_divisors - ab_divisors - ac_divisors - bc_divisors + abc_divisors\\n        \\n        def is_ugly(x, a, b, c):\\n            \"\"\"Checks whether the current number is an ugly number\"\"\"\\n            return x % a == 0 or x % b == 0 or x % c == 0\\n        \\n        # binary search\\n        # initialize at min and max results\\n        left = 1\\n        right = 2_000_000_000\\n        \\n        while left <= right:\\n            # set the mid point to look at\\n            target = (left + right) // 2\\n            \\n            # check the ugly rank\\n            nth_ugly = get_nth_ugly(target, a, b, c)\\n            \\n            # was this the number we were looking for?\\n            if nth_ugly == n:\\n                \\n                # correct rank AND is ugly\\n                if is_ugly(target, a, b, c):\\n                    return target\\n                else:\\n                    \\n                    # correct rank but not ugly, a lower number with the same rank exists that IS ugly\\n                    right = target - 1\\n                \\n                # not found, move the boundary accordingly\\n            elif nth_ugly < n:\\n                left = target + 1\\n            else:\\n                right = target - 1\\n        \\n        # code is guaranteed to have a solution, no ending return is needed\\n        ```",
                "codeTag": "Java"
            },
            {
                "id": 2421037,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n   \\n\\n  long long lcm(int a, int b)\\n  {\\n    long long int gcd=__gcd(a,b);  \\n    return (a /gcd) * b;\\n  } \\n    \\n   long long int check(int n, int a, int b, int c) {\\n      \\n        long long int c1=n/a;\\n        long long int c2=n/b;\\n        long long int c3=n/c;\\n        long long int c4=n/lcm(a,b);  \\n        long long int c5=n/lcm(b,c);  \\n        long long int c6=n/lcm(c,a);  \\n        long long int c7=n/lcm(lcm(a,b),c);\\n      \\n       \\n       return c1+c2+c3-c4-c5-c6+c7;\\n    }\\n    \\n    \\n    int nthUglyNumber(int n, int a, int b, int c) {\\n     \\n        \\n     long long int end=2*1e9;   \\n        \\n     long long int start=1;\\n        \\n     long long int mid=1; \\n      while(start<=end){\\n       \\n       mid=(start+end)/2;   \\n          \\n       if(check(mid,a,b,c)==n){\\n           break;\\n       }\\n       else if(check(mid,a,b,c)>n){\\n           end=mid-1;\\n       }\\n       else{\\n           start=mid+1; \\n       }   \\n          \\n          \\n          \\n      }   \\n        \\n      long long int x=mid/a*a;\\n        \\n      long long int y=mid/b*b;\\n        \\n      long long int z=mid/c*c;  \\n      \\n        \\n      int max1=max(max(x,y),z);\\n        \\n      return max1;  \\n          \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n\\n  long long lcm(int a, int b)\\n  {\\n    long long int gcd=__gcd(a,b);  \\n    return (a /gcd) * b;\\n  } \\n    \\n   long long int check(int n, int a, int b, int c) {\\n      \\n        long long int c1=n/a;\\n        long long int c2=n/b;\\n        long long int c3=n/c;\\n        long long int c4=n/lcm(a,b);  \\n        long long int c5=n/lcm(b,c);  \\n        long long int c6=n/lcm(c,a);  \\n        long long int c7=n/lcm(lcm(a,b),c);\\n      \\n       \\n       return c1+c2+c3-c4-c5-c6+c7;\\n    }\\n    \\n    \\n    int nthUglyNumber(int n, int a, int b, int c) {\\n     \\n        \\n     long long int end=2*1e9;   \\n        \\n     long long int start=1;\\n        \\n     long long int mid=1; \\n      while(start<=end){\\n       \\n       mid=(start+end)/2;   \\n          \\n       if(check(mid,a,b,c)==n){\\n           break;\\n       }\\n       else if(check(mid,a,b,c)>n){\\n           end=mid-1;\\n       }\\n       else{\\n           start=mid+1; \\n       }   \\n          \\n          \\n          \\n      }   \\n        \\n      long long int x=mid/a*a;\\n        \\n      long long int y=mid/b*b;\\n        \\n      long long int z=mid/c*c;  \\n      \\n        \\n      int max1=max(max(x,y),z);\\n        \\n      return max1;  \\n          \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2420975,
                "title": "c-solution-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        long long med=1, end, beg;\\n        beg=1; end=2*1e9;\\n        \\n        while(beg<=end){\\n            med=(beg + end)/2;\\n            long long fk=uglyNumsLessThanK(med,a,b,c);\\n            if(fk==n){\\n                cout<<med;\\n                break;\\n            }\\n            else if(n<fk){\\n                end=med-1;\\n            }\\n            else{\\n                beg=med+1;\\n            }\\n        }\\n        \\n        \\n                long long c1=med/a*a, c2=med/b*b, c3=med/c*c;\\n                long long max=0;\\n                max=c1>c2?c1:c2;\\n                max=max>c3?max:c3;\\n                return (int)max; \\n    }\\n    \\n    long long uglyNumsLessThanK(long long k, int a, int b, int c){\\n        int lcm12=lcm(a,b);\\n        long long c1=k/a, c2=k/b, c3=k/c, c12=k/lcm12, c13=k/lcm(a,c), c23=k/lcm(b,c), c123=k/lcm(lcm12,c);\\n        \\n        return c1+c2+c3-c12-c13-c23+c123;\\n    }\\n    \\n    long long gcd(long long int a, long long int b)\\n{\\n  if (b == 0)\\n    return a;\\n  return gcd(b, a % b);\\n}\\n \\n// Function to return LCM of two numbers\\nlong long lcm(int a, int b)\\n{\\n    return (a / gcd(a, b)) * b;\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        long long med=1, end, beg;\\n        beg=1; end=2*1e9;\\n        \\n        while(beg<=end){\\n            med=(beg + end)/2;\\n            long long fk=uglyNumsLessThanK(med,a,b,c);\\n            if(fk==n){\\n                cout<<med;\\n                break;\\n            }\\n            else if(n<fk){\\n                end=med-1;\\n            }\\n            else{\\n                beg=med+1;\\n            }\\n        }\\n        \\n        \\n                long long c1=med/a*a, c2=med/b*b, c3=med/c*c;\\n                long long max=0;\\n                max=c1>c2?c1:c2;\\n                max=max>c3?max:c3;\\n                return (int)max; \\n    }\\n    \\n    long long uglyNumsLessThanK(long long k, int a, int b, int c){\\n        int lcm12=lcm(a,b);\\n        long long c1=k/a, c2=k/b, c3=k/c, c12=k/lcm12, c13=k/lcm(a,c), c23=k/lcm(b,c), c123=k/lcm(lcm12,c);\\n        \\n        return c1+c2+c3-c12-c13-c23+c123;\\n    }\\n    \\n    long long gcd(long long int a, long long int b)\\n{\\n  if (b == 0)\\n    return a;\\n  return gcd(b, a % b);\\n}\\n \\n// Function to return LCM of two numbers\\nlong long lcm(int a, int b)\\n{\\n    return (a / gcd(a, b)) * b;\\n}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2402964,
                "title": "leetcode-the-hard-way-inclusive-exclusive-binary-search",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. If you like it, please give a star and watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way).\\n\\n---\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int ok(long long n, long long a, long long b, long long c) {\\n        // numbers (1 to n) divisble by a = n / a\\n        // numbers (1 to n) divisble by b = n / b\\n        // numbers (1 to n) divisble by c = n / c\\n        // exclude overlapping counts for a and b = n / lcm(a, b)\\n        // exclude overlapping counts for b and c = n / lcm(b, c)\\n        // exclude overlapping counts for a and c = n / lcm(a, c)\\n        // include those covered by all a, b and c = n / lcm(a, lcm(b, c))  \\n        \\n        // Set theory Formula: \\n        // a + b + c - a \\u2229 c - a \\u2229 b - b \\u2229 c + a \\u2229 b \\u2229 c\\n        return (int) n / a + n / b + n / c \\n        - n / lcm(a, b)\\n        - n / lcm(b, c)\\n        - n / lcm(a, c)\\n        + n / lcm(a, lcm(b, c));\\n    }\\n    \\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        // init possible range [1, 2 * 10 ^ 9]\\n        int l = 1, r = 2e9;\\n        while (l < r) {\\n            // get the middle one\\n            // for even number of elements, take the lower one\\n            int m = l + (r - l) / 2;\\n            // exclude m\\n            if (n > ok(m, a, b, c)) l = m + 1;\\n            // include m\\n            else r = m;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int ok(long long n, long long a, long long b, long long c) {\\n        // numbers (1 to n) divisble by a = n / a\\n        // numbers (1 to n) divisble by b = n / b\\n        // numbers (1 to n) divisble by c = n / c\\n        // exclude overlapping counts for a and b = n / lcm(a, b)\\n        // exclude overlapping counts for b and c = n / lcm(b, c)\\n        // exclude overlapping counts for a and c = n / lcm(a, c)\\n        // include those covered by all a, b and c = n / lcm(a, lcm(b, c))  \\n        \\n        // Set theory Formula: \\n        // a + b + c - a \\u2229 c - a \\u2229 b - b \\u2229 c + a \\u2229 b \\u2229 c\\n        return (int) n / a + n / b + n / c \\n        - n / lcm(a, b)\\n        - n / lcm(b, c)\\n        - n / lcm(a, c)\\n        + n / lcm(a, lcm(b, c));\\n    }\\n    \\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        // init possible range [1, 2 * 10 ^ 9]\\n        int l = 1, r = 2e9;\\n        while (l < r) {\\n            // get the middle one\\n            // for even number of elements, take the lower one\\n            int m = l + (r - l) / 2;\\n            // exclude m\\n            if (n > ok(m, a, b, c)) l = m + 1;\\n            // include m\\n            else r = m;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2147013,
                "title": "java-solution-binary-search-maths",
                "content": "**This solution is nothing but based on the formula maths derivation show below:** \\n\\n*1.n(AUBUC) = n(A)+n(B)+n(C)-n(A\\u2229B)-n(A\\u2229C)-n(B\\u2229C)+n(A\\u2229B\\u2229C).*\\n\\n*2. n(A)=mid/a similarly n(B)=mid/b and n(C)=mid/c .* \\n\\n*3.n(A\\u2229B)=mid/lcm(a,b) similarly n(A\\u2229C)=mid/lcm(a,c) and n(B\\u2229C)=mid/lcm(b,c)*\\n\\n*4.n(A\\u2229B\\u2229C)=mid/lcm(a,lcm(b,c)) by the help of this above illustrations we will apply the binary searching* \\n*algorithm and find out the ugly number for the given number for this problem.*\\n\\n**TC-O(log(n * min(a, b, c)))\\nSC-O(1)**\\n\\n class Solution {\\n\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        int start=1;\\n        int end=Integer.MAX_VALUE;\\n        while(start<end){\\n            int mid=start+(end-start)/2;\\n            if(isUgly(mid,a,b,c,n)){\\n                end=mid;\\n            }\\n            else{\\n                start=mid+1;\\n            }\\n        }\\n        return start;\\n    }\\n    public boolean isUgly(long mid,long a,long b,long c,long n){\\n        return (int)(mid/a+mid/b+mid/c-mid/lcm(a,b)-mid/lcm(b,c)-mid/lcm(c,a)+mid/lcm(a,lcm(b,c)))>=n;\\n    }\\n    public long gcd(long m,long n){\\n          if(m==0)\\n              return n;\\n        else\\n            return gcd(n%m,m);\\n    }\\n    public long lcm(long m,long n){\\n       return m*n/(gcd(m,n));\\n    }\\n}",
                "solutionTags": [
                    "Math",
                    "Binary Search"
                ],
                "code": "class Solution {\\n\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        int start=1;\\n        int end=Integer.MAX_VALUE;\\n        while(start<end){\\n            int mid=start+(end-start)/2;\\n            if(isUgly(mid,a,b,c,n)){\\n                end=mid;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2105407,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        \\n        long long lla = (long long)a;\\n        long long llb = (long long)b;\\n        long long llc = (long long)c;\\n        \\n        // function f(k) to determine how many ugly numbers smaller than k.\\n        // f(k) is non-decreasing.\\n        auto f = [](long long k, long long a, long long b, long long c) {\\n            return k/a + k/b + k/c - k/lcm(a, b) - k/lcm(b, c) - k/lcm(a, c) + k/lcm(a, lcm(b, c));\\n        };\\n        \\n        int lo = 1, hi = 2 * 1e9;\\n        while (lo < hi) {\\n            long long mid = lo + (hi - lo) / 2;\\n            \\n            int num = f(mid, lla, llb, llc);\\n            \\n            if (num < n) {\\n                lo = mid + 1;\\n            }\\n            else if (num > n) {\\n                hi = mid - 1;\\n            }\\n            else {\\n                hi = mid;\\n            }\\n        }\\n        \\n        return lo;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        \\n        long long lla = (long long)a;\\n        long long llb = (long long)b;\\n        long long llc = (long long)c;\\n        \\n        // function f(k) to determine how many ugly numbers smaller than k.\\n        // f(k) is non-decreasing.\\n        auto f = [](long long k, long long a, long long b, long long c) {\\n            return k/a + k/b + k/c - k/lcm(a, b) - k/lcm(b, c) - k/lcm(a, c) + k/lcm(a, lcm(b, c));\\n        };\\n        \\n        int lo = 1, hi = 2 * 1e9;\\n        while (lo < hi) {\\n            long long mid = lo + (hi - lo) / 2;\\n            \\n            int num = f(mid, lla, llb, llc);\\n            \\n            if (num < n) {\\n                lo = mid + 1;\\n            }\\n            else if (num > n) {\\n                hi = mid - 1;\\n            }\\n            else {\\n                hi = mid;\\n            }\\n        }\\n        \\n        return lo;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2063707,
                "title": "python3-binary-search",
                "content": "```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        lcm_ab = a * b // math.gcd(a, b)\\n        lcm_ac = a * c // math.gcd(a, c)\\n        lcm_bc = b * c // math.gcd(b, c)\\n        lcm_abc = a * lcm_bc // math.gcd(a, lcm_bc)\\n    \\n        def isEnough(num):\\n            cnt = num // a + num // b + num // c \\\\\\n                    - num // lcm_ab - num // lcm_ac - num // lcm_bc \\\\\\n                    + num // lcm_abc\\n            return cnt >= n\\n            \\n        left, right = 1, 10**10\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if isEnough(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        lcm_ab = a * b // math.gcd(a, b)\\n        lcm_ac = a * c // math.gcd(a, c)\\n        lcm_bc = b * c // math.gcd(b, c)\\n        lcm_abc = a * lcm_bc // math.gcd(a, lcm_bc)\\n    \\n        def isEnough(num):\\n            cnt = num // a + num // b + num // c \\\\\\n                    - num // lcm_ab - num // lcm_ac - num // lcm_bc \\\\\\n                    + num // lcm_abc\\n            return cnt >= n\\n            \\n        left, right = 1, 10**10\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if isEnough(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1919652,
                "title": "illustrated-explanation",
                "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/82574c8a-c4f6-4274-b32f-c86a74c59f47_1649247475.906736.png)\\n\\n\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        \"\"\" O(NlogN)T O(1)S\"\"\"\\n        fn = lambda x: x // a + x // b + x // c - x // math.lcm(a, b) - x // math.lcm(a, c) - x // math.lcm(b, c) + x // math.lcm(a, b, c) >= n\\n        return bisect.bisect_left(range(10 ** 10), True, 1, key=fn)",
                "solutionTags": [
                    "Python"
                ],
                "code": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/82574c8a-c4f6-4274-b32f-c86a74c59f47_1649247475.906736.png)\\n\\n\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        \"\"\" O(NlogN)T O(1)S\"\"\"\\n        fn = lambda x: x // a + x // b + x // c - x // math.lcm(a, b) - x // math.lcm(a, c) - x // math.lcm(b, c) + x // math.lcm(a, b, c) >= n\\n        return bisect.bisect_left(range(10 ** 10), True, 1, key=fn)",
                "codeTag": "Python3"
            },
            {
                "id": 1873045,
                "title": "c-binary-search-100-faster-ugly-number",
                "content": "```\\n long long int mini(long long int a,long long int b,long long int c){\\n        if(a<b && a<c)\\n            return a;\\n        else if(b<c)\\n            return b;\\n        else\\n            return c;\\n    }\\n    long long int fun(long long int n,long long int a,long long int b,long long int c){\\n        long long int lcm1=(a*b)/__gcd(a,b);\\n        long long int lcm2=(b*c)/__gcd(b,c);\\n        long long int lcm3=(a*c)/__gcd(a,c);\\n        long long int lcm=(lcm1*c)/__gcd(lcm1,c);\\n        return (n/a+n/b+n/c-n/lcm1-n/lcm2-n/lcm3+n/lcm);\\n    }\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n       long long int low=mini(a,b,c);\\n        long long int high=1e18;\\n        while(low<=high){\\n            long long int mid=low+((high-low)/2);\\n            long long int count=fun(mid,a,b,c);\\n            if(count==n){\\n                long long int count1=fun(mid-1,a,b,c);\\n                if(count1!=n)\\n                    return mid;\\n                else high=mid-1;\\n            }\\n            else if(count>n)\\n                high=mid-1;\\n            else\\n                low=mid+1;\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n long long int mini(long long int a,long long int b,long long int c){\\n        if(a<b && a<c)\\n            return a;\\n        else if(b<c)\\n            return b;\\n        else\\n            return c;\\n    }\\n    long long int fun(long long int n,long long int a,long long int b,long long int c){\\n        long long int lcm1=(a*b)/__gcd(a,b);\\n        long long int lcm2=(b*c)/__gcd(b,c);\\n        long long int lcm3=(a*c)/__gcd(a,c);\\n        long long int lcm=(lcm1*c)/__gcd(lcm1,c);\\n        return (n/a+n/b+n/c-n/lcm1-n/lcm2-n/lcm3+n/lcm);\\n    }\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n       long long int low=mini(a,b,c);\\n        long long int high=1e18;\\n        while(low<=high){\\n            long long int mid=low+((high-low)/2);\\n            long long int count=fun(mid,a,b,c);\\n            if(count==n){\\n                long long int count1=fun(mid-1,a,b,c);\\n                if(count1!=n)\\n                    return mid;\\n                else high=mid-1;\\n            }\\n            else if(count>n)\\n                high=mid-1;\\n            else\\n                low=mid+1;\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1708753,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    long long lcm(long long n1, long long n2) {\\n        return n1 * n2 / __gcd(n1, n2);\\n    }\\n       \\n    bool enough(long long x, int n, int a, int b, int c) {\\n        long long cnt = x/a + x/b + x/c - x/lcm(a, b) - x/lcm(b, c) - x/lcm(a, c) + x/lcm(a, lcm(b, c));\\n        return cnt >= n;\\n    }\\n    \\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        long long lo = 1;\\n        long long hi = 2e9;\\n        while (lo < hi) {\\n            long long mid = lo + (hi - lo) / 2;\\n            if (enough(mid, n, a, b, c))\\n                hi = mid;\\n            else\\n                lo = mid + 1;\\n        }\\n        return lo;\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long lcm(long long n1, long long n2) {\\n        return n1 * n2 / __gcd(n1, n2);\\n    }\\n       \\n    bool enough(long long x, int n, int a, int b, int c) {\\n        long long cnt = x/a + x/b + x/c - x/lcm(a, b) - x/lcm(b, c) - x/lcm(a, c) + x/lcm(a, lcm(b, c));\\n        return cnt >= n;\\n    }\\n    \\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        long long lo = 1;\\n        long long hi = 2e9;\\n        while (lo < hi) {\\n            long long mid = lo + (hi - lo) / 2;\\n            if (enough(mid, n, a, b, c))\\n                hi = mid;\\n            else\\n                lo = mid + 1;\\n        }\\n        return lo;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1662661,
                "title": "100-faster-easy-to-understand-c-code",
                "content": "* ******Using Binary Search******\\n\\n1. ***Time Complexity : O(log(size of integer variable))***\\n2. ***Space Complexity : O(1)***\\n\\n```\\nlong long lcm(long long a, long long b)\\n    {\\n        return (a * b) / __gcd(a, b) ;\\n    }\\n    \\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        \\n        long long low = 1;\\n        \\n        long long high = INT_MAX;\\n        \\n        while(low <= high)\\n        {\\n            long long mid = (low + high) / 2 ;\\n            \\n            long long nth_ugly = mid / a + mid / b + mid / c - mid / (lcm(a, b)) - mid / (lcm(b, c)) - mid / (lcm(c, a)) + mid / (lcm(a, lcm(b, c))) ;\\n            \\n            if(nth_ugly >= n)\\n                high = mid - 1 ;\\n            \\n            else if(nth_ugly < n)\\n            {\\n                low = mid + 1 ;\\n            }  \\n        }\\n        \\n        return low;\\n    }\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nlong long lcm(long long a, long long b)\\n    {\\n        return (a * b) / __gcd(a, b) ;\\n    }\\n    \\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        \\n        long long low = 1;\\n        \\n        long long high = INT_MAX;\\n        \\n        while(low <= high)\\n        {\\n            long long mid = (low + high) / 2 ;\\n            \\n            long long nth_ugly = mid / a + mid / b + mid / c - mid / (lcm(a, b)) - mid / (lcm(b, c)) - mid / (lcm(c, a)) + mid / (lcm(a, lcm(b, c))) ;\\n            \\n            if(nth_ugly >= n)\\n                high = mid - 1 ;\\n            \\n            else if(nth_ugly < n)\\n            {\\n                low = mid + 1 ;\\n            }  \\n        }\\n        \\n        return low;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1499626,
                "title": "javascript-binary-search-solution",
                "content": "**Complexity**\\nTime: O(log(MAX_ANS)), MAX_ANS = 2*10^9\\nSpace: O(1)\\n\\n```\\n/**\\n * @param {number} n\\n * @param {number} a\\n * @param {number} b\\n * @param {number} c\\n * @return {number}\\n */\\nvar nthUglyNumber = function (n, a, b, c) {\\n  const ab = lcm(a, b);\\n  const bc = lcm(b, c);\\n  const ac = lcm(a, c);\\n  const abc = lcm(ab, c);\\n\\n  const f = (num) => Math.floor(num);\\n  const getUglyNumberCount = (k) => {\\n    return (\\n      f(k / a) +\\n      f(k / b) +\\n      f(k / c) -\\n      f(k / ab) -\\n      f(k / ac) -\\n      f(k / bc) +\\n      f(k / abc)\\n    );\\n  };\\n\\n  let start = n;\\n  let end = n * Math.min(a, b, c);\\n  let boundaryIndex = end;\\n\\n  while (start <= end) {\\n    const mid = Math.floor((end - start) / 2) + start;\\n    if (getUglyNumberCount(mid) < n) {\\n      start = mid + 1;\\n    } else {\\n      boundaryIndex = mid;\\n      end = mid - 1;\\n    }\\n  }\\n\\n  return boundaryIndex;\\n};\\n\\nconst lcm = (a, b) => {\\n  return (a * b) / gcd(a, b);\\n};\\n\\nconst gcd = function (a, b) {\\n  if (b === 0) return a;\\n  return gcd(b, a % b);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number} a\\n * @param {number} b\\n * @param {number} c\\n * @return {number}\\n */\\nvar nthUglyNumber = function (n, a, b, c) {\\n  const ab = lcm(a, b);\\n  const bc = lcm(b, c);\\n  const ac = lcm(a, c);\\n  const abc = lcm(ab, c);\\n\\n  const f = (num) => Math.floor(num);\\n  const getUglyNumberCount = (k) => {\\n    return (\\n      f(k / a) +\\n      f(k / b) +\\n      f(k / c) -\\n      f(k / ab) -\\n      f(k / ac) -\\n      f(k / bc) +\\n      f(k / abc)\\n    );\\n  };\\n\\n  let start = n;\\n  let end = n * Math.min(a, b, c);\\n  let boundaryIndex = end;\\n\\n  while (start <= end) {\\n    const mid = Math.floor((end - start) / 2) + start;\\n    if (getUglyNumberCount(mid) < n) {\\n      start = mid + 1;\\n    } else {\\n      boundaryIndex = mid;\\n      end = mid - 1;\\n    }\\n  }\\n\\n  return boundaryIndex;\\n};\\n\\nconst lcm = (a, b) => {\\n  return (a * b) / gcd(a, b);\\n};\\n\\nconst gcd = function (a, b) {\\n  if (b === 0) return a;\\n  return gcd(b, a % b);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1434654,
                "title": "c-binary-search-100-faster",
                "content": "```\\n#define ll long long int\\n#define gcd(a,b) __gcd(a,b)\\nclass Solution {\\npublic:\\n    //note : x / a => give no of int devisible by \\'a\\' from 1 to x.\\n    ll HowManyUglyTill(ll x,ll a,ll b,ll c)\\n    {\\n        ll lcm_ab = (a * b) / gcd(a,b);\\n        ll lcm_bc = (b * c) / gcd(b,c);\\n        ll lcm_ca = (c * a) / gcd(c,a);\\n        ll lcm_abc = (lcm_ab  * c) / gcd(lcm_ab,c);\\n                                    \\n        return (x / a) + (x / b) + (x / c) - (x / lcm_ab) - (x / lcm_bc) - (x / lcm_ca) + (x / lcm_abc);\\n    }\\n    \\n    int nthUglyNumber(int n, int a, int b, int c) \\n    {\\n        ll ans = -1;\\n        ll beg = 1,end = 2 * 1e9;\\n        while(beg <= end)\\n        {\\n            ll mid = (beg + end) / 2;\\n            ll now = HowManyUglyTill(mid,a,b,c);\\n            \\n            if(now >= n)\\n            {\\n                if((mid % a == 0) || (mid % b == 0) || (mid % c == 0)) \\n                    ans = mid;\\n                end = mid - 1;\\n            }\\n            else beg = mid + 1;\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long int\\n#define gcd(a,b) __gcd(a,b)\\nclass Solution {\\npublic:\\n    //note : x / a => give no of int devisible by \\'a\\' from 1 to x.\\n    ll HowManyUglyTill(ll x,ll a,ll b,ll c)\\n    {\\n        ll lcm_ab = (a * b) / gcd(a,b);\\n        ll lcm_bc = (b * c) / gcd(b,c);\\n        ll lcm_ca = (c * a) / gcd(c,a);\\n        ll lcm_abc = (lcm_ab  * c) / gcd(lcm_ab,c);\\n                                    \\n        return (x / a) + (x / b) + (x / c) - (x / lcm_ab) - (x / lcm_bc) - (x / lcm_ca) + (x / lcm_abc);\\n    }\\n    \\n    int nthUglyNumber(int n, int a, int b, int c) \\n    {\\n        ll ans = -1;\\n        ll beg = 1,end = 2 * 1e9;\\n        while(beg <= end)\\n        {\\n            ll mid = (beg + end) / 2;\\n            ll now = HowManyUglyTill(mid,a,b,c);\\n            \\n            if(now >= n)\\n            {\\n                if((mid % a == 0) || (mid % b == 0) || (mid % c == 0)) \\n                    ans = mid;\\n                end = mid - 1;\\n            }\\n            else beg = mid + 1;\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1275018,
                "title": "c-binary-search-faster-than-100",
                "content": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    ll lcm(ll a,ll b){\\n        return (a*b)/(__gcd(a,b));\\n    }\\n    ll uglyhelper(ll m,ll a,ll b,ll c){\\n        return m/a+m/b+m/c-(m/lcm(a,b))-(m/lcm(b,c))-(m/lcm(a,c))+(m/lcm(a,lcm(b,c)));\\n    }\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        ll l=1;\\n        ll h=2*1000000000;\\n        while(l<=h){\\n            ll mid=(l+h)/2;\\n            ll cnt=uglyhelper(mid,a,b,c);\\n            if(cnt<n){\\n                l=mid+1;\\n            }\\n            else if(cnt>=n){\\n                if(uglyhelper(mid-1,a,b,c)<n){\\n                    return mid;\\n                }\\n                else{\\n                    h=mid-1;\\n                }\\n            }\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    ll lcm(ll a,ll b){\\n        return (a*b)/(__gcd(a,b));\\n    }\\n    ll uglyhelper(ll m,ll a,ll b,ll c){\\n        return m/a+m/b+m/c-(m/lcm(a,b))-(m/lcm(b,c))-(m/lcm(a,c))+(m/lcm(a,lcm(b,c)));\\n    }\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        ll l=1;\\n        ll h=2*1000000000;\\n        while(l<=h){\\n            ll mid=(l+h)/2;\\n            ll cnt=uglyhelper(mid,a,b,c);\\n            if(cnt<n){\\n                l=mid+1;\\n            }\\n            else if(cnt>=n){\\n                if(uglyhelper(mid-1,a,b,c)<n){\\n                    return mid;\\n                }\\n                else{\\n                    h=mid-1;\\n                }\\n            }\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1180051,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    // \\u8FD4\\u56DE\\u4E0D\\u5927\\u4E8Em\\u7684ugly number\\n    long long numOfUglyNumberWithUpperLimit(long m, long a, long b, long c) {\\n        long long lcm_ab = std::lcm(a, b);\\n        long long lcm_ac = std::lcm(a, c);\\n        long long lcm_bc = std::lcm(b, c);\\n        long long lcm_abc = std::lcm(a, std::lcm(b, c));\\n        return (m / a + m / b + m / c - m / lcm_ab - m / lcm_ac - m / lcm_bc + m / lcm_abc);\\n    }\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        long long l = 1;\\n        long long u = 2 * 1e9;\\n        while (l <= u) {\\n            long long m = (l + u) / 2;\\n            if (numOfUglyNumberWithUpperLimit(m, a, b, c) >= n) {\\n                u = m - 1;\\n            } else {\\n                l = m + 1;\\n            }\\n        }\\n        return (int)l;\\n    }\\n};\\n```\\n1. C++\\u6709\\u6807\\u51C6\\u5E93\\u51FD\\u6570\\u53EF\\u4EE5\\u7528\\u6765\\u6C42\\u89E3\\u6700\\u5C0F\\u516C\\u500D\\u6570\\uFF0Cstd::lcm\\uFF0C\\u5BF9\\u5E94\\u7684\\u5934\\u6587\\u4EF6\\u662F#include <numeric>\\n2. \\u4E0D\\u5927\\u4E8Em\\u7684\\u548Ca, b, c\\u76F8\\u5173\\u7684ugly number\\u662F(m/a + m/b + m/c - m/lcm(a, b) - m/lcm(a, c) - m/lcm(b, c) + m/lcm(a, lcm(b, c)));\\n3. \\u7528\\u4E8C\\u5206\\u6CD5\\u6C42\\u89E3\\uFF0C\\u8FB9\\u754C\\u95EE\\u9898\\u6211\\u8FD8\\u9700\\u8981\\u5B66\\u4E60",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // \\u8FD4\\u56DE\\u4E0D\\u5927\\u4E8Em\\u7684ugly number\\n    long long numOfUglyNumberWithUpperLimit(long m, long a, long b, long c) {\\n        long long lcm_ab = std::lcm(a, b);\\n        long long lcm_ac = std::lcm(a, c);\\n        long long lcm_bc = std::lcm(b, c);\\n        long long lcm_abc = std::lcm(a, std::lcm(b, c));\\n        return (m / a + m / b + m / c - m / lcm_ab - m / lcm_ac - m / lcm_bc + m / lcm_abc);\\n    }\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        long long l = 1;\\n        long long u = 2 * 1e9;\\n        while (l <= u) {\\n            long long m = (l + u) / 2;\\n            if (numOfUglyNumberWithUpperLimit(m, a, b, c) >= n) {\\n                u = m - 1;\\n            } else {\\n                l = m + 1;\\n            }\\n        }\\n        return (int)l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1068074,
                "title": "simple-maths-union-inersection-lcm-python3-solution",
                "content": "formula:-\\na U b U c = a + b + c - a \\u2229 c - a \\u2229 b - b \\u2229 c + a \\u2229 b \\u2229 c\\n\\n```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        def gcd(x,y):\\n            if x==0:\\n                return y\\n            return gcd(y%x,x)\\n        def lcm(a,b):\\n            return (a*b)//gcd(a,b)\\n        res=0\\n        l=min(a,b,c)\\n        r=10**18\\n        while(l<=r):\\n            m=l+(r-l)//2\\n            s=0\\n            s=s+((m//a)+(m//b)+(m//c))\\n            s-=(m//lcm(a,b))\\n            s-=(m//lcm(a,c))\\n            s-=(m//lcm(b,c))\\n            x=lcm(a,b)\\n            s+=(m//lcm(x,c))\\n            if s>=n:\\n                res = m\\n                r=m-1\\n            else:\\n                l=m+1\\n        return res",
                "solutionTags": [],
                "code": "formula:-\\na U b U c = a + b + c - a \\u2229 c - a \\u2229 b - b \\u2229 c + a \\u2229 b \\u2229 c\\n\\n```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        def gcd(x,y):\\n            if x==0:\\n                return y\\n            return gcd(y%x,x)\\n        def lcm(a,b):\\n            return (a*b)//gcd(a,b)\\n        res=0\\n        l=min(a,b,c)\\n        r=10**18\\n        while(l<=r):\\n            m=l+(r-l)//2\\n            s=0\\n            s=s+((m//a)+(m//b)+(m//c))\\n            s-=(m//lcm(a,b))\\n            s-=(m//lcm(a,c))\\n            s-=(m//lcm(b,c))\\n            x=lcm(a,b)\\n            s+=(m//lcm(x,c))\\n            if s>=n:\\n                res = m\\n                r=m-1\\n            else:\\n                l=m+1\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1021129,
                "title": "c-binary-search-and-math-solution-0ms",
                "content": "Run-time is `O(loga + logb + logc)`, space is `O(1)`. Idea is to realize that the `nth` number must be a multiple of `a`, `b`, or `c`, so we can run binary search for that multiple value using `a`, `b`, and `c`, since one of them must work. Each search we are checking to see if the number of multiples of `a`, `b`, and `c` less than or equal to `a*mid` is equal to `n`. If it is, then`a*mid` is the solution. \\n\\nTo do this problem correctly, math is needed to use the inclusion-exclusion principle to not double-count multiples of more than 1 of `a`, `b`, or `c`. Also, the knowledge that `LCM(a,b) = a*b/gcd(a,b)` and `LCM(a,b,c) = LCM(a,b)*c/gcd(LCM(a,b),c)` is needed to count number of multiples of some combination of numbers. \\n\\n```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        if(c == a || c == b) {\\n            if(b == a) return a*n;\\n            int res{search2(n,a,b)};\\n            if(res) return res;\\n            return search2(n,b,a);\\n        }\\n        int res{search3(n,a,b,c)};\\n        if(res) return res;\\n        res = search3(n,b,a,c);\\n        if(res) return res;\\n        res = search3(n,c,a,b);\\n        if(res) return res;\\n        return 0;\\n    }\\n    \\n    int search3(int n, int a, int b, int c) {\\n        int64_t lo{0}, hi{(int64_t)n}, mid, det, ab{(int64_t)a*b/gcd(a,b)}, ac{(int64_t)a*c/gcd(a,c)}, bc{(int64_t)b*c/gcd(b,c)}, abc{(int64_t)ab*c/gcd(ab,c)};\\n        while(lo <= hi) {\\n            mid = (lo+hi)>>1, det = mid + (a*mid-1)/b + (a*mid-1)/c - (a*mid-1)/ab - (a*mid-1)/ac - (a*mid-1)/bc + (a*mid-1)/abc;\\n            if(det == n) return mid*a;\\n            else if(det > n) hi = mid-1;\\n            else lo = mid+1;\\n        }\\n        return 0;\\n    }\\n    \\n    int search2(int n, int a, int b) {\\n        int64_t lo{0}, hi{(int64_t)n}, mid, det, ab{(int64_t)a*b/gcd(a,b)};\\n        while(lo <= hi) {\\n            mid = (lo+hi)>>1, det = mid + (a*mid-1)/b - (a*mid-1)/(ab);\\n            if(det == n) return mid*a;\\n            else if(det > n) hi = mid-1;\\n            else lo = mid+1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        if(c == a || c == b) {\\n            if(b == a) return a*n;\\n            int res{search2(n,a,b)};\\n            if(res) return res;\\n            return search2(n,b,a);\\n        }\\n        int res{search3(n,a,b,c)};\\n        if(res) return res;\\n        res = search3(n,b,a,c);\\n        if(res) return res;\\n        res = search3(n,c,a,b);\\n        if(res) return res;\\n        return 0;\\n    }\\n    \\n    int search3(int n, int a, int b, int c) {\\n        int64_t lo{0}, hi{(int64_t)n}, mid, det, ab{(int64_t)a*b/gcd(a,b)}, ac{(int64_t)a*c/gcd(a,c)}, bc{(int64_t)b*c/gcd(b,c)}, abc{(int64_t)ab*c/gcd(ab,c)};\\n        while(lo <= hi) {\\n            mid = (lo+hi)>>1, det = mid + (a*mid-1)/b + (a*mid-1)/c - (a*mid-1)/ab - (a*mid-1)/ac - (a*mid-1)/bc + (a*mid-1)/abc;\\n            if(det == n) return mid*a;\\n            else if(det > n) hi = mid-1;\\n            else lo = mid+1;\\n        }\\n        return 0;\\n    }\\n    \\n    int search2(int n, int a, int b) {\\n        int64_t lo{0}, hi{(int64_t)n}, mid, det, ab{(int64_t)a*b/gcd(a,b)};\\n        while(lo <= hi) {\\n            mid = (lo+hi)>>1, det = mid + (a*mid-1)/b - (a*mid-1)/(ab);\\n            if(det == n) return mid*a;\\n            else if(det > n) hi = mid-1;\\n            else lo = mid+1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 926706,
                "title": "the-best-solution-ever",
                "content": "The main idea of my solution is to calculate the maximum possible value for n-th ugly number which is obviously min(a, b, c) * n. Then we have to determine the index of this value in the sequence of ugly numbers. After that is is easy to iterate backwards by the ugly number sequence until we reach n-th entry.\\n\\n```\\nclass Solution {\\n    \\n\\t//Helper structure\\n    struct Divisor{\\n\\n        let value : Int\\n        var top : Int\\n\\n    }\\n    \\n    func nthUglyNumber(_ n: Int, _ aVal: Int, _ bVal: Int, _ cVal: Int) -> Int {\\n\\n\\t\\t//Make sure a <= b <= c\\n        let orderedParams = [aVal, bVal, cVal].sorted()\\n        let a = orderedParams[0]\\n        let b = orderedParams[1]\\n        let c = orderedParams[2]\\n\\n\\t\\t//Maximum value for n-th ugly number is the min(a, b, c) * n\\n        let aTop = a * n //Maximum value\\n        let bTop = (aTop / b) * b\\n        let cTop = (aTop / c) * c\\n\\n\\t\\t//Calculate the number of multiples of b which are not divisible by a.\\n\\t\\t//Here we get the number of ugly sequence entries which arised only due to b factor\\n        var bUniqueEntrys = 0\\n        var bSteps = aTop / b\\n        if bSteps >= 1{\\n            for i in 1...bSteps{\\n                let value = (b * i)\\n                if !value.isMultiple(of: a){\\n                    bUniqueEntrys += 1\\n                }\\n            }\\n        }\\n\\n\\t\\t//Calculate the number of multiples of c which are not divisible by b and a.\\n\\t\\t//Here we get the number of ugly sequence entries which arised only due to c factor     \\n        var cUniqueEntrys = 0\\n        var cSteps = aTop / c\\n        if cSteps >= 1{    \\n            for i in 1...cSteps{\\n                let value = (c * i)\\n                if !value.isMultiple(of: b) && !value.isMultiple(of: a){\\n                    cUniqueEntrys += 1\\n                }\\n            }\\n        }\\n\\n        //This is an index of ugly number which value is a * n\\n        var index = n + bUniqueEntrys + cUniqueEntrys\\n\\n        var divisors = [Divisor(value: a, top: aTop), Divisor(value: b, top: bTop), Divisor(value: c, top: cTop)]\\n        var currentValue = aTop\\n\\t\\t\\n\\t\\t//Next we iterate backwards from an index of maximum possible value down to n-th value\\n        while index > n {\\n\\n            let maxValue = max(max(divisors[0].top, divisors[1].top), divisors[2].top)\\n            for i in 0..<divisors.count{\\n                if divisors[i].top == maxValue{\\n                    divisors[i].top = divisors[i].top - divisors[i].value\\n                }\\n            }\\n            index -= 1\\n\\n        }\\n\\n        return max(max(divisors[0].top, divisors[1].top), divisors[2].top)\\n        \\n    }\\n        \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n\\t//Helper structure\\n    struct Divisor{\\n\\n        let value : Int\\n        var top : Int\\n\\n    }\\n    \\n    func nthUglyNumber(_ n: Int, _ aVal: Int, _ bVal: Int, _ cVal: Int) -> Int {\\n\\n\\t\\t//Make sure a <= b <= c\\n        let orderedParams = [aVal, bVal, cVal].sorted()\\n        let a = orderedParams[0]\\n        let b = orderedParams[1]\\n        let c = orderedParams[2]\\n\\n\\t\\t//Maximum value for n-th ugly number is the min(a, b, c) * n\\n        let aTop = a * n //Maximum value\\n        let bTop = (aTop / b) * b\\n        let cTop = (aTop / c) * c\\n\\n\\t\\t//Calculate the number of multiples of b which are not divisible by a.\\n\\t\\t//Here we get the number of ugly sequence entries which arised only due to b factor\\n        var bUniqueEntrys = 0\\n        var bSteps = aTop / b\\n        if bSteps >= 1{\\n            for i in 1...bSteps{\\n                let value = (b * i)\\n                if !value.isMultiple(of: a){\\n                    bUniqueEntrys += 1\\n                }\\n            }\\n        }\\n\\n\\t\\t//Calculate the number of multiples of c which are not divisible by b and a.\\n\\t\\t//Here we get the number of ugly sequence entries which arised only due to c factor     \\n        var cUniqueEntrys = 0\\n        var cSteps = aTop / c\\n        if cSteps >= 1{    \\n            for i in 1...cSteps{\\n                let value = (c * i)\\n                if !value.isMultiple(of: b) && !value.isMultiple(of: a){\\n                    cUniqueEntrys += 1\\n                }\\n            }\\n        }\\n\\n        //This is an index of ugly number which value is a * n\\n        var index = n + bUniqueEntrys + cUniqueEntrys\\n\\n        var divisors = [Divisor(value: a, top: aTop), Divisor(value: b, top: bTop), Divisor(value: c, top: cTop)]\\n        var currentValue = aTop\\n\\t\\t\\n\\t\\t//Next we iterate backwards from an index of maximum possible value down to n-th value\\n        while index > n {\\n\\n            let maxValue = max(max(divisors[0].top, divisors[1].top), divisors[2].top)\\n            for i in 0..<divisors.count{\\n                if divisors[i].top == maxValue{\\n                    divisors[i].top = divisors[i].top - divisors[i].value\\n                }\\n            }\\n            index -= 1\\n\\n        }\\n\\n        return max(max(divisors[0].top, divisors[1].top), divisors[2].top)\\n        \\n    }\\n        \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 902383,
                "title": "java-0ms-o-logn-using-lcm",
                "content": "```\\nclass Solution {\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        int ab = lcm(a,b);\\n        int bc = lcm(b,c);\\n        int ca = lcm(c,a);\\n        int abc = lcm(ab,c);\\n        \\n        int s = 1, e = 2000000000, m;\\n        int x;\\n        while(s<e){\\n            m = s/2 + e/2 +(s%2+e%2)/2;\\n            x = m/a + m/b + m/c - m/ab - m/bc - m/ca + m/abc;\\n            if(x>=n) e=m;\\n            else s=m+1;\\n        }\\n        \\n        return s;\\n    }\\n    \\n    public int lcm(int a, int b){\\n        if(a==Integer.MAX_VALUE || b==Integer.MAX_VALUE)return Integer.MAX_VALUE;\\n        int gcd = gcd(a, b);\\n        if(Integer.MAX_VALUE / (a/gcd) < b)return Integer.MAX_VALUE;\\n        return a / gcd * b;\\n    }\\n    \\n    public int gcd(int a, int b){\\n        if(b==0)return a;\\n        return gcd(b, a%b);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        int ab = lcm(a,b);\\n        int bc = lcm(b,c);\\n        int ca = lcm(c,a);\\n        int abc = lcm(ab,c);\\n        \\n        int s = 1, e = 2000000000, m;\\n        int x;\\n        while(s<e){\\n            m = s/2 + e/2 +(s%2+e%2)/2;\\n            x = m/a + m/b + m/c - m/ab - m/bc - m/ca + m/abc;\\n            if(x>=n) e=m;\\n            else s=m+1;\\n        }\\n        \\n        return s;\\n    }\\n    \\n    public int lcm(int a, int b){\\n        if(a==Integer.MAX_VALUE || b==Integer.MAX_VALUE)return Integer.MAX_VALUE;\\n        int gcd = gcd(a, b);\\n        if(Integer.MAX_VALUE / (a/gcd) < b)return Integer.MAX_VALUE;\\n        return a / gcd * b;\\n    }\\n    \\n    public int gcd(int a, int b){\\n        if(b==0)return a;\\n        return gcd(b, a%b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796719,
                "title": "java-100-faster-binary-search",
                "content": "\\nUgly numbers are positive integers which are divisible by a or b or c.\\n\\n**Solution 1**\\nFirst n ugly numbers.\\nRuntime complexity - O(N)\\nSpace - constant\\n**Note** : this solution failed with TLE  \\n```\\nclass Solution {\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        long am = 1, bm = 1, cm = 1, cnt = 0, min = 1;\\n        while (cnt++ < n) {\\n            long an = am * a, bn = bm * b, cn = cm * c;\\n            min = Math.min(an, Math.min(bn, cn));\\n            if (an == min) am++;\\n            if (bn == min) bm++;\\n            if (cn == min) cm++;\\n        }\\n        return (int)min;\\n    }\\n}\\n```\\n\\n**Solution 2**\\n\\nSince we have to find only **n th** ugly number, it is not required to find all the first n ugly numbers.\\n\\nWe can find the nth ugly number using binary search. \\nCondition - keep checking the count of ugly numbers less **n**. \\n\\nRuntime complexity - O(Log(N))\\nSpace - constant\\n\\n```\\nclass Solution {\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        long lo = Math.min(a,Math.min(b,c));\\n        long hi = lo*n;\\n        while(lo<hi){\\n            long mid = lo+(hi-lo)/2;\\n            if(count(a,b,c,mid)>=n) hi=mid;\\n            else lo=mid+1;\\n        } \\n        return (int)lo;\\n    }\\n    \\n\\t//total number of ugly numbers less than **mid**\\n    public long count(int a,int b,int c,long mid){\\n\\t   //remove multiples lcm(a,b),  lcm(b,c),  lcm(c,a) - since they are counted twice.  add multiples of lcm(a,b,c);\\n\\t   // mid/a - > contains count including -> mid/lcm(a,b)+mid/lcm(a,c)+mid/lcm(a,b,c) , similarly for b and c\\n        return mid/a+mid/b+mid/c-mid/lcm(a,b)-mid/lcm(b,c)-mid/lcm(a,c)+mid/lcm(lcm(a,b),c);\\n    }\\n    \\n    private long lcm(long a,long b){\\n        return a*b/gcd(a,b);\\n    }\\n    private long gcd(long a,long b){\\n        if(b==0) return a;\\n        if(a<b) return gcd(b,a);\\n        return gcd(a%b,b);\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        long am = 1, bm = 1, cm = 1, cnt = 0, min = 1;\\n        while (cnt++ < n) {\\n            long an = am * a, bn = bm * b, cn = cm * c;\\n            min = Math.min(an, Math.min(bn, cn));\\n            if (an == min) am++;\\n            if (bn == min) bm++;\\n            if (cn == min) cm++;\\n        }\\n        return (int)min;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        long lo = Math.min(a,Math.min(b,c));\\n        long hi = lo*n;\\n        while(lo<hi){\\n            long mid = lo+(hi-lo)/2;\\n            if(count(a,b,c,mid)>=n) hi=mid;\\n            else lo=mid+1;\\n        } \\n        return (int)lo;\\n    }\\n    \\n\\t//total number of ugly numbers less than **mid**\\n    public long count(int a,int b,int c,long mid){\\n\\t   //remove multiples lcm(a,b),  lcm(b,c),  lcm(c,a) - since they are counted twice.  add multiples of lcm(a,b,c);\\n\\t   // mid/a - > contains count including -> mid/lcm(a,b)+mid/lcm(a,c)+mid/lcm(a,b,c) , similarly for b and c\\n        return mid/a+mid/b+mid/c-mid/lcm(a,b)-mid/lcm(b,c)-mid/lcm(a,c)+mid/lcm(lcm(a,b),c);\\n    }\\n    \\n    private long lcm(long a,long b){\\n        return a*b/gcd(a,b);\\n    }\\n    private long gcd(long a,long b){\\n        if(b==0) return a;\\n        if(a<b) return gcd(b,a);\\n        return gcd(a%b,b);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 791018,
                "title": "python-o-log-n-faster-than-97",
                "content": "```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        \\n        ab = a*b//math.gcd(a, b)\\n        bc = b*c//math.gcd(c, b)\\n        ac = a*c//math.gcd(a, c)\\n        abc = ab*c//math.gcd(ab, c)\\n        \\n        \\n        def nthUgly(k:int) -> bool: #are there more than n uglies below it number?\\n        \\n            h = k//a + k//b + k//c - k//ab - k//ac - k//bc+ k//abc\\n            \\n            if h >= n:\\n                return True\\n            \\n            \\n            return False\\n        \\n        left, right = 1, 10**10\\n        print(nthUgly(10))\\n        while left < right:\\n            mid = left + (right - left)//2\\n            if nthUgly(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n            \\n        return left\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        \\n        ab = a*b//math.gcd(a, b)\\n        bc = b*c//math.gcd(c, b)\\n        ac = a*c//math.gcd(a, c)\\n        abc = ab*c//math.gcd(ab, c)\\n        \\n        \\n        def nthUgly(k:int) -> bool: #are there more than n uglies below it number?\\n        \\n            h = k//a + k//b + k//c - k//ab - k//ac - k//bc+ k//abc\\n            \\n            if h >= n:\\n                return True\\n            \\n            \\n            return False\\n        \\n        left, right = 1, 10**10\\n        print(nthUgly(10))\\n        while left < right:\\n            mid = left + (right - left)//2\\n            if nthUgly(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n            \\n        return left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 761482,
                "title": "python-100-speed-commented-o-log-n-binary-search",
                "content": "**Python | 100% Speed | Commented | O( Log n ) Binary Search**\\n\\n```\\n# Python 2/3 Compatibility:\\nif hasattr(math,\\'gcd\\'):\\n    gcd = math.gcd\\nelse:\\n    from fractions import gcd\\n#\\nclass Solution:\\n    def nthUglyNumber(self, n, a, b, c):\\n        # Multiples have the form K*a, K*b, K*c\\n        #     - How about binary search?\\n        #         - Try number, find K-th position... move forward\\n        #\\n        # Cross-Products\\n        lcm = lambda x,y: x*y//gcd(x,y)\\n        ab  = lcm(a,b)\\n        ac  = lcm(a,c)\\n        bc  = lcm(b,c)\\n        abc = lcm(ab,c)\\n        #\\n        def index(mid):\\n            # Get n-th index of multiple \"mid\"\\n            Ka,Kb,Kc    = mid//a , mid//b , mid//c\\n            Kabc        = mid//abc\\n            Kab,Kac,Kbc = mid//ab, mid//ac, mid//bc\\n            return Ka + Kb + Kc - Kab - Kac - Kbc + Kabc\\n        def closest(m):\\n            # Find closest number to \"m\" that is a multiple of [a,b,c]\\n            Ka,Kb,Kc = m//a, m//b, m//c\\n            return max(Ka*a,Kb*b,Kc*c)\\n        #\\n        # Low and High Guesses for the K-th multiple (get started with numbers that are multiples themselves)\\n        lo, hi = min(a,b,c), closest(int(2e9))\\n        while lo<=hi:\\n            # m: mid guess\\n            m   = (lo+hi)//2\\n            # mid: closest multiple to mid guess\\n            mid = closest( m )\\n            # Kth: Position of K-th multiple \"mid\"\\n            Kth = index(mid)\\n            if Kth==n:\\n                return mid # Success\\n            if Kth<n:\\n                lo = m + 1 # m was too low\\n            else: # Kth>n\\n                hi = m - 1 # m was too high\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Python 2/3 Compatibility:\\nif hasattr(math,\\'gcd\\'):\\n    gcd = math.gcd\\nelse:\\n    from fractions import gcd\\n#\\nclass Solution:\\n    def nthUglyNumber(self, n, a, b, c):\\n        # Multiples have the form K*a, K*b, K*c\\n        #     - How about binary search?\\n        #         - Try number, find K-th position... move forward\\n        #\\n        # Cross-Products\\n        lcm = lambda x,y: x*y//gcd(x,y)\\n        ab  = lcm(a,b)\\n        ac  = lcm(a,c)\\n        bc  = lcm(b,c)\\n        abc = lcm(ab,c)\\n        #\\n        def index(mid):\\n            # Get n-th index of multiple \"mid\"\\n            Ka,Kb,Kc    = mid//a , mid//b , mid//c\\n            Kabc        = mid//abc\\n            Kab,Kac,Kbc = mid//ab, mid//ac, mid//bc\\n            return Ka + Kb + Kc - Kab - Kac - Kbc + Kabc\\n        def closest(m):\\n            # Find closest number to \"m\" that is a multiple of [a,b,c]\\n            Ka,Kb,Kc = m//a, m//b, m//c\\n            return max(Ka*a,Kb*b,Kc*c)\\n        #\\n        # Low and High Guesses for the K-th multiple (get started with numbers that are multiples themselves)\\n        lo, hi = min(a,b,c), closest(int(2e9))\\n        while lo<=hi:\\n            # m: mid guess\\n            m   = (lo+hi)//2\\n            # mid: closest multiple to mid guess\\n            mid = closest( m )\\n            # Kth: Position of K-th multiple \"mid\"\\n            Kth = index(mid)\\n            if Kth==n:\\n                return mid # Success\\n            if Kth<n:\\n                lo = m + 1 # m was too low\\n            else: # Kth>n\\n                hi = m - 1 # m was too high\\n```",
                "codeTag": "Java"
            },
            {
                "id": 761280,
                "title": "rust-0ms",
                "content": "Runtime: 0 ms, faster than 100.00% of Rust online submissions for Ugly Number III.\\nMemory Usage: 2.1 MB, less than 100.00% of Rust online submissions for Ugly Number III.\\n\\n```rust\\nimpl Solution {\\n    pub fn nth_ugly_number(n: i32, a: i32, b: i32, c: i32) -> i32 {\\n        #[inline]\\n        fn gcd(a: i64, b: i64) -> i64 {\\n            if a == 0 {\\n                b\\n            } else {\\n                gcd(b % a, a)\\n            }\\n        }\\n\\n        #[inline]\\n        fn lcm(a: i64, b: i64) -> i64 {\\n            a / gcd(a, b) * b\\n        }\\n\\n        #[inline]\\n        fn count(x: i64, a: i64, b: i64, c: i64) -> i64 {\\n            x / a + x / b + x / c - x / lcm(a, b) - x / lcm(b, c) - x / lcm(c, a)\\n                + x / lcm(a, lcm(b, c))\\n        }\\n\\n        let mut left = 1;\\n        let mut right = 2_000_000_000;\\n        while left < right {\\n            let mid = left + (right - left) / 2;\\n            if count(mid as i64, a as i64, b as i64, c as i64) as i32 >= n {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        left\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_nth_ugly_number() {\\n        assert_eq!(Solution::nth_ugly_number(3, 2, 3, 5), 4)\\n    }\\n\\n    #[test]\\n    fn test_nth_ugly_number_02() {\\n        assert_eq!(Solution::nth_ugly_number(4, 2, 3, 4), 6)\\n    }\\n\\n    #[test]\\n    fn test_nth_ugly_number_03() {\\n        assert_eq!(Solution::nth_ugly_number(5, 2, 11, 13), 10)\\n    }\\n\\n    #[test]\\n    fn test_nth_ugly_number_04() {\\n        assert_eq!(\\n            Solution::nth_ugly_number(1_000_000_000, 2, 217_983_653, 336_916_467),\\n            1999_999_984\\n        )\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn nth_ugly_number(n: i32, a: i32, b: i32, c: i32) -> i32 {\\n        #[inline]\\n        fn gcd(a: i64, b: i64) -> i64 {\\n            if a == 0 {\\n                b\\n            } else {\\n                gcd(b % a, a)\\n            }\\n        }\\n\\n        #[inline]\\n        fn lcm(a: i64, b: i64) -> i64 {\\n            a / gcd(a, b) * b\\n        }\\n\\n        #[inline]\\n        fn count(x: i64, a: i64, b: i64, c: i64) -> i64 {\\n            x / a + x / b + x / c - x / lcm(a, b) - x / lcm(b, c) - x / lcm(c, a)\\n                + x / lcm(a, lcm(b, c))\\n        }\\n\\n        let mut left = 1;\\n        let mut right = 2_000_000_000;\\n        while left < right {\\n            let mid = left + (right - left) / 2;\\n            if count(mid as i64, a as i64, b as i64, c as i64) as i32 >= n {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        left\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_nth_ugly_number() {\\n        assert_eq!(Solution::nth_ugly_number(3, 2, 3, 5), 4)\\n    }\\n\\n    #[test]\\n    fn test_nth_ugly_number_02() {\\n        assert_eq!(Solution::nth_ugly_number(4, 2, 3, 4), 6)\\n    }\\n\\n    #[test]\\n    fn test_nth_ugly_number_03() {\\n        assert_eq!(Solution::nth_ugly_number(5, 2, 11, 13), 10)\\n    }\\n\\n    #[test]\\n    fn test_nth_ugly_number_04() {\\n        assert_eq!(\\n            Solution::nth_ugly_number(1_000_000_000, 2, 217_983_653, 336_916_467),\\n            1999_999_984\\n        )\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 672901,
                "title": "rust-100-ac-calculate-lcm-from-gcd",
                "content": "#### 100% AC Solution:\\n\\n```\\nimpl Solution {\\n    pub fn nth_ugly_number(n: i32, a: i32, b: i32, c: i32) -> i32 {\\n        let (a, b, c) = (a as i64, b as i64, c as i64);\\n        let lcm_ab = Solution::lcm(a, b);\\n        let lcm_bc = Solution::lcm(b, c);\\n        let lcm_ac = Solution::lcm(a, c);\\n        let lcm_abc = Solution::lcm(lcm_ab, c);\\n\\n        let mut lo: i64 = 1;\\n        let mut hi: i64 = 2 * 1e9 as i64;\\n        while lo < hi {\\n            let mid = lo + (hi - lo) / 2;\\n            let cnt = mid / a + mid / b + mid / c - mid / lcm_ab - mid / lcm_bc - mid / lcm_ac\\n                + mid / lcm_abc;\\n            if cnt < n as i64 {\\n                lo = mid + 1\\n            } else {\\n                hi = mid\\n            }\\n        }\\n        lo as i32\\n    }\\n\\n    pub fn lcm(a: i64, b: i64) -> i64 {\\n        a * b / Solution::gcd(a, b)\\n    }\\n\\n    pub fn gcd(mut x: i64, mut y: i64) -> i64 {\\n        x = x.abs();\\n        y = y.abs();\\n        while y != 0 {\\n            // let (x, y) = (y, x % y);  This will not work! due to rust\\'s binding and ownership.\\n            let tmp = x;\\n            x = y;\\n            y = tmp % y;\\n        }\\n        x\\n    }\\n}\\n\\n```\\n\\n__Time Complexity:__ O(Log(2 * 1e9))\\n__Space Complexity:__ O(1)\\nshould be obvious!\\n\\n#### if we can use crate\\n```\\nextern crate num;\\nuse num::integer::lcm;\\n\\nfn nth_ugly_number(n: i32, a: i32, b: i32, c: i32) -> i32 {\\n    let a = a as i64;\\n    let b = b as i64;\\n    let c = c as i64;\\n    let lcm_ab = lcm(a, b);\\n    let lcm_bc = lcm(b, c);\\n    let lcm_ac = lcm(a, c);\\n    let lcm_abc = lcm(lcm_ab, c);\\n\\n    let mut lo: i64 = 1;\\n    let mut hi: i64 = 2 * 1e9 as i64;\\n    while lo < hi {\\n        let mid = lo + (hi - lo) / 2;\\n        let cnt = mid / a + mid / b + mid / c - mid / lcm_ab - mid / lcm_bc - mid / lcm_ac\\n            + mid / lcm_abc;\\n        if cnt < n as i64 {\\n            lo = mid + 1\\n        } else {\\n            hi = mid\\n        }\\n    }\\n    lo as i32\\n}\\n\\n```\\n\\n__Reference for Rustacean:__\\n* use lcm from crate `num` \\n\\t* https://crates.io/crates/num\\n\\t* https://docs.rs/num/0.2.1/num/integer/fn.lcm.html\\n\\n\\n> Please give it a star \\uD83C\\uDF1F if you find the solution and resources rustacean and helpful!\\n",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn nth_ugly_number(n: i32, a: i32, b: i32, c: i32) -> i32 {\\n        let (a, b, c) = (a as i64, b as i64, c as i64);\\n        let lcm_ab = Solution::lcm(a, b);\\n        let lcm_bc = Solution::lcm(b, c);\\n        let lcm_ac = Solution::lcm(a, c);\\n        let lcm_abc = Solution::lcm(lcm_ab, c);\\n\\n        let mut lo: i64 = 1;\\n        let mut hi: i64 = 2 * 1e9 as i64;\\n        while lo < hi {\\n            let mid = lo + (hi - lo) / 2;\\n            let cnt = mid / a + mid / b + mid / c - mid / lcm_ab - mid / lcm_bc - mid / lcm_ac\\n                + mid / lcm_abc;\\n            if cnt < n as i64 {\\n                lo = mid + 1\\n            } else {\\n                hi = mid\\n            }\\n        }\\n        lo as i32\\n    }\\n\\n    pub fn lcm(a: i64, b: i64) -> i64 {\\n        a * b / Solution::gcd(a, b)\\n    }\\n\\n    pub fn gcd(mut x: i64, mut y: i64) -> i64 {\\n        x = x.abs();\\n        y = y.abs();\\n        while y != 0 {\\n            // let (x, y) = (y, x % y);  This will not work! due to rust\\'s binding and ownership.\\n            let tmp = x;\\n            x = y;\\n            y = tmp % y;\\n        }\\n        x\\n    }\\n}\\n\\n```\n```\\nextern crate num;\\nuse num::integer::lcm;\\n\\nfn nth_ugly_number(n: i32, a: i32, b: i32, c: i32) -> i32 {\\n    let a = a as i64;\\n    let b = b as i64;\\n    let c = c as i64;\\n    let lcm_ab = lcm(a, b);\\n    let lcm_bc = lcm(b, c);\\n    let lcm_ac = lcm(a, c);\\n    let lcm_abc = lcm(lcm_ab, c);\\n\\n    let mut lo: i64 = 1;\\n    let mut hi: i64 = 2 * 1e9 as i64;\\n    while lo < hi {\\n        let mid = lo + (hi - lo) / 2;\\n        let cnt = mid / a + mid / b + mid / c - mid / lcm_ab - mid / lcm_bc - mid / lcm_ac\\n            + mid / lcm_abc;\\n        if cnt < n as i64 {\\n            lo = mid + 1\\n        } else {\\n            hi = mid\\n        }\\n    }\\n    lo as i32\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 619616,
                "title": "1201-ugly-number-iii-py-all-in-one-by-talse",
                "content": "**Get it Done, Make it Better, Share the Best -- Talse**\\n**I). Math LCM: Binary Search**\\n| O(T): O(lgn) | O(S): O(1) | Rt: 28ms | \\n```python\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        lcm = lambda x, y: x * y // math.gcd(x, y)\\n        ab, bc, ac = lcm(a, b), lcm(b, c), lcm(a, c)\\n        abc = lcm(ab, c)\\n        l, r = 0, 2 * (10 ** 9)\\n        while l < r:\\n            m = l + (r - l) // 2\\n            ct = m//a + m//b + m//c - m//ab - m//bc - m//ac + m//abc\\n            if ct < n: l = m+1\\n            else: r = m\\n        return l\\n```\\nReferrence: https://leetcode.com/problems/ugly-number-iii/discuss/387539/cpp-Binary-Search-with-picture-and-Binary-Search-Template\\n\\nAlternative: | Rt: 28ms |\\n```python\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        def gcd(a, b):\\n            while b:\\n                a, b = b, a%b\\n            return a\\n        \\n        lcm = lambda x, y: x * y // gcd(x, y)\\n        ab, bc, ac = lcm(a, b), lcm(b, c), lcm(a, c)\\n        abc = lcm(ab, c)\\n        l, r = 0, 2 * (10 ** 9)\\n        while l < r:\\n            m = l + (r - l) // 2\\n            ct = m//a + m//b + m//c - m//ab - m//bc - m//ac + m//abc\\n            if ct < n: l = m+1\\n            else: r = m\\n        return l\\n```",
                "solutionTags": [],
                "code": "```python\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        lcm = lambda x, y: x * y // math.gcd(x, y)\\n        ab, bc, ac = lcm(a, b), lcm(b, c), lcm(a, c)\\n        abc = lcm(ab, c)\\n        l, r = 0, 2 * (10 ** 9)\\n        while l < r:\\n            m = l + (r - l) // 2\\n            ct = m//a + m//b + m//c - m//ab - m//bc - m//ac + m//abc\\n            if ct < n: l = m+1\\n            else: r = m\\n        return l\\n```\n```python\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        def gcd(a, b):\\n            while b:\\n                a, b = b, a%b\\n            return a\\n        \\n        lcm = lambda x, y: x * y // gcd(x, y)\\n        ab, bc, ac = lcm(a, b), lcm(b, c), lcm(a, c)\\n        abc = lcm(ab, c)\\n        l, r = 0, 2 * (10 ** 9)\\n        while l < r:\\n            m = l + (r - l) // 2\\n            ct = m//a + m//b + m//c - m//ab - m//bc - m//ac + m//abc\\n            if ct < n: l = m+1\\n            else: r = m\\n        return l\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 591808,
                "title": "c-100-time-and-space-using-binary-search",
                "content": "The concept used here is to find the smallest number x such that \\nthe number of values v<=x divisible by either a,b, or c is n.\\nBinary search can be used to find this value. \\n\\nFor finding the number of values v<=x divisible by either a,b, or c :\\nWe need to use Inclusion-exclusion principle as the values divisible by lcm(a,b), lcm(b,c) and lcm(c,a) get counted more than once.\\nSo subtract x/lcm(a,b) , x/lcm(b,c) and x/lcm(a,c).\\nNow the values which are divisible by lcm(a,b,c) have been removed more than once, therefore we need to include then again.\\nSo add x/lcm(a,lcm(b,c))\\n\\n\\n```\\nclass Solution {\\npublic:\\n    long long lcm(long long a,long long b){\\n        return (a*b)/__gcd(a,b);\\n    }\\n    \\n    long long func(long long x,long long a,long long b,long long c){\\n        long long ans = x/a + x/b + x/c - x/lcm(a,b) - x/lcm(b,c) - x/lcm(c,a) + x/lcm(a,lcm(b,c));\\n        return ans;\\n    }\\n    \\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        long long low = min(a,min(b,c)),high = INT_MAX,mid;\\n        while(low<high){\\n            mid = (low+high)/2;\\n            if(func(mid,a,b,c)>=n){\\n                high = mid-1;\\n            }\\n            else if(func(mid,a,b,c)<n){\\n                low = mid+1;\\n            }\\n        }\\n        while(func(mid,a,b,c)<n) mid++;\\n        while(func(mid,a,b,c)>=n) mid--;\\n        return mid+1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long lcm(long long a,long long b){\\n        return (a*b)/__gcd(a,b);\\n    }\\n    \\n    long long func(long long x,long long a,long long b,long long c){\\n        long long ans = x/a + x/b + x/c - x/lcm(a,b) - x/lcm(b,c) - x/lcm(c,a) + x/lcm(a,lcm(b,c));\\n        return ans;\\n    }\\n    \\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        long long low = min(a,min(b,c)),high = INT_MAX,mid;\\n        while(low<high){\\n            mid = (low+high)/2;\\n            if(func(mid,a,b,c)>=n){\\n                high = mid-1;\\n            }\\n            else if(func(mid,a,b,c)<n){\\n                low = mid+1;\\n            }\\n        }\\n        while(func(mid,a,b,c)<n) mid++;\\n        while(func(mid,a,b,c)>=n) mid--;\\n        return mid+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 487173,
                "title": "3-lines-binary-search-with-inclusion-exclusion-ruby",
                "content": "Same idea that apparently everyone else came up with as well (so I won\\'t repeat the explanation), but Ruby is so awesome that it not only provides simple short binary search but even least common multiple.\\n```\\ndef nth_ugly_number(n, a, b, c)\\n  ab, ac, bc = a.lcm(b), a.lcm(c), b.lcm(c)\\n  abc = ab.lcm(c)\\n  (1..2*10**9).bsearch { |m| m/a + m/b + m/c - m/ab - m/ac - m/bc + m/abc >= n }\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef nth_ugly_number(n, a, b, c)\\n  ab, ac, bc = a.lcm(b), a.lcm(c), b.lcm(c)\\n  abc = ab.lcm(c)\\n  (1..2*10**9).bsearch { |m| m/a + m/b + m/c - m/ab - m/ac - m/bc + m/abc >= n }\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 467329,
                "title": "most-efficient-c-solution-faster-than-100-100-memory-efficient",
                "content": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        long long ab,bc,ac,abc,l=1,r=2*1e9,m,ans;\\n        ab=(long long)a*b/__gcd(a,b);\\n        bc=(long long)b*c/__gcd(b,c);\\n        ac=(long long)a*c/__gcd(a,c);\\n        abc=ab*c/__gcd(ab,(long long)c);\\n        while(l<=r){\\n            m=(l+r)/2;\\n            ans=m/a+m/b+m/c+m/abc-m/ab-m/bc-m/ac;\\n            if(ans<n)\\n                l=m+1;\\n            else\\n                r=m-1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        long long ab,bc,ac,abc,l=1,r=2*1e9,m,ans;\\n        ab=(long long)a*b/__gcd(a,b);\\n        bc=(long long)b*c/__gcd(b,c);\\n        ac=(long long)a*c/__gcd(a,c);\\n        abc=ab*c/__gcd(ab,(long long)c);\\n        while(l<=r){\\n            m=(l+r)/2;\\n            ans=m/a+m/b+m/c+m/abc-m/ab-m/bc-m/ac;\\n            if(ans<n)\\n                l=m+1;\\n            else\\n                r=m-1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 424329,
                "title": "0-ms-c-solution-faster-than-100-percent",
                "content": "```\\ntypedef long long int ll;\\nclass Solution {\\npublic:\\n    int f(ll &n, int &a, int &b, int &c, ll &d, ll &e, ll &f, ll &g){\\n        return n/a+n/b+n/c-n/d-n/e-n/f+n/g;\\n    }\\n    \\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        ll lcmab = ((ll)a*b)/gcd(a,b);\\n        ll lcmbc = ((ll)b*c)/gcd(b,c);\\n        ll lcmac = ((ll)a*c)/gcd(a,c);\\n        ll lcmabc = ((ll)a*lcmbc)/gcd(a,lcmbc);\\n        int ans;\\n        int l=0, r=2*1e9;\\n        while(l<r){\\n            ll mid=((ll)l+r)/2;\\n            ll count = f(mid,a,b,c,lcmab,lcmbc,lcmac,lcmabc);\\n            if(count >= n) r = mid;\\n            else l = mid+1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef long long int ll;\\nclass Solution {\\npublic:\\n    int f(ll &n, int &a, int &b, int &c, ll &d, ll &e, ll &f, ll &g){\\n        return n/a+n/b+n/c-n/d-n/e-n/f+n/g;\\n    }\\n    \\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        ll lcmab = ((ll)a*b)/gcd(a,b);\\n        ll lcmbc = ((ll)b*c)/gcd(b,c);\\n        ll lcmac = ((ll)a*c)/gcd(a,c);\\n        ll lcmabc = ((ll)a*lcmbc)/gcd(a,lcmbc);\\n        int ans;\\n        int l=0, r=2*1e9;\\n        while(l<r){\\n            ll mid=((ll)l+r)/2;\\n            ll count = f(mid,a,b,c,lcmab,lcmbc,lcmac,lcmabc);\\n            if(count >= n) r = mid;\\n            else l = mid+1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 423450,
                "title": "python-concise-bi-search",
                "content": "numbers <=x which is divider of a,b,c==f(x)==f(a)+f(b)+f(c)-f(divide a,b)-f(divide b,c)-f(divide a,c)+f(divide a,b,c)\\nanother formula gcm(a,b)=a*b/gcd(a,b)\\n```\\nclass Solution(object):\\n    def nthUglyNumber(self, n, a, b, c):\\n        def gcd(a,b):\\n            while b>0:\\n                a,b=b,a%b\\n            return a\\n        \\n        def gcm(a,b):\\n            return a*b/gcd(a,b)\\n        \\n        def f(x,a):\\n            return x//a\\n        \\n        l,r=0,2*10**9\\n        while l<r:\\n            mid=(l+r)//2\\n            num=f(mid,a)+f(mid,b)+f(mid,c)-f(mid,gcm(a,b))-f(mid,gcm(b,c))-f(mid,gcm(a,c))+f(mid,gcm(gcm(a,b),c))\\n            if num==n:\\n                r=mid\\n            elif num>n:\\n                r=mid-1\\n            else:\\n                l=mid+1\\n        return l",
                "solutionTags": [],
                "code": "numbers <=x which is divider of a,b,c==f(x)==f(a)+f(b)+f(c)-f(divide a,b)-f(divide b,c)-f(divide a,c)+f(divide a,b,c)\\nanother formula gcm(a,b)=a*b/gcd(a,b)\\n```\\nclass Solution(object):\\n    def nthUglyNumber(self, n, a, b, c):\\n        def gcd(a,b):\\n            while b>0:\\n                a,b=b,a%b\\n            return a\\n        \\n        def gcm(a,b):\\n            return a*b/gcd(a,b)\\n        \\n        def f(x,a):\\n            return x//a\\n        \\n        l,r=0,2*10**9\\n        while l<r:\\n            mid=(l+r)//2\\n            num=f(mid,a)+f(mid,b)+f(mid,c)-f(mid,gcm(a,b))-f(mid,gcm(b,c))-f(mid,gcm(a,c))+f(mid,gcm(gcm(a,b),c))\\n            if num==n:\\n                r=mid\\n            elif num>n:\\n                r=mid-1\\n            else:\\n                l=mid+1\\n        return l",
                "codeTag": "Java"
            },
            {
                "id": 389059,
                "title": "clean-python-solution-beat-99-submission",
                "content": "```\\ndef nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n\\tfrom math import gcd\\n\\tab = a * b // gcd(a, b)\\n\\tac = a * c // gcd(a, c)\\n\\tbc = b * c // gcd(b, c)\\n\\tabc = ab * c // gcd(ab, c)\\n\\tl, r = 1, min(a, b, c) * n\\n\\twhile l < r:\\n\\t\\tmid = (l + r) // 2\\n\\t\\tcnt = mid//a + mid // b + mid//c - mid//ab - mid//ac - mid//bc + mid//abc\\n\\t\\tif cnt < n:\\n\\t\\t\\tl = mid + 1\\n\\t\\telse:\\n\\t\\t\\tr = mid\\n\\treturn l\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\ndef nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n\\tfrom math import gcd\\n\\tab = a * b // gcd(a, b)\\n\\tac = a * c // gcd(a, c)\\n\\tbc = b * c // gcd(b, c)\\n\\tabc = ab * c // gcd(ab, c)\\n\\tl, r = 1, min(a, b, c) * n\\n\\twhile l < r:\\n\\t\\tmid = (l + r) // 2\\n\\t\\tcnt = mid//a + mid // b + mid//c - mid//ab - mid//ac - mid//bc + mid//abc\\n\\t\\tif cnt < n:\\n\\t\\t\\tl = mid + 1\\n\\t\\telse:\\n\\t\\t\\tr = mid\\n\\treturn l\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 388461,
                "title": "c-binary-search-solution-with-explanation",
                "content": "My solution is inspired by hint 1. Our goal is to find a function f that f(x) means number of ugly number smaller than or equal to x.\\n\\nFor number x, there are x/a number can be divisible by a, x/b number can be divisible by b and x/c number can be divisible by c.\\nHowever, in such case, if one number can be divisible by both (a,b), we count it twice. We have to subtract those cases from our total count. \\n\\nLucky enough, if a number can be divisible by both (a,b), it must can be divisible by lcm(a,b). So we need to calucalte least common multiple between (a,b) (b,c) (a,c) and (a,b,c).\\n\\nThen we know, there are x/lcm(a,b) number can be divisible by both (a,b), x/lcm(b,c) number can be divisible by both (b,c), and x/lcm(a,c) number can be divisible by both (a,c). \\n\\nHowever, after subtracting them, we don\\'t count number which can be divisible by (a,b,c) together, to fix it, we simply need to add x/lcm(a,lcm(b,c)).\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    long long gcd(long long a, long long b){\\n        if(b == 0){\\n            return a;\\n        }\\n        return gcd(b, a%b);\\n    }\\n    \\n    long long lcm(long long a, long long b){\\n        if(a<b){\\n            swap(a,b);\\n        }\\n        return a*b / gcd(a,b);\\n    }\\n    \\n    template<typename T>\\n    void sort3(T& a, T& b, T& c){\\n        if (a > c)\\n            swap(a, c);\\n        if (a > b)\\n            swap(a, b);\\n        if (b > c)\\n            swap(b, c);\\n    }\\n    \\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        sort3(a,b,c);\\n        long long ab = lcm(a,b);\\n        long long bc = lcm(b,c);\\n        long long ac = lcm(a,c);\\n        long long abc = lcm(a,lcm(b,c));\\n        auto f = [&](long long x){\\n            return x/a + x/b + x/c - x/ab - x/ac - x/bc + x/abc;\\n        };\\n        long long l = a;\\n        long long r = a*n;\\n        while(l<r){\\n            long long m = (l+r)/2;\\n            int _n = f(m);\\n            if(_n == n){\\n                r = m;\\n                break;\\n            }\\n            else if (_n<n){\\n                l = m + 1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n        while(r){\\n            if(r%a == 0 || r%b == 0 || r%c == 0){\\n                return r;\\n            }\\n            r--;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long gcd(long long a, long long b){\\n        if(b == 0){\\n            return a;\\n        }\\n        return gcd(b, a%b);\\n    }\\n    \\n    long long lcm(long long a, long long b){\\n        if(a<b){\\n            swap(a,b);\\n        }\\n        return a*b / gcd(a,b);\\n    }\\n    \\n    template<typename T>\\n    void sort3(T& a, T& b, T& c){\\n        if (a > c)\\n            swap(a, c);\\n        if (a > b)\\n            swap(a, b);\\n        if (b > c)\\n            swap(b, c);\\n    }\\n    \\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        sort3(a,b,c);\\n        long long ab = lcm(a,b);\\n        long long bc = lcm(b,c);\\n        long long ac = lcm(a,c);\\n        long long abc = lcm(a,lcm(b,c));\\n        auto f = [&](long long x){\\n            return x/a + x/b + x/c - x/ab - x/ac - x/bc + x/abc;\\n        };\\n        long long l = a;\\n        long long r = a*n;\\n        while(l<r){\\n            long long m = (l+r)/2;\\n            int _n = f(m);\\n            if(_n == n){\\n                r = m;\\n                break;\\n            }\\n            else if (_n<n){\\n                l = m + 1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n        while(r){\\n            if(r%a == 0 || r%b == 0 || r%c == 0){\\n                return r;\\n            }\\n            r--;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 387736,
                "title": "python3-beats-100",
                "content": "If it\\'s nth ugly number in sequence, then this number must be less than **a * n**. With this limit, the binary search can be more efficient.\\n```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        def lcm(a, b):\\n            return (a * b) // math.gcd(a, b) # a, b, c >= 1\\n        \\n        def count(val, a, b, c):\\n            return (val // a) + (val // b) + (val // c) - (val // lcm(a, b)) - \\\\\\n                   (val // lcm(a, c)) - (val // lcm(b, c)) + (val // lcm(lcm(a, b), c))\\n        \\n        low = 1\\n        high = n * a\\n        \\n        while low < high:\\n            mid = low + (high - low) // 2\\n            if count(mid, a, b, c) < n:\\n                low = mid + 1\\n            else:\\n                high = mid\\n        return low\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        def lcm(a, b):\\n            return (a * b) // math.gcd(a, b) # a, b, c >= 1\\n        \\n        def count(val, a, b, c):\\n            return (val // a) + (val // b) + (val // c) - (val // lcm(a, b)) - \\\\\\n                   (val // lcm(a, c)) - (val // lcm(b, c)) + (val // lcm(lcm(a, b), c))\\n        \\n        low = 1\\n        high = n * a\\n        \\n        while low < high:\\n            mid = low + (high - low) // 2\\n            if count(mid, a, b, c) < n:\\n                low = mid + 1\\n            else:\\n                high = mid\\n        return low\\n```",
                "codeTag": "Java"
            },
            {
                "id": 387728,
                "title": "java-clean-binarysearch-solution",
                "content": "```\\nclass Solution {\\n   public int nthUglyNumber(int n, int a, int b, int c) {\\n        int start = 1, end = Integer.MAX_VALUE;\\n        while (start + 1 < end) {\\n            int mid = start + (end - start) / 2;\\n            if (countUgly(a, b, c, mid) >= n) {\\n                end = mid;\\n            } else {\\n                start = mid;\\n            }\\n        }\\n        return end;\\n    }\\n\\n    private int countUgly(int a, int b, int c, int target) {\\n        int count = 0;\\n        count += (target / a + target / b + target / c);\\n        count -= (target / GCM(a, b) + target / GCM(a, c) + target / GCM(b, c));\\n        count += target / GCM(a, GCM(b, c));\\n        return count;\\n    }\\n\\n    private long GCM(long a, long b) {\\n        return a * b / GCD(a, b);\\n    }\\n\\n    private long GCD(long a, long b) {\\n        if (b != 0) {\\n            return GCD(b, a % b);\\n        }\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n   public int nthUglyNumber(int n, int a, int b, int c) {\\n        int start = 1, end = Integer.MAX_VALUE;\\n        while (start + 1 < end) {\\n            int mid = start + (end - start) / 2;\\n            if (countUgly(a, b, c, mid) >= n) {\\n                end = mid;\\n            } else {\\n                start = mid;\\n            }\\n        }\\n        return end;\\n    }\\n\\n    private int countUgly(int a, int b, int c, int target) {\\n        int count = 0;\\n        count += (target / a + target / b + target / c);\\n        count -= (target / GCM(a, b) + target / GCM(a, c) + target / GCM(b, c));\\n        count += target / GCM(a, GCM(b, c));\\n        return count;\\n    }\\n\\n    private long GCM(long a, long b) {\\n        return a * b / GCD(a, b);\\n    }\\n\\n    private long GCD(long a, long b) {\\n        if (b != 0) {\\n            return GCD(b, a % b);\\n        }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 387554,
                "title": "cxx-inclusion-exclusion-and-binary-search",
                "content": "Inclusion-Exclusion may be visualized by the following Venn-diagram\\n\\n```\\n             \\n      /-----------------------------\\\\\\n      |  Divisible by A             |\\n      |                             |\\n      |                             |\\n /----+---------------\\\\             |\\n/     | Div. by       |             |\\n|     | A and B       |             |\\n|     |               |             |\\n|     |    /----------+-------------+---------\\\\\\n|     |    |Div by    | Divisible   |         |\\n|     |    |A,B and C |   by A and C|         |\\n|     |    |          |             |         |\\n|     \\\\----+----------+-------------/         |\\n|          | Div. by  |                       |\\n| Divisible|  B and C |                       |\\n|  by B    |          |  Divisible            |\\n|          |          |     by C              |\\n|          |          |                       |\\n\\\\----------+----------/                       |\\n           |                                  |\\n\\t\\t   \\\\----------------------------------/\\n\\n```\\n\\n```\\nclass Solution {\\npublic:\\n\\tlong gcd(long a, long b) {\\n\\t\\tlong rem = 0;\\n\\t\\tdo {\\n\\t\\t\\trem = a % b;\\n\\t\\t\\ta = b;\\n\\t\\t\\tb = rem;\\n\\t\\t} while (b!=0);\\n\\t\\treturn a;\\n\\t}\\n\\tlong lcm(long a, long b) {\\n\\t\\treturn a * b / gcd(a,b);\\n\\t}\\n\\tlong a, b, c, lcm_ab, lcm_bc, lcm_ac, lcm_abc;\\n\\tint rank(int x) {\\n\\t\\treturn x/a + x/b + x/c - x/lcm_ab - x/lcm_bc - x/lcm_ac + x/lcm_abc;\\n\\t}\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n\\t\\tthis->a = a;\\n\\t\\tthis->b = b;\\n\\t\\tthis->c = c;\\n\\t\\tlcm_ab =  lcm(long(a), long(b));\\n\\t\\tlcm_bc =  lcm(long(b), long(c));\\n\\t\\tlcm_ac =  lcm(long(a), long(c));\\n\\t\\tlcm_abc = lcm(long(lcm_ac), long(b));\\n\\n\\t\\t// lb = Lower Bound, ub = Upper Bound\\n\\t\\tint lb = 1, ub = 2147483647;\\n\\n\\t\\t// Binary Search!\\n\\t\\twhile (lb+1 < ub) {\\n\\t\\t\\tint mid = int((long(lb) + long(ub)) / 2L);\\n\\t\\t\\tint rank_mid = rank(mid);\\n\\t\\t\\tif (rank_mid < n) { lb = mid; }\\n\\t\\t\\telse ub = mid;\\n\\n\\t\\t\\tprintf(\"%d,%d\\\\n\", lb, ub);\\n\\t\\t}\\n\\t\\tif (rank(lb) == n) return lb;\\n\\t\\telse return ub;\\n    }\\n};\\n\\nint main() {\\n\\tSolution s;\\n\\tprintf(\"%d\\\\n\", s.nthUglyNumber(3, 2, 3, 5));\\n\\tprintf(\"%d\\\\n\", s.nthUglyNumber(4, 2, 3, 4));\\n\\tprintf(\"%d\\\\n\", s.nthUglyNumber(1000000000, 2, 217983653, 336916467));\\n}\\n\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\n             \\n      /-----------------------------\\\\\\n      |  Divisible by A             |\\n      |                             |\\n      |                             |\\n /----+---------------\\\\             |\\n/     | Div. by       |             |\\n|     | A and B       |             |\\n|     |               |             |\\n|     |    /----------+-------------+---------\\\\\\n|     |    |Div by    | Divisible   |         |\\n|     |    |A,B and C |   by A and C|         |\\n|     |    |          |             |         |\\n|     \\\\----+----------+-------------/         |\\n|          | Div. by  |                       |\\n| Divisible|  B and C |                       |\\n|  by B    |          |  Divisible            |\\n|          |          |     by C              |\\n|          |          |                       |\\n\\\\----------+----------/                       |\\n           |                                  |\\n\\t\\t   \\\\----------------------------------/\\n\\n```\n```\\nclass Solution {\\npublic:\\n\\tlong gcd(long a, long b) {\\n\\t\\tlong rem = 0;\\n\\t\\tdo {\\n\\t\\t\\trem = a % b;\\n\\t\\t\\ta = b;\\n\\t\\t\\tb = rem;\\n\\t\\t} while (b!=0);\\n\\t\\treturn a;\\n\\t}\\n\\tlong lcm(long a, long b) {\\n\\t\\treturn a * b / gcd(a,b);\\n\\t}\\n\\tlong a, b, c, lcm_ab, lcm_bc, lcm_ac, lcm_abc;\\n\\tint rank(int x) {\\n\\t\\treturn x/a + x/b + x/c - x/lcm_ab - x/lcm_bc - x/lcm_ac + x/lcm_abc;\\n\\t}\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n\\t\\tthis->a = a;\\n\\t\\tthis->b = b;\\n\\t\\tthis->c = c;\\n\\t\\tlcm_ab =  lcm(long(a), long(b));\\n\\t\\tlcm_bc =  lcm(long(b), long(c));\\n\\t\\tlcm_ac =  lcm(long(a), long(c));\\n\\t\\tlcm_abc = lcm(long(lcm_ac), long(b));\\n\\n\\t\\t// lb = Lower Bound, ub = Upper Bound\\n\\t\\tint lb = 1, ub = 2147483647;\\n\\n\\t\\t// Binary Search!\\n\\t\\twhile (lb+1 < ub) {\\n\\t\\t\\tint mid = int((long(lb) + long(ub)) / 2L);\\n\\t\\t\\tint rank_mid = rank(mid);\\n\\t\\t\\tif (rank_mid < n) { lb = mid; }\\n\\t\\t\\telse ub = mid;\\n\\n\\t\\t\\tprintf(\"%d,%d\\\\n\", lb, ub);\\n\\t\\t}\\n\\t\\tif (rank(lb) == n) return lb;\\n\\t\\telse return ub;\\n    }\\n};\\n\\nint main() {\\n\\tSolution s;\\n\\tprintf(\"%d\\\\n\", s.nthUglyNumber(3, 2, 3, 5));\\n\\tprintf(\"%d\\\\n\", s.nthUglyNumber(4, 2, 3, 4));\\n\\tprintf(\"%d\\\\n\", s.nthUglyNumber(1000000000, 2, 217983653, 336916467));\\n}\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3996401,
                "title": "100-beat-easy-to-understand-solution-using-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long gcd(long long a,long long b){\\n        if(b==0){\\n            return a;\\n        }\\n        else{\\n            return gcd(b,a%b);\\n        }\\n        return 0;\\n    }\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n    long long left=1,right=1e13;\\n    long long a_b=(1ll*a*b)/(1ll*gcd(1ll*a,1ll*b));\\n    long long a_c=(1ll*a*c)/(1ll*gcd(1ll*a,1ll*c));\\n    long long b_c=(1ll*b*c)/(1ll*gcd(1ll*b,1ll*c));\\n    long long a_b_c=(1ll*a_b*c)/(1ll*gcd(a_b,1ll*c));\\n    long long ans=-1;\\n    while(left<=right){\\n        long long mid=(left+right)/2;\\n    long long count=mid/a+mid/b+mid/c-mid/a_b-mid/a_c-mid/b_c+mid/a_b_c;\\n    if(count==n){\\n    \\n        ans=mid;\\n        right=mid-1;\\n    }\\n    else if(count>n){\\n        right=mid-1;\\n    }\\n    else{\\n        left=mid+1;\\n    }\\n    }\\n    return  ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long gcd(long long a,long long b){\\n        if(b==0){\\n            return a;\\n        }\\n        else{\\n            return gcd(b,a%b);\\n        }\\n        return 0;\\n    }\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n    long long left=1,right=1e13;\\n    long long a_b=(1ll*a*b)/(1ll*gcd(1ll*a,1ll*b));\\n    long long a_c=(1ll*a*c)/(1ll*gcd(1ll*a,1ll*c));\\n    long long b_c=(1ll*b*c)/(1ll*gcd(1ll*b,1ll*c));\\n    long long a_b_c=(1ll*a_b*c)/(1ll*gcd(a_b,1ll*c));\\n    long long ans=-1;\\n    while(left<=right){\\n        long long mid=(left+right)/2;\\n    long long count=mid/a+mid/b+mid/c-mid/a_b-mid/a_c-mid/b_c+mid/a_b_c;\\n    if(count==n){\\n    \\n        ans=mid;\\n        right=mid-1;\\n    }\\n    else if(count>n){\\n        right=mid-1;\\n    }\\n    else{\\n        left=mid+1;\\n    }\\n    }\\n    return  ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929703,
                "title": "java-solution-for-nth-ugly-number-inclusion-exclusion-principles-binary-search",
                "content": "\\n# Approach\\nSteps:\\n1. Find GCD\\n2. Find LCM\\n3. Create function based on of Inclusion-Exclusion Sets principle\\n4. Do a binary search to find the nth element\\n\\n# Complexity\\n- Time complexity:\\nFor LCM & GCD :  O(log min(a, b))\\nFor Binary Search : O(log M)\\nOverall : O(log M)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        int left  = 1;\\n        int right = Integer.MAX_VALUE;\\n\\n        while( left < right){                       //  Binary Search\\n            int m = left + (right - left) /2;  \\n            if( isUgly(m, a, b, c, n))\\n                right = m;\\n            \\n            else\\n                left = m +1;\\n        }\\n        return left;\\n    }\\n\\n    public long gcd ( long a, long  b){  // Function to find GCD using\\n        if( a == 0){                        //      Recursion\\n            return b;\\n        }\\n        else{\\n            return gcd(b%a, a);\\n        }\\n    }\\n\\n    public long lcm ( long a, long b){      // Formual to calculate\\n        return (a*b)/ (gcd(a,b));              //  lcm using gcd\\n    }\\n\\n    public boolean isUgly(long m, long a, long b, long c, long n){ // Inclucsion Sets Principle\\n        return (int) (m/a + m/b + m/c - m/lcm(a,b) - m/lcm(b,c) - m/ lcm(c,a) + m/ lcm(a, lcm(b,c))) >= n;   \\n    }                                        \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        int left  = 1;\\n        int right = Integer.MAX_VALUE;\\n\\n        while( left < right){                       //  Binary Search\\n            int m = left + (right - left) /2;  \\n            if( isUgly(m, a, b, c, n))\\n                right = m;\\n            \\n            else\\n                left = m +1;\\n        }\\n        return left;\\n    }\\n\\n    public long gcd ( long a, long  b){  // Function to find GCD using\\n        if( a == 0){                        //      Recursion\\n            return b;\\n        }\\n        else{\\n            return gcd(b%a, a);\\n        }\\n    }\\n\\n    public long lcm ( long a, long b){      // Formual to calculate\\n        return (a*b)/ (gcd(a,b));              //  lcm using gcd\\n    }\\n\\n    public boolean isUgly(long m, long a, long b, long c, long n){ // Inclucsion Sets Principle\\n        return (int) (m/a + m/b + m/c - m/lcm(a,b) - m/lcm(b,c) - m/ lcm(c,a) + m/ lcm(a, lcm(b,c))) >= n;   \\n    }                                        \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3807293,
                "title": "bs-approach-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int __gcd(int a,int b){\\n        if(b==0)return a;\\n        return __gcd(b,a%b);\\n    }\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        long long l=1;\\n        long long r=2000000000;\\n        long long amb = 1ll*a*b;\\n        long long bmc = 1ll*b*c;\\n        long long cma = 1ll*a*c;\\n        long long a_b=(amb)/__gcd(a,b);\\n        long long b_c=(bmc)/__gcd(b,c);\\n        long long a_c=(cma)/__gcd(a,c);\\n        long long a_b_c=(a_b*c)/__gcd(a_b,c);\\n        while(l<r){\\n            long long mid = l+(r-l)/2;\\n            long long lessOrEqualToMid = (mid/a + mid/b + mid/c - mid/(a_b) - mid/(b_c) - mid/(a_c) + mid/(a_b_c));\\n            if(lessOrEqualToMid < n){\\n                l=mid+1;\\n            }else{\\n                r=mid;\\n            }\\n        }return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int __gcd(int a,int b){\\n        if(b==0)return a;\\n        return __gcd(b,a%b);\\n    }\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        long long l=1;\\n        long long r=2000000000;\\n        long long amb = 1ll*a*b;\\n        long long bmc = 1ll*b*c;\\n        long long cma = 1ll*a*c;\\n        long long a_b=(amb)/__gcd(a,b);\\n        long long b_c=(bmc)/__gcd(b,c);\\n        long long a_c=(cma)/__gcd(a,c);\\n        long long a_b_c=(a_b*c)/__gcd(a_b,c);\\n        while(l<r){\\n            long long mid = l+(r-l)/2;\\n            long long lessOrEqualToMid = (mid/a + mid/b + mid/c - mid/(a_b) - mid/(b_c) - mid/(a_c) + mid/(a_b_c));\\n            if(lessOrEqualToMid < n){\\n                l=mid+1;\\n            }else{\\n                r=mid;\\n            }\\n        }return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630940,
                "title": "the-inclusion-exclusion-principle",
                "content": "148A (RU): https://codeforces.com/blog/entry/3819\\n```ruby\\ndef nth_ugly_number n, *d0\\n    a, b, c = *d0.sort!\\n    d1 = [a.lcm(b), a.lcm(c), b.lcm(c)]\\n    d2 = d0.reduce(&:lcm)\\n    (1..a * n).bsearch do | x |\\n        r = d0.sum { x / _1 } -\\n            d1.sum { x / _1 } +\\n            x / d2\\n        return x if r == n && d0.any? { x % _1 == 0 }\\n        r >= n\\n    end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef nth_ugly_number n, *d0\\n    a, b, c = *d0.sort!\\n    d1 = [a.lcm(b), a.lcm(c), b.lcm(c)]\\n    d2 = d0.reduce(&:lcm)\\n    (1..a * n).bsearch do | x |\\n        r = d0.sum { x / _1 } -\\n            d1.sum { x / _1 } +\\n            x / d2\\n        return x if r == n && d0.any? { x % _1 == 0 }\\n        r >= n\\n    end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3626938,
                "title": "just-to-be-a-c-version-of-the-code",
                "content": "# Code\\n```\\npublic class Solution {\\n    int max_ans = 2000000000;\\n\\n    public int NthUglyNumber(int n, int a, int b, int c) {\\n        int l = 1, r = max_ans, result = 0;\\n        while (l <= r) {\\n            int mid = l + (r - l) / 2;\\n            if ( count(mid,a,b,c) >= n) {\\n                // find mid as small as possible that count == n\\n                result = mid;\\n                r = mid - 1;\\n            }\\n            else l = mid + 1;\\n        }\\n        return result;\\n    }\\n\\n    public int count(long num, long a, long b, long c) {\\n        return (int)(num / a + num / b + num / c\\n            - num / lcm(a, b)\\n            - num / lcm(b, c)\\n            - num / lcm(a, c)\\n            + num / (lcm(a,lcm(b, c)))\\n            );\\n    }\\n\\n    // Greatest common divider\\n    public long gcd(long a, long b){\\n        if (a == 0) return b;\\n        return gcd(b % a, a);\\n    }\\n\\n    // Least common multiple\\n    public long lcm(long a, long b){\\n        return a * b / gcd(a, b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Math",
                    "Binary Search"
                ],
                "code": "```\\npublic class Solution {\\n    int max_ans = 2000000000;\\n\\n    public int NthUglyNumber(int n, int a, int b, int c) {\\n        int l = 1, r = max_ans, result = 0;\\n        while (l <= r) {\\n            int mid = l + (r - l) / 2;\\n            if ( count(mid,a,b,c) >= n) {\\n                // find mid as small as possible that count == n\\n                result = mid;\\n                r = mid - 1;\\n            }\\n            else l = mid + 1;\\n        }\\n        return result;\\n    }\\n\\n    public int count(long num, long a, long b, long c) {\\n        return (int)(num / a + num / b + num / c\\n            - num / lcm(a, b)\\n            - num / lcm(b, c)\\n            - num / lcm(a, c)\\n            + num / (lcm(a,lcm(b, c)))\\n            );\\n    }\\n\\n    // Greatest common divider\\n    public long gcd(long a, long b){\\n        if (a == 0) return b;\\n        return gcd(b % a, a);\\n    }\\n\\n    // Least common multiple\\n    public long lcm(long a, long b){\\n        return a * b / gcd(a, b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3616631,
                "title": "easy-viennn-diagram-principles",
                "content": "```\\nlong long ab,ac,bc,abc;\\n    long long solve(int m,int a,int b,int c)\\n    {\\n        long long count=0;\\n        \\n        /// draw the veiin diagram \\n        \\n        count+=(m/a);\\n        count+=(m/b);\\n        count+=(m/c);\\n        \\n        count-=(m/ab);\\n        count-=(m/ac);\\n        count-=(m/bc);\\n        \\n        count+=(m/abc);\\n        return count;\\n        \\n        \\n    }\\n    int nthUglyNumber(int n, int A, int B, int C)\\n    {\\n        long long l=1,h=2*1e9;\\n        long long a=A,b=B,c=C;\\n        long long pro=a*b;\\n        ab=pro/__gcd(a,b);\\n        pro=a*c;\\n        ac=pro/__gcd(a,c);\\n        pro=b*c;\\n        bc=pro/__gcd(b,c);\\n        pro=ab*c;\\n        abc=pro/__gcd(ab,c);\\n \\n        while(l<=h)\\n        {\\n            long long m=l+(h-l)/2;\\n            \\n            long long uglyCount=solve(m,a,b,c);\\n            \\n            bool checkDivisibility =(m%a==0) || (m%b==0) || (m%c==0);\\n            \\n            if(uglyCount==n and checkDivisibility)\\n                return m;\\n            if(uglyCount>=n) // answer will be on right side \\n                h=m-1;\\n            else\\n                l=m+1;\\n        }\\n        \\n        return -1;\\n    }\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nlong long ab,ac,bc,abc;\\n    long long solve(int m,int a,int b,int c)\\n    {\\n        long long count=0;\\n        \\n        /// draw the veiin diagram \\n        \\n        count+=(m/a);\\n        count+=(m/b);\\n        count+=(m/c);\\n        \\n        count-=(m/ab);\\n        count-=(m/ac);\\n        count-=(m/bc);\\n        \\n        count+=(m/abc);\\n        return count;\\n        \\n        \\n    }\\n    int nthUglyNumber(int n, int A, int B, int C)\\n    {\\n        long long l=1,h=2*1e9;\\n        long long a=A,b=B,c=C;\\n        long long pro=a*b;\\n        ab=pro/__gcd(a,b);\\n        pro=a*c;\\n        ac=pro/__gcd(a,c);\\n        pro=b*c;\\n        bc=pro/__gcd(b,c);\\n        pro=ab*c;\\n        abc=pro/__gcd(ab,c);\\n \\n        while(l<=h)\\n        {\\n            long long m=l+(h-l)/2;\\n            \\n            long long uglyCount=solve(m,a,b,c);\\n            \\n            bool checkDivisibility =(m%a==0) || (m%b==0) || (m%c==0);\\n            \\n            if(uglyCount==n and checkDivisibility)\\n                return m;\\n            if(uglyCount>=n) // answer will be on right side \\n                h=m-1;\\n            else\\n                l=m+1;\\n        }\\n        \\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3552320,
                "title": "binary-search-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        #Condition: Are there at least n ugly numbers smaller than or equal to value?\\n        def countUglyNumbers(value):\\n            count = (value//a) + (value//b) + (value//c) + (value//abc)\\n            count -= ((value//ab) + (value//bc) + (value//ac))\\n            return count >= n\\n\\n        ab = math.lcm(a,b) #LCM of a and b\\n        bc = math.lcm(b,c) #LCM of b and c\\n        ac = math.lcm(a,c) #LCM of a and c\\n        abc = math.lcm(ab,c) #LCM of a, b, and c\\n        \\n        left, right = 1, (2 * 10**9)\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if countUglyNumbers(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        #Condition: Are there at least n ugly numbers smaller than or equal to value?\\n        def countUglyNumbers(value):\\n            count = (value//a) + (value//b) + (value//c) + (value//abc)\\n            count -= ((value//ab) + (value//bc) + (value//ac))\\n            return count >= n\\n\\n        ab = math.lcm(a,b) #LCM of a and b\\n        bc = math.lcm(b,c) #LCM of b and c\\n        ac = math.lcm(a,c) #LCM of a and c\\n        abc = math.lcm(ab,c) #LCM of a, b, and c\\n        \\n        left, right = 1, (2 * 10**9)\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if countUglyNumbers(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531879,
                "title": "gcd-and-lcm-search-commented-and-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor this problem, we are looking for the nth ugly numbers of three factors. We can do this by considering the combination of greatest common denominators and least common multiples. We will then search within this range and find the location of the nth ugly number by considering the value of the sum of nth ugly numbers of each factor at a value and then discount this by the sum of the least common multiples of the factors and increment by any joint least common multiple. \\n\\nIn this way we \\n- get how many nth ugly numbers of each factor at a given value \\n- reduce this by any matching ugly numbers of each factor by their least common multiples \\n- increase this by any triple matching ugly numbers of all factors least common multiple (since we already took these out in the prior step) \\n\\nFrom this it can be seen that we can binarily search for the correct lower bound of our valuation appropriately \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSome edge cases can be considered to speed up our search \\nFirst if we have n = 1, we can simply return the min of our factors \\n\\nSecondly, we can consider ways to reduce our number of factors via modulo comparisons. This can get us down to 2 or even 1 factor! If we can, we can of course speed up our process as well. \\n\\nFinally, we can get the least of our factors to determine if it is 1. If it is, we can simply return n. \\n\\nIn all other cases, we will proceed to solve. \\nUsing our above consideration, our count ugly numbers function takes a mid bound value to consider in binary searching. With it \\n- determine the number of single factor ugly numbers by factor and sum them up \\n- determine the number of two factor least common multiple ugly numbers and sum them up. For this, we leave off the last entry for either the case of only two factors, in which the final number is zero, or the case where we have three factors, in which case it is the least common multiple of all three factors\\n- Determine the number of three factor least common multiple ugly numbers either accordingly if we have three factors or set to zero otherwise \\n- return the value of the single factor ugly numbers minus the two factor least common multiple ugly numbers so we do not overcount plus the three factor least common multiple ugly numbers so we do not remove too many \\n\\nif our length of factors is two, \\n- set up a, b as factors \\n- set self.factors to [a, b] \\n- set self.lcms to [a * b // gcd (a, b), 0]\\n\\nif our length of factors is three, \\n- set up self.factors as list cast of factors \\n- set up self.lcms as above for a,b with (a,b), (a, c), and (b,c), then instead of 0 use a, b, c and gcd of a, b, c\\n\\nlower bound must be at least n - least factor * least factor // 2 or least factor * 2, whichever is greater. \\n\\nupper bound must be min of least factor by n or 2 * 10**9 \\n\\nWhile conducting binary search \\n- if count ugly numbers at mid bound is greater than or equal to n \\n    - move upper bound down to mid bound minus 1 \\n- otherwise \\n    - move lower bound up to mid bound + 1 \\n\\nwhen done return lower bound    \\n\\n# Complexity\\n- Time complexity : O (log (N))\\n    - We conduct binary search over N numbers, in log N time \\n        - in which we conduct O(1) operations with stored values  \\n\\n- Space complexity : O (1)\\n    - We are non-recursive and use no large data structures. O(1) \\n\\n\\n# Code\\n```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int :\\n        # edge case for n == 1 \\n        if n == 1 : \\n            return min(a, b, c)\\n\\n        # determine modular relationships \\n        # if a mod b is 0 or a mod c is zero a is b -> a mod b == 0 -> implies b is subfactor of a, and so will reach sooner \\n        #                                              a mod c == 0 -> implies c is subfactor of a, and so will reach sooner  \\n        if a % b == 0 or a % c == 0:\\n            a = b\\n        # similar for other relationships \\n        if b % a == 0 or b % c == 0:\\n            b = a\\n        # note that after testing first, if a % b was equal to 0, b % a will be 0 as well. \\n        # However, if a % c was 0, and then b % c was zero, they are all now the same     \\n        if c % a == 0 or c % b == 0:\\n            c = b\\n\\n        # if a == b == c -> return n * a \\n        if a == b == c:\\n            return n * a\\n\\n        # reduce factors down to set cast of their list \\n        factors = set([a, b, c])\\n        # get least factor \\n        least_factor = min(factors)\\n\\n        # if least is 1, return n \\n        if least_factor == 1 : \\n            return n \\n\\n        # to count ugly numbers before some bound with 3 factors \\n        # find the number of single factor ugly numbers up to mid bound for each factor \\n        # find the number of two factor least common multiple ugly numbers for each factor pair -> we overcounted by these\\n        # find the number of three factor least common multiple ugly numbers for all factor pairs -> we took too many of these away \\n        # we thus want the number of single factor ugly numbers less the two factor lcm ugly numbers plus the three factor lcm ugly numbers \\n        def count_ugly_numbers(mid_bound) :\\n            # get number of single factor ugly numbers \\n            number_of_factor_ugly_numbers = 0\\n            for factor in self.factors : \\n                number_of_factor_ugly_numbers += mid_bound//factor\\n\\n            # get number of two factor ugly numbers \\n            number_of_two_factor_least_common_multiple_ugly_numbers = 0\\n            for lcm in self.lcms[:-1] : \\n                number_of_two_factor_least_common_multiple_ugly_numbers += mid_bound//lcm\\n            \\n            # get number of triple factor ugly numbers if possible, else get 0  \\n            number_of_three_factor_least_common_multiple_ugly_numbers  = mid_bound // self.lcms[-1] if self.lcms[-1] != 0 else 0 \\n            \\n            return number_of_factor_ugly_numbers - number_of_two_factor_least_common_multiple_ugly_numbers - number_of_three_factor_least_common_multiple_ugly_numbers  \\n\\n        # if length of set is 2 \\n        if len(factors) == 2 :\\n            # set a and b appropriately \\n            a, b = factors\\n            # set up factors and least common multiples \\n            self.factors = [a, b]\\n            self.lcms = [(a*b)//(gcd(a, b)), 0]\\n        else : \\n            # otherwise, set up to use 3 factors \\n            self.factors = list(factors)\\n            self.lcms = [(a*b)//(gcd(a,b)), (a*c)//(gcd(a, c)), (b*c)//(gcd(b,c)), (a*b*c)//(gcd(a, b, c))]\\n\\n\\n        # set lower bound as n - least factor * (least factor // 2)\\n        # we know it\\'s not 1 -> this means the least it can be is n - least factor * least factor // 2 -> \\n        # it is at least n - least factor as smallest upper value. Then it is at least least factor // 2 away from this value \\n        # this is because we need to have at least that much as this size. In the case this is 0 or less, we can also use least factor * 2 since n is at least not 1. \\n        # set upper bound as least factor * n or 2 * 10**9, whichever is smaller -> gauranteed to be in 2 * 10 ** 9 \\n        # the bounds are searching for the nth ugly number \\n        lower_bound = max((n-least_factor) * (least_factor//2), least_factor*2) \\n        upper_bound = min(least_factor * n, 2 * 10 ** 9)\\n\\n        # while lower less than equal to upper bound \\n        while lower_bound <= upper_bound :\\n            # find mid bound as mid point of upper and lower bound \\n            mid_bound = (lower_bound + upper_bound) // 2\\n            # if number of ugly numbers at mid bound is gte n -> upper bound needs to reduce \\n            if count_ugly_numbers(mid_bound) >= n :\\n                upper_bound = mid_bound - 1\\n            else:\\n                # otherwise, lower bound needs to increase \\n                lower_bound = mid_bound + 1\\n\\n        # return lower bound \\n        return lower_bound\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int :\\n        # edge case for n == 1 \\n        if n == 1 : \\n            return min(a, b, c)\\n\\n        # determine modular relationships \\n        # if a mod b is 0 or a mod c is zero a is b -> a mod b == 0 -> implies b is subfactor of a, and so will reach sooner \\n        #                                              a mod c == 0 -> implies c is subfactor of a, and so will reach sooner  \\n        if a % b == 0 or a % c == 0:\\n            a = b\\n        # similar for other relationships \\n        if b % a == 0 or b % c == 0:\\n            b = a\\n        # note that after testing first, if a % b was equal to 0, b % a will be 0 as well. \\n        # However, if a % c was 0, and then b % c was zero, they are all now the same     \\n        if c % a == 0 or c % b == 0:\\n            c = b\\n\\n        # if a == b == c -> return n * a \\n        if a == b == c:\\n            return n * a\\n\\n        # reduce factors down to set cast of their list \\n        factors = set([a, b, c])\\n        # get least factor \\n        least_factor = min(factors)\\n\\n        # if least is 1, return n \\n        if least_factor == 1 : \\n            return n \\n\\n        # to count ugly numbers before some bound with 3 factors \\n        # find the number of single factor ugly numbers up to mid bound for each factor \\n        # find the number of two factor least common multiple ugly numbers for each factor pair -> we overcounted by these\\n        # find the number of three factor least common multiple ugly numbers for all factor pairs -> we took too many of these away \\n        # we thus want the number of single factor ugly numbers less the two factor lcm ugly numbers plus the three factor lcm ugly numbers \\n        def count_ugly_numbers(mid_bound) :\\n            # get number of single factor ugly numbers \\n            number_of_factor_ugly_numbers = 0\\n            for factor in self.factors : \\n                number_of_factor_ugly_numbers += mid_bound//factor\\n\\n            # get number of two factor ugly numbers \\n            number_of_two_factor_least_common_multiple_ugly_numbers = 0\\n            for lcm in self.lcms[:-1] : \\n                number_of_two_factor_least_common_multiple_ugly_numbers += mid_bound//lcm\\n            \\n            # get number of triple factor ugly numbers if possible, else get 0  \\n            number_of_three_factor_least_common_multiple_ugly_numbers  = mid_bound // self.lcms[-1] if self.lcms[-1] != 0 else 0 \\n            \\n            return number_of_factor_ugly_numbers - number_of_two_factor_least_common_multiple_ugly_numbers - number_of_three_factor_least_common_multiple_ugly_numbers  \\n\\n        # if length of set is 2 \\n        if len(factors) == 2 :\\n            # set a and b appropriately \\n            a, b = factors\\n            # set up factors and least common multiples \\n            self.factors = [a, b]\\n            self.lcms = [(a*b)//(gcd(a, b)), 0]\\n        else : \\n            # otherwise, set up to use 3 factors \\n            self.factors = list(factors)\\n            self.lcms = [(a*b)//(gcd(a,b)), (a*c)//(gcd(a, c)), (b*c)//(gcd(b,c)), (a*b*c)//(gcd(a, b, c))]\\n\\n\\n        # set lower bound as n - least factor * (least factor // 2)\\n        # we know it\\'s not 1 -> this means the least it can be is n - least factor * least factor // 2 -> \\n        # it is at least n - least factor as smallest upper value. Then it is at least least factor // 2 away from this value \\n        # this is because we need to have at least that much as this size. In the case this is 0 or less, we can also use least factor * 2 since n is at least not 1. \\n        # set upper bound as least factor * n or 2 * 10**9, whichever is smaller -> gauranteed to be in 2 * 10 ** 9 \\n        # the bounds are searching for the nth ugly number \\n        lower_bound = max((n-least_factor) * (least_factor//2), least_factor*2) \\n        upper_bound = min(least_factor * n, 2 * 10 ** 9)\\n\\n        # while lower less than equal to upper bound \\n        while lower_bound <= upper_bound :\\n            # find mid bound as mid point of upper and lower bound \\n            mid_bound = (lower_bound + upper_bound) // 2\\n            # if number of ugly numbers at mid bound is gte n -> upper bound needs to reduce \\n            if count_ugly_numbers(mid_bound) >= n :\\n                upper_bound = mid_bound - 1\\n            else:\\n                # otherwise, lower bound needs to increase \\n                lower_bound = mid_bound + 1\\n\\n        # return lower bound \\n        return lower_bound\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3486838,
                "title": "javascript-1201-ugly-number-iii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n1\\n```\\nconst gcd = (a, b) => (!b ? a : gcd(b, a % b));\\nconst lcm = (a, b) => (a * b) / gcd(a, b);\\nconst div = (n, a) => ~~(n / a); // count of nums in [0,n] divisible by a\\nconst divisibleByABorC = (n, a, b, c) => {\\n    let s = div(n, a) + div(n, b) + div(n, c);\\n    let s2 = div(n, lcm(a, b)) + div(n, lcm(b, c)) + div(n, lcm(c, a));\\n    let s3 = div(n, lcm(lcm(a, b), c));\\n    return s - s2 + s3; // principle of inclusion and exclusion\\n};\\nvar nthUglyNumber = function (target, a, b, c) {\\n    let L = 1;\\n    let R = 2 * 10 ** 9; // result will be in range [1, 2 * 10**9]\\n    while (L < R) {\\n        let mid = ~~(L / 2 + R / 2);\\n        divisibleByABorC(mid, a, b, c) < target ? (L = mid + 1) : (R = mid);\\n    }\\n    return L;\\n};\\n```\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst gcd = (a, b) => (!b ? a : gcd(b, a % b));\\nconst lcm = (a, b) => (a * b) / gcd(a, b);\\nconst div = (n, a) => ~~(n / a); // count of nums in [0,n] divisible by a\\nconst divisibleByABorC = (n, a, b, c) => {\\n    let s = div(n, a) + div(n, b) + div(n, c);\\n    let s2 = div(n, lcm(a, b)) + div(n, lcm(b, c)) + div(n, lcm(c, a));\\n    let s3 = div(n, lcm(lcm(a, b), c));\\n    return s - s2 + s3; // principle of inclusion and exclusion\\n};\\nvar nthUglyNumber = function (target, a, b, c) {\\n    let L = 1;\\n    let R = 2 * 10 ** 9; // result will be in range [1, 2 * 10**9]\\n    while (L < R) {\\n        let mid = ~~(L / 2 + R / 2);\\n        divisibleByABorC(mid, a, b, c) < target ? (L = mid + 1) : (R = mid);\\n    }\\n    return L;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3486390,
                "title": "swift-binary-search-using-lcm-readable-and-commented",
                "content": "# Complexity\\n- Time complexity: $$O(log(n*w))$$, where $$w$$ is $$min(a, b, c)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    func nthUglyNumber(_ n: Int, _ a: Int, _ b: Int, _ c: Int) -> Int\\n    {\\n        // since a might be multiple of b or c, or the other way round,\\n        // we need the help of least common multiple to avoid counting duplicate numbers\\n        let lcmAB = lcm(a, b), lcmAC = lcm(a, c), lcmBC = lcm(b, c), lcmABC = lcm(lcmAB, c)\\n\\n        // binary search for the smallest integer satisfying the condition\\n        // \"count of all ugly numbers less than or equal to it is at least n\"\\n        var low = min(a, b, c) * n / 3\\n        var high = min(a, b, c) * n\\n        var mid: Int\\n        while low < high\\n        {\\n            mid = (low + high) / 2\\n            if uglyCount(for: mid) >= n {\\n                high = mid\\n            }\\n            else {\\n                low = mid + 1\\n            }\\n        }\\n\\n        // count of all ugly numbers less than or equal to x\\n        func uglyCount(for x: Int) -> Int\\n        {\\n            (x/a + x/b + x/c) -              // all multiples of a, b, c up to x\\n            (x/lcmAB + x/lcmAC + x/lcmBC) +  // subtract those that have been counted twice\\n             x/lcmABC                        // add back the twice subtracted\\n        }\\n\\n        return low\\n    }\\n}\\n\\n// least common multiple\\nfunc lcm(_ x: Int, _ y: Int) -> Int {\\n    return x * y / gcd(x, y)\\n}\\n\\n// greatest common divisor, Euclidean algorithm\\nfunc gcd(_ x: Int, _ y: Int) -> Int\\n{\\n    let rem = x % y\\n    if rem == 0 { return y }\\n    else { return gcd(y, rem) }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Math",
                    "Binary Search",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\n    func nthUglyNumber(_ n: Int, _ a: Int, _ b: Int, _ c: Int) -> Int\\n    {\\n        // since a might be multiple of b or c, or the other way round,\\n        // we need the help of least common multiple to avoid counting duplicate numbers\\n        let lcmAB = lcm(a, b), lcmAC = lcm(a, c), lcmBC = lcm(b, c), lcmABC = lcm(lcmAB, c)\\n\\n        // binary search for the smallest integer satisfying the condition\\n        // \"count of all ugly numbers less than or equal to it is at least n\"\\n        var low = min(a, b, c) * n / 3\\n        var high = min(a, b, c) * n\\n        var mid: Int\\n        while low < high\\n        {\\n            mid = (low + high) / 2\\n            if uglyCount(for: mid) >= n {\\n                high = mid\\n            }\\n            else {\\n                low = mid + 1\\n            }\\n        }\\n\\n        // count of all ugly numbers less than or equal to x\\n        func uglyCount(for x: Int) -> Int\\n        {\\n            (x/a + x/b + x/c) -              // all multiples of a, b, c up to x\\n            (x/lcmAB + x/lcmAC + x/lcmBC) +  // subtract those that have been counted twice\\n             x/lcmABC                        // add back the twice subtracted\\n        }\\n\\n        return low\\n    }\\n}\\n\\n// least common multiple\\nfunc lcm(_ x: Int, _ y: Int) -> Int {\\n    return x * y / gcd(x, y)\\n}\\n\\n// greatest common divisor, Euclidean algorithm\\nfunc gcd(_ x: Int, _ y: Int) -> Int\\n{\\n    let rem = x % y\\n    if rem == 0 { return y }\\n    else { return gcd(y, rem) }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453814,
                "title": "basic-math-and-binary-search-solution-beats-100-cpp",
                "content": "# Intuition and Approach\\n* the ans lies in between [min(a,b,c),n*min(a,b,c)].\\n* find gcd of each pair of a,b,c and whole of three.\\n* now l=min(a,b,c) and r=n*min(a,b,c). apply binary seach on it.\\n* use the formula aUbUc=a+b+c-ab-bc-ca+abc.\\n* take care of conditions when gcd of pairs is greater then one(**remove the repeating part).\\n* at the end return the ans.\\n\\n# Complexity\\n- Time complexity: log(N)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, int a1, int b1, int c1) {\\n        long long a=a1;\\n        long long b=b1;\\n        long long c=c1;\\n        long long l=min(a,min(b,c));\\n        long long r=l*n;\\n        long long ab=__gcd(a,b);\\n        long long bc=__gcd(b,c);\\n        long long ca=__gcd(c,a);\\n        long long abc=__gcd(ab,bc);\\n        while(l<r){\\n            long long mid=(l+r)/2;\\n            long long cnt=0;\\n            cnt+=mid/a;\\n            cnt+=mid/b;\\n            cnt+=mid/c;\\n            cnt-=mid/((a*b)/ab);\\n            cnt-=mid/((b*c)/bc);\\n            cnt-=mid/((c*a)/ca);\\n            cnt+=mid/(((((c*a*b)/ab)/ca)/bc)*abc);\\n            if(cnt<n){\\n                l=mid+1;\\n            }\\n            else {\\n                r=mid;\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, int a1, int b1, int c1) {\\n        long long a=a1;\\n        long long b=b1;\\n        long long c=c1;\\n        long long l=min(a,min(b,c));\\n        long long r=l*n;\\n        long long ab=__gcd(a,b);\\n        long long bc=__gcd(b,c);\\n        long long ca=__gcd(c,a);\\n        long long abc=__gcd(ab,bc);\\n        while(l<r){\\n            long long mid=(l+r)/2;\\n            long long cnt=0;\\n            cnt+=mid/a;\\n            cnt+=mid/b;\\n            cnt+=mid/c;\\n            cnt-=mid/((a*b)/ab);\\n            cnt-=mid/((b*c)/bc);\\n            cnt-=mid/((c*a)/ca);\\n            cnt+=mid/(((((c*a*b)/ab)/ca)/bc)*abc);\\n            if(cnt<n){\\n                l=mid+1;\\n            }\\n            else {\\n                r=mid;\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452627,
                "title": "easy-to-understand-faster-simple-python-solution",
                "content": "\\n\\n# Code\\n```\\nfrom math import gcd\\n\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        def num_of_ugly_below(val):\\n            return (val // a) + (val // b) + (val // c) - (val // lcm_ab) - (val // lcm_bc) - (val // lcm_ca) + (val // lcm_abc)\\n        \\n        def get_lcm(*vals):\\n            res = vals[0]\\n            for i in range(1, len(vals)):\\n                res = res * vals[i] // gcd(res, vals[i])\\n            return res\\n        \\n        lcm_ab, lcm_bc, lcm_ca, lcm_abc = get_lcm(a, b), get_lcm(b, c), get_lcm(c, a), get_lcm(a, b, c)\\n        \\n        #binary search\\n        l, r = 1, min(a, b, c) * n\\n        while l < r:\\n            mid = (l + r) // 2\\n            if num_of_ugly_below(mid) < n:\\n                l = mid + 1\\n            else:\\n                r = mid\\n        return l\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom math import gcd\\n\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        def num_of_ugly_below(val):\\n            return (val // a) + (val // b) + (val // c) - (val // lcm_ab) - (val // lcm_bc) - (val // lcm_ca) + (val // lcm_abc)\\n        \\n        def get_lcm(*vals):\\n            res = vals[0]\\n            for i in range(1, len(vals)):\\n                res = res * vals[i] // gcd(res, vals[i])\\n            return res\\n        \\n        lcm_ab, lcm_bc, lcm_ca, lcm_abc = get_lcm(a, b), get_lcm(b, c), get_lcm(c, a), get_lcm(a, b, c)\\n        \\n        #binary search\\n        l, r = 1, min(a, b, c) * n\\n        while l < r:\\n            mid = (l + r) // 2\\n            if num_of_ugly_below(mid) < n:\\n                l = mid + 1\\n            else:\\n                r = mid\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442999,
                "title": "easy-to-understand-javascript-solution",
                "content": "```\\nvar nthUglyNumber = function(n, a, b, c) {\\n    const gcd = (a, b) => a === 0 ? b : gcd(b % a, a);\\n    const lcm = (a, b) => a * b / gcd(a, b);\\n    const lcmAB = lcm(a, b);\\n    const lcmBC = lcm(b, c);\\n    const lcmAC = lcm(a, c);\\n    const lcmABC = lcm(lcmAB, c);\\n    let low = 1;\\n    let high = 2 * 10 ** 9;\\n\\n    while (low < high) {\\n        const mid = Math.floor((low + high) / 2);\\n        const countA = Math.floor(mid / a);\\n        const countB = Math.floor(mid / b);\\n        const countC = Math.floor(mid / c);\\n        const countAB = Math.floor(mid / lcmAB);\\n        const countBC = Math.floor(mid / lcmBC);\\n        const countAC = Math.floor(mid / lcmAC);\\n        const countABC = Math.floor(mid / lcmABC);\\n        const count = countA + countB + countC - countAB - countBC - countAC + countABC;\\n\\n        count < n ? low = mid + 1 : high = mid;\\n    }\\n    return low;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar nthUglyNumber = function(n, a, b, c) {\\n    const gcd = (a, b) => a === 0 ? b : gcd(b % a, a);\\n    const lcm = (a, b) => a * b / gcd(a, b);\\n    const lcmAB = lcm(a, b);\\n    const lcmBC = lcm(b, c);\\n    const lcmAC = lcm(a, c);\\n    const lcmABC = lcm(lcmAB, c);\\n    let low = 1;\\n    let high = 2 * 10 ** 9;\\n\\n    while (low < high) {\\n        const mid = Math.floor((low + high) / 2);\\n        const countA = Math.floor(mid / a);\\n        const countB = Math.floor(mid / b);\\n        const countC = Math.floor(mid / c);\\n        const countAB = Math.floor(mid / lcmAB);\\n        const countBC = Math.floor(mid / lcmBC);\\n        const countAC = Math.floor(mid / lcmAC);\\n        const countABC = Math.floor(mid / lcmABC);\\n        const count = countA + countB + countC - countAB - countBC - countAC + countABC;\\n\\n        count < n ? low = mid + 1 : high = mid;\\n    }\\n    return low;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3404295,
                "title": "beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nlong int gcd(int a , int b)\\n{\\n    if(a==0)\\n    return b;\\n    else return gcd(b%a,a);\\n}\\n    int nthUglyNumber(int n, int a, int b, int c) \\n    {\\n       long long  int l =  1 , h = min({a,b,c})*n , mid , ans;\\n       long long int  lcmab =  (long long )a*(long long)b/gcd(a,b);\\n       long long int  lcmbc =  (long long )b*(long long)c/gcd(b,c);\\n       long long int  lcmac =  (long long )a*(long long)c/gcd(a,c);\\n       long long int  lcmabc =   lcmab*c/gcd(lcmab,c);\\n\\n       \\n\\n        while(l<=h)\\n        {\\n            mid = (l+h)/2;\\n            int count =   mid/a + mid/b + mid/c - mid/lcmab - mid/lcmbc - mid/lcmac + mid/lcmabc; \\n\\n\\n            if(count>=n)\\n            {\\n                ans = mid; \\n                h = mid -1; \\n            }\\n            else  l = mid +1; \\n\\n\\n        }\\n        return  ans; \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nlong int gcd(int a , int b)\\n{\\n    if(a==0)\\n    return b;\\n    else return gcd(b%a,a);\\n}\\n    int nthUglyNumber(int n, int a, int b, int c) \\n    {\\n       long long  int l =  1 , h = min({a,b,c})*n , mid , ans;\\n       long long int  lcmab =  (long long )a*(long long)b/gcd(a,b);\\n       long long int  lcmbc =  (long long )b*(long long)c/gcd(b,c);\\n       long long int  lcmac =  (long long )a*(long long)c/gcd(a,c);\\n       long long int  lcmabc =   lcmab*c/gcd(lcmab,c);\\n\\n       \\n\\n        while(l<=h)\\n        {\\n            mid = (l+h)/2;\\n            int count =   mid/a + mid/b + mid/c - mid/lcmab - mid/lcmbc - mid/lcmac + mid/lcmabc; \\n\\n\\n            if(count>=n)\\n            {\\n                ans = mid; \\n                h = mid -1; \\n            }\\n            else  l = mid +1; \\n\\n\\n        }\\n        return  ans; \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3394666,
                "title": "c-easy-to-understand-binary-search-math",
                "content": "# Code\\n```\\ntypedef long long ll;\\n#define MAX_ANS 2e9\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int left =0,right = MAX_ANS;\\n        int result =0;\\n        while(left<=right){\\n            int mid = left+(right-left)/2;\\n            if(count(mid,a,b,c)>=n){\\n                result = mid;\\n                right = mid-1;\\n            }\\n            else{\\n                left = mid+1;\\n            }\\n        }\\n        return result;\\n    }\\n    int count(ll num,ll a,ll b,ll c){\\n        return (int)(num/a+num/b+num/c-num/lcm(a,b)-num/lcm(b,c)-num/lcm(a,c)+num/(lcm(a,lcm(b,c))));\\n    }\\n\\n    ll gcd(ll a,ll b){\\n        if(a==0)\\n          return b;\\n        return gcd(b%a,a);\\n    }\\n    ll lcm(ll a,ll b){\\n        return a*b/gcd(a,b);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ntypedef long long ll;\\n#define MAX_ANS 2e9\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int left =0,right = MAX_ANS;\\n        int result =0;\\n        while(left<=right){\\n            int mid = left+(right-left)/2;\\n            if(count(mid,a,b,c)>=n){\\n                result = mid;\\n                right = mid-1;\\n            }\\n            else{\\n                left = mid+1;\\n            }\\n        }\\n        return result;\\n    }\\n    int count(ll num,ll a,ll b,ll c){\\n        return (int)(num/a+num/b+num/c-num/lcm(a,b)-num/lcm(b,c)-num/lcm(a,c)+num/(lcm(a,lcm(b,c))));\\n    }\\n\\n    ll gcd(ll a,ll b){\\n        if(a==0)\\n          return b;\\n        return gcd(b%a,a);\\n    }\\n    ll lcm(ll a,ll b){\\n        return a*b/gcd(a,b);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362768,
                "title": "easiest-java-solution",
                "content": "\\n\\n# Code\\n```\\n//just tried to explain as much as I can. Upvote if it helped. thanks\\nclass Solution {\\n  \\n    long lcmOfAC;\\n    long lcmOfAB;\\n    long lcmOfBC;\\n    long lcmOfABC;\\n  \\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        \\n      lcmOfAC  = lcm(a,c);\\n      lcmOfAB  = lcm(a,b);\\n      lcmOfBC  = lcm(b,c);\\n      lcmOfABC = lcm(a,lcmOfBC);\\n      \\n      int left = 1;\\n      int right = Integer.MAX_VALUE;\\n      \\n      \\n      //how BS works here: If our count of ugly numbers before the value of \\'mid\\'\\n      //is greater or equal we decrease right. \\n      //And when we have exactly \\'n-1\\' on the left side, our answer is \\'left\\', \\n      //meaning that left is the number which is at ((n-1)+1) th position.\\n      \\n      \\n      /// MOST IMPORTANT THING TO UNDERSTAND HERE IS: HOW DOES HOW MANY UGLY NUMBERS ARE THERE BEFORE \\'MID\\' GIVES THE NTH UGLY NUMBER??? WE ARE JUST COUNTING NUMBERS RIGHT?? HOW DOES IT EVEN WORK??\\n      /*\\n        LET ME EXPLAIN: FOR EXAMPLE TEST-CASE 1: \\n        \\n        N = 3, A = 2, B = 3, C = 5. CLEAR HERE.\\n        \\n        NOW TAKE A SERIES OF N NATURAL NUMBERS. LIKE:\\n        \\n        1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21...\\n        \\n        NOW FOR 2 IT\\'S: 2 4 6 8 10 12 14 16...\\n                 FOR 3: 3 6 9 12 15 18\\n                 FOR 5: 5 10 15 20 25.....\\n                 \\n        //WITH THIS LINE: long total = mid/a + mid/b + mid/c - mid/lcmOfAB - mid/lcmOfBC - mid/lcmOfAC + mid/lcmOfABC;        \\n        //WE ARE ADDING EVERY UNIQUE MULTIPLE OF ALL OF THE THREE ONLY ONE TIME.\\n        \\n        //SO OUR FINAL N-NATURAL NUMBER SERIES BECOMES:  //EVERY DUPLICATE IS REMOVED.\\n          1, 2, 3, 4, 5, 6, 8, 9, 10... (SAME AS PROVIDED IN TEST CASE) //EVERY NUMBER IS UNIQUE AND INCREASING. //ONE IS INCLUDED BECAUSE LEFT = 1.\\n          \\n        //KEEP-IN-MIND, BY COUNTING WE ARE SAYING - HOW MANY UGLY NUMBERS APPEAR BEFORE THIS \\'MID\\'\\n        // WE ARE SAYING IF THERE ARE \"n-1\" UGLY NUMBERS BEFORE THAN \"n\" IS OUR ANSWER. HERE \"LEFT\" IS THAT \"N\"\\n\\n        // SO IF OUR MID IS FINALLY AT LET SAY \\'5\\', WE DECREASE OUR RIGHT TO \\'MID\\' (RIGHT = MID),\\n        // BECAUSE TOTAL NUMBERS BEFORE 5 ARE 3 (1,2,3,4).\\n        \\n        //THIS PROCESS KEEPS GOING UNTIL MID IS AT 3, AND COUNT < N WHICH MEANS LEFT = MID+1 (3+1) = 4;\\n        \\n        //TRY TO THINK IN YOUR WAY A LITTLE MORE IF YOU STILL DON\\'T GET IT.\\n          \\n      */\\n      \\n      \\n      \\n      while(left<right){\\n        \\n        int mid = left+(right-left)/2;\\n\\n        if(count(mid, a, b, c, n)){\\n          right = mid;\\n        }\\n        \\n        else\\n          left = mid+1;        \\n      }\\n      \\n      return left;      \\n    }\\n  \\n   \\n    \\n    boolean count(long mid, long a, long b, long c, long n){\\n      \\n      \\n\\t\\t/*\\n\\t\\t*   mid/a = total number of multiples \\'a\\' till chosen \\'mid\\'. //same for \\'b\\' and \\'c\\'.\\n\\t\\t*  \\n\\t\\t*   mid/lcm(a,b) = total number of duplicate multiples that appear for series of \\'a\\' and \\'b\\'  // same for (b,c) & (c,a)      \\n\\t\\t*   \\n\\t\\t*   now because we subtract all the common mulitples  that appear for all three \\'a\\' & \\'b\\' & \\'c\\'\\n\\n\\t\\t*   we\\'ll have to again add those who appear in all three series again (check below comment)\\n\\t\\t*/      \\n\\t\\t /* example: \\n\\n\\t\\t\\t\\tfor 2:- 2 4 6 8 10 12 14\\n\\t\\t\\t\\tfor 3:- 3 9 12 15 18 21\\n\\t\\t\\t\\tfor 4:- 4 8 12\\n\\n\\t\\t\\t\\t//now notice that \\'12\\' is common in all of them, it should be counted only \\'once\\', not \\'thrice\\'.\\n\\t\\t\\t\\t// same goes for \\'4\\', it appeared 2 times, we want to count only \\'one\\' time.\\n\\n\\t\\t\\t\\t// this is why we subtracted  all common duplicates first, then lastly add the lcm(a,lcm(b,c)) //simply say -  lcm(a,b,c)\\n\\t\\t\\t\\t// we do this last \\'add\\' step because we have already subtracted all duplicates that are common.\\n\\t\\t\\t\\t// so to add those who are common in \"all three series\" (like 12 here), we do this last  \\'+ lcm(a,b,c)\\' step.\\n\\t\\t*/\\n\\t\\t\\n     \\n      long total = mid/a + mid/b + mid/c - mid/lcmOfAB - mid/lcmOfBC - mid/lcmOfAC + mid/lcmOfABC;\\n      \\n      return total >= n;\\n      \\n    }\\n  \\n  \\n    static long gcd(long a,long b){\\n      while(b>0){\\n        a%=b;\\n        //swap\\n        long temp = a;\\n        a = b;\\n        b = temp;\\n      }\\n      return a;\\n    }\\n\\n    static long lcm(long a, long b){\\n      \\n      return a/gcd(a,b)*b;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//just tried to explain as much as I can. Upvote if it helped. thanks\\nclass Solution {\\n  \\n    long lcmOfAC;\\n    long lcmOfAB;\\n    long lcmOfBC;\\n    long lcmOfABC;\\n  \\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        \\n      lcmOfAC  = lcm(a,c);\\n      lcmOfAB  = lcm(a,b);\\n      lcmOfBC  = lcm(b,c);\\n      lcmOfABC = lcm(a,lcmOfBC);\\n      \\n      int left = 1;\\n      int right = Integer.MAX_VALUE;\\n      \\n      \\n      //how BS works here: If our count of ugly numbers before the value of \\'mid\\'\\n      //is greater or equal we decrease right. \\n      //And when we have exactly \\'n-1\\' on the left side, our answer is \\'left\\', \\n      //meaning that left is the number which is at ((n-1)+1) th position.\\n      \\n      \\n      /// MOST IMPORTANT THING TO UNDERSTAND HERE IS: HOW DOES HOW MANY UGLY NUMBERS ARE THERE BEFORE \\'MID\\' GIVES THE NTH UGLY NUMBER??? WE ARE JUST COUNTING NUMBERS RIGHT?? HOW DOES IT EVEN WORK??\\n      /*\\n        LET ME EXPLAIN: FOR EXAMPLE TEST-CASE 1: \\n        \\n        N = 3, A = 2, B = 3, C = 5. CLEAR HERE.\\n        \\n        NOW TAKE A SERIES OF N NATURAL NUMBERS. LIKE:\\n        \\n        1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21...\\n        \\n        NOW FOR 2 IT\\'S: 2 4 6 8 10 12 14 16...\\n                 FOR 3: 3 6 9 12 15 18\\n                 FOR 5: 5 10 15 20 25.....\\n                 \\n        //WITH THIS LINE: long total = mid/a + mid/b + mid/c - mid/lcmOfAB - mid/lcmOfBC - mid/lcmOfAC + mid/lcmOfABC;        \\n        //WE ARE ADDING EVERY UNIQUE MULTIPLE OF ALL OF THE THREE ONLY ONE TIME.\\n        \\n        //SO OUR FINAL N-NATURAL NUMBER SERIES BECOMES:  //EVERY DUPLICATE IS REMOVED.\\n          1, 2, 3, 4, 5, 6, 8, 9, 10... (SAME AS PROVIDED IN TEST CASE) //EVERY NUMBER IS UNIQUE AND INCREASING. //ONE IS INCLUDED BECAUSE LEFT = 1.\\n          \\n        //KEEP-IN-MIND, BY COUNTING WE ARE SAYING - HOW MANY UGLY NUMBERS APPEAR BEFORE THIS \\'MID\\'\\n        // WE ARE SAYING IF THERE ARE \"n-1\" UGLY NUMBERS BEFORE THAN \"n\" IS OUR ANSWER. HERE \"LEFT\" IS THAT \"N\"\\n\\n        // SO IF OUR MID IS FINALLY AT LET SAY \\'5\\', WE DECREASE OUR RIGHT TO \\'MID\\' (RIGHT = MID),\\n        // BECAUSE TOTAL NUMBERS BEFORE 5 ARE 3 (1,2,3,4).\\n        \\n        //THIS PROCESS KEEPS GOING UNTIL MID IS AT 3, AND COUNT < N WHICH MEANS LEFT = MID+1 (3+1) = 4;\\n        \\n        //TRY TO THINK IN YOUR WAY A LITTLE MORE IF YOU STILL DON\\'T GET IT.\\n          \\n      */\\n      \\n      \\n      \\n      while(left<right){\\n        \\n        int mid = left+(right-left)/2;\\n\\n        if(count(mid, a, b, c, n)){\\n          right = mid;\\n        }\\n        \\n        else\\n          left = mid+1;        \\n      }\\n      \\n      return left;      \\n    }\\n  \\n   \\n    \\n    boolean count(long mid, long a, long b, long c, long n){\\n      \\n      \\n\\t\\t/*\\n\\t\\t*   mid/a = total number of multiples \\'a\\' till chosen \\'mid\\'. //same for \\'b\\' and \\'c\\'.\\n\\t\\t*  \\n\\t\\t*   mid/lcm(a,b) = total number of duplicate multiples that appear for series of \\'a\\' and \\'b\\'  // same for (b,c) & (c,a)      \\n\\t\\t*   \\n\\t\\t*   now because we subtract all the common mulitples  that appear for all three \\'a\\' & \\'b\\' & \\'c\\'\\n\\n\\t\\t*   we\\'ll have to again add those who appear in all three series again (check below comment)\\n\\t\\t*/      \\n\\t\\t /* example: \\n\\n\\t\\t\\t\\tfor 2:- 2 4 6 8 10 12 14\\n\\t\\t\\t\\tfor 3:- 3 9 12 15 18 21\\n\\t\\t\\t\\tfor 4:- 4 8 12\\n\\n\\t\\t\\t\\t//now notice that \\'12\\' is common in all of them, it should be counted only \\'once\\', not \\'thrice\\'.\\n\\t\\t\\t\\t// same goes for \\'4\\', it appeared 2 times, we want to count only \\'one\\' time.\\n\\n\\t\\t\\t\\t// this is why we subtracted  all common duplicates first, then lastly add the lcm(a,lcm(b,c)) //simply say -  lcm(a,b,c)\\n\\t\\t\\t\\t// we do this last \\'add\\' step because we have already subtracted all duplicates that are common.\\n\\t\\t\\t\\t// so to add those who are common in \"all three series\" (like 12 here), we do this last  \\'+ lcm(a,b,c)\\' step.\\n\\t\\t*/\\n\\t\\t\\n     \\n      long total = mid/a + mid/b + mid/c - mid/lcmOfAB - mid/lcmOfBC - mid/lcmOfAC + mid/lcmOfABC;\\n      \\n      return total >= n;\\n      \\n    }\\n  \\n  \\n    static long gcd(long a,long b){\\n      while(b>0){\\n        a%=b;\\n        //swap\\n        long temp = a;\\n        a = b;\\n        b = temp;\\n      }\\n      return a;\\n    }\\n\\n    static long lcm(long a, long b){\\n      \\n      return a/gcd(a,b)*b;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3307928,
                "title": "c",
                "content": "```\\nclass Solution {\\n    long long LCM(int a, int b){\\n        long long ret = 1 ;\\n        return ret * a * b/gcd(a, b) ;\\n    }\\n        \\n    long long helper(int val, int x, int y, int z){\\n        int a = val/x ;\\n        int b = val/y ;\\n        int c = val/z ;\\n        int ab = val/LCM(x,y) ;\\n        int bc = val/LCM(y,z) ;\\n        int ac = val/LCM(x,z) ;\\n        int abc = val/LCM(LCM(x,y), z) ;\\n        return (long long)a + b + c - ab - bc - ac + abc ;\\n    }\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int left = 1 , right = INT_MAX ;   \\n        while(left < right){\\n            int mid = left + (right - left)/2 ;\\n            long long k = helper(mid, a, b, c) ;\\n            if(k >= n)\\n                right = mid ;\\n            else\\n                left = mid + 1 ;\\n        }\\n        return left ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    long long LCM(int a, int b){\\n        long long ret = 1 ;\\n        return ret * a * b/gcd(a, b) ;\\n    }\\n        \\n    long long helper(int val, int x, int y, int z){\\n        int a = val/x ;\\n        int b = val/y ;\\n        int c = val/z ;\\n        int ab = val/LCM(x,y) ;\\n        int bc = val/LCM(y,z) ;\\n        int ac = val/LCM(x,z) ;\\n        int abc = val/LCM(LCM(x,y), z) ;\\n        return (long long)a + b + c - ab - bc - ac + abc ;\\n    }\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int left = 1 , right = INT_MAX ;   \\n        while(left < right){\\n            int mid = left + (right - left)/2 ;\\n            long long k = helper(mid, a, b, c) ;\\n            if(k >= n)\\n                right = mid ;\\n            else\\n                left = mid + 1 ;\\n        }\\n        return left ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3274035,
                "title": "python-binary-search-math-gcd-lcm-explained",
                "content": "The idea to solve this problem is to first binary search between the range and once we find the mid calculate how many numbers get hit at or before this number returning if the amount was larger than our target or less.\\n\\nThe way we can find this out is with the following idea:\\n\\n**a = 2, b = 3, c = 3, n = 4**\\n\\nif we get mid == 10\\n\\nwe can break the problem down as \\n**2,4,6,8,10 = 10 // a = 5\\n3,6,9 = 10 // b = 3\\n3,6,9 = 10 // c = 3\\n11 total**\\n\\nNow we have all the multiples before this number but we have a problem where numbers are overlapping if you look at the number 3 and 6 both of these numbers show up multiple times 3 showing up twice and 6 three times.\\n\\nThe way we can handle this is with LCM.\\nThere are 3 combinations to check (a,b), (a,c), (b,c)\\nthe lcm of a,b = 6, a,c = 6 and b,c = 3\\n\\nnow lets count how many times these numbers show up and remove them from our total\\n**mid // lcm(a,b) = 1\\nmid // lcm(a,c) = 1\\nmid// lcm(b,c) = 3**\\n\\nnow we have 11 - 5 = 6\\nbut this is still incorrect since we removed all 3 of the 6s since all 3 of our lcms hit 6 multiples so as a final step we should add back multiples where LCM(a,b,c)\\nto do this we take the LCM of 2 numbers say (a,b) than LCM the third # with it LCM(LCM(a,b),c) which will give us 6\\n\\nwe can calculate this the same way mid // LCM(LCM(a,b),c) = 1\\n**res = 6 + 1**\\n\\nnow we can return if our res is >= to our target and continue our BS.\\n\\n\\n```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        \\n        def lcm(a,b):\\n            \\n            return a * b // gcd(a,b)\\n        \\n        def isGood(mid):\\n            \\n            #calculate how many solves are before this number for each a, b and c\\n            tarA = mid // a\\n            tarB = mid // b\\n            tarC = mid // c\\n\\n            #remove intersection points\\n            ab = mid // abLCM\\n            ac = mid // acLCM\\n            bc = mid // bcLCM\\n            \\n            #remove points where they all intersect\\n            al = mid // allLCM\\n            \\n            #sum up all of our results\\n            s = tarA + tarB + tarC - ab - ac - bc + al\\n            \\n            #are we above and = or below our target\\n            return s >= n \\n            \\n        #check all lcms ahead of time\\n        abLCM = lcm(a,b)\\n        acLCM = lcm(a,c)\\n        bcLCM = lcm(b,c)\\n        allLCM = lcm(abLCM, c)\\n        \\n        #search range from \\n        l,r = 0, 2 * 10**9\\n        \\n        while l < r:\\n            \\n            mid = l + (r-l)//2\\n\\n            if isGood(mid):\\n                r = mid\\n            else:\\n                l = mid +1\\n                \\n        \\n        return l",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "The idea to solve this problem is to first binary search between the range and once we find the mid calculate how many numbers get hit at or before this number returning if the amount was larger than our target or less.\\n\\nThe way we can find this out is with the following idea:\\n\\n**a = 2, b = 3, c = 3, n = 4**\\n\\nif we get mid == 10\\n\\nwe can break the problem down as \\n**2,4,6,8,10 = 10 // a = 5\\n3,6,9 = 10 // b = 3\\n3,6,9 = 10 // c = 3\\n11 total**\\n\\nNow we have all the multiples before this number but we have a problem where numbers are overlapping if you look at the number 3 and 6 both of these numbers show up multiple times 3 showing up twice and 6 three times.\\n\\nThe way we can handle this is with LCM.\\nThere are 3 combinations to check (a,b), (a,c), (b,c)\\nthe lcm of a,b = 6, a,c = 6 and b,c = 3\\n\\nnow lets count how many times these numbers show up and remove them from our total\\n**mid // lcm(a,b) = 1\\nmid // lcm(a,c) = 1\\nmid// lcm(b,c) = 3**\\n\\nnow we have 11 - 5 = 6\\nbut this is still incorrect since we removed all 3 of the 6s since all 3 of our lcms hit 6 multiples so as a final step we should add back multiples where LCM(a,b,c)\\nto do this we take the LCM of 2 numbers say (a,b) than LCM the third # with it LCM(LCM(a,b),c) which will give us 6\\n\\nwe can calculate this the same way mid // LCM(LCM(a,b),c) = 1\\n**res = 6 + 1**\\n\\nnow we can return if our res is >= to our target and continue our BS.\\n\\n\\n```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        \\n        def lcm(a,b):\\n            \\n            return a * b // gcd(a,b)\\n        \\n        def isGood(mid):\\n            \\n            #calculate how many solves are before this number for each a, b and c\\n            tarA = mid // a\\n            tarB = mid // b\\n            tarC = mid // c\\n\\n            #remove intersection points\\n            ab = mid // abLCM\\n            ac = mid // acLCM\\n            bc = mid // bcLCM\\n            \\n            #remove points where they all intersect\\n            al = mid // allLCM\\n            \\n            #sum up all of our results\\n            s = tarA + tarB + tarC - ab - ac - bc + al\\n            \\n            #are we above and = or below our target\\n            return s >= n \\n            \\n        #check all lcms ahead of time\\n        abLCM = lcm(a,b)\\n        acLCM = lcm(a,c)\\n        bcLCM = lcm(b,c)\\n        allLCM = lcm(abLCM, c)\\n        \\n        #search range from \\n        l,r = 0, 2 * 10**9\\n        \\n        while l < r:\\n            \\n            mid = l + (r-l)//2\\n\\n            if isGood(mid):\\n                r = mid\\n            else:\\n                l = mid +1\\n                \\n        \\n        return l",
                "codeTag": "Java"
            },
            {
                "id": 3262133,
                "title": "c-bring-smallest-to-2nd-smallest",
                "content": "For more parameters it is better to use priority queue.\\n```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, long a, long b, long c) {\\n        vector<pair<long, long>> v = {{a, a}, {b, b}, {c, c}};\\n        while (n > 0){\\n            sort(v.begin(), v.end());\\n            --n;\\n            int dif = (v[1].first - v[0].first) / v[0].second;\\n            if (dif >= n) return v[0].first + n * v[0].second;\\n            else n -= dif;\\n            v[0].first += dif * v[0].second;\\n            long smallest = v[0].first;\\n            for (auto& [f,s] : v)\\n                if (f == smallest) f += s;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, long a, long b, long c) {\\n        vector<pair<long, long>> v = {{a, a}, {b, b}, {c, c}};\\n        while (n > 0){\\n            sort(v.begin(), v.end());\\n            --n;\\n            int dif = (v[1].first - v[0].first) / v[0].second;\\n            if (dif >= n) return v[0].first + n * v[0].second;\\n            else n -= dif;\\n            v[0].first += dif * v[0].second;\\n            long smallest = v[0].first;\\n            for (auto& [f,s] : v)\\n                if (f == smallest) f += s;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3246732,
                "title": "java-0ms-easy-solution",
                "content": "# Intuition\\nThe idea behind this solution is to use binary search to find the nth ugly number. We start by initializing a range of possible ugly numbers between 1 and Integer.MAX_VALUE. \\n\\n# Approach\\n We then use the principle of inclusion-exclusion to count the number of ugly numbers in this range. Specifically, we count the number of multiples of a, b, and c, subtract the number of multiples of the least common multiple of a and b, a and c, b and c, and add back the number of multiples of the least common multiple of a, b, and c.\\n\\nIf the count of ugly numbers in the range is less than n, we adjust the range so that the lower bound is the midpoint of the current range plus one. Otherwise, we adjust the range so that the upper bound is the midpoint of the current range.\\n\\nWe repeat this process until the range has converged to a single value, which is the nth ugly number.\\n\\nThe lcm and gcd helper functions are used to compute the least common multiple and greatest common divisor of two numbers, respectively. These functions are used in the computation of the multiples of the least common multiple of a, b, and c.\\n\\n# Complexity\\n- Time complexity:\\nThe binary search algorithm used in this solution has a time complexity of O(log N), where N is the size of the search space. In this case, the search space is the range of possible ugly numbers between 1 and Integer.MAX_VALUE, which has a size of O(N). Therefore, the time complexity of the binary search step is O(log N).\\n\\n- Space complexity:\\nThe space complexity of the solution I provided for the Ugly Number III problem is O(1).\\n\\n# Code\\n```\\nclass Solution {\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n     long low = 1, high = Integer.MAX_VALUE;\\n    long ab = lcm(a, b), ac = lcm(a, c), bc = lcm(b, c), abc = lcm(a, bc);\\n    \\n    while (low < high) {\\n        long mid = (low + high) / 2;\\n        long count = mid/a + mid/b + mid/c - mid/ab - mid/ac - mid/bc + mid/abc;\\n        if (count < n) {\\n            low = mid + 1;\\n        } else {\\n            high = mid;\\n        }\\n    }\\n    \\n    return (int)low;\\n}\\n\\nprivate long lcm(long a, long b) {\\n    return a * b / gcd(a, b);\\n}\\n\\nprivate long gcd(long a, long b) {\\n    if (b == 0) {\\n        return a;\\n    } else {\\n        return gcd(b, a % b);\\n    }\\n}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Binary Search",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n     long low = 1, high = Integer.MAX_VALUE;\\n    long ab = lcm(a, b), ac = lcm(a, c), bc = lcm(b, c), abc = lcm(a, bc);\\n    \\n    while (low < high) {\\n        long mid = (low + high) / 2;\\n        long count = mid/a + mid/b + mid/c - mid/ab - mid/ac - mid/bc + mid/abc;\\n        if (count < n) {\\n            low = mid + 1;\\n        } else {\\n            high = mid;\\n        }\\n    }\\n    \\n    return (int)low;\\n}\\n\\nprivate long lcm(long a, long b) {\\n    return a * b / gcd(a, b);\\n}\\n\\nprivate long gcd(long a, long b) {\\n    if (b == 0) {\\n        return a;\\n    } else {\\n        return gcd(b, a % b);\\n    }\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3182838,
                "title": "binary-search",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long lcmab,lcmbc,lcmac,lcmabc;\\n    long long  gcd(long long  a, long long  b){\\n        if(b==0) return a;\\n        if(a<b) return gcd(b,a);\\n        return gcd(b,a%b);\\n    }\\n    long long  lcm(long long  a, long long  b){\\n        return (a*b)/gcd(a,b);\\n    }\\n    long long  before(long long  x, long long  a, long long  b, long long  c){\\n        return (x/a)+(x/b)+(x/c)-(x/lcmab)-(x/lcmbc)-(x/lcmac)+(x/lcmabc);\\n    }\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        lcmab=lcm(a,b);\\n        lcmbc=lcm(b,c);\\n        lcmac=lcm(a,c);\\n        lcmabc=lcm(lcmab,c);\\n        long long  lo=1;\\n        long long  hi=2e9;\\n        while(lo<hi){\\n            long long  x=lo+(hi-lo)/2;\\n            if(before(x,a,b,c)>=n) hi=x;\\n            else lo=x+1;\\n        }\\n        return hi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long lcmab,lcmbc,lcmac,lcmabc;\\n    long long  gcd(long long  a, long long  b){\\n        if(b==0) return a;\\n        if(a<b) return gcd(b,a);\\n        return gcd(b,a%b);\\n    }\\n    long long  lcm(long long  a, long long  b){\\n        return (a*b)/gcd(a,b);\\n    }\\n    long long  before(long long  x, long long  a, long long  b, long long  c){\\n        return (x/a)+(x/b)+(x/c)-(x/lcmab)-(x/lcmbc)-(x/lcmac)+(x/lcmabc);\\n    }\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        lcmab=lcm(a,b);\\n        lcmbc=lcm(b,c);\\n        lcmac=lcm(a,c);\\n        lcmabc=lcm(lcmab,c);\\n        long long  lo=1;\\n        long long  hi=2e9;\\n        while(lo<hi){\\n            long long  x=lo+(hi-lo)/2;\\n            if(before(x,a,b,c)>=n) hi=x;\\n            else lo=x+1;\\n        }\\n        return hi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3136314,
                "title": "solution-in-java",
                "content": "```\\npublic class Solution {\\n    int MAX_ANS = (int) 2e9; // 2*10^9\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        int left = 0, right = MAX_ANS, result = 0;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (count(mid, a, b, c) >= n) {\\n                result = mid;\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return result;\\n    }\\n    int count(long num, long a, long b, long c) {\\n        return (int) (num / a + num / b + num / c\\n                - num / lcm(a, b)\\n                - num / lcm(b, c)\\n                - num / lcm(a, c)\\n                + num / (lcm(a, lcm(b, c))));\\n    }\\n    long gcd(long a, long b) {\\n        if (a == 0) return b;\\n        return gcd(b % a, a);\\n    }\\n    long lcm(long a, long b) {\\n        return a * b / gcd(a, b);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    int MAX_ANS = (int) 2e9; // 2*10^9\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        int left = 0, right = MAX_ANS, result = 0;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (count(mid, a, b, c) >= n) {\\n                result = mid;\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n        return result;\\n    }\\n    int count(long num, long a, long b, long c) {\\n        return (int) (num / a + num / b + num / c\\n                - num / lcm(a, b)\\n                - num / lcm(b, c)\\n                - num / lcm(a, c)\\n                + num / (lcm(a, lcm(b, c))));\\n    }\\n    long gcd(long a, long b) {\\n        if (a == 0) return b;\\n        return gcd(b % a, a);\\n    }\\n    long lcm(long a, long b) {\\n        return a * b / gcd(a, b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3119018,
                "title": "c-binary-search-with-intersection-trick-and-explanation",
                "content": "Time: O(log(2e9))\\nSpace: O(1)\\n\\nWe notice that the constraints give us an upper and lower bound on the solution, so we think of binary search. (\"It is guaranteed that the result will be in range [1, 2e9].\")\\n\\nPredicate: P(x) = (Number of ugly numbers less than x) >= n\\nWe note that this is monotonically increasing, (the larger the x, the more ugly numbers, and eventually it will be >= n) \\nand we want the smallest x such that P(x) is true.\\n\\nNow we need to determine P(x). \\nWe note that the number of multiples of a less than or equal to x is x/a, however, summing up `x/a + x/b + x/c` is wrong since there can be double counting. We thus need to account for the intersections, much like a venn diagram. Note here that for the intersection of a and b, we need to divide x by lcm(a,b).\\n\\nOne last thing to note is that if any of a, b, or c are 1, every number is ugly and so we can return n directly.\\n```\\nclass Solution {\\npublic:\\n    // get number of ugly nums less than mid\\n    long long numLess(long long a, long long b, long long c, long long x){\\n        long long ans = 0;\\n        long long ab = a*b/__gcd(a,b);\\n        long long ac = a*c/__gcd(a,c);\\n        long long bc = b*c/__gcd(b,c);\\n        long long abc = ab*c/__gcd(ab,c);\\n        \\n        ans += x/a + x/b + x/c;\\n        ans -= x/ab + x/ac + x/bc;\\n        ans += x/abc;\\n        return ans;\\n    }\\n    \\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        if(a==1 || b==1 || c==1) return n;\\n        long long low=0, high=2e9;\\n        while(low<high){\\n            long long mid = (low+high)/2;\\n            if(numLess(a,b,c,mid) >= n) high = mid;\\n            else low = mid+1;\\n        }\\n        return low;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // get number of ugly nums less than mid\\n    long long numLess(long long a, long long b, long long c, long long x){\\n        long long ans = 0;\\n        long long ab = a*b/__gcd(a,b);\\n        long long ac = a*c/__gcd(a,c);\\n        long long bc = b*c/__gcd(b,c);\\n        long long abc = ab*c/__gcd(ab,c);\\n        \\n        ans += x/a + x/b + x/c;\\n        ans -= x/ab + x/ac + x/bc;\\n        ans += x/abc;\\n        return ans;\\n    }\\n    \\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        if(a==1 || b==1 || c==1) return n;\\n        long long low=0, high=2e9;\\n        while(low<high){\\n            long long mid = (low+high)/2;\\n            if(numLess(a,b,c,mid) >= n) high = mid;\\n            else low = mid+1;\\n        }\\n        return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3094479,
                "title": "100-and-tle-solution-need-cleaning-typescript-js",
                "content": "\\n\\n# Code\\n```\\nfunction nthUglyNumber(n: number, a: number, b: number, c: number): number {\\n    // binary search\\n    const ab: number = Math.floor(a * b / gcd_two_num(a,b));\\n    const ac: number = Math.floor(a * c / gcd_two_num(a,c));\\n    const bc: number = Math.floor(b * c / gcd_two_num(b,c));\\n    const abc: number = Math.floor(a * bc / gcd_two_num(a,bc));\\n    const is_enough = (mid: number): boolean=>{\\n        const total: number = floor_div(mid,a) + floor_div(mid,b) + floor_div(mid,c) - floor_div(mid,ab) - floor_div(mid,bc) - floor_div(mid,ac) + floor_div(mid,abc);\\n        return total >= n;\\n    }\\n    let start: number = Math.min(a,b,c);\\n    // let start: number = 1;\\n    let end: number = 10 ** 10;\\n    while (start < end){\\n        const mid = Math.floor((start+end)/2);\\n        // const mid = start +  Math.floor((end-start)/2);\\n        if (is_enough(mid)){\\n            end = mid;\\n            continue;\\n        }\\n        start = mid + 1;\\n    }\\n    return start;\\n\\n\\n    // linear solution : TLE solution\\n    let count: number = 0;\\n    let num: number = Math.min(a,b,c);\\n    while (count < n){\\n        if (is_ugly(num, a, b, c)) count += 1;\\n        num += 1;\\n    }\\n    return num - 1;\\n\\n};\\n// utils\\nconst floor_div = (num1: number, num2: number): number => Math.floor(num1/num2);\\n\\n// euclid algo, source wikipedia\\n// function gcd(a, b)\\n//     while b \\u2260 0\\n//         t := b\\n//         b := a mod b\\n//         a := t\\n//     return a\\nconst gcd_two_num = (num1: number, num2: number): number => {\\n    let n1: number = num1;\\n    let n2: number = num2;\\n    while (n2 !== 0){\\n        const temp: number = n2;\\n        n2 = n1 % n2;\\n        n1 = temp;\\n    }\\n    return n1;\\n}\\n\\n// scuk algorthm\\nconst greatest_div = (...args: number[]): number =>{\\n    if (!args) return -1;\\n    const min_num: number = Math.min(...args);\\n    for (let div = min_num; div >= 1; div -= 1){\\n        let count: number = args.reduce((prev_count, curr_num)=>{\\n            if (curr_num % div === 0){\\n                return prev_count+1;\\n            }\\n        }, 0)\\n        if (count === args.length) return div;\\n    }\\n}\\n\\nconst is_ugly = (num: number, a: number, b: number, c: number): boolean =>{\\n    return num % a === 0 || num % b === 0 || num % c === 0;\\n}\\n\\nconst ugly_before = (num: number, a: number, b: number, c: number, start_num: number): number=>{\\n    let count: number = 1;\\n    for (let i = start_num; i < num; i += 1){\\n        if (is_ugly(i, a, b, c)) count += 1;\\n    }\\n    return count;\\n}\\n\\n// const all_ugly_below = (num: number, a: number, b: number, c: number): {nth: number, nth_num: number} => {\\n//    // return an array or nah think \\n// }\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Math",
                    "Binary Search",
                    "Number Theory"
                ],
                "code": "```\\nfunction nthUglyNumber(n: number, a: number, b: number, c: number): number {\\n    // binary search\\n    const ab: number = Math.floor(a * b / gcd_two_num(a,b));\\n    const ac: number = Math.floor(a * c / gcd_two_num(a,c));\\n    const bc: number = Math.floor(b * c / gcd_two_num(b,c));\\n    const abc: number = Math.floor(a * bc / gcd_two_num(a,bc));\\n    const is_enough = (mid: number): boolean=>{\\n        const total: number = floor_div(mid,a) + floor_div(mid,b) + floor_div(mid,c) - floor_div(mid,ab) - floor_div(mid,bc) - floor_div(mid,ac) + floor_div(mid,abc);\\n        return total >= n;\\n    }\\n    let start: number = Math.min(a,b,c);\\n    // let start: number = 1;\\n    let end: number = 10 ** 10;\\n    while (start < end){\\n        const mid = Math.floor((start+end)/2);\\n        // const mid = start +  Math.floor((end-start)/2);\\n        if (is_enough(mid)){\\n            end = mid;\\n            continue;\\n        }\\n        start = mid + 1;\\n    }\\n    return start;\\n\\n\\n    // linear solution : TLE solution\\n    let count: number = 0;\\n    let num: number = Math.min(a,b,c);\\n    while (count < n){\\n        if (is_ugly(num, a, b, c)) count += 1;\\n        num += 1;\\n    }\\n    return num - 1;\\n\\n};\\n// utils\\nconst floor_div = (num1: number, num2: number): number => Math.floor(num1/num2);\\n\\n// euclid algo, source wikipedia\\n// function gcd(a, b)\\n//     while b \\u2260 0\\n//         t := b\\n//         b := a mod b\\n//         a := t\\n//     return a\\nconst gcd_two_num = (num1: number, num2: number): number => {\\n    let n1: number = num1;\\n    let n2: number = num2;\\n    while (n2 !== 0){\\n        const temp: number = n2;\\n        n2 = n1 % n2;\\n        n1 = temp;\\n    }\\n    return n1;\\n}\\n\\n// scuk algorthm\\nconst greatest_div = (...args: number[]): number =>{\\n    if (!args) return -1;\\n    const min_num: number = Math.min(...args);\\n    for (let div = min_num; div >= 1; div -= 1){\\n        let count: number = args.reduce((prev_count, curr_num)=>{\\n            if (curr_num % div === 0){\\n                return prev_count+1;\\n            }\\n        }, 0)\\n        if (count === args.length) return div;\\n    }\\n}\\n\\nconst is_ugly = (num: number, a: number, b: number, c: number): boolean =>{\\n    return num % a === 0 || num % b === 0 || num % c === 0;\\n}\\n\\nconst ugly_before = (num: number, a: number, b: number, c: number, start_num: number): number=>{\\n    let count: number = 1;\\n    for (let i = start_num; i < num; i += 1){\\n        if (is_ugly(i, a, b, c)) count += 1;\\n    }\\n    return count;\\n}\\n\\n// const all_ugly_below = (num: number, a: number, b: number, c: number): {nth: number, nth_num: number} => {\\n//    // return an array or nah think \\n// }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3066911,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn nth_ugly_number(n: i32, a: i32, b: i32, c: i32) -> i32 {\\n        fn count(n: i64, a: i64, b: i64, c: i64) -> i64 {\\n            let mut count = 0;\\n            count += n / a;\\n            count += n / b;\\n            count += n / c;\\n            count -= n / lcm(a, b);\\n            count -= n / lcm(a, c);\\n            count -= n / lcm(b, c);\\n            count += n / lcm(a, lcm(b, c));\\n            count\\n        }\\n\\n        fn gcd(a: i64, b: i64) -> i64 {\\n            if b == 0 {\\n                a\\n            } else {\\n                gcd(b, a % b)\\n            }\\n        }\\n\\n        fn lcm(a: i64, b: i64) -> i64 {\\n            a * b / gcd(a, b)\\n        }\\n\\n        let (n, a, b, c) = (n as i64, a as i64, b as i64, c as i64);\\n\\n        let mut left = 1;\\n        let mut right = 2 * 10_i64.pow(9);\\n        while left < right {\\n            let mid = left + (right - left) / 2;\\n            let count = count(mid, a, b, c);\\n            if count < n {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        left as _\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn nth_ugly_number(n: i32, a: i32, b: i32, c: i32) -> i32 {\\n        fn count(n: i64, a: i64, b: i64, c: i64) -> i64 {\\n            let mut count = 0;\\n            count += n / a;\\n            count += n / b;\\n            count += n / c;\\n            count -= n / lcm(a, b);\\n            count -= n / lcm(a, c);\\n            count -= n / lcm(b, c);\\n            count += n / lcm(a, lcm(b, c));\\n            count\\n        }\\n\\n        fn gcd(a: i64, b: i64) -> i64 {\\n            if b == 0 {\\n                a\\n            } else {\\n                gcd(b, a % b)\\n            }\\n        }\\n\\n        fn lcm(a: i64, b: i64) -> i64 {\\n            a * b / gcd(a, b)\\n        }\\n\\n        let (n, a, b, c) = (n as i64, a as i64, b as i64, c as i64);\\n\\n        let mut left = 1;\\n        let mut right = 2 * 10_i64.pow(9);\\n        while left < right {\\n            let mid = left + (right - left) / 2;\\n            let count = count(mid, a, b, c);\\n            if count < n {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        left as _\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2973181,
                "title": "great-question-for-gcd-eucledian-algorithm-implementation",
                "content": "# Intuition\\nIf you think of the greatest common divisors as groups, you can count the number of elements simply by adding and the groups and subtracting elements that are in two groups (wich will result in you subtracting twice elements that are in three groups) and adding elements that are in three groups.\\n\\n# Approach\\n- Euclidean Algorithm\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```java\\nclass Solution {\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        long nab = a*1l*b/gcd(a,b);\\n        long nac = a*1l*c/gcd(a,c);\\n        long nbc = b*1l*c/gcd(b,c);\\n        long nabc = nab*c/gcd(nab,c);\\n\\n        int x=1, y=2000000001;\\n        while(x<=y) {\\n            long mid=x+(y-x)/2;\\n            long g= mid/a + mid/b + mid/c - mid/nab - mid/nac - mid/nbc + mid/nabc;\\n            if(g<n) x=(int)mid+1;\\n            else y=(int)mid-1;\\n        }\\n        return x;\\n        \\n    }\\n\\n    long gcd(long a, long b) {\\n        if(b==0) return a;\\n        return gcd(b,a%b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        long nab = a*1l*b/gcd(a,b);\\n        long nac = a*1l*c/gcd(a,c);\\n        long nbc = b*1l*c/gcd(b,c);\\n        long nabc = nab*c/gcd(nab,c);\\n\\n        int x=1, y=2000000001;\\n        while(x<=y) {\\n            long mid=x+(y-x)/2;\\n            long g= mid/a + mid/b + mid/c - mid/nab - mid/nac - mid/nbc + mid/nabc;\\n            if(g<n) x=(int)mid+1;\\n            else y=(int)mid-1;\\n        }\\n        return x;\\n        \\n    }\\n\\n    long gcd(long a, long b) {\\n        if(b==0) return a;\\n        return gcd(b,a%b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2884326,
                "title": "javascript",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number} a\\n * @param {number} b\\n * @param {number} c\\n * @return {number}\\n */\\nvar nthUglyNumber = function(n, a, b, c) {\\n    \\n    let left = 1, right = Math.pow(10,10)\\n\\n    const feasible = (num) => {\\n        let total = Math.floor(num/a) +Math.floor(num/b) +Math.floor(num/c) - Math.floor(num/ab) - Math.floor(num/ac) - Math.floor(num/bc) + Math.floor(num/abc)\\n\\n        return total >=n\\n    }\\n\\n    const gcd = (a,b) => b == 0  ? a : gcd(b,a%b)\\n\\n    let ab = Math.floor(a*b/ gcd(a,b))\\n    let bc = Math.floor(b*c/ gcd(b,c))\\n    let ac = Math.floor(a*c/ gcd(a,c))\\n    let abc = Math.floor(a*bc/ gcd(a,bc))\\n\\n\\n\\n    while(left<right){\\n        let mid = Math.floor(left + (right - left) / 2)\\n\\n        if(feasible(mid)) right = mid\\n        else left = mid + 1\\n    }\\n\\n    return left\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number} a\\n * @param {number} b\\n * @param {number} c\\n * @return {number}\\n */\\nvar nthUglyNumber = function(n, a, b, c) {\\n    \\n    let left = 1, right = Math.pow(10,10)\\n\\n    const feasible = (num) => {\\n        let total = Math.floor(num/a) +Math.floor(num/b) +Math.floor(num/c) - Math.floor(num/ab) - Math.floor(num/ac) - Math.floor(num/bc) + Math.floor(num/abc)\\n\\n        return total >=n\\n    }\\n\\n    const gcd = (a,b) => b == 0  ? a : gcd(b,a%b)\\n\\n    let ab = Math.floor(a*b/ gcd(a,b))\\n    let bc = Math.floor(b*c/ gcd(b,c))\\n    let ac = Math.floor(a*c/ gcd(a,c))\\n    let abc = Math.floor(a*bc/ gcd(a,bc))\\n\\n\\n\\n    while(left<right){\\n        let mid = Math.floor(left + (right - left) / 2)\\n\\n        if(feasible(mid)) right = mid\\n        else left = mid + 1\\n    }\\n\\n    return left\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2858650,
                "title": "swift-solution",
                "content": "```\\n// Ugly number III\\n// https://leetcode.com/problems/ugly-number-iii/\\n\\nclass Solution {\\n    func nthUglyNumber(_ n: Int, _ a: Int, _ b: Int, _ c: Int) -> Int {\\n        var left = 1\\n        var right = Int(2e9)\\n        let ab = lcm(a, b)\\n        let ac = lcm(a, c)\\n        let bc = lcm(b, c)\\n        let abc = lcm(ab, c)\\n        while left < right {\\n            let mid = left + (right - left) / 2\\n            let count = mid / a + mid / b + mid / c - mid / ab - mid / ac - mid / bc + mid / abc\\n            if count < n {\\n                left = mid + 1\\n            } else {\\n                right = mid\\n            }\\n        }\\n        return left\\n    }\\n    \\n    func gcd(_ a: Int, _ b: Int) -> Int {\\n        return b == 0 ? a : gcd(b, a % b)\\n    }\\n    \\n    func lcm(_ a: Int, _ b: Int) -> Int {\\n        return a * b / gcd(a, b)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Binary Tree"
                ],
                "code": "```\\n// Ugly number III\\n// https://leetcode.com/problems/ugly-number-iii/\\n\\nclass Solution {\\n    func nthUglyNumber(_ n: Int, _ a: Int, _ b: Int, _ c: Int) -> Int {\\n        var left = 1\\n        var right = Int(2e9)\\n        let ab = lcm(a, b)\\n        let ac = lcm(a, c)\\n        let bc = lcm(b, c)\\n        let abc = lcm(ab, c)\\n        while left < right {\\n            let mid = left + (right - left) / 2\\n            let count = mid / a + mid / b + mid / c - mid / ab - mid / ac - mid / bc + mid / abc\\n            if count < n {\\n                left = mid + 1\\n            } else {\\n                right = mid\\n            }\\n        }\\n        return left\\n    }\\n    \\n    func gcd(_ a: Int, _ b: Int) -> Int {\\n        return b == 0 ? a : gcd(b, a % b)\\n    }\\n    \\n    func lcm(_ a: Int, _ b: Int) -> Int {\\n        return a * b / gcd(a, b)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2857929,
                "title": "binary-search-rust-solution",
                "content": "```\\nimpl Solution {\\n    \\n    pub fn gcd(a: i64, b: i64) -> i64 {\\n        \\n        let mut x = a;\\n        let mut y = b;\\n        \\n        while y != 0 {\\n            let temp = x;\\n            x = y;\\n            y = (temp%y);\\n        }\\n        \\n        return x;\\n    }\\n    \\n    pub fn lcm(a: i64, b: i64) -> i64 {\\n        \\n        return (a*b) / Solution::gcd(a, b);\\n        \\n    }\\n    \\n    pub fn ugly_numbers_count(n: i64, a: i64, b: i64, c: i64) -> i64 {\\n        \\n        let a_mult = n / a;\\n        let b_mult = n / b;\\n        let c_mult = n / c;\\n        \\n        let a_c = n / Solution::lcm(a, c);\\n        let a_b = n / Solution::lcm(a, b);\\n        let c_b = n / Solution::lcm(c, b);\\n        \\n        let a_b_c = n / Solution::lcm(a, Solution::lcm(b, c));\\n        \\n        return a_mult + b_mult + c_mult - a_b - a_c - c_b + a_b_c;\\n        \\n    }\\n    \\n    \\n    pub fn is_divisible(num: i64, a: i64, b: i64, c: i64) -> bool {\\n        \\n        if num % a == 0 || num % b == 0 || num % c == 0 {\\n            return true;\\n        }\\n        \\n        return false;\\n        \\n    }\\n    \\n    \\n    // O(logn) time,\\n    // O(logn) space,\\n    // Approach: binary search, math\\n    pub fn nth_ugly_number(n: i32, a: i32, b: i32, c: i32) -> i32 {\\n        \\n        let mut lo = 1 as i64;\\n        let mut hi = i32::MAX as i64;\\n        \\n        while lo <= hi {\\n            \\n            let mid = lo + (hi-lo)/2;\\n            let count = Solution::ugly_numbers_count(mid, a as i64, b as i64, c as i64);\\n\\n            if count == n as i64 && Solution::is_divisible(mid, a as i64, b as i64, c as i64) {\\n                return mid as i32;\\n            }\\n            else if count >= n  as i64 {\\n                hi = mid-1;\\n            }\\n            else {\\n                lo = mid + 1;\\n            }\\n            \\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Math",
                    "Binary Search"
                ],
                "code": "```\\nimpl Solution {\\n    \\n    pub fn gcd(a: i64, b: i64) -> i64 {\\n        \\n        let mut x = a;\\n        let mut y = b;\\n        \\n        while y != 0 {\\n            let temp = x;\\n            x = y;\\n            y = (temp%y);\\n        }\\n        \\n        return x;\\n    }\\n    \\n    pub fn lcm(a: i64, b: i64) -> i64 {\\n        \\n        return (a*b) / Solution::gcd(a, b);\\n        \\n    }\\n    \\n    pub fn ugly_numbers_count(n: i64, a: i64, b: i64, c: i64) -> i64 {\\n        \\n        let a_mult = n / a;\\n        let b_mult = n / b;\\n        let c_mult = n / c;\\n        \\n        let a_c = n / Solution::lcm(a, c);\\n        let a_b = n / Solution::lcm(a, b);\\n        let c_b = n / Solution::lcm(c, b);\\n        \\n        let a_b_c = n / Solution::lcm(a, Solution::lcm(b, c));\\n        \\n        return a_mult + b_mult + c_mult - a_b - a_c - c_b + a_b_c;\\n        \\n    }\\n    \\n    \\n    pub fn is_divisible(num: i64, a: i64, b: i64, c: i64) -> bool {\\n        \\n        if num % a == 0 || num % b == 0 || num % c == 0 {\\n            return true;\\n        }\\n        \\n        return false;\\n        \\n    }\\n    \\n    \\n    // O(logn) time,\\n    // O(logn) space,\\n    // Approach: binary search, math\\n    pub fn nth_ugly_number(n: i32, a: i32, b: i32, c: i32) -> i32 {\\n        \\n        let mut lo = 1 as i64;\\n        let mut hi = i32::MAX as i64;\\n        \\n        while lo <= hi {\\n            \\n            let mid = lo + (hi-lo)/2;\\n            let count = Solution::ugly_numbers_count(mid, a as i64, b as i64, c as i64);\\n\\n            if count == n as i64 && Solution::is_divisible(mid, a as i64, b as i64, c as i64) {\\n                return mid as i32;\\n            }\\n            else if count >= n  as i64 {\\n                hi = mid-1;\\n            }\\n            else {\\n                lo = mid + 1;\\n            }\\n            \\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2844082,
                "title": "java-easy-solution-with-explanation",
                "content": "```\\nclass Solution {\\n  //So what\\'s the thought process for this question if we generate linearly all the ugly number and give the nth ugly number it will give tle in this question like in the previousugly number2 approach we did solve with the help of dp but here we can\\'t since the constraints are too big so what else we can do... so what if I use the binary search why? I had the parameter start and end now if we will apply the binary search and find the mid than that mid have some numbers\\n//ya that\\'s true now if I divide that mid with first A than B than C what will I get I will get the amount of those numbers which are divisible by these number. \\n  //example 7 a=2 b=3 c=5  what will i get when i divide everyone 7/2=3  7/3=2  7/5=1  this shows how many divisible element are present so did you observe something if i add these numbers i will get as 3+2+1 =5 and from the range of 1to7 how many ugly number are there which are either divsible by 2 or 3 or 5 they are 5 numbers and has what I wanted but here we have 5 in the range of 7 but if n=3 was there i have to decrement the range in ordre to get the correct number but potentially i will store the mid in the answer as it can be ...\\n  \\n  //some important observation  as we can see we are adding the number divisible by 2 or 3 or 5 don\\'t you think we are adding some number twice which are both common in (2 and 3) (2 and 5) (3 and 5) as well as (a and b and c) so we ahd to remove these as well .\\n  \\n  //Don\\'t you think this is some type of formula yes exactly this is AuBuC formula observe it carefully \\n  \\n  //so final formula we will be using is k/A+k/B+k/C-k/(lcm(A,B))-k/(lcm(A,C))-k/(lcm(B,C))+k/(lcm(A,lcm(B,C)));\\n  \\n//least common divisible will give us the umber of common factors .Here k is the number which is nothing but mid have a look in the below implementation.  \\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n      long start=1;\\n      long end=(long)(2*1e9);\\n      long A=a;\\n      long B=b;\\n      long C=c;\\n      long ans=0;\\n      while(start<=end){\\n        long mid=start+(end-start)/2;\\n        long count=0;\\n        count+=mid/A;\\n        count+=mid/B;\\n        count+=mid/C;\\n        count-=mid/(LCM(A,B));\\n        count-=mid/(LCM(A,C));\\n        count-=mid/(LCM(B,C));\\n        count+=mid/(LCM(A,LCM(B,C)));\\n        \\n        if(count>=n){\\n          ans=mid;\\n          end=mid-1;\\n        }\\n        else{\\n          start=mid+1;\\n        }\\n      }\\n      return (int)ans;\\n    }\\n  \\n  public long LCM(long a,long b){\\n    return a*b/GCD(a,b);\\n  }\\n  public long GCD(long a,long b){\\n    if(b==0)return a;\\n    return GCD(b,a%b);\\n  }\\n}\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n  //So what\\'s the thought process for this question if we generate linearly all the ugly number and give the nth ugly number it will give tle in this question like in the previousugly number2 approach we did solve with the help of dp but here we can\\'t since the constraints are too big so what else we can do... so what if I use the binary search why? I had the parameter start and end now if we will apply the binary search and find the mid than that mid have some numbers\\n//ya that\\'s true now if I divide that mid with first A than B than C what will I get I will get the amount of those numbers which are divisible by these number. \\n  //example 7 a=2 b=3 c=5  what will i get when i divide everyone 7/2=3  7/3=2  7/5=1  this shows how many divisible element are present so did you observe something if i add these numbers i will get as 3+2+1 =5 and from the range of 1to7 how many ugly number are there which are either divsible by 2 or 3 or 5 they are 5 numbers and has what I wanted but here we have 5 in the range of 7 but if n=3 was there i have to decrement the range in ordre to get the correct number but potentially i will store the mid in the answer as it can be ...\\n  \\n  //some important observation  as we can see we are adding the number divisible by 2 or 3 or 5 don\\'t you think we are adding some number twice which are both common in (2 and 3) (2 and 5) (3 and 5) as well as (a and b and c) so we ahd to remove these as well .\\n  \\n  //Don\\'t you think this is some type of formula yes exactly this is AuBuC formula observe it carefully \\n  \\n  //so final formula we will be using is k/A+k/B+k/C-k/(lcm(A,B))-k/(lcm(A,C))-k/(lcm(B,C))+k/(lcm(A,lcm(B,C)));\\n  \\n//least common divisible will give us the umber of common factors .Here k is the number which is nothing but mid have a look in the below implementation.  \\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n      long start=1;\\n      long end=(long)(2*1e9);\\n      long A=a;\\n      long B=b;\\n      long C=c;\\n      long ans=0;\\n      while(start<=end){\\n        long mid=start+(end-start)/2;\\n        long count=0;\\n        count+=mid/A;\\n        count+=mid/B;\\n        count+=mid/C;\\n        count-=mid/(LCM(A,B));\\n        count-=mid/(LCM(A,C));\\n        count-=mid/(LCM(B,C));\\n        count+=mid/(LCM(A,LCM(B,C)));\\n        \\n        if(count>=n){\\n          ans=mid;\\n          end=mid-1;\\n        }\\n        else{\\n          start=mid+1;\\n        }\\n      }\\n      return (int)ans;\\n    }\\n  \\n  public long LCM(long a,long b){\\n    return a*b/GCD(a,b);\\n  }\\n  public long GCD(long a,long b){\\n    if(b==0)return a;\\n    return GCD(b,a%b);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832655,
                "title": "c-solution-binary-search-faster-than-100-easy-to-understand",
                "content": "\\n```\\nclass Solution {\\npublic:\\n//reference : ugly number II\\n    long long lcm(long long a,long long b){\\n        return (a*b)/(__gcd(a,b));\\n    }\\n\\n    int nthUglyNumber(int n, int aa, int bb, int cc) {\\n        long long a=aa,b=bb,c=cc;\\n        long long low = 1 ,high = INT_MAX;\\n        while(low < high){\\n            int mid = low + (high - low)/2;\\n            //number of divisible numbers (aDiv) : numbers divisible by a,(abDiv):numbers divisible by a and b,(abcDiv) : numbers divisible by a,b and c;\\n            long long aDiv = mid/a, bDiv = mid/b , cDiv = mid/c , abDiv = mid/lcm(a,b), bcDiv = mid/lcm(b,c),caDiv = mid/lcm(c,a),abcDiv=mid/lcm(a,lcm(b,c));\\n\\n            long long total = aDiv + bDiv + cDiv - abDiv - bcDiv - caDiv + abcDiv;\\n            if(total < n) low = mid + 1;\\n            else high = mid;\\n        }\\n\\n        return low;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//reference : ugly number II\\n    long long lcm(long long a,long long b){\\n        return (a*b)/(__gcd(a,b));\\n    }\\n\\n    int nthUglyNumber(int n, int aa, int bb, int cc) {\\n        long long a=aa,b=bb,c=cc;\\n        long long low = 1 ,high = INT_MAX;\\n        while(low < high){\\n            int mid = low + (high - low)/2;\\n            //number of divisible numbers (aDiv) : numbers divisible by a,(abDiv):numbers divisible by a and b,(abcDiv) : numbers divisible by a,b and c;\\n            long long aDiv = mid/a, bDiv = mid/b , cDiv = mid/c , abDiv = mid/lcm(a,b), bcDiv = mid/lcm(b,c),caDiv = mid/lcm(c,a),abcDiv=mid/lcm(a,lcm(b,c));\\n\\n            long long total = aDiv + bDiv + cDiv - abDiv - bcDiv - caDiv + abcDiv;\\n            if(total < n) low = mid + 1;\\n            else high = mid;\\n        }\\n\\n        return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2827729,
                "title": "python3-using-binary-search-and-set-theory",
                "content": "class Solution:\\n\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        def gcd(a,b):\\n            if b == 0:\\n                return a\\n            return gcd(b,a%b)\\n        \\n        def lcm(a,b):\\n            return (a*b)//gcd(a,b)\\n        \\n        l,r = 1,2*10**9\\n        \\n        while l<r:\\n            mid = (l+r)//2\\n            count = mid//a+mid//b+mid//c-mid//lcm(a,b)-mid//lcm(a,c)-mid//lcm(b,c)+mid//lcm(a,lcm(b,c))\\n            if count<n:\\n                l = mid + 1\\n            else:\\n                r = mid\\n        return l",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        def gcd(a,b):\\n            if b == 0:\\n                return a\\n            return gcd(b,a%b)\\n        \\n        def lcm(a,b):\\n            return (a*b)//gcd(a,b)\\n        \\n        l,r = 1,2*10**9\\n        \\n        while l<r:\\n            mid = (l+r)//2\\n            count = mid//a+mid//b+mid//c-mid//lcm(a,b)-mid//lcm(a,c)-mid//lcm(b,c)+mid//lcm(a,lcm(b,c))\\n            if count<n:\\n                l = mid + 1\\n            else:\\n                r = mid\\n        return l",
                "codeTag": "Java"
            },
            {
                "id": 2814916,
                "title": "fully-explained-code-c-solution-binary-search-union-concept",
                "content": "\\nIf It helps plz upvote :)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, int A, int B, int C) {\\n        // Logic (Binary Search)\\n        // We can find the kth ugly element by binary searching it\\'s position\\n        // No upto N divisible by a = N / a\\n        // No upto N divisible by b = N / b\\n        // No upto N divisible by c = N / c\\n        // No upto N divisible by both (a,b) = N / Lcm(a,b)\\n        // No upto N divisible by both (b,c) = N / Lcm(b,c)\\n        // No upto N divisible by both (c,a) = N / Lcm(c,a)\\n        // No upto N divisible by (a,b,c) = N / Lcm(a,b,c)\\n\\n        // We can find the position of any ugly number by this\\n        // We already have range of ugly number from constraint\\n        \\n        long long s = 1;\\n        long long e = 2 * 1e9;\\n        long long ans;\\n        // Type converting\\n        long a = long(A);\\n        long b = long(B);\\n        long c = long(C);\\n\\n        while(s <= e){\\n            long long mid = s + (e - s) / 2;\\n            long long count = 0;\\n            // Finding the position of ugly number\\n            // (A U B U C) = A + B + C - (A \\u2229 B) - (B \\u2229 C) - (C \\u2229 A) + (A \\u2229 B \\u2229 C)\\n            count += mid / a;\\n            count += mid / b;\\n            count += mid / c;\\n            count -= mid / lcm(a,b);\\n            count -= mid / lcm(b,c);\\n            count -= mid / lcm(c,a);\\n            count += mid / lcm(a,lcm(b,c));\\n\\n            if(count >= n){\\n                ans = mid;\\n                e = mid - 1;\\n            }\\n            else{\\n                s = mid + 1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Binary Search",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, int A, int B, int C) {\\n        // Logic (Binary Search)\\n        // We can find the kth ugly element by binary searching it\\'s position\\n        // No upto N divisible by a = N / a\\n        // No upto N divisible by b = N / b\\n        // No upto N divisible by c = N / c\\n        // No upto N divisible by both (a,b) = N / Lcm(a,b)\\n        // No upto N divisible by both (b,c) = N / Lcm(b,c)\\n        // No upto N divisible by both (c,a) = N / Lcm(c,a)\\n        // No upto N divisible by (a,b,c) = N / Lcm(a,b,c)\\n\\n        // We can find the position of any ugly number by this\\n        // We already have range of ugly number from constraint\\n        \\n        long long s = 1;\\n        long long e = 2 * 1e9;\\n        long long ans;\\n        // Type converting\\n        long a = long(A);\\n        long b = long(B);\\n        long c = long(C);\\n\\n        while(s <= e){\\n            long long mid = s + (e - s) / 2;\\n            long long count = 0;\\n            // Finding the position of ugly number\\n            // (A U B U C) = A + B + C - (A \\u2229 B) - (B \\u2229 C) - (C \\u2229 A) + (A \\u2229 B \\u2229 C)\\n            count += mid / a;\\n            count += mid / b;\\n            count += mid / c;\\n            count -= mid / lcm(a,b);\\n            count -= mid / lcm(b,c);\\n            count -= mid / lcm(c,a);\\n            count += mid / lcm(a,lcm(b,c));\\n\\n            if(count >= n){\\n                ans = mid;\\n                e = mid - 1;\\n            }\\n            else{\\n                s = mid + 1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2777954,
                "title": "python-binary-search-inclusion-and-exclusion",
                "content": "```\\nfrom math import gcd\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        def count(k, a, b, c):\\n            ab = a*b//gcd(a,b)\\n            abc = ab*c//gcd(ab,c)\\n            return k//a + k//b + k//c - k//(a*b//gcd(a,b)) - k//(b*c//gcd(b,c)) -k//(a*c//gcd(a,c)) + k//abc\\n        left, right = 1, 2*10**9\\n        while left < right:\\n            m = (left + right)//2\\n            if count(m, a, b, c) >= n:\\n                right = m\\n            else:\\n                left = m + 1\\n        return left",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom math import gcd\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        def count(k, a, b, c):\\n            ab = a*b//gcd(a,b)\\n            abc = ab*c//gcd(ab,c)\\n            return k//a + k//b + k//c - k//(a*b//gcd(a,b)) - k//(b*c//gcd(b,c)) -k//(a*c//gcd(a,c)) + k//abc\\n        left, right = 1, 2*10**9\\n        while left < right:\\n            m = (left + right)//2\\n            if count(m, a, b, c) >= n:\\n                right = m\\n            else:\\n                left = m + 1\\n        return left",
                "codeTag": "Java"
            },
            {
                "id": 2699325,
                "title": "clearly-explained-c-solution-runtime-0ms-o-log-n-complexity-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNth Smallest Number is same as finding the Kth smallest number\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTwo questions are required to be answered here.\\n\\nQ1. Given a number n, and three numbers a, b and c, calculate the total count of numbers in range [1,n] such that each number is either divisible by a or b or c.\\n\\nQ2. Think about if multiple of one another exist in (a or b or c) i.e, c can be a multiple of b\\n\\n# Complexity\\n- Time complexity: O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool condition(long long int mid, int a, int b, int c, int n){\\n        long long int ab, ac, bc, abc,count = 0;\\n        ab = (((long)a*b)/__gcd(a,b));\\n        bc = (((long)b*c)/__gcd(b,c));\\n        ac = (((long)a*c)/__gcd(a,c));\\n        abc = (((long)a*bc)/__gcd((long long)a,bc));\\n        count += (mid/a + mid/b + mid/c - mid/ab - mid/bc - mid/ac + mid/abc);\\n        return count>=n;\\n    }\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        //  are there n-1 smallest numbers when n = mid?\\n        long long int left = 1, right = 1e12, mid;\\n        while(left<right){\\n            mid = (left) + (right-left)/2;\\n            if(condition(mid,a,b,c,n))right = mid;\\n            else left = mid+1;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool condition(long long int mid, int a, int b, int c, int n){\\n        long long int ab, ac, bc, abc,count = 0;\\n        ab = (((long)a*b)/__gcd(a,b));\\n        bc = (((long)b*c)/__gcd(b,c));\\n        ac = (((long)a*c)/__gcd(a,c));\\n        abc = (((long)a*bc)/__gcd((long long)a,bc));\\n        count += (mid/a + mid/b + mid/c - mid/ab - mid/bc - mid/ac + mid/abc);\\n        return count>=n;\\n    }\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        //  are there n-1 smallest numbers when n = mid?\\n        long long int left = 1, right = 1e12, mid;\\n        while(left<right){\\n            mid = (left) + (right-left)/2;\\n            if(condition(mid,a,b,c,n))right = mid;\\n            else left = mid+1;\\n        }\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2659476,
                "title": "runtime-0-ms-faster-than-100-00-of-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    long gcd(long a,long b){\\n        if(a>b)return gcd(b,a);\\n        if(a==0)return b;\\n        return gcd(a,b%a);\\n    }\\n    long lcm(long a,long b){\\n        return (a*b)/gcd(a,b);\\n    }\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        if(min({a,b,c})==1)return n;\\n        long long int l=min({a,b,c});\\n        long long int h=n*l;\\n        while(h>l){\\n            long long int mid=l+(h-l)/2;\\n            long long int pos=mid/a+mid/b+mid/c-(mid/lcm(a,b)+mid/lcm(a,c)+mid/lcm(b,c))+mid/lcm(a,lcm(b,c));\\n            if(pos>=n) h=mid;\\n            else  l=mid+1;\\n        }\\n        return (int)l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long gcd(long a,long b){\\n        if(a>b)return gcd(b,a);\\n        if(a==0)return b;\\n        return gcd(a,b%a);\\n    }\\n    long lcm(long a,long b){\\n        return (a*b)/gcd(a,b);\\n    }\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        if(min({a,b,c})==1)return n;\\n        long long int l=min({a,b,c});\\n        long long int h=n*l;\\n        while(h>l){\\n            long long int mid=l+(h-l)/2;\\n            long long int pos=mid/a+mid/b+mid/c-(mid/lcm(a,b)+mid/lcm(a,c)+mid/lcm(b,c))+mid/lcm(a,lcm(b,c));\\n            if(pos>=n) h=mid;\\n            else  l=mid+1;\\n        }\\n        return (int)l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620373,
                "title": "java-easy-solution-java-binary-search-easy-beginner-friendly",
                "content": "class Solution {\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n    \\n        int lo=0;\\n        int hi=Integer.MAX_VALUE;\\n        \\n        long ab=lcm(a,b),bc=lcm(b,c),ac=lcm(a,c),abc=lcm(ab,c);\\n        \\n        while(lo < hi)\\n        {\\n            int mid = lo+(hi-lo)/2;\\n            \\n            long count =0L+ mid/a+mid/b+mid/c-mid/ab-mid/ac-mid/bc+mid/abc;\\n            \\n            if(count >=n){\\n                hi = mid;\\n            }\\n            else{\\n                lo=mid+1;\\n            }\\n        }\\n        \\n        return lo;\\n        \\n        \\n        \\n    }\\n    long gcd(long a ,long b){\\n        return b==0 ? a : gcd(b,a%b);\\n    }\\n    \\n    long lcm(long a ,long b){\\n        return a*b /gcd(a,b);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n    \\n        int lo=0;\\n        int hi=Integer.MAX_VALUE;\\n        \\n        long ab=lcm(a,b),bc=lcm(b,c),ac=lcm(a,c),abc=lcm(ab,c);\\n        \\n        while(lo < hi)\\n        {\\n            int mid = lo+(hi-lo)/2;\\n            \\n            long count =0L+ mid/a+mid/b+mid/c-mid/ab-mid/ac-mid/bc+mid/abc;\\n            \\n            if(count >=n){\\n                hi = mid;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2560728,
                "title": "java-binary-search-gcd-lcm-lots-of-long-varaibles",
                "content": "```java\\nclass Solution {\\n    private static final int PLACEHOLDER = 2_000_000_001;\\n    \\n    \\n    private int a;\\n    private int b;\\n    private int c;\\n    private long ab;\\n    private long ac;\\n    private long bc;\\n    private long abc;\\n    \\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        this.a = a;\\n        this.b = b;\\n        this.c = c;\\n        this.ab = lcm(a, b);\\n        this.ac = lcm(a, c);\\n        this.bc = lcm(b, c);\\n        this.abc = lcm(a, lcm(b, c));\\n        \\n        // System.out.println(ab);\\n        // System.out.println(ac);\\n        // System.out.println(bc);\\n        // System.out.println(abc);\\n        \\n        int left = 1;\\n        int right = 2_000_000_001;\\n        \\n        while(left < right) {\\n            int mid = left + (right - left) / 2;\\n            \\n            if(hasNUglyNumber(mid, n)) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n            \\n        }\\n        \\n        return left == PLACEHOLDER ? -1 : left;\\n    }\\n    \\n    private boolean hasNUglyNumber(long number, long n) {\\n        long count = number/a + number/b + number/c \\n            - number/ab - number/bc - number/ac \\n            + number/abc;\\n        \\n        // System.out.println(String.format(\"number=%d, count=%d\", number, count));\\n        \\n        return count >= n;\\n    }\\n    \\n    private long gcd(long a, long b) {\\n        if(b == 0) {\\n            return a;\\n        }\\n        \\n        return gcd(b, a%b);\\n    }\\n    \\n    private long lcm(long a, long b) {\\n        return ((long)a * (long)b) / gcd(a, b);\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    private static final int PLACEHOLDER = 2_000_000_001;\\n    \\n    \\n    private int a;\\n    private int b;\\n    private int c;\\n    private long ab;\\n    private long ac;\\n    private long bc;\\n    private long abc;\\n    \\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        this.a = a;\\n        this.b = b;\\n        this.c = c;\\n        this.ab = lcm(a, b);\\n        this.ac = lcm(a, c);\\n        this.bc = lcm(b, c);\\n        this.abc = lcm(a, lcm(b, c));\\n        \\n        // System.out.println(ab);\\n        // System.out.println(ac);\\n        // System.out.println(bc);\\n        // System.out.println(abc);\\n        \\n        int left = 1;\\n        int right = 2_000_000_001;\\n        \\n        while(left < right) {\\n            int mid = left + (right - left) / 2;\\n            \\n            if(hasNUglyNumber(mid, n)) {\\n                right = mid;\\n            } else {\\n                left = mid + 1;\\n            }\\n            \\n        }\\n        \\n        return left == PLACEHOLDER ? -1 : left;\\n    }\\n    \\n    private boolean hasNUglyNumber(long number, long n) {\\n        long count = number/a + number/b + number/c \\n            - number/ab - number/bc - number/ac \\n            + number/abc;\\n        \\n        // System.out.println(String.format(\"number=%d, count=%d\", number, count));\\n        \\n        return count >= n;\\n    }\\n    \\n    private long gcd(long a, long b) {\\n        if(b == 0) {\\n            return a;\\n        }\\n        \\n        return gcd(b, a%b);\\n    }\\n    \\n    private long lcm(long a, long b) {\\n        return ((long)a * (long)b) / gcd(a, b);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2514921,
                "title": "c-0ms-100-faster-solution-gcd-binarysearch",
                "content": "```\\n        int low=1, high = 2e9;\\n        long a=long(A), b=long(B), c=long(C);\\n        long ab=a*b/__gcd(a,b);\\n        long bc=b*c/__gcd(b,c);\\n        long ac=a*c/__gcd(a,c);\\n        long abc=a*bc/__gcd(a,bc);\\n        while(low<high)\\n        {\\n            int mid=low+(high-low)/2;\\n            int cnt=mid/a+mid/b+mid/c-mid/ab-mid/bc-mid/ac+mid/abc;\\n            if(cnt<n)\\n            {\\n                low=mid+1;\\n            }\\n            else\\n            {\\n                high=mid;\\n            }\\n        }\\n        return low;\\n```\\n![image](https://assets.leetcode.com/users/images/2751ba6e-a9d2-4f40-bf82-f560a35406db_1662049655.2491727.jpeg)\\n",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n        int low=1, high = 2e9;\\n        long a=long(A), b=long(B), c=long(C);\\n        long ab=a*b/__gcd(a,b);\\n        long bc=b*c/__gcd(b,c);\\n        long ac=a*c/__gcd(a,c);\\n        long abc=a*bc/__gcd(a,bc);\\n        while(low<high)\\n        {\\n            int mid=low+(high-low)/2;\\n            int cnt=mid/a+mid/b+mid/c-mid/ab-mid/bc-mid/ac+mid/abc;\\n            if(cnt<n)\\n            {\\n                low=mid+1;\\n            }\\n            else\\n            {\\n                high=mid;\\n            }\\n        }\\n        return low;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2480112,
                "title": "number-theory-binary-search",
                "content": "The key part in understanding the solution is to first understand how to calculate the total ugly numbers before a particular interger\\n\\nOnce that is done then we can binary search throgh 1 to 2e9 to find the answer\\n\\n```\\n#define ll long long\\n    ll func(ll a,ll b){\\n        ll pro=a*1ll*b;\\n        ll g=__gcd(a,b);\\n        pro=pro/g;\\n        return pro;}\\n    \\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int ans=-1;\\n        int l=1,r=2e9;\\n        while(l<=r){\\n            ll m=l+(r-l)/2;\\n            ll temp=m/a;\\n            temp+=(m/b);\\n            temp+=(m/c);\\n            int v1=(m/func(a,b));\\n            int v2=(m/func(b,c));\\n            int v3=(m/func(c,a));\\n            int v4=(m/func(a,func(b,c)));\\n            temp-=v1;\\n            temp-=v2;\\n            temp-=v3;\\n            temp+=v4;\\n            if(temp>=n){\\n                ans=m;\\n                r=m-1;}\\n            else\\n                l=m+1;\\n       }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\n#define ll long long\\n    ll func(ll a,ll b){\\n        ll pro=a*1ll*b;\\n        ll g=__gcd(a,b);\\n        pro=pro/g;\\n        return pro;}\\n    \\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int ans=-1;\\n        int l=1,r=2e9;\\n        while(l<=r){\\n            ll m=l+(r-l)/2;\\n            ll temp=m/a;\\n            temp+=(m/b);\\n            temp+=(m/c);\\n            int v1=(m/func(a,b));\\n            int v2=(m/func(b,c));\\n            int v3=(m/func(c,a));\\n            int v4=(m/func(a,func(b,c)));\\n            temp-=v1;\\n            temp-=v2;\\n            temp-=v3;\\n            temp+=v4;\\n            if(temp>=n){\\n                ans=m;\\n                r=m-1;}\\n            else\\n                l=m+1;\\n       }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2474587,
                "title": "binary-search-with-inclusion-and-exclusion-method",
                "content": "```\\nclass Solution {\\npublic:\\n    typedef long long int ll;\\n    ll gcd(ll a,ll b)\\n    {\\n        if(a==0)\\n            return b;\\n        \\n        return gcd(b%a,a);\\n    }\\n    ll lcm(ll a,ll b)\\n    {\\n        return (a*b)/gcd(a,b);\\n    }\\n    bool check(ll x, ll n,ll a,ll b,ll c)\\n    {\\n        // check how many ugly number is less than x \\n        // if count is greater than or equal to n return true otherwise return false;\\n        \\n        // n(aUbUc)=n(a)+n(b)+n(c)-n(a^b)-n(b^c)-n(c^a)+n(a^b^c) where ^ represent intersection\\n        \\n        ll n_a=(x/a);\\n        ll n_b=(x/b);\\n        ll n_c=(x/c);\\n        ll n_ab=(x/(lcm(a,b)));\\n        ll n_bc=(x/(lcm(b,c)));\\n        ll n_ca=(x/lcm(c,a));\\n        ll f=lcm(a,b);\\n        ll n_abc=(x/lcm(f,c));\\n        \\n        ll d=n_a+n_b+n_c-n_ab-n_bc-n_ca+n_abc;\\n        \\n        if(d>=n)\\n            return true;\\n        return false;\\n    }\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        ll start=1,end=2*1e9;\\n        ll ans=0;\\n        while(start<=end)\\n        {\\n            ll mid=(start+(end-start)/2);\\n            if(check(mid, n,a,b,c))\\n            {\\n                ans=mid;\\n                end=mid-1;\\n            }\\n            else\\n                start=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long int ll;\\n    ll gcd(ll a,ll b)\\n    {\\n        if(a==0)\\n            return b;\\n        \\n        return gcd(b%a,a);\\n    }\\n    ll lcm(ll a,ll b)\\n    {\\n        return (a*b)/gcd(a,b);\\n    }\\n    bool check(ll x, ll n,ll a,ll b,ll c)\\n    {\\n        // check how many ugly number is less than x \\n        // if count is greater than or equal to n return true otherwise return false;\\n        \\n        // n(aUbUc)=n(a)+n(b)+n(c)-n(a^b)-n(b^c)-n(c^a)+n(a^b^c) where ^ represent intersection\\n        \\n        ll n_a=(x/a);\\n        ll n_b=(x/b);\\n        ll n_c=(x/c);\\n        ll n_ab=(x/(lcm(a,b)));\\n        ll n_bc=(x/(lcm(b,c)));\\n        ll n_ca=(x/lcm(c,a));\\n        ll f=lcm(a,b);\\n        ll n_abc=(x/lcm(f,c));\\n        \\n        ll d=n_a+n_b+n_c-n_ab-n_bc-n_ca+n_abc;\\n        \\n        if(d>=n)\\n            return true;\\n        return false;\\n    }\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        ll start=1,end=2*1e9;\\n        ll ans=0;\\n        while(start<=end)\\n        {\\n            ll mid=(start+(end-start)/2);\\n            if(check(mid, n,a,b,c))\\n            {\\n                ans=mid;\\n                end=mid-1;\\n            }\\n            else\\n                start=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455629,
                "title": "c",
                "content": "(```)  class Solution {\\npublic:\\n    \\n    long lcm(long a, long b)\\n    {\\n        return (a*b) / __gcd(a,b);\\n    }\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        \\n        long low = 1, high = 2*1e9, mid, count,  ans;\\n        \\n        while(low <= high)\\n        {\\n             mid = low + (high -low)/2;\\n            \\n            count = 0;\\n            \\n            count += mid/a;\\n            count += mid/b;\\n            count += mid/c;\\n            \\n            count -= mid/ lcm(a,b);\\n            count -= mid / lcm(b,c);\\n            count -= mid / lcm(c,a);\\n            \\n            count += mid / lcm(a,lcm(b,c));\\n            \\n            if(count >= n)\\n            {\\n                high = mid-1;\\n                \\n                ans = mid;\\n            }\\n            else\\n            {\\n               low = mid+1; \\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    long lcm(long a, long b)\\n    {\\n        return (a*b) / __gcd(a,b);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2425821,
                "title": "python-simple-binary-search",
                "content": "\\n    def dfs(self, val, a, b, c):\\n        ab = a*b//math.gcd(a,b)\\n        bc = b*c//math.gcd(b,c)\\n        ca = c*a//math.gcd(c,a)\\n        abc = ab*c//math.gcd(ab,c)\\n        \\n        return val//a + val//b + val//c - val//ab - val//bc - val//ca + val//abc\\n        \\n    def nthUglyNumber(self, n, a, b, c):\\n        low, high = 1, 2*10**9\\n        \\n        while low <= high:\\n            mid = (low + high)//2\\n            \\n            if self.dfs(mid, a, b, c) >= n:\\n                high = mid - 1\\n            else:\\n                low = mid + 1\\n                \\n        return low",
                "solutionTags": [],
                "code": "\\n    def dfs(self, val, a, b, c):\\n        ab = a*b//math.gcd(a,b)\\n        bc = b*c//math.gcd(b,c)\\n        ca = c*a//math.gcd(c,a)\\n        abc = ab*c//math.gcd(ab,c)\\n        \\n        return val//a + val//b + val//c - val//ab - val//bc - val//ca + val//abc\\n        \\n    def nthUglyNumber(self, n, a, b, c):\\n        low, high = 1, 2*10**9\\n        \\n        while low <= high:\\n            mid = (low + high)//2\\n            \\n            if self.dfs(mid, a, b, c) >= n:\\n                high = mid - 1\\n            else:\\n                low = mid + 1\\n                \\n        return low",
                "codeTag": "Python3"
            },
            {
                "id": 2403282,
                "title": "c-binary-search-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int lo = 1;\\n        int hi = 2*(int)1e9;\\n        \\n        long A = long(a);\\n        long B = long(b);\\n        long C = long(c);\\n        \\n        long AB = A*B/__gcd(A,B);\\n        long BC = B*C/__gcd(B,C);\\n        long AC = A*C/__gcd(A,C);\\n        \\n        long ABC = A*BC/__gcd(A,BC);\\n        \\n        while(lo<hi) {\\n            int mid = lo + (hi - lo)/2;\\n            int cnt = mid/A + mid/B + mid/C - mid/AB - mid/BC - mid/AC + mid/ABC;\\n            if(cnt<n)\\n                lo = mid + 1;\\n            else\\n                hi = mid;\\n        }\\n        return lo;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int lo = 1;\\n        int hi = 2*(int)1e9;\\n        \\n        long A = long(a);\\n        long B = long(b);\\n        long C = long(c);\\n        \\n        long AB = A*B/__gcd(A,B);\\n        long BC = B*C/__gcd(B,C);\\n        long AC = A*C/__gcd(A,C);\\n        \\n        long ABC = A*BC/__gcd(A,BC);\\n        \\n        while(lo<hi) {\\n            int mid = lo + (hi - lo)/2;\\n            int cnt = mid/A + mid/B + mid/C - mid/AB - mid/BC - mid/AC + mid/ABC;\\n            if(cnt<n)\\n                lo = mid + 1;\\n            else\\n                hi = mid;\\n        }\\n        return lo;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2370064,
                "title": "simple-binary-search-solution-overflow-handled-java",
                "content": "```\\nclass Solution {\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        int low = 1, high =2*(int)1e9;\\n        \\n        int ab = lcm(a,b), bc = lcm(b,c), ca = lcm(c,a), abc = lcm(a,bc);\\n        \\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            \\n            int count = mid/a + mid/b + mid/c - mid/ab - mid/bc - mid/ca + mid/abc;\\n            if(count>=n){\\n                high = mid - 1;\\n            }\\n            else low = mid + 1;\\n        }\\n        return low;\\n    }\\n    private int lcm(int x,int y){\\n        int a = x, b = y; \\n        while(a!=0){\\n            int t = a;\\n            a = b%a;\\n            b = t;\\n        }\\n        return (int)(x*(y/(double)b));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int nthUglyNumber(int n, int a, int b, int c) {\\n        int low = 1, high =2*(int)1e9;\\n        \\n        int ab = lcm(a,b), bc = lcm(b,c), ca = lcm(c,a), abc = lcm(a,bc);\\n        \\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            \\n            int count = mid/a + mid/b + mid/c - mid/ab - mid/bc - mid/ca + mid/abc;\\n            if(count>=n){\\n                high = mid - 1;\\n            }\\n            else low = mid + 1;\\n        }\\n        return low;\\n    }\\n    private int lcm(int x,int y){\\n        int a = x, b = y; \\n        while(a!=0){\\n            int t = a;\\n            a = b%a;\\n            b = t;\\n        }\\n        return (int)(x*(y/(double)b));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2359321,
                "title": "intuitive-binary-search",
                "content": "```\\nclass Solution {\\n    \\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int cur = 0;\\n        \\n        auto lcm_ab = lcm<long long, long long>(a, b);\\n        auto lcm_ac = lcm<long long, long long>(a, c);\\n        auto lcm_bc = lcm<long long, long long>(b, c);\\n        auto lcm_abc = lcm<long long, long long>(lcm_ab, lcm_ac);\\n        \\n        long long l = 1;\\n        long long h = 2 * 1\\'000\\'000\\'001;\\n        \\n        int ans = 0;\\n        while (l <= h) {\\n            auto mid = (l + h) / 2;\\n            long long counter = mid / a + mid / b + mid / c - mid / lcm_ab - mid / lcm_bc - mid / lcm_ac + mid / lcm_abc;\\n            \\n            if (counter >= n) {\\n                h = mid - 1;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n        \\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    \\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int cur = 0;\\n        \\n        auto lcm_ab = lcm<long long, long long>(a, b);\\n        auto lcm_ac = lcm<long long, long long>(a, c);\\n        auto lcm_bc = lcm<long long, long long>(b, c);\\n        auto lcm_abc = lcm<long long, long long>(lcm_ab, lcm_ac);\\n        \\n        long long l = 1;\\n        long long h = 2 * 1\\'000\\'000\\'001;\\n        \\n        int ans = 0;\\n        while (l <= h) {\\n            auto mid = (l + h) / 2;\\n            long long counter = mid / a + mid / b + mid / c - mid / lcm_ab - mid / lcm_bc - mid / lcm_ac + mid / lcm_abc;\\n            \\n            if (counter >= n) {\\n                h = mid - 1;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n        \\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2235272,
                "title": "c-runtime-0-ms-faster-than-100-00-of-c-online-submissions-for-ugly",
                "content": "class Solution {\\npublic:\\n\\n    int nthUglyNumber(int n, int a1, int b1, int c1) {\\n        \\n    long long a=(long)a1;\\n    long long b=(long)b1;\\n    long long c=(long)c1;\\n    long long ab=a*b/__gcd(a,b);\\n    long long bc=b*c/__gcd(b,c);\\n    long long ac=a*c/__gcd(a,c);\\n    long long abc= a*bc/__gcd(a,bc);\\n    long long int l=min({a,b,c}),r=1e18+100;\\n        int ans =0;\\n        while(l<=r)\\n        {\\n            long long int mid=l+(r-l)/2;\\n            long long int count=mid/a+mid/b+mid/c-mid/ab-mid/bc-mid/ac+mid/abc;\\n            \\n           \\n            if(count>=n)\\n            {   ans =mid;\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        return ans ;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int nthUglyNumber(int n, int a1, int b1, int c1) {\\n        \\n    long long a=(long)a1;\\n    long long b=(long)b1;\\n    long long c=(long)c1;\\n    long long ab=a*b/__gcd(a,b);\\n    long long bc=b*c/__gcd(b,c);\\n    long long ac=a*c/__gcd(a,c);\\n    long long abc= a*bc/__gcd(a,bc);\\n    long long int l=min({a,b,c}",
                "codeTag": "Java"
            },
            {
                "id": 2178255,
                "title": "c-binary-search-with-inclusion-exclusion-principle",
                "content": "```\\n/* \\n    Time: O(log(n*min(a,b,c)))\\n    Space: O(1)\\n    Tag: Binary Search, Maths\\n    Difficulty: H\\n    Easier Version: https://leetcode.com/problems/nth-magical-number/\\n*/\\n\\nclass Solution {\\n    long long gcd(long long a, long long b) {\\n        return b == 0 ? a : gcd(b, a % b);\\n    }\\n\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        long long lo = 0, hi = n * min({a, b, c});\\n        long long mid = 0, ans = -1;\\n\\n        long long lcmABC = (((long long)a * b * c) * gcd(c, gcd(a, b))) / (gcd(a, b) * gcd(b, c) * gcd(c, a));\\n        long long lcmAB = (long long)a * b / gcd(a, b);\\n        long long lcmBC = (long long)b * c / gcd(b, c);\\n        long long lcmCA = (long long)c * a / gcd(c, a);\\n\\n        while (lo <= hi) {\\n            mid = lo + (hi - lo) / 2;\\n\\n            long long curPos = mid / a + mid / b + mid / c - mid / lcmAB - mid / lcmBC - mid / lcmCA + mid / lcmABC;\\n\\n            if (curPos < n)\\n                lo = mid + 1;\\n            else {\\n                ans = mid;\\n                hi = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Binary Tree"
                ],
                "code": "```\\n/* \\n    Time: O(log(n*min(a,b,c)))\\n    Space: O(1)\\n    Tag: Binary Search, Maths\\n    Difficulty: H\\n    Easier Version: https://leetcode.com/problems/nth-magical-number/\\n*/\\n\\nclass Solution {\\n    long long gcd(long long a, long long b) {\\n        return b == 0 ? a : gcd(b, a % b);\\n    }\\n\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        long long lo = 0, hi = n * min({a, b, c});\\n        long long mid = 0, ans = -1;\\n\\n        long long lcmABC = (((long long)a * b * c) * gcd(c, gcd(a, b))) / (gcd(a, b) * gcd(b, c) * gcd(c, a));\\n        long long lcmAB = (long long)a * b / gcd(a, b);\\n        long long lcmBC = (long long)b * c / gcd(b, c);\\n        long long lcmCA = (long long)c * a / gcd(c, a);\\n\\n        while (lo <= hi) {\\n            mid = lo + (hi - lo) / 2;\\n\\n            long long curPos = mid / a + mid / b + mid / c - mid / lcmAB - mid / lcmBC - mid / lcmCA + mid / lcmABC;\\n\\n            if (curPos < n)\\n                lo = mid + 1;\\n            else {\\n                ans = mid;\\n                hi = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2176900,
                "title": "java-solutions",
                "content": "class Solution {\\n    static long gcd(long a, long b) {\\n        if (a == 0)\\n            return b;\\n        return gcd(b % a, a);\\n    }\\n\\n     static long lcm(long a, long b) {\\n        return (a * b) / gcd(a, b);\\n    }\\n\\n   static long count(long a, long b, long c, long num) {\\n        return ((num / a) + (num / b) + (num / c)\\n                - (num / lcm(a, b))\\n                - (num / lcm(b, c))\\n                - (num / lcm(a, c))\\n                + (num / lcm(a, lcm(b, c))));\\n    }\\n      public static int nthUglyNumber(int n, int a, int b, int c) {\\n        int low = 1, high = Integer.MAX_VALUE; \\n        while (low < high) {\\n          int   mid = low + (high - low) / 2;\\n            if (count(a, b, c, mid) < n)\\n                low = mid + 1;\\n            else\\n                high = mid;\\n        }\\n        return low;\\n    }\\n}\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    static long gcd(long a, long b) {\\n        if (a == 0)\\n            return b;\\n        return gcd(b % a, a);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2130727,
                "title": "c-numbertheory-easy-binary-search",
                "content": "\\n    int nthUglyNumber(int n, int a1, int b1, int c1) {\\n        long long a=(long)a1;\\n        long long b=(long)b1;\\n        long long c=(long)c1;\\n        long long ab=a*b/__gcd(a,b);\\n        long long bc=b*c/__gcd(b,c);\\n        long long ac=a*c/__gcd(a,c);\\n        long long abc= a*bc/__gcd(a,bc);\\n        int lo=1,hi=2*(int)1e9;\\n        int mid=0;\\n        while(lo<hi){\\n            mid=(hi-lo)/2+lo;\\n            int count= mid/a+mid/b+mid/c-mid/ab-mid/bc-mid/ac+mid/abc;\\n            if(count<n){\\n                lo=mid+1;\\n            }else{\\n                hi=mid;\\n            }\\n        }\\n        return lo;\\n\\n",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "\\n    int nthUglyNumber(int n, int a1, int b1, int c1) {\\n        long long a=(long)a1;\\n        long long b=(long)b1;\\n        long long c=(long)c1;\\n        long long ab=a*b/__gcd(a,b);\\n        long long bc=b*c/__gcd(b,c);\\n        long long ac=a*c/__gcd(a,c);\\n        long long abc= a*bc/__gcd(a,bc);\\n        int lo=1,hi=2*(int)1e9;\\n        int mid=0;\\n        while(lo<hi){\\n            mid=(hi-lo)/2+lo;\\n            int count= mid/a+mid/b+mid/c-mid/ab-mid/bc-mid/ac+mid/abc;\\n            if(count<n){\\n                lo=mid+1;\\n            }else{\\n                hi=mid;\\n            }\\n        }\\n        return lo;\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2066381,
                "title": "c-binary-search-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int gcd(int a, int b){\\n        return b == 0 ? a : gcd(b, a % b);\\n    }\\n    \\n    long long lcm(int a, int b){\\n        return ((long long)a * b) / gcd(a, b);\\n    }\\n    \\n    long long getUglyCount(int n, int a, int b, int c){\\n        long long count = (long long)(n / a) + (n / b) + (n / c);\\n        count -= n / lcm(a, b);\\n        count -= n / lcm(b, c);\\n        count -= n / lcm(c, a);\\n        count += n / lcm(lcm(a, b), c);\\n        return count;\\n    }\\n    \\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int start = 1;\\n        int end = 2e9;\\n        int mid;\\n        \\n        while(start <= end){\\n            mid = start + (end - start) / 2;\\n            if(start == mid){\\n                if(getUglyCount(start, a, b, c) == n){\\n                    return start;\\n                }\\n                else if(getUglyCount(end, a, b, c) == n){\\n                    return end;\\n                }\\n                return -1;\\n            }\\n            else{\\n                if(getUglyCount(mid, a, b, c) >= n){\\n                    end = mid;\\n                }\\n                else{\\n                    start = mid;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int gcd(int a, int b){\\n        return b == 0 ? a : gcd(b, a % b);\\n    }\\n    \\n    long long lcm(int a, int b){\\n        return ((long long)a * b) / gcd(a, b);\\n    }\\n    \\n    long long getUglyCount(int n, int a, int b, int c){\\n        long long count = (long long)(n / a) + (n / b) + (n / c);\\n        count -= n / lcm(a, b);\\n        count -= n / lcm(b, c);\\n        count -= n / lcm(c, a);\\n        count += n / lcm(lcm(a, b), c);\\n        return count;\\n    }\\n    \\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int start = 1;\\n        int end = 2e9;\\n        int mid;\\n        \\n        while(start <= end){\\n            mid = start + (end - start) / 2;\\n            if(start == mid){\\n                if(getUglyCount(start, a, b, c) == n){\\n                    return start;\\n                }\\n                else if(getUglyCount(end, a, b, c) == n){\\n                    return end;\\n                }\\n                return -1;\\n            }\\n            else{\\n                if(getUglyCount(mid, a, b, c) >= n){\\n                    end = mid;\\n                }\\n                else{\\n                    start = mid;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1992848,
                "title": "binary-search-inclusion-exclusion-c",
                "content": "```\\n    int gcd(int a, int b) \\n    {\\n        if (a == 0) return b;\\n        if (b == 0) return a;\\n        return gcd(b%a, a);\\n    }\\n\\n    int64_t lcm(int a, int b)\\n    {\\n        return (int64_t) a * (b / gcd(a, b));\\n    }\\n    \\n    int check(int x, int a, int b, int c)\\n    {\\n        /* Count ugly numbers less than or equal to x using inclusion-exclusion */\\n        return (unsigned) x / a + x / b + x / c +\\n         - (x / lcm(a, b) + x / lcm(a, c) + x / lcm(b, c))\\n        + x / lcm(lcm(a, b), c);\\n    }\\n\\n    int nthUglyNumber(int n, int a, int b, int c) \\n    {\\n        int l = 1, r = INT_MAX;\\n        while (l < r) { /* use binary search to find the smalest value for which the count is n */\\n            int mid = l + (r - l) / 2;\\n            if (check(mid, a, b, c) >= n) \\n                r = mid;\\n            else l = mid + 1;\\n        }\\n        return l;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n    int gcd(int a, int b) \\n    {\\n        if (a == 0) return b;\\n        if (b == 0) return a;\\n        return gcd(b%a, a);\\n    }\\n\\n    int64_t lcm(int a, int b)\\n    {\\n        return (int64_t) a * (b / gcd(a, b));\\n    }\\n    \\n    int check(int x, int a, int b, int c)\\n    {\\n        /* Count ugly numbers less than or equal to x using inclusion-exclusion */\\n        return (unsigned) x / a + x / b + x / c +\\n         - (x / lcm(a, b) + x / lcm(a, c) + x / lcm(b, c))\\n        + x / lcm(lcm(a, b), c);\\n    }\\n\\n    int nthUglyNumber(int n, int a, int b, int c) \\n    {\\n        int l = 1, r = INT_MAX;\\n        while (l < r) { /* use binary search to find the smalest value for which the count is n */\\n            int mid = l + (r - l) / 2;\\n            if (check(mid, a, b, c) >= n) \\n                r = mid;\\n            else l = mid + 1;\\n        }\\n        return l;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1980247,
                "title": "c-binary-search-inclusion-exclusion-principle",
                "content": "```\\n// NOTE: be careful on places where will overflow int\\n\\ntypedef long long LL;\\n\\nclass Solution {\\n    LL lcm(int a, int b)\\n    {\\n        return (LL)a * b / gcd(a, b);\\n    }\\n    int check(int x, int a, int b, int c, int n)\\n    {\\n        LL cnt = (LL)x / a + x / b + x / c;\\n        cnt -= (x / lcm(a, b) + x / lcm(a, c) + x / lcm(b, c));\\n        cnt += x / lcm(lcm(a, b), c);\\n        return cnt >= n;\\n    }\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int l = 1, r = 2e9;\\n        while (l < r)\\n        {\\n            int mid = l + (r - l) / 2;\\n            if (check(mid, a, b, c, n)) r = mid;\\n            else l = mid + 1;\\n        }\\n        return l;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n// NOTE: be careful on places where will overflow int\\n\\ntypedef long long LL;\\n\\nclass Solution {\\n    LL lcm(int a, int b)\\n    {\\n        return (LL)a * b / gcd(a, b);\\n    }\\n    int check(int x, int a, int b, int c, int n)\\n    {\\n        LL cnt = (LL)x / a + x / b + x / c;\\n        cnt -= (x / lcm(a, b) + x / lcm(a, c) + x / lcm(b, c));\\n        cnt += x / lcm(lcm(a, b), c);\\n        return cnt >= n;\\n    }\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int l = 1, r = 2e9;\\n        while (l < r)\\n        {\\n            int mid = l + (r - l) / 2;\\n            if (check(mid, a, b, c, n)) r = mid;\\n            else l = mid + 1;\\n        }\\n        return l;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918861,
                "title": "binary-search-100-faster-c-principle-of-inclusion-exclusion",
                "content": "```\\nclass Solution {\\n\\n    long lcm(long a, long b) {\\n        if (a==0 or b==0)\\n            return 0;\\n        return a*b/__gcd(a, b);\\n    }\\n    \\n    long count(long a, long b, long c, long x) {\\n        long divs = x/a+x/b+x/c;\\n        divs -= ( x/lcm(a, b) + x/lcm(b, c) + x/lcm(c, a) );\\n        divs += ( x/lcm(a, lcm(b, c)) );\\n    return divs;\\n    }    \\n    \\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        long l = 1;\\n        long r = INT_MAX;\\n        long ans=-1;\\n        while(l<=r) {\\n            long m = (l+r)/2;\\n            if (count((long)a, (long)b, (long)c, m)>=n) {\\n                ans=m;\\n                r=m-1;\\n            } else l=m+1;\\n        }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n\\n    long lcm(long a, long b) {\\n        if (a==0 or b==0)\\n            return 0;\\n        return a*b/__gcd(a, b);\\n    }\\n    \\n    long count(long a, long b, long c, long x) {\\n        long divs = x/a+x/b+x/c;\\n        divs -= ( x/lcm(a, b) + x/lcm(b, c) + x/lcm(c, a) );\\n        divs += ( x/lcm(a, lcm(b, c)) );\\n    return divs;\\n    }    \\n    \\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        long l = 1;\\n        long r = INT_MAX;\\n        long ans=-1;\\n        while(l<=r) {\\n            long m = (l+r)/2;\\n            if (count((long)a, (long)b, (long)c, m)>=n) {\\n                ans=m;\\n                r=m-1;\\n            } else l=m+1;\\n        }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1710035,
                "title": "100-binary-search",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tlong  lcm(long a,long b){\\n\\t\\t\\treturn a*b/__gcd(a,b);\\n\\t\\t}\\n\\t\\tint nthUglyNumber(int n, int a, int b, int c) {\\n\\n\\t\\t\\tlong  l=min({a,b,c}),r=long(n)*max({a,b,c});\\n\\n\\t\\t\\tlong lcmab=lcm(a,b),lcmac=lcm(a,c),lcmbc=lcm(b,c),lcmabc=lcm(a,lcmbc);\\n\\n\\t\\t\\twhile(l<r){\\n\\t\\t\\t\\tlong mid=(r+l)/2;\\n\\t\\t\\t\\tlong t=mid/a+mid/b+mid/c;\\n\\t\\t\\t\\tt=t-mid/lcmab-mid/lcmac-mid/lcmbc+mid/lcmabc;\\n\\t\\t\\t\\tif(t<n)l=mid+1;\\n\\t\\t\\t\\telse r=mid;\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\treturn r;\\n\\t\\t}\\n\\n\\t};\\n",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tlong  lcm(long a,long b){\\n\\t\\t\\treturn a*b/__gcd(a,b);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1706361,
                "title": "c-binary-search-o-log-2000000000-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        long long l=1,r=2000000000;\\n        long long p1=(long long)a*b;\\n        long long p2=(long long)c*b;\\n        long long p3=(long long)a*c;\\n        int x=p1/__gcd(a,b);\\n        long long p4=(long long)x*c;\\n        long long y=p2/__gcd(b,c);\\n        long long z=p3/__gcd(c,a);\\n        long long lcm=p4/__gcd(x,c);\\n        while(l<=r){\\n            long long mid=l+(r-l)/2;\\n            long long cnt=(mid/a)+(mid/b)+(mid/c)-(mid/x)-(mid/y)-(mid/z)+(mid/lcm);\\n            if(cnt==n and (mid%a==0 or mid%b==0 or mid%c==0)){\\n                return mid;\\n            }\\n            \\n            if(cnt>=n){\\n                r=mid-1;\\n            }else{\\n                l=mid+1;\\n            }\\n            \\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        long long l=1,r=2000000000;\\n        long long p1=(long long)a*b;\\n        long long p2=(long long)c*b;\\n        long long p3=(long long)a*c;\\n        int x=p1/__gcd(a,b);\\n        long long p4=(long long)x*c;\\n        long long y=p2/__gcd(b,c);\\n        long long z=p3/__gcd(c,a);\\n        long long lcm=p4/__gcd(x,c);\\n        while(l<=r){\\n            long long mid=l+(r-l)/2;\\n            long long cnt=(mid/a)+(mid/b)+(mid/c)-(mid/x)-(mid/y)-(mid/z)+(mid/lcm);\\n            if(cnt==n and (mid%a==0 or mid%b==0 or mid%c==0)){\\n                return mid;\\n            }\\n            \\n            if(cnt>=n){\\n                r=mid-1;\\n            }else{\\n                l=mid+1;\\n            }\\n            \\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1686494,
                "title": "c-binary-search-100-faster",
                "content": "```\\n//count of N elements in the set AUBUC\\n    //F(N) = a + b + c - a \\u2229 c - a \\u2229 b - b \\u2229 c + a \\u2229 b \\u2229 c\\n    long long lcm(long long a, long long b) \\n    {\\n        return a*b / __gcd(a, b);\\n    }\\n    \\n    int nthUglyNumber(int N, int A, int B, int C) \\n    {\\n        long long lo = 1, hi = 2000000000, mid, ans;\\n        \\n        while(lo <= hi)\\n        {\\n            mid = lo + (hi - lo)/2;\\n            long long ctr = 0;\\n            ctr += mid/A;\\n            ctr += mid/B;\\n            ctr += mid/C;\\n            ctr -= mid / lcm(A, B);\\n            ctr -= mid / lcm(B, C);\\n            ctr -= mid / lcm(C, A);\\n            ctr += mid / lcm(A, lcm(B, C));\\n            \\n            if(ctr >= N)\\n            {\\n                ans = mid;\\n                hi = mid-1;\\n            }\\n            else\\n                lo = mid+1;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n//count of N elements in the set AUBUC\\n    //F(N) = a + b + c - a \\u2229 c - a \\u2229 b - b \\u2229 c + a \\u2229 b \\u2229 c\\n    long long lcm(long long a, long long b) \\n    {\\n        return a*b / __gcd(a, b);\\n    }\\n    \\n    int nthUglyNumber(int N, int A, int B, int C) \\n    {\\n        long long lo = 1, hi = 2000000000, mid, ans;\\n        \\n        while(lo <= hi)\\n        {\\n            mid = lo + (hi - lo)/2;\\n            long long ctr = 0;\\n            ctr += mid/A;\\n            ctr += mid/B;\\n            ctr += mid/C;\\n            ctr -= mid / lcm(A, B);\\n            ctr -= mid / lcm(B, C);\\n            ctr -= mid / lcm(C, A);\\n            ctr += mid / lcm(A, lcm(B, C));\\n            \\n            if(ctr >= N)\\n            {\\n                ans = mid;\\n                hi = mid-1;\\n            }\\n            else\\n                lo = mid+1;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1628737,
                "title": "c-solution-using-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    using ll=long long;\\n    ll lcm(ll a,ll b)\\n    {\\n        return (a*b)/(__gcd(a,b));\\n    }\\n    ll find(ll a,ll b,ll c,ll mid)\\n    {\\n        ll x1=(mid/a)+(mid/b)+(mid/c);\\n        return x1-(mid/lcm(a,b))-(mid/lcm(b,c))-(mid/lcm(a,c))+(mid/lcm(a,lcm(b,c)));\\n    }\\n    int nthUglyNumber(int n, int a, int b, int c) \\n    {\\n        ll l=min({a,b,c});\\n        ll r=1e18+1000;\\n        ll ans=0;\\n        while(l<=r)\\n        {\\n            ll mid=l+(r-l)/2;\\n            if(find(a,b,c,mid)<n)\\n            {\\n                l=mid+1;\\n            }\\n            else\\n            {\\n                ans=mid;\\n                r=mid-1;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using ll=long long;\\n    ll lcm(ll a,ll b)\\n    {\\n        return (a*b)/(__gcd(a,b));\\n    }\\n    ll find(ll a,ll b,ll c,ll mid)\\n    {\\n        ll x1=(mid/a)+(mid/b)+(mid/c);\\n        return x1-(mid/lcm(a,b))-(mid/lcm(b,c))-(mid/lcm(a,c))+(mid/lcm(a,lcm(b,c)));\\n    }\\n    int nthUglyNumber(int n, int a, int b, int c) \\n    {\\n        ll l=min({a,b,c});\\n        ll r=1e18+1000;\\n        ll ans=0;\\n        while(l<=r)\\n        {\\n            ll mid=l+(r-l)/2;\\n            if(find(a,b,c,mid)<n)\\n            {\\n                l=mid+1;\\n            }\\n            else\\n            {\\n                ans=mid;\\n                r=mid-1;\\n            }\\n        }\\n        return (int)ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1622869,
                "title": "binary-search-0ms-c",
                "content": "```\\nclass Solution {\\npublic:\\n    // Binary Search on the answer\\n    long long LCM(long long x, long long y){\\n        return (1LL * x * y ) / __gcd(x, y);\\n    }\\n    \\n    long long check(long long n, long long a, long long b, long long c, long long upper){\\n        \\n        long long count = (upper / a) + (upper / b) + (upper / c);\\n        count -= (upper / LCM(a,b)); // intersection of a and b (-)\\n        count -= (upper / LCM(a,c)); // intersection of a and c (-)\\n        count -= (upper / LCM(b,c)); // intersection of b and c (-)\\n        count += (upper/LCM(a, LCM(b,c))); // intersection of a, b and c (+)\\n        \\n        return count >= n;\\n    }\\n    \\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        \\n        long long l = 1LL * min({a, b, c}) , r = 1LL * max({a , b , c}) * n;\\n        long long ans = 0;\\n\\n        while(l <= r){\\n            long long upper = l + (r - l) / 2;\\n            \\n            if(check(n,a,b,c,upper)){\\n                ans = upper;\\n                r = upper - 1;\\n            }\\n            else{\\n                l = upper + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Binary Search on the answer\\n    long long LCM(long long x, long long y){\\n        return (1LL * x * y ) / __gcd(x, y);\\n    }\\n    \\n    long long check(long long n, long long a, long long b, long long c, long long upper){\\n        \\n        long long count = (upper / a) + (upper / b) + (upper / c);\\n        count -= (upper / LCM(a,b)); // intersection of a and b (-)\\n        count -= (upper / LCM(a,c)); // intersection of a and c (-)\\n        count -= (upper / LCM(b,c)); // intersection of b and c (-)\\n        count += (upper/LCM(a, LCM(b,c))); // intersection of a, b and c (+)\\n        \\n        return count >= n;\\n    }\\n    \\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        \\n        long long l = 1LL * min({a, b, c}) , r = 1LL * max({a , b , c}) * n;\\n        long long ans = 0;\\n\\n        while(l <= r){\\n            long long upper = l + (r - l) / 2;\\n            \\n            if(check(n,a,b,c,upper)){\\n                ans = upper;\\n                r = upper - 1;\\n            }\\n            else{\\n                l = upper + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1585931,
                "title": "straightforward-approach-takes-0-ms-faster-than-100-00-of-c-submissions",
                "content": "I implemented just a simple cycle: we enumerate all the ugly numbers until we reach the n-th. And this algortithm works pretty fast (takes 0ms) and uses O(1) space.\\n\\nBut of course the idea to use binary search is very smart and should be used.\\n\\n```\\nclass Solution {\\n    typedef long long ll;\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        ll u = 1;\\n        ll A = a;\\n        ll B = b;\\n        ll C = c;\\n        ll i = 0;    \\n        while (i < n) {\\n            ll delta;\\n            ll D = min(B, C) - A;\\n            ll E = min(A, C) - B;\\n            ll F = min(A, B) - C;\\n            if (D >= 0) {\\n                delta = min(D / a, n - i - 1);\\n                u = A + a * delta;\\n                A = u + a;\\n            } else if (E >= 0) {\\n                delta = min(E / b, n - i - 1);\\n                u = B + b * delta;\\n                B = u + b;\\n            } else {\\n                delta = min(F / c, n - i - 1);\\n                u = C + c * delta;\\n                C = u + c;\\n            }\\n            i += delta + 1;\\n            \\n            if (u == A) {\\n                A += a;\\n            }\\n            if (u == B) {\\n                B += b;\\n            }\\n            if (u == C) {\\n                C += c;\\n            }\\n        }\\n        \\n        return u; \\n    } \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    typedef long long ll;\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        ll u = 1;\\n        ll A = a;\\n        ll B = b;\\n        ll C = c;\\n        ll i = 0;    \\n        while (i < n) {\\n            ll delta;\\n            ll D = min(B, C) - A;\\n            ll E = min(A, C) - B;\\n            ll F = min(A, B) - C;\\n            if (D >= 0) {\\n                delta = min(D / a, n - i - 1);\\n                u = A + a * delta;\\n                A = u + a;\\n            } else if (E >= 0) {\\n                delta = min(E / b, n - i - 1);\\n                u = B + b * delta;\\n                B = u + b;\\n            } else {\\n                delta = min(F / c, n - i - 1);\\n                u = C + c * delta;\\n                C = u + c;\\n            }\\n            i += delta + 1;\\n            \\n            if (u == A) {\\n                A += a;\\n            }\\n            if (u == B) {\\n                B += b;\\n            }\\n            if (u == C) {\\n                C += c;\\n            }\\n        }\\n        \\n        return u; \\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1545883,
                "title": "c-1201-ugly-number-iii",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        // inclusion-exclusion principle\\n        long ab = (long) a/gcd(a, b)*b, bc = (long) b/gcd(b, c)*c, ca = (long) c/gcd(c, a)*a, abc = (long) ab/gcd(ab, c)*c; \\n        int lo = 0, hi = n*min({a, b, c});\\n        while (lo < hi) {\\n            int mid = lo + (hi - lo)/2; \\n            if (mid/a + mid/b + mid/c - mid/ab - mid/bc - mid/ca + mid/abc < n) lo = mid + 1; \\n            else hi = mid; \\n        }\\n        return lo; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        // inclusion-exclusion principle\\n        long ab = (long) a/gcd(a, b)*b, bc = (long) b/gcd(b, c)*c, ca = (long) c/gcd(c, a)*a, abc = (long) ab/gcd(ab, c)*c; \\n        int lo = 0, hi = n*min({a, b, c});\\n        while (lo < hi) {\\n            int mid = lo + (hi - lo)/2; \\n            if (mid/a + mid/b + mid/c - mid/ab - mid/bc - mid/ca + mid/abc < n) lo = mid + 1; \\n            else hi = mid; \\n        }\\n        return lo; \\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1943203,
                "content": [
                    {
                        "username": "Mrinal2100",
                        "content": "This was a really ugly problem"
                    },
                    {
                        "username": "gaur",
                        "content": "How is it guaranteed that the value found throught binary search would be divisible by one of a, b or c?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Proof by contradiction. Suppose we found minimal value `x`, satisfying the search condition \"count of all ugly numbers less than or equal to `x` is at least `n`\". Let's assume that `x` is divisible by neither `a`, `b`, nor `c`. Than it is not an ugly number, and therefore `x-1` has the same amount of `n` ugly numbers less than or equal to it. But our basic presumption from the outset was that `x` is the minimal value satisfying this condition. Contradiction! That means the opposite of assumption is true: `x` is divisible by either `a`, `b`, or `c` and is an ugly number."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Yes.. We cannot ensure that.. But we can count how many ugly numbers would be there less than or equal to that num(on which you are doing binary Search)"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "We need to keep a check, whenever we get the count equal to n, then we have to check whether the mid is divisible by either a,b,orc if yes return else reduce high.\\n\\nMY code : \\n```\\nclass Solution {\\n    long countOFUglyNumber(int num,int A,int B,int C)\\n    {  \\n        long a = long(A),b = long(B),c = long(C);\\n        long total = (num/a + num/b + num/c);\\n        long ab = (a*b)/__gcd(a,b);\\n        long bc = (b*c)/__gcd(b,c);\\n        long ca = (a*c)/__gcd(a,c);\\n        long abc = (a*bc)/__gcd(a,bc);\\n        long common = (num/ab + num/bc + num/ca);\\n        return total - common + num/abc;\\n    };\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int low = 1, high = 2*1e9;\\n        while(low <= high)\\n        {\\n            int mid = low + (high-low)/2;\\n            int count = countOFUglyNumber(mid,a,b,c);\\n            if(count == n)\\n            {  \\n                if(mid%a == 0 || mid%b == 0 || mid%c == 0)\\n                    return mid;\\n                high = mid-1;\\n            }\\n            count < n ? low = mid+1 : high = mid-1;\\n        }\\n        return 0;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Andrew_2018_11",
                        "content": "For the test case:\\n1000000000\\n2\\n217983653\\n336916467\\n\\nThe expected answer is 1999999984\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320660.png)\\n\\n\\nBut for test case\\n1000000000\\n217983653\\n336916467\\n2\\n\\nThe expected answer is 1999999982\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320669.png)\\n\\nIs this a bug??? I am confused.\\n"
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "Use long long for everything including the lcm."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I guess they might have corrected it..\\nBecause it\\'s coming 1999999984 in both cases now.."
                    },
                    {
                        "username": "hegupta",
                        "content": "It\\'s not obvious what to conduct binary search over, then it\\'s not obvious what quantity to compute for the current candidate so that you can decide whether to go left or right, and finally it\\'s not obvious how to do the computation efficiently. The acceptance rate seems to agree."
                    },
                    {
                        "username": "starkovss",
                        "content": "input is  **n**= 5 \\nNUMBERS ARE : **a**= 2 , **b**=11, **c**=13\\nThey expect to see 10. HOW ?\\nThe sequence should be \\n2 4 8 11 **13** ( not 10 ! )\\nHow you can get **10** from any combination of that numbers ?\\n"
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "2,4,6,8,**10**\\n\\nhence 10?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "is a multiple of any of these numbers !"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "why example 3 has 10 as ugly number but example 2 does not have 10?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Why is Binary Search preferred here over the method of using 3 priority queues as in Ugly Number 2"
                    },
                    {
                        "username": "code__HARD",
                        "content": "as the constrinants are high"
                    },
                    {
                        "username": "moatasem9626",
                        "content": "very stubbed question, with the int limits"
                    },
                    {
                        "username": "Pmparekh2000",
                        "content": "Wrong test case is\\n5\\n2\\n11\\n13\\nHere the expected ans is 10 and I am getting 13. How can 10 come with prime factors 2,11,13. My series for this test case is 2,4,8,11,13,.... Please help :)"
                    },
                    {
                        "username": "SEVENx2",
                        "content": "The series would be 2,4,6,8,10,11,13..."
                    },
                    {
                        "username": "pygh55",
                        "content": "10\\n2\\n3\\n5\\n\\nwhy the answer is 14 not 15?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@KautsIITD](/KautsIITD) You missed 4"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "2,3,5,6,8,9,10,12,14,15\\n14 would be 9th ugly number here.."
                    }
                ]
            },
            {
                "id": 1568216,
                "content": [
                    {
                        "username": "Mrinal2100",
                        "content": "This was a really ugly problem"
                    },
                    {
                        "username": "gaur",
                        "content": "How is it guaranteed that the value found throught binary search would be divisible by one of a, b or c?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Proof by contradiction. Suppose we found minimal value `x`, satisfying the search condition \"count of all ugly numbers less than or equal to `x` is at least `n`\". Let's assume that `x` is divisible by neither `a`, `b`, nor `c`. Than it is not an ugly number, and therefore `x-1` has the same amount of `n` ugly numbers less than or equal to it. But our basic presumption from the outset was that `x` is the minimal value satisfying this condition. Contradiction! That means the opposite of assumption is true: `x` is divisible by either `a`, `b`, or `c` and is an ugly number."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Yes.. We cannot ensure that.. But we can count how many ugly numbers would be there less than or equal to that num(on which you are doing binary Search)"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "We need to keep a check, whenever we get the count equal to n, then we have to check whether the mid is divisible by either a,b,orc if yes return else reduce high.\\n\\nMY code : \\n```\\nclass Solution {\\n    long countOFUglyNumber(int num,int A,int B,int C)\\n    {  \\n        long a = long(A),b = long(B),c = long(C);\\n        long total = (num/a + num/b + num/c);\\n        long ab = (a*b)/__gcd(a,b);\\n        long bc = (b*c)/__gcd(b,c);\\n        long ca = (a*c)/__gcd(a,c);\\n        long abc = (a*bc)/__gcd(a,bc);\\n        long common = (num/ab + num/bc + num/ca);\\n        return total - common + num/abc;\\n    };\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int low = 1, high = 2*1e9;\\n        while(low <= high)\\n        {\\n            int mid = low + (high-low)/2;\\n            int count = countOFUglyNumber(mid,a,b,c);\\n            if(count == n)\\n            {  \\n                if(mid%a == 0 || mid%b == 0 || mid%c == 0)\\n                    return mid;\\n                high = mid-1;\\n            }\\n            count < n ? low = mid+1 : high = mid-1;\\n        }\\n        return 0;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Andrew_2018_11",
                        "content": "For the test case:\\n1000000000\\n2\\n217983653\\n336916467\\n\\nThe expected answer is 1999999984\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320660.png)\\n\\n\\nBut for test case\\n1000000000\\n217983653\\n336916467\\n2\\n\\nThe expected answer is 1999999982\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320669.png)\\n\\nIs this a bug??? I am confused.\\n"
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "Use long long for everything including the lcm."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I guess they might have corrected it..\\nBecause it\\'s coming 1999999984 in both cases now.."
                    },
                    {
                        "username": "hegupta",
                        "content": "It\\'s not obvious what to conduct binary search over, then it\\'s not obvious what quantity to compute for the current candidate so that you can decide whether to go left or right, and finally it\\'s not obvious how to do the computation efficiently. The acceptance rate seems to agree."
                    },
                    {
                        "username": "starkovss",
                        "content": "input is  **n**= 5 \\nNUMBERS ARE : **a**= 2 , **b**=11, **c**=13\\nThey expect to see 10. HOW ?\\nThe sequence should be \\n2 4 8 11 **13** ( not 10 ! )\\nHow you can get **10** from any combination of that numbers ?\\n"
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "2,4,6,8,**10**\\n\\nhence 10?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "is a multiple of any of these numbers !"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "why example 3 has 10 as ugly number but example 2 does not have 10?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Why is Binary Search preferred here over the method of using 3 priority queues as in Ugly Number 2"
                    },
                    {
                        "username": "code__HARD",
                        "content": "as the constrinants are high"
                    },
                    {
                        "username": "moatasem9626",
                        "content": "very stubbed question, with the int limits"
                    },
                    {
                        "username": "Pmparekh2000",
                        "content": "Wrong test case is\\n5\\n2\\n11\\n13\\nHere the expected ans is 10 and I am getting 13. How can 10 come with prime factors 2,11,13. My series for this test case is 2,4,8,11,13,.... Please help :)"
                    },
                    {
                        "username": "SEVENx2",
                        "content": "The series would be 2,4,6,8,10,11,13..."
                    },
                    {
                        "username": "pygh55",
                        "content": "10\\n2\\n3\\n5\\n\\nwhy the answer is 14 not 15?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@KautsIITD](/KautsIITD) You missed 4"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "2,3,5,6,8,9,10,12,14,15\\n14 would be 9th ugly number here.."
                    }
                ]
            },
            {
                "id": 1573075,
                "content": [
                    {
                        "username": "Mrinal2100",
                        "content": "This was a really ugly problem"
                    },
                    {
                        "username": "gaur",
                        "content": "How is it guaranteed that the value found throught binary search would be divisible by one of a, b or c?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Proof by contradiction. Suppose we found minimal value `x`, satisfying the search condition \"count of all ugly numbers less than or equal to `x` is at least `n`\". Let's assume that `x` is divisible by neither `a`, `b`, nor `c`. Than it is not an ugly number, and therefore `x-1` has the same amount of `n` ugly numbers less than or equal to it. But our basic presumption from the outset was that `x` is the minimal value satisfying this condition. Contradiction! That means the opposite of assumption is true: `x` is divisible by either `a`, `b`, or `c` and is an ugly number."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Yes.. We cannot ensure that.. But we can count how many ugly numbers would be there less than or equal to that num(on which you are doing binary Search)"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "We need to keep a check, whenever we get the count equal to n, then we have to check whether the mid is divisible by either a,b,orc if yes return else reduce high.\\n\\nMY code : \\n```\\nclass Solution {\\n    long countOFUglyNumber(int num,int A,int B,int C)\\n    {  \\n        long a = long(A),b = long(B),c = long(C);\\n        long total = (num/a + num/b + num/c);\\n        long ab = (a*b)/__gcd(a,b);\\n        long bc = (b*c)/__gcd(b,c);\\n        long ca = (a*c)/__gcd(a,c);\\n        long abc = (a*bc)/__gcd(a,bc);\\n        long common = (num/ab + num/bc + num/ca);\\n        return total - common + num/abc;\\n    };\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int low = 1, high = 2*1e9;\\n        while(low <= high)\\n        {\\n            int mid = low + (high-low)/2;\\n            int count = countOFUglyNumber(mid,a,b,c);\\n            if(count == n)\\n            {  \\n                if(mid%a == 0 || mid%b == 0 || mid%c == 0)\\n                    return mid;\\n                high = mid-1;\\n            }\\n            count < n ? low = mid+1 : high = mid-1;\\n        }\\n        return 0;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Andrew_2018_11",
                        "content": "For the test case:\\n1000000000\\n2\\n217983653\\n336916467\\n\\nThe expected answer is 1999999984\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320660.png)\\n\\n\\nBut for test case\\n1000000000\\n217983653\\n336916467\\n2\\n\\nThe expected answer is 1999999982\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320669.png)\\n\\nIs this a bug??? I am confused.\\n"
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "Use long long for everything including the lcm."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I guess they might have corrected it..\\nBecause it\\'s coming 1999999984 in both cases now.."
                    },
                    {
                        "username": "hegupta",
                        "content": "It\\'s not obvious what to conduct binary search over, then it\\'s not obvious what quantity to compute for the current candidate so that you can decide whether to go left or right, and finally it\\'s not obvious how to do the computation efficiently. The acceptance rate seems to agree."
                    },
                    {
                        "username": "starkovss",
                        "content": "input is  **n**= 5 \\nNUMBERS ARE : **a**= 2 , **b**=11, **c**=13\\nThey expect to see 10. HOW ?\\nThe sequence should be \\n2 4 8 11 **13** ( not 10 ! )\\nHow you can get **10** from any combination of that numbers ?\\n"
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "2,4,6,8,**10**\\n\\nhence 10?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "is a multiple of any of these numbers !"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "why example 3 has 10 as ugly number but example 2 does not have 10?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Why is Binary Search preferred here over the method of using 3 priority queues as in Ugly Number 2"
                    },
                    {
                        "username": "code__HARD",
                        "content": "as the constrinants are high"
                    },
                    {
                        "username": "moatasem9626",
                        "content": "very stubbed question, with the int limits"
                    },
                    {
                        "username": "Pmparekh2000",
                        "content": "Wrong test case is\\n5\\n2\\n11\\n13\\nHere the expected ans is 10 and I am getting 13. How can 10 come with prime factors 2,11,13. My series for this test case is 2,4,8,11,13,.... Please help :)"
                    },
                    {
                        "username": "SEVENx2",
                        "content": "The series would be 2,4,6,8,10,11,13..."
                    },
                    {
                        "username": "pygh55",
                        "content": "10\\n2\\n3\\n5\\n\\nwhy the answer is 14 not 15?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@KautsIITD](/KautsIITD) You missed 4"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "2,3,5,6,8,9,10,12,14,15\\n14 would be 9th ugly number here.."
                    }
                ]
            },
            {
                "id": 1573034,
                "content": [
                    {
                        "username": "Mrinal2100",
                        "content": "This was a really ugly problem"
                    },
                    {
                        "username": "gaur",
                        "content": "How is it guaranteed that the value found throught binary search would be divisible by one of a, b or c?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Proof by contradiction. Suppose we found minimal value `x`, satisfying the search condition \"count of all ugly numbers less than or equal to `x` is at least `n`\". Let's assume that `x` is divisible by neither `a`, `b`, nor `c`. Than it is not an ugly number, and therefore `x-1` has the same amount of `n` ugly numbers less than or equal to it. But our basic presumption from the outset was that `x` is the minimal value satisfying this condition. Contradiction! That means the opposite of assumption is true: `x` is divisible by either `a`, `b`, or `c` and is an ugly number."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Yes.. We cannot ensure that.. But we can count how many ugly numbers would be there less than or equal to that num(on which you are doing binary Search)"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "We need to keep a check, whenever we get the count equal to n, then we have to check whether the mid is divisible by either a,b,orc if yes return else reduce high.\\n\\nMY code : \\n```\\nclass Solution {\\n    long countOFUglyNumber(int num,int A,int B,int C)\\n    {  \\n        long a = long(A),b = long(B),c = long(C);\\n        long total = (num/a + num/b + num/c);\\n        long ab = (a*b)/__gcd(a,b);\\n        long bc = (b*c)/__gcd(b,c);\\n        long ca = (a*c)/__gcd(a,c);\\n        long abc = (a*bc)/__gcd(a,bc);\\n        long common = (num/ab + num/bc + num/ca);\\n        return total - common + num/abc;\\n    };\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int low = 1, high = 2*1e9;\\n        while(low <= high)\\n        {\\n            int mid = low + (high-low)/2;\\n            int count = countOFUglyNumber(mid,a,b,c);\\n            if(count == n)\\n            {  \\n                if(mid%a == 0 || mid%b == 0 || mid%c == 0)\\n                    return mid;\\n                high = mid-1;\\n            }\\n            count < n ? low = mid+1 : high = mid-1;\\n        }\\n        return 0;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Andrew_2018_11",
                        "content": "For the test case:\\n1000000000\\n2\\n217983653\\n336916467\\n\\nThe expected answer is 1999999984\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320660.png)\\n\\n\\nBut for test case\\n1000000000\\n217983653\\n336916467\\n2\\n\\nThe expected answer is 1999999982\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320669.png)\\n\\nIs this a bug??? I am confused.\\n"
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "Use long long for everything including the lcm."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I guess they might have corrected it..\\nBecause it\\'s coming 1999999984 in both cases now.."
                    },
                    {
                        "username": "hegupta",
                        "content": "It\\'s not obvious what to conduct binary search over, then it\\'s not obvious what quantity to compute for the current candidate so that you can decide whether to go left or right, and finally it\\'s not obvious how to do the computation efficiently. The acceptance rate seems to agree."
                    },
                    {
                        "username": "starkovss",
                        "content": "input is  **n**= 5 \\nNUMBERS ARE : **a**= 2 , **b**=11, **c**=13\\nThey expect to see 10. HOW ?\\nThe sequence should be \\n2 4 8 11 **13** ( not 10 ! )\\nHow you can get **10** from any combination of that numbers ?\\n"
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "2,4,6,8,**10**\\n\\nhence 10?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "is a multiple of any of these numbers !"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "why example 3 has 10 as ugly number but example 2 does not have 10?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Why is Binary Search preferred here over the method of using 3 priority queues as in Ugly Number 2"
                    },
                    {
                        "username": "code__HARD",
                        "content": "as the constrinants are high"
                    },
                    {
                        "username": "moatasem9626",
                        "content": "very stubbed question, with the int limits"
                    },
                    {
                        "username": "Pmparekh2000",
                        "content": "Wrong test case is\\n5\\n2\\n11\\n13\\nHere the expected ans is 10 and I am getting 13. How can 10 come with prime factors 2,11,13. My series for this test case is 2,4,8,11,13,.... Please help :)"
                    },
                    {
                        "username": "SEVENx2",
                        "content": "The series would be 2,4,6,8,10,11,13..."
                    },
                    {
                        "username": "pygh55",
                        "content": "10\\n2\\n3\\n5\\n\\nwhy the answer is 14 not 15?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@KautsIITD](/KautsIITD) You missed 4"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "2,3,5,6,8,9,10,12,14,15\\n14 would be 9th ugly number here.."
                    }
                ]
            },
            {
                "id": 1569764,
                "content": [
                    {
                        "username": "Mrinal2100",
                        "content": "This was a really ugly problem"
                    },
                    {
                        "username": "gaur",
                        "content": "How is it guaranteed that the value found throught binary search would be divisible by one of a, b or c?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Proof by contradiction. Suppose we found minimal value `x`, satisfying the search condition \"count of all ugly numbers less than or equal to `x` is at least `n`\". Let's assume that `x` is divisible by neither `a`, `b`, nor `c`. Than it is not an ugly number, and therefore `x-1` has the same amount of `n` ugly numbers less than or equal to it. But our basic presumption from the outset was that `x` is the minimal value satisfying this condition. Contradiction! That means the opposite of assumption is true: `x` is divisible by either `a`, `b`, or `c` and is an ugly number."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Yes.. We cannot ensure that.. But we can count how many ugly numbers would be there less than or equal to that num(on which you are doing binary Search)"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "We need to keep a check, whenever we get the count equal to n, then we have to check whether the mid is divisible by either a,b,orc if yes return else reduce high.\\n\\nMY code : \\n```\\nclass Solution {\\n    long countOFUglyNumber(int num,int A,int B,int C)\\n    {  \\n        long a = long(A),b = long(B),c = long(C);\\n        long total = (num/a + num/b + num/c);\\n        long ab = (a*b)/__gcd(a,b);\\n        long bc = (b*c)/__gcd(b,c);\\n        long ca = (a*c)/__gcd(a,c);\\n        long abc = (a*bc)/__gcd(a,bc);\\n        long common = (num/ab + num/bc + num/ca);\\n        return total - common + num/abc;\\n    };\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int low = 1, high = 2*1e9;\\n        while(low <= high)\\n        {\\n            int mid = low + (high-low)/2;\\n            int count = countOFUglyNumber(mid,a,b,c);\\n            if(count == n)\\n            {  \\n                if(mid%a == 0 || mid%b == 0 || mid%c == 0)\\n                    return mid;\\n                high = mid-1;\\n            }\\n            count < n ? low = mid+1 : high = mid-1;\\n        }\\n        return 0;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Andrew_2018_11",
                        "content": "For the test case:\\n1000000000\\n2\\n217983653\\n336916467\\n\\nThe expected answer is 1999999984\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320660.png)\\n\\n\\nBut for test case\\n1000000000\\n217983653\\n336916467\\n2\\n\\nThe expected answer is 1999999982\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320669.png)\\n\\nIs this a bug??? I am confused.\\n"
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "Use long long for everything including the lcm."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I guess they might have corrected it..\\nBecause it\\'s coming 1999999984 in both cases now.."
                    },
                    {
                        "username": "hegupta",
                        "content": "It\\'s not obvious what to conduct binary search over, then it\\'s not obvious what quantity to compute for the current candidate so that you can decide whether to go left or right, and finally it\\'s not obvious how to do the computation efficiently. The acceptance rate seems to agree."
                    },
                    {
                        "username": "starkovss",
                        "content": "input is  **n**= 5 \\nNUMBERS ARE : **a**= 2 , **b**=11, **c**=13\\nThey expect to see 10. HOW ?\\nThe sequence should be \\n2 4 8 11 **13** ( not 10 ! )\\nHow you can get **10** from any combination of that numbers ?\\n"
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "2,4,6,8,**10**\\n\\nhence 10?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "is a multiple of any of these numbers !"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "why example 3 has 10 as ugly number but example 2 does not have 10?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Why is Binary Search preferred here over the method of using 3 priority queues as in Ugly Number 2"
                    },
                    {
                        "username": "code__HARD",
                        "content": "as the constrinants are high"
                    },
                    {
                        "username": "moatasem9626",
                        "content": "very stubbed question, with the int limits"
                    },
                    {
                        "username": "Pmparekh2000",
                        "content": "Wrong test case is\\n5\\n2\\n11\\n13\\nHere the expected ans is 10 and I am getting 13. How can 10 come with prime factors 2,11,13. My series for this test case is 2,4,8,11,13,.... Please help :)"
                    },
                    {
                        "username": "SEVENx2",
                        "content": "The series would be 2,4,6,8,10,11,13..."
                    },
                    {
                        "username": "pygh55",
                        "content": "10\\n2\\n3\\n5\\n\\nwhy the answer is 14 not 15?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@KautsIITD](/KautsIITD) You missed 4"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "2,3,5,6,8,9,10,12,14,15\\n14 would be 9th ugly number here.."
                    }
                ]
            },
            {
                "id": 1569635,
                "content": [
                    {
                        "username": "Mrinal2100",
                        "content": "This was a really ugly problem"
                    },
                    {
                        "username": "gaur",
                        "content": "How is it guaranteed that the value found throught binary search would be divisible by one of a, b or c?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Proof by contradiction. Suppose we found minimal value `x`, satisfying the search condition \"count of all ugly numbers less than or equal to `x` is at least `n`\". Let's assume that `x` is divisible by neither `a`, `b`, nor `c`. Than it is not an ugly number, and therefore `x-1` has the same amount of `n` ugly numbers less than or equal to it. But our basic presumption from the outset was that `x` is the minimal value satisfying this condition. Contradiction! That means the opposite of assumption is true: `x` is divisible by either `a`, `b`, or `c` and is an ugly number."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Yes.. We cannot ensure that.. But we can count how many ugly numbers would be there less than or equal to that num(on which you are doing binary Search)"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "We need to keep a check, whenever we get the count equal to n, then we have to check whether the mid is divisible by either a,b,orc if yes return else reduce high.\\n\\nMY code : \\n```\\nclass Solution {\\n    long countOFUglyNumber(int num,int A,int B,int C)\\n    {  \\n        long a = long(A),b = long(B),c = long(C);\\n        long total = (num/a + num/b + num/c);\\n        long ab = (a*b)/__gcd(a,b);\\n        long bc = (b*c)/__gcd(b,c);\\n        long ca = (a*c)/__gcd(a,c);\\n        long abc = (a*bc)/__gcd(a,bc);\\n        long common = (num/ab + num/bc + num/ca);\\n        return total - common + num/abc;\\n    };\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int low = 1, high = 2*1e9;\\n        while(low <= high)\\n        {\\n            int mid = low + (high-low)/2;\\n            int count = countOFUglyNumber(mid,a,b,c);\\n            if(count == n)\\n            {  \\n                if(mid%a == 0 || mid%b == 0 || mid%c == 0)\\n                    return mid;\\n                high = mid-1;\\n            }\\n            count < n ? low = mid+1 : high = mid-1;\\n        }\\n        return 0;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Andrew_2018_11",
                        "content": "For the test case:\\n1000000000\\n2\\n217983653\\n336916467\\n\\nThe expected answer is 1999999984\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320660.png)\\n\\n\\nBut for test case\\n1000000000\\n217983653\\n336916467\\n2\\n\\nThe expected answer is 1999999982\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320669.png)\\n\\nIs this a bug??? I am confused.\\n"
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "Use long long for everything including the lcm."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I guess they might have corrected it..\\nBecause it\\'s coming 1999999984 in both cases now.."
                    },
                    {
                        "username": "hegupta",
                        "content": "It\\'s not obvious what to conduct binary search over, then it\\'s not obvious what quantity to compute for the current candidate so that you can decide whether to go left or right, and finally it\\'s not obvious how to do the computation efficiently. The acceptance rate seems to agree."
                    },
                    {
                        "username": "starkovss",
                        "content": "input is  **n**= 5 \\nNUMBERS ARE : **a**= 2 , **b**=11, **c**=13\\nThey expect to see 10. HOW ?\\nThe sequence should be \\n2 4 8 11 **13** ( not 10 ! )\\nHow you can get **10** from any combination of that numbers ?\\n"
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "2,4,6,8,**10**\\n\\nhence 10?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "is a multiple of any of these numbers !"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "why example 3 has 10 as ugly number but example 2 does not have 10?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Why is Binary Search preferred here over the method of using 3 priority queues as in Ugly Number 2"
                    },
                    {
                        "username": "code__HARD",
                        "content": "as the constrinants are high"
                    },
                    {
                        "username": "moatasem9626",
                        "content": "very stubbed question, with the int limits"
                    },
                    {
                        "username": "Pmparekh2000",
                        "content": "Wrong test case is\\n5\\n2\\n11\\n13\\nHere the expected ans is 10 and I am getting 13. How can 10 come with prime factors 2,11,13. My series for this test case is 2,4,8,11,13,.... Please help :)"
                    },
                    {
                        "username": "SEVENx2",
                        "content": "The series would be 2,4,6,8,10,11,13..."
                    },
                    {
                        "username": "pygh55",
                        "content": "10\\n2\\n3\\n5\\n\\nwhy the answer is 14 not 15?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@KautsIITD](/KautsIITD) You missed 4"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "2,3,5,6,8,9,10,12,14,15\\n14 would be 9th ugly number here.."
                    }
                ]
            },
            {
                "id": 1860364,
                "content": [
                    {
                        "username": "Mrinal2100",
                        "content": "This was a really ugly problem"
                    },
                    {
                        "username": "gaur",
                        "content": "How is it guaranteed that the value found throught binary search would be divisible by one of a, b or c?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Proof by contradiction. Suppose we found minimal value `x`, satisfying the search condition \"count of all ugly numbers less than or equal to `x` is at least `n`\". Let's assume that `x` is divisible by neither `a`, `b`, nor `c`. Than it is not an ugly number, and therefore `x-1` has the same amount of `n` ugly numbers less than or equal to it. But our basic presumption from the outset was that `x` is the minimal value satisfying this condition. Contradiction! That means the opposite of assumption is true: `x` is divisible by either `a`, `b`, or `c` and is an ugly number."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Yes.. We cannot ensure that.. But we can count how many ugly numbers would be there less than or equal to that num(on which you are doing binary Search)"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "We need to keep a check, whenever we get the count equal to n, then we have to check whether the mid is divisible by either a,b,orc if yes return else reduce high.\\n\\nMY code : \\n```\\nclass Solution {\\n    long countOFUglyNumber(int num,int A,int B,int C)\\n    {  \\n        long a = long(A),b = long(B),c = long(C);\\n        long total = (num/a + num/b + num/c);\\n        long ab = (a*b)/__gcd(a,b);\\n        long bc = (b*c)/__gcd(b,c);\\n        long ca = (a*c)/__gcd(a,c);\\n        long abc = (a*bc)/__gcd(a,bc);\\n        long common = (num/ab + num/bc + num/ca);\\n        return total - common + num/abc;\\n    };\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int low = 1, high = 2*1e9;\\n        while(low <= high)\\n        {\\n            int mid = low + (high-low)/2;\\n            int count = countOFUglyNumber(mid,a,b,c);\\n            if(count == n)\\n            {  \\n                if(mid%a == 0 || mid%b == 0 || mid%c == 0)\\n                    return mid;\\n                high = mid-1;\\n            }\\n            count < n ? low = mid+1 : high = mid-1;\\n        }\\n        return 0;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Andrew_2018_11",
                        "content": "For the test case:\\n1000000000\\n2\\n217983653\\n336916467\\n\\nThe expected answer is 1999999984\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320660.png)\\n\\n\\nBut for test case\\n1000000000\\n217983653\\n336916467\\n2\\n\\nThe expected answer is 1999999982\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320669.png)\\n\\nIs this a bug??? I am confused.\\n"
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "Use long long for everything including the lcm."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I guess they might have corrected it..\\nBecause it\\'s coming 1999999984 in both cases now.."
                    },
                    {
                        "username": "hegupta",
                        "content": "It\\'s not obvious what to conduct binary search over, then it\\'s not obvious what quantity to compute for the current candidate so that you can decide whether to go left or right, and finally it\\'s not obvious how to do the computation efficiently. The acceptance rate seems to agree."
                    },
                    {
                        "username": "starkovss",
                        "content": "input is  **n**= 5 \\nNUMBERS ARE : **a**= 2 , **b**=11, **c**=13\\nThey expect to see 10. HOW ?\\nThe sequence should be \\n2 4 8 11 **13** ( not 10 ! )\\nHow you can get **10** from any combination of that numbers ?\\n"
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "2,4,6,8,**10**\\n\\nhence 10?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "is a multiple of any of these numbers !"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "why example 3 has 10 as ugly number but example 2 does not have 10?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Why is Binary Search preferred here over the method of using 3 priority queues as in Ugly Number 2"
                    },
                    {
                        "username": "code__HARD",
                        "content": "as the constrinants are high"
                    },
                    {
                        "username": "moatasem9626",
                        "content": "very stubbed question, with the int limits"
                    },
                    {
                        "username": "Pmparekh2000",
                        "content": "Wrong test case is\\n5\\n2\\n11\\n13\\nHere the expected ans is 10 and I am getting 13. How can 10 come with prime factors 2,11,13. My series for this test case is 2,4,8,11,13,.... Please help :)"
                    },
                    {
                        "username": "SEVENx2",
                        "content": "The series would be 2,4,6,8,10,11,13..."
                    },
                    {
                        "username": "pygh55",
                        "content": "10\\n2\\n3\\n5\\n\\nwhy the answer is 14 not 15?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@KautsIITD](/KautsIITD) You missed 4"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "2,3,5,6,8,9,10,12,14,15\\n14 would be 9th ugly number here.."
                    }
                ]
            },
            {
                "id": 1717190,
                "content": [
                    {
                        "username": "Mrinal2100",
                        "content": "This was a really ugly problem"
                    },
                    {
                        "username": "gaur",
                        "content": "How is it guaranteed that the value found throught binary search would be divisible by one of a, b or c?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Proof by contradiction. Suppose we found minimal value `x`, satisfying the search condition \"count of all ugly numbers less than or equal to `x` is at least `n`\". Let's assume that `x` is divisible by neither `a`, `b`, nor `c`. Than it is not an ugly number, and therefore `x-1` has the same amount of `n` ugly numbers less than or equal to it. But our basic presumption from the outset was that `x` is the minimal value satisfying this condition. Contradiction! That means the opposite of assumption is true: `x` is divisible by either `a`, `b`, or `c` and is an ugly number."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Yes.. We cannot ensure that.. But we can count how many ugly numbers would be there less than or equal to that num(on which you are doing binary Search)"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "We need to keep a check, whenever we get the count equal to n, then we have to check whether the mid is divisible by either a,b,orc if yes return else reduce high.\\n\\nMY code : \\n```\\nclass Solution {\\n    long countOFUglyNumber(int num,int A,int B,int C)\\n    {  \\n        long a = long(A),b = long(B),c = long(C);\\n        long total = (num/a + num/b + num/c);\\n        long ab = (a*b)/__gcd(a,b);\\n        long bc = (b*c)/__gcd(b,c);\\n        long ca = (a*c)/__gcd(a,c);\\n        long abc = (a*bc)/__gcd(a,bc);\\n        long common = (num/ab + num/bc + num/ca);\\n        return total - common + num/abc;\\n    };\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int low = 1, high = 2*1e9;\\n        while(low <= high)\\n        {\\n            int mid = low + (high-low)/2;\\n            int count = countOFUglyNumber(mid,a,b,c);\\n            if(count == n)\\n            {  \\n                if(mid%a == 0 || mid%b == 0 || mid%c == 0)\\n                    return mid;\\n                high = mid-1;\\n            }\\n            count < n ? low = mid+1 : high = mid-1;\\n        }\\n        return 0;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Andrew_2018_11",
                        "content": "For the test case:\\n1000000000\\n2\\n217983653\\n336916467\\n\\nThe expected answer is 1999999984\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320660.png)\\n\\n\\nBut for test case\\n1000000000\\n217983653\\n336916467\\n2\\n\\nThe expected answer is 1999999982\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320669.png)\\n\\nIs this a bug??? I am confused.\\n"
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "Use long long for everything including the lcm."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I guess they might have corrected it..\\nBecause it\\'s coming 1999999984 in both cases now.."
                    },
                    {
                        "username": "hegupta",
                        "content": "It\\'s not obvious what to conduct binary search over, then it\\'s not obvious what quantity to compute for the current candidate so that you can decide whether to go left or right, and finally it\\'s not obvious how to do the computation efficiently. The acceptance rate seems to agree."
                    },
                    {
                        "username": "starkovss",
                        "content": "input is  **n**= 5 \\nNUMBERS ARE : **a**= 2 , **b**=11, **c**=13\\nThey expect to see 10. HOW ?\\nThe sequence should be \\n2 4 8 11 **13** ( not 10 ! )\\nHow you can get **10** from any combination of that numbers ?\\n"
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "2,4,6,8,**10**\\n\\nhence 10?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "is a multiple of any of these numbers !"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "why example 3 has 10 as ugly number but example 2 does not have 10?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Why is Binary Search preferred here over the method of using 3 priority queues as in Ugly Number 2"
                    },
                    {
                        "username": "code__HARD",
                        "content": "as the constrinants are high"
                    },
                    {
                        "username": "moatasem9626",
                        "content": "very stubbed question, with the int limits"
                    },
                    {
                        "username": "Pmparekh2000",
                        "content": "Wrong test case is\\n5\\n2\\n11\\n13\\nHere the expected ans is 10 and I am getting 13. How can 10 come with prime factors 2,11,13. My series for this test case is 2,4,8,11,13,.... Please help :)"
                    },
                    {
                        "username": "SEVENx2",
                        "content": "The series would be 2,4,6,8,10,11,13..."
                    },
                    {
                        "username": "pygh55",
                        "content": "10\\n2\\n3\\n5\\n\\nwhy the answer is 14 not 15?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@KautsIITD](/KautsIITD) You missed 4"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "2,3,5,6,8,9,10,12,14,15\\n14 would be 9th ugly number here.."
                    }
                ]
            },
            {
                "id": 1574746,
                "content": [
                    {
                        "username": "Mrinal2100",
                        "content": "This was a really ugly problem"
                    },
                    {
                        "username": "gaur",
                        "content": "How is it guaranteed that the value found throught binary search would be divisible by one of a, b or c?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Proof by contradiction. Suppose we found minimal value `x`, satisfying the search condition \"count of all ugly numbers less than or equal to `x` is at least `n`\". Let's assume that `x` is divisible by neither `a`, `b`, nor `c`. Than it is not an ugly number, and therefore `x-1` has the same amount of `n` ugly numbers less than or equal to it. But our basic presumption from the outset was that `x` is the minimal value satisfying this condition. Contradiction! That means the opposite of assumption is true: `x` is divisible by either `a`, `b`, or `c` and is an ugly number."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Yes.. We cannot ensure that.. But we can count how many ugly numbers would be there less than or equal to that num(on which you are doing binary Search)"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "We need to keep a check, whenever we get the count equal to n, then we have to check whether the mid is divisible by either a,b,orc if yes return else reduce high.\\n\\nMY code : \\n```\\nclass Solution {\\n    long countOFUglyNumber(int num,int A,int B,int C)\\n    {  \\n        long a = long(A),b = long(B),c = long(C);\\n        long total = (num/a + num/b + num/c);\\n        long ab = (a*b)/__gcd(a,b);\\n        long bc = (b*c)/__gcd(b,c);\\n        long ca = (a*c)/__gcd(a,c);\\n        long abc = (a*bc)/__gcd(a,bc);\\n        long common = (num/ab + num/bc + num/ca);\\n        return total - common + num/abc;\\n    };\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int low = 1, high = 2*1e9;\\n        while(low <= high)\\n        {\\n            int mid = low + (high-low)/2;\\n            int count = countOFUglyNumber(mid,a,b,c);\\n            if(count == n)\\n            {  \\n                if(mid%a == 0 || mid%b == 0 || mid%c == 0)\\n                    return mid;\\n                high = mid-1;\\n            }\\n            count < n ? low = mid+1 : high = mid-1;\\n        }\\n        return 0;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Andrew_2018_11",
                        "content": "For the test case:\\n1000000000\\n2\\n217983653\\n336916467\\n\\nThe expected answer is 1999999984\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320660.png)\\n\\n\\nBut for test case\\n1000000000\\n217983653\\n336916467\\n2\\n\\nThe expected answer is 1999999982\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320669.png)\\n\\nIs this a bug??? I am confused.\\n"
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "Use long long for everything including the lcm."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I guess they might have corrected it..\\nBecause it\\'s coming 1999999984 in both cases now.."
                    },
                    {
                        "username": "hegupta",
                        "content": "It\\'s not obvious what to conduct binary search over, then it\\'s not obvious what quantity to compute for the current candidate so that you can decide whether to go left or right, and finally it\\'s not obvious how to do the computation efficiently. The acceptance rate seems to agree."
                    },
                    {
                        "username": "starkovss",
                        "content": "input is  **n**= 5 \\nNUMBERS ARE : **a**= 2 , **b**=11, **c**=13\\nThey expect to see 10. HOW ?\\nThe sequence should be \\n2 4 8 11 **13** ( not 10 ! )\\nHow you can get **10** from any combination of that numbers ?\\n"
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "2,4,6,8,**10**\\n\\nhence 10?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "is a multiple of any of these numbers !"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "why example 3 has 10 as ugly number but example 2 does not have 10?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Why is Binary Search preferred here over the method of using 3 priority queues as in Ugly Number 2"
                    },
                    {
                        "username": "code__HARD",
                        "content": "as the constrinants are high"
                    },
                    {
                        "username": "moatasem9626",
                        "content": "very stubbed question, with the int limits"
                    },
                    {
                        "username": "Pmparekh2000",
                        "content": "Wrong test case is\\n5\\n2\\n11\\n13\\nHere the expected ans is 10 and I am getting 13. How can 10 come with prime factors 2,11,13. My series for this test case is 2,4,8,11,13,.... Please help :)"
                    },
                    {
                        "username": "SEVENx2",
                        "content": "The series would be 2,4,6,8,10,11,13..."
                    },
                    {
                        "username": "pygh55",
                        "content": "10\\n2\\n3\\n5\\n\\nwhy the answer is 14 not 15?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@KautsIITD](/KautsIITD) You missed 4"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "2,3,5,6,8,9,10,12,14,15\\n14 would be 9th ugly number here.."
                    }
                ]
            },
            {
                "id": 1574559,
                "content": [
                    {
                        "username": "Mrinal2100",
                        "content": "This was a really ugly problem"
                    },
                    {
                        "username": "gaur",
                        "content": "How is it guaranteed that the value found throught binary search would be divisible by one of a, b or c?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Proof by contradiction. Suppose we found minimal value `x`, satisfying the search condition \"count of all ugly numbers less than or equal to `x` is at least `n`\". Let's assume that `x` is divisible by neither `a`, `b`, nor `c`. Than it is not an ugly number, and therefore `x-1` has the same amount of `n` ugly numbers less than or equal to it. But our basic presumption from the outset was that `x` is the minimal value satisfying this condition. Contradiction! That means the opposite of assumption is true: `x` is divisible by either `a`, `b`, or `c` and is an ugly number."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Yes.. We cannot ensure that.. But we can count how many ugly numbers would be there less than or equal to that num(on which you are doing binary Search)"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "We need to keep a check, whenever we get the count equal to n, then we have to check whether the mid is divisible by either a,b,orc if yes return else reduce high.\\n\\nMY code : \\n```\\nclass Solution {\\n    long countOFUglyNumber(int num,int A,int B,int C)\\n    {  \\n        long a = long(A),b = long(B),c = long(C);\\n        long total = (num/a + num/b + num/c);\\n        long ab = (a*b)/__gcd(a,b);\\n        long bc = (b*c)/__gcd(b,c);\\n        long ca = (a*c)/__gcd(a,c);\\n        long abc = (a*bc)/__gcd(a,bc);\\n        long common = (num/ab + num/bc + num/ca);\\n        return total - common + num/abc;\\n    };\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int low = 1, high = 2*1e9;\\n        while(low <= high)\\n        {\\n            int mid = low + (high-low)/2;\\n            int count = countOFUglyNumber(mid,a,b,c);\\n            if(count == n)\\n            {  \\n                if(mid%a == 0 || mid%b == 0 || mid%c == 0)\\n                    return mid;\\n                high = mid-1;\\n            }\\n            count < n ? low = mid+1 : high = mid-1;\\n        }\\n        return 0;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Andrew_2018_11",
                        "content": "For the test case:\\n1000000000\\n2\\n217983653\\n336916467\\n\\nThe expected answer is 1999999984\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320660.png)\\n\\n\\nBut for test case\\n1000000000\\n217983653\\n336916467\\n2\\n\\nThe expected answer is 1999999982\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320669.png)\\n\\nIs this a bug??? I am confused.\\n"
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "Use long long for everything including the lcm."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I guess they might have corrected it..\\nBecause it\\'s coming 1999999984 in both cases now.."
                    },
                    {
                        "username": "hegupta",
                        "content": "It\\'s not obvious what to conduct binary search over, then it\\'s not obvious what quantity to compute for the current candidate so that you can decide whether to go left or right, and finally it\\'s not obvious how to do the computation efficiently. The acceptance rate seems to agree."
                    },
                    {
                        "username": "starkovss",
                        "content": "input is  **n**= 5 \\nNUMBERS ARE : **a**= 2 , **b**=11, **c**=13\\nThey expect to see 10. HOW ?\\nThe sequence should be \\n2 4 8 11 **13** ( not 10 ! )\\nHow you can get **10** from any combination of that numbers ?\\n"
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "2,4,6,8,**10**\\n\\nhence 10?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "is a multiple of any of these numbers !"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "why example 3 has 10 as ugly number but example 2 does not have 10?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Why is Binary Search preferred here over the method of using 3 priority queues as in Ugly Number 2"
                    },
                    {
                        "username": "code__HARD",
                        "content": "as the constrinants are high"
                    },
                    {
                        "username": "moatasem9626",
                        "content": "very stubbed question, with the int limits"
                    },
                    {
                        "username": "Pmparekh2000",
                        "content": "Wrong test case is\\n5\\n2\\n11\\n13\\nHere the expected ans is 10 and I am getting 13. How can 10 come with prime factors 2,11,13. My series for this test case is 2,4,8,11,13,.... Please help :)"
                    },
                    {
                        "username": "SEVENx2",
                        "content": "The series would be 2,4,6,8,10,11,13..."
                    },
                    {
                        "username": "pygh55",
                        "content": "10\\n2\\n3\\n5\\n\\nwhy the answer is 14 not 15?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@KautsIITD](/KautsIITD) You missed 4"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "2,3,5,6,8,9,10,12,14,15\\n14 would be 9th ugly number here.."
                    }
                ]
            },
            {
                "id": 1943203,
                "content": [
                    {
                        "username": "Mrinal2100",
                        "content": "This was a really ugly problem"
                    },
                    {
                        "username": "gaur",
                        "content": "How is it guaranteed that the value found throught binary search would be divisible by one of a, b or c?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Proof by contradiction. Suppose we found minimal value `x`, satisfying the search condition \"count of all ugly numbers less than or equal to `x` is at least `n`\". Let's assume that `x` is divisible by neither `a`, `b`, nor `c`. Than it is not an ugly number, and therefore `x-1` has the same amount of `n` ugly numbers less than or equal to it. But our basic presumption from the outset was that `x` is the minimal value satisfying this condition. Contradiction! That means the opposite of assumption is true: `x` is divisible by either `a`, `b`, or `c` and is an ugly number."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Yes.. We cannot ensure that.. But we can count how many ugly numbers would be there less than or equal to that num(on which you are doing binary Search)"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "We need to keep a check, whenever we get the count equal to n, then we have to check whether the mid is divisible by either a,b,orc if yes return else reduce high.\\n\\nMY code : \\n```\\nclass Solution {\\n    long countOFUglyNumber(int num,int A,int B,int C)\\n    {  \\n        long a = long(A),b = long(B),c = long(C);\\n        long total = (num/a + num/b + num/c);\\n        long ab = (a*b)/__gcd(a,b);\\n        long bc = (b*c)/__gcd(b,c);\\n        long ca = (a*c)/__gcd(a,c);\\n        long abc = (a*bc)/__gcd(a,bc);\\n        long common = (num/ab + num/bc + num/ca);\\n        return total - common + num/abc;\\n    };\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int low = 1, high = 2*1e9;\\n        while(low <= high)\\n        {\\n            int mid = low + (high-low)/2;\\n            int count = countOFUglyNumber(mid,a,b,c);\\n            if(count == n)\\n            {  \\n                if(mid%a == 0 || mid%b == 0 || mid%c == 0)\\n                    return mid;\\n                high = mid-1;\\n            }\\n            count < n ? low = mid+1 : high = mid-1;\\n        }\\n        return 0;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Andrew_2018_11",
                        "content": "For the test case:\\n1000000000\\n2\\n217983653\\n336916467\\n\\nThe expected answer is 1999999984\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320660.png)\\n\\n\\nBut for test case\\n1000000000\\n217983653\\n336916467\\n2\\n\\nThe expected answer is 1999999982\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320669.png)\\n\\nIs this a bug??? I am confused.\\n"
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "Use long long for everything including the lcm."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I guess they might have corrected it..\\nBecause it\\'s coming 1999999984 in both cases now.."
                    },
                    {
                        "username": "hegupta",
                        "content": "It\\'s not obvious what to conduct binary search over, then it\\'s not obvious what quantity to compute for the current candidate so that you can decide whether to go left or right, and finally it\\'s not obvious how to do the computation efficiently. The acceptance rate seems to agree."
                    },
                    {
                        "username": "starkovss",
                        "content": "input is  **n**= 5 \\nNUMBERS ARE : **a**= 2 , **b**=11, **c**=13\\nThey expect to see 10. HOW ?\\nThe sequence should be \\n2 4 8 11 **13** ( not 10 ! )\\nHow you can get **10** from any combination of that numbers ?\\n"
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "2,4,6,8,**10**\\n\\nhence 10?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "is a multiple of any of these numbers !"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "why example 3 has 10 as ugly number but example 2 does not have 10?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Why is Binary Search preferred here over the method of using 3 priority queues as in Ugly Number 2"
                    },
                    {
                        "username": "code__HARD",
                        "content": "as the constrinants are high"
                    },
                    {
                        "username": "moatasem9626",
                        "content": "very stubbed question, with the int limits"
                    },
                    {
                        "username": "Pmparekh2000",
                        "content": "Wrong test case is\\n5\\n2\\n11\\n13\\nHere the expected ans is 10 and I am getting 13. How can 10 come with prime factors 2,11,13. My series for this test case is 2,4,8,11,13,.... Please help :)"
                    },
                    {
                        "username": "SEVENx2",
                        "content": "The series would be 2,4,6,8,10,11,13..."
                    },
                    {
                        "username": "pygh55",
                        "content": "10\\n2\\n3\\n5\\n\\nwhy the answer is 14 not 15?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@KautsIITD](/KautsIITD) You missed 4"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "2,3,5,6,8,9,10,12,14,15\\n14 would be 9th ugly number here.."
                    }
                ]
            },
            {
                "id": 1568216,
                "content": [
                    {
                        "username": "Mrinal2100",
                        "content": "This was a really ugly problem"
                    },
                    {
                        "username": "gaur",
                        "content": "How is it guaranteed that the value found throught binary search would be divisible by one of a, b or c?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Proof by contradiction. Suppose we found minimal value `x`, satisfying the search condition \"count of all ugly numbers less than or equal to `x` is at least `n`\". Let's assume that `x` is divisible by neither `a`, `b`, nor `c`. Than it is not an ugly number, and therefore `x-1` has the same amount of `n` ugly numbers less than or equal to it. But our basic presumption from the outset was that `x` is the minimal value satisfying this condition. Contradiction! That means the opposite of assumption is true: `x` is divisible by either `a`, `b`, or `c` and is an ugly number."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Yes.. We cannot ensure that.. But we can count how many ugly numbers would be there less than or equal to that num(on which you are doing binary Search)"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "We need to keep a check, whenever we get the count equal to n, then we have to check whether the mid is divisible by either a,b,orc if yes return else reduce high.\\n\\nMY code : \\n```\\nclass Solution {\\n    long countOFUglyNumber(int num,int A,int B,int C)\\n    {  \\n        long a = long(A),b = long(B),c = long(C);\\n        long total = (num/a + num/b + num/c);\\n        long ab = (a*b)/__gcd(a,b);\\n        long bc = (b*c)/__gcd(b,c);\\n        long ca = (a*c)/__gcd(a,c);\\n        long abc = (a*bc)/__gcd(a,bc);\\n        long common = (num/ab + num/bc + num/ca);\\n        return total - common + num/abc;\\n    };\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int low = 1, high = 2*1e9;\\n        while(low <= high)\\n        {\\n            int mid = low + (high-low)/2;\\n            int count = countOFUglyNumber(mid,a,b,c);\\n            if(count == n)\\n            {  \\n                if(mid%a == 0 || mid%b == 0 || mid%c == 0)\\n                    return mid;\\n                high = mid-1;\\n            }\\n            count < n ? low = mid+1 : high = mid-1;\\n        }\\n        return 0;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Andrew_2018_11",
                        "content": "For the test case:\\n1000000000\\n2\\n217983653\\n336916467\\n\\nThe expected answer is 1999999984\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320660.png)\\n\\n\\nBut for test case\\n1000000000\\n217983653\\n336916467\\n2\\n\\nThe expected answer is 1999999982\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320669.png)\\n\\nIs this a bug??? I am confused.\\n"
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "Use long long for everything including the lcm."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I guess they might have corrected it..\\nBecause it\\'s coming 1999999984 in both cases now.."
                    },
                    {
                        "username": "hegupta",
                        "content": "It\\'s not obvious what to conduct binary search over, then it\\'s not obvious what quantity to compute for the current candidate so that you can decide whether to go left or right, and finally it\\'s not obvious how to do the computation efficiently. The acceptance rate seems to agree."
                    },
                    {
                        "username": "starkovss",
                        "content": "input is  **n**= 5 \\nNUMBERS ARE : **a**= 2 , **b**=11, **c**=13\\nThey expect to see 10. HOW ?\\nThe sequence should be \\n2 4 8 11 **13** ( not 10 ! )\\nHow you can get **10** from any combination of that numbers ?\\n"
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "2,4,6,8,**10**\\n\\nhence 10?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "is a multiple of any of these numbers !"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "why example 3 has 10 as ugly number but example 2 does not have 10?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Why is Binary Search preferred here over the method of using 3 priority queues as in Ugly Number 2"
                    },
                    {
                        "username": "code__HARD",
                        "content": "as the constrinants are high"
                    },
                    {
                        "username": "moatasem9626",
                        "content": "very stubbed question, with the int limits"
                    },
                    {
                        "username": "Pmparekh2000",
                        "content": "Wrong test case is\\n5\\n2\\n11\\n13\\nHere the expected ans is 10 and I am getting 13. How can 10 come with prime factors 2,11,13. My series for this test case is 2,4,8,11,13,.... Please help :)"
                    },
                    {
                        "username": "SEVENx2",
                        "content": "The series would be 2,4,6,8,10,11,13..."
                    },
                    {
                        "username": "pygh55",
                        "content": "10\\n2\\n3\\n5\\n\\nwhy the answer is 14 not 15?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@KautsIITD](/KautsIITD) You missed 4"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "2,3,5,6,8,9,10,12,14,15\\n14 would be 9th ugly number here.."
                    }
                ]
            },
            {
                "id": 1573075,
                "content": [
                    {
                        "username": "Mrinal2100",
                        "content": "This was a really ugly problem"
                    },
                    {
                        "username": "gaur",
                        "content": "How is it guaranteed that the value found throught binary search would be divisible by one of a, b or c?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Proof by contradiction. Suppose we found minimal value `x`, satisfying the search condition \"count of all ugly numbers less than or equal to `x` is at least `n`\". Let's assume that `x` is divisible by neither `a`, `b`, nor `c`. Than it is not an ugly number, and therefore `x-1` has the same amount of `n` ugly numbers less than or equal to it. But our basic presumption from the outset was that `x` is the minimal value satisfying this condition. Contradiction! That means the opposite of assumption is true: `x` is divisible by either `a`, `b`, or `c` and is an ugly number."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Yes.. We cannot ensure that.. But we can count how many ugly numbers would be there less than or equal to that num(on which you are doing binary Search)"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "We need to keep a check, whenever we get the count equal to n, then we have to check whether the mid is divisible by either a,b,orc if yes return else reduce high.\\n\\nMY code : \\n```\\nclass Solution {\\n    long countOFUglyNumber(int num,int A,int B,int C)\\n    {  \\n        long a = long(A),b = long(B),c = long(C);\\n        long total = (num/a + num/b + num/c);\\n        long ab = (a*b)/__gcd(a,b);\\n        long bc = (b*c)/__gcd(b,c);\\n        long ca = (a*c)/__gcd(a,c);\\n        long abc = (a*bc)/__gcd(a,bc);\\n        long common = (num/ab + num/bc + num/ca);\\n        return total - common + num/abc;\\n    };\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int low = 1, high = 2*1e9;\\n        while(low <= high)\\n        {\\n            int mid = low + (high-low)/2;\\n            int count = countOFUglyNumber(mid,a,b,c);\\n            if(count == n)\\n            {  \\n                if(mid%a == 0 || mid%b == 0 || mid%c == 0)\\n                    return mid;\\n                high = mid-1;\\n            }\\n            count < n ? low = mid+1 : high = mid-1;\\n        }\\n        return 0;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Andrew_2018_11",
                        "content": "For the test case:\\n1000000000\\n2\\n217983653\\n336916467\\n\\nThe expected answer is 1999999984\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320660.png)\\n\\n\\nBut for test case\\n1000000000\\n217983653\\n336916467\\n2\\n\\nThe expected answer is 1999999982\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320669.png)\\n\\nIs this a bug??? I am confused.\\n"
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "Use long long for everything including the lcm."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I guess they might have corrected it..\\nBecause it\\'s coming 1999999984 in both cases now.."
                    },
                    {
                        "username": "hegupta",
                        "content": "It\\'s not obvious what to conduct binary search over, then it\\'s not obvious what quantity to compute for the current candidate so that you can decide whether to go left or right, and finally it\\'s not obvious how to do the computation efficiently. The acceptance rate seems to agree."
                    },
                    {
                        "username": "starkovss",
                        "content": "input is  **n**= 5 \\nNUMBERS ARE : **a**= 2 , **b**=11, **c**=13\\nThey expect to see 10. HOW ?\\nThe sequence should be \\n2 4 8 11 **13** ( not 10 ! )\\nHow you can get **10** from any combination of that numbers ?\\n"
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "2,4,6,8,**10**\\n\\nhence 10?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "is a multiple of any of these numbers !"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "why example 3 has 10 as ugly number but example 2 does not have 10?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Why is Binary Search preferred here over the method of using 3 priority queues as in Ugly Number 2"
                    },
                    {
                        "username": "code__HARD",
                        "content": "as the constrinants are high"
                    },
                    {
                        "username": "moatasem9626",
                        "content": "very stubbed question, with the int limits"
                    },
                    {
                        "username": "Pmparekh2000",
                        "content": "Wrong test case is\\n5\\n2\\n11\\n13\\nHere the expected ans is 10 and I am getting 13. How can 10 come with prime factors 2,11,13. My series for this test case is 2,4,8,11,13,.... Please help :)"
                    },
                    {
                        "username": "SEVENx2",
                        "content": "The series would be 2,4,6,8,10,11,13..."
                    },
                    {
                        "username": "pygh55",
                        "content": "10\\n2\\n3\\n5\\n\\nwhy the answer is 14 not 15?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@KautsIITD](/KautsIITD) You missed 4"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "2,3,5,6,8,9,10,12,14,15\\n14 would be 9th ugly number here.."
                    }
                ]
            },
            {
                "id": 1573034,
                "content": [
                    {
                        "username": "Mrinal2100",
                        "content": "This was a really ugly problem"
                    },
                    {
                        "username": "gaur",
                        "content": "How is it guaranteed that the value found throught binary search would be divisible by one of a, b or c?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Proof by contradiction. Suppose we found minimal value `x`, satisfying the search condition \"count of all ugly numbers less than or equal to `x` is at least `n`\". Let's assume that `x` is divisible by neither `a`, `b`, nor `c`. Than it is not an ugly number, and therefore `x-1` has the same amount of `n` ugly numbers less than or equal to it. But our basic presumption from the outset was that `x` is the minimal value satisfying this condition. Contradiction! That means the opposite of assumption is true: `x` is divisible by either `a`, `b`, or `c` and is an ugly number."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Yes.. We cannot ensure that.. But we can count how many ugly numbers would be there less than or equal to that num(on which you are doing binary Search)"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "We need to keep a check, whenever we get the count equal to n, then we have to check whether the mid is divisible by either a,b,orc if yes return else reduce high.\\n\\nMY code : \\n```\\nclass Solution {\\n    long countOFUglyNumber(int num,int A,int B,int C)\\n    {  \\n        long a = long(A),b = long(B),c = long(C);\\n        long total = (num/a + num/b + num/c);\\n        long ab = (a*b)/__gcd(a,b);\\n        long bc = (b*c)/__gcd(b,c);\\n        long ca = (a*c)/__gcd(a,c);\\n        long abc = (a*bc)/__gcd(a,bc);\\n        long common = (num/ab + num/bc + num/ca);\\n        return total - common + num/abc;\\n    };\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int low = 1, high = 2*1e9;\\n        while(low <= high)\\n        {\\n            int mid = low + (high-low)/2;\\n            int count = countOFUglyNumber(mid,a,b,c);\\n            if(count == n)\\n            {  \\n                if(mid%a == 0 || mid%b == 0 || mid%c == 0)\\n                    return mid;\\n                high = mid-1;\\n            }\\n            count < n ? low = mid+1 : high = mid-1;\\n        }\\n        return 0;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Andrew_2018_11",
                        "content": "For the test case:\\n1000000000\\n2\\n217983653\\n336916467\\n\\nThe expected answer is 1999999984\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320660.png)\\n\\n\\nBut for test case\\n1000000000\\n217983653\\n336916467\\n2\\n\\nThe expected answer is 1999999982\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320669.png)\\n\\nIs this a bug??? I am confused.\\n"
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "Use long long for everything including the lcm."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I guess they might have corrected it..\\nBecause it\\'s coming 1999999984 in both cases now.."
                    },
                    {
                        "username": "hegupta",
                        "content": "It\\'s not obvious what to conduct binary search over, then it\\'s not obvious what quantity to compute for the current candidate so that you can decide whether to go left or right, and finally it\\'s not obvious how to do the computation efficiently. The acceptance rate seems to agree."
                    },
                    {
                        "username": "starkovss",
                        "content": "input is  **n**= 5 \\nNUMBERS ARE : **a**= 2 , **b**=11, **c**=13\\nThey expect to see 10. HOW ?\\nThe sequence should be \\n2 4 8 11 **13** ( not 10 ! )\\nHow you can get **10** from any combination of that numbers ?\\n"
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "2,4,6,8,**10**\\n\\nhence 10?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "is a multiple of any of these numbers !"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "why example 3 has 10 as ugly number but example 2 does not have 10?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Why is Binary Search preferred here over the method of using 3 priority queues as in Ugly Number 2"
                    },
                    {
                        "username": "code__HARD",
                        "content": "as the constrinants are high"
                    },
                    {
                        "username": "moatasem9626",
                        "content": "very stubbed question, with the int limits"
                    },
                    {
                        "username": "Pmparekh2000",
                        "content": "Wrong test case is\\n5\\n2\\n11\\n13\\nHere the expected ans is 10 and I am getting 13. How can 10 come with prime factors 2,11,13. My series for this test case is 2,4,8,11,13,.... Please help :)"
                    },
                    {
                        "username": "SEVENx2",
                        "content": "The series would be 2,4,6,8,10,11,13..."
                    },
                    {
                        "username": "pygh55",
                        "content": "10\\n2\\n3\\n5\\n\\nwhy the answer is 14 not 15?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@KautsIITD](/KautsIITD) You missed 4"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "2,3,5,6,8,9,10,12,14,15\\n14 would be 9th ugly number here.."
                    }
                ]
            },
            {
                "id": 1569764,
                "content": [
                    {
                        "username": "Mrinal2100",
                        "content": "This was a really ugly problem"
                    },
                    {
                        "username": "gaur",
                        "content": "How is it guaranteed that the value found throught binary search would be divisible by one of a, b or c?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Proof by contradiction. Suppose we found minimal value `x`, satisfying the search condition \"count of all ugly numbers less than or equal to `x` is at least `n`\". Let's assume that `x` is divisible by neither `a`, `b`, nor `c`. Than it is not an ugly number, and therefore `x-1` has the same amount of `n` ugly numbers less than or equal to it. But our basic presumption from the outset was that `x` is the minimal value satisfying this condition. Contradiction! That means the opposite of assumption is true: `x` is divisible by either `a`, `b`, or `c` and is an ugly number."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Yes.. We cannot ensure that.. But we can count how many ugly numbers would be there less than or equal to that num(on which you are doing binary Search)"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "We need to keep a check, whenever we get the count equal to n, then we have to check whether the mid is divisible by either a,b,orc if yes return else reduce high.\\n\\nMY code : \\n```\\nclass Solution {\\n    long countOFUglyNumber(int num,int A,int B,int C)\\n    {  \\n        long a = long(A),b = long(B),c = long(C);\\n        long total = (num/a + num/b + num/c);\\n        long ab = (a*b)/__gcd(a,b);\\n        long bc = (b*c)/__gcd(b,c);\\n        long ca = (a*c)/__gcd(a,c);\\n        long abc = (a*bc)/__gcd(a,bc);\\n        long common = (num/ab + num/bc + num/ca);\\n        return total - common + num/abc;\\n    };\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int low = 1, high = 2*1e9;\\n        while(low <= high)\\n        {\\n            int mid = low + (high-low)/2;\\n            int count = countOFUglyNumber(mid,a,b,c);\\n            if(count == n)\\n            {  \\n                if(mid%a == 0 || mid%b == 0 || mid%c == 0)\\n                    return mid;\\n                high = mid-1;\\n            }\\n            count < n ? low = mid+1 : high = mid-1;\\n        }\\n        return 0;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Andrew_2018_11",
                        "content": "For the test case:\\n1000000000\\n2\\n217983653\\n336916467\\n\\nThe expected answer is 1999999984\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320660.png)\\n\\n\\nBut for test case\\n1000000000\\n217983653\\n336916467\\n2\\n\\nThe expected answer is 1999999982\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320669.png)\\n\\nIs this a bug??? I am confused.\\n"
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "Use long long for everything including the lcm."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I guess they might have corrected it..\\nBecause it\\'s coming 1999999984 in both cases now.."
                    },
                    {
                        "username": "hegupta",
                        "content": "It\\'s not obvious what to conduct binary search over, then it\\'s not obvious what quantity to compute for the current candidate so that you can decide whether to go left or right, and finally it\\'s not obvious how to do the computation efficiently. The acceptance rate seems to agree."
                    },
                    {
                        "username": "starkovss",
                        "content": "input is  **n**= 5 \\nNUMBERS ARE : **a**= 2 , **b**=11, **c**=13\\nThey expect to see 10. HOW ?\\nThe sequence should be \\n2 4 8 11 **13** ( not 10 ! )\\nHow you can get **10** from any combination of that numbers ?\\n"
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "2,4,6,8,**10**\\n\\nhence 10?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "is a multiple of any of these numbers !"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "why example 3 has 10 as ugly number but example 2 does not have 10?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Why is Binary Search preferred here over the method of using 3 priority queues as in Ugly Number 2"
                    },
                    {
                        "username": "code__HARD",
                        "content": "as the constrinants are high"
                    },
                    {
                        "username": "moatasem9626",
                        "content": "very stubbed question, with the int limits"
                    },
                    {
                        "username": "Pmparekh2000",
                        "content": "Wrong test case is\\n5\\n2\\n11\\n13\\nHere the expected ans is 10 and I am getting 13. How can 10 come with prime factors 2,11,13. My series for this test case is 2,4,8,11,13,.... Please help :)"
                    },
                    {
                        "username": "SEVENx2",
                        "content": "The series would be 2,4,6,8,10,11,13..."
                    },
                    {
                        "username": "pygh55",
                        "content": "10\\n2\\n3\\n5\\n\\nwhy the answer is 14 not 15?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@KautsIITD](/KautsIITD) You missed 4"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "2,3,5,6,8,9,10,12,14,15\\n14 would be 9th ugly number here.."
                    }
                ]
            },
            {
                "id": 1569635,
                "content": [
                    {
                        "username": "Mrinal2100",
                        "content": "This was a really ugly problem"
                    },
                    {
                        "username": "gaur",
                        "content": "How is it guaranteed that the value found throught binary search would be divisible by one of a, b or c?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Proof by contradiction. Suppose we found minimal value `x`, satisfying the search condition \"count of all ugly numbers less than or equal to `x` is at least `n`\". Let's assume that `x` is divisible by neither `a`, `b`, nor `c`. Than it is not an ugly number, and therefore `x-1` has the same amount of `n` ugly numbers less than or equal to it. But our basic presumption from the outset was that `x` is the minimal value satisfying this condition. Contradiction! That means the opposite of assumption is true: `x` is divisible by either `a`, `b`, or `c` and is an ugly number."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Yes.. We cannot ensure that.. But we can count how many ugly numbers would be there less than or equal to that num(on which you are doing binary Search)"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "We need to keep a check, whenever we get the count equal to n, then we have to check whether the mid is divisible by either a,b,orc if yes return else reduce high.\\n\\nMY code : \\n```\\nclass Solution {\\n    long countOFUglyNumber(int num,int A,int B,int C)\\n    {  \\n        long a = long(A),b = long(B),c = long(C);\\n        long total = (num/a + num/b + num/c);\\n        long ab = (a*b)/__gcd(a,b);\\n        long bc = (b*c)/__gcd(b,c);\\n        long ca = (a*c)/__gcd(a,c);\\n        long abc = (a*bc)/__gcd(a,bc);\\n        long common = (num/ab + num/bc + num/ca);\\n        return total - common + num/abc;\\n    };\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int low = 1, high = 2*1e9;\\n        while(low <= high)\\n        {\\n            int mid = low + (high-low)/2;\\n            int count = countOFUglyNumber(mid,a,b,c);\\n            if(count == n)\\n            {  \\n                if(mid%a == 0 || mid%b == 0 || mid%c == 0)\\n                    return mid;\\n                high = mid-1;\\n            }\\n            count < n ? low = mid+1 : high = mid-1;\\n        }\\n        return 0;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Andrew_2018_11",
                        "content": "For the test case:\\n1000000000\\n2\\n217983653\\n336916467\\n\\nThe expected answer is 1999999984\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320660.png)\\n\\n\\nBut for test case\\n1000000000\\n217983653\\n336916467\\n2\\n\\nThe expected answer is 1999999982\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320669.png)\\n\\nIs this a bug??? I am confused.\\n"
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "Use long long for everything including the lcm."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I guess they might have corrected it..\\nBecause it\\'s coming 1999999984 in both cases now.."
                    },
                    {
                        "username": "hegupta",
                        "content": "It\\'s not obvious what to conduct binary search over, then it\\'s not obvious what quantity to compute for the current candidate so that you can decide whether to go left or right, and finally it\\'s not obvious how to do the computation efficiently. The acceptance rate seems to agree."
                    },
                    {
                        "username": "starkovss",
                        "content": "input is  **n**= 5 \\nNUMBERS ARE : **a**= 2 , **b**=11, **c**=13\\nThey expect to see 10. HOW ?\\nThe sequence should be \\n2 4 8 11 **13** ( not 10 ! )\\nHow you can get **10** from any combination of that numbers ?\\n"
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "2,4,6,8,**10**\\n\\nhence 10?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "is a multiple of any of these numbers !"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "why example 3 has 10 as ugly number but example 2 does not have 10?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Why is Binary Search preferred here over the method of using 3 priority queues as in Ugly Number 2"
                    },
                    {
                        "username": "code__HARD",
                        "content": "as the constrinants are high"
                    },
                    {
                        "username": "moatasem9626",
                        "content": "very stubbed question, with the int limits"
                    },
                    {
                        "username": "Pmparekh2000",
                        "content": "Wrong test case is\\n5\\n2\\n11\\n13\\nHere the expected ans is 10 and I am getting 13. How can 10 come with prime factors 2,11,13. My series for this test case is 2,4,8,11,13,.... Please help :)"
                    },
                    {
                        "username": "SEVENx2",
                        "content": "The series would be 2,4,6,8,10,11,13..."
                    },
                    {
                        "username": "pygh55",
                        "content": "10\\n2\\n3\\n5\\n\\nwhy the answer is 14 not 15?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@KautsIITD](/KautsIITD) You missed 4"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "2,3,5,6,8,9,10,12,14,15\\n14 would be 9th ugly number here.."
                    }
                ]
            },
            {
                "id": 1860364,
                "content": [
                    {
                        "username": "Mrinal2100",
                        "content": "This was a really ugly problem"
                    },
                    {
                        "username": "gaur",
                        "content": "How is it guaranteed that the value found throught binary search would be divisible by one of a, b or c?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Proof by contradiction. Suppose we found minimal value `x`, satisfying the search condition \"count of all ugly numbers less than or equal to `x` is at least `n`\". Let's assume that `x` is divisible by neither `a`, `b`, nor `c`. Than it is not an ugly number, and therefore `x-1` has the same amount of `n` ugly numbers less than or equal to it. But our basic presumption from the outset was that `x` is the minimal value satisfying this condition. Contradiction! That means the opposite of assumption is true: `x` is divisible by either `a`, `b`, or `c` and is an ugly number."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Yes.. We cannot ensure that.. But we can count how many ugly numbers would be there less than or equal to that num(on which you are doing binary Search)"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "We need to keep a check, whenever we get the count equal to n, then we have to check whether the mid is divisible by either a,b,orc if yes return else reduce high.\\n\\nMY code : \\n```\\nclass Solution {\\n    long countOFUglyNumber(int num,int A,int B,int C)\\n    {  \\n        long a = long(A),b = long(B),c = long(C);\\n        long total = (num/a + num/b + num/c);\\n        long ab = (a*b)/__gcd(a,b);\\n        long bc = (b*c)/__gcd(b,c);\\n        long ca = (a*c)/__gcd(a,c);\\n        long abc = (a*bc)/__gcd(a,bc);\\n        long common = (num/ab + num/bc + num/ca);\\n        return total - common + num/abc;\\n    };\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int low = 1, high = 2*1e9;\\n        while(low <= high)\\n        {\\n            int mid = low + (high-low)/2;\\n            int count = countOFUglyNumber(mid,a,b,c);\\n            if(count == n)\\n            {  \\n                if(mid%a == 0 || mid%b == 0 || mid%c == 0)\\n                    return mid;\\n                high = mid-1;\\n            }\\n            count < n ? low = mid+1 : high = mid-1;\\n        }\\n        return 0;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Andrew_2018_11",
                        "content": "For the test case:\\n1000000000\\n2\\n217983653\\n336916467\\n\\nThe expected answer is 1999999984\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320660.png)\\n\\n\\nBut for test case\\n1000000000\\n217983653\\n336916467\\n2\\n\\nThe expected answer is 1999999982\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320669.png)\\n\\nIs this a bug??? I am confused.\\n"
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "Use long long for everything including the lcm."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I guess they might have corrected it..\\nBecause it\\'s coming 1999999984 in both cases now.."
                    },
                    {
                        "username": "hegupta",
                        "content": "It\\'s not obvious what to conduct binary search over, then it\\'s not obvious what quantity to compute for the current candidate so that you can decide whether to go left or right, and finally it\\'s not obvious how to do the computation efficiently. The acceptance rate seems to agree."
                    },
                    {
                        "username": "starkovss",
                        "content": "input is  **n**= 5 \\nNUMBERS ARE : **a**= 2 , **b**=11, **c**=13\\nThey expect to see 10. HOW ?\\nThe sequence should be \\n2 4 8 11 **13** ( not 10 ! )\\nHow you can get **10** from any combination of that numbers ?\\n"
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "2,4,6,8,**10**\\n\\nhence 10?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "is a multiple of any of these numbers !"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "why example 3 has 10 as ugly number but example 2 does not have 10?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Why is Binary Search preferred here over the method of using 3 priority queues as in Ugly Number 2"
                    },
                    {
                        "username": "code__HARD",
                        "content": "as the constrinants are high"
                    },
                    {
                        "username": "moatasem9626",
                        "content": "very stubbed question, with the int limits"
                    },
                    {
                        "username": "Pmparekh2000",
                        "content": "Wrong test case is\\n5\\n2\\n11\\n13\\nHere the expected ans is 10 and I am getting 13. How can 10 come with prime factors 2,11,13. My series for this test case is 2,4,8,11,13,.... Please help :)"
                    },
                    {
                        "username": "SEVENx2",
                        "content": "The series would be 2,4,6,8,10,11,13..."
                    },
                    {
                        "username": "pygh55",
                        "content": "10\\n2\\n3\\n5\\n\\nwhy the answer is 14 not 15?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@KautsIITD](/KautsIITD) You missed 4"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "2,3,5,6,8,9,10,12,14,15\\n14 would be 9th ugly number here.."
                    }
                ]
            },
            {
                "id": 1717190,
                "content": [
                    {
                        "username": "Mrinal2100",
                        "content": "This was a really ugly problem"
                    },
                    {
                        "username": "gaur",
                        "content": "How is it guaranteed that the value found throught binary search would be divisible by one of a, b or c?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Proof by contradiction. Suppose we found minimal value `x`, satisfying the search condition \"count of all ugly numbers less than or equal to `x` is at least `n`\". Let's assume that `x` is divisible by neither `a`, `b`, nor `c`. Than it is not an ugly number, and therefore `x-1` has the same amount of `n` ugly numbers less than or equal to it. But our basic presumption from the outset was that `x` is the minimal value satisfying this condition. Contradiction! That means the opposite of assumption is true: `x` is divisible by either `a`, `b`, or `c` and is an ugly number."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Yes.. We cannot ensure that.. But we can count how many ugly numbers would be there less than or equal to that num(on which you are doing binary Search)"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "We need to keep a check, whenever we get the count equal to n, then we have to check whether the mid is divisible by either a,b,orc if yes return else reduce high.\\n\\nMY code : \\n```\\nclass Solution {\\n    long countOFUglyNumber(int num,int A,int B,int C)\\n    {  \\n        long a = long(A),b = long(B),c = long(C);\\n        long total = (num/a + num/b + num/c);\\n        long ab = (a*b)/__gcd(a,b);\\n        long bc = (b*c)/__gcd(b,c);\\n        long ca = (a*c)/__gcd(a,c);\\n        long abc = (a*bc)/__gcd(a,bc);\\n        long common = (num/ab + num/bc + num/ca);\\n        return total - common + num/abc;\\n    };\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int low = 1, high = 2*1e9;\\n        while(low <= high)\\n        {\\n            int mid = low + (high-low)/2;\\n            int count = countOFUglyNumber(mid,a,b,c);\\n            if(count == n)\\n            {  \\n                if(mid%a == 0 || mid%b == 0 || mid%c == 0)\\n                    return mid;\\n                high = mid-1;\\n            }\\n            count < n ? low = mid+1 : high = mid-1;\\n        }\\n        return 0;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Andrew_2018_11",
                        "content": "For the test case:\\n1000000000\\n2\\n217983653\\n336916467\\n\\nThe expected answer is 1999999984\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320660.png)\\n\\n\\nBut for test case\\n1000000000\\n217983653\\n336916467\\n2\\n\\nThe expected answer is 1999999982\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320669.png)\\n\\nIs this a bug??? I am confused.\\n"
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "Use long long for everything including the lcm."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I guess they might have corrected it..\\nBecause it\\'s coming 1999999984 in both cases now.."
                    },
                    {
                        "username": "hegupta",
                        "content": "It\\'s not obvious what to conduct binary search over, then it\\'s not obvious what quantity to compute for the current candidate so that you can decide whether to go left or right, and finally it\\'s not obvious how to do the computation efficiently. The acceptance rate seems to agree."
                    },
                    {
                        "username": "starkovss",
                        "content": "input is  **n**= 5 \\nNUMBERS ARE : **a**= 2 , **b**=11, **c**=13\\nThey expect to see 10. HOW ?\\nThe sequence should be \\n2 4 8 11 **13** ( not 10 ! )\\nHow you can get **10** from any combination of that numbers ?\\n"
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "2,4,6,8,**10**\\n\\nhence 10?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "is a multiple of any of these numbers !"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "why example 3 has 10 as ugly number but example 2 does not have 10?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Why is Binary Search preferred here over the method of using 3 priority queues as in Ugly Number 2"
                    },
                    {
                        "username": "code__HARD",
                        "content": "as the constrinants are high"
                    },
                    {
                        "username": "moatasem9626",
                        "content": "very stubbed question, with the int limits"
                    },
                    {
                        "username": "Pmparekh2000",
                        "content": "Wrong test case is\\n5\\n2\\n11\\n13\\nHere the expected ans is 10 and I am getting 13. How can 10 come with prime factors 2,11,13. My series for this test case is 2,4,8,11,13,.... Please help :)"
                    },
                    {
                        "username": "SEVENx2",
                        "content": "The series would be 2,4,6,8,10,11,13..."
                    },
                    {
                        "username": "pygh55",
                        "content": "10\\n2\\n3\\n5\\n\\nwhy the answer is 14 not 15?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@KautsIITD](/KautsIITD) You missed 4"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "2,3,5,6,8,9,10,12,14,15\\n14 would be 9th ugly number here.."
                    }
                ]
            },
            {
                "id": 1574746,
                "content": [
                    {
                        "username": "Mrinal2100",
                        "content": "This was a really ugly problem"
                    },
                    {
                        "username": "gaur",
                        "content": "How is it guaranteed that the value found throught binary search would be divisible by one of a, b or c?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Proof by contradiction. Suppose we found minimal value `x`, satisfying the search condition \"count of all ugly numbers less than or equal to `x` is at least `n`\". Let's assume that `x` is divisible by neither `a`, `b`, nor `c`. Than it is not an ugly number, and therefore `x-1` has the same amount of `n` ugly numbers less than or equal to it. But our basic presumption from the outset was that `x` is the minimal value satisfying this condition. Contradiction! That means the opposite of assumption is true: `x` is divisible by either `a`, `b`, or `c` and is an ugly number."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Yes.. We cannot ensure that.. But we can count how many ugly numbers would be there less than or equal to that num(on which you are doing binary Search)"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "We need to keep a check, whenever we get the count equal to n, then we have to check whether the mid is divisible by either a,b,orc if yes return else reduce high.\\n\\nMY code : \\n```\\nclass Solution {\\n    long countOFUglyNumber(int num,int A,int B,int C)\\n    {  \\n        long a = long(A),b = long(B),c = long(C);\\n        long total = (num/a + num/b + num/c);\\n        long ab = (a*b)/__gcd(a,b);\\n        long bc = (b*c)/__gcd(b,c);\\n        long ca = (a*c)/__gcd(a,c);\\n        long abc = (a*bc)/__gcd(a,bc);\\n        long common = (num/ab + num/bc + num/ca);\\n        return total - common + num/abc;\\n    };\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int low = 1, high = 2*1e9;\\n        while(low <= high)\\n        {\\n            int mid = low + (high-low)/2;\\n            int count = countOFUglyNumber(mid,a,b,c);\\n            if(count == n)\\n            {  \\n                if(mid%a == 0 || mid%b == 0 || mid%c == 0)\\n                    return mid;\\n                high = mid-1;\\n            }\\n            count < n ? low = mid+1 : high = mid-1;\\n        }\\n        return 0;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Andrew_2018_11",
                        "content": "For the test case:\\n1000000000\\n2\\n217983653\\n336916467\\n\\nThe expected answer is 1999999984\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320660.png)\\n\\n\\nBut for test case\\n1000000000\\n217983653\\n336916467\\n2\\n\\nThe expected answer is 1999999982\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320669.png)\\n\\nIs this a bug??? I am confused.\\n"
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "Use long long for everything including the lcm."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I guess they might have corrected it..\\nBecause it\\'s coming 1999999984 in both cases now.."
                    },
                    {
                        "username": "hegupta",
                        "content": "It\\'s not obvious what to conduct binary search over, then it\\'s not obvious what quantity to compute for the current candidate so that you can decide whether to go left or right, and finally it\\'s not obvious how to do the computation efficiently. The acceptance rate seems to agree."
                    },
                    {
                        "username": "starkovss",
                        "content": "input is  **n**= 5 \\nNUMBERS ARE : **a**= 2 , **b**=11, **c**=13\\nThey expect to see 10. HOW ?\\nThe sequence should be \\n2 4 8 11 **13** ( not 10 ! )\\nHow you can get **10** from any combination of that numbers ?\\n"
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "2,4,6,8,**10**\\n\\nhence 10?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "is a multiple of any of these numbers !"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "why example 3 has 10 as ugly number but example 2 does not have 10?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Why is Binary Search preferred here over the method of using 3 priority queues as in Ugly Number 2"
                    },
                    {
                        "username": "code__HARD",
                        "content": "as the constrinants are high"
                    },
                    {
                        "username": "moatasem9626",
                        "content": "very stubbed question, with the int limits"
                    },
                    {
                        "username": "Pmparekh2000",
                        "content": "Wrong test case is\\n5\\n2\\n11\\n13\\nHere the expected ans is 10 and I am getting 13. How can 10 come with prime factors 2,11,13. My series for this test case is 2,4,8,11,13,.... Please help :)"
                    },
                    {
                        "username": "SEVENx2",
                        "content": "The series would be 2,4,6,8,10,11,13..."
                    },
                    {
                        "username": "pygh55",
                        "content": "10\\n2\\n3\\n5\\n\\nwhy the answer is 14 not 15?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@KautsIITD](/KautsIITD) You missed 4"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "2,3,5,6,8,9,10,12,14,15\\n14 would be 9th ugly number here.."
                    }
                ]
            },
            {
                "id": 1574559,
                "content": [
                    {
                        "username": "Mrinal2100",
                        "content": "This was a really ugly problem"
                    },
                    {
                        "username": "gaur",
                        "content": "How is it guaranteed that the value found throught binary search would be divisible by one of a, b or c?"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Proof by contradiction. Suppose we found minimal value `x`, satisfying the search condition \"count of all ugly numbers less than or equal to `x` is at least `n`\". Let's assume that `x` is divisible by neither `a`, `b`, nor `c`. Than it is not an ugly number, and therefore `x-1` has the same amount of `n` ugly numbers less than or equal to it. But our basic presumption from the outset was that `x` is the minimal value satisfying this condition. Contradiction! That means the opposite of assumption is true: `x` is divisible by either `a`, `b`, or `c` and is an ugly number."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "Yes.. We cannot ensure that.. But we can count how many ugly numbers would be there less than or equal to that num(on which you are doing binary Search)"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "We need to keep a check, whenever we get the count equal to n, then we have to check whether the mid is divisible by either a,b,orc if yes return else reduce high.\\n\\nMY code : \\n```\\nclass Solution {\\n    long countOFUglyNumber(int num,int A,int B,int C)\\n    {  \\n        long a = long(A),b = long(B),c = long(C);\\n        long total = (num/a + num/b + num/c);\\n        long ab = (a*b)/__gcd(a,b);\\n        long bc = (b*c)/__gcd(b,c);\\n        long ca = (a*c)/__gcd(a,c);\\n        long abc = (a*bc)/__gcd(a,bc);\\n        long common = (num/ab + num/bc + num/ca);\\n        return total - common + num/abc;\\n    };\\npublic:\\n    int nthUglyNumber(int n, int a, int b, int c) {\\n        int low = 1, high = 2*1e9;\\n        while(low <= high)\\n        {\\n            int mid = low + (high-low)/2;\\n            int count = countOFUglyNumber(mid,a,b,c);\\n            if(count == n)\\n            {  \\n                if(mid%a == 0 || mid%b == 0 || mid%c == 0)\\n                    return mid;\\n                high = mid-1;\\n            }\\n            count < n ? low = mid+1 : high = mid-1;\\n        }\\n        return 0;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Andrew_2018_11",
                        "content": "For the test case:\\n1000000000\\n2\\n217983653\\n336916467\\n\\nThe expected answer is 1999999984\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320660.png)\\n\\n\\nBut for test case\\n1000000000\\n217983653\\n336916467\\n2\\n\\nThe expected answer is 1999999982\\n![image](https://assets.leetcode.com/users/neptune2011fall/image_1570320669.png)\\n\\nIs this a bug??? I am confused.\\n"
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "Use long long for everything including the lcm."
                    },
                    {
                        "username": "KautsIITD",
                        "content": "I guess they might have corrected it..\\nBecause it\\'s coming 1999999984 in both cases now.."
                    },
                    {
                        "username": "hegupta",
                        "content": "It\\'s not obvious what to conduct binary search over, then it\\'s not obvious what quantity to compute for the current candidate so that you can decide whether to go left or right, and finally it\\'s not obvious how to do the computation efficiently. The acceptance rate seems to agree."
                    },
                    {
                        "username": "starkovss",
                        "content": "input is  **n**= 5 \\nNUMBERS ARE : **a**= 2 , **b**=11, **c**=13\\nThey expect to see 10. HOW ?\\nThe sequence should be \\n2 4 8 11 **13** ( not 10 ! )\\nHow you can get **10** from any combination of that numbers ?\\n"
                    },
                    {
                        "username": "ChaiBapchya",
                        "content": "2,4,6,8,**10**\\n\\nhence 10?"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "is a multiple of any of these numbers !"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "why example 3 has 10 as ugly number but example 2 does not have 10?"
                    },
                    {
                        "username": "r_roy",
                        "content": "Why is Binary Search preferred here over the method of using 3 priority queues as in Ugly Number 2"
                    },
                    {
                        "username": "code__HARD",
                        "content": "as the constrinants are high"
                    },
                    {
                        "username": "moatasem9626",
                        "content": "very stubbed question, with the int limits"
                    },
                    {
                        "username": "Pmparekh2000",
                        "content": "Wrong test case is\\n5\\n2\\n11\\n13\\nHere the expected ans is 10 and I am getting 13. How can 10 come with prime factors 2,11,13. My series for this test case is 2,4,8,11,13,.... Please help :)"
                    },
                    {
                        "username": "SEVENx2",
                        "content": "The series would be 2,4,6,8,10,11,13..."
                    },
                    {
                        "username": "pygh55",
                        "content": "10\\n2\\n3\\n5\\n\\nwhy the answer is 14 not 15?\\n"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "[@KautsIITD](/KautsIITD) You missed 4"
                    },
                    {
                        "username": "KautsIITD",
                        "content": "2,3,5,6,8,9,10,12,14,15\\n14 would be 9th ugly number here.."
                    }
                ]
            }
        ]
    },
    {
        "title": "Average Time of Process per Machine",
        "question_content": "<p>Table: <code>Activity</code></p>\n\n<pre>\n+----------------+---------+\n| Column Name    | Type    |\n+----------------+---------+\n| machine_id     | int     |\n| process_id     | int     |\n| activity_type  | enum    |\n| timestamp      | float   |\n+----------------+---------+\nThe table shows the user activities for a factory website.\n(machine_id, process_id, activity_type) is the primary key (combination of columns with unique values) of this table.\nmachine_id is the ID of a machine.\nprocess_id is the ID of a process running on the machine with ID machine_id.\nactivity_type is an ENUM (category) of type (&#39;start&#39;, &#39;end&#39;).\ntimestamp is a float representing the current time in seconds.\n&#39;start&#39; means the machine starts the process at the given timestamp and &#39;end&#39; means the machine ends the process at the given timestamp.\nThe &#39;start&#39; timestamp will always be before the &#39;end&#39; timestamp for every (machine_id, process_id) pair.</pre>\n\n<p>&nbsp;</p>\n\n<p>There is a factory website that has several machines each running the <strong>same number of processes</strong>. Write a solution&nbsp;to find the <strong>average time</strong> each machine takes to complete a process.</p>\n\n<p>The time to complete a process is the <code>&#39;end&#39; timestamp</code> minus the <code>&#39;start&#39; timestamp</code>. The average time is calculated by the total time to complete every process on the machine divided by the number of processes that were run.</p>\n\n<p>The resulting table should have the <code>machine_id</code> along with the <strong>average time</strong> as <code>processing_time</code>, which should be <strong>rounded to 3 decimal places</strong>.</p>\n\n<p>Return the result table in <strong>any order</strong>.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nActivity table:\n+------------+------------+---------------+-----------+\n| machine_id | process_id | activity_type | timestamp |\n+------------+------------+---------------+-----------+\n| 0          | 0          | start         | 0.712     |\n| 0          | 0          | end           | 1.520     |\n| 0          | 1          | start         | 3.140     |\n| 0          | 1          | end           | 4.120     |\n| 1          | 0          | start         | 0.550     |\n| 1          | 0          | end           | 1.550     |\n| 1          | 1          | start         | 0.430     |\n| 1          | 1          | end           | 1.420     |\n| 2          | 0          | start         | 4.100     |\n| 2          | 0          | end           | 4.512     |\n| 2          | 1          | start         | 2.500     |\n| 2          | 1          | end           | 5.000     |\n+------------+------------+---------------+-----------+\n<strong>Output:</strong> \n+------------+-----------------+\n| machine_id | processing_time |\n+------------+-----------------+\n| 0          | 0.894           |\n| 1          | 0.995           |\n| 2          | 1.456           |\n+------------+-----------------+\n<strong>Explanation:</strong> \nThere are 3 machines running 2 processes each.\nMachine 0&#39;s average time is ((1.520 - 0.712) + (4.120 - 3.140)) / 2 = 0.894\nMachine 1&#39;s average time is ((1.550 - 0.550) + (1.420 - 0.430)) / 2 = 0.995\nMachine 2&#39;s average time is ((4.512 - 4.100) + (5.000 - 2.500)) / 2 = 1.456\n</pre>\n",
        "solutions": [
            {
                "id": 3722056,
                "title": "sql-join-or-subquery-easy-to-understand",
                "content": "# Intuition\\n***The paste was solved in 2 different ways.\\nIn the first one, a solution based on \\'join\\' is achieved (which is more self-explanatory)\\nIn the second one, the solution is achieved through subqueries (This solution is also understandable and wonderful)***\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/c0d84b6d-15b9-43c1-b31d-999d38c4781e_1688555463.4935868.png)\\n\\n# First Solution\\n```\\nselect a1.machine_id, round(avg(a2.timestamp-a1.timestamp), 3) as processing_time \\nfrom Activity a1\\njoin Activity a2 \\non a1.machine_id=a2.machine_id and a1.process_id=a2.process_id\\nand a1.activity_type=\\'start\\' and a2.activity_type=\\'end\\'\\ngroup by a1.machine_id\\n\\n```\\n# Second Solution\\n```\\nselect \\na.machine_id,\\nround(\\n      (select avg(a1.timestamp) from Activity a1 where a1.activity_type = \\'end\\' and a1.machine_id = a.machine_id) - \\n      (select avg(a1.timestamp) from Activity a1 where a1.activity_type = \\'start\\' and a1.machine_id = a.machine_id)\\n,3) as processing_time\\nfrom Activity a\\ngroup by a.machine_id\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\nselect a1.machine_id, round(avg(a2.timestamp-a1.timestamp), 3) as processing_time \\nfrom Activity a1\\njoin Activity a2 \\non a1.machine_id=a2.machine_id and a1.process_id=a2.process_id\\nand a1.activity_type=\\'start\\' and a2.activity_type=\\'end\\'\\ngroup by a1.machine_id\\n\\n```\n```\\nselect \\na.machine_id,\\nround(\\n      (select avg(a1.timestamp) from Activity a1 where a1.activity_type = \\'end\\' and a1.machine_id = a.machine_id) - \\n      (select avg(a1.timestamp) from Activity a1 where a1.activity_type = \\'start\\' and a1.machine_id = a.machine_id)\\n,3) as processing_time\\nfrom Activity a\\ngroup by a.machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3537533,
                "title": "detailed-explanation-of-join-round-avg-group-by",
                "content": "# Approach\\nTo solve this problem, 1st we need to join the same table, so we will have starting time and ending time in the same line:\\n\\n```\\nselect a1.machine_id, a1.timestamp, a2.timestamp\\nfrom Activity a1\\njoin Activity a2\\non a1.process_id=a2.process_id\\nand a1.machine_id=a2.machine_id\\nand a1.timestamp<a2.timestamp;\\n\\n| machine_id | timestamp | timestamp |\\n| ---------- | --------- | --------- |\\n| 0          | 0.712     | 1.52      |\\n| 0          | 3.14      | 4.12      |\\n| 1          | 0.55      | 1.55      |\\n| 1          | 0.43      | 1.42      |\\n| 2          | 4.1       | 4.512     |\\n| 2          | 2.5       | 5         |\\n```\\n\\nnow we can calculate the difference between timestamps, group the values by machine_id and round average value of differences\\n\\n```\\nselect a1.machine_id\\n, ROUND(AVG(a2.timestamp - a1.timestamp),3) as processing_time\\nfrom Activity a1\\njoin Activity a2\\non a1.process_id=a2.process_id\\nand a1.machine_id=a2.machine_id\\nand a1.timestamp<a2.timestamp\\ngroup by a1.machine_id;\\n\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\n```\\n\\nPlease upvote if you like my explanation. Good luck!\\n\\n",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Oracle"
                ],
                "code": "```\\nselect a1.machine_id, a1.timestamp, a2.timestamp\\nfrom Activity a1\\njoin Activity a2\\non a1.process_id=a2.process_id\\nand a1.machine_id=a2.machine_id\\nand a1.timestamp<a2.timestamp;\\n\\n| machine_id | timestamp | timestamp |\\n| ---------- | --------- | --------- |\\n| 0          | 0.712     | 1.52      |\\n| 0          | 3.14      | 4.12      |\\n| 1          | 0.55      | 1.55      |\\n| 1          | 0.43      | 1.42      |\\n| 2          | 4.1       | 4.512     |\\n| 2          | 2.5       | 5         |\\n```\n```\\nselect a1.machine_id\\n, ROUND(AVG(a2.timestamp - a1.timestamp),3) as processing_time\\nfrom Activity a1\\njoin Activity a2\\non a1.process_id=a2.process_id\\nand a1.machine_id=a2.machine_id\\nand a1.timestamp<a2.timestamp\\ngroup by a1.machine_id;\\n\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 941770,
                "title": "mysql-self-join-100-faster-100-less-memory",
                "content": "```\\nSELECT s.machine_id, ROUND(AVG(e.timestamp-s.timestamp), 3) AS processing_time\\nFROM Activity s JOIN Activity e ON\\n    s.machine_id = e.machine_id AND s.process_id = e.process_id AND\\n    s.activity_type = \\'start\\' AND e.activity_type = \\'end\\'\\nGROUP BY s.machine_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT s.machine_id, ROUND(AVG(e.timestamp-s.timestamp), 3) AS processing_time\\nFROM Activity s JOIN Activity e ON\\n    s.machine_id = e.machine_id AND s.process_id = e.process_id AND\\n    s.activity_type = \\'start\\' AND e.activity_type = \\'end\\'\\nGROUP BY s.machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3574206,
                "title": "best-optimum-solution-with-explanation-using-joins",
                "content": "## ***Please Upvote my solution, if you find it helpful ;)***\\n\\n# Intuition\\nThe problem asks us to calculate the average time taken to process each machine based on start and end activities recorded in the \"Activity\" table.\\n\\n# Approach\\nTo solve this problem, we use a SQL query with the following steps:\\n\\n1. We join the \"Activity\" table with itself using the \"machine_id\" column. This allows us to pair the start and end activities for each machine.\\n1. We filter the rows to include only the start activities for the first occurrence and the end activities for the second occurrence. This ensures we have matched start and end activities for each machine.\\n1. We calculate the time difference between the start and end activities for each machine by subtracting the start timestamp from the end timestamp.\\n1. We use the AVG function to calculate the average processing time for each machine.\\n1. We round the average processing time to three decimal places using the ROUND function.\\n1. Finally, we group the results by \"machine_id\" to get the average processing time for each machine.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this query depends on the size of the \"Activity\" table and the efficiency of the database engine. For a well-indexed table, the time complexity is usually efficient. We can say that it will take $$O(n log n)$$ or $$O(n)$$ time, where n is the number of rows in the \"Activity\" table. The database engine uses techniques like indexing and joining algorithms to quickly process the query.\\n\\n- Space complexity:\\nThe space complexity of this query is determined by the size of the result set. In other words, it depends on the number of machines for which there are start and end activities. We can say the space complexity is $$O(n)$$, where n is the number of machines. The memory required to store the result set grows with the number of machines.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT \\n    s.machine_id, \\n    ROUND(AVG(e.timestamp-s.timestamp),3) as processing_time \\nFROM Activity s\\nJOIN Activity e ON e.machine_id=s.machine_id\\nWHERE s.activity_type=\\'start\\' AND e.activity_type=\\'end\\'\\nGROUP BY s.machine_id\\n```\\n***Please Upvote my solution, if you find it helpful ;)***\\n![6a87bc25-d70b-424f-9e60-7da6f345b82a_1673875931.8933976.jpeg](https://assets.leetcode.com/users/images/0e5e5357-5af9-4902-a584-62f5ac275515_1685478393.9930801.jpeg)\\n",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT \\n    s.machine_id, \\n    ROUND(AVG(e.timestamp-s.timestamp),3) as processing_time \\nFROM Activity s\\nJOIN Activity e ON e.machine_id=s.machine_id\\nWHERE s.activity_type=\\'start\\' AND e.activity_type=\\'end\\'\\nGROUP BY s.machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 950171,
                "title": "simple-mysql-no-join",
                "content": "```\\nSELECT machine_id, ROUND((SUM(CASE WHEN activity_type = \\'end\\' THEN timestamp END)-SUM(CASE WHEN activity_type = \\'start\\' THEN timestamp END))/COUNT(DISTINCT process_id), 3) processing_time\\nFROM Activity\\nGROUP BY 1\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT machine_id, ROUND((SUM(CASE WHEN activity_type = \\'end\\' THEN timestamp END)-SUM(CASE WHEN activity_type = \\'start\\' THEN timestamp END))/COUNT(DISTINCT process_id), 3) processing_time\\nFROM Activity\\nGROUP BY 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3861997,
                "title": "100-easy-fast-clean-2-solution",
                "content": "IF THIS WILL BE HELPFUL TO YOU, PLEASE UPVOTE !\\n\\n# Code1\\n```\\n/* Write your PL/SQL query statement below */\\nSELECT A1.machine_id, ROUND(AVG(A2.timestamp - A1.timestamp),3) As \\n\\nprocessing_time FROM Activity A1, Activity A2 WHERE \\n\\nA1.machine_id = A2.machine_id AND A1.process_id = A2.process_id \\n\\nAND A1.timestamp < A2.timestamp GROUP BY A1.machine_id\\n\\n\\n```\\n\\n# Code2\\n```\\n/* Write your PL/SQL query statement below */\\nSELECT A.machine_id, ROUND(( SELECT AVG(A1.timestamp) FROM Activity A1\\n\\nWHERE A1.activity_type=\\'end\\' AND A1.machine_id = A.machine_id) -  \\n\\n( SELECT AVG(A1.timestamp) FROM Activity A1 WHERE \\n\\nA1.activity_type=\\'start\\' AND A1.machine_id = A.machine_id), 3) AS \\n\\nprocessing_time FROM Activity A GROUP BY A.machine_id\\n```\\n\\n![5kej8w.jpg](https://assets.leetcode.com/users/images/2f9cf237-bad8-4dbf-b421-b227f9fbc79e_1691140207.4912024.jpeg)\\n",
                "solutionTags": [
                    "Oracle",
                    "Database"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nSELECT A1.machine_id, ROUND(AVG(A2.timestamp - A1.timestamp),3) As \\n\\nprocessing_time FROM Activity A1, Activity A2 WHERE \\n\\nA1.machine_id = A2.machine_id AND A1.process_id = A2.process_id \\n\\nAND A1.timestamp < A2.timestamp GROUP BY A1.machine_id\\n\\n\\n```\n```\\n/* Write your PL/SQL query statement below */\\nSELECT A.machine_id, ROUND(( SELECT AVG(A1.timestamp) FROM Activity A1\\n\\nWHERE A1.activity_type=\\'end\\' AND A1.machine_id = A.machine_id) -  \\n\\n( SELECT AVG(A1.timestamp) FROM Activity A1 WHERE \\n\\nA1.activity_type=\\'start\\' AND A1.machine_id = A.machine_id), 3) AS \\n\\nprocessing_time FROM Activity A GROUP BY A.machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1084239,
                "title": "simple-solution-without-join",
                "content": "```\\nselect machine_id, \\nround(sum(case when activity_type = \\'start\\' then -1*timestamp else timestamp end)/count(distinct process_id),3) as processing_time\\nfrom Activity\\ngroup by machine_id\\n```\\n",
                "solutionTags": [],
                "code": "```\\nselect machine_id, \\nround(sum(case when activity_type = \\'start\\' then -1*timestamp else timestamp end)/count(distinct process_id),3) as processing_time\\nfrom Activity\\ngroup by machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2081173,
                "title": "why-make-it-complicated-easiest-solution-ever",
                "content": "```\\nSELECT \\n    machine_id,\\n    ROUND(AVG(IF(activity_type = \"end\", timestamp, -timestamp)) * 2, 3) AS processing_time\\nFROM Activity\\nGROUP BY machine_id;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT \\n    machine_id,\\n    ROUND(AVG(IF(activity_type = \"end\", timestamp, -timestamp)) * 2, 3) AS processing_time\\nFROM Activity\\nGROUP BY machine_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1028190,
                "title": "solution-using-avg-and-case-mysql",
                "content": "Explanation:\\nWhat we actually want to do is to compute the difference corresponding to each machine and process pair and then take average. \\n1. Instead of difference, we can just add negative timestamp of the \\'start\\' entry and positive timestamp for \\'end\\' entry. It will effectively be the same.\\n2. After doing this, when you take average, the total number of entries double because value corresponding to end and start are considered separately. So, multiply the average with a 2.\\n3. Finally, the average we want is for all the processes corresponding to a machine. So, we just have to group by machine. Which process the start and end timestamps belong to is not required because we are just finding the average.\\n\\n```\\nSELECT\\n    a.machine_id, ROUND(AVG(CASE \\n                   WHEN a.activity_type = \\'end\\' THEN a.timestamp\\n                   WHEN a.activity_type = \\'start\\' THEN -a.timestamp\\n                  END)*2, 3) as processing_time\\nFROM\\n    Activity a\\nGROUP BY\\n    a.machine_id\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT\\n    a.machine_id, ROUND(AVG(CASE \\n                   WHEN a.activity_type = \\'end\\' THEN a.timestamp\\n                   WHEN a.activity_type = \\'start\\' THEN -a.timestamp\\n                  END)*2, 3) as processing_time\\nFROM\\n    Activity a\\nGROUP BY\\n    a.machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4029004,
                "title": "no-joins-no-subquery-easy-solution",
                "content": "\\n# Approach\\n\\nCalculate the time take by processes to complete\\nby the formula given in question \\n\\nthen divide it by count(*) / 2  \\n\\ncount(*) will give pairs (start,end) for a  process\\ndivide it by 2 to get no. of processes\\n\\nat the end group iy by machine_id to get machine wise avg time\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\n select machine_id ,\\n\\n Round(\\n\\n    ( sum(case when activity_type = \\'end\\' then timestamp else 0 end) - \\n     sum(case when activity_type = \\'start\\' then timestamp else 0 end) ) / (count(*)/2)\\n     \\n\\n     ,3\\n ) as processing_time\\n\\n from activity\\n group by machine_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\n select machine_id ,\\n\\n Round(\\n\\n    ( sum(case when activity_type = \\'end\\' then timestamp else 0 end) - \\n     sum(case when activity_type = \\'start\\' then timestamp else 0 end) ) / (count(*)/2)\\n     \\n\\n     ,3\\n ) as processing_time\\n\\n from activity\\n group by machine_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3449053,
                "title": "easy-simple-querry-using-only-case-when-then",
                "content": "**1.Lastly to round 3 digits after column**\\n\\uD83D\\uDC47\\uD83C\\uDFFB \\n```\\nRound( ,3)\\n```\\n**2.To get average of all cells with timestamp column**\\n\\uD83D\\uDC47\\uD83C\\uDFFB \\n```\\nRound(avg(),3)\\n```\\n**3.Simple institution \\uD83E\\uDD17 \\nwhen activity is start, get from row timestamp\\nwhen activity is end, get from row -timestamp**\\n\\uD83D\\uDC47\\uD83C\\uDFFB\\n```\\nRound(avg(case\\nwhen activity_type=\"start\" then timestamp\\nwhen activity_type=\"end\" then -timestamp\\nend),3)\\n```\\n**4.In 3rd step our avg() getting 2 times more values,\\nso deviding it into the same number. \\nJust multiply it by 2**\\n\\n**5.As out end allways greater you can use \"-\" sign like this \\uD83D\\uDC47\\uD83C\\uDFFB**\\n```\\nRound(avg(\\n  case\\nwhen activity_type=\"start\" then timestamp\\nwhen activity_type=\"end\" then -timestamp\\nend\\n)*(-2),3)\\n```\\n**or avg() function it is your wish**\\n\\n**GOOD LUCK\\u2757\\uFE0F**\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect machine_id, Round(avg(\\n  case\\nwhen activity_type=\"start\" then timestamp\\nwhen activity_type=\"end\" then -timestamp\\nend\\n)*(-2),3)as processing_time\\nfrom activity\\ngroup by machine_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nRound( ,3)\\n```\n```\\nRound(avg(),3)\\n```\n```\\nRound(avg(case\\nwhen activity_type=\"start\" then timestamp\\nwhen activity_type=\"end\" then -timestamp\\nend),3)\\n```\n```\\nRound(avg(\\n  case\\nwhen activity_type=\"start\" then timestamp\\nwhen activity_type=\"end\" then -timestamp\\nend\\n)*(-2),3)\\n```\n```\\n# Write your MySQL query statement below\\nselect machine_id, Round(avg(\\n  case\\nwhen activity_type=\"start\" then timestamp\\nwhen activity_type=\"end\" then -timestamp\\nend\\n)*(-2),3)as processing_time\\nfrom activity\\ngroup by machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1035191,
                "title": "mysql-case-when",
                "content": "\\n```\\nSELECT \\n    machine_id, \\n    ROUND(SUM(CASE WHEN activity_type = \"end\" THEN timestamp ELSE -timestamp END)/COUNT(DISTINCT process_id), 3) AS processing_time\\nFROM Activity\\nGROUP BY 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT \\n    machine_id, \\n    ROUND(SUM(CASE WHEN activity_type = \"end\" THEN timestamp ELSE -timestamp END)/COUNT(DISTINCT process_id), 3) AS processing_time\\nFROM Activity\\nGROUP BY 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2507960,
                "title": "5-different-methods-basically-sum-count-or-avg-difference",
                "content": "/*#window function\\nselect\\nmachine_id,\\nround(avg(time_diff),3) processing_time\\nfrom\\n(select\\nmachine_id,\\ntimestamp - lag(timestamp,1)over(partition by machine_id, Process_id order by timestamp) as time_diff\\nfrom activity) a\\nwhere time_diff is not null\\ngroup by 1\\n*/\\n/*#most simple way with temp table\\nwith starttime as (select machine_id, timestamp as starttime from activity where activity_type =\\'start\\'),\\n\\nendtime as (select machine_id, timestamp as endtime from activity where activity_type =\\'end\\')\\n\\nselect s.machine_id,\\nround(avg(endtime-starttime),3) as processing_time\\nfrom starttime s\\ninner join endtime e on s.machine_id=e.machine_id\\ngroup by 1\\n*/\\n/*#sum(if())\\nselect machine_id,\\nround(sum(if(activity_type=\\'start\\', -timestamp, timestamp)) / count(distinct process_id),3) as processing_time\\nfrom activity\\ngroup by 1\\n*/\\n/*case statement\\nselect\\nmachine_id,\\nround((endtime-starttime)/cnt_pid, 3) as processing_time\\nfrom\\n(\\nselect machine_id,\\nsum(case when activity_type=\\'start\\' then timestamp end) as starttime,\\nsum(case when activity_type=\\'end\\' then timestamp end) as endtime,\\ncount(distinct process_id) as cnt_pid\\nfrom activity\\ngroup by 1) a\\n*/\\n",
                "solutionTags": [],
                "code": "/*#window function\\nselect\\nmachine_id,\\nround(avg(time_diff),3) processing_time\\nfrom\\n(select\\nmachine_id,\\ntimestamp - lag(timestamp,1)over(partition by machine_id, Process_id order by timestamp) as time_diff\\nfrom activity) a\\nwhere time_diff is not null\\ngroup by 1\\n*/\\n/*#most simple way with temp table\\nwith starttime as (select machine_id, timestamp as starttime from activity where activity_type =\\'start\\'),\\n\\nendtime as (select machine_id, timestamp as endtime from activity where activity_type =\\'end\\')\\n\\nselect s.machine_id,\\nround(avg(endtime-starttime),3) as processing_time\\nfrom starttime s\\ninner join endtime e on s.machine_id=e.machine_id\\ngroup by 1\\n*/\\n/*#sum(if())\\nselect machine_id,\\nround(sum(if(activity_type=\\'start\\', -timestamp, timestamp)) / count(distinct process_id),3) as processing_time\\nfrom activity\\ngroup by 1\\n*/\\n/*case statement\\nselect\\nmachine_id,\\nround((endtime-starttime)/cnt_pid, 3) as processing_time\\nfrom\\n(\\nselect machine_id,\\nsum(case when activity_type=\\'start\\' then timestamp end) as starttime,\\nsum(case when activity_type=\\'end\\' then timestamp end) as endtime,\\ncount(distinct process_id) as cnt_pid\\nfrom activity\\ngroup by 1) a\\n*/\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2268489,
                "title": "simple-mysql-solution-cte-group-by-sum-case-when",
                "content": "```\\n# Write your MySQL query statement below\\nWITH t AS (\\n    SELECT\\n        machine_id,\\n        process_id,\\n        SUM(CASE WHEN activity_type=\\'start\\' THEN timestamp ELSE 0 END) AS start_time,\\n        SUM(CASE WHEN activity_type=\\'end\\' THEN timestamp ELSE 0 END) AS end_time\\n    FROM Activity\\n    GROUP BY machine_id, process_id\\n    ORDER BY machine_id, process_id\\n)\\nSELECT\\n    machine_id,\\n    ROUND(AVG(end_time-start_time), 3) AS processing_time\\nFROM t\\nGROUP BY machine_id\\nORDER BY machine_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nWITH t AS (\\n    SELECT\\n        machine_id,\\n        process_id,\\n        SUM(CASE WHEN activity_type=\\'start\\' THEN timestamp ELSE 0 END) AS start_time,\\n        SUM(CASE WHEN activity_type=\\'end\\' THEN timestamp ELSE 0 END) AS end_time\\n    FROM Activity\\n    GROUP BY machine_id, process_id\\n    ORDER BY machine_id, process_id\\n)\\nSELECT\\n    machine_id,\\n    ROUND(AVG(end_time-start_time), 3) AS processing_time\\nFROM t\\nGROUP BY machine_id\\nORDER BY machine_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 945756,
                "title": "mysql-solution-no-join-a-simple-groupby",
                "content": "```\\n# Write your MySQL query statement below\\nselect machine_id, \\nround(sum(case when activity_type = \\'end\\' then `timestamp` else -`timestamp` end) / \\ncount(distinct process_id),3) as processing_time\\nfrom Activity\\ngroup by machine_id\\n\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nselect machine_id, \\nround(sum(case when activity_type = \\'end\\' then `timestamp` else -`timestamp` end) / \\ncount(distinct process_id),3) as processing_time\\nfrom Activity\\ngroup by machine_id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3716919,
                "title": "mysql-simple-and-clean-beats-88",
                "content": "# Average Time of Process per Machine\\n### Please upvote if you find this helpful. \\u270C\\n<img src=\"https://assets.leetcode.com/users/images/b8e25620-d320-420a-ae09-94c7453bd033_1678818986.7001078.jpeg\" alt=\"Cute Robot - Stable diffusion\" width=\"200\"/>\\n\\n## Intuition\\n\\nThe problem requires us to find the average time each machine takes to complete a process in a factory. We are given a table that records the start and end timestamps of each process for each machine. To calculate the average time, we need to subtract the start timestamp from the end timestamp for each process and then find the average time for all processes on each machine.\\n\\n## Approach\\n\\nTo solve the problem, we can use the following approach:\\n\\n1. Join the `Activity` table with itself, denoting the first occurrence as `a` and the second occurrence as `b`.\\n2. Use the `JOIN` condition to match the rows with the same `machine_id`, `process_id`, and activity types \\'start\\' and \\'end\\'.\\n3. Calculate the time taken for each process by subtracting the start timestamp (`a.timestamp`) from the end timestamp (`b.timestamp`).\\n4. Use the `GROUP BY` clause to group the results by `machine_id`.\\n5. Apply the `AVG` function on the time taken for each machine to calculate the average time.\\n6. Round the average time to 3 decimal places using the `ROUND` function.\\n7. Select the `machine_id` and the rounded average time as `processing_time`.\\n\\nThe SQL query for the above approach is as follows:\\n\\n```sql\\nSELECT a.machine_id, ROUND(AVG(b.timestamp - a.timestamp), 3) AS processing_time\\nFROM Activity a\\nJOIN Activity b ON a.machine_id = b.machine_id AND a.process_id = b.process_id AND a.activity_type = \\'start\\' AND b.activity_type = \\'end\\'\\nGROUP BY a.machine_id;\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "# Average Time of Process per Machine\\n### Please upvote if you find this helpful. \\u270C\\n<img src=\"https://assets.leetcode.com/users/images/b8e25620-d320-420a-ae09-94c7453bd033_1678818986.7001078.jpeg\" alt=\"Cute Robot - Stable diffusion\" width=\"200\"/>\\n\\n## Intuition\\n\\nThe problem requires us to find the average time each machine takes to complete a process in a factory. We are given a table that records the start and end timestamps of each process for each machine. To calculate the average time, we need to subtract the start timestamp from the end timestamp for each process and then find the average time for all processes on each machine.\\n\\n## Approach\\n\\nTo solve the problem, we can use the following approach:\\n\\n1. Join the `Activity` table with itself, denoting the first occurrence as `a` and the second occurrence as `b`.\\n2. Use the `JOIN` condition to match the rows with the same `machine_id`, `process_id`, and activity types \\'start\\' and \\'end\\'.\\n3. Calculate the time taken for each process by subtracting the start timestamp (`a.timestamp`) from the end timestamp (`b.timestamp`).\\n4. Use the `GROUP BY` clause to group the results by `machine_id`.\\n5. Apply the `AVG` function on the time taken for each machine to calculate the average time.\\n6. Round the average time to 3 decimal places using the `ROUND` function.\\n7. Select the `machine_id` and the rounded average time as `processing_time`.\\n\\nThe SQL query for the above approach is as follows:\\n\\n```sql\\nSELECT a.machine_id, ROUND(AVG(b.timestamp - a.timestamp), 3) AS processing_time\\nFROM Activity a\\nJOIN Activity b ON a.machine_id = b.machine_id AND a.process_id = b.process_id AND a.activity_type = \\'start\\' AND b.activity_type = \\'end\\'\\nGROUP BY a.machine_id;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3558610,
                "title": "easy-sql-code",
                "content": "\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT \\n    machine_id,\\n    ROUND(AVG(IF(activity_type = \"end\", timestamp, -timestamp)) * 2, 3) AS processing_time\\nFROM Activity\\nGROUP BY machine_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT \\n    machine_id,\\n    ROUND(AVG(IF(activity_type = \"end\", timestamp, -timestamp)) * 2, 3) AS processing_time\\nFROM Activity\\nGROUP BY machine_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3815801,
                "title": "easy-mysql-solution",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nYou are performing a self-join on the Activity table using the aliases \"a\" and \"b\" to join based on machine_id and process_id.\\n\\nYou use the condition \"b.activity_type = \\'end\\' AND a.activity_type = \\'start\\'\" in the WHERE clause to ensure that you are only considering pairs where the \\'start\\' activity comes before the \\'end\\' activity for each (machine_id, process_id) pair.\\n\\nNext, you GROUP BY a.machine_id to group the results by machine_id.\\n\\nInside the SELECT statement, you calculate the average processing time for each machine using \"AVG(b.timestamp - a.timestamp)\" and round the result to 3 decimal places using the ROUND function.\\n\\n# Code\\n```\\nSelect a.machine_id , ROUND(AVG(b.timestamp-a.timestamp),3) AS processing_time \\nFROM Activity AS a JOIN Activity AS b ON\\na.machine_id = b.machine_id AND\\na.process_id = b.process_id WHERE\\nb.activity_type = \\'end\\' AND A.activity_type =\\'start\\' \\nGROUP BY a.machine_id;\\n\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\nSelect a.machine_id , ROUND(AVG(b.timestamp-a.timestamp),3) AS processing_time \\nFROM Activity AS a JOIN Activity AS b ON\\na.machine_id = b.machine_id AND\\na.process_id = b.process_id WHERE\\nb.activity_type = \\'end\\' AND A.activity_type =\\'start\\' \\nGROUP BY a.machine_id;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3760156,
                "title": "really-easy-solution-without-any-join",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nSo, the question asked about the average time each machine takes to complete a process. Therefore, what we can do is that we can group by each machine, then find all of the \"start\" and \"end\" activity, combining them together. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nFirst, we find the sum for all of the activity_type, however, when activity_type = \"start\" then the number is negative. \\n\\n```\\nSELECT machine_id, ROUND(SUM(CASE WHEN activity_type = \"start\" THEN -timestamp\\n            WHEN activity_type = \"end\" THEN timestamp\\n            END), 3)\\nAS processing_time\\nFROM Activity\\nGROUP BY machine_id\\n```\\n\\nAfter finding the total sum, then what we need to do is to find the average. The easy way we can do it is to find the distinct count for the process_id, since it can show the total count easily for each machine_id. The output will be:  \\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT machine_id, ROUND(SUM(CASE WHEN activity_type = \"start\" THEN -timestamp\\n            WHEN activity_type = \"end\" THEN timestamp\\n            END) / COUNT(DISTINCT process_id), 3)\\nAS processing_time\\nFROM Activity\\nGROUP BY machine_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT machine_id, ROUND(SUM(CASE WHEN activity_type = \"start\" THEN -timestamp\\n            WHEN activity_type = \"end\" THEN timestamp\\n            END), 3)\\nAS processing_time\\nFROM Activity\\nGROUP BY machine_id\\n```\n```\\n# Write your MySQL query statement below\\nSELECT machine_id, ROUND(SUM(CASE WHEN activity_type = \"start\" THEN -timestamp\\n            WHEN activity_type = \"end\" THEN timestamp\\n            END) / COUNT(DISTINCT process_id), 3)\\nAS processing_time\\nFROM Activity\\nGROUP BY machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587805,
                "title": "mysql-solution-for-average-time-of-process-per-machine-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe query aims to calculate the average time taken by each machine to complete a process. It involves retrieving the start and end timestamps for each process on each machine and then calculating the average processing time for each machine.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The inner subquery groups the activity records by machine_id and process_id and uses conditional statements (CASE WHEN) to determine the start and end timestamps for each process.\\n1. The subquery calculates the maximum start timestamp and maximum end timestamp for each process using the MAX() function.\\n1. The outer query uses the results from the subquery and calculates the average processing time for each machine by subtracting the start time from the end time.\\n1. The ROUND() function is used to round the average processing time to 3 decimal places.\\n1. Finally, the outer query groups the results by machine_id and retrieves the machine ID along with the corresponding average processing time.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this query depends on the number of records in the Activity table. Let\\'s denote this number as N.\\n\\n- The inner subquery performs a grouping operation on the Activity table, which requires iterating through all N records. Therefore, its time complexity is O(N).\\n- The outer query performs a grouping operation on the results of the subquery, which also requires iterating through all N records. Thus, its time complexity is O(N).\\nOverall, the time complexity of the query is O(N).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is determined by the storage of the intermediate subquery results and the final result set. Since the subquery groups the records by machine_id and process_id, the number of rows in the subquery result will be equal to or less than the number of records in the Activity table. Therefore, the space complexity is O(N) to store the intermediate subquery results. The final result set will contain a row for each unique machine_id, so its space complexity is O(M), where M is the number of unique machines.\\nHence, the overall space complexity is O(N + M).\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT machine_id, ROUND(AVG(end_time - start_time), 3) AS processing_time\\nFROM (\\n    SELECT machine_id, process_id, MAX(CASE WHEN activity_type = \\'start\\' THEN timestamp END) AS start_time,\\n           MAX(CASE WHEN activity_type = \\'end\\' THEN timestamp END) AS end_time\\n    FROM Activity\\n    GROUP BY machine_id, process_id\\n) AS subquery\\nGROUP BY machine_id;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT machine_id, ROUND(AVG(end_time - start_time), 3) AS processing_time\\nFROM (\\n    SELECT machine_id, process_id, MAX(CASE WHEN activity_type = \\'start\\' THEN timestamp END) AS start_time,\\n           MAX(CASE WHEN activity_type = \\'end\\' THEN timestamp END) AS end_time\\n    FROM Activity\\n    GROUP BY machine_id, process_id\\n) AS subquery\\nGROUP BY machine_id;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3583754,
                "title": "the-solution-to-oracle-average-time-of-process-per-machine-problem-beats-50-72-in-my-case",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI decided to divide problem into subqueries the following manner. Becaue this way we can solve our issue more effectively and intuitively.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirstly we should find out the start and end timestamps where each process ends and starts accordingly. We could do this by the following subquery with grouping by end_time, start_time. Where MAX and MIN functions will let us find the appropriate timestamps.\\n\\n# Code \\n\\n```\\nSELECT machine_id, process_id,\\n    MIN(timestamp) AS start_time,\\n    MAX(timestamp) AS end_time\\nFROM Activity\\nGROUP BY machine_id, process_id\\nORDER BY machine_id, process_id;\\n\\n```\\nKeep it mind this is not strictly necessary to use ORDER BY here. But it gives you more concise and straight ordered result.\\n\\nAfter this you could easily wrap this structure inside the main query in order for you to find the essential result.\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\n\\nSELECT machine_id, ROUND(AVG(end_time - start_time), 3) AS processing_time\\nFROM \\n  (\\n    SELECT machine_id, process_id,\\n      MIN(timestamp) AS start_time,\\n      MAX(timestamp) AS end_time\\n    FROM Activity\\n    GROUP BY machine_id, process_id\\n    ORDER BY machine_id, process_id\\n  ) \\nGROUP BY machine_id\\nORDER BY machine_id;\\n\\n```\\n\\nAs you can see, we round our AVG value so as to get the appropriate outcome. And actually we also should GROUP our result using GROUP BY and ORDER BY.\\n\\nThank you. Feel free to leave your comments.",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nSELECT machine_id, process_id,\\n    MIN(timestamp) AS start_time,\\n    MAX(timestamp) AS end_time\\nFROM Activity\\nGROUP BY machine_id, process_id\\nORDER BY machine_id, process_id;\\n\\n```\n```\\n/* Write your PL/SQL query statement below */\\n\\nSELECT machine_id, ROUND(AVG(end_time - start_time), 3) AS processing_time\\nFROM \\n  (\\n    SELECT machine_id, process_id,\\n      MIN(timestamp) AS start_time,\\n      MAX(timestamp) AS end_time\\n    FROM Activity\\n    GROUP BY machine_id, process_id\\n    ORDER BY machine_id, process_id\\n  ) \\nGROUP BY machine_id\\nORDER BY machine_id;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3578548,
                "title": "simple-sql-solution",
                "content": "# Code\\n```\\nSelect s.machine_id, \\n        round(avg(e.timestamp-s.timestamp), 3) as processing_time\\nfrom Activity s \\njoin Activity e\\non s.machine_id = e.machine_id \\nand s.process_id = e.process_id\\nand s.activity_type = \\'start\\' \\nand e.activity_type = \\'end\\'\\ngroup by s.machine_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSelect s.machine_id, \\n        round(avg(e.timestamp-s.timestamp), 3) as processing_time\\nfrom Activity s \\njoin Activity e\\non s.machine_id = e.machine_id \\nand s.process_id = e.process_id\\nand s.activity_type = \\'start\\' \\nand e.activity_type = \\'end\\'\\ngroup by s.machine_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3571590,
                "title": "easy-solution-using-subquery",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMake a subquery which will extract start and end points for every process in every machine using group by machine_id and process_id. Then goes an easy part. We just selct avg of end-start over our subquery and using group by machide_id. \\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect machine_id, round(avg(end-start), 3) as processing_time\\n\\nfrom (select machine_id, process_id ,max(timestamp) as end, min(timestamp) as start from Activity group by machine_id, process_id) as a \\ngroup by machine_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect machine_id, round(avg(end-start), 3) as processing_time\\n\\nfrom (select machine_id, process_id ,max(timestamp) as end, min(timestamp) as start from Activity group by machine_id, process_id) as a \\ngroup by machine_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3083603,
                "title": "mysql-clear-and-simple-approach",
                "content": "# Query\\n```\\n# Write your MySQL query statement below\\nWITH start AS (\\n    SELECT machine_id, process_id, activity_type, timestamp FROM Activity\\n    WHERE activity_type=\\'start\\'\\n),\\nends AS (\\n    SELECT machine_id, process_id, activity_type, timestamp FROM Activity\\n    WHERE activity_type=\\'end\\'\\n)\\n\\nSELECT s.machine_id, \\n       ROUND((SUM(e.timestamp) - SUM(s.timestamp))/COUNT(e.machine_id), 3) AS processing_time\\nFROM start s\\nJOIN ends e\\nON e.machine_id = s.machine_id AND e.process_id = s.process_id\\nGROUP BY e.machine_id\\n\\n```\\n\\n\\nThe above query might seem long and there are other approaches to obtain the solution(using JOINS). I just want to implement distinct queries in each problem.\\n\\n*if you find its helpful* **please upvote**",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nWITH start AS (\\n    SELECT machine_id, process_id, activity_type, timestamp FROM Activity\\n    WHERE activity_type=\\'start\\'\\n),\\nends AS (\\n    SELECT machine_id, process_id, activity_type, timestamp FROM Activity\\n    WHERE activity_type=\\'end\\'\\n)\\n\\nSELECT s.machine_id, \\n       ROUND((SUM(e.timestamp) - SUM(s.timestamp))/COUNT(e.machine_id), 3) AS processing_time\\nFROM start s\\nJOIN ends e\\nON e.machine_id = s.machine_id AND e.process_id = s.process_id\\nGROUP BY e.machine_id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3756397,
                "title": "mysql-solution-using-cross-join-90-28",
                "content": "# Code\\n```\\nSELECT a.machine_id, ROUND(AVG(b.timestamp - a.timestamp), 3) AS processing_time\\nFROM Activity a, Activity b\\nWHERE a.activity_type = \\'start\\' \\n  AND b.activity_type = \\'end\\'\\n  AND a.machine_id = b.machine_id \\n  AND a.process_id = b.process_id\\nGROUP BY a.machine_id;\\n```\\n![laptop-cat.jpg](https://assets.leetcode.com/users/images/d6b89ae0-1c8f-4340-b3e1-b877c5762c72_1689187902.2983496.jpeg)\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT a.machine_id, ROUND(AVG(b.timestamp - a.timestamp), 3) AS processing_time\\nFROM Activity a, Activity b\\nWHERE a.activity_type = \\'start\\' \\n  AND b.activity_type = \\'end\\'\\n  AND a.machine_id = b.machine_id \\n  AND a.process_id = b.process_id\\nGROUP BY a.machine_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3705567,
                "title": "easily-understandable-solution",
                "content": "# Code\\n```\\nselect a.machine_id ,round(avg(b.timestamp-a.timestamp),3) as processing_time \\nfrom Activity a join Activity b on a.machine_id= b.machine_id and a.process_id=b.process_id \\nwhere a.activity_type=\\'start\\' and b.activity_type=\\'end\\'\\ngroup by machine_id \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect a.machine_id ,round(avg(b.timestamp-a.timestamp),3) as processing_time \\nfrom Activity a join Activity b on a.machine_id= b.machine_id and a.process_id=b.process_id \\nwhere a.activity_type=\\'start\\' and b.activity_type=\\'end\\'\\ngroup by machine_id \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3556555,
                "title": "using-case-sum-count-distinct",
                "content": "# Intuition\\nCASE for seperating start & end values from activity table.\\nSUM for finding the difference.\\nCOUNT * DISTINCT for finding average.\\nROUND to round off values.\\n\\n# Approach\\nIn order to take average processing time, first step is to seperate the start & end time which is done using CASE.After finding the difference using CASE statement, to find average divide the difference with DISTINCT process_id\\'s which need to be grouped by machine_id.\\nFinal step is to reound off the values.\\n\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nSELECT machine_id,\\nROUND((SUM(CASE \\nWHEN activity_type = \\'end\\' THEN timestamp\\nEND) -\\nSUM(CASE \\nWHEN activity_type = \\'start\\' THEN timestamp\\nEND)) / COUNT(DISTINCT process_id),3)\\nAS processing_time\\nFROM Activity\\nGROUP BY machine_id\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nSELECT machine_id,\\nROUND((SUM(CASE \\nWHEN activity_type = \\'end\\' THEN timestamp\\nEND) -\\nSUM(CASE \\nWHEN activity_type = \\'start\\' THEN timestamp\\nEND)) / COUNT(DISTINCT process_id),3)\\nAS processing_time\\nFROM Activity\\nGROUP BY machine_id\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1792152,
                "title": "solution-using-avg-round",
                "content": "\\'\\'\\'\\nSELECT machine_id, ROUND((AVG(CASE WHEN activity_type = \\'end\\' THEN timestamp ELSE NULL END))-AVG((CASE WHEN activity_type = \\'start\\' THEN timestamp ELSE NULL END)), 3) AS processing_time\\nFROM Activity\\nGROUP BY machine_id\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\nSELECT machine_id, ROUND((AVG(CASE WHEN activity_type = \\'end\\' THEN timestamp ELSE NULL END))-AVG((CASE WHEN activity_type = \\'start\\' THEN timestamp ELSE NULL END)), 3) AS processing_time\\nFROM Activity\\nGROUP BY machine_id\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 942098,
                "title": "easy-solution-with-window-function-100-no-joins",
                "content": "First create the query to determine the delta table. This can be done in a simple way with a window function. First order by activity within a partition, then subtract the lagged value (previous row) so that for the activity = \\'end\\' you will have the value you need and for the \\'start\\' you will have null values\\n```\\nselect machine_id, timestamp - lag(timestamp,1) over (partition by machine_id, process_id order by activity_type) as delta \\nfrom Activity as DeltaTabl\\n```\\n\\nNow all you have left to do is simply select the non-null entries and round, so the final query should look like: \\n```\\nselect machine_id, round(avg(delta),3) as processing_time from \\n(select machine_id, timestamp - lag(timestamp,1) over (partition by machine_id, process_id order by activity_type) as delta \\nfrom Activity as DeltaTable) \\nas result where delta is not null group by machine_id\\n```\\n",
                "solutionTags": [],
                "code": "```\\nselect machine_id, timestamp - lag(timestamp,1) over (partition by machine_id, process_id order by activity_type) as delta \\nfrom Activity as DeltaTabl\\n```\n```\\nselect machine_id, round(avg(delta),3) as processing_time from \\n(select machine_id, timestamp - lag(timestamp,1) over (partition by machine_id, process_id order by activity_type) as delta \\nfrom Activity as DeltaTable) \\nas result where delta is not null group by machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4039151,
                "title": "simplified-approach-using-case",
                "content": "# Approach\\n- Start by selecting the `machine_id` and calculating the time taken for each process:\\n  - Use a `CASE` statement to distinguish between \\'start\\' and \\'end\\' activities.\\n  - For \\'start\\' activities, multiply the `timestamp` by -1 to prepare for subtraction in the next step.\\n- Sum the calculated times for each `machine_id`.\\n- Divide the sum by the count of distinct `process_id` to get the average processing time.\\n- Round the result to 3 decimal places using the `ROUND` function.\\n- Group the results by `machine_id`.\\n\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\n\\nselect machine_id, \\nround(\\n  sum(case when activity_type = \\'start\\' then timestamp*-1 \\n  else timestamp end) / count(distinct process_id), 3) as processing_time \\nfrom Activity\\ngroup by machine_id\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "MS SQL Server",
                    "Database"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\n\\nselect machine_id, \\nround(\\n  sum(case when activity_type = \\'start\\' then timestamp*-1 \\n  else timestamp end) / count(distinct process_id), 3) as processing_time \\nfrom Activity\\ngroup by machine_id\\n\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3788077,
                "title": "sql",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nselect a.machine_id ,round(avg(b.timestamp-a.timestamp),3) as processing_time \\nfrom Activity a join Activity b on a.machine_id= b.machine_id and a.process_id=b.process_id \\nwhere a.activity_type=\\'start\\' and b.activity_type=\\'end\\'\\ngroup by machine_id \\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect a.machine_id ,round(avg(b.timestamp-a.timestamp),3) as processing_time \\nfrom Activity a join Activity b on a.machine_id= b.machine_id and a.process_id=b.process_id \\nwhere a.activity_type=\\'start\\' and b.activity_type=\\'end\\'\\ngroup by machine_id \\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3762798,
                "title": "simple-solution-with-using-cte-s",
                "content": "\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nwith x as (select machine_id, round(sum(timestamp), 3) as total_starttime, count(machine_id) as machine_count from activity\\nwhere activity_type = \\'start\\'\\ngroup by machine_id),\\n\\ny as (select machine_id, round(sum(timestamp), 3) as total_endtime, count(machine_id) as machine_count from activity\\nwhere activity_type = \\'end\\'\\ngroup by machine_id)\\n\\nselect x.machine_id, round((y.total_endtime - x.total_starttime)/x.machine_count, 3) as processing_time from x\\njoin y on x.machine_id = y.machine_id\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nwith x as (select machine_id, round(sum(timestamp), 3) as total_starttime, count(machine_id) as machine_count from activity\\nwhere activity_type = \\'start\\'\\ngroup by machine_id),\\n\\ny as (select machine_id, round(sum(timestamp), 3) as total_endtime, count(machine_id) as machine_count from activity\\nwhere activity_type = \\'end\\'\\ngroup by machine_id)\\n\\nselect x.machine_id, round((y.total_endtime - x.total_starttime)/x.machine_count, 3) as processing_time from x\\njoin y on x.machine_id = y.machine_id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3646378,
                "title": "solution-using-with-and-join",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\nwith starts as (\\n  select machine_id , process_id, timestamp from activity\\n  where activity_type = \\'start\\'\\n),ends as\\n(select machine_id , process_id , timestamp from activity \\nwhere activity_type = \\'end\\')\\nselect e.machine_id , round(avg(e.timestamp - s.timestamp),3)processing_time from starts s\\njoin ends e\\non s.machine_id = e.machine_id and s.process_id = e.process_id\\ngroup by e.machine_id\\n\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nwith starts as (\\n  select machine_id , process_id, timestamp from activity\\n  where activity_type = \\'start\\'\\n),ends as\\n(select machine_id , process_id , timestamp from activity \\nwhere activity_type = \\'end\\')\\nselect e.machine_id , round(avg(e.timestamp - s.timestamp),3)processing_time from starts s\\njoin ends e\\non s.machine_id = e.machine_id and s.process_id = e.process_id\\ngroup by e.machine_id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3589826,
                "title": "very-easy-mysql-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Firstly, we perform a SELF JOIN on table Activity in order to get the timestamps for the start and the end of the process.\\n- In order to do that, we execute the query on the condition that the machine_id and process_id for the two aliases is the same.\\n- We then use average the timestamp for the same machine using GROUP BY clause and round the timestamp to 3 decimals.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. In the SELECT statement, we retrieve the machine_id and the average of the timestamp for every machine upto 3 decimals using the **AVG() and ROUND()** functions.\\n2. In the FROM statement, we perform a **SELF JOIN** on the table Activity, with **aliases A1 and A2**, on the condition that **A1.process_id = A2.process_id AND A1.machine_id = A2.machine_id**. \\n3. Also, we put a condition that **A2.timestamp > A1.timestamp** in order to obtain the **end and start** for the same process running on the same machine as given in step 2.\\n4. We then use **GROUP BY to group the timestamps by machine_id** because we need the timestamp for every machine.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT A1.machine_id, ROUND(AVG(A2.timestamp-A1.timestamp),3) as processing_time\\nFROM Activity as A1 INNER JOIN Activity as A2\\nON A1.process_id = A2.process_id \\nAND A1.machine_id = A2.machine_id\\nAND A2.timestamp > A1.timestamp\\nGROUP BY machine_id;\\n```\\n# Note\\nPlease upvote if you find my solution helpful. If you have any doubts, suggestion or want to discuss any solution, comment it. If you wish to discuss other related topics, feel free to message me on LinkedIn, https://leetcode.com/prathams29/",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT A1.machine_id, ROUND(AVG(A2.timestamp-A1.timestamp),3) as processing_time\\nFROM Activity as A1 INNER JOIN Activity as A2\\nON A1.process_id = A2.process_id \\nAND A1.machine_id = A2.machine_id\\nAND A2.timestamp > A1.timestamp\\nGROUP BY machine_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3577943,
                "title": "query-for-all-3-db-simple-query-using-self-join-and-then-group-by-on-machine-id",
                "content": "\\n```\\nselect a1.machine_id as MACHINE_ID, round(avg(a2.TIMESTAMP - a1.TIMESTAMP),3) as processing_time \\nfrom Activity a1 inner join Activity a2 \\non a1.machine_id = a2.machine_id and a1.process_id=a2.process_id and a1.ACTIVITY_TYPE not in (a2.ACTIVITY_TYPE,\\'end\\') \\ngroup by a1.machine_id;\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Oracle"
                ],
                "code": "```\\nselect a1.machine_id as MACHINE_ID, round(avg(a2.TIMESTAMP - a1.TIMESTAMP),3) as processing_time \\nfrom Activity a1 inner join Activity a2 \\non a1.machine_id = a2.machine_id and a1.process_id=a2.process_id and a1.ACTIVITY_TYPE not in (a2.ACTIVITY_TYPE,\\'end\\') \\ngroup by a1.machine_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3438290,
                "title": "2-solution-with-lead-over-or-simple-sum-and-count-sql-server",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\n/* Write your T-SQL query statement below */\\r\\n\\r\\n\\r\\n--SOLUTION WITH [ LEAD() OVER() ]\\r\\n\\r\\nWITH CTE AS (\\r\\n        SELECT\\r\\n            machine_id,\\r\\n            timestamp,\\r\\n            lead(timestamp) OVER(PARTITION BY machine_id,process_id ORDER BY activity_type DESC) nextActive\\r\\n        FROM\\r\\n            Activity\\r\\n)\\r\\nSELECT\\r\\n    machine_id,\\r\\n    ROUND(SUM(nextActive - timestamp) / COUNT( machine_id),3) processing_time\\r\\nFROM\\r\\n    CTE\\r\\nWHERE\\r\\n    nextActive IS NOT NULL\\r\\nGROUP BY\\r\\n    machine_id\\r\\n```\\r\\n\\r\\n\\r\\n--SOLUTION WITH SIMPLE SUM AND COUNT\\r\\n\\r\\nWITH CTE AS (SELECT\\r\\n    machine_id,\\r\\n    SUM(CASE WHEN activity_type = \\'start\\' THEN timestamp ELSE NULL END) SUMSTART,\\r\\n    SUM(CASE WHEN activity_type = \\'end\\' THEN timestamp ELSE NULL END) SUMEND,\\r\\n    COUNT(machine_id) / 2 CountM\\r\\nFROM\\r\\n    Activity\\r\\nGROUP BY \\r\\n    machine_id\\r\\n)\\r\\nSELECT\\r\\n    machine_id,\\r\\n    ROUND((SUMEND - SUMSTART) / CountM,3) processing_time\\r\\nFROM\\r\\n    CTE",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\r\\n/* Write your T-SQL query statement below */\\r\\n\\r\\n\\r\\n--SOLUTION WITH [ LEAD() OVER() ]\\r\\n\\r\\nWITH CTE AS (\\r\\n        SELECT\\r\\n            machine_id,\\r\\n            timestamp,\\r\\n            lead(timestamp) OVER(PARTITION BY machine_id,process_id ORDER BY activity_type DESC) nextActive\\r\\n        FROM\\r\\n            Activity\\r\\n)\\r\\nSELECT\\r\\n    machine_id,\\r\\n    ROUND(SUM(nextActive - timestamp) / COUNT( machine_id),3) processing_time\\r\\nFROM\\r\\n    CTE\\r\\nWHERE\\r\\n    nextActive IS NOT NULL\\r\\nGROUP BY\\r\\n    machine_id\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2443220,
                "title": "super-easy-solution",
                "content": "```\\n# Write your MySQL query statement below\\nwith t1 as \\n(\\n    select machine_id, process_id, timestamp as start_time from Activity\\n    where activity_type = \\'start\\'\\n    ),\\nt2 as \\n(\\n    select machine_id, process_id, timestamp as end_time from Activity\\n    where activity_type = \\'end\\'\\n    )\\nselect t1.machine_id,\\nround(avg(end_time-start_time), 3) as processing_time\\nfrom t1\\njoin t2 on t1.machine_id=t2.machine_id and t1.process_id=t2.process_id\\ngroup by t1.machine_id\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nwith t1 as \\n(\\n    select machine_id, process_id, timestamp as start_time from Activity\\n    where activity_type = \\'start\\'\\n    ),\\nt2 as \\n(\\n    select machine_id, process_id, timestamp as end_time from Activity\\n    where activity_type = \\'end\\'\\n    )\\nselect t1.machine_id,\\nround(avg(end_time-start_time), 3) as processing_time\\nfrom t1\\njoin t2 on t1.machine_id=t2.machine_id and t1.process_id=t2.process_id\\ngroup by t1.machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1937836,
                "title": "mysql-just-need-4-lines",
                "content": "select a.machine_id, round(avg(b.timestamp - a.timestamp),3) as processing_time\\nfrom Activity a, Activity b\\nwhere a.machine_id = b.machine_id and a.activity_type = \\'start\\' and b.activity_type = \\'end\\'\\ngroup by a.machine_id\\n",
                "solutionTags": [],
                "code": "select a.machine_id, round(avg(b.timestamp - a.timestamp),3) as processing_time\\nfrom Activity a, Activity b\\nwhere a.machine_id = b.machine_id and a.activity_type = \\'start\\' and b.activity_type = \\'end\\'\\ngroup by a.machine_id\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1531983,
                "title": "mysql-1-cte-no-joins",
                "content": "```\\nwith cte as (\\nSELECT machine_id, process_id, min(case when activity_type = \\'start\\' then timestamp end) as start_time, min(case when activity_type = \\'end\\' then timestamp end) as end_time\\nFROM activity\\ngroup by 1,2\\n)\\nSELECT machine_id, round(avg(end_time - start_time),3) as processing_time\\nFROM cte \\ngroup by machine_id\\n```",
                "solutionTags": [],
                "code": "```\\nwith cte as (\\nSELECT machine_id, process_id, min(case when activity_type = \\'start\\' then timestamp end) as start_time, min(case when activity_type = \\'end\\' then timestamp end) as end_time\\nFROM activity\\ngroup by 1,2\\n)\\nSELECT machine_id, round(avg(end_time - start_time),3) as processing_time\\nFROM cte \\ngroup by machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1289256,
                "title": "simple-solution-without-temp-table",
                "content": "```\\n/* Write your T-SQL query statement below */\\nSELECT DISTINCT A.machine_id, ROUND(AVG(B.timestamp - A.timestamp), 3) AS processing_time\\nFROM Activity AS A\\nINNER JOIN Activity AS B\\nON A.machine_id = B.machine_id AND A.process_id = B.process_id AND A.activity_type = \\'start\\' AND B.activity_type = \\'end\\'\\nGROUP BY A.machine_id\\nORDER BY A.machine_id\\n```\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nSELECT DISTINCT A.machine_id, ROUND(AVG(B.timestamp - A.timestamp), 3) AS processing_time\\nFROM Activity AS A\\nINNER JOIN Activity AS B\\nON A.machine_id = B.machine_id AND A.process_id = B.process_id AND A.activity_type = \\'start\\' AND B.activity_type = \\'end\\'\\nGROUP BY A.machine_id\\nORDER BY A.machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1232314,
                "title": "simple-mysql-solution-using-max-and-min",
                "content": "```\\nSELECT a.machine_id, ROUND(AVG(a.duration), 3) AS processing_time\\nFROM (\\n    SELECT machine_id, process_id, (MAX(timestamp) - MIN(timestamp)) AS duration\\n    FROM Activity\\n    GROUP BY 1, 2\\n) a\\nGROUP BY a.machine_id\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT a.machine_id, ROUND(AVG(a.duration), 3) AS processing_time\\nFROM (\\n    SELECT machine_id, process_id, (MAX(timestamp) - MIN(timestamp)) AS duration\\n    FROM Activity\\n    GROUP BY 1, 2\\n) a\\nGROUP BY a.machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 941930,
                "title": "no-joins-no-cte-simple-solution-group-by-case",
                "content": "```\\nSELECT machine_id, ROUND(avg(end_time - start_time),3) as processing_time FROM (\\n    SELECT \\n    machine_id,\\n    process_id,\\n    SUM(CASE WHEN activity_type = \"start\"  then timestamp END) as start_time,\\n    SUM(CASE WHEN activity_type = \"end\"  then timestamp END) as end_time\\n    FROM Activity\\n    GROUP BY 1,2) as f\\nGROUP BY 1\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT machine_id, ROUND(avg(end_time - start_time),3) as processing_time FROM (\\n    SELECT \\n    machine_id,\\n    process_id,\\n    SUM(CASE WHEN activity_type = \"start\"  then timestamp END) as start_time,\\n    SUM(CASE WHEN activity_type = \"end\"  then timestamp END) as end_time\\n    FROM Activity\\n    GROUP BY 1,2) as f\\nGROUP BY 1\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4077402,
                "title": "pandas-sql-easy-average-time-of-process-per-machine",
                "content": "[see the Successfully Accepted Submission](https://leetcode.com/submissions/detail/1056441593/)\\n\\n```\\nimport pandas as pd\\n\\ndef get_average_time(activity: pd.DataFrame) -> pd.DataFrame:\\n    \\n    # First, we filter rows from the activity DataFrame where the value in the \"activity_type\" column is equal to \\'start\\'\\n    start_activities = activity[activity[\\'activity_type\\'] == \\'start\\']\\n\\n     # Meanwhile, we also filter rows from the activity DataFrame where the value in the \"activity_type\" column is equal to \\'end\\'\\n    end_activities = activity[activity[\\'activity_type\\'] == \\'end\\']\\n\\n    # Then, we merge two DataFrames, `start_activities` and `end_activities`, based on the columns `machine_id` and `process_id`. Also, as a result it adds the suffixes \\'_start\\', \\'_end\\' to the columns to distinguish them after merging. \\n    merged_start_end = start_activities.merge(\\n        end_activities,\\n        on=[\\'machine_id\\', \\'process_id\\'],\\n        suffixes=(\\'_start\\', \\'_end\\')\\n    )\\n\\n    # After that, we calculate the `processing_time` as the difference between timestamps by  calculating the time duration between two the columns, specifically \"timestamp_end\" and \"timestamp_start\"\\n    merged_start_end[\\'processing_time\\'] = merged_start_end[\\'timestamp_end\\'] - merged_start_end[\\'timestamp_start\\']\\n    \\n\\n    # Next, we group data by the \"machine_id\" column and then select a specific column (\"processing_time\") from within each group.\\n    grouped_start_end = merged_start_end.groupby(\\'machine_id\\')[\\'processing_time\\']\\n    \\n    # After grouping by `machine_id`, the average `processing_time` is calculated.\\n    average_time = grouped_start_end.mean()\\n    \\n    # Now, we have to transform the grouped DataFrame back into a more conventional format, so we will reset the index after the Series has been grouped above. Because, after grouping the index often changes. By default, pandas assigns a new index to the resulting grouped DataFrame. This new index is typically a multi-level index, with one level for each grouping key. The original index becomes part of the DataFrame as metadata.\\n    structured_df = average_time.reset_index()\\n    \\n    # Finally, we  round the numerical values in the structured_df. Because, in the task it is asked to that the average time should be rounded to 3 decimal places.\\n    average_time_to_complete = structured_df.round(3)\\n\\n    return average_time_to_complete\\n    \\n```\\n\\n**SQL**\\n[see the Successfully Accepted Submission](https://leetcode.com/submissions/detail/1061746957/)\\n\\n```\\nSELECT a.machine_id, ROUND(SUM((c.timestamp - a.timestamp)) / COUNT(a.machine_id),3) as processing_time  \\n\\nFROM Activity as a \\n\\nJOIN Activity as c ON a.machine_id = c.machine_id \\nand a.process_id = c.process_id \\nand a.activity_type = \"start\" \\nand c.activity_type = \"end\"\\n\\nGROUP BY a.machine_id\\n```\\n\\n```\\n-- Select \\'machine_id\\' and calculate the average processing time for each machine\\n-- The processing time is calculated as the difference in timestamps between \"start\" and \"end\" activities\\nSELECT a.machine_id,\\n        ROUND(SUM((c.timestamp - a.timestamp)) / COUNT(a.machine_id), 3) as processing_time  \\n\\n-- Retrieve data from the \\'Activity\\' table and alias it as \\'a\\'\\nFROM Activity as a \\n\\n-- Join the \\'Activity\\' table with itself as \\'c\\' based on specific conditions\\n-- - The same \\'machine_id\\'\\n-- - The same \\'process_id\\'\\n-- - \\'activity_type\\' is \"start\" for \\'a\\' and \"end\" for \\'c\\'\\nJOIN Activity as c ON a.machine_id = c.machine_id \\nand a.process_id = c.process_id \\nand a.activity_type = \"start\" \\nand c.activity_type = \"end\"\\n\\n-- Group the results by \\'machine_id\\' to calculate the average processing time for each machine\\nGROUP BY a.machine_id;\\n```\\n\\n![image](https://assets.leetcode.com/users/images/04dd34e1-d7b5-4481-857e-8461fc196ece_1695399610.5759363.jpeg)\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef get_average_time(activity: pd.DataFrame) -> pd.DataFrame:\\n    \\n    # First, we filter rows from the activity DataFrame where the value in the \"activity_type\" column is equal to \\'start\\'\\n    start_activities = activity[activity[\\'activity_type\\'] == \\'start\\']\\n\\n     # Meanwhile, we also filter rows from the activity DataFrame where the value in the \"activity_type\" column is equal to \\'end\\'\\n    end_activities = activity[activity[\\'activity_type\\'] == \\'end\\']\\n\\n    # Then, we merge two DataFrames, `start_activities` and `end_activities`, based on the columns `machine_id` and `process_id`. Also, as a result it adds the suffixes \\'_start\\', \\'_end\\' to the columns to distinguish them after merging. \\n    merged_start_end = start_activities.merge(\\n        end_activities,\\n        on=[\\'machine_id\\', \\'process_id\\'],\\n        suffixes=(\\'_start\\', \\'_end\\')\\n    )\\n\\n    # After that, we calculate the `processing_time` as the difference between timestamps by  calculating the time duration between two the columns, specifically \"timestamp_end\" and \"timestamp_start\"\\n    merged_start_end[\\'processing_time\\'] = merged_start_end[\\'timestamp_end\\'] - merged_start_end[\\'timestamp_start\\']\\n    \\n\\n    # Next, we group data by the \"machine_id\" column and then select a specific column (\"processing_time\") from within each group.\\n    grouped_start_end = merged_start_end.groupby(\\'machine_id\\')[\\'processing_time\\']\\n    \\n    # After grouping by `machine_id`, the average `processing_time` is calculated.\\n    average_time = grouped_start_end.mean()\\n    \\n    # Now, we have to transform the grouped DataFrame back into a more conventional format, so we will reset the index after the Series has been grouped above. Because, after grouping the index often changes. By default, pandas assigns a new index to the resulting grouped DataFrame. This new index is typically a multi-level index, with one level for each grouping key. The original index becomes part of the DataFrame as metadata.\\n    structured_df = average_time.reset_index()\\n    \\n    # Finally, we  round the numerical values in the structured_df. Because, in the task it is asked to that the average time should be rounded to 3 decimal places.\\n    average_time_to_complete = structured_df.round(3)\\n\\n    return average_time_to_complete\\n    \\n```\n```\\nSELECT a.machine_id, ROUND(SUM((c.timestamp - a.timestamp)) / COUNT(a.machine_id),3) as processing_time  \\n\\nFROM Activity as a \\n\\nJOIN Activity as c ON a.machine_id = c.machine_id \\nand a.process_id = c.process_id \\nand a.activity_type = \"start\" \\nand c.activity_type = \"end\"\\n\\nGROUP BY a.machine_id\\n```\n```\\n-- Select \\'machine_id\\' and calculate the average processing time for each machine\\n-- The processing time is calculated as the difference in timestamps between \"start\" and \"end\" activities\\nSELECT a.machine_id,\\n        ROUND(SUM((c.timestamp - a.timestamp)) / COUNT(a.machine_id), 3) as processing_time  \\n\\n-- Retrieve data from the \\'Activity\\' table and alias it as \\'a\\'\\nFROM Activity as a \\n\\n-- Join the \\'Activity\\' table with itself as \\'c\\' based on specific conditions\\n-- - The same \\'machine_id\\'\\n-- - The same \\'process_id\\'\\n-- - \\'activity_type\\' is \"start\" for \\'a\\' and \"end\" for \\'c\\'\\nJOIN Activity as c ON a.machine_id = c.machine_id \\nand a.process_id = c.process_id \\nand a.activity_type = \"start\" \\nand c.activity_type = \"end\"\\n\\n-- Group the results by \\'machine_id\\' to calculate the average processing time for each machine\\nGROUP BY a.machine_id;\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3932494,
                "title": "solution-using-with-clause",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\nI thout as two table one containing sum of start time and other containig sum of end time  and difference will be the required time and in same we can count distinct process_id. so average can be calculate *(endTime-startTime)/no of distinct process_id*. Then I joined both table on machine_id\\r\\n\\r\\n<!-- # Complexity -->\\r\\n<!-- - Time complexity: -->\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n<!-- - Space complexity: -->\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\n# Write your MySQL query statement below\\r\\nwith t1 as\\r\\n(\\r\\n    select machine_id,count(distinct process_id) as cnt,\\r\\n    Sum(case when activity_type =\\'start\\' then timestamp end) as total_start_time\\r\\n     from Activity \\r\\n    group by machine_id\\r\\n),\\r\\nt2 as(\\r\\n   select machine_id,count(distinct process_id) as cnt,\\r\\n    Sum(case when activity_type =\\'end\\' then timestamp end) as total_end_time\\r\\n     from Activity \\r\\n    group by machine_id\\r\\n)\\r\\nselect t1.machine_id as machine_id ,\\r\\nround((t2.total_end_time-total_start_time)/t1.cnt,3) processing_time  \\r\\nfrom t1 \\r\\njoin t2 on t2.machine_id=t1.t1.machine_id;\\r\\n\\r\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\r\\n# Write your MySQL query statement below\\r\\nwith t1 as\\r\\n(\\r\\n    select machine_id,count(distinct process_id) as cnt,\\r\\n    Sum(case when activity_type =\\'start\\' then timestamp end) as total_start_time\\r\\n     from Activity \\r\\n    group by machine_id\\r\\n),\\r\\nt2 as(\\r\\n   select machine_id,count(distinct process_id) as cnt,\\r\\n    Sum(case when activity_type =\\'end\\' then timestamp end) as total_end_time\\r\\n     from Activity \\r\\n    group by machine_id\\r\\n)\\r\\nselect t1.machine_id as machine_id ,\\r\\nround((t2.total_end_time-total_start_time)/t1.cnt,3) processing_time  \\r\\nfrom t1 \\r\\njoin t2 on t2.machine_id=t1.t1.machine_id;\\r\\n\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3906851,
                "title": "mysql-easy-to-understand",
                "content": "# Approach\\nHere 2 is multiplied with sum value because count will add both start and end timestamp so it will divide the sum value accordingly. \\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect machine_id, round(2 * sum(\\n  case\\n    when activity_type = \\'start\\' then -timestamp\\n    when activity_type = \\'end\\' then timestamp\\n  end\\n) / count(timestamp), 3) as processing_time \\nfrom activity \\ngroup by machine_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect machine_id, round(2 * sum(\\n  case\\n    when activity_type = \\'start\\' then -timestamp\\n    when activity_type = \\'end\\' then timestamp\\n  end\\n) / count(timestamp), 3) as processing_time \\nfrom activity \\ngroup by machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3775028,
                "title": "eassy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect a1.machine_id, round(avg(a2.timestamp-a1.timestamp), 3) as processing_time from Activity a1 join Activity a2 on a1.machine_id=a2.machine_id and a1.process_id=a2.process_id and a1.activity_type=\\'start\\' and a2.activity_type=\\'end\\' group by a1.machine_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect a1.machine_id, round(avg(a2.timestamp-a1.timestamp), 3) as processing_time from Activity a1 join Activity a2 on a1.machine_id=a2.machine_id and a1.process_id=a2.process_id and a1.activity_type=\\'start\\' and a2.activity_type=\\'end\\' group by a1.machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3611036,
                "title": "mssql-1-inner-join-and-no-where",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nSELECT s.machine_id, ROUND(SUM(e.timestamp - s.timestamp) / COUNT(s.process_id), 3) AS processing_time\\nFROM Activity s\\nINNER JOIN Activity e ON s.activity_type = \\'start\\'\\n                    AND e.activity_type=\\'end\\' \\n                    AND e.machine_id = s.machine_id\\n                    AND e.process_id = s.process_id\\nGROUP BY s.machine_id\\n\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nSELECT s.machine_id, ROUND(SUM(e.timestamp - s.timestamp) / COUNT(s.process_id), 3) AS processing_time\\nFROM Activity s\\nINNER JOIN Activity e ON s.activity_type = \\'start\\'\\n                    AND e.activity_type=\\'end\\' \\n                    AND e.machine_id = s.machine_id\\n                    AND e.process_id = s.process_id\\nGROUP BY s.machine_id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3609061,
                "title": "efficient-mysql-query-for-calculating-average-processing-time-per-machine",
                "content": "# Intuition\\nThe goal of the given MySQL query is to calculate the average processing time for each machine based on specific conditions. To achieve this, we need to join the \"Activity\" table with itself, filtering the rows based on activity types and matching machine and process IDs.\\n\\n# Approach\\n1. We start by selecting the columns we need for the result set: A.Machine_id and the rounded average processing time. The ROUND function is used to round the average processing time to three decimal places.\\n2. We specify the table we are fetching data from using the FROM clause, and we use table aliases A and B to refer to two instances of the \"Activity\" table.\\n3. We use the JOIN clause to combine rows from A and B based on specific conditions:\\n    - The ON keyword specifies the conditions for the join.\\n    - We match rows where A.machine_id is equal to B.Machine_id.\\n    - We match rows where A.process_id is equal to B.process_id.\\n    - We include rows where A.Activity_type is \\'start\\' and B.Activity_type is \\'end\\'.\\n1. Finally, we use the GROUP BY clause to group the result set by the first column specified in the SELECT statement, which is A.Machine_id. This groups the data by unique Machine_id values and allows us to calculate the average processing time for each machine.\\n\\n# Code\\n```\\nselect A.Machine_id, round(Avg(B.timestamp-A.timestamp), 3) \\nas processing_time from Activity A join Activity B \\non A.machine_id = B.Machine_id and A.process_id = B.process_id \\nand A.Activity_type = \\'start\\' and B.Activity_type = \\'end\\' \\ngroup by 1;\\n\\n```\\n# Summary\\nTo summarize, this query retrieves data from the \"Activity\" table and calculates the average processing time for each machine. It considers rows where the Activity_type is \\'start\\' for one instance (A) and \\'end\\' for another instance (B). The calculation is based on the difference between the timestamp values of the start and end activities. The result set will consist of the Machine_id and the rounded average processing time for each machine.\\n\\nPlease upvote if you find it helpful. Good luck!",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Oracle"
                ],
                "code": "```\\nselect A.Machine_id, round(Avg(B.timestamp-A.timestamp), 3) \\nas processing_time from Activity A join Activity B \\non A.machine_id = B.Machine_id and A.process_id = B.process_id \\nand A.Activity_type = \\'start\\' and B.Activity_type = \\'end\\' \\ngroup by 1;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3547690,
                "title": "simple-solution-using-temp-table-and-subquery",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nwith start as (select machine_id, process_id, timestamp from Activity where activity_type = \\'start\\' ),\\nstop as (select machine_id, process_id, timestamp from Activity where activity_type = \\'end\\' )\\nselect \\nmachine_id , ROUND(avg(minus),3) as processing_time \\nfrom \\n  (select a.machine_id, b.process_id, b.timestamp - a.timestamp as minus \\n  from start as a \\n  join stop as b \\n  on a.machine_id = b.machine_id and a.process_id = b.process_id ) as a\\ngroup by machine_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nwith start as (select machine_id, process_id, timestamp from Activity where activity_type = \\'start\\' ),\\nstop as (select machine_id, process_id, timestamp from Activity where activity_type = \\'end\\' )\\nselect \\nmachine_id , ROUND(avg(minus),3) as processing_time \\nfrom \\n  (select a.machine_id, b.process_id, b.timestamp - a.timestamp as minus \\n  from start as a \\n  join stop as b \\n  on a.machine_id = b.machine_id and a.process_id = b.process_id ) as a\\ngroup by machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3477853,
                "title": "1661-average-time-of-process-per-machine-solution",
                "content": "# Code\\n```\\nselect a.machine_id,round(avg(b.timestamp-a.timestamp),3) as processing_time\\nfrom Activity a join activity b\\non a.machine_id=b.machine_id and a.process_id=b.process_id\\nwhere a.activity_type=\\'start\\' and b.activity_type=\\'end\\'\\ngroup by machine_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect a.machine_id,round(avg(b.timestamp-a.timestamp),3) as processing_time\\nfrom Activity a join activity b\\non a.machine_id=b.machine_id and a.process_id=b.process_id\\nwhere a.activity_type=\\'start\\' and b.activity_type=\\'end\\'\\ngroup by machine_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3416342,
                "title": "cte-with-window-function",
                "content": "\\r\\n\\r\\n# Code\\r\\n<b> start_ts</b> got via  window function because of \\r\\n<b>ORDER BY DESC \\'S\\'</b>tart letter is higher than <b>\\'E\\'</b>nd\\r\\nOR You could use <b>LAG</b> but with  <b>ORDER BY activity_type  ASC</b>\\r\\n```\\r\\nWITH \\r\\nactivity_lead AS (\\r\\nSELECT *, \\r\\n       LEAD(a.timestamp) OVER (PARTITION BY machine_id, process_id \\r\\n                               ORDER BY activity_type DESC) \\'start_ts\\'\\r\\nFROM Activity a\\r\\n\\r\\n)\\r\\n# here  a.timestamp is end_ts\\r\\nSELECT machine_id, ROUND(AVG(a.timestamp - start_ts), 3) \\'processing_time\\'\\r\\nFROM activity_lead a\\r\\nGROUP BY 1\\r\\n\\r\\n\\r\\n\\r\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\r\\nWITH \\r\\nactivity_lead AS (\\r\\nSELECT *, \\r\\n       LEAD(a.timestamp) OVER (PARTITION BY machine_id, process_id \\r\\n                               ORDER BY activity_type DESC) \\'start_ts\\'\\r\\nFROM Activity a\\r\\n\\r\\n)\\r\\n# here  a.timestamp is end_ts\\r\\nSELECT machine_id, ROUND(AVG(a.timestamp - start_ts), 3) \\'processing_time\\'\\r\\nFROM activity_lead a\\r\\nGROUP BY 1\\r\\n\\r\\n\\r\\n\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2034033,
                "title": "ms-sql-mysql-query-statement",
                "content": "Runtime: 180 ms, faster than 93.18% of MySQL online submissions for Average Time of Process per Machine.\\nMemory Usage: 0B, less than 100.00% of MySQL online submissions for Average Time of Process per Machine.\\n```\\n# Write your MySQL query statement below\\n\\nselect a.machine_id, ROUND(avg(b.timestamp - a.timestamp),3) processing_time\\nfrom Activity a left join Activity b on a.machine_id=b.machine_id and a.process_id=b.process_id and b.activity_type=\\'end\\'\\nwhere a.activity_type=\\'start\\'\\ngroup by a.machine_id\\n```\\n\\nRuntime: 558 ms, faster than 43.09% of MS SQL Server online submissions for Average Time of Process per Machine.\\nMemory Usage: 0B, less than 100.00% of MS SQL Server online submissions for Average Time of Process per Machine.\\n```\\n/* Write your T-SQL query statement below */\\n\\nwith c1 as (\\n\\tselect *\\n\\tfrom Activity\\n\\twhere activity_type=\\'start\\'\\n)\\n, c2 as (\\n\\tselect *\\n\\tfrom Activity\\n\\twhere activity_type=\\'end\\'\\n)\\nselect c1.machine_id, ROUND(avg(c2.timestamp - c1.timestamp),3) processing_time\\nfrom c1, c2\\nwhere c1.machine_id = c2.machine_id and c1.process_id = c2.process_id\\ngroup by c1.machine_id\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect a.machine_id, ROUND(avg(b.timestamp - a.timestamp),3) processing_time\\nfrom Activity a left join Activity b on a.machine_id=b.machine_id and a.process_id=b.process_id and b.activity_type=\\'end\\'\\nwhere a.activity_type=\\'start\\'\\ngroup by a.machine_id\\n```\n```\\n/* Write your T-SQL query statement below */\\n\\nwith c1 as (\\n\\tselect *\\n\\tfrom Activity\\n\\twhere activity_type=\\'start\\'\\n)\\n, c2 as (\\n\\tselect *\\n\\tfrom Activity\\n\\twhere activity_type=\\'end\\'\\n)\\nselect c1.machine_id, ROUND(avg(c2.timestamp - c1.timestamp),3) processing_time\\nfrom c1, c2\\nwhere c1.machine_id = c2.machine_id and c1.process_id = c2.process_id\\ngroup by c1.machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2022816,
                "title": "case-when-solution",
                "content": "```\\nselect machine_id, \\n        round(sum(case when activity_type = \\'end\\' then timestamp else -timestamp end)/\\n        count(distinct process_id),3) as \\'processing_time\\'\\nfrom activity\\ngroup by machine_id\\n```",
                "solutionTags": [],
                "code": "```\\nselect machine_id, \\n        round(sum(case when activity_type = \\'end\\' then timestamp else -timestamp end)/\\n        count(distinct process_id),3) as \\'processing_time\\'\\nfrom activity\\ngroup by machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1962036,
                "title": "runtime-204-ms-shortest-and-simplest",
                "content": "select a.machine_id, round(avg(a.timestamp - b.timestamp),3) as processing_time\\nfrom Activity a\\njoin Activity b on a.machine_id  = b.machine_id and a.activity_type = \\'end\\' and b.activity_type = \\'start\\'\\ngroup by a.machine_id",
                "solutionTags": [],
                "code": "select a.machine_id, round(avg(a.timestamp - b.timestamp),3) as processing_time\\nfrom Activity a\\njoin Activity b on a.machine_id  = b.machine_id and a.activity_type = \\'end\\' and b.activity_type = \\'start\\'\\ngroup by a.machine_id",
                "codeTag": "Unknown"
            },
            {
                "id": 1934115,
                "title": "subquery-mysql",
                "content": "SELECT\\n    machine_id,\\n    ROUND((SUM(processtime)/COUNT(machine_id)),3) AS processing_time\\nFROM    \\n\\n(SELECT\\n    o.machine_id,\\n    o.process_id,\\n    ROUND((o.timestamp - t.timestamp),3) AS processtime\\nFROM Activity o\\nJOIN Activity t\\nON o.machine_id = t.machine_id\\nWHERE o.activity_type = \"end\" AND t.activity_type = \\'start\\' AND o.process_id = t.process_id\\nGROUP BY Machine_id, process_id\\n) AS c\\nGROUP BY machine_id",
                "solutionTags": [],
                "code": "SELECT\\n    machine_id,\\n    ROUND((SUM(processtime)/COUNT(machine_id)),3) AS processing_time\\nFROM    \\n\\n(SELECT\\n    o.machine_id,\\n    o.process_id,\\n    ROUND((o.timestamp - t.timestamp),3) AS processtime\\nFROM Activity o\\nJOIN Activity t\\nON o.machine_id = t.machine_id\\nWHERE o.activity_type = \"end\" AND t.activity_type = \\'start\\' AND o.process_id = t.process_id\\nGROUP BY Machine_id, process_id\\n) AS c\\nGROUP BY machine_id",
                "codeTag": "Unknown"
            },
            {
                "id": 1871386,
                "title": "sql-server-easy-to-read",
                "content": "```\\nselect a.machine_id,  CAST(sum(b.timestamp - a.timestamp)/count(a.process_id) AS DECIMAL(38,3)) as processing_time \\nfrom Activity a\\njoin Activity b\\non a.machine_id  = b.machine_id and a.process_id = b.process_id\\nwhere a.activity_type = \\'start\\' and b.activity_type = \\'end\\'\\ngroup by a.machine_id\\n```",
                "solutionTags": [],
                "code": "```\\nselect a.machine_id,  CAST(sum(b.timestamp - a.timestamp)/count(a.process_id) AS DECIMAL(38,3)) as processing_time \\nfrom Activity a\\njoin Activity b\\non a.machine_id  = b.machine_id and a.process_id = b.process_id\\nwhere a.activity_type = \\'start\\' and b.activity_type = \\'end\\'\\ngroup by a.machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1862686,
                "title": "simple-mysql-98-7-faster",
                "content": "```\\nselect \\n    machine_id, round(avg(end_time - start_time), 3) as processing_time\\nfrom\\n    (select\\n        machine_id, \\n        sum(if (activity_type = \\'start\\', timestamp, 0)) as start_time,\\n        sum(if (activity_type = \\'end\\', timestamp, 0)) as end_time\\n    from\\n        Activity\\n    group by\\n        machine_id, process_id)t\\ngroup by machine_id;\\n        \\n",
                "solutionTags": [],
                "code": "```\\nselect \\n    machine_id, round(avg(end_time - start_time), 3) as processing_time\\nfrom\\n    (select\\n        machine_id, \\n        sum(if (activity_type = \\'start\\', timestamp, 0)) as start_time,\\n        sum(if (activity_type = \\'end\\', timestamp, 0)) as end_time\\n    from\\n        Activity\\n    group by\\n        machine_id, process_id)t\\ngroup by machine_id;\\n        \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1826671,
                "title": "simple-and-straightforward",
                "content": "use round and avg function\\n```\\nSELECT machine_id, ROUND(AVG(CASE WHEN activity_type = \\'end\\' THEN a.timestamp ELSE -a.timestamp END)*2, 3) AS processing_time\\nFROM Activity a \\nGROUP BY machine_id\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT machine_id, ROUND(AVG(CASE WHEN activity_type = \\'end\\' THEN a.timestamp ELSE -a.timestamp END)*2, 3) AS processing_time\\nFROM Activity a \\nGROUP BY machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1809242,
                "title": "cte-case-when-easy-and-faster-than-97-07",
                "content": "\\n```\\nWITH cte_process\\nAS\\n(\\n    SELECT\\n        machine_id,\\n        process_id,\\n        SUM(CASE WHEN activity_type = \\'end\\' THEN timestamp\\n                 ELSE -1*timestamp\\n                 END) AS avg_time \\n    FROM \\n        Activity\\n    GROUP BY machine_id,process_id\\n)\\n    \\nSELECT\\n    machine_id,\\n    ROUND(SUM(avg_time)/COUNT(*),3) AS processing_time\\nFROM\\n    cte_process\\nGROUP BY machine_id\\n```",
                "solutionTags": [],
                "code": "```\\nWITH cte_process\\nAS\\n(\\n    SELECT\\n        machine_id,\\n        process_id,\\n        SUM(CASE WHEN activity_type = \\'end\\' THEN timestamp\\n                 ELSE -1*timestamp\\n                 END) AS avg_time \\n    FROM \\n        Activity\\n    GROUP BY machine_id,process_id\\n)\\n    \\nSELECT\\n    machine_id,\\n    ROUND(SUM(avg_time)/COUNT(*),3) AS processing_time\\nFROM\\n    cte_process\\nGROUP BY machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1776903,
                "title": "cte-easy-to-read-solution",
                "content": "* easy to read solution\\n* In an interview I\\'d mention the performance hit of using a CTE, but for analysis this is ok\\n* the median would probably be a better question to ask here\\n```\\n# Write your MySQL query statement below\\nWITH raw_data AS (\\nSELECT\\n    a.machine_id AS machine_id,\\n    COUNT(*) AS cnt,\\n    SUM(CASE WHEN a.activity_type = \\'start\\' THEN timestamp ELSE 0 END) AS sum_start,\\n    SUM(CASE WHEN a.activity_type = \\'end\\' THEN timestamp ELSE 0 END) AS sum_end\\nFROM\\n    Activity a\\nGROUP BY\\n    a.machine_id\\n)\\nSELECT\\n    rd.machine_id,\\n    ROUND((rd.sum_end - rd.sum_start) / rd.cnt * 2,3) AS processing_time\\nFROM\\n    raw_data rd\\nGROUP BY\\n    rd.machine_id\\n",
                "solutionTags": [],
                "code": "* easy to read solution\\n* In an interview I\\'d mention the performance hit of using a CTE, but for analysis this is ok\\n* the median would probably be a better question to ask here\\n```\\n# Write your MySQL query statement below\\nWITH raw_data AS (\\nSELECT\\n    a.machine_id AS machine_id,\\n    COUNT(*) AS cnt,\\n    SUM(CASE WHEN a.activity_type = \\'start\\' THEN timestamp ELSE 0 END) AS sum_start,\\n    SUM(CASE WHEN a.activity_type = \\'end\\' THEN timestamp ELSE 0 END) AS sum_end\\nFROM\\n    Activity a\\nGROUP BY\\n    a.machine_id\\n)\\nSELECT\\n    rd.machine_id,\\n    ROUND((rd.sum_end - rd.sum_start) / rd.cnt * 2,3) AS processing_time\\nFROM\\n    raw_data rd\\nGROUP BY\\n    rd.machine_id\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1769613,
                "title": "mysql-no-joins-no-window-functions-no-subqueries",
                "content": "```\\n# avg = (x01 - x00) + (x11 - x10) + ... \\n# / nProcesses\\n\\n# nProcesses = machine_id count / 2\\n\\n# => avg = (x01 - x00 + x11 - x10) / count(machine_id) * 2\\n\\nselect machine_id\\n    , round(\\n        sum(\\n            case when activity_type = \\'end\\' \\n                then timestamp \\n                else -timestamp \\n            end)  / \\n            count(machine_id)\\n        * 2\\n        , 3 \\n    ) as processing_time\\nfrom activity\\ngroup by machine_id\\n```",
                "solutionTags": [],
                "code": "```\\n# avg = (x01 - x00) + (x11 - x10) + ... \\n# / nProcesses\\n\\n# nProcesses = machine_id count / 2\\n\\n# => avg = (x01 - x00 + x11 - x10) / count(machine_id) * 2\\n\\nselect machine_id\\n    , round(\\n        sum(\\n            case when activity_type = \\'end\\' \\n                then timestamp \\n                else -timestamp \\n            end)  / \\n            count(machine_id)\\n        * 2\\n        , 3 \\n    ) as processing_time\\nfrom activity\\ngroup by machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1762241,
                "title": "mysql-self-join-avg",
                "content": "```sql\\nSELECT\\n  a.machine_id,\\n  ROUND(AVG(b.timestamp - a.timestamp), 3) AS processing_time\\nFROM\\n  Activity a\\n  JOIN Activity b\\n    ON a.machine_id = b.machine_id\\n    AND a.process_id = b.process_id\\n    AND a.activity_type = \\'start\\'\\n    AND b.activity_type = \\'end\\'\\nGROUP BY\\n  a.machine_id;\\n```",
                "solutionTags": [],
                "code": "```sql\\nSELECT\\n  a.machine_id,\\n  ROUND(AVG(b.timestamp - a.timestamp), 3) AS processing_time\\nFROM\\n  Activity a\\n  JOIN Activity b\\n    ON a.machine_id = b.machine_id\\n    AND a.process_id = b.process_id\\n    AND a.activity_type = \\'start\\'\\n    AND b.activity_type = \\'end\\'\\nGROUP BY\\n  a.machine_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1629433,
                "title": "easy-case-when-without-cte-or-joins",
                "content": "```\\nSELECT machine_id,\\n    ROUND((SUM(CASE WHEN activity_type = \"end\" THEN timestamp ELSE 0 END) - SUM(CASE WHEN activity_type = \"start\" THEN timestamp ELSE 0 END))/COUNT(DISTINCT process_id),3) as processing_time\\nFROM Activity\\nGROUP BY 1\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT machine_id,\\n    ROUND((SUM(CASE WHEN activity_type = \"end\" THEN timestamp ELSE 0 END) - SUM(CASE WHEN activity_type = \"start\" THEN timestamp ELSE 0 END))/COUNT(DISTINCT process_id),3) as processing_time\\nFROM Activity\\nGROUP BY 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1513091,
                "title": "runtime-577-ms-faster-than-99-18-of-ms-sql-server",
                "content": "\\n\\n\\nselect machine_id, cast(sum(case when activity_type  = \\'start\\' then -1.0*timestamp when activity_type = \\'end\\' then timestamp  end)/count(distinct(process_id)) as numeric(36,3)) \\'processing_time\\' from Activity group by machine_id",
                "solutionTags": [],
                "code": "\\n\\n\\nselect machine_id, cast(sum(case when activity_type  = \\'start\\' then -1.0*timestamp when activity_type = \\'end\\' then timestamp  end)/count(distinct(process_id)) as numeric(36,3)) \\'processing_time\\' from Activity group by machine_id",
                "codeTag": "Unknown"
            },
            {
                "id": 1512665,
                "title": "ms-sql",
                "content": "#### Question\\n```\\nSQL Schema\\nTable: Activity\\n\\n+----------------+---------+\\n| Column Name    | Type    |\\n+----------------+---------+\\n| machine_id     | int     |\\n| process_id     | int     |\\n| activity_type  | enum    |\\n| timestamp      | float   |\\n+----------------+---------+\\nThe table shows the user activities for a factory website.\\n(machine_id, process_id, activity_type) is the primary key of this table.\\nmachine_id is the ID of a machine.\\nprocess_id is the ID of a process running on the machine with ID machine_id.\\nactivity_type is an ENUM of type (\\'start\\', \\'end\\').\\ntimestamp is a float representing the current time in seconds.\\n\\'start\\' means the machine starts the process at the given timestamp and \\'end\\' means the machine ends the process at the given timestamp.\\nThe \\'start\\' timestamp will always be before the \\'end\\' timestamp for every (machine_id, process_id) pair.\\n \\n\\nThere is a factory website that has several machines each running the same number of processes. Write an SQL query to find the average time each machine takes to complete a process.\\n\\nThe time to complete a process is the \\'end\\' timestamp minus the \\'start\\' timestamp. The average time is calculated by the total time to complete every process on the machine divided by the number of processes that were run.\\n\\nThe resulting table should have the machine_id along with the average time as processing_time, which should be rounded to 3 decimal places.\\n\\nThe query result format is in the following example:\\n\\n \\n\\nActivity table:\\n+------------+------------+---------------+-----------+\\n| machine_id | process_id | activity_type | timestamp |\\n+------------+------------+---------------+-----------+\\n| 0          | 0          | start         | 0.712     |\\n| 0          | 0          | end           | 1.520     |\\n| 0          | 1          | start         | 3.140     |\\n| 0          | 1          | end           | 4.120     |\\n| 1          | 0          | start         | 0.550     |\\n| 1          | 0          | end           | 1.550     |\\n| 1          | 1          | start         | 0.430     |\\n| 1          | 1          | end           | 1.420     |\\n| 2          | 0          | start         | 4.100     |\\n| 2          | 0          | end           | 4.512     |\\n| 2          | 1          | start         | 2.500     |\\n| 2          | 1          | end           | 5.000     |\\n+------------+------------+---------------+-----------+\\n\\nResult table:\\n+------------+-----------------+\\n| machine_id | processing_time |\\n+------------+-----------------+\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\n+------------+-----------------+\\n\\nThere are 3 machines running 2 processes each.\\nMachine 0\\'s average time is ((1.520 - 0.712) + (4.120 - 3.140)) / 2 = 0.894\\nMachine 1\\'s average time is ((1.550 - 0.550) + (1.420 - 0.430)) / 2 = 0.995\\nMachine 2\\'s average time is ((4.512 - 4.100) + (5.000 - 2.500)) / 2 = 1.456\\n```\\n\\n#### Answer\\n````SQL\\n/* Write your T-SQL query statement below */\\n\\nwith process_time as (select a1.machine_id, abs(a1.timestamp - a2.timestamp ) processing_time \\n            from Activity a1 join Activity a2 \\n             on a1.machine_id = a2.machine_id and a1.process_id = a2.process_id \\n             where a1.activity_type != a2.activity_type )\\n             \\n             \\nselect machine_id, ROUND(AVG(processing_time), 3) processing_time from process_time\\ngroup by machine_id\\n",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nSQL Schema\\nTable: Activity\\n\\n+----------------+---------+\\n| Column Name    | Type    |\\n+----------------+---------+\\n| machine_id     | int     |\\n| process_id     | int     |\\n| activity_type  | enum    |\\n| timestamp      | float   |\\n+----------------+---------+\\nThe table shows the user activities for a factory website.\\n(machine_id, process_id, activity_type) is the primary key of this table.\\nmachine_id is the ID of a machine.\\nprocess_id is the ID of a process running on the machine with ID machine_id.\\nactivity_type is an ENUM of type (\\'start\\', \\'end\\').\\ntimestamp is a float representing the current time in seconds.\\n\\'start\\' means the machine starts the process at the given timestamp and \\'end\\' means the machine ends the process at the given timestamp.\\nThe \\'start\\' timestamp will always be before the \\'end\\' timestamp for every (machine_id, process_id) pair.\\n \\n\\nThere is a factory website that has several machines each running the same number of processes. Write an SQL query to find the average time each machine takes to complete a process.\\n\\nThe time to complete a process is the \\'end\\' timestamp minus the \\'start\\' timestamp. The average time is calculated by the total time to complete every process on the machine divided by the number of processes that were run.\\n\\nThe resulting table should have the machine_id along with the average time as processing_time, which should be rounded to 3 decimal places.\\n\\nThe query result format is in the following example:\\n\\n \\n\\nActivity table:\\n+------------+------------+---------------+-----------+\\n| machine_id | process_id | activity_type | timestamp |\\n+------------+------------+---------------+-----------+\\n| 0          | 0          | start         | 0.712     |\\n| 0          | 0          | end           | 1.520     |\\n| 0          | 1          | start         | 3.140     |\\n| 0          | 1          | end           | 4.120     |\\n| 1          | 0          | start         | 0.550     |\\n| 1          | 0          | end           | 1.550     |\\n| 1          | 1          | start         | 0.430     |\\n| 1          | 1          | end           | 1.420     |\\n| 2          | 0          | start         | 4.100     |\\n| 2          | 0          | end           | 4.512     |\\n| 2          | 1          | start         | 2.500     |\\n| 2          | 1          | end           | 5.000     |\\n+------------+------------+---------------+-----------+\\n\\nResult table:\\n+------------+-----------------+\\n| machine_id | processing_time |\\n+------------+-----------------+\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\n+------------+-----------------+\\n\\nThere are 3 machines running 2 processes each.\\nMachine 0\\'s average time is ((1.520 - 0.712) + (4.120 - 3.140)) / 2 = 0.894\\nMachine 1\\'s average time is ((1.550 - 0.550) + (1.420 - 0.430)) / 2 = 0.995\\nMachine 2\\'s average time is ((4.512 - 4.100) + (5.000 - 2.500)) / 2 = 1.456\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1467952,
                "title": "no-join-use-if-and-avg",
                "content": "select\\nmachine_id,\\nround(2*avg(if(activity_type=\\'end\\',timestamp,0)-if(activity_type=\\'start\\',timestamp,0)),3)\\nas processing_time\\n\\nfrom Activity\\ngroup by 1",
                "solutionTags": [],
                "code": "select\\nmachine_id,\\nround(2*avg(if(activity_type=\\'end\\',timestamp,0)-if(activity_type=\\'start\\',timestamp,0)),3)\\nas processing_time\\n\\nfrom Activity\\ngroup by 1",
                "codeTag": "Unknown"
            },
            {
                "id": 1446434,
                "title": "sql-server-self-join-faster-than-99",
                "content": "select  a1.machine_id  , round(sum(a2.timestamp - a1.timestamp)/count(distinct a1.process_id), 3)  as processing_time \\nfrom    Activity a1\\njoin    Activity a2\\n        on a1.machine_id = a2.machine_id \\n        and a1.process_id = a2.process_id \\n        and a2.timestamp > a1.timestamp \\nwhere   a1.activity_type like \\'start\\'\\n        and a2.activity_type like \\'end\\'\\ngroup by a1.machine_id",
                "solutionTags": [],
                "code": "select  a1.machine_id  , round(sum(a2.timestamp - a1.timestamp)/count(distinct a1.process_id), 3)  as processing_time \\nfrom    Activity a1\\njoin    Activity a2\\n        on a1.machine_id = a2.machine_id \\n        and a1.process_id = a2.process_id \\n        and a2.timestamp > a1.timestamp \\nwhere   a1.activity_type like \\'start\\'\\n        and a2.activity_type like \\'end\\'\\ngroup by a1.machine_id",
                "codeTag": "Unknown"
            },
            {
                "id": 1366562,
                "title": "no-join-2-line-solution",
                "content": "```\\nselect machine_id, round(sum(case when activity_type = \\'start\\' then -timestamp else timestamp end)/count(distinct process_id) ,3)as processing_time\\nfrom activity group by machine_id\\n\\n```",
                "solutionTags": [],
                "code": "```\\nselect machine_id, round(sum(case when activity_type = \\'start\\' then -timestamp else timestamp end)/count(distinct process_id) ,3)as processing_time\\nfrom activity group by machine_id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1362557,
                "title": "simple-self-join-solution",
                "content": "select  a.machine_id, round(avg(b.timestamp-a.timestamp),3) as processing_time\\nfrom activity a, activity b\\nwhere b.timestamp>a.timestamp\\nand b.activity_type = \\'end\\'\\nand a.process_id = b.process_id\\nand a.activity_type = \\'start\\'\\nand a.machine_id = b.machine_id\\ngroup by a.machine_id",
                "solutionTags": [],
                "code": "select  a.machine_id, round(avg(b.timestamp-a.timestamp),3) as processing_time\\nfrom activity a, activity b\\nwhere b.timestamp>a.timestamp\\nand b.activity_type = \\'end\\'\\nand a.process_id = b.process_id\\nand a.activity_type = \\'start\\'\\nand a.machine_id = b.machine_id\\ngroup by a.machine_id",
                "codeTag": "Unknown"
            },
            {
                "id": 1330066,
                "title": "mysql-4-lines",
                "content": "```\\nselect machine_id,\\n    round(sum(case when activity_type = \\'start\\' then 0-timestamp else timestamp end)/count(distinct process_id),3) as processing_time\\nfrom Activity\\ngroup by machine_id",
                "solutionTags": [],
                "code": "```\\nselect machine_id,\\n    round(sum(case when activity_type = \\'start\\' then 0-timestamp else timestamp end)/count(distinct process_id),3) as processing_time\\nfrom Activity\\ngroup by machine_id",
                "codeTag": "Unknown"
            },
            {
                "id": 1303231,
                "title": "simple-my-sql-no-join-and-case",
                "content": "```\\nSELECT machine_id, ROUND(((SUM(IF(activity_type = \\'end\\',timestamp,0))\\n    - SUM(IF(activity_type = \\'start\\',timestamp,0))) / COUNT(DISTINCT process_id)),3)\\n    AS processing_time FROM Activity GROUP BY machine_id\\n\\n",
                "solutionTags": [],
                "code": "```\\nSELECT machine_id, ROUND(((SUM(IF(activity_type = \\'end\\',timestamp,0))\\n    - SUM(IF(activity_type = \\'start\\',timestamp,0))) / COUNT(DISTINCT process_id)),3)\\n    AS processing_time FROM Activity GROUP BY machine_id\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1259342,
                "title": "mysql-faster-than-95-8-using-with-if",
                "content": "with cte as (\\n    select machine_id, process_id, if(activity_type=\\'start\\',-timestamp,timestamp) as timestamp\\n    from activity)\\n    \\n   select machine_id, round(sum(timestamp)/count(distinct process_id),3) as processing_time\\n    from cte\\n    group by 1;",
                "solutionTags": [],
                "code": "with cte as (\\n    select machine_id, process_id, if(activity_type=\\'start\\',-timestamp,timestamp) as timestamp\\n    from activity)\\n    \\n   select machine_id, round(sum(timestamp)/count(distinct process_id),3) as processing_time\\n    from cte\\n    group by 1;",
                "codeTag": "Unknown"
            },
            {
                "id": 1219471,
                "title": "ms-sql-server-93-75-faster",
                "content": "select machine_id,\\nround(sum(case when activity_type = \\'start\\' then -[timestamp]\\n    when activity_type = \\'end\\' then [timestamp] end)/cast(count(distinct process_id) as float), 3) processing_time\\nfrom activity\\ngroup by machine_id",
                "solutionTags": [],
                "code": "select machine_id,\\nround(sum(case when activity_type = \\'start\\' then -[timestamp]\\n    when activity_type = \\'end\\' then [timestamp] end)/cast(count(distinct process_id) as float), 3) processing_time\\nfrom activity\\ngroup by machine_id",
                "codeTag": "Unknown"
            },
            {
                "id": 1151962,
                "title": "91-faster-using-mysql",
                "content": "```\\nSELECT t_start.machine_id, round(avg(t_end.timestamp- t_start.timestamp),3) as processing_time\\nFROM Activity as t_start join Activity as t_end\\non t_start.machine_id = t_end.machine_id and t_start.process_id = t_end.process_id\\nwhere t_start.activity_type = \\'start\\' and t_end.activity_type = \\'end\\'\\ngroup by t_start.machine_id\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT t_start.machine_id, round(avg(t_end.timestamp- t_start.timestamp),3) as processing_time\\nFROM Activity as t_start join Activity as t_end\\non t_start.machine_id = t_end.machine_id and t_start.process_id = t_end.process_id\\nwhere t_start.activity_type = \\'start\\' and t_end.activity_type = \\'end\\'\\ngroup by t_start.machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1139999,
                "title": "mysql-join-and-aggregate",
                "content": "```\\nselect\\na.machine_id,\\nround(avg(b.timestamp - a.timestamp), 3) as processing_time\\nfrom activity a\\njoin activity b on a.machine_id = b.machine_id and a.process_id = b.process_id and a.activity_type = \\'start\\' and b.activity_type = \\'end\\'\\ngroup by 1\\n```",
                "solutionTags": [],
                "code": "```\\nselect\\na.machine_id,\\nround(avg(b.timestamp - a.timestamp), 3) as processing_time\\nfrom activity a\\njoin activity b on a.machine_id = b.machine_id and a.process_id = b.process_id and a.activity_type = \\'start\\' and b.activity_type = \\'end\\'\\ngroup by 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1113345,
                "title": "simplest-line-by-line-breakdown",
                "content": "SELECT s.machine_id, ROUND(AVG(e.timestamp-s.timestamp), 3) AS processing_time\\nFROM Activity s JOIN Activity e ON\\n    s.machine_id = e.machine_id AND s.process_id = e.process_id AND\\n    s.activity_type = \\'start\\' AND e.activity_type = \\'end\\'\\nGROUP BY s.machine_id",
                "solutionTags": [],
                "code": "SELECT s.machine_id, ROUND(AVG(e.timestamp-s.timestamp), 3) AS processing_time\\nFROM Activity s JOIN Activity e ON\\n    s.machine_id = e.machine_id AND s.process_id = e.process_id AND\\n    s.activity_type = \\'start\\' AND e.activity_type = \\'end\\'\\nGROUP BY s.machine_id",
                "codeTag": "Unknown"
            },
            {
                "id": 1094812,
                "title": "simple-if-statement-sql",
                "content": "select machine_id,\\nround(sum(if(activity_type like \\'end\\',timestamp,-timestamp))/count(distinct process_id),3) as processing_time \\nfrom activity \\ngroup by machine_id",
                "solutionTags": [],
                "code": "select machine_id,\\nround(sum(if(activity_type like \\'end\\',timestamp,-timestamp))/count(distinct process_id),3) as processing_time \\nfrom activity \\ngroup by machine_id",
                "codeTag": "Unknown"
            },
            {
                "id": 1030403,
                "title": "easy-self-join-solution",
                "content": "```\\nselect machine_id,round(avg(processing_time),3) as processing_time   from (\\nselect a.machine_id,a.process_id , b.timestamp-a.timestamp as processing_time \\nfrom activity a join activity b on a.machine_id=b.machine_id and a.process_id=b.process_id\\nwhere a.activity_type=\\'start\\' and b.activity_type=\\'end\\') a group by 1\\n```",
                "solutionTags": [],
                "code": "```\\nselect machine_id,round(avg(processing_time),3) as processing_time   from (\\nselect a.machine_id,a.process_id , b.timestamp-a.timestamp as processing_time \\nfrom activity a join activity b on a.machine_id=b.machine_id and a.process_id=b.process_id\\nwhere a.activity_type=\\'start\\' and b.activity_type=\\'end\\') a group by 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1009609,
                "title": "simple-mysql-solution",
                "content": "```\\nWITH cte AS (\\n    SELECT machine_id, process_id, MAX(timestamp) - MIN(timestamp) AS process_time\\n    FROM activity\\n    GROUP BY machine_id, process_id\\n)\\nSELECT machine_id, ROUND(AVG(process_time), 3) AS processing_time\\nFROM cte\\nGROUP BY machine_id\\n```",
                "solutionTags": [],
                "code": "```\\nWITH cte AS (\\n    SELECT machine_id, process_id, MAX(timestamp) - MIN(timestamp) AS process_time\\n    FROM activity\\n    GROUP BY machine_id, process_id\\n)\\nSELECT machine_id, ROUND(AVG(process_time), 3) AS processing_time\\nFROM cte\\nGROUP BY machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1008138,
                "title": "using-only-case-no-joins",
                "content": "```\\nWITH main AS (\\nSELECT machine_id, process_id, activity_type, \\n    CASE WHEN  activity_type = \\'start\\' THEN timestamp*(-1)\\n    ELSE timestamp END as new_time\\nFROM Activity\\n)\\nSELECT machine_id, ROUND(2*AVG(new_time),3) as processing_time\\nFROM main\\nGROUP BY machine_id\\n```",
                "solutionTags": [],
                "code": "```\\nWITH main AS (\\nSELECT machine_id, process_id, activity_type, \\n    CASE WHEN  activity_type = \\'start\\' THEN timestamp*(-1)\\n    ELSE timestamp END as new_time\\nFROM Activity\\n)\\nSELECT machine_id, ROUND(2*AVG(new_time),3) as processing_time\\nFROM main\\nGROUP BY machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 963996,
                "title": "simple-mysql-solution-4-lines-of-code",
                "content": "select machine_id,\\n       round(avg(case when activity_type = \\'start\\' then -timestamp else timestamp end)*2, 3) as processing_time\\n  from Activity\\n  group by machine_id",
                "solutionTags": [],
                "code": "select machine_id,\\n       round(avg(case when activity_type = \\'start\\' then -timestamp else timestamp end)*2, 3) as processing_time\\n  from Activity\\n  group by machine_id",
                "codeTag": "Unknown"
            },
            {
                "id": 948324,
                "title": "simple-sql-server-solution",
                "content": "first solution:\\n\\n```\\nselect a.machine_id,round(avg(b.timestamp-a.timestamp),3) as processing_time\\nfrom Activity a join Activity b\\non a.machine_id = b.machine_id and a.process_id = b.process_id\\nwhere a.activity_type = \\'start\\' and b.activity_type = \\'end\\'\\ngroup by a.machine_id\\norder by a.machine_id\\n```\\n\\nsecond solution:\\n\\n```\\nselect x.machine_id,round(sum(x.timestamp - x.endts)/count(distinct x.process_id)*1.0,3) as processing_time\\nfrom\\n(\\nselect *, lead(timestamp) over (partition by process_id,machine_id order by activity_type) as endts\\nfrom Activity\\n)x\\ngroup by x.machine_id",
                "solutionTags": [],
                "code": "```\\nselect a.machine_id,round(avg(b.timestamp-a.timestamp),3) as processing_time\\nfrom Activity a join Activity b\\non a.machine_id = b.machine_id and a.process_id = b.process_id\\nwhere a.activity_type = \\'start\\' and b.activity_type = \\'end\\'\\ngroup by a.machine_id\\norder by a.machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 947997,
                "title": "simple-self-join-in-ms-sql",
                "content": "```\\nwith cte as (\\nselect a1.machine_id,\\n    a1.process_id,\\n    a2.timestamp - a1.timestamp as duration\\nfrom activity as a1\\n    inner join activity as a2\\n    on a1.machine_id = a2.machine_id\\n    and a1.process_id = a2.process_id\\n    and a1.activity_type > a2.activity_type\\n)\\n\\nselect machine_id,\\n    cast(avg(duration) as decimal(16,3)) as processing_time\\nfrom cte\\ngroup by machine_id\\norder by machine_id\\n;\\n\\n\\n```\\n",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nwith cte as (\\nselect a1.machine_id,\\n    a1.process_id,\\n    a2.timestamp - a1.timestamp as duration\\nfrom activity as a1\\n    inner join activity as a2\\n    on a1.machine_id = a2.machine_id\\n    and a1.process_id = a2.process_id\\n    and a1.activity_type > a2.activity_type\\n)\\n\\nselect machine_id,\\n    cast(avg(duration) as decimal(16,3)) as processing_time\\nfrom cte\\ngroup by machine_id\\norder by machine_id\\n;\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 945882,
                "title": "oracle-solution",
                "content": "Faster than 100% submissions\\n```\\nselect distinct a.machine_id, round(avg(b.timestamp - a.timestamp),3) as processing_time\\nfrom\\nActivity a, Activity b\\nwhere\\na.machine_id = b.machine_id and a.process_id = b.process_id\\nand a.activity_type = \\'start\\' and b.activity_type = \\'end\\'\\ngroup by a.machine_id\\norder by a.machine_id\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nselect distinct a.machine_id, round(avg(b.timestamp - a.timestamp),3) as processing_time\\nfrom\\nActivity a, Activity b\\nwhere\\na.machine_id = b.machine_id and a.process_id = b.process_id\\nand a.activity_type = \\'start\\' and b.activity_type = \\'end\\'\\ngroup by a.machine_id\\norder by a.machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 941505,
                "title": "first-solution-easy-and-simple",
                "content": "```\\nselect a1.machine_id , round(avg(a2.timestamp - a1.timestamp),3) processing_time \\nfrom Activity a1 join Activity a2 on a1.machine_id = a2.machine_id and a1.process_id = a2.process_id and a1.activity_type != a2.activity_type\\nwhere a1.activity_type = \\'start\\'\\ngroup by a1.machine_id\\norder by 1\\n```\\n\\nFor some reason, the same code wont work in Oracle",
                "solutionTags": [],
                "code": "```\\nselect a1.machine_id , round(avg(a2.timestamp - a1.timestamp),3) processing_time \\nfrom Activity a1 join Activity a2 on a1.machine_id = a2.machine_id and a1.process_id = a2.process_id and a1.activity_type != a2.activity_type\\nwhere a1.activity_type = \\'start\\'\\ngroup by a1.machine_id\\norder by 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4107370,
                "title": "step-by-step-process-for-the-query",
                "content": "# Intuition\\nFirst we make 2 saperate tables for starting and ending time \\nthen use the difference to calculate total time and then the average\\n\\n# Approach\\n\\n**Step 1**: First we create a Table \\'s\\' that has the following fields-\\nmachine_id , process_id and timestamp, where activity_type is eaqual\\nto \\'start\\'\\n\\n**Step 2**: Then we create a Table \\'e\\' that has the following fields-\\nmachine_id , process_id and timestamp, where activity_type is eaqual to \\'end\\'\\n\\n**Step 3**: We inner join the table on matching machine_id and process_id and create another table with following fields -\\nmachine_id and average of the difference of timestamps of the previous 2 tables\\n\\n**Step 4**: We group the final table by machine_id\\n\\nNote: ROUND() function rounds off the values\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n#SELECT s.machine_id , s.process_id , (e.timestamp - s.timestamp)\\n#FROM \\nSELECT s.machine_id ,ROUND(AVG((e.timestamp - s.timestamp)),3) as processing_time\\nFROM\\n(\\n    SELECT a.machine_id , a.process_id ,a.timestamp\\n    FROM Activity a\\n    WHERE activity_type = \\'start\\'\\n) s \\nINNER JOIN \\n(\\n    SELECT a.machine_id , a.process_id , a.timestamp\\n    FROM Activity a\\n    WHERE activity_type = \\'end\\'\\n) e\\nON s.machine_id = e.machine_id AND s.process_id = e.process_id\\nGROUP BY s.machine_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n#SELECT s.machine_id , s.process_id , (e.timestamp - s.timestamp)\\n#FROM \\nSELECT s.machine_id ,ROUND(AVG((e.timestamp - s.timestamp)),3) as processing_time\\nFROM\\n(\\n    SELECT a.machine_id , a.process_id ,a.timestamp\\n    FROM Activity a\\n    WHERE activity_type = \\'start\\'\\n) s \\nINNER JOIN \\n(\\n    SELECT a.machine_id , a.process_id , a.timestamp\\n    FROM Activity a\\n    WHERE activity_type = \\'end\\'\\n) e\\nON s.machine_id = e.machine_id AND s.process_id = e.process_id\\nGROUP BY s.machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4106437,
                "title": "run-time-beats-94-07-oracle-straight-forward-solution",
                "content": "# Code\\n```\\n/* Write your PL/SQL query statement below */\\nSELECT MACHINE_ID,\\nROUND(\\n    (\\n        SUM(\\n            CASE WHEN ACTIVITY_TYPE = \\'end\\' THEN timestamp ELSE 0 END\\n            )\\n        -\\n        SUM(\\n            CASE WHEN ACTIVITY_TYPE = \\'start\\' THEN timestamp ELSE 0 END\\n            )\\n    ) / (COUNT(*) / 2)\\n    , 3\\n    ) AS processing_time\\nFROM ACTIVITY\\nGROUP BY MACHINE_ID\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nSELECT MACHINE_ID,\\nROUND(\\n    (\\n        SUM(\\n            CASE WHEN ACTIVITY_TYPE = \\'end\\' THEN timestamp ELSE 0 END\\n            )\\n        -\\n        SUM(\\n            CASE WHEN ACTIVITY_TYPE = \\'start\\' THEN timestamp ELSE 0 END\\n            )\\n    ) / (COUNT(*) / 2)\\n    , 3\\n    ) AS processing_time\\nFROM ACTIVITY\\nGROUP BY MACHINE_ID\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4106333,
                "title": "average-time-of-process-per-machine",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect distinct(a1.machine_id) , round(avg(a2.timestamp - a1.timestamp),3) as processing_time  \\nfrom Activity a1, Activity a2\\nwhere a1.machine_id = a2.machine_id \\nand a1.process_id = a2.process_id\\nand a1.activity_type = \"start\" \\nand a2.activity_type = \"end\"\\ngroup by a1.machine_id;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect distinct(a1.machine_id) , round(avg(a2.timestamp - a1.timestamp),3) as processing_time  \\nfrom Activity a1, Activity a2\\nwhere a1.machine_id = a2.machine_id \\nand a1.process_id = a2.process_id\\nand a1.activity_type = \"start\" \\nand a2.activity_type = \"end\"\\ngroup by a1.machine_id;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4104848,
                "title": "cte",
                "content": "# Intuition\\nI am a big fan of CTEs because they make the query more readable\\n# Approach\\n1. Creating the table which gets the table with the activity_type= \\'start\\'\\n2. Creating the table which gets the table with the activity_type=\\'end\\' \\n3. Creating the intermediate table with the field end-start. \\n4. Selecting the machine id and dividing the sum of the time/count(proccess_id)\\n\\nThe method that I showed you is definetely more readable, however if you prefer you can use also double call method where you use \\n\\nFROM activites a, activites b\\nand start and end timestamps on one row level that will help you to do the calculations.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nWITH \\n    END_Spiel AS (\\n        SELECT MACHINE_ID, PROCESS_ID, SUM(timestamp) AS FINISH\\n        FROM Activity\\n        WHERE ACTIVITY_TYPE = \\'end\\'\\n        GROUP BY 1,2\\n    ),\\n    START_Spiel AS (\\n        SELECT MACHINE_ID, PROCESS_ID, SUM(timestamp) AS START\\n        FROM Activity\\n        WHERE ACTIVITY_TYPE = \\'start\\'\\n        GROUP BY 1,2\\n    ),\\n    Calcolo_intermedio AS (\\n        SELECT a.MACHINE_ID, a.PROCESS_ID, a.FINISH - b.START AS TIME_SPEND\\n        FROM END_Spiel a\\n        INNER JOIN START_Spiel b ON a.MACHINE_ID = b.MACHINE_ID AND a.PROCESS_ID = b.PROCESS_ID\\n    )\\nSELECT MACHINE_ID, round(SUM(TIME_SPEND) / COUNT(PROCESS_ID),3) AS processing_time\\nFROM Calcolo_intermedio\\nGROUP BY 1;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nWITH \\n    END_Spiel AS (\\n        SELECT MACHINE_ID, PROCESS_ID, SUM(timestamp) AS FINISH\\n        FROM Activity\\n        WHERE ACTIVITY_TYPE = \\'end\\'\\n        GROUP BY 1,2\\n    ),\\n    START_Spiel AS (\\n        SELECT MACHINE_ID, PROCESS_ID, SUM(timestamp) AS START\\n        FROM Activity\\n        WHERE ACTIVITY_TYPE = \\'start\\'\\n        GROUP BY 1,2\\n    ),\\n    Calcolo_intermedio AS (\\n        SELECT a.MACHINE_ID, a.PROCESS_ID, a.FINISH - b.START AS TIME_SPEND\\n        FROM END_Spiel a\\n        INNER JOIN START_Spiel b ON a.MACHINE_ID = b.MACHINE_ID AND a.PROCESS_ID = b.PROCESS_ID\\n    )\\nSELECT MACHINE_ID, round(SUM(TIME_SPEND) / COUNT(PROCESS_ID),3) AS processing_time\\nFROM Calcolo_intermedio\\nGROUP BY 1;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4104072,
                "title": "sql-subquery-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT machine_id, ROUND(AVG(end_time - start_time), 3) AS processing_time\\nFROM (\\n    SELECT machine_id, process_id,\\n           MAX(CASE WHEN activity_type = \\'start\\' THEN timestamp END) AS start_time,\\n           MAX(CASE WHEN activity_type = \\'end\\' THEN timestamp END) AS end_time\\n    FROM Activity\\n    GROUP BY machine_id, process_id\\n) AS machine_activities\\nGROUP BY machine_id\\nORDER BY machine_id;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT machine_id, ROUND(AVG(end_time - start_time), 3) AS processing_time\\nFROM (\\n    SELECT machine_id, process_id,\\n           MAX(CASE WHEN activity_type = \\'start\\' THEN timestamp END) AS start_time,\\n           MAX(CASE WHEN activity_type = \\'end\\' THEN timestamp END) AS end_time\\n    FROM Activity\\n    GROUP BY machine_id, process_id\\n) AS machine_activities\\nGROUP BY machine_id\\nORDER BY machine_id;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4102131,
                "title": "cte-2-agg-functions-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nwith tablee as (\\nselect machine_id, process_id, \\nROUND(max(timestamp) - min(timestamp),3) as diff\\nfrom activity\\ngroup by machine_id, process_id)\\n\\nselect machine_id, round(avg(diff),3) as processing_time  from tablee\\ngroup by machine_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nwith tablee as (\\nselect machine_id, process_id, \\nROUND(max(timestamp) - min(timestamp),3) as diff\\nfrom activity\\ngroup by machine_id, process_id)\\n\\nselect machine_id, round(avg(diff),3) as processing_time  from tablee\\ngroup by machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4101886,
                "title": "pandas-and-mysql-with-explanation",
                "content": "```sql []\\nSELECT a.machine_id, ROUND(AVG(b.timestamp - a.timestamp), 3) AS processing_time\\nFROM Activity a, Activity b\\nWHERE a.machine_id = b.machine_id AND a.process_id = b.process_id AND a.activity_type = \\'start\\' AND b.activity_type = \\'end\\'\\nGROUP BY a.machine_id, b.machine_id;\\n```\\n\\n## MySQL Explanation\\n\\n![acti.png](https://assets.leetcode.com/users/images/717c9c1a-ea37-406b-b83a-a12e20920f0f_1695919608.416645.png)\\n\\nFor the red color part: (since we grouped by `GROUP BY a.machine_id, b.machine_id`)\\n- `a.machine_id = b.machine_id` matches the red group in a and b.\\n- For red group `a.process_id = b.process_id` matches green and blue part in both a and b.\\n- - `For the green part` : by `a.activity_type = \\'start\\' AND b.activity_type = \\'end\\'` we\\'re telling who will be the start and end. We\\'ve no more condition, so let\\'s go to the `SELECT` part. We see `AVG(b.timestamp - a.timestamp)`, inside AVG, `b.timestamp - a.timestamp` taking places by 1.520 - 0.712 = `0.808`.\\n\\n#### Wait, is the condition `WHERE a.machine_id = b.machine_id AND a.process_id = b.process_id AND a.activity_type = \\'start\\' AND b.activity_type = \\'end\\'` really finished? NO! For red group we\\'ve green and blue. Green is finished, blue will will take place now.\\n\\n- - `For the blue part` : Similarly we will get here 4.120 - 3.140 = `0.98`. But where the previous result `0.808` gone? It was stored in `AVG()` FUNCTION. \\n```py\\nIn Python: sum(v for v in [1,2,3]), what happens in sum() here? A value(v) is returned after every iteration in the loop and the value\\n(v) is being added by sum().\\n\\nThe same thing happens in the MySQL code. The whole where condition is the for loop and the return value is \\'b.timestamp - a.timestamp\\'\\nwhich is being stored in \\'AVG() FUNCTION\\' to be operated.\\n```\\n- - Now `0.98` will be added with `0.808` and then 0.98 + 0.808 = `1.788` will divided by 2 by the `AVG()` FUNCTION.\\n- In this way for red group the whole where condition is executed. Now similar operation will happen for the group of 1 and 2 in `machine_id`.\\n- \\n## Pandas\\n```py []\\nimport pandas as pd\\n\\ndef get_average_time(activity: pd.DataFrame) -> pd.DataFrame:\\n    startDf, endDf = activity.query(\\'activity_type == \"start\"\\'), activity.query(\\'activity_type == \"end\"\\')\\n    merged_df = pd.merge(startDf, endDf, on=[\\'machine_id\\', \\'process_id\\'], suffixes=[\\'_start\\', \\'_end\\'])\\n    merged_df[\\'processing_time\\'] = merged_df[\\'timestamp_end\\'] - merged_df[\\'timestamp_start\\']\\n    return merged_df.groupby([\\'machine_id\\'])[\\'processing_time\\'].mean().round(3).reset_index()\\n```\\n\\n## Pandas Explanation\\nWe separated the the activity dataframe based on the `activity_type` column where first df `startDf` has values related with value `start` and second df `endDf` has values related with value `end`, then we merged them and added new column `processing_time`.. The rest is given in the below 2 pics :\\n![sivity1.png](https://assets.leetcode.com/users/images/ee72936b-e9a0-457a-99a0-5335dffa06bf_1695925401.88148.png)\\n\\n![sivity2.png](https://assets.leetcode.com/users/images/343319d1-44e9-4336-a64d-f02c609f9aaf_1695925411.748391.png)\\n\\n## If the solution was helpful, an upvote  will be appreciated. Thank youu\\n\\n",
                "solutionTags": [
                    "MySQL",
                    "Pandas"
                ],
                "code": "```sql []\\nSELECT a.machine_id, ROUND(AVG(b.timestamp - a.timestamp), 3) AS processing_time\\nFROM Activity a, Activity b\\nWHERE a.machine_id = b.machine_id AND a.process_id = b.process_id AND a.activity_type = \\'start\\' AND b.activity_type = \\'end\\'\\nGROUP BY a.machine_id, b.machine_id;\\n```\n```py\\nIn Python: sum(v for v in [1,2,3]), what happens in sum() here? A value(v) is returned after every iteration in the loop and the value\\n(v) is being added by sum().\\n\\nThe same thing happens in the MySQL code. The whole where condition is the for loop and the return value is \\'b.timestamp - a.timestamp\\'\\nwhich is being stored in \\'AVG() FUNCTION\\' to be operated.\\n```\n```py []\\nimport pandas as pd\\n\\ndef get_average_time(activity: pd.DataFrame) -> pd.DataFrame:\\n    startDf, endDf = activity.query(\\'activity_type == \"start\"\\'), activity.query(\\'activity_type == \"end\"\\')\\n    merged_df = pd.merge(startDf, endDf, on=[\\'machine_id\\', \\'process_id\\'], suffixes=[\\'_start\\', \\'_end\\'])\\n    merged_df[\\'processing_time\\'] = merged_df[\\'timestamp_end\\'] - merged_df[\\'timestamp_start\\']\\n    return merged_df.groupby([\\'machine_id\\'])[\\'processing_time\\'].mean().round(3).reset_index()\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4101683,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nWITH CTE AS \\n(\\n    SELECT\\n      A.machine_id,\\n      A.process_id,\\n      (Act.timestamp - A.timestamp) AS time_stamp\\n    FROM Activity A \\n      INNER JOIN Activity Act ON A.machine_id= Act.machine_id \\n        AND A. process_id=Act.process_id \\n        AND A.activity_type =\\'start\\' \\n        AND Act.activity_type=\\'end\\'\\n)\\nSELECT \\n  machine_id, \\n  ROUND(AVG(time_stamp),3) AS processing_time\\nFROM CTE\\nGROUP BY machine_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nWITH CTE AS \\n(\\n    SELECT\\n      A.machine_id,\\n      A.process_id,\\n      (Act.timestamp - A.timestamp) AS time_stamp\\n    FROM Activity A \\n      INNER JOIN Activity Act ON A.machine_id= Act.machine_id \\n        AND A. process_id=Act.process_id \\n        AND A.activity_type =\\'start\\' \\n        AND Act.activity_type=\\'end\\'\\n)\\nSELECT \\n  machine_id, \\n  ROUND(AVG(time_stamp),3) AS processing_time\\nFROM CTE\\nGROUP BY machine_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4100624,
                "title": "with-without-using-join",
                "content": "# Intuition\\nMy initial thoughts for solving this problem involve using SQL with a self-join on the \"Activity\" table to match \"start\" and \"end\" activities for the same machine and process. Then, I calculate the time difference for each process and average it per machine. Both answers provided use a similar approach.\\n\\n# Approach\\nThe approach in both answers is to perform a self-join on the \"Activity\" table, matching \"start\" and \"end\" activities based on machine_id and process_id. This allows us to calculate the time taken for each process and then average the times per machine. The ROUND function is used to round the result to three decimal places for the processing time.\\n\\n# Complexity\\n- Time complexity [For both Solutions]:\\nThe time complexity of these queries depends on the size of the \"Activity\" table but typically involves a linear scan of the table. Therefore, the time complexity is O(N), where N is the number of rows in the \"Activity\" table.\\n\\n- Space complexity  [For both Solutions]:\\nThe space complexity is minimal as the queries primarily involve calculations without significant additional space requirements. The space complexity can be considered constant, O(1).\\n\\n# Code 1\\n```\\nselect t1.machine_id, ROUND(avg(t2.timestamp - t1.timestamp), 3) as processing_time\\nfrom Activity as t1 \\nJOIN Activity as t2\\nON t1.machine_id = t2.machine_id AND t1.process_id = t2.process_id\\nAND t1.activity_type = \"start\" AND t2.activity_type = \"end\"\\ngroup by t1.machine_id;\\n```\\n# Code 2\\n```\\nselect t1.machine_id, ROUND(avg(t2.timestamp-t1.timestamp),3) as processing_time\\nfrom Activity as t1, Activity as t2\\nwhere t1.machine_id = t2.machine_id AND t1.process_id = t2.process_id AND t1.activity_type =\"start\" AND t2.activity_type = \"end\"\\ngroup by t1.machine_id;\\n\\n```\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect t1.machine_id, ROUND(avg(t2.timestamp - t1.timestamp), 3) as processing_time\\nfrom Activity as t1 \\nJOIN Activity as t2\\nON t1.machine_id = t2.machine_id AND t1.process_id = t2.process_id\\nAND t1.activity_type = \"start\" AND t2.activity_type = \"end\"\\ngroup by t1.machine_id;\\n```\n```\\nselect t1.machine_id, ROUND(avg(t2.timestamp-t1.timestamp),3) as processing_time\\nfrom Activity as t1, Activity as t2\\nwhere t1.machine_id = t2.machine_id AND t1.process_id = t2.process_id AND t1.activity_type =\"start\" AND t2.activity_type = \"end\"\\ngroup by t1.machine_id;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4100421,
                "title": "sql-easy-fast-using-join",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect A1.machine_id, round(sum(A2.timestamp-A1.timestamp)/(count(*)),3) as processing_time  from Activity as A1 JOIN Activity as A2 on \\nA1.activity_type=\"start\" and A2.activity_type=\"end\" and A1.machine_id=A2.machine_id\\ngroup by machine_id\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect A1.machine_id, round(sum(A2.timestamp-A1.timestamp)/(count(*)),3) as processing_time  from Activity as A1 JOIN Activity as A2 on \\nA1.activity_type=\"start\" and A2.activity_type=\"end\" and A1.machine_id=A2.machine_id\\ngroup by machine_id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4099797,
                "title": "average-time-of-process-per-machine",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT a12.machine_id, ROUND(AVG(a12.end_time - a12.start_time), 3) AS processing_time \\nFROM (\\n    SELECT a1.machine_id, a1.process_id, a1.timestamp AS start_time, a2.timestamp AS end_time \\n    FROM (\\n        SELECT * \\n        FROM Activity \\n        WHERE activity_type=\\'start\\'\\n    ) AS a1 \\n    LEFT JOIN (\\n        SELECT * \\n        FROM Activity \\n        WHERE activity_type=\\'end\\'\\n    ) AS a2 \\n    ON a1.machine_id=a2.machine_id AND a1.process_id=a2.process_id\\n) AS a12\\nGROUP BY a12.machine_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT a12.machine_id, ROUND(AVG(a12.end_time - a12.start_time), 3) AS processing_time \\nFROM (\\n    SELECT a1.machine_id, a1.process_id, a1.timestamp AS start_time, a2.timestamp AS end_time \\n    FROM (\\n        SELECT * \\n        FROM Activity \\n        WHERE activity_type=\\'start\\'\\n    ) AS a1 \\n    LEFT JOIN (\\n        SELECT * \\n        FROM Activity \\n        WHERE activity_type=\\'end\\'\\n    ) AS a2 \\n    ON a1.machine_id=a2.machine_id AND a1.process_id=a2.process_id\\n) AS a12\\nGROUP BY a12.machine_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4099744,
                "title": "join-two-subqueries-beats-94-78",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nselect s.machine_id, \\n    round(avg(e.timestamp - s.timestamp), 3) as processing_time\\nfrom\\n(select * \\nfrom activity\\nwhere activity_type = \\'start\\') s\\njoin\\n(select * \\nfrom activity\\nwhere activity_type = \\'end\\') e\\non s.machine_id = e.machine_id and s.process_id = e.process_id\\ngroup by s.machine_id\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nselect s.machine_id, \\n    round(avg(e.timestamp - s.timestamp), 3) as processing_time\\nfrom\\n(select * \\nfrom activity\\nwhere activity_type = \\'start\\') s\\njoin\\n(select * \\nfrom activity\\nwhere activity_type = \\'end\\') e\\non s.machine_id = e.machine_id and s.process_id = e.process_id\\ngroup by s.machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4098712,
                "title": "1661-average-time-of-process-per-machine",
                "content": "```\\n# Write your MySQL query statement below\\nselect machine_id ,\\nround((\\n  -avg(case when activity_type=\"start\" then timestamp\\n        else 0\\n\\t\\tend )\\n+avg(case when activity_type=\"end\" then timestamp\\n        else 0\\n        end )\\n)*2,3) as processing_time\\nfrom Activity\\ngroup by machine_id\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect machine_id ,\\nround((\\n  -avg(case when activity_type=\"start\" then timestamp\\n        else 0\\n\\t\\tend )\\n+avg(case when activity_type=\"end\" then timestamp\\n        else 0\\n        end )\\n)*2,3) as processing_time\\nfrom Activity\\ngroup by machine_id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4097842,
                "title": "sql-query-avg-time-of-process-per-machine",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nYou can find the average time each machine takes to complete a process by joining the Activity table with itself to calculate the difference in timestamps for \\'start\\' and \\'end\\' activities for each (machine_id, process_id) pair. Then, group the results by machine_id and calculate the average time for each machine.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\nIn this query:\\n\\nIn the subquery, we calculate the start_time and end_time for each (machine_id, process_id) pair by using conditional aggregation. We use the MAX function to get the timestamps for \\'start\\' and \\'end\\' activities.\\n\\nThen, we calculate the difference between end_time and start_time for each (machine_id, process_id) pair.\\n\\nNext, we calculate the average processing time for each machine by summing up the differences and dividing by the number of distinct process_id values for that machine.\\n\\nFinally, we round the result to three decimal places using the ROUND function.\\n\\nThis query will give you the desired output with the machine_id and their corresponding average processing times.\\n\\n<!-- # Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT \\n    a.machine_id,\\n    ROUND(SUM(end_time - start_time) / COUNT(DISTINCT a.process_id), 3) AS processing_time\\nFROM\\n    (SELECT\\n        machine_id,\\n        process_id,\\n        MAX(CASE WHEN activity_type = \\'start\\' THEN timestamp END) AS start_time,\\n        MAX(CASE WHEN activity_type = \\'end\\' THEN timestamp END) AS end_time\\n    FROM Activity\\n    GROUP BY machine_id, process_id) AS a\\nGROUP BY a.machine_id;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT \\n    a.machine_id,\\n    ROUND(SUM(end_time - start_time) / COUNT(DISTINCT a.process_id), 3) AS processing_time\\nFROM\\n    (SELECT\\n        machine_id,\\n        process_id,\\n        MAX(CASE WHEN activity_type = \\'start\\' THEN timestamp END) AS start_time,\\n        MAX(CASE WHEN activity_type = \\'end\\' THEN timestamp END) AS end_time\\n    FROM Activity\\n    GROUP BY machine_id, process_id) AS a\\nGROUP BY a.machine_id;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4097841,
                "title": "sql-query-avg-time-of-process-per-machine",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nYou can find the average time each machine takes to complete a process by joining the Activity table with itself to calculate the difference in timestamps for \\'start\\' and \\'end\\' activities for each (machine_id, process_id) pair. Then, group the results by machine_id and calculate the average time for each machine.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\nIn this query:\\n\\nIn the subquery, we calculate the start_time and end_time for each (machine_id, process_id) pair by using conditional aggregation. We use the MAX function to get the timestamps for \\'start\\' and \\'end\\' activities.\\n\\nThen, we calculate the difference between end_time and start_time for each (machine_id, process_id) pair.\\n\\nNext, we calculate the average processing time for each machine by summing up the differences and dividing by the number of distinct process_id values for that machine.\\n\\nFinally, we round the result to three decimal places using the ROUND function.\\n\\nThis query will give you the desired output with the machine_id and their corresponding average processing times.\\n\\n<!-- # Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT \\n    a.machine_id,\\n    ROUND(SUM(end_time - start_time) / COUNT(DISTINCT a.process_id), 3) AS processing_time\\nFROM\\n    (SELECT\\n        machine_id,\\n        process_id,\\n        MAX(CASE WHEN activity_type = \\'start\\' THEN timestamp END) AS start_time,\\n        MAX(CASE WHEN activity_type = \\'end\\' THEN timestamp END) AS end_time\\n    FROM Activity\\n    GROUP BY machine_id, process_id) AS a\\nGROUP BY a.machine_id;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT \\n    a.machine_id,\\n    ROUND(SUM(end_time - start_time) / COUNT(DISTINCT a.process_id), 3) AS processing_time\\nFROM\\n    (SELECT\\n        machine_id,\\n        process_id,\\n        MAX(CASE WHEN activity_type = \\'start\\' THEN timestamp END) AS start_time,\\n        MAX(CASE WHEN activity_type = \\'end\\' THEN timestamp END) AS end_time\\n    FROM Activity\\n    GROUP BY machine_id, process_id) AS a\\nGROUP BY a.machine_id;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4097035,
                "title": "easy-solution-without-using-join",
                "content": "# Without using JOIN, just using GROUP BY and aggregate functions!\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect c.machine_id, round(avg(c.timeTaken), 3) as processing_time\\nfrom (\\n\\tselect \\n\\t\\tmachine_id,\\n\\t\\tprocess_id,\\n\\t\\tmax(timestamp) - min(timestamp) as timeTaken\\n\\tfrom activity\\n\\tgroup by machine_id, process_id\\n) c\\ngroup by c.machine_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect c.machine_id, round(avg(c.timeTaken), 3) as processing_time\\nfrom (\\n\\tselect \\n\\t\\tmachine_id,\\n\\t\\tprocess_id,\\n\\t\\tmax(timestamp) - min(timestamp) as timeTaken\\n\\tfrom activity\\n\\tgroup by machine_id, process_id\\n) c\\ngroup by c.machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4096544,
                "title": "pandas-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef get_average_time(activity: pd.DataFrame) -> pd.DataFrame:\\n    df = activity.sort_values([\\'machine_id\\',\\'process_id\\',\\'timestamp\\'],ascending=[True,True,True])\\n    df = df.groupby([\\'machine_id\\',\\'process_id\\'])[\\'timestamp\\'].apply(lambda x: x.diff()).reset_index(name=\\'processing_time\\')\\n    return df.groupby(\\'machine_id\\')[\\'processing_time\\'].mean().round(3).reset_index()\\n    \\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef get_average_time(activity: pd.DataFrame) -> pd.DataFrame:\\n    df = activity.sort_values([\\'machine_id\\',\\'process_id\\',\\'timestamp\\'],ascending=[True,True,True])\\n    df = df.groupby([\\'machine_id\\',\\'process_id\\'])[\\'timestamp\\'].apply(lambda x: x.diff()).reset_index(name=\\'processing_time\\')\\n    return df.groupby(\\'machine_id\\')[\\'processing_time\\'].mean().round(3).reset_index()\\n    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4095249,
                "title": "my-solution",
                "content": "\\n# Code\\n```\\nselect machine_id,\\nround(sum(case\\nwhen activity_type = \\'start\\' then -timestamp else timestamp end)/(count(process_id)/2),3) as processing_time\\nfrom activity\\ngroup by machine_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect machine_id,\\nround(sum(case\\nwhen activity_type = \\'start\\' then -timestamp else timestamp end)/(count(process_id)/2),3) as processing_time\\nfrom activity\\ngroup by machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4093885,
                "title": "pandas-solution",
                "content": "I started by changing all start values to negative. \\n\\nThen I groupby machine_id and process_id and get the sum. Reset_index and drop columns that are not necessary (activity_type and process_id). \\n\\nThen perform another groupby using just the machine_id and get the mean for the summed timestamp values. \\n\\nReset_index again to bring back the machine_id column, rename columns for submission, and round to 3 decimal places.\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef get_average_time(activity: pd.DataFrame) -> pd.DataFrame:\\n    activity.loc[activity[\\'activity_type\\'] == \\'start\\', \\'timestamp\\'] *= -1\\n    return activity.groupby([\\'machine_id\\', \\'process_id\\']).sum().reset_index().drop(columns = [\\'activity_type\\', \\'process_id\\']).groupby(\\'machine_id\\').mean().reset_index().rename(columns={\\'timestamp\\': \\'processing_time\\'}).round(3)\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef get_average_time(activity: pd.DataFrame) -> pd.DataFrame:\\n    activity.loc[activity[\\'activity_type\\'] == \\'start\\', \\'timestamp\\'] *= -1\\n    return activity.groupby([\\'machine_id\\', \\'process_id\\']).sum().reset_index().drop(columns = [\\'activity_type\\', \\'process_id\\']).groupby(\\'machine_id\\').mean().reset_index().rename(columns={\\'timestamp\\': \\'processing_time\\'}).round(3)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4093538,
                "title": "average-time-processing-per-machine-self-join",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nSelect a.machine_id,round(avg(b.timestamp-a.timestamp),3) as processing_time from Activity a, Activity b where a.machine_id=b.machine_id and a.process_id=b.process_id and a.activity_type=\\'start\\' and b.activity_type=\\'end\\' group by machine_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSelect a.machine_id,round(avg(b.timestamp-a.timestamp),3) as processing_time from Activity a, Activity b where a.machine_id=b.machine_id and a.process_id=b.process_id and a.activity_type=\\'start\\' and b.activity_type=\\'end\\' group by machine_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4093382,
                "title": "mysql-convoluted-solution-but-good-run-time",
                "content": "I\\'m getting the sum of end times, subtracting the sum of start times and dividing that by the # of start-end sequences (in hindsight the AVG function would make this cleaner). \\n```\\n# Write your MySQL query statement below\\nSELECT a.machine_id,\\nROUND( \\n  (\\n    (SELECT SUM(timestamp) \\n      FROM Activity \\n      WHERE activity_type=\\'end\\' \\n      AND machine_id=a.machine_id) -\\n    (SELECT SUM(timestamp) \\n      FROM Activity \\n      WHERE activity_type=\\'start\\' \\n      AND machine_id=a.machine_id)\\n  ) / (COUNT(a.machine_id) /2), 3 \\n)\\n  AS processing_time\\nFROM Activity a\\nGROUP BY a.machine_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT a.machine_id,\\nROUND( \\n  (\\n    (SELECT SUM(timestamp) \\n      FROM Activity \\n      WHERE activity_type=\\'end\\' \\n      AND machine_id=a.machine_id) -\\n    (SELECT SUM(timestamp) \\n      FROM Activity \\n      WHERE activity_type=\\'start\\' \\n      AND machine_id=a.machine_id)\\n  ) / (COUNT(a.machine_id) /2), 3 \\n)\\n  AS processing_time\\nFROM Activity a\\nGROUP BY a.machine_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4091921,
                "title": "using-joins-and-group-by-only",
                "content": "\\n1. We want to find the average time it takes for each machine to complete a process. To do this, we need to calculate the time it takes for each process to complete on each machine.\\n\\n2. We start by creating a subquery (a query within a query) to calculate the time it takes for each process to complete. This subquery does the following:\\n   - It joins the \"activity\" table with itself (aliased as \\'a\\' and \\'b\\') based on three conditions:\\n     - The machine_id must be the same for both activities (\\'a.machine_id = b.machine_id\\').\\n     - The process_id must be the same for both activities (\\'a.process_id = b.process_id\\').\\n     - The activity_type of \\'a\\' must be different from the activity_type of \\'b\\' (\\'a.activity_type != b.activity_type\\'). This ensures that we are pairing a \"start\" activity with an \"end\" activity for the same process on the same machine.\\n   - It calculates the time it takes to complete the process by subtracting the \\'timestamp\\' of the \"start\" activity (\\'b.timestamp\\') from the \\'timestamp\\' of the \"end\" activity (\\'a.timestamp\\').\\n   - It only selects records where the \\'activity_type\\' of \\'a\\' is \\'end\\'. This filters out any \"start\" activities without corresponding \"end\" activities.\\n\\n3. After calculating the time it takes for each process to complete, we use this subquery as a source for our main query.\\n\\n4. In the main query, we group the results by \\'machine_id\\' because we want to find the average processing time for each machine.\\n\\n5. We use the \\'AVG\\' function to calculate the average processing time for each machine. The \\'Round\\' function is used to round the result to three decimal places, as specified in the problem statement.\\n\\n6. Finally, we select \\'machine_id\\' and the rounded average processing time as \\'processing_time\\' in our result table.\\n\\nSo, in summary, this query first pairs \"start\" and \"end\" activities for the same process on the same machine, calculates the time it takes for each process to complete, and then finds the average processing time for each machine by grouping the results. The \\'Round\\' function is used to format the result to three decimal places.\\n\\n\\n\\n# Code\\n```\\n\\n\\nselect machine_id, Round(avg(timer),3) as processing_time \\n    from\\n     (select a.machine_id ,(a.timestamp-b.timestamp) as timer \\n      from activity  a \\n      join activity  b \\n      on (a.machine_id=b.machine_id and a.process_id=b.process_id and a.activity_type!=b.activity_type) \\n      where a.activity_type=\\'end\\') \\ngroup by machine_id\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n\\n\\nselect machine_id, Round(avg(timer),3) as processing_time \\n    from\\n     (select a.machine_id ,(a.timestamp-b.timestamp) as timer \\n      from activity  a \\n      join activity  b \\n      on (a.machine_id=b.machine_id and a.process_id=b.process_id and a.activity_type!=b.activity_type) \\n      where a.activity_type=\\'end\\') \\ngroup by machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4088146,
                "title": "avg-time-of-process-per-machine",
                "content": "\\n# Code\\n```\\nSelect a1.machine_id , ROUND(AVG(a2.timestamp-a1.timestamp),3) AS processing_time \\nFROM Activity AS a1 JOIN Activity AS a2 ON\\na1.machine_id = a2.machine_id AND\\na1.process_id = a2.process_id WHERE\\na2.activity_type = \\'end\\' AND a1.activity_type =\\'start\\' \\nGROUP BY a1.machine_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSelect a1.machine_id , ROUND(AVG(a2.timestamp-a1.timestamp),3) AS processing_time \\nFROM Activity AS a1 JOIN Activity AS a2 ON\\na1.machine_id = a2.machine_id AND\\na1.process_id = a2.process_id WHERE\\na2.activity_type = \\'end\\' AND a1.activity_type =\\'start\\' \\nGROUP BY a1.machine_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4087358,
                "title": "not-an-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect table1.machine_id as machine_id, round(end-start,3) as processing_time from (select machine_id,avg(timestamp) as start from\\n (select machine_id,timestamp from activity where activity_type=\\'start\\') as a group by machine_id) table1 \\n inner join \\n (select machine_id,avg(timestamp) as end from (select machine_id,timestamp from activity where activity_type=\\'end\\') as a group by machine_id) as table2 on table1.machine_id=table2.machine_id; \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect table1.machine_id as machine_id, round(end-start,3) as processing_time from (select machine_id,avg(timestamp) as start from\\n (select machine_id,timestamp from activity where activity_type=\\'start\\') as a group by machine_id) table1 \\n inner join \\n (select machine_id,avg(timestamp) as end from (select machine_id,timestamp from activity where activity_type=\\'end\\') as a group by machine_id) as table2 on table1.machine_id=table2.machine_id; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4086876,
                "title": "join-avg-round",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo the join and have the start and end time of each process in single column\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nDo the join operation with following *ON* condition:\\n                        a1.machine_id = a2.machine_id   \\n                        and a1.process_id = a2.process_id \\n                        and a1.activity_type != a2.activity_type\\n                        and a1.activity_type != \\'start\\'\\nwe will have end and start time of process in single column\\n\\nthen we can group by machine_id and calculate the avg of the timestamp\\n\\n\\n**Hope the solution helps**\\n**Please upvote if you like the solution**\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\n\\n\\n\\nselect  a1.machine_id,\\n        ROUND(Avg(a1.timestamp - a2.timestamp), 3) as processing_time\\nfrom activity as a1\\njoin\\nactivity as a2\\non a1.machine_id = a2.machine_id \\n                        and a1.process_id = a2.process_id \\n                        and a1.activity_type != a2.activity_type\\n                        and a1.activity_type != \\'start\\'\\n                        \\n  group by a1.machine_id;\\n                        \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\n\\n\\n\\nselect  a1.machine_id,\\n        ROUND(Avg(a1.timestamp - a2.timestamp), 3) as processing_time\\nfrom activity as a1\\njoin\\nactivity as a2\\non a1.machine_id = a2.machine_id \\n                        and a1.process_id = a2.process_id \\n                        and a1.activity_type != a2.activity_type\\n                        and a1.activity_type != \\'start\\'\\n                        \\n  group by a1.machine_id;\\n                        \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4086010,
                "title": "easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect a1.machine_id , round(avg(a2.timestamp-a1.timestamp),3) as processing_time\\nfrom Activity a1\\njoin Activity a2\\non a1.machine_id=a2.machine_id and a1.process_id=a2.process_id and\\na1.activity_type=\\'start\\' and a2.activity_type=\\'end\\'\\ngroup by a1.machine_id\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect a1.machine_id , round(avg(a2.timestamp-a1.timestamp),3) as processing_time\\nfrom Activity a1\\njoin Activity a2\\non a1.machine_id=a2.machine_id and a1.process_id=a2.process_id and\\na1.activity_type=\\'start\\' and a2.activity_type=\\'end\\'\\ngroup by a1.machine_id\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4084824,
                "title": "easy-solution-simply-explained",
                "content": "### Main idea: Calculate the average of the start timestamps and subtract from it the average of the end timestamps (for each machine_id). \\nWhy does this work ? Becouse ((e1-s1) + (e2-s2) + ... + (en - sn)) / n = (e1+e2+...+en)/n - (s1+s2+...+sn)/n \\n\\n\\n\\n# Code\\n```\\nselect\\n    machine_id, \\n    round(averageE - averagesS, 3) as processing_time\\nfrom \\n    (select \\n        x.machine_id, \\n        avg(x.averagestart) as averagesS, \\n        avg(y.averageend) as averageE\\n   \\n    from \\n        (select\\n            machine_id, \\n            avg(timestamp) as averagestart\\n        from activity \\n        where activity_type = \\'start\\'\\n        group by machine_id) as x\\n    join\\n        (select \\n            machine_id, \\n            avg(timestamp) as averageend \\n        from activity\\n        where activity_type = \\'end\\'\\n        group by machine_id) as y\\n        on x.machine_id = y.machine_id\\ngroup by machine_id\\n) as q\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect\\n    machine_id, \\n    round(averageE - averagesS, 3) as processing_time\\nfrom \\n    (select \\n        x.machine_id, \\n        avg(x.averagestart) as averagesS, \\n        avg(y.averageend) as averageE\\n   \\n    from \\n        (select\\n            machine_id, \\n            avg(timestamp) as averagestart\\n        from activity \\n        where activity_type = \\'start\\'\\n        group by machine_id) as x\\n    join\\n        (select \\n            machine_id, \\n            avg(timestamp) as averageend \\n        from activity\\n        where activity_type = \\'end\\'\\n        group by machine_id) as y\\n        on x.machine_id = y.machine_id\\ngroup by machine_id\\n) as q\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4084806,
                "title": "beats-94-55-of-users-with-mysql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT \\n  Activity_1.machine_id,\\n  ROUND(AVG(processing_time),3) processing_time \\nFROM (\\n  SELECT \\n    Activity.machine_id,\\n    Activity.process_id,\\n    ROUND((Activity.end_time-Activity.start_time),3) processing_time \\n  FROM (\\n    SELECT\\n      machine_id,\\n      process_id,\\n      SUM(CASE WHEN activity_type=\\'start\\' THEN timestamp END) AS start_time, \\n      SUM(CASE WHEN activity_type=\\'end\\' THEN timestamp END) AS end_time\\n    FROM Activity  GROUP BY 1,2\\n      ) Activity \\n    ) Activity_1 \\n  GROUP BY \\n    Activity_1.machine_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT \\n  Activity_1.machine_id,\\n  ROUND(AVG(processing_time),3) processing_time \\nFROM (\\n  SELECT \\n    Activity.machine_id,\\n    Activity.process_id,\\n    ROUND((Activity.end_time-Activity.start_time),3) processing_time \\n  FROM (\\n    SELECT\\n      machine_id,\\n      process_id,\\n      SUM(CASE WHEN activity_type=\\'start\\' THEN timestamp END) AS start_time, \\n      SUM(CASE WHEN activity_type=\\'end\\' THEN timestamp END) AS end_time\\n    FROM Activity  GROUP BY 1,2\\n      ) Activity \\n    ) Activity_1 \\n  GROUP BY \\n    Activity_1.machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4084762,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nSELECT a1.machine_id, round(avg(a2.timestamp-a1.timestamp), 3) as processing_time \\nFROM Activity a1\\nJOIN Activity a2 on a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id\\nAND a1.activity_type=\\'start\\' AND a2.activity_type=\\'end\\'\\nGROUP By a1.machine_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nSELECT a1.machine_id, round(avg(a2.timestamp-a1.timestamp), 3) as processing_time \\nFROM Activity a1\\nJOIN Activity a2 on a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id\\nAND a1.activity_type=\\'start\\' AND a2.activity_type=\\'end\\'\\nGROUP By a1.machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4084643,
                "title": "using-left-join-easy-solution",
                "content": "# Intuition\\nCalculating procissing time for each process on every machine and then averaging it\\n\\n# Approach\\nConsider the table as a1 and a2.\\na1 should only contain start time and a2 should only contain end time.\\nSubtracting a1.starttime from a2.endtime will give processing time for each process on every machine.\\n\\nThen use this table to get averages.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect machine_id, ROUND(sum(processing_time)/(max(process_id)+1), 3) as processing_time\\nfrom\\n(\\nselect machine_id,  a1.process_id as process_id, (a2.timestamp - a1.timestamp) as processing_time\\nfrom Activity as a1 left join Activity as a2 using(machine_id)\\nwhere a1.activity_type = \"start\" and a2.activity_type = \"end\" and a1.process_id = a2.process_id\\norder by machine_id\\n)\\nAS result\\n\\ngroup by machine_id\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect machine_id, ROUND(sum(processing_time)/(max(process_id)+1), 3) as processing_time\\nfrom\\n(\\nselect machine_id,  a1.process_id as process_id, (a2.timestamp - a1.timestamp) as processing_time\\nfrom Activity as a1 left join Activity as a2 using(machine_id)\\nwhere a1.activity_type = \"start\" and a2.activity_type = \"end\" and a1.process_id = a2.process_id\\norder by machine_id\\n)\\nAS result\\n\\ngroup by machine_id\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4084041,
                "title": "oracle-easy-fast-solution",
                "content": "\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\nselect a1.machine_id, round(avg(a2.timestamp - a1.timestamp), 3) as processing_time\\nfrom activity a1, activity a2\\nwhere a1.machine_id=a2.machine_id\\nand a1.process_id=a2.process_id\\nand a1.timestamp < a2.timestamp\\ngroup by a1.machine_id;\\n\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nselect a1.machine_id, round(avg(a2.timestamp - a1.timestamp), 3) as processing_time\\nfrom activity a1, activity a2\\nwhere a1.machine_id=a2.machine_id\\nand a1.process_id=a2.process_id\\nand a1.timestamp < a2.timestamp\\ngroup by a1.machine_id;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4083341,
                "title": "beats-93-44-of-users-with-ms-sql-server",
                "content": "Beats 93.44%of users with MS SQL Server\\r\\n\\r\\n# Code\\r\\n```\\r\\n/* Write your T-SQL query statement below */\\r\\n\\r\\nwith cte as\\r\\n(\\r\\n   Select *,--count(machine_id) over(partition by machine_id) as a,\\r\\n   lag(timestamp,1) over(partition by machine_id,process_id order by timestamp) as b\\r\\n   from activity\\r\\n)\\r\\nselect machine_id,\\r\\nround(sum(timestamp-b) * 1.000/count(machine_id),3) as processing_time from cte\\r\\nwhere activity_type = \\'end\\'\\r\\ngroup by machine_id\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\r\\n/* Write your T-SQL query statement below */\\r\\n\\r\\nwith cte as\\r\\n(\\r\\n   Select *,--count(machine_id) over(partition by machine_id) as a,\\r\\n   lag(timestamp,1) over(partition by machine_id,process_id order by timestamp) as b\\r\\n   from activity\\r\\n)\\r\\nselect machine_id,\\r\\nround(sum(timestamp-b) * 1.000/count(machine_id),3) as processing_time from cte\\r\\nwhere activity_type = \\'end\\'\\r\\ngroup by machine_id\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4081983,
                "title": "beats-93-39-of-users-with-mysql",
                "content": "# Intuition\\nUse the process_id as a divisor and use min and max to get the difference \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSelect\\nmachine_id,\\nROUND(SUM(processing_time) / SUM(x), 3) as  processing_time\\nfrom(\\nselect distinct\\nmachine_id,\\nprocess_id,\\nDENSE_RANK() OVER ( PARTITION BY process_id\\n        ORDER BY process_id\\n    )  x,\\n(MAX(timestamp)  -  MIN(timestamp)) processing_time\\nfrom Activity\\ngroup by machine_id ,  process_id ) as a\\ngroup by machine_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSelect\\nmachine_id,\\nROUND(SUM(processing_time) / SUM(x), 3) as  processing_time\\nfrom(\\nselect distinct\\nmachine_id,\\nprocess_id,\\nDENSE_RANK() OVER ( PARTITION BY process_id\\n        ORDER BY process_id\\n    )  x,\\n(MAX(timestamp)  -  MIN(timestamp)) processing_time\\nfrom Activity\\ngroup by machine_id ,  process_id ) as a\\ngroup by machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4081924,
                "title": "sql-two-approaches",
                "content": "# Code\\n\\n## Option 1\\n\\n```\\nSELECT \\n  a1.machine_id,\\n  round(avg(a1.timestamp - a2.timestamp), 3) AS processing_time\\nFROM Activity a1 \\nINNER JOIN Activity a2 \\n  ON a1.machine_id = a2.machine_id\\n    AND a1.process_id = a2.process_id \\n    AND a1.activity_type = \\'end\\'\\n    AND a2.activity_type = \\'start\\'\\nGROUP BY a1.machine_id\\n```\\n\\n## Option 2\\n\\n```\\nSELECT \\n  a1.machine_id,\\n  round(avg(a2.max - a2.min), 3) AS processing_time\\nFROM Activity a1 \\nINNER JOIN (\\n    SELECT \\n      machine_id, \\n      max(timestamp) AS max, \\n      min(timestamp) AS min\\n    FROM Activity\\n    GROUP BY machine_id, process_id\\n  ) a2 ON a1.machine_id = a2.machine_id\\nGROUP BY a1.machine_id\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server"
                ],
                "code": "```\\nSELECT \\n  a1.machine_id,\\n  round(avg(a1.timestamp - a2.timestamp), 3) AS processing_time\\nFROM Activity a1 \\nINNER JOIN Activity a2 \\n  ON a1.machine_id = a2.machine_id\\n    AND a1.process_id = a2.process_id \\n    AND a1.activity_type = \\'end\\'\\n    AND a2.activity_type = \\'start\\'\\nGROUP BY a1.machine_id\\n```\n```\\nSELECT \\n  a1.machine_id,\\n  round(avg(a2.max - a2.min), 3) AS processing_time\\nFROM Activity a1 \\nINNER JOIN (\\n    SELECT \\n      machine_id, \\n      max(timestamp) AS max, \\n      min(timestamp) AS min\\n    FROM Activity\\n    GROUP BY machine_id, process_id\\n  ) a2 ON a1.machine_id = a2.machine_id\\nGROUP BY a1.machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4081069,
                "title": "mysql-only-group-by-avg-if-my-solution-is-diff",
                "content": "# Intuition\\nThe query aims to calculate the average processing time for each machine based on activities recorded in a database. It appears to involve conditional calculations of time differences for different activity types and then averaging those differences for each machine.\\n\\n# Approach\\n1. The query selects data from the `activity` table.\\n2. It groups the data by `machine_id`, meaning it will calculate the average processing time for each unique machine.\\n3. Inside the `avg` function, there\\'s a conditional check using `If(activity_type = \"end\", timestamp, -timestamp)`. This means that if the `activity_type` is \"end,\" it takes the `timestamp` value as is, and if it\\'s not \"end,\" it negates the `timestamp` value (likely indicating the start time).\\n4. The `avg` function calculates the average of these modified `timestamp` values.\\n5. The key to ensure the result is in the desired result is the result is multiplied by 2. Because, when we calculate the `avg` function, we divide for both the timestamp of *end* and *start*). \\nEx: Let\\'s say there\\'s a machine with 3 `processes`. This means there are 6 `activities` in total. If we calculate the average, it would divides the total number of `activities` (6) by the number of `processes` (3). However, if we only want to divide by 3 `processes`, we need to multiply the result by `2` to get the most accurate outcome.\\n6. Then rounded to 3 decimal places.\\n7. The result is labeled as `processing_time` in the output.\\n\\n# Complexity\\n- Time complexity: The time complexity of this query depends on the size of the `activity` table and the number of unique `machine_id` values. It involves grouping and conditional calculations, so it may have a time complexity of approximately O(n), where n is the number of rows in the `activity` table.\\n- Space complexity: The space complexity of this query is generally related to the memory required for processing and storing intermediate results. It\\'s also influenced by the size of the result set, which in this case, consists of one row per unique `machine_id`. So, the space complexity can be considered moderate, depending on the database\\'s query optimization and indexing.\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nSELECT machine_id, \\n    ROUND(\\n        AVG(\\n            IF(activity_type = \"end\", timestamp, -timestamp)) * 2, 3) as processing_time \\nFROM activity \\nGROUP BY machine_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nSELECT machine_id, \\n    ROUND(\\n        AVG(\\n            IF(activity_type = \"end\", timestamp, -timestamp)) * 2, 3) as processing_time \\nFROM activity \\nGROUP BY machine_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4078920,
                "title": "clean-solution-with-100-and-explanation-of-each-step",
                "content": "# Code\\n```\\nSELECT \\n  a1.machine_id, \\n  ROUND(AVG(a2.timestamp - a1.timestamp), 3) AS processing_time \\n  FROM Activity a1 \\n    INNER JOIN Activity a2 \\n      ON a1.machine_id = a2.machine_id \\n      AND a1.process_id = a2.process_id \\n      AND a1.activity_type = \\'start\\' \\n      AND a2.activity_type = \\'end\\'\\nGROUP BY machine_id\\n```\\n\\n# Explanation\\nWe know that for a given machine_id and process_id, there will be 2 rows in the table: 1 for start and 1 for end.\\nWe want to select these 2 rows as one, such that we can then find the processing time. To do this, we apply `INNER JOIN` on the same table with the condition (`ON`) that the machine_id and process_id are the same (`a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id`). \\nNext we can used the first table to get the start process, and the second table to get the second process. We do this by specifying `a1.activity_type = \\'start\\'` and `a2.activity_type = \\'end\\'`, resulting in a2 being the end process and a1 being the start process.\\n\\nNow that we have a1 as start, and a2 as end process for a given machine_id and process_id, we find the processing_time by subtracting start from end with `a2.timestamp - a1.timestamp`.\\nTo find the average of a machine of all processes, we find the average in 2 parts. First we apply `AVG()` method to the processing_time and use `GROUP BY machine_id` as we need average of all processes for a given machine_id.\\n\\nLastly, with the average processing_time, we use the `ROUND(_, 3)` method to round the average to 3 decimal places.\\n\\nHope this helps!\\n\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT \\n  a1.machine_id, \\n  ROUND(AVG(a2.timestamp - a1.timestamp), 3) AS processing_time \\n  FROM Activity a1 \\n    INNER JOIN Activity a2 \\n      ON a1.machine_id = a2.machine_id \\n      AND a1.process_id = a2.process_id \\n      AND a1.activity_type = \\'start\\' \\n      AND a2.activity_type = \\'end\\'\\nGROUP BY machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4078785,
                "title": "using-if-inside-select-thought-of-an-excel-user",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen working with the average value of data, I only care about the number of divisions and the total number of divisions. So I approach using Excel\\'s trick with the sum function \"sumif\" and it works\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproaching the problem: I think the problem is approached by 2 different times according to arithmetic as follows: when activity_type = end, the value is a positive number, when activity_type = start, the value is a negative number.\\n# Note\\nRemember to use group by and round to get the desired results\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT machine_id, \\n      round((SUM(IF(activity_type = \\'end\\', timestamp, 0)) - SUM(IF(activity_type = \\'start\\', timestamp, 0)))/COUNT(DISTINCT process_id),3) AS processing_time\\nFROM Activity\\nGROUP BY machine_id\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT machine_id, \\n      round((SUM(IF(activity_type = \\'end\\', timestamp, 0)) - SUM(IF(activity_type = \\'start\\', timestamp, 0)))/COUNT(DISTINCT process_id),3) AS processing_time\\nFROM Activity\\nGROUP BY machine_id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4074795,
                "title": "usando-pivot-round-avg-group-by",
                "content": "# Intuition\\nHay que tomarlo desde la perspectiva del Pivot\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nFacil no esta, es poco codigo, pero involucra muchos elementos\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nSELECT machine_id,ROUND(AVG([end]-[start]),3) as processing_time FROM\\n        (\\n          SELECT machine_id,activity_type,timestamp\\n          FROM Activity\\n        ) as T\\n        Pivot\\n        (AVG(timestamp)\\n        FOR Activity_type in ([start],[end])\\n        ) AS P\\n        GROUP BY machine_id\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nSELECT machine_id,ROUND(AVG([end]-[start]),3) as processing_time FROM\\n        (\\n          SELECT machine_id,activity_type,timestamp\\n          FROM Activity\\n        ) as T\\n        Pivot\\n        (AVG(timestamp)\\n        FOR Activity_type in ([start],[end])\\n        ) AS P\\n        GROUP BY machine_id\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4074402,
                "title": "mssql",
                "content": "# Code\\n```\\n/* Write your T-SQL query statement below */\\n\\nselect\\n    machine_id,\\n    round(avg(duration),3) as processing_time\\nfrom (    \\n    select\\n        start.machine_id,\\n        start.process_id,\\n        e.timestamp-start.timestamp as duration\\n    from Activity start\\n    inner join Activity e on e.machine_id=start.machine_id and e.process_id=start.process_id and e.activity_type=\\'end\\'\\n    where start.activity_type=\\'start\\'\\n) as aa\\ngroup by machine_id\\n```",
                "solutionTags": [
                    "MS SQL Server",
                    "Database"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\n\\nselect\\n    machine_id,\\n    round(avg(duration),3) as processing_time\\nfrom (    \\n    select\\n        start.machine_id,\\n        start.process_id,\\n        e.timestamp-start.timestamp as duration\\n    from Activity start\\n    inner join Activity e on e.machine_id=start.machine_id and e.process_id=start.process_id and e.activity_type=\\'end\\'\\n    where start.activity_type=\\'start\\'\\n) as aa\\ngroup by machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4074311,
                "title": "runtime-461ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT TF.machine_id as machine_id, ROUND(AVG(TF.timediff),3) as processing_time\\nFROM (SELECT A.machine_id as machine_id, (B.timestamp-A.timestamp) as timediff\\nFROM Activity as A, Activity as B\\nWHERE  A.machine_id = B.machine_id and\\nA.process_id = B.process_id and \\nA.activity_type = \"start\" and \\nB.activity_type = \"end\") TF\\nGROUP BY machine_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT TF.machine_id as machine_id, ROUND(AVG(TF.timediff),3) as processing_time\\nFROM (SELECT A.machine_id as machine_id, (B.timestamp-A.timestamp) as timediff\\nFROM Activity as A, Activity as B\\nWHERE  A.machine_id = B.machine_id and\\nA.process_id = B.process_id and \\nA.activity_type = \"start\" and \\nB.activity_type = \"end\") TF\\nGROUP BY machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4073006,
                "title": "using-nested-query-and-not-self-join",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect machine_id, round(avg(timestamp),3) processing_time\\nfrom(\\nselect machine_id, process_id, (max(timestamp) - min(timestamp)) timestamp\\nfrom Activity a\\ngroup by machine_id,process_id\\n) tab1\\ngroup by machine_id\\n;\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect machine_id, round(avg(timestamp),3) processing_time\\nfrom(\\nselect machine_id, process_id, (max(timestamp) - min(timestamp)) timestamp\\nfrom Activity a\\ngroup by machine_id,process_id\\n) tab1\\ngroup by machine_id\\n;\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4070214,
                "title": "mysql-easy-solution-beats-95-69-in-time-complexity-beats-100-in-space-complexity",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect a1.machine_id, round(avg(a1.timestamp-a2.timestamp),3) as processing_time\\nfrom activity a1, activity a2\\nwhere a1.activity_type = \\'end\\' and a2.activity_type = \\'start\\' and a1.machine_id = a2.machine_id and a1.process_id = a2.process_id\\ngroup by a1.machine_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect a1.machine_id, round(avg(a1.timestamp-a2.timestamp),3) as processing_time\\nfrom activity a1, activity a2\\nwhere a1.activity_type = \\'end\\' and a2.activity_type = \\'start\\' and a1.machine_id = a2.machine_id and a1.process_id = a2.process_id\\ngroup by a1.machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4070074,
                "title": "simple-two-loops",
                "content": "# Intuition\\nsimple two loops\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect machine_id, ROUND(sum(diff)/count(machine_id),3) as processing_time from ( select  t1.machine_id, t1.process_id,  \\n(\\n  select t2.timestamp-t1.timestamp \\n  from Activity t2 where \\n  t1.machine_id=t2.machine_id and  \\n  t1.process_id=t2.process_id  and \\n  t1.activity_type=\\'start\\' and \\n  t2.activity_type=\\'end\\'\\n)\\n as diff  from Activity t1 where  t1.activity_type=\\'start\\') as t3  group by machine_id;\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect machine_id, ROUND(sum(diff)/count(machine_id),3) as processing_time from ( select  t1.machine_id, t1.process_id,  \\n(\\n  select t2.timestamp-t1.timestamp \\n  from Activity t2 where \\n  t1.machine_id=t2.machine_id and  \\n  t1.process_id=t2.process_id  and \\n  t1.activity_type=\\'start\\' and \\n  t2.activity_type=\\'end\\'\\n)\\n as diff  from Activity t1 where  t1.activity_type=\\'start\\') as t3  group by machine_id;\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4068239,
                "title": "97-21-easy-mysql-solution",
                "content": "# Intuition\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# heading\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nSelect a.machine_id as machine_id,\\nround( avg( a.timeCal ) ,3)  as processing_time \\n from \\n(\\nSelect machine_id ,\\nround( timestamp ,3 ) - lag ( round( timestamp ,3 ) ) \\nover(PARTITION BY  machine_id ,Process_id  order by  machine_id ,Process_id , activity_type   ) as timeCal\\nfrom Activity\\n) a\\nwhere a.timeCal is not null \\ngroup by a.machine_id\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nSelect a.machine_id as machine_id,\\nround( avg( a.timeCal ) ,3)  as processing_time \\n from \\n(\\nSelect machine_id ,\\nround( timestamp ,3 ) - lag ( round( timestamp ,3 ) ) \\nover(PARTITION BY  machine_id ,Process_id  order by  machine_id ,Process_id , activity_type   ) as timeCal\\nfrom Activity\\n) a\\nwhere a.timeCal is not null \\ngroup by a.machine_id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4067477,
                "title": "mysql-solution-using-simple-cte",
                "content": "# Intuition\\ndone using the cte \\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nwith cte1 as\\n(select machine_id, process_id,timestamp from activity where activity_type = \"start\"),\\ncte2 as\\n(select machine_id, process_id,timestamp from activity where activity_type = \"end\")\\nselect a.machine_id as machine_id, round(avg(b.timestamp - a.timestamp),3) as processing_time\\nfrom cte1 a\\njoin cte2 b\\non a.machine_id = b.machine_id and a.process_id = b.process_id\\ngroup by machine_id\\norder by machine_id \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nwith cte1 as\\n(select machine_id, process_id,timestamp from activity where activity_type = \"start\"),\\ncte2 as\\n(select machine_id, process_id,timestamp from activity where activity_type = \"end\")\\nselect a.machine_id as machine_id, round(avg(b.timestamp - a.timestamp),3) as processing_time\\nfrom cte1 a\\njoin cte2 b\\non a.machine_id = b.machine_id and a.process_id = b.process_id\\ngroup by machine_id\\norder by machine_id \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4067408,
                "title": "mysql-beats-99-99-solution-self-join-and-where-condition-with-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThere are 3 main components in this query:\\n1. **Self join:** Self join has to be used because start and end activities are listed in same table and we have to calculate the difference between them. So we joined the tables based on machine and process ids but we also wanted to think of table 1 with all start dates and table 2 with all end dates. Now, that is not possible to add in ON condition \\n2. **Where condition:** So the where condition came into picture. We separated table 1 and table 2 for start and end conditions and picked start condition from 1 table and end condition from another table\\n3. **Calculation of Average:** For calculation, we need end time - start time divided by total number of distinct processes (distinct is not required here because we are splitting start processes into 1 table and end processed into other table so process ids are not repeated)\\n4. Grouping is done on machine id only because obviously we need result for each machine only\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSelect a1.machine_id as machine_id ,\\nround(sum(a2.timestamp - a1.timestamp)/count(a1.process_id),3) as processing_time\\nfrom Activity a1 join \\nActivity a2\\non a1.machine_id = a2.machine_id and a1.process_id = a2.process_id \\nwhere a1.activity_type = \\'start\\' and a2.activity_type = \\'end\\'\\ngroup by a1.machine_id \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSelect a1.machine_id as machine_id ,\\nround(sum(a2.timestamp - a1.timestamp)/count(a1.process_id),3) as processing_time\\nfrom Activity a1 join \\nActivity a2\\non a1.machine_id = a2.machine_id and a1.process_id = a2.process_id \\nwhere a1.activity_type = \\'start\\' and a2.activity_type = \\'end\\'\\ngroup by a1.machine_id \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4065395,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect A1.machine_id,Round(sum(A2.timestamp-A1.timestamp)/count(A1.process_id),3) as processing_time\\nfrom Activity A1 \\njoin Activity A2 \\non A1.machine_id=A2.machine_id \\nand A1.process_id =A2.process_id \\nand A1.activity_type =\"Start\" \\nand A2.activity_type=\"end\"\\ngroup by machine_id\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect A1.machine_id,Round(sum(A2.timestamp-A1.timestamp)/count(A1.process_id),3) as processing_time\\nfrom Activity A1 \\njoin Activity A2 \\non A1.machine_id=A2.machine_id \\nand A1.process_id =A2.process_id \\nand A1.activity_type =\"Start\" \\nand A2.activity_type=\"end\"\\ngroup by machine_id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4064333,
                "title": "oracle-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\nselect \\n    machine_id,\\n    round(sum(processing_time)/count(processing_time), 3) as processing_time\\nfrom (\\n    select\\n        s.machine_id,\\n        s.process_id,\\n        e.timestamp-s.timestamp as processing_time\\n    from \\n        Activity s,\\n        Activity e\\n    where\\n        s.machine_id = e.machine_id and \\n        s.process_id = e.process_id and\\n        s.activity_type=\\'start\\' and\\n        e.activity_type=\\'end\\'\\n)\\ngroup by machine_id\\n\\n\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nselect \\n    machine_id,\\n    round(sum(processing_time)/count(processing_time), 3) as processing_time\\nfrom (\\n    select\\n        s.machine_id,\\n        s.process_id,\\n        e.timestamp-s.timestamp as processing_time\\n    from \\n        Activity s,\\n        Activity e\\n    where\\n        s.machine_id = e.machine_id and \\n        s.process_id = e.process_id and\\n        s.activity_type=\\'start\\' and\\n        e.activity_type=\\'end\\'\\n)\\ngroup by machine_id\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4063442,
                "title": "sql-server-solution-using-pivot-cte-group-by-avg",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Using PIVOT to seperate \\'start\\' and \\'end\\' type timestamp values.\\n- Then, getting a duration column by subtracting start timestamp from end timestamp.\\n- Then, using this table as \\'base_table\\' in CTE, and applying grouping of \\'machine_id\\' and average() on the \\'duration\\' column.\\n- Lastly, applying ROUND() and CAST() function to format the output as required.\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nWITH base_tbl AS (\\n\\tSELECT *, [end]-[start] AS duration FROM Activity\\n\\tPIVOT (\\n\\t\\tSUM(timestamp)\\n\\t\\tFOR activity_type IN ([start],[end])\\n\\t) AS pivot_table\\n)\\nSELECT machine_id, CAST(ROUND(AVG(duration), 3) AS DECIMAL(10,3) ) processing_time FROM base_tbl\\nGROUP BY machine_id;\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nWITH base_tbl AS (\\n\\tSELECT *, [end]-[start] AS duration FROM Activity\\n\\tPIVOT (\\n\\t\\tSUM(timestamp)\\n\\t\\tFOR activity_type IN ([start],[end])\\n\\t) AS pivot_table\\n)\\nSELECT machine_id, CAST(ROUND(AVG(duration), 3) AS DECIMAL(10,3) ) processing_time FROM base_tbl\\nGROUP BY machine_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4062127,
                "title": "easy-3-line-solution-basic-mathematics",
                "content": "# Intuition\\nBasic mathematics\\navg_processing_time\\n= sum(processing_time) / count(process)\\n= sum(end_time - start_time) / count((start + end) / 2)\\n= 2 * (sum(end_time) - sum(start_time)) / count(start + end)\\n\\n# Code\\n```\\nselect machine_id, round(2 * sum(timestamp * if(activity_type=\\'start\\', -1, 1)) / count(*), 3) processing_time\\nfrom Activity\\ngroup by machine_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect machine_id, round(2 * sum(timestamp * if(activity_type=\\'start\\', -1, 1)) / count(*), 3) processing_time\\nfrom Activity\\ngroup by machine_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4062004,
                "title": "sub-query-is-more-straightforward",
                "content": "# Intuition\\n<!-- Take advantage of **\"same number of processes\"** -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT X.machine_id, ROUND(MAX(avg_timestamp) - MIN(avg_timestamp), 3) AS processing_time\\nFROM\\n(SELECT machine_id, AVG(A.timestamp) as avg_timestamp\\nFROM Activity AS A\\nGROUP BY A.machine_id, A.activity_type\\n) AS X\\nGROUP BY X.machine_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT X.machine_id, ROUND(MAX(avg_timestamp) - MIN(avg_timestamp), 3) AS processing_time\\nFROM\\n(SELECT machine_id, AVG(A.timestamp) as avg_timestamp\\nFROM Activity AS A\\nGROUP BY A.machine_id, A.activity_type\\n) AS X\\nGROUP BY X.machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4059293,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT t1.machine_id machine_id,round(avg(diff),3) as processing_time\\nFROM(\\n    SELECT a.machine_id,a.process_id,abs(a.timestamp-b.timestamp) as diff\\n\\n    FROM Activity a\\n    INNER JOIN Activity b\\n    on a.machine_id = b.machine_id\\n    AND a.process_id = b.process_id\\n    AND a.activity_type = \\'start\\' AND b.activity_type = \\'end\\'\\n)t1\\n\\nGROUP BY t1.machine_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT t1.machine_id machine_id,round(avg(diff),3) as processing_time\\nFROM(\\n    SELECT a.machine_id,a.process_id,abs(a.timestamp-b.timestamp) as diff\\n\\n    FROM Activity a\\n    INNER JOIN Activity b\\n    on a.machine_id = b.machine_id\\n    AND a.process_id = b.process_id\\n    AND a.activity_type = \\'start\\' AND b.activity_type = \\'end\\'\\n)t1\\n\\nGROUP BY t1.machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4058303,
                "title": "with-cte-approach",
                "content": "\\n\\n# Code\\n```\\nwith start_table as\\n(\\n  select * from activity \\n  where activity_type = \\'start\\'\\n),\\nend_table as \\n(\\n  select * from activity\\n  where activity_type = \\'end\\'\\n) \\n\\nselect a.machine_id, round(sum(b.timestamp-a.timestamp)/count(a.process_id),3) as processing_time\\nfrom start_table a\\ninner join end_table b\\non a.machine_id = b.machine_id\\nand a.process_id = b.process_id\\ngroup by machine_id\\n\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nwith start_table as\\n(\\n  select * from activity \\n  where activity_type = \\'start\\'\\n),\\nend_table as \\n(\\n  select * from activity\\n  where activity_type = \\'end\\'\\n) \\n\\nselect a.machine_id, round(sum(b.timestamp-a.timestamp)/count(a.process_id),3) as processing_time\\nfrom start_table a\\ninner join end_table b\\non a.machine_id = b.machine_id\\nand a.process_id = b.process_id\\ngroup by machine_id\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4057690,
                "title": "mysql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT \\n    A1.machine_id,\\n    ROUND(AVG(A2.timestamp - A1.timestamp), 3) AS processing_time\\nFROM \\n    (SELECT machine_id, process_id, timestamp \\n     FROM Activity \\n     WHERE activity_type = \\'start\\') AS A1\\nJOIN \\n    (SELECT machine_id, process_id, timestamp \\n     FROM Activity \\n     WHERE activity_type = \\'end\\') AS A2\\nON \\n    A1.machine_id = A2.machine_id AND A1.process_id = A2.process_id\\nGROUP BY \\n    A1.machine_id;\\n\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT \\n    A1.machine_id,\\n    ROUND(AVG(A2.timestamp - A1.timestamp), 3) AS processing_time\\nFROM \\n    (SELECT machine_id, process_id, timestamp \\n     FROM Activity \\n     WHERE activity_type = \\'start\\') AS A1\\nJOIN \\n    (SELECT machine_id, process_id, timestamp \\n     FROM Activity \\n     WHERE activity_type = \\'end\\') AS A2\\nON \\n    A1.machine_id = A2.machine_id AND A1.process_id = A2.process_id\\nGROUP BY \\n    A1.machine_id;\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4056994,
                "title": "easy-to-understand",
                "content": "# Intuition\\nit must use group by clause\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\njoining the tables to calculate difference between two values of the same column\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 4.19ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 0.0 MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect t.machine_id as machine_id , round(avg(t.d),3)\\nas processing_time\\nfrom\\n(select a.machine_id,b.timestamp-a.timestamp as d\\nfrom Activity a inner join Activity b\\non a.machine_id=b.machine_id\\nand a.process_id=b.process_id\\nand a.activity_type=\\'start\\' \\nand b.activity_type=\\'end\\') as t\\ngroup by t.machine_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect t.machine_id as machine_id , round(avg(t.d),3)\\nas processing_time\\nfrom\\n(select a.machine_id,b.timestamp-a.timestamp as d\\nfrom Activity a inner join Activity b\\non a.machine_id=b.machine_id\\nand a.process_id=b.process_id\\nand a.activity_type=\\'start\\' \\nand b.activity_type=\\'end\\') as t\\ngroup by t.machine_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4056407,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nSelect s.machine_id,\\nRound(AVG(e.timestamp-s.timestamp),3) as processing_time\\nFrom Activity e\\nJoin Activity s ON s.machine_id=e.machine_id\\nwhere s.activity_type=\\'start\\' AND e.activity_type=\\'end\\'\\nGROUP BY s.machine_id\\n \\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSelect s.machine_id,\\nRound(AVG(e.timestamp-s.timestamp),3) as processing_time\\nFrom Activity e\\nJoin Activity s ON s.machine_id=e.machine_id\\nwhere s.activity_type=\\'start\\' AND e.activity_type=\\'end\\'\\nGROUP BY s.machine_id\\n \\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4054660,
                "title": "why-don-t-try-if-statement-here",
                "content": "# JAI HIND JAI BHARAT\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n->>Approach is simply to group it according to machine_id\\n\\n->>and then using if statement we - if its start and + if its end\\n\\n->>We find the average and before rounding it to 3 decimal place we multiply with 2.\\n\\n->>Rest of the work will be done by round().\\n\\nDo upvote if you have understood my simple uproach. :-) \\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nselect machine_id,round(avg(if(activity_type = \"start\",-timestamp,+timestamp))*2,3) as processing_time\\nfrom Activity \\ngroup by machine_id;\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect machine_id,round(avg(if(activity_type = \"start\",-timestamp,+timestamp))*2,3) as processing_time\\nfrom Activity \\ngroup by machine_id;\\n\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4054282,
                "title": "average-time-of-process-per-machine",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Use self join -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect s.machine_id, round(avg(e.timestamp - s.timestamp),3) as processing_time\\nfrom Activity e inner join Activity s \\non e.machine_id = s.machine_id\\nand e.process_id = s.process_id\\nand e.activity_type = \\'end\\'\\nand s.activity_type = \\'start\\'\\ngroup by machine_id; \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect s.machine_id, round(avg(e.timestamp - s.timestamp),3) as processing_time\\nfrom Activity e inner join Activity s \\non e.machine_id = s.machine_id\\nand e.process_id = s.process_id\\nand e.activity_type = \\'end\\'\\nand s.activity_type = \\'start\\'\\ngroup by machine_id; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4052950,
                "title": "sql-without-join",
                "content": "SELECT \\n    machine_id, \\n    ROUND(SUM(timestamp * (activity_type = \\'end\\') - timestamp * (activity_type = \\'start\\')) / \\n    COUNT(DISTINCT process_id), 3) AS processing_time\\nFROM \\n    activity\\nGROUP BY \\n    machine_id;\\n\\n",
                "solutionTags": [],
                "code": "SELECT \\n    machine_id, \\n    ROUND(SUM(timestamp * (activity_type = \\'end\\') - timestamp * (activity_type = \\'start\\')) / \\n    COUNT(DISTINCT process_id), 3) AS processing_time\\nFROM \\n    activity\\nGROUP BY \\n    machine_id;\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 4052724,
                "title": "easy-solution-using-cte-join",
                "content": "# Approach\\nFirst filter rows using start time then similarly filter data for end time. Then Join both using machine_id and process_id. \\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nWITH cte1 AS \\n  (SELECT machine_id,process_id,timestamp AS startTime\\n  FROM activity\\n  WHERE activity_type = \"start\"),\\ncte2 AS\\n  (SELECT machine_id,process_id,timestamp AS endTime\\n  FROM activity\\n  WHERE activity_type = \"end\")\\nSELECT \\n  c1.machine_id,\\n  ROUND(SUM(endTime-startTime)/COUNT(c1.process_id),3) AS processing_time\\nFROM cte1 c1\\nJOIN cte2 c2\\nON c1.machine_id = c2.machine_id AND c1.process_id = c2.process_id\\nGROUP BY 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nWITH cte1 AS \\n  (SELECT machine_id,process_id,timestamp AS startTime\\n  FROM activity\\n  WHERE activity_type = \"start\"),\\ncte2 AS\\n  (SELECT machine_id,process_id,timestamp AS endTime\\n  FROM activity\\n  WHERE activity_type = \"end\")\\nSELECT \\n  c1.machine_id,\\n  ROUND(SUM(endTime-startTime)/COUNT(c1.process_id),3) AS processing_time\\nFROM cte1 c1\\nJOIN cte2 c2\\nON c1.machine_id = c2.machine_id AND c1.process_id = c2.process_id\\nGROUP BY 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4051849,
                "title": "100-better-easy-and-short-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT a.machine_id,ROUND(SUM((c.timestamp - a.timestamp)) / COUNT(a.machine_id),3) as processing_time  FROM Activity as a JOIN\\nActivity as c ON a.machine_id = c.machine_id and a.process_id = c.process_id and a.activity_type = \"start\" and c.activity_type = \"end\"\\nGROUP BY a.machine_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT a.machine_id,ROUND(SUM((c.timestamp - a.timestamp)) / COUNT(a.machine_id),3) as processing_time  FROM Activity as a JOIN\\nActivity as c ON a.machine_id = c.machine_id and a.process_id = c.process_id and a.activity_type = \"start\" and c.activity_type = \"end\"\\nGROUP BY a.machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4051782,
                "title": "self-join-avg-round",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nselect et.machine_id, round(avg (et.timestamp-st.timestamp),3) as processing_time\\nfrom activity as et\\ninner join activity  as st\\non  et.machine_id = st.machine_id \\nand et.process_id = st.process_id \\nand et.activity_type = \\'end\\' \\nand  st.activity_type = \\'start\\'\\ngroup by et.machine_id\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect et.machine_id, round(avg (et.timestamp-st.timestamp),3) as processing_time\\nfrom activity as et\\ninner join activity  as st\\non  et.machine_id = st.machine_id \\nand et.process_id = st.process_id \\nand et.activity_type = \\'end\\' \\nand  st.activity_type = \\'start\\'\\ngroup by et.machine_id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4051028,
                "title": "just-by-using-group-by",
                "content": "\\n\\n# Code\\n```\\nselect machine_id , round(avg(timediff),3) as processing_time\\nfrom\\n(\\nselect machine_id , process_id ,(max(timestamp)-min(timestamp)) as timediff\\nfrom Activity\\ngroup by machine_id , process_id\\n)\\ngroup by machine_id",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "\\n\\n# Code\\n```\\nselect machine_id , round(avg(timediff),3) as processing_time\\nfrom\\n(\\nselect machine_id , process_id ,(max(timestamp)-min(timestamp)) as timediff\\nfrom Activity\\ngroup by machine_id , process_id\\n)\\ngroup by machine_id",
                "codeTag": "Unknown"
            },
            {
                "id": 4050704,
                "title": "easy-solution-using-self-join",
                "content": "# Code\\n```\\nSELECT a1.machine_id, ROUND(AVG(a1.timestamp-a2.timestamp), 3) AS processing_time\\nFROM Activity a1 JOIN Activity a2 ON\\n    a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND\\n    a2.activity_type = \\'start\\' AND a1.activity_type = \\'end\\'\\nGROUP BY a1.machine_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT a1.machine_id, ROUND(AVG(a1.timestamp-a2.timestamp), 3) AS processing_time\\nFROM Activity a1 JOIN Activity a2 ON\\n    a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND\\n    a2.activity_type = \\'start\\' AND a1.activity_type = \\'end\\'\\nGROUP BY a1.machine_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4049392,
                "title": "clean-solution-using-with-clause",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nBeats 84.92%of users with MySQL\\n\\n- Space complexity:\\nBeats 100.00%of users with MySQL\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nWITH start as(\\n  SELECT *\\n  FROM Activity\\n  WHERE activity_type = \\'start\\'\\n),\\nend_t as(\\n  SELECT *\\n  FROM Activity\\n  WHERE activity_type = \\'end\\'\\n)\\nSELECT start.machine_id, ROUND(AVG(end_t.timestamp - start.timestamp),3) as processing_time\\nFROM start\\nINNER JOIN end_t\\nON start.machine_id = end_t.machine_id\\nAND start.process_id = end_t.process_id\\nGROUP BY start.machine_id\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nWITH start as(\\n  SELECT *\\n  FROM Activity\\n  WHERE activity_type = \\'start\\'\\n),\\nend_t as(\\n  SELECT *\\n  FROM Activity\\n  WHERE activity_type = \\'end\\'\\n)\\nSELECT start.machine_id, ROUND(AVG(end_t.timestamp - start.timestamp),3) as processing_time\\nFROM start\\nINNER JOIN end_t\\nON start.machine_id = end_t.machine_id\\nAND start.process_id = end_t.process_id\\nGROUP BY start.machine_id\\n\\n\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1911039,
                "content": [
                    {
                        "username": "sarthakkharabanda",
                        "content": "can people keep the discussion tab for discussions only? What\\'s so hard to understand in that? Also, why is the question categorized as easy ;-:"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@contactaditya832126](/contactaditya832126) can do without doing self join"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically it\\'s a question of self join, If you could anyhow find out differnces between end and start for same processes you are done, you can make a cte for that"
                    },
                    {
                        "username": "Msey",
                        "content": "should be medium"
                    },
                    {
                        "username": "spookie886",
                        "content": "Came here looking for this comment."
                    },
                    {
                        "username": "rishu00007",
                        "content": "Definitely not an easy problem"
                    },
                    {
                        "username": "lancexie",
                        "content": "\\t# I see some others solving this question using case when and sum.... which is nice... but\\n\\t# That would not work if the timestamp is an actual date/time format. So I decided to just use join.\\n\\t\\n\\tselect a.machine_id, round(avg(b.timestamp - a.timestamp), 3) as processing_time \\n\\tfrom activity a join activity b\\n\\ton a.machine_id = b.machine_id and a.process_id = b.process_id and a.activity_type = \\'start\\' and b.activity_type = \\'end\\'\\n    group by 1;\\n"
                    },
                    {
                        "username": "SomnathDeb",
                        "content": "[@TGBBSZWHWDLANZP](/TGBBSZWHWDLANZP)  Idiom doesn\\'t work  here"
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I came up with same solution. :)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "`group by 1` is an idiom that groups by the first column.\\nWe can be more explicit by doing\\n```\\ngroup by a.machine_id\\n;\\n```"
                    },
                    {
                        "username": "sw_code",
                        "content": "\"\"\"\\nselect\\n    machine_id\\n    , round(sum(if(activity_type = \\'start\\', -1, 1) *timestamp)/count(distinct process_id),3) as processing_time\\nfrom activity\\ngroup by machine_id\\n\"\"\""
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a1.machine_id, ROUND(avg(a2.timestamp - a1.timestamp), 3) as processing_time\\nFROM Activity as a1, Activity as a2\\nWHERE a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND a1.activity_type = \\'start\\' AND a2.activity_type = \\'end\\'\\nGROUP BY a1.machine_id"
                    },
                    {
                        "username": "RushikeshMahajan",
                        "content": "The given table is already joined table to make it complicated they should have given separate table with activity_type."
                    },
                    {
                        "username": "crothers17",
                        "content": "I can\\'t see what I did wrong based on the response. used a cte.\\n\\nWrong Answer\\nRuntime: 140 ms\\nCase 1\\n\\nOutput\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\nExpected\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\n"
                    },
                    {
                        "username": "Scaranin",
                        "content": "Another one solution:\\n\\nwith t\\n  as (  select machine_id\\n            , process_id\\n            , timestamp ts_start\\n            , activity_type\\n            , lead (timestamp) over (partition by machine_id, process_id order by activity_type desc) ts_end\\n         from Activity)\\nselect machine_id\\n     , round(avg(ts_end -ts_start), 3) processing_time\\n  from t\\n where activity_type = \\'start\\'\\n group by machine_id"
                    },
                    {
                        "username": "SabikaShahid",
                        "content": "with \\n\\nstart as ( select * from activity \\nwhere \\nactivity_type = \\'start\\' ), \\n\\nend as ( select * from activity where activity_type = \\'end\\' ),\\n\\nDifference as ( select start.machine_id, start.process_id,\\n end.timestamp - start.timestamp as td\\nfrom start \\nleft join end on start.machine_id = end.machine_id \\nand start.process_id = end.process_id\\nwhere start.machine_id = end.machine_id and start.process_id = end.process_id )\\n\\n\\n\\n select d.machine_id, round(avg(d.td),3) as processing_time  from difference as d, difference as dd\\n\\nwhere d.machine_id = dd.machine_id\\n\\ngroup by 1"
                    },
                    {
                        "username": "Anantjain03",
                        "content": "with cte as(select machine_id, process_id, round(sum(case when activity_type = 'start' then timestamp\n                            end),3) as sumstart_time,\n                            round(sum(case when activity_type='end' then timestamp\n                            end),3) as sumend_time\n                            from activity\n                            group by machine_id,process_id),\ncte2 as(select machine_id, (sumend_time-sumstart_time) as time1 from cte)\n\nselect machine_id,round((sum(time1))/count(machine_id),3) as processing_time from cte2\ngroup by machine_id"
                    },
                    {
                        "username": "14vivek",
                        "content": "I  think you have to correct your code at last. In cte2 you have to add column process_id and then in the main query replace it with the count of machine_id to count of process_id(As per the question.)\\n"
                    }
                ]
            },
            {
                "id": 1934803,
                "content": [
                    {
                        "username": "sarthakkharabanda",
                        "content": "can people keep the discussion tab for discussions only? What\\'s so hard to understand in that? Also, why is the question categorized as easy ;-:"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@contactaditya832126](/contactaditya832126) can do without doing self join"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically it\\'s a question of self join, If you could anyhow find out differnces between end and start for same processes you are done, you can make a cte for that"
                    },
                    {
                        "username": "Msey",
                        "content": "should be medium"
                    },
                    {
                        "username": "spookie886",
                        "content": "Came here looking for this comment."
                    },
                    {
                        "username": "rishu00007",
                        "content": "Definitely not an easy problem"
                    },
                    {
                        "username": "lancexie",
                        "content": "\\t# I see some others solving this question using case when and sum.... which is nice... but\\n\\t# That would not work if the timestamp is an actual date/time format. So I decided to just use join.\\n\\t\\n\\tselect a.machine_id, round(avg(b.timestamp - a.timestamp), 3) as processing_time \\n\\tfrom activity a join activity b\\n\\ton a.machine_id = b.machine_id and a.process_id = b.process_id and a.activity_type = \\'start\\' and b.activity_type = \\'end\\'\\n    group by 1;\\n"
                    },
                    {
                        "username": "SomnathDeb",
                        "content": "[@TGBBSZWHWDLANZP](/TGBBSZWHWDLANZP)  Idiom doesn\\'t work  here"
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I came up with same solution. :)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "`group by 1` is an idiom that groups by the first column.\\nWe can be more explicit by doing\\n```\\ngroup by a.machine_id\\n;\\n```"
                    },
                    {
                        "username": "sw_code",
                        "content": "\"\"\"\\nselect\\n    machine_id\\n    , round(sum(if(activity_type = \\'start\\', -1, 1) *timestamp)/count(distinct process_id),3) as processing_time\\nfrom activity\\ngroup by machine_id\\n\"\"\""
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a1.machine_id, ROUND(avg(a2.timestamp - a1.timestamp), 3) as processing_time\\nFROM Activity as a1, Activity as a2\\nWHERE a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND a1.activity_type = \\'start\\' AND a2.activity_type = \\'end\\'\\nGROUP BY a1.machine_id"
                    },
                    {
                        "username": "RushikeshMahajan",
                        "content": "The given table is already joined table to make it complicated they should have given separate table with activity_type."
                    },
                    {
                        "username": "crothers17",
                        "content": "I can\\'t see what I did wrong based on the response. used a cte.\\n\\nWrong Answer\\nRuntime: 140 ms\\nCase 1\\n\\nOutput\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\nExpected\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\n"
                    },
                    {
                        "username": "Scaranin",
                        "content": "Another one solution:\\n\\nwith t\\n  as (  select machine_id\\n            , process_id\\n            , timestamp ts_start\\n            , activity_type\\n            , lead (timestamp) over (partition by machine_id, process_id order by activity_type desc) ts_end\\n         from Activity)\\nselect machine_id\\n     , round(avg(ts_end -ts_start), 3) processing_time\\n  from t\\n where activity_type = \\'start\\'\\n group by machine_id"
                    },
                    {
                        "username": "SabikaShahid",
                        "content": "with \\n\\nstart as ( select * from activity \\nwhere \\nactivity_type = \\'start\\' ), \\n\\nend as ( select * from activity where activity_type = \\'end\\' ),\\n\\nDifference as ( select start.machine_id, start.process_id,\\n end.timestamp - start.timestamp as td\\nfrom start \\nleft join end on start.machine_id = end.machine_id \\nand start.process_id = end.process_id\\nwhere start.machine_id = end.machine_id and start.process_id = end.process_id )\\n\\n\\n\\n select d.machine_id, round(avg(d.td),3) as processing_time  from difference as d, difference as dd\\n\\nwhere d.machine_id = dd.machine_id\\n\\ngroup by 1"
                    },
                    {
                        "username": "Anantjain03",
                        "content": "with cte as(select machine_id, process_id, round(sum(case when activity_type = 'start' then timestamp\n                            end),3) as sumstart_time,\n                            round(sum(case when activity_type='end' then timestamp\n                            end),3) as sumend_time\n                            from activity\n                            group by machine_id,process_id),\ncte2 as(select machine_id, (sumend_time-sumstart_time) as time1 from cte)\n\nselect machine_id,round((sum(time1))/count(machine_id),3) as processing_time from cte2\ngroup by machine_id"
                    },
                    {
                        "username": "14vivek",
                        "content": "I  think you have to correct your code at last. In cte2 you have to add column process_id and then in the main query replace it with the count of machine_id to count of process_id(As per the question.)\\n"
                    }
                ]
            },
            {
                "id": 2033928,
                "content": [
                    {
                        "username": "sarthakkharabanda",
                        "content": "can people keep the discussion tab for discussions only? What\\'s so hard to understand in that? Also, why is the question categorized as easy ;-:"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@contactaditya832126](/contactaditya832126) can do without doing self join"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically it\\'s a question of self join, If you could anyhow find out differnces between end and start for same processes you are done, you can make a cte for that"
                    },
                    {
                        "username": "Msey",
                        "content": "should be medium"
                    },
                    {
                        "username": "spookie886",
                        "content": "Came here looking for this comment."
                    },
                    {
                        "username": "rishu00007",
                        "content": "Definitely not an easy problem"
                    },
                    {
                        "username": "lancexie",
                        "content": "\\t# I see some others solving this question using case when and sum.... which is nice... but\\n\\t# That would not work if the timestamp is an actual date/time format. So I decided to just use join.\\n\\t\\n\\tselect a.machine_id, round(avg(b.timestamp - a.timestamp), 3) as processing_time \\n\\tfrom activity a join activity b\\n\\ton a.machine_id = b.machine_id and a.process_id = b.process_id and a.activity_type = \\'start\\' and b.activity_type = \\'end\\'\\n    group by 1;\\n"
                    },
                    {
                        "username": "SomnathDeb",
                        "content": "[@TGBBSZWHWDLANZP](/TGBBSZWHWDLANZP)  Idiom doesn\\'t work  here"
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I came up with same solution. :)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "`group by 1` is an idiom that groups by the first column.\\nWe can be more explicit by doing\\n```\\ngroup by a.machine_id\\n;\\n```"
                    },
                    {
                        "username": "sw_code",
                        "content": "\"\"\"\\nselect\\n    machine_id\\n    , round(sum(if(activity_type = \\'start\\', -1, 1) *timestamp)/count(distinct process_id),3) as processing_time\\nfrom activity\\ngroup by machine_id\\n\"\"\""
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a1.machine_id, ROUND(avg(a2.timestamp - a1.timestamp), 3) as processing_time\\nFROM Activity as a1, Activity as a2\\nWHERE a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND a1.activity_type = \\'start\\' AND a2.activity_type = \\'end\\'\\nGROUP BY a1.machine_id"
                    },
                    {
                        "username": "RushikeshMahajan",
                        "content": "The given table is already joined table to make it complicated they should have given separate table with activity_type."
                    },
                    {
                        "username": "crothers17",
                        "content": "I can\\'t see what I did wrong based on the response. used a cte.\\n\\nWrong Answer\\nRuntime: 140 ms\\nCase 1\\n\\nOutput\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\nExpected\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\n"
                    },
                    {
                        "username": "Scaranin",
                        "content": "Another one solution:\\n\\nwith t\\n  as (  select machine_id\\n            , process_id\\n            , timestamp ts_start\\n            , activity_type\\n            , lead (timestamp) over (partition by machine_id, process_id order by activity_type desc) ts_end\\n         from Activity)\\nselect machine_id\\n     , round(avg(ts_end -ts_start), 3) processing_time\\n  from t\\n where activity_type = \\'start\\'\\n group by machine_id"
                    },
                    {
                        "username": "SabikaShahid",
                        "content": "with \\n\\nstart as ( select * from activity \\nwhere \\nactivity_type = \\'start\\' ), \\n\\nend as ( select * from activity where activity_type = \\'end\\' ),\\n\\nDifference as ( select start.machine_id, start.process_id,\\n end.timestamp - start.timestamp as td\\nfrom start \\nleft join end on start.machine_id = end.machine_id \\nand start.process_id = end.process_id\\nwhere start.machine_id = end.machine_id and start.process_id = end.process_id )\\n\\n\\n\\n select d.machine_id, round(avg(d.td),3) as processing_time  from difference as d, difference as dd\\n\\nwhere d.machine_id = dd.machine_id\\n\\ngroup by 1"
                    },
                    {
                        "username": "Anantjain03",
                        "content": "with cte as(select machine_id, process_id, round(sum(case when activity_type = 'start' then timestamp\n                            end),3) as sumstart_time,\n                            round(sum(case when activity_type='end' then timestamp\n                            end),3) as sumend_time\n                            from activity\n                            group by machine_id,process_id),\ncte2 as(select machine_id, (sumend_time-sumstart_time) as time1 from cte)\n\nselect machine_id,round((sum(time1))/count(machine_id),3) as processing_time from cte2\ngroup by machine_id"
                    },
                    {
                        "username": "14vivek",
                        "content": "I  think you have to correct your code at last. In cte2 you have to add column process_id and then in the main query replace it with the count of machine_id to count of process_id(As per the question.)\\n"
                    }
                ]
            },
            {
                "id": 1575226,
                "content": [
                    {
                        "username": "sarthakkharabanda",
                        "content": "can people keep the discussion tab for discussions only? What\\'s so hard to understand in that? Also, why is the question categorized as easy ;-:"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@contactaditya832126](/contactaditya832126) can do without doing self join"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically it\\'s a question of self join, If you could anyhow find out differnces between end and start for same processes you are done, you can make a cte for that"
                    },
                    {
                        "username": "Msey",
                        "content": "should be medium"
                    },
                    {
                        "username": "spookie886",
                        "content": "Came here looking for this comment."
                    },
                    {
                        "username": "rishu00007",
                        "content": "Definitely not an easy problem"
                    },
                    {
                        "username": "lancexie",
                        "content": "\\t# I see some others solving this question using case when and sum.... which is nice... but\\n\\t# That would not work if the timestamp is an actual date/time format. So I decided to just use join.\\n\\t\\n\\tselect a.machine_id, round(avg(b.timestamp - a.timestamp), 3) as processing_time \\n\\tfrom activity a join activity b\\n\\ton a.machine_id = b.machine_id and a.process_id = b.process_id and a.activity_type = \\'start\\' and b.activity_type = \\'end\\'\\n    group by 1;\\n"
                    },
                    {
                        "username": "SomnathDeb",
                        "content": "[@TGBBSZWHWDLANZP](/TGBBSZWHWDLANZP)  Idiom doesn\\'t work  here"
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I came up with same solution. :)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "`group by 1` is an idiom that groups by the first column.\\nWe can be more explicit by doing\\n```\\ngroup by a.machine_id\\n;\\n```"
                    },
                    {
                        "username": "sw_code",
                        "content": "\"\"\"\\nselect\\n    machine_id\\n    , round(sum(if(activity_type = \\'start\\', -1, 1) *timestamp)/count(distinct process_id),3) as processing_time\\nfrom activity\\ngroup by machine_id\\n\"\"\""
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a1.machine_id, ROUND(avg(a2.timestamp - a1.timestamp), 3) as processing_time\\nFROM Activity as a1, Activity as a2\\nWHERE a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND a1.activity_type = \\'start\\' AND a2.activity_type = \\'end\\'\\nGROUP BY a1.machine_id"
                    },
                    {
                        "username": "RushikeshMahajan",
                        "content": "The given table is already joined table to make it complicated they should have given separate table with activity_type."
                    },
                    {
                        "username": "crothers17",
                        "content": "I can\\'t see what I did wrong based on the response. used a cte.\\n\\nWrong Answer\\nRuntime: 140 ms\\nCase 1\\n\\nOutput\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\nExpected\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\n"
                    },
                    {
                        "username": "Scaranin",
                        "content": "Another one solution:\\n\\nwith t\\n  as (  select machine_id\\n            , process_id\\n            , timestamp ts_start\\n            , activity_type\\n            , lead (timestamp) over (partition by machine_id, process_id order by activity_type desc) ts_end\\n         from Activity)\\nselect machine_id\\n     , round(avg(ts_end -ts_start), 3) processing_time\\n  from t\\n where activity_type = \\'start\\'\\n group by machine_id"
                    },
                    {
                        "username": "SabikaShahid",
                        "content": "with \\n\\nstart as ( select * from activity \\nwhere \\nactivity_type = \\'start\\' ), \\n\\nend as ( select * from activity where activity_type = \\'end\\' ),\\n\\nDifference as ( select start.machine_id, start.process_id,\\n end.timestamp - start.timestamp as td\\nfrom start \\nleft join end on start.machine_id = end.machine_id \\nand start.process_id = end.process_id\\nwhere start.machine_id = end.machine_id and start.process_id = end.process_id )\\n\\n\\n\\n select d.machine_id, round(avg(d.td),3) as processing_time  from difference as d, difference as dd\\n\\nwhere d.machine_id = dd.machine_id\\n\\ngroup by 1"
                    },
                    {
                        "username": "Anantjain03",
                        "content": "with cte as(select machine_id, process_id, round(sum(case when activity_type = 'start' then timestamp\n                            end),3) as sumstart_time,\n                            round(sum(case when activity_type='end' then timestamp\n                            end),3) as sumend_time\n                            from activity\n                            group by machine_id,process_id),\ncte2 as(select machine_id, (sumend_time-sumstart_time) as time1 from cte)\n\nselect machine_id,round((sum(time1))/count(machine_id),3) as processing_time from cte2\ngroup by machine_id"
                    },
                    {
                        "username": "14vivek",
                        "content": "I  think you have to correct your code at last. In cte2 you have to add column process_id and then in the main query replace it with the count of machine_id to count of process_id(As per the question.)\\n"
                    }
                ]
            },
            {
                "id": 1570395,
                "content": [
                    {
                        "username": "sarthakkharabanda",
                        "content": "can people keep the discussion tab for discussions only? What\\'s so hard to understand in that? Also, why is the question categorized as easy ;-:"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@contactaditya832126](/contactaditya832126) can do without doing self join"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically it\\'s a question of self join, If you could anyhow find out differnces between end and start for same processes you are done, you can make a cte for that"
                    },
                    {
                        "username": "Msey",
                        "content": "should be medium"
                    },
                    {
                        "username": "spookie886",
                        "content": "Came here looking for this comment."
                    },
                    {
                        "username": "rishu00007",
                        "content": "Definitely not an easy problem"
                    },
                    {
                        "username": "lancexie",
                        "content": "\\t# I see some others solving this question using case when and sum.... which is nice... but\\n\\t# That would not work if the timestamp is an actual date/time format. So I decided to just use join.\\n\\t\\n\\tselect a.machine_id, round(avg(b.timestamp - a.timestamp), 3) as processing_time \\n\\tfrom activity a join activity b\\n\\ton a.machine_id = b.machine_id and a.process_id = b.process_id and a.activity_type = \\'start\\' and b.activity_type = \\'end\\'\\n    group by 1;\\n"
                    },
                    {
                        "username": "SomnathDeb",
                        "content": "[@TGBBSZWHWDLANZP](/TGBBSZWHWDLANZP)  Idiom doesn\\'t work  here"
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I came up with same solution. :)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "`group by 1` is an idiom that groups by the first column.\\nWe can be more explicit by doing\\n```\\ngroup by a.machine_id\\n;\\n```"
                    },
                    {
                        "username": "sw_code",
                        "content": "\"\"\"\\nselect\\n    machine_id\\n    , round(sum(if(activity_type = \\'start\\', -1, 1) *timestamp)/count(distinct process_id),3) as processing_time\\nfrom activity\\ngroup by machine_id\\n\"\"\""
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a1.machine_id, ROUND(avg(a2.timestamp - a1.timestamp), 3) as processing_time\\nFROM Activity as a1, Activity as a2\\nWHERE a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND a1.activity_type = \\'start\\' AND a2.activity_type = \\'end\\'\\nGROUP BY a1.machine_id"
                    },
                    {
                        "username": "RushikeshMahajan",
                        "content": "The given table is already joined table to make it complicated they should have given separate table with activity_type."
                    },
                    {
                        "username": "crothers17",
                        "content": "I can\\'t see what I did wrong based on the response. used a cte.\\n\\nWrong Answer\\nRuntime: 140 ms\\nCase 1\\n\\nOutput\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\nExpected\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\n"
                    },
                    {
                        "username": "Scaranin",
                        "content": "Another one solution:\\n\\nwith t\\n  as (  select machine_id\\n            , process_id\\n            , timestamp ts_start\\n            , activity_type\\n            , lead (timestamp) over (partition by machine_id, process_id order by activity_type desc) ts_end\\n         from Activity)\\nselect machine_id\\n     , round(avg(ts_end -ts_start), 3) processing_time\\n  from t\\n where activity_type = \\'start\\'\\n group by machine_id"
                    },
                    {
                        "username": "SabikaShahid",
                        "content": "with \\n\\nstart as ( select * from activity \\nwhere \\nactivity_type = \\'start\\' ), \\n\\nend as ( select * from activity where activity_type = \\'end\\' ),\\n\\nDifference as ( select start.machine_id, start.process_id,\\n end.timestamp - start.timestamp as td\\nfrom start \\nleft join end on start.machine_id = end.machine_id \\nand start.process_id = end.process_id\\nwhere start.machine_id = end.machine_id and start.process_id = end.process_id )\\n\\n\\n\\n select d.machine_id, round(avg(d.td),3) as processing_time  from difference as d, difference as dd\\n\\nwhere d.machine_id = dd.machine_id\\n\\ngroup by 1"
                    },
                    {
                        "username": "Anantjain03",
                        "content": "with cte as(select machine_id, process_id, round(sum(case when activity_type = 'start' then timestamp\n                            end),3) as sumstart_time,\n                            round(sum(case when activity_type='end' then timestamp\n                            end),3) as sumend_time\n                            from activity\n                            group by machine_id,process_id),\ncte2 as(select machine_id, (sumend_time-sumstart_time) as time1 from cte)\n\nselect machine_id,round((sum(time1))/count(machine_id),3) as processing_time from cte2\ngroup by machine_id"
                    },
                    {
                        "username": "14vivek",
                        "content": "I  think you have to correct your code at last. In cte2 you have to add column process_id and then in the main query replace it with the count of machine_id to count of process_id(As per the question.)\\n"
                    }
                ]
            },
            {
                "id": 1883530,
                "content": [
                    {
                        "username": "sarthakkharabanda",
                        "content": "can people keep the discussion tab for discussions only? What\\'s so hard to understand in that? Also, why is the question categorized as easy ;-:"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@contactaditya832126](/contactaditya832126) can do without doing self join"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically it\\'s a question of self join, If you could anyhow find out differnces between end and start for same processes you are done, you can make a cte for that"
                    },
                    {
                        "username": "Msey",
                        "content": "should be medium"
                    },
                    {
                        "username": "spookie886",
                        "content": "Came here looking for this comment."
                    },
                    {
                        "username": "rishu00007",
                        "content": "Definitely not an easy problem"
                    },
                    {
                        "username": "lancexie",
                        "content": "\\t# I see some others solving this question using case when and sum.... which is nice... but\\n\\t# That would not work if the timestamp is an actual date/time format. So I decided to just use join.\\n\\t\\n\\tselect a.machine_id, round(avg(b.timestamp - a.timestamp), 3) as processing_time \\n\\tfrom activity a join activity b\\n\\ton a.machine_id = b.machine_id and a.process_id = b.process_id and a.activity_type = \\'start\\' and b.activity_type = \\'end\\'\\n    group by 1;\\n"
                    },
                    {
                        "username": "SomnathDeb",
                        "content": "[@TGBBSZWHWDLANZP](/TGBBSZWHWDLANZP)  Idiom doesn\\'t work  here"
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I came up with same solution. :)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "`group by 1` is an idiom that groups by the first column.\\nWe can be more explicit by doing\\n```\\ngroup by a.machine_id\\n;\\n```"
                    },
                    {
                        "username": "sw_code",
                        "content": "\"\"\"\\nselect\\n    machine_id\\n    , round(sum(if(activity_type = \\'start\\', -1, 1) *timestamp)/count(distinct process_id),3) as processing_time\\nfrom activity\\ngroup by machine_id\\n\"\"\""
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a1.machine_id, ROUND(avg(a2.timestamp - a1.timestamp), 3) as processing_time\\nFROM Activity as a1, Activity as a2\\nWHERE a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND a1.activity_type = \\'start\\' AND a2.activity_type = \\'end\\'\\nGROUP BY a1.machine_id"
                    },
                    {
                        "username": "RushikeshMahajan",
                        "content": "The given table is already joined table to make it complicated they should have given separate table with activity_type."
                    },
                    {
                        "username": "crothers17",
                        "content": "I can\\'t see what I did wrong based on the response. used a cte.\\n\\nWrong Answer\\nRuntime: 140 ms\\nCase 1\\n\\nOutput\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\nExpected\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\n"
                    },
                    {
                        "username": "Scaranin",
                        "content": "Another one solution:\\n\\nwith t\\n  as (  select machine_id\\n            , process_id\\n            , timestamp ts_start\\n            , activity_type\\n            , lead (timestamp) over (partition by machine_id, process_id order by activity_type desc) ts_end\\n         from Activity)\\nselect machine_id\\n     , round(avg(ts_end -ts_start), 3) processing_time\\n  from t\\n where activity_type = \\'start\\'\\n group by machine_id"
                    },
                    {
                        "username": "SabikaShahid",
                        "content": "with \\n\\nstart as ( select * from activity \\nwhere \\nactivity_type = \\'start\\' ), \\n\\nend as ( select * from activity where activity_type = \\'end\\' ),\\n\\nDifference as ( select start.machine_id, start.process_id,\\n end.timestamp - start.timestamp as td\\nfrom start \\nleft join end on start.machine_id = end.machine_id \\nand start.process_id = end.process_id\\nwhere start.machine_id = end.machine_id and start.process_id = end.process_id )\\n\\n\\n\\n select d.machine_id, round(avg(d.td),3) as processing_time  from difference as d, difference as dd\\n\\nwhere d.machine_id = dd.machine_id\\n\\ngroup by 1"
                    },
                    {
                        "username": "Anantjain03",
                        "content": "with cte as(select machine_id, process_id, round(sum(case when activity_type = 'start' then timestamp\n                            end),3) as sumstart_time,\n                            round(sum(case when activity_type='end' then timestamp\n                            end),3) as sumend_time\n                            from activity\n                            group by machine_id,process_id),\ncte2 as(select machine_id, (sumend_time-sumstart_time) as time1 from cte)\n\nselect machine_id,round((sum(time1))/count(machine_id),3) as processing_time from cte2\ngroup by machine_id"
                    },
                    {
                        "username": "14vivek",
                        "content": "I  think you have to correct your code at last. In cte2 you have to add column process_id and then in the main query replace it with the count of machine_id to count of process_id(As per the question.)\\n"
                    }
                ]
            },
            {
                "id": 2009536,
                "content": [
                    {
                        "username": "sarthakkharabanda",
                        "content": "can people keep the discussion tab for discussions only? What\\'s so hard to understand in that? Also, why is the question categorized as easy ;-:"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@contactaditya832126](/contactaditya832126) can do without doing self join"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically it\\'s a question of self join, If you could anyhow find out differnces between end and start for same processes you are done, you can make a cte for that"
                    },
                    {
                        "username": "Msey",
                        "content": "should be medium"
                    },
                    {
                        "username": "spookie886",
                        "content": "Came here looking for this comment."
                    },
                    {
                        "username": "rishu00007",
                        "content": "Definitely not an easy problem"
                    },
                    {
                        "username": "lancexie",
                        "content": "\\t# I see some others solving this question using case when and sum.... which is nice... but\\n\\t# That would not work if the timestamp is an actual date/time format. So I decided to just use join.\\n\\t\\n\\tselect a.machine_id, round(avg(b.timestamp - a.timestamp), 3) as processing_time \\n\\tfrom activity a join activity b\\n\\ton a.machine_id = b.machine_id and a.process_id = b.process_id and a.activity_type = \\'start\\' and b.activity_type = \\'end\\'\\n    group by 1;\\n"
                    },
                    {
                        "username": "SomnathDeb",
                        "content": "[@TGBBSZWHWDLANZP](/TGBBSZWHWDLANZP)  Idiom doesn\\'t work  here"
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I came up with same solution. :)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "`group by 1` is an idiom that groups by the first column.\\nWe can be more explicit by doing\\n```\\ngroup by a.machine_id\\n;\\n```"
                    },
                    {
                        "username": "sw_code",
                        "content": "\"\"\"\\nselect\\n    machine_id\\n    , round(sum(if(activity_type = \\'start\\', -1, 1) *timestamp)/count(distinct process_id),3) as processing_time\\nfrom activity\\ngroup by machine_id\\n\"\"\""
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a1.machine_id, ROUND(avg(a2.timestamp - a1.timestamp), 3) as processing_time\\nFROM Activity as a1, Activity as a2\\nWHERE a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND a1.activity_type = \\'start\\' AND a2.activity_type = \\'end\\'\\nGROUP BY a1.machine_id"
                    },
                    {
                        "username": "RushikeshMahajan",
                        "content": "The given table is already joined table to make it complicated they should have given separate table with activity_type."
                    },
                    {
                        "username": "crothers17",
                        "content": "I can\\'t see what I did wrong based on the response. used a cte.\\n\\nWrong Answer\\nRuntime: 140 ms\\nCase 1\\n\\nOutput\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\nExpected\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\n"
                    },
                    {
                        "username": "Scaranin",
                        "content": "Another one solution:\\n\\nwith t\\n  as (  select machine_id\\n            , process_id\\n            , timestamp ts_start\\n            , activity_type\\n            , lead (timestamp) over (partition by machine_id, process_id order by activity_type desc) ts_end\\n         from Activity)\\nselect machine_id\\n     , round(avg(ts_end -ts_start), 3) processing_time\\n  from t\\n where activity_type = \\'start\\'\\n group by machine_id"
                    },
                    {
                        "username": "SabikaShahid",
                        "content": "with \\n\\nstart as ( select * from activity \\nwhere \\nactivity_type = \\'start\\' ), \\n\\nend as ( select * from activity where activity_type = \\'end\\' ),\\n\\nDifference as ( select start.machine_id, start.process_id,\\n end.timestamp - start.timestamp as td\\nfrom start \\nleft join end on start.machine_id = end.machine_id \\nand start.process_id = end.process_id\\nwhere start.machine_id = end.machine_id and start.process_id = end.process_id )\\n\\n\\n\\n select d.machine_id, round(avg(d.td),3) as processing_time  from difference as d, difference as dd\\n\\nwhere d.machine_id = dd.machine_id\\n\\ngroup by 1"
                    },
                    {
                        "username": "Anantjain03",
                        "content": "with cte as(select machine_id, process_id, round(sum(case when activity_type = 'start' then timestamp\n                            end),3) as sumstart_time,\n                            round(sum(case when activity_type='end' then timestamp\n                            end),3) as sumend_time\n                            from activity\n                            group by machine_id,process_id),\ncte2 as(select machine_id, (sumend_time-sumstart_time) as time1 from cte)\n\nselect machine_id,round((sum(time1))/count(machine_id),3) as processing_time from cte2\ngroup by machine_id"
                    },
                    {
                        "username": "14vivek",
                        "content": "I  think you have to correct your code at last. In cte2 you have to add column process_id and then in the main query replace it with the count of machine_id to count of process_id(As per the question.)\\n"
                    }
                ]
            },
            {
                "id": 2049070,
                "content": [
                    {
                        "username": "sarthakkharabanda",
                        "content": "can people keep the discussion tab for discussions only? What\\'s so hard to understand in that? Also, why is the question categorized as easy ;-:"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@contactaditya832126](/contactaditya832126) can do without doing self join"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically it\\'s a question of self join, If you could anyhow find out differnces between end and start for same processes you are done, you can make a cte for that"
                    },
                    {
                        "username": "Msey",
                        "content": "should be medium"
                    },
                    {
                        "username": "spookie886",
                        "content": "Came here looking for this comment."
                    },
                    {
                        "username": "rishu00007",
                        "content": "Definitely not an easy problem"
                    },
                    {
                        "username": "lancexie",
                        "content": "\\t# I see some others solving this question using case when and sum.... which is nice... but\\n\\t# That would not work if the timestamp is an actual date/time format. So I decided to just use join.\\n\\t\\n\\tselect a.machine_id, round(avg(b.timestamp - a.timestamp), 3) as processing_time \\n\\tfrom activity a join activity b\\n\\ton a.machine_id = b.machine_id and a.process_id = b.process_id and a.activity_type = \\'start\\' and b.activity_type = \\'end\\'\\n    group by 1;\\n"
                    },
                    {
                        "username": "SomnathDeb",
                        "content": "[@TGBBSZWHWDLANZP](/TGBBSZWHWDLANZP)  Idiom doesn\\'t work  here"
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I came up with same solution. :)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "`group by 1` is an idiom that groups by the first column.\\nWe can be more explicit by doing\\n```\\ngroup by a.machine_id\\n;\\n```"
                    },
                    {
                        "username": "sw_code",
                        "content": "\"\"\"\\nselect\\n    machine_id\\n    , round(sum(if(activity_type = \\'start\\', -1, 1) *timestamp)/count(distinct process_id),3) as processing_time\\nfrom activity\\ngroup by machine_id\\n\"\"\""
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a1.machine_id, ROUND(avg(a2.timestamp - a1.timestamp), 3) as processing_time\\nFROM Activity as a1, Activity as a2\\nWHERE a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND a1.activity_type = \\'start\\' AND a2.activity_type = \\'end\\'\\nGROUP BY a1.machine_id"
                    },
                    {
                        "username": "RushikeshMahajan",
                        "content": "The given table is already joined table to make it complicated they should have given separate table with activity_type."
                    },
                    {
                        "username": "crothers17",
                        "content": "I can\\'t see what I did wrong based on the response. used a cte.\\n\\nWrong Answer\\nRuntime: 140 ms\\nCase 1\\n\\nOutput\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\nExpected\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\n"
                    },
                    {
                        "username": "Scaranin",
                        "content": "Another one solution:\\n\\nwith t\\n  as (  select machine_id\\n            , process_id\\n            , timestamp ts_start\\n            , activity_type\\n            , lead (timestamp) over (partition by machine_id, process_id order by activity_type desc) ts_end\\n         from Activity)\\nselect machine_id\\n     , round(avg(ts_end -ts_start), 3) processing_time\\n  from t\\n where activity_type = \\'start\\'\\n group by machine_id"
                    },
                    {
                        "username": "SabikaShahid",
                        "content": "with \\n\\nstart as ( select * from activity \\nwhere \\nactivity_type = \\'start\\' ), \\n\\nend as ( select * from activity where activity_type = \\'end\\' ),\\n\\nDifference as ( select start.machine_id, start.process_id,\\n end.timestamp - start.timestamp as td\\nfrom start \\nleft join end on start.machine_id = end.machine_id \\nand start.process_id = end.process_id\\nwhere start.machine_id = end.machine_id and start.process_id = end.process_id )\\n\\n\\n\\n select d.machine_id, round(avg(d.td),3) as processing_time  from difference as d, difference as dd\\n\\nwhere d.machine_id = dd.machine_id\\n\\ngroup by 1"
                    },
                    {
                        "username": "Anantjain03",
                        "content": "with cte as(select machine_id, process_id, round(sum(case when activity_type = 'start' then timestamp\n                            end),3) as sumstart_time,\n                            round(sum(case when activity_type='end' then timestamp\n                            end),3) as sumend_time\n                            from activity\n                            group by machine_id,process_id),\ncte2 as(select machine_id, (sumend_time-sumstart_time) as time1 from cte)\n\nselect machine_id,round((sum(time1))/count(machine_id),3) as processing_time from cte2\ngroup by machine_id"
                    },
                    {
                        "username": "14vivek",
                        "content": "I  think you have to correct your code at last. In cte2 you have to add column process_id and then in the main query replace it with the count of machine_id to count of process_id(As per the question.)\\n"
                    }
                ]
            },
            {
                "id": 2046338,
                "content": [
                    {
                        "username": "sarthakkharabanda",
                        "content": "can people keep the discussion tab for discussions only? What\\'s so hard to understand in that? Also, why is the question categorized as easy ;-:"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@contactaditya832126](/contactaditya832126) can do without doing self join"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically it\\'s a question of self join, If you could anyhow find out differnces between end and start for same processes you are done, you can make a cte for that"
                    },
                    {
                        "username": "Msey",
                        "content": "should be medium"
                    },
                    {
                        "username": "spookie886",
                        "content": "Came here looking for this comment."
                    },
                    {
                        "username": "rishu00007",
                        "content": "Definitely not an easy problem"
                    },
                    {
                        "username": "lancexie",
                        "content": "\\t# I see some others solving this question using case when and sum.... which is nice... but\\n\\t# That would not work if the timestamp is an actual date/time format. So I decided to just use join.\\n\\t\\n\\tselect a.machine_id, round(avg(b.timestamp - a.timestamp), 3) as processing_time \\n\\tfrom activity a join activity b\\n\\ton a.machine_id = b.machine_id and a.process_id = b.process_id and a.activity_type = \\'start\\' and b.activity_type = \\'end\\'\\n    group by 1;\\n"
                    },
                    {
                        "username": "SomnathDeb",
                        "content": "[@TGBBSZWHWDLANZP](/TGBBSZWHWDLANZP)  Idiom doesn\\'t work  here"
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I came up with same solution. :)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "`group by 1` is an idiom that groups by the first column.\\nWe can be more explicit by doing\\n```\\ngroup by a.machine_id\\n;\\n```"
                    },
                    {
                        "username": "sw_code",
                        "content": "\"\"\"\\nselect\\n    machine_id\\n    , round(sum(if(activity_type = \\'start\\', -1, 1) *timestamp)/count(distinct process_id),3) as processing_time\\nfrom activity\\ngroup by machine_id\\n\"\"\""
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a1.machine_id, ROUND(avg(a2.timestamp - a1.timestamp), 3) as processing_time\\nFROM Activity as a1, Activity as a2\\nWHERE a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND a1.activity_type = \\'start\\' AND a2.activity_type = \\'end\\'\\nGROUP BY a1.machine_id"
                    },
                    {
                        "username": "RushikeshMahajan",
                        "content": "The given table is already joined table to make it complicated they should have given separate table with activity_type."
                    },
                    {
                        "username": "crothers17",
                        "content": "I can\\'t see what I did wrong based on the response. used a cte.\\n\\nWrong Answer\\nRuntime: 140 ms\\nCase 1\\n\\nOutput\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\nExpected\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\n"
                    },
                    {
                        "username": "Scaranin",
                        "content": "Another one solution:\\n\\nwith t\\n  as (  select machine_id\\n            , process_id\\n            , timestamp ts_start\\n            , activity_type\\n            , lead (timestamp) over (partition by machine_id, process_id order by activity_type desc) ts_end\\n         from Activity)\\nselect machine_id\\n     , round(avg(ts_end -ts_start), 3) processing_time\\n  from t\\n where activity_type = \\'start\\'\\n group by machine_id"
                    },
                    {
                        "username": "SabikaShahid",
                        "content": "with \\n\\nstart as ( select * from activity \\nwhere \\nactivity_type = \\'start\\' ), \\n\\nend as ( select * from activity where activity_type = \\'end\\' ),\\n\\nDifference as ( select start.machine_id, start.process_id,\\n end.timestamp - start.timestamp as td\\nfrom start \\nleft join end on start.machine_id = end.machine_id \\nand start.process_id = end.process_id\\nwhere start.machine_id = end.machine_id and start.process_id = end.process_id )\\n\\n\\n\\n select d.machine_id, round(avg(d.td),3) as processing_time  from difference as d, difference as dd\\n\\nwhere d.machine_id = dd.machine_id\\n\\ngroup by 1"
                    },
                    {
                        "username": "Anantjain03",
                        "content": "with cte as(select machine_id, process_id, round(sum(case when activity_type = 'start' then timestamp\n                            end),3) as sumstart_time,\n                            round(sum(case when activity_type='end' then timestamp\n                            end),3) as sumend_time\n                            from activity\n                            group by machine_id,process_id),\ncte2 as(select machine_id, (sumend_time-sumstart_time) as time1 from cte)\n\nselect machine_id,round((sum(time1))/count(machine_id),3) as processing_time from cte2\ngroup by machine_id"
                    },
                    {
                        "username": "14vivek",
                        "content": "I  think you have to correct your code at last. In cte2 you have to add column process_id and then in the main query replace it with the count of machine_id to count of process_id(As per the question.)\\n"
                    }
                ]
            },
            {
                "id": 1995112,
                "content": [
                    {
                        "username": "sarthakkharabanda",
                        "content": "can people keep the discussion tab for discussions only? What\\'s so hard to understand in that? Also, why is the question categorized as easy ;-:"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@contactaditya832126](/contactaditya832126) can do without doing self join"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically it\\'s a question of self join, If you could anyhow find out differnces between end and start for same processes you are done, you can make a cte for that"
                    },
                    {
                        "username": "Msey",
                        "content": "should be medium"
                    },
                    {
                        "username": "spookie886",
                        "content": "Came here looking for this comment."
                    },
                    {
                        "username": "rishu00007",
                        "content": "Definitely not an easy problem"
                    },
                    {
                        "username": "lancexie",
                        "content": "\\t# I see some others solving this question using case when and sum.... which is nice... but\\n\\t# That would not work if the timestamp is an actual date/time format. So I decided to just use join.\\n\\t\\n\\tselect a.machine_id, round(avg(b.timestamp - a.timestamp), 3) as processing_time \\n\\tfrom activity a join activity b\\n\\ton a.machine_id = b.machine_id and a.process_id = b.process_id and a.activity_type = \\'start\\' and b.activity_type = \\'end\\'\\n    group by 1;\\n"
                    },
                    {
                        "username": "SomnathDeb",
                        "content": "[@TGBBSZWHWDLANZP](/TGBBSZWHWDLANZP)  Idiom doesn\\'t work  here"
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I came up with same solution. :)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "`group by 1` is an idiom that groups by the first column.\\nWe can be more explicit by doing\\n```\\ngroup by a.machine_id\\n;\\n```"
                    },
                    {
                        "username": "sw_code",
                        "content": "\"\"\"\\nselect\\n    machine_id\\n    , round(sum(if(activity_type = \\'start\\', -1, 1) *timestamp)/count(distinct process_id),3) as processing_time\\nfrom activity\\ngroup by machine_id\\n\"\"\""
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a1.machine_id, ROUND(avg(a2.timestamp - a1.timestamp), 3) as processing_time\\nFROM Activity as a1, Activity as a2\\nWHERE a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND a1.activity_type = \\'start\\' AND a2.activity_type = \\'end\\'\\nGROUP BY a1.machine_id"
                    },
                    {
                        "username": "RushikeshMahajan",
                        "content": "The given table is already joined table to make it complicated they should have given separate table with activity_type."
                    },
                    {
                        "username": "crothers17",
                        "content": "I can\\'t see what I did wrong based on the response. used a cte.\\n\\nWrong Answer\\nRuntime: 140 ms\\nCase 1\\n\\nOutput\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\nExpected\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\n"
                    },
                    {
                        "username": "Scaranin",
                        "content": "Another one solution:\\n\\nwith t\\n  as (  select machine_id\\n            , process_id\\n            , timestamp ts_start\\n            , activity_type\\n            , lead (timestamp) over (partition by machine_id, process_id order by activity_type desc) ts_end\\n         from Activity)\\nselect machine_id\\n     , round(avg(ts_end -ts_start), 3) processing_time\\n  from t\\n where activity_type = \\'start\\'\\n group by machine_id"
                    },
                    {
                        "username": "SabikaShahid",
                        "content": "with \\n\\nstart as ( select * from activity \\nwhere \\nactivity_type = \\'start\\' ), \\n\\nend as ( select * from activity where activity_type = \\'end\\' ),\\n\\nDifference as ( select start.machine_id, start.process_id,\\n end.timestamp - start.timestamp as td\\nfrom start \\nleft join end on start.machine_id = end.machine_id \\nand start.process_id = end.process_id\\nwhere start.machine_id = end.machine_id and start.process_id = end.process_id )\\n\\n\\n\\n select d.machine_id, round(avg(d.td),3) as processing_time  from difference as d, difference as dd\\n\\nwhere d.machine_id = dd.machine_id\\n\\ngroup by 1"
                    },
                    {
                        "username": "Anantjain03",
                        "content": "with cte as(select machine_id, process_id, round(sum(case when activity_type = 'start' then timestamp\n                            end),3) as sumstart_time,\n                            round(sum(case when activity_type='end' then timestamp\n                            end),3) as sumend_time\n                            from activity\n                            group by machine_id,process_id),\ncte2 as(select machine_id, (sumend_time-sumstart_time) as time1 from cte)\n\nselect machine_id,round((sum(time1))/count(machine_id),3) as processing_time from cte2\ngroup by machine_id"
                    },
                    {
                        "username": "14vivek",
                        "content": "I  think you have to correct your code at last. In cte2 you have to add column process_id and then in the main query replace it with the count of machine_id to count of process_id(As per the question.)\\n"
                    }
                ]
            },
            {
                "id": 1911039,
                "content": [
                    {
                        "username": "sarthakkharabanda",
                        "content": "can people keep the discussion tab for discussions only? What\\'s so hard to understand in that? Also, why is the question categorized as easy ;-:"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@contactaditya832126](/contactaditya832126) can do without doing self join"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically it\\'s a question of self join, If you could anyhow find out differnces between end and start for same processes you are done, you can make a cte for that"
                    },
                    {
                        "username": "Msey",
                        "content": "should be medium"
                    },
                    {
                        "username": "spookie886",
                        "content": "Came here looking for this comment."
                    },
                    {
                        "username": "rishu00007",
                        "content": "Definitely not an easy problem"
                    },
                    {
                        "username": "lancexie",
                        "content": "\\t# I see some others solving this question using case when and sum.... which is nice... but\\n\\t# That would not work if the timestamp is an actual date/time format. So I decided to just use join.\\n\\t\\n\\tselect a.machine_id, round(avg(b.timestamp - a.timestamp), 3) as processing_time \\n\\tfrom activity a join activity b\\n\\ton a.machine_id = b.machine_id and a.process_id = b.process_id and a.activity_type = \\'start\\' and b.activity_type = \\'end\\'\\n    group by 1;\\n"
                    },
                    {
                        "username": "SomnathDeb",
                        "content": "[@TGBBSZWHWDLANZP](/TGBBSZWHWDLANZP)  Idiom doesn\\'t work  here"
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I came up with same solution. :)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "`group by 1` is an idiom that groups by the first column.\\nWe can be more explicit by doing\\n```\\ngroup by a.machine_id\\n;\\n```"
                    },
                    {
                        "username": "sw_code",
                        "content": "\"\"\"\\nselect\\n    machine_id\\n    , round(sum(if(activity_type = \\'start\\', -1, 1) *timestamp)/count(distinct process_id),3) as processing_time\\nfrom activity\\ngroup by machine_id\\n\"\"\""
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a1.machine_id, ROUND(avg(a2.timestamp - a1.timestamp), 3) as processing_time\\nFROM Activity as a1, Activity as a2\\nWHERE a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND a1.activity_type = \\'start\\' AND a2.activity_type = \\'end\\'\\nGROUP BY a1.machine_id"
                    },
                    {
                        "username": "RushikeshMahajan",
                        "content": "The given table is already joined table to make it complicated they should have given separate table with activity_type."
                    },
                    {
                        "username": "crothers17",
                        "content": "I can\\'t see what I did wrong based on the response. used a cte.\\n\\nWrong Answer\\nRuntime: 140 ms\\nCase 1\\n\\nOutput\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\nExpected\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\n"
                    },
                    {
                        "username": "Scaranin",
                        "content": "Another one solution:\\n\\nwith t\\n  as (  select machine_id\\n            , process_id\\n            , timestamp ts_start\\n            , activity_type\\n            , lead (timestamp) over (partition by machine_id, process_id order by activity_type desc) ts_end\\n         from Activity)\\nselect machine_id\\n     , round(avg(ts_end -ts_start), 3) processing_time\\n  from t\\n where activity_type = \\'start\\'\\n group by machine_id"
                    },
                    {
                        "username": "SabikaShahid",
                        "content": "with \\n\\nstart as ( select * from activity \\nwhere \\nactivity_type = \\'start\\' ), \\n\\nend as ( select * from activity where activity_type = \\'end\\' ),\\n\\nDifference as ( select start.machine_id, start.process_id,\\n end.timestamp - start.timestamp as td\\nfrom start \\nleft join end on start.machine_id = end.machine_id \\nand start.process_id = end.process_id\\nwhere start.machine_id = end.machine_id and start.process_id = end.process_id )\\n\\n\\n\\n select d.machine_id, round(avg(d.td),3) as processing_time  from difference as d, difference as dd\\n\\nwhere d.machine_id = dd.machine_id\\n\\ngroup by 1"
                    },
                    {
                        "username": "Anantjain03",
                        "content": "with cte as(select machine_id, process_id, round(sum(case when activity_type = 'start' then timestamp\n                            end),3) as sumstart_time,\n                            round(sum(case when activity_type='end' then timestamp\n                            end),3) as sumend_time\n                            from activity\n                            group by machine_id,process_id),\ncte2 as(select machine_id, (sumend_time-sumstart_time) as time1 from cte)\n\nselect machine_id,round((sum(time1))/count(machine_id),3) as processing_time from cte2\ngroup by machine_id"
                    },
                    {
                        "username": "14vivek",
                        "content": "I  think you have to correct your code at last. In cte2 you have to add column process_id and then in the main query replace it with the count of machine_id to count of process_id(As per the question.)\\n"
                    }
                ]
            },
            {
                "id": 1934803,
                "content": [
                    {
                        "username": "sarthakkharabanda",
                        "content": "can people keep the discussion tab for discussions only? What\\'s so hard to understand in that? Also, why is the question categorized as easy ;-:"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@contactaditya832126](/contactaditya832126) can do without doing self join"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically it\\'s a question of self join, If you could anyhow find out differnces between end and start for same processes you are done, you can make a cte for that"
                    },
                    {
                        "username": "Msey",
                        "content": "should be medium"
                    },
                    {
                        "username": "spookie886",
                        "content": "Came here looking for this comment."
                    },
                    {
                        "username": "rishu00007",
                        "content": "Definitely not an easy problem"
                    },
                    {
                        "username": "lancexie",
                        "content": "\\t# I see some others solving this question using case when and sum.... which is nice... but\\n\\t# That would not work if the timestamp is an actual date/time format. So I decided to just use join.\\n\\t\\n\\tselect a.machine_id, round(avg(b.timestamp - a.timestamp), 3) as processing_time \\n\\tfrom activity a join activity b\\n\\ton a.machine_id = b.machine_id and a.process_id = b.process_id and a.activity_type = \\'start\\' and b.activity_type = \\'end\\'\\n    group by 1;\\n"
                    },
                    {
                        "username": "SomnathDeb",
                        "content": "[@TGBBSZWHWDLANZP](/TGBBSZWHWDLANZP)  Idiom doesn\\'t work  here"
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I came up with same solution. :)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "`group by 1` is an idiom that groups by the first column.\\nWe can be more explicit by doing\\n```\\ngroup by a.machine_id\\n;\\n```"
                    },
                    {
                        "username": "sw_code",
                        "content": "\"\"\"\\nselect\\n    machine_id\\n    , round(sum(if(activity_type = \\'start\\', -1, 1) *timestamp)/count(distinct process_id),3) as processing_time\\nfrom activity\\ngroup by machine_id\\n\"\"\""
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a1.machine_id, ROUND(avg(a2.timestamp - a1.timestamp), 3) as processing_time\\nFROM Activity as a1, Activity as a2\\nWHERE a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND a1.activity_type = \\'start\\' AND a2.activity_type = \\'end\\'\\nGROUP BY a1.machine_id"
                    },
                    {
                        "username": "RushikeshMahajan",
                        "content": "The given table is already joined table to make it complicated they should have given separate table with activity_type."
                    },
                    {
                        "username": "crothers17",
                        "content": "I can\\'t see what I did wrong based on the response. used a cte.\\n\\nWrong Answer\\nRuntime: 140 ms\\nCase 1\\n\\nOutput\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\nExpected\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\n"
                    },
                    {
                        "username": "Scaranin",
                        "content": "Another one solution:\\n\\nwith t\\n  as (  select machine_id\\n            , process_id\\n            , timestamp ts_start\\n            , activity_type\\n            , lead (timestamp) over (partition by machine_id, process_id order by activity_type desc) ts_end\\n         from Activity)\\nselect machine_id\\n     , round(avg(ts_end -ts_start), 3) processing_time\\n  from t\\n where activity_type = \\'start\\'\\n group by machine_id"
                    },
                    {
                        "username": "SabikaShahid",
                        "content": "with \\n\\nstart as ( select * from activity \\nwhere \\nactivity_type = \\'start\\' ), \\n\\nend as ( select * from activity where activity_type = \\'end\\' ),\\n\\nDifference as ( select start.machine_id, start.process_id,\\n end.timestamp - start.timestamp as td\\nfrom start \\nleft join end on start.machine_id = end.machine_id \\nand start.process_id = end.process_id\\nwhere start.machine_id = end.machine_id and start.process_id = end.process_id )\\n\\n\\n\\n select d.machine_id, round(avg(d.td),3) as processing_time  from difference as d, difference as dd\\n\\nwhere d.machine_id = dd.machine_id\\n\\ngroup by 1"
                    },
                    {
                        "username": "Anantjain03",
                        "content": "with cte as(select machine_id, process_id, round(sum(case when activity_type = 'start' then timestamp\n                            end),3) as sumstart_time,\n                            round(sum(case when activity_type='end' then timestamp\n                            end),3) as sumend_time\n                            from activity\n                            group by machine_id,process_id),\ncte2 as(select machine_id, (sumend_time-sumstart_time) as time1 from cte)\n\nselect machine_id,round((sum(time1))/count(machine_id),3) as processing_time from cte2\ngroup by machine_id"
                    },
                    {
                        "username": "14vivek",
                        "content": "I  think you have to correct your code at last. In cte2 you have to add column process_id and then in the main query replace it with the count of machine_id to count of process_id(As per the question.)\\n"
                    }
                ]
            },
            {
                "id": 2033928,
                "content": [
                    {
                        "username": "sarthakkharabanda",
                        "content": "can people keep the discussion tab for discussions only? What\\'s so hard to understand in that? Also, why is the question categorized as easy ;-:"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@contactaditya832126](/contactaditya832126) can do without doing self join"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically it\\'s a question of self join, If you could anyhow find out differnces between end and start for same processes you are done, you can make a cte for that"
                    },
                    {
                        "username": "Msey",
                        "content": "should be medium"
                    },
                    {
                        "username": "spookie886",
                        "content": "Came here looking for this comment."
                    },
                    {
                        "username": "rishu00007",
                        "content": "Definitely not an easy problem"
                    },
                    {
                        "username": "lancexie",
                        "content": "\\t# I see some others solving this question using case when and sum.... which is nice... but\\n\\t# That would not work if the timestamp is an actual date/time format. So I decided to just use join.\\n\\t\\n\\tselect a.machine_id, round(avg(b.timestamp - a.timestamp), 3) as processing_time \\n\\tfrom activity a join activity b\\n\\ton a.machine_id = b.machine_id and a.process_id = b.process_id and a.activity_type = \\'start\\' and b.activity_type = \\'end\\'\\n    group by 1;\\n"
                    },
                    {
                        "username": "SomnathDeb",
                        "content": "[@TGBBSZWHWDLANZP](/TGBBSZWHWDLANZP)  Idiom doesn\\'t work  here"
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I came up with same solution. :)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "`group by 1` is an idiom that groups by the first column.\\nWe can be more explicit by doing\\n```\\ngroup by a.machine_id\\n;\\n```"
                    },
                    {
                        "username": "sw_code",
                        "content": "\"\"\"\\nselect\\n    machine_id\\n    , round(sum(if(activity_type = \\'start\\', -1, 1) *timestamp)/count(distinct process_id),3) as processing_time\\nfrom activity\\ngroup by machine_id\\n\"\"\""
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a1.machine_id, ROUND(avg(a2.timestamp - a1.timestamp), 3) as processing_time\\nFROM Activity as a1, Activity as a2\\nWHERE a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND a1.activity_type = \\'start\\' AND a2.activity_type = \\'end\\'\\nGROUP BY a1.machine_id"
                    },
                    {
                        "username": "RushikeshMahajan",
                        "content": "The given table is already joined table to make it complicated they should have given separate table with activity_type."
                    },
                    {
                        "username": "crothers17",
                        "content": "I can\\'t see what I did wrong based on the response. used a cte.\\n\\nWrong Answer\\nRuntime: 140 ms\\nCase 1\\n\\nOutput\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\nExpected\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\n"
                    },
                    {
                        "username": "Scaranin",
                        "content": "Another one solution:\\n\\nwith t\\n  as (  select machine_id\\n            , process_id\\n            , timestamp ts_start\\n            , activity_type\\n            , lead (timestamp) over (partition by machine_id, process_id order by activity_type desc) ts_end\\n         from Activity)\\nselect machine_id\\n     , round(avg(ts_end -ts_start), 3) processing_time\\n  from t\\n where activity_type = \\'start\\'\\n group by machine_id"
                    },
                    {
                        "username": "SabikaShahid",
                        "content": "with \\n\\nstart as ( select * from activity \\nwhere \\nactivity_type = \\'start\\' ), \\n\\nend as ( select * from activity where activity_type = \\'end\\' ),\\n\\nDifference as ( select start.machine_id, start.process_id,\\n end.timestamp - start.timestamp as td\\nfrom start \\nleft join end on start.machine_id = end.machine_id \\nand start.process_id = end.process_id\\nwhere start.machine_id = end.machine_id and start.process_id = end.process_id )\\n\\n\\n\\n select d.machine_id, round(avg(d.td),3) as processing_time  from difference as d, difference as dd\\n\\nwhere d.machine_id = dd.machine_id\\n\\ngroup by 1"
                    },
                    {
                        "username": "Anantjain03",
                        "content": "with cte as(select machine_id, process_id, round(sum(case when activity_type = 'start' then timestamp\n                            end),3) as sumstart_time,\n                            round(sum(case when activity_type='end' then timestamp\n                            end),3) as sumend_time\n                            from activity\n                            group by machine_id,process_id),\ncte2 as(select machine_id, (sumend_time-sumstart_time) as time1 from cte)\n\nselect machine_id,round((sum(time1))/count(machine_id),3) as processing_time from cte2\ngroup by machine_id"
                    },
                    {
                        "username": "14vivek",
                        "content": "I  think you have to correct your code at last. In cte2 you have to add column process_id and then in the main query replace it with the count of machine_id to count of process_id(As per the question.)\\n"
                    }
                ]
            },
            {
                "id": 1575226,
                "content": [
                    {
                        "username": "sarthakkharabanda",
                        "content": "can people keep the discussion tab for discussions only? What\\'s so hard to understand in that? Also, why is the question categorized as easy ;-:"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@contactaditya832126](/contactaditya832126) can do without doing self join"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically it\\'s a question of self join, If you could anyhow find out differnces between end and start for same processes you are done, you can make a cte for that"
                    },
                    {
                        "username": "Msey",
                        "content": "should be medium"
                    },
                    {
                        "username": "spookie886",
                        "content": "Came here looking for this comment."
                    },
                    {
                        "username": "rishu00007",
                        "content": "Definitely not an easy problem"
                    },
                    {
                        "username": "lancexie",
                        "content": "\\t# I see some others solving this question using case when and sum.... which is nice... but\\n\\t# That would not work if the timestamp is an actual date/time format. So I decided to just use join.\\n\\t\\n\\tselect a.machine_id, round(avg(b.timestamp - a.timestamp), 3) as processing_time \\n\\tfrom activity a join activity b\\n\\ton a.machine_id = b.machine_id and a.process_id = b.process_id and a.activity_type = \\'start\\' and b.activity_type = \\'end\\'\\n    group by 1;\\n"
                    },
                    {
                        "username": "SomnathDeb",
                        "content": "[@TGBBSZWHWDLANZP](/TGBBSZWHWDLANZP)  Idiom doesn\\'t work  here"
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I came up with same solution. :)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "`group by 1` is an idiom that groups by the first column.\\nWe can be more explicit by doing\\n```\\ngroup by a.machine_id\\n;\\n```"
                    },
                    {
                        "username": "sw_code",
                        "content": "\"\"\"\\nselect\\n    machine_id\\n    , round(sum(if(activity_type = \\'start\\', -1, 1) *timestamp)/count(distinct process_id),3) as processing_time\\nfrom activity\\ngroup by machine_id\\n\"\"\""
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a1.machine_id, ROUND(avg(a2.timestamp - a1.timestamp), 3) as processing_time\\nFROM Activity as a1, Activity as a2\\nWHERE a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND a1.activity_type = \\'start\\' AND a2.activity_type = \\'end\\'\\nGROUP BY a1.machine_id"
                    },
                    {
                        "username": "RushikeshMahajan",
                        "content": "The given table is already joined table to make it complicated they should have given separate table with activity_type."
                    },
                    {
                        "username": "crothers17",
                        "content": "I can\\'t see what I did wrong based on the response. used a cte.\\n\\nWrong Answer\\nRuntime: 140 ms\\nCase 1\\n\\nOutput\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\nExpected\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\n"
                    },
                    {
                        "username": "Scaranin",
                        "content": "Another one solution:\\n\\nwith t\\n  as (  select machine_id\\n            , process_id\\n            , timestamp ts_start\\n            , activity_type\\n            , lead (timestamp) over (partition by machine_id, process_id order by activity_type desc) ts_end\\n         from Activity)\\nselect machine_id\\n     , round(avg(ts_end -ts_start), 3) processing_time\\n  from t\\n where activity_type = \\'start\\'\\n group by machine_id"
                    },
                    {
                        "username": "SabikaShahid",
                        "content": "with \\n\\nstart as ( select * from activity \\nwhere \\nactivity_type = \\'start\\' ), \\n\\nend as ( select * from activity where activity_type = \\'end\\' ),\\n\\nDifference as ( select start.machine_id, start.process_id,\\n end.timestamp - start.timestamp as td\\nfrom start \\nleft join end on start.machine_id = end.machine_id \\nand start.process_id = end.process_id\\nwhere start.machine_id = end.machine_id and start.process_id = end.process_id )\\n\\n\\n\\n select d.machine_id, round(avg(d.td),3) as processing_time  from difference as d, difference as dd\\n\\nwhere d.machine_id = dd.machine_id\\n\\ngroup by 1"
                    },
                    {
                        "username": "Anantjain03",
                        "content": "with cte as(select machine_id, process_id, round(sum(case when activity_type = 'start' then timestamp\n                            end),3) as sumstart_time,\n                            round(sum(case when activity_type='end' then timestamp\n                            end),3) as sumend_time\n                            from activity\n                            group by machine_id,process_id),\ncte2 as(select machine_id, (sumend_time-sumstart_time) as time1 from cte)\n\nselect machine_id,round((sum(time1))/count(machine_id),3) as processing_time from cte2\ngroup by machine_id"
                    },
                    {
                        "username": "14vivek",
                        "content": "I  think you have to correct your code at last. In cte2 you have to add column process_id and then in the main query replace it with the count of machine_id to count of process_id(As per the question.)\\n"
                    }
                ]
            },
            {
                "id": 1570395,
                "content": [
                    {
                        "username": "sarthakkharabanda",
                        "content": "can people keep the discussion tab for discussions only? What\\'s so hard to understand in that? Also, why is the question categorized as easy ;-:"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@contactaditya832126](/contactaditya832126) can do without doing self join"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically it\\'s a question of self join, If you could anyhow find out differnces between end and start for same processes you are done, you can make a cte for that"
                    },
                    {
                        "username": "Msey",
                        "content": "should be medium"
                    },
                    {
                        "username": "spookie886",
                        "content": "Came here looking for this comment."
                    },
                    {
                        "username": "rishu00007",
                        "content": "Definitely not an easy problem"
                    },
                    {
                        "username": "lancexie",
                        "content": "\\t# I see some others solving this question using case when and sum.... which is nice... but\\n\\t# That would not work if the timestamp is an actual date/time format. So I decided to just use join.\\n\\t\\n\\tselect a.machine_id, round(avg(b.timestamp - a.timestamp), 3) as processing_time \\n\\tfrom activity a join activity b\\n\\ton a.machine_id = b.machine_id and a.process_id = b.process_id and a.activity_type = \\'start\\' and b.activity_type = \\'end\\'\\n    group by 1;\\n"
                    },
                    {
                        "username": "SomnathDeb",
                        "content": "[@TGBBSZWHWDLANZP](/TGBBSZWHWDLANZP)  Idiom doesn\\'t work  here"
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I came up with same solution. :)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "`group by 1` is an idiom that groups by the first column.\\nWe can be more explicit by doing\\n```\\ngroup by a.machine_id\\n;\\n```"
                    },
                    {
                        "username": "sw_code",
                        "content": "\"\"\"\\nselect\\n    machine_id\\n    , round(sum(if(activity_type = \\'start\\', -1, 1) *timestamp)/count(distinct process_id),3) as processing_time\\nfrom activity\\ngroup by machine_id\\n\"\"\""
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a1.machine_id, ROUND(avg(a2.timestamp - a1.timestamp), 3) as processing_time\\nFROM Activity as a1, Activity as a2\\nWHERE a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND a1.activity_type = \\'start\\' AND a2.activity_type = \\'end\\'\\nGROUP BY a1.machine_id"
                    },
                    {
                        "username": "RushikeshMahajan",
                        "content": "The given table is already joined table to make it complicated they should have given separate table with activity_type."
                    },
                    {
                        "username": "crothers17",
                        "content": "I can\\'t see what I did wrong based on the response. used a cte.\\n\\nWrong Answer\\nRuntime: 140 ms\\nCase 1\\n\\nOutput\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\nExpected\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\n"
                    },
                    {
                        "username": "Scaranin",
                        "content": "Another one solution:\\n\\nwith t\\n  as (  select machine_id\\n            , process_id\\n            , timestamp ts_start\\n            , activity_type\\n            , lead (timestamp) over (partition by machine_id, process_id order by activity_type desc) ts_end\\n         from Activity)\\nselect machine_id\\n     , round(avg(ts_end -ts_start), 3) processing_time\\n  from t\\n where activity_type = \\'start\\'\\n group by machine_id"
                    },
                    {
                        "username": "SabikaShahid",
                        "content": "with \\n\\nstart as ( select * from activity \\nwhere \\nactivity_type = \\'start\\' ), \\n\\nend as ( select * from activity where activity_type = \\'end\\' ),\\n\\nDifference as ( select start.machine_id, start.process_id,\\n end.timestamp - start.timestamp as td\\nfrom start \\nleft join end on start.machine_id = end.machine_id \\nand start.process_id = end.process_id\\nwhere start.machine_id = end.machine_id and start.process_id = end.process_id )\\n\\n\\n\\n select d.machine_id, round(avg(d.td),3) as processing_time  from difference as d, difference as dd\\n\\nwhere d.machine_id = dd.machine_id\\n\\ngroup by 1"
                    },
                    {
                        "username": "Anantjain03",
                        "content": "with cte as(select machine_id, process_id, round(sum(case when activity_type = 'start' then timestamp\n                            end),3) as sumstart_time,\n                            round(sum(case when activity_type='end' then timestamp\n                            end),3) as sumend_time\n                            from activity\n                            group by machine_id,process_id),\ncte2 as(select machine_id, (sumend_time-sumstart_time) as time1 from cte)\n\nselect machine_id,round((sum(time1))/count(machine_id),3) as processing_time from cte2\ngroup by machine_id"
                    },
                    {
                        "username": "14vivek",
                        "content": "I  think you have to correct your code at last. In cte2 you have to add column process_id and then in the main query replace it with the count of machine_id to count of process_id(As per the question.)\\n"
                    }
                ]
            },
            {
                "id": 1883530,
                "content": [
                    {
                        "username": "sarthakkharabanda",
                        "content": "can people keep the discussion tab for discussions only? What\\'s so hard to understand in that? Also, why is the question categorized as easy ;-:"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@contactaditya832126](/contactaditya832126) can do without doing self join"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically it\\'s a question of self join, If you could anyhow find out differnces between end and start for same processes you are done, you can make a cte for that"
                    },
                    {
                        "username": "Msey",
                        "content": "should be medium"
                    },
                    {
                        "username": "spookie886",
                        "content": "Came here looking for this comment."
                    },
                    {
                        "username": "rishu00007",
                        "content": "Definitely not an easy problem"
                    },
                    {
                        "username": "lancexie",
                        "content": "\\t# I see some others solving this question using case when and sum.... which is nice... but\\n\\t# That would not work if the timestamp is an actual date/time format. So I decided to just use join.\\n\\t\\n\\tselect a.machine_id, round(avg(b.timestamp - a.timestamp), 3) as processing_time \\n\\tfrom activity a join activity b\\n\\ton a.machine_id = b.machine_id and a.process_id = b.process_id and a.activity_type = \\'start\\' and b.activity_type = \\'end\\'\\n    group by 1;\\n"
                    },
                    {
                        "username": "SomnathDeb",
                        "content": "[@TGBBSZWHWDLANZP](/TGBBSZWHWDLANZP)  Idiom doesn\\'t work  here"
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I came up with same solution. :)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "`group by 1` is an idiom that groups by the first column.\\nWe can be more explicit by doing\\n```\\ngroup by a.machine_id\\n;\\n```"
                    },
                    {
                        "username": "sw_code",
                        "content": "\"\"\"\\nselect\\n    machine_id\\n    , round(sum(if(activity_type = \\'start\\', -1, 1) *timestamp)/count(distinct process_id),3) as processing_time\\nfrom activity\\ngroup by machine_id\\n\"\"\""
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a1.machine_id, ROUND(avg(a2.timestamp - a1.timestamp), 3) as processing_time\\nFROM Activity as a1, Activity as a2\\nWHERE a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND a1.activity_type = \\'start\\' AND a2.activity_type = \\'end\\'\\nGROUP BY a1.machine_id"
                    },
                    {
                        "username": "RushikeshMahajan",
                        "content": "The given table is already joined table to make it complicated they should have given separate table with activity_type."
                    },
                    {
                        "username": "crothers17",
                        "content": "I can\\'t see what I did wrong based on the response. used a cte.\\n\\nWrong Answer\\nRuntime: 140 ms\\nCase 1\\n\\nOutput\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\nExpected\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\n"
                    },
                    {
                        "username": "Scaranin",
                        "content": "Another one solution:\\n\\nwith t\\n  as (  select machine_id\\n            , process_id\\n            , timestamp ts_start\\n            , activity_type\\n            , lead (timestamp) over (partition by machine_id, process_id order by activity_type desc) ts_end\\n         from Activity)\\nselect machine_id\\n     , round(avg(ts_end -ts_start), 3) processing_time\\n  from t\\n where activity_type = \\'start\\'\\n group by machine_id"
                    },
                    {
                        "username": "SabikaShahid",
                        "content": "with \\n\\nstart as ( select * from activity \\nwhere \\nactivity_type = \\'start\\' ), \\n\\nend as ( select * from activity where activity_type = \\'end\\' ),\\n\\nDifference as ( select start.machine_id, start.process_id,\\n end.timestamp - start.timestamp as td\\nfrom start \\nleft join end on start.machine_id = end.machine_id \\nand start.process_id = end.process_id\\nwhere start.machine_id = end.machine_id and start.process_id = end.process_id )\\n\\n\\n\\n select d.machine_id, round(avg(d.td),3) as processing_time  from difference as d, difference as dd\\n\\nwhere d.machine_id = dd.machine_id\\n\\ngroup by 1"
                    },
                    {
                        "username": "Anantjain03",
                        "content": "with cte as(select machine_id, process_id, round(sum(case when activity_type = 'start' then timestamp\n                            end),3) as sumstart_time,\n                            round(sum(case when activity_type='end' then timestamp\n                            end),3) as sumend_time\n                            from activity\n                            group by machine_id,process_id),\ncte2 as(select machine_id, (sumend_time-sumstart_time) as time1 from cte)\n\nselect machine_id,round((sum(time1))/count(machine_id),3) as processing_time from cte2\ngroup by machine_id"
                    },
                    {
                        "username": "14vivek",
                        "content": "I  think you have to correct your code at last. In cte2 you have to add column process_id and then in the main query replace it with the count of machine_id to count of process_id(As per the question.)\\n"
                    }
                ]
            },
            {
                "id": 2009536,
                "content": [
                    {
                        "username": "sarthakkharabanda",
                        "content": "can people keep the discussion tab for discussions only? What\\'s so hard to understand in that? Also, why is the question categorized as easy ;-:"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@contactaditya832126](/contactaditya832126) can do without doing self join"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically it\\'s a question of self join, If you could anyhow find out differnces between end and start for same processes you are done, you can make a cte for that"
                    },
                    {
                        "username": "Msey",
                        "content": "should be medium"
                    },
                    {
                        "username": "spookie886",
                        "content": "Came here looking for this comment."
                    },
                    {
                        "username": "rishu00007",
                        "content": "Definitely not an easy problem"
                    },
                    {
                        "username": "lancexie",
                        "content": "\\t# I see some others solving this question using case when and sum.... which is nice... but\\n\\t# That would not work if the timestamp is an actual date/time format. So I decided to just use join.\\n\\t\\n\\tselect a.machine_id, round(avg(b.timestamp - a.timestamp), 3) as processing_time \\n\\tfrom activity a join activity b\\n\\ton a.machine_id = b.machine_id and a.process_id = b.process_id and a.activity_type = \\'start\\' and b.activity_type = \\'end\\'\\n    group by 1;\\n"
                    },
                    {
                        "username": "SomnathDeb",
                        "content": "[@TGBBSZWHWDLANZP](/TGBBSZWHWDLANZP)  Idiom doesn\\'t work  here"
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I came up with same solution. :)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "`group by 1` is an idiom that groups by the first column.\\nWe can be more explicit by doing\\n```\\ngroup by a.machine_id\\n;\\n```"
                    },
                    {
                        "username": "sw_code",
                        "content": "\"\"\"\\nselect\\n    machine_id\\n    , round(sum(if(activity_type = \\'start\\', -1, 1) *timestamp)/count(distinct process_id),3) as processing_time\\nfrom activity\\ngroup by machine_id\\n\"\"\""
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a1.machine_id, ROUND(avg(a2.timestamp - a1.timestamp), 3) as processing_time\\nFROM Activity as a1, Activity as a2\\nWHERE a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND a1.activity_type = \\'start\\' AND a2.activity_type = \\'end\\'\\nGROUP BY a1.machine_id"
                    },
                    {
                        "username": "RushikeshMahajan",
                        "content": "The given table is already joined table to make it complicated they should have given separate table with activity_type."
                    },
                    {
                        "username": "crothers17",
                        "content": "I can\\'t see what I did wrong based on the response. used a cte.\\n\\nWrong Answer\\nRuntime: 140 ms\\nCase 1\\n\\nOutput\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\nExpected\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\n"
                    },
                    {
                        "username": "Scaranin",
                        "content": "Another one solution:\\n\\nwith t\\n  as (  select machine_id\\n            , process_id\\n            , timestamp ts_start\\n            , activity_type\\n            , lead (timestamp) over (partition by machine_id, process_id order by activity_type desc) ts_end\\n         from Activity)\\nselect machine_id\\n     , round(avg(ts_end -ts_start), 3) processing_time\\n  from t\\n where activity_type = \\'start\\'\\n group by machine_id"
                    },
                    {
                        "username": "SabikaShahid",
                        "content": "with \\n\\nstart as ( select * from activity \\nwhere \\nactivity_type = \\'start\\' ), \\n\\nend as ( select * from activity where activity_type = \\'end\\' ),\\n\\nDifference as ( select start.machine_id, start.process_id,\\n end.timestamp - start.timestamp as td\\nfrom start \\nleft join end on start.machine_id = end.machine_id \\nand start.process_id = end.process_id\\nwhere start.machine_id = end.machine_id and start.process_id = end.process_id )\\n\\n\\n\\n select d.machine_id, round(avg(d.td),3) as processing_time  from difference as d, difference as dd\\n\\nwhere d.machine_id = dd.machine_id\\n\\ngroup by 1"
                    },
                    {
                        "username": "Anantjain03",
                        "content": "with cte as(select machine_id, process_id, round(sum(case when activity_type = 'start' then timestamp\n                            end),3) as sumstart_time,\n                            round(sum(case when activity_type='end' then timestamp\n                            end),3) as sumend_time\n                            from activity\n                            group by machine_id,process_id),\ncte2 as(select machine_id, (sumend_time-sumstart_time) as time1 from cte)\n\nselect machine_id,round((sum(time1))/count(machine_id),3) as processing_time from cte2\ngroup by machine_id"
                    },
                    {
                        "username": "14vivek",
                        "content": "I  think you have to correct your code at last. In cte2 you have to add column process_id and then in the main query replace it with the count of machine_id to count of process_id(As per the question.)\\n"
                    }
                ]
            },
            {
                "id": 2049070,
                "content": [
                    {
                        "username": "sarthakkharabanda",
                        "content": "can people keep the discussion tab for discussions only? What\\'s so hard to understand in that? Also, why is the question categorized as easy ;-:"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@contactaditya832126](/contactaditya832126) can do without doing self join"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically it\\'s a question of self join, If you could anyhow find out differnces between end and start for same processes you are done, you can make a cte for that"
                    },
                    {
                        "username": "Msey",
                        "content": "should be medium"
                    },
                    {
                        "username": "spookie886",
                        "content": "Came here looking for this comment."
                    },
                    {
                        "username": "rishu00007",
                        "content": "Definitely not an easy problem"
                    },
                    {
                        "username": "lancexie",
                        "content": "\\t# I see some others solving this question using case when and sum.... which is nice... but\\n\\t# That would not work if the timestamp is an actual date/time format. So I decided to just use join.\\n\\t\\n\\tselect a.machine_id, round(avg(b.timestamp - a.timestamp), 3) as processing_time \\n\\tfrom activity a join activity b\\n\\ton a.machine_id = b.machine_id and a.process_id = b.process_id and a.activity_type = \\'start\\' and b.activity_type = \\'end\\'\\n    group by 1;\\n"
                    },
                    {
                        "username": "SomnathDeb",
                        "content": "[@TGBBSZWHWDLANZP](/TGBBSZWHWDLANZP)  Idiom doesn\\'t work  here"
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I came up with same solution. :)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "`group by 1` is an idiom that groups by the first column.\\nWe can be more explicit by doing\\n```\\ngroup by a.machine_id\\n;\\n```"
                    },
                    {
                        "username": "sw_code",
                        "content": "\"\"\"\\nselect\\n    machine_id\\n    , round(sum(if(activity_type = \\'start\\', -1, 1) *timestamp)/count(distinct process_id),3) as processing_time\\nfrom activity\\ngroup by machine_id\\n\"\"\""
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a1.machine_id, ROUND(avg(a2.timestamp - a1.timestamp), 3) as processing_time\\nFROM Activity as a1, Activity as a2\\nWHERE a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND a1.activity_type = \\'start\\' AND a2.activity_type = \\'end\\'\\nGROUP BY a1.machine_id"
                    },
                    {
                        "username": "RushikeshMahajan",
                        "content": "The given table is already joined table to make it complicated they should have given separate table with activity_type."
                    },
                    {
                        "username": "crothers17",
                        "content": "I can\\'t see what I did wrong based on the response. used a cte.\\n\\nWrong Answer\\nRuntime: 140 ms\\nCase 1\\n\\nOutput\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\nExpected\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\n"
                    },
                    {
                        "username": "Scaranin",
                        "content": "Another one solution:\\n\\nwith t\\n  as (  select machine_id\\n            , process_id\\n            , timestamp ts_start\\n            , activity_type\\n            , lead (timestamp) over (partition by machine_id, process_id order by activity_type desc) ts_end\\n         from Activity)\\nselect machine_id\\n     , round(avg(ts_end -ts_start), 3) processing_time\\n  from t\\n where activity_type = \\'start\\'\\n group by machine_id"
                    },
                    {
                        "username": "SabikaShahid",
                        "content": "with \\n\\nstart as ( select * from activity \\nwhere \\nactivity_type = \\'start\\' ), \\n\\nend as ( select * from activity where activity_type = \\'end\\' ),\\n\\nDifference as ( select start.machine_id, start.process_id,\\n end.timestamp - start.timestamp as td\\nfrom start \\nleft join end on start.machine_id = end.machine_id \\nand start.process_id = end.process_id\\nwhere start.machine_id = end.machine_id and start.process_id = end.process_id )\\n\\n\\n\\n select d.machine_id, round(avg(d.td),3) as processing_time  from difference as d, difference as dd\\n\\nwhere d.machine_id = dd.machine_id\\n\\ngroup by 1"
                    },
                    {
                        "username": "Anantjain03",
                        "content": "with cte as(select machine_id, process_id, round(sum(case when activity_type = 'start' then timestamp\n                            end),3) as sumstart_time,\n                            round(sum(case when activity_type='end' then timestamp\n                            end),3) as sumend_time\n                            from activity\n                            group by machine_id,process_id),\ncte2 as(select machine_id, (sumend_time-sumstart_time) as time1 from cte)\n\nselect machine_id,round((sum(time1))/count(machine_id),3) as processing_time from cte2\ngroup by machine_id"
                    },
                    {
                        "username": "14vivek",
                        "content": "I  think you have to correct your code at last. In cte2 you have to add column process_id and then in the main query replace it with the count of machine_id to count of process_id(As per the question.)\\n"
                    }
                ]
            },
            {
                "id": 2046338,
                "content": [
                    {
                        "username": "sarthakkharabanda",
                        "content": "can people keep the discussion tab for discussions only? What\\'s so hard to understand in that? Also, why is the question categorized as easy ;-:"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@contactaditya832126](/contactaditya832126) can do without doing self join"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically it\\'s a question of self join, If you could anyhow find out differnces between end and start for same processes you are done, you can make a cte for that"
                    },
                    {
                        "username": "Msey",
                        "content": "should be medium"
                    },
                    {
                        "username": "spookie886",
                        "content": "Came here looking for this comment."
                    },
                    {
                        "username": "rishu00007",
                        "content": "Definitely not an easy problem"
                    },
                    {
                        "username": "lancexie",
                        "content": "\\t# I see some others solving this question using case when and sum.... which is nice... but\\n\\t# That would not work if the timestamp is an actual date/time format. So I decided to just use join.\\n\\t\\n\\tselect a.machine_id, round(avg(b.timestamp - a.timestamp), 3) as processing_time \\n\\tfrom activity a join activity b\\n\\ton a.machine_id = b.machine_id and a.process_id = b.process_id and a.activity_type = \\'start\\' and b.activity_type = \\'end\\'\\n    group by 1;\\n"
                    },
                    {
                        "username": "SomnathDeb",
                        "content": "[@TGBBSZWHWDLANZP](/TGBBSZWHWDLANZP)  Idiom doesn\\'t work  here"
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I came up with same solution. :)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "`group by 1` is an idiom that groups by the first column.\\nWe can be more explicit by doing\\n```\\ngroup by a.machine_id\\n;\\n```"
                    },
                    {
                        "username": "sw_code",
                        "content": "\"\"\"\\nselect\\n    machine_id\\n    , round(sum(if(activity_type = \\'start\\', -1, 1) *timestamp)/count(distinct process_id),3) as processing_time\\nfrom activity\\ngroup by machine_id\\n\"\"\""
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a1.machine_id, ROUND(avg(a2.timestamp - a1.timestamp), 3) as processing_time\\nFROM Activity as a1, Activity as a2\\nWHERE a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND a1.activity_type = \\'start\\' AND a2.activity_type = \\'end\\'\\nGROUP BY a1.machine_id"
                    },
                    {
                        "username": "RushikeshMahajan",
                        "content": "The given table is already joined table to make it complicated they should have given separate table with activity_type."
                    },
                    {
                        "username": "crothers17",
                        "content": "I can\\'t see what I did wrong based on the response. used a cte.\\n\\nWrong Answer\\nRuntime: 140 ms\\nCase 1\\n\\nOutput\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\nExpected\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\n"
                    },
                    {
                        "username": "Scaranin",
                        "content": "Another one solution:\\n\\nwith t\\n  as (  select machine_id\\n            , process_id\\n            , timestamp ts_start\\n            , activity_type\\n            , lead (timestamp) over (partition by machine_id, process_id order by activity_type desc) ts_end\\n         from Activity)\\nselect machine_id\\n     , round(avg(ts_end -ts_start), 3) processing_time\\n  from t\\n where activity_type = \\'start\\'\\n group by machine_id"
                    },
                    {
                        "username": "SabikaShahid",
                        "content": "with \\n\\nstart as ( select * from activity \\nwhere \\nactivity_type = \\'start\\' ), \\n\\nend as ( select * from activity where activity_type = \\'end\\' ),\\n\\nDifference as ( select start.machine_id, start.process_id,\\n end.timestamp - start.timestamp as td\\nfrom start \\nleft join end on start.machine_id = end.machine_id \\nand start.process_id = end.process_id\\nwhere start.machine_id = end.machine_id and start.process_id = end.process_id )\\n\\n\\n\\n select d.machine_id, round(avg(d.td),3) as processing_time  from difference as d, difference as dd\\n\\nwhere d.machine_id = dd.machine_id\\n\\ngroup by 1"
                    },
                    {
                        "username": "Anantjain03",
                        "content": "with cte as(select machine_id, process_id, round(sum(case when activity_type = 'start' then timestamp\n                            end),3) as sumstart_time,\n                            round(sum(case when activity_type='end' then timestamp\n                            end),3) as sumend_time\n                            from activity\n                            group by machine_id,process_id),\ncte2 as(select machine_id, (sumend_time-sumstart_time) as time1 from cte)\n\nselect machine_id,round((sum(time1))/count(machine_id),3) as processing_time from cte2\ngroup by machine_id"
                    },
                    {
                        "username": "14vivek",
                        "content": "I  think you have to correct your code at last. In cte2 you have to add column process_id and then in the main query replace it with the count of machine_id to count of process_id(As per the question.)\\n"
                    }
                ]
            },
            {
                "id": 1995112,
                "content": [
                    {
                        "username": "sarthakkharabanda",
                        "content": "can people keep the discussion tab for discussions only? What\\'s so hard to understand in that? Also, why is the question categorized as easy ;-:"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@contactaditya832126](/contactaditya832126) can do without doing self join"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "Basically it\\'s a question of self join, If you could anyhow find out differnces between end and start for same processes you are done, you can make a cte for that"
                    },
                    {
                        "username": "Msey",
                        "content": "should be medium"
                    },
                    {
                        "username": "spookie886",
                        "content": "Came here looking for this comment."
                    },
                    {
                        "username": "rishu00007",
                        "content": "Definitely not an easy problem"
                    },
                    {
                        "username": "lancexie",
                        "content": "\\t# I see some others solving this question using case when and sum.... which is nice... but\\n\\t# That would not work if the timestamp is an actual date/time format. So I decided to just use join.\\n\\t\\n\\tselect a.machine_id, round(avg(b.timestamp - a.timestamp), 3) as processing_time \\n\\tfrom activity a join activity b\\n\\ton a.machine_id = b.machine_id and a.process_id = b.process_id and a.activity_type = \\'start\\' and b.activity_type = \\'end\\'\\n    group by 1;\\n"
                    },
                    {
                        "username": "SomnathDeb",
                        "content": "[@TGBBSZWHWDLANZP](/TGBBSZWHWDLANZP)  Idiom doesn\\'t work  here"
                    },
                    {
                        "username": "Tirumanidas",
                        "content": "I came up with same solution. :)"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "`group by 1` is an idiom that groups by the first column.\\nWe can be more explicit by doing\\n```\\ngroup by a.machine_id\\n;\\n```"
                    },
                    {
                        "username": "sw_code",
                        "content": "\"\"\"\\nselect\\n    machine_id\\n    , round(sum(if(activity_type = \\'start\\', -1, 1) *timestamp)/count(distinct process_id),3) as processing_time\\nfrom activity\\ngroup by machine_id\\n\"\"\""
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT a1.machine_id, ROUND(avg(a2.timestamp - a1.timestamp), 3) as processing_time\\nFROM Activity as a1, Activity as a2\\nWHERE a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND a1.activity_type = \\'start\\' AND a2.activity_type = \\'end\\'\\nGROUP BY a1.machine_id"
                    },
                    {
                        "username": "RushikeshMahajan",
                        "content": "The given table is already joined table to make it complicated they should have given separate table with activity_type."
                    },
                    {
                        "username": "crothers17",
                        "content": "I can\\'t see what I did wrong based on the response. used a cte.\\n\\nWrong Answer\\nRuntime: 140 ms\\nCase 1\\n\\nOutput\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\nExpected\\n| machine_id | processing_time |\\n| ---------- | --------------- |\\n| 0          | 0.894           |\\n| 1          | 0.995           |\\n| 2          | 1.456           |\\n"
                    },
                    {
                        "username": "Scaranin",
                        "content": "Another one solution:\\n\\nwith t\\n  as (  select machine_id\\n            , process_id\\n            , timestamp ts_start\\n            , activity_type\\n            , lead (timestamp) over (partition by machine_id, process_id order by activity_type desc) ts_end\\n         from Activity)\\nselect machine_id\\n     , round(avg(ts_end -ts_start), 3) processing_time\\n  from t\\n where activity_type = \\'start\\'\\n group by machine_id"
                    },
                    {
                        "username": "SabikaShahid",
                        "content": "with \\n\\nstart as ( select * from activity \\nwhere \\nactivity_type = \\'start\\' ), \\n\\nend as ( select * from activity where activity_type = \\'end\\' ),\\n\\nDifference as ( select start.machine_id, start.process_id,\\n end.timestamp - start.timestamp as td\\nfrom start \\nleft join end on start.machine_id = end.machine_id \\nand start.process_id = end.process_id\\nwhere start.machine_id = end.machine_id and start.process_id = end.process_id )\\n\\n\\n\\n select d.machine_id, round(avg(d.td),3) as processing_time  from difference as d, difference as dd\\n\\nwhere d.machine_id = dd.machine_id\\n\\ngroup by 1"
                    },
                    {
                        "username": "Anantjain03",
                        "content": "with cte as(select machine_id, process_id, round(sum(case when activity_type = 'start' then timestamp\n                            end),3) as sumstart_time,\n                            round(sum(case when activity_type='end' then timestamp\n                            end),3) as sumend_time\n                            from activity\n                            group by machine_id,process_id),\ncte2 as(select machine_id, (sumend_time-sumstart_time) as time1 from cte)\n\nselect machine_id,round((sum(time1))/count(machine_id),3) as processing_time from cte2\ngroup by machine_id"
                    },
                    {
                        "username": "14vivek",
                        "content": "I  think you have to correct your code at last. In cte2 you have to add column process_id and then in the main query replace it with the count of machine_id to count of process_id(As per the question.)\\n"
                    }
                ]
            },
            {
                "id": 1958866,
                "content": [
                    {
                        "username": "chriswebdv",
                        "content": "just a clue since this should be a medium difficulty problem. use CTEs"
                    },
                    {
                        "username": "Sarthak_Sriw",
                        "content": "with ct as \\n(select machine_id ,sum(case when activity_type = \\'end\\' then timestamp else -1 * timestamp end) as s1 ,count(*)/2 as c1 from Activity group by machine_id)\\n\\nselect machine_id,round(s1/c1,3) as processing_time from ct"
                    },
                    {
                        "username": "dineshyuga",
                        "content": "Easy Way Using Case Statement.\\n\\n/* Write your T-SQL query statement below */\\nselect \\nmachine_id,\\nround(sum(endtime - starttime)/count(distinct(process_id)),3) as processing_time\\nfrom\\n(\\nselect \\nmachine_id,\\nprocess_id,\\nmin(Case when activity_type = \\'start\\' then timestamp end) as starttime,\\nmax(Case when activity_type = \\'end\\' then timestamp end) as endtime\\nfrom Activity\\ngroup by machine_id, process_id\\n) as x\\ngroup by machine_id"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "with cte as\\n(\\nselect case activity_type when \\'start\\' then nvl(timestamp,0) end  start_timestamp,\\n       case activity_type when \\'end\\' then nvl(timestamp,0) end  end_timestamp,\\n       --(end_timestamp-start_timestamp) as diff_ts,\\n       machine_id,\\n       process_id,\\n       activity_type\\n       from activity\\n)\\nselect machine_id, round(sum(nvl(end_timestamp,0)-nvl(start_timestamp,0))/count(distinct process_id),3) as processing_time\\nfrom cte\\ngroup by machine_id\\norder by machine_id;"
                    },
                    {
                        "username": "anish_raja",
                        "content": "can anyone please tell me why we can\\'t use timediff() function here?"
                    },
                    {
                        "username": "sfan0037",
                        "content": "SELECT a1.machine_id, ROUND(AVG(a1.timestamp-a2.timestamp),3) AS processing_time\\nFROM Activity AS a1\\nInner join Activity AS a2\\nON a1.machine_id=a2.machine_id AND a1.process_id=a2.process_id AND a1.activity_type=\\'end\\' AND a2.activity_type=\\'start\\'\\nGROUP BY machine_id\\nORDER BY machine_id"
                    },
                    {
                        "username": "sunil93",
                        "content": "Oracle SQL:\n\nselect a.machine_id, round(avg (b.timestamp-a.timestamp),3) as processing_time\nfrom activity a,activity b\nwhere a.machine_id=b.machine_id AND \n    a.process_id=b.process_id AND\n    a.activity_type ='start' AND\n    b.activity_type ='end'\ngroup by  a.machine_id\norder by a.machine_id asc;"
                    },
                    {
                        "username": "1703Adish",
                        "content": "select machine_id, cast(avg(v) as decimal(10,3)) as processing_time from(select *, a.`timestamp`- lead(a.`timestamp`) over (partition by a.machine_id,a.process_id order by a.flag) v from (select machine_id, process_id,timestamp, case when activity_type=\"start\" then 1 else 0 end as flag  from Activity ) a)  b  group by machine_id"
                    },
                    {
                        "username": "Krithik77",
                        "content": " I used format function instead of round ,output is correct but it shows wrong why?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": " a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND a1.activity_type = \\'start\\' AND a2.activity_type = \\'end\\'\\n\\n\\n\\nonly u nned to guess this  condition.............."
                    }
                ]
            },
            {
                "id": 2074670,
                "content": [
                    {
                        "username": "chriswebdv",
                        "content": "just a clue since this should be a medium difficulty problem. use CTEs"
                    },
                    {
                        "username": "Sarthak_Sriw",
                        "content": "with ct as \\n(select machine_id ,sum(case when activity_type = \\'end\\' then timestamp else -1 * timestamp end) as s1 ,count(*)/2 as c1 from Activity group by machine_id)\\n\\nselect machine_id,round(s1/c1,3) as processing_time from ct"
                    },
                    {
                        "username": "dineshyuga",
                        "content": "Easy Way Using Case Statement.\\n\\n/* Write your T-SQL query statement below */\\nselect \\nmachine_id,\\nround(sum(endtime - starttime)/count(distinct(process_id)),3) as processing_time\\nfrom\\n(\\nselect \\nmachine_id,\\nprocess_id,\\nmin(Case when activity_type = \\'start\\' then timestamp end) as starttime,\\nmax(Case when activity_type = \\'end\\' then timestamp end) as endtime\\nfrom Activity\\ngroup by machine_id, process_id\\n) as x\\ngroup by machine_id"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "with cte as\\n(\\nselect case activity_type when \\'start\\' then nvl(timestamp,0) end  start_timestamp,\\n       case activity_type when \\'end\\' then nvl(timestamp,0) end  end_timestamp,\\n       --(end_timestamp-start_timestamp) as diff_ts,\\n       machine_id,\\n       process_id,\\n       activity_type\\n       from activity\\n)\\nselect machine_id, round(sum(nvl(end_timestamp,0)-nvl(start_timestamp,0))/count(distinct process_id),3) as processing_time\\nfrom cte\\ngroup by machine_id\\norder by machine_id;"
                    },
                    {
                        "username": "anish_raja",
                        "content": "can anyone please tell me why we can\\'t use timediff() function here?"
                    },
                    {
                        "username": "sfan0037",
                        "content": "SELECT a1.machine_id, ROUND(AVG(a1.timestamp-a2.timestamp),3) AS processing_time\\nFROM Activity AS a1\\nInner join Activity AS a2\\nON a1.machine_id=a2.machine_id AND a1.process_id=a2.process_id AND a1.activity_type=\\'end\\' AND a2.activity_type=\\'start\\'\\nGROUP BY machine_id\\nORDER BY machine_id"
                    },
                    {
                        "username": "sunil93",
                        "content": "Oracle SQL:\n\nselect a.machine_id, round(avg (b.timestamp-a.timestamp),3) as processing_time\nfrom activity a,activity b\nwhere a.machine_id=b.machine_id AND \n    a.process_id=b.process_id AND\n    a.activity_type ='start' AND\n    b.activity_type ='end'\ngroup by  a.machine_id\norder by a.machine_id asc;"
                    },
                    {
                        "username": "1703Adish",
                        "content": "select machine_id, cast(avg(v) as decimal(10,3)) as processing_time from(select *, a.`timestamp`- lead(a.`timestamp`) over (partition by a.machine_id,a.process_id order by a.flag) v from (select machine_id, process_id,timestamp, case when activity_type=\"start\" then 1 else 0 end as flag  from Activity ) a)  b  group by machine_id"
                    },
                    {
                        "username": "Krithik77",
                        "content": " I used format function instead of round ,output is correct but it shows wrong why?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": " a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND a1.activity_type = \\'start\\' AND a2.activity_type = \\'end\\'\\n\\n\\n\\nonly u nned to guess this  condition.............."
                    }
                ]
            },
            {
                "id": 2073852,
                "content": [
                    {
                        "username": "chriswebdv",
                        "content": "just a clue since this should be a medium difficulty problem. use CTEs"
                    },
                    {
                        "username": "Sarthak_Sriw",
                        "content": "with ct as \\n(select machine_id ,sum(case when activity_type = \\'end\\' then timestamp else -1 * timestamp end) as s1 ,count(*)/2 as c1 from Activity group by machine_id)\\n\\nselect machine_id,round(s1/c1,3) as processing_time from ct"
                    },
                    {
                        "username": "dineshyuga",
                        "content": "Easy Way Using Case Statement.\\n\\n/* Write your T-SQL query statement below */\\nselect \\nmachine_id,\\nround(sum(endtime - starttime)/count(distinct(process_id)),3) as processing_time\\nfrom\\n(\\nselect \\nmachine_id,\\nprocess_id,\\nmin(Case when activity_type = \\'start\\' then timestamp end) as starttime,\\nmax(Case when activity_type = \\'end\\' then timestamp end) as endtime\\nfrom Activity\\ngroup by machine_id, process_id\\n) as x\\ngroup by machine_id"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "with cte as\\n(\\nselect case activity_type when \\'start\\' then nvl(timestamp,0) end  start_timestamp,\\n       case activity_type when \\'end\\' then nvl(timestamp,0) end  end_timestamp,\\n       --(end_timestamp-start_timestamp) as diff_ts,\\n       machine_id,\\n       process_id,\\n       activity_type\\n       from activity\\n)\\nselect machine_id, round(sum(nvl(end_timestamp,0)-nvl(start_timestamp,0))/count(distinct process_id),3) as processing_time\\nfrom cte\\ngroup by machine_id\\norder by machine_id;"
                    },
                    {
                        "username": "anish_raja",
                        "content": "can anyone please tell me why we can\\'t use timediff() function here?"
                    },
                    {
                        "username": "sfan0037",
                        "content": "SELECT a1.machine_id, ROUND(AVG(a1.timestamp-a2.timestamp),3) AS processing_time\\nFROM Activity AS a1\\nInner join Activity AS a2\\nON a1.machine_id=a2.machine_id AND a1.process_id=a2.process_id AND a1.activity_type=\\'end\\' AND a2.activity_type=\\'start\\'\\nGROUP BY machine_id\\nORDER BY machine_id"
                    },
                    {
                        "username": "sunil93",
                        "content": "Oracle SQL:\n\nselect a.machine_id, round(avg (b.timestamp-a.timestamp),3) as processing_time\nfrom activity a,activity b\nwhere a.machine_id=b.machine_id AND \n    a.process_id=b.process_id AND\n    a.activity_type ='start' AND\n    b.activity_type ='end'\ngroup by  a.machine_id\norder by a.machine_id asc;"
                    },
                    {
                        "username": "1703Adish",
                        "content": "select machine_id, cast(avg(v) as decimal(10,3)) as processing_time from(select *, a.`timestamp`- lead(a.`timestamp`) over (partition by a.machine_id,a.process_id order by a.flag) v from (select machine_id, process_id,timestamp, case when activity_type=\"start\" then 1 else 0 end as flag  from Activity ) a)  b  group by machine_id"
                    },
                    {
                        "username": "Krithik77",
                        "content": " I used format function instead of round ,output is correct but it shows wrong why?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": " a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND a1.activity_type = \\'start\\' AND a2.activity_type = \\'end\\'\\n\\n\\n\\nonly u nned to guess this  condition.............."
                    }
                ]
            },
            {
                "id": 2072973,
                "content": [
                    {
                        "username": "chriswebdv",
                        "content": "just a clue since this should be a medium difficulty problem. use CTEs"
                    },
                    {
                        "username": "Sarthak_Sriw",
                        "content": "with ct as \\n(select machine_id ,sum(case when activity_type = \\'end\\' then timestamp else -1 * timestamp end) as s1 ,count(*)/2 as c1 from Activity group by machine_id)\\n\\nselect machine_id,round(s1/c1,3) as processing_time from ct"
                    },
                    {
                        "username": "dineshyuga",
                        "content": "Easy Way Using Case Statement.\\n\\n/* Write your T-SQL query statement below */\\nselect \\nmachine_id,\\nround(sum(endtime - starttime)/count(distinct(process_id)),3) as processing_time\\nfrom\\n(\\nselect \\nmachine_id,\\nprocess_id,\\nmin(Case when activity_type = \\'start\\' then timestamp end) as starttime,\\nmax(Case when activity_type = \\'end\\' then timestamp end) as endtime\\nfrom Activity\\ngroup by machine_id, process_id\\n) as x\\ngroup by machine_id"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "with cte as\\n(\\nselect case activity_type when \\'start\\' then nvl(timestamp,0) end  start_timestamp,\\n       case activity_type when \\'end\\' then nvl(timestamp,0) end  end_timestamp,\\n       --(end_timestamp-start_timestamp) as diff_ts,\\n       machine_id,\\n       process_id,\\n       activity_type\\n       from activity\\n)\\nselect machine_id, round(sum(nvl(end_timestamp,0)-nvl(start_timestamp,0))/count(distinct process_id),3) as processing_time\\nfrom cte\\ngroup by machine_id\\norder by machine_id;"
                    },
                    {
                        "username": "anish_raja",
                        "content": "can anyone please tell me why we can\\'t use timediff() function here?"
                    },
                    {
                        "username": "sfan0037",
                        "content": "SELECT a1.machine_id, ROUND(AVG(a1.timestamp-a2.timestamp),3) AS processing_time\\nFROM Activity AS a1\\nInner join Activity AS a2\\nON a1.machine_id=a2.machine_id AND a1.process_id=a2.process_id AND a1.activity_type=\\'end\\' AND a2.activity_type=\\'start\\'\\nGROUP BY machine_id\\nORDER BY machine_id"
                    },
                    {
                        "username": "sunil93",
                        "content": "Oracle SQL:\n\nselect a.machine_id, round(avg (b.timestamp-a.timestamp),3) as processing_time\nfrom activity a,activity b\nwhere a.machine_id=b.machine_id AND \n    a.process_id=b.process_id AND\n    a.activity_type ='start' AND\n    b.activity_type ='end'\ngroup by  a.machine_id\norder by a.machine_id asc;"
                    },
                    {
                        "username": "1703Adish",
                        "content": "select machine_id, cast(avg(v) as decimal(10,3)) as processing_time from(select *, a.`timestamp`- lead(a.`timestamp`) over (partition by a.machine_id,a.process_id order by a.flag) v from (select machine_id, process_id,timestamp, case when activity_type=\"start\" then 1 else 0 end as flag  from Activity ) a)  b  group by machine_id"
                    },
                    {
                        "username": "Krithik77",
                        "content": " I used format function instead of round ,output is correct but it shows wrong why?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": " a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND a1.activity_type = \\'start\\' AND a2.activity_type = \\'end\\'\\n\\n\\n\\nonly u nned to guess this  condition.............."
                    }
                ]
            },
            {
                "id": 2070549,
                "content": [
                    {
                        "username": "chriswebdv",
                        "content": "just a clue since this should be a medium difficulty problem. use CTEs"
                    },
                    {
                        "username": "Sarthak_Sriw",
                        "content": "with ct as \\n(select machine_id ,sum(case when activity_type = \\'end\\' then timestamp else -1 * timestamp end) as s1 ,count(*)/2 as c1 from Activity group by machine_id)\\n\\nselect machine_id,round(s1/c1,3) as processing_time from ct"
                    },
                    {
                        "username": "dineshyuga",
                        "content": "Easy Way Using Case Statement.\\n\\n/* Write your T-SQL query statement below */\\nselect \\nmachine_id,\\nround(sum(endtime - starttime)/count(distinct(process_id)),3) as processing_time\\nfrom\\n(\\nselect \\nmachine_id,\\nprocess_id,\\nmin(Case when activity_type = \\'start\\' then timestamp end) as starttime,\\nmax(Case when activity_type = \\'end\\' then timestamp end) as endtime\\nfrom Activity\\ngroup by machine_id, process_id\\n) as x\\ngroup by machine_id"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "with cte as\\n(\\nselect case activity_type when \\'start\\' then nvl(timestamp,0) end  start_timestamp,\\n       case activity_type when \\'end\\' then nvl(timestamp,0) end  end_timestamp,\\n       --(end_timestamp-start_timestamp) as diff_ts,\\n       machine_id,\\n       process_id,\\n       activity_type\\n       from activity\\n)\\nselect machine_id, round(sum(nvl(end_timestamp,0)-nvl(start_timestamp,0))/count(distinct process_id),3) as processing_time\\nfrom cte\\ngroup by machine_id\\norder by machine_id;"
                    },
                    {
                        "username": "anish_raja",
                        "content": "can anyone please tell me why we can\\'t use timediff() function here?"
                    },
                    {
                        "username": "sfan0037",
                        "content": "SELECT a1.machine_id, ROUND(AVG(a1.timestamp-a2.timestamp),3) AS processing_time\\nFROM Activity AS a1\\nInner join Activity AS a2\\nON a1.machine_id=a2.machine_id AND a1.process_id=a2.process_id AND a1.activity_type=\\'end\\' AND a2.activity_type=\\'start\\'\\nGROUP BY machine_id\\nORDER BY machine_id"
                    },
                    {
                        "username": "sunil93",
                        "content": "Oracle SQL:\n\nselect a.machine_id, round(avg (b.timestamp-a.timestamp),3) as processing_time\nfrom activity a,activity b\nwhere a.machine_id=b.machine_id AND \n    a.process_id=b.process_id AND\n    a.activity_type ='start' AND\n    b.activity_type ='end'\ngroup by  a.machine_id\norder by a.machine_id asc;"
                    },
                    {
                        "username": "1703Adish",
                        "content": "select machine_id, cast(avg(v) as decimal(10,3)) as processing_time from(select *, a.`timestamp`- lead(a.`timestamp`) over (partition by a.machine_id,a.process_id order by a.flag) v from (select machine_id, process_id,timestamp, case when activity_type=\"start\" then 1 else 0 end as flag  from Activity ) a)  b  group by machine_id"
                    },
                    {
                        "username": "Krithik77",
                        "content": " I used format function instead of round ,output is correct but it shows wrong why?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": " a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND a1.activity_type = \\'start\\' AND a2.activity_type = \\'end\\'\\n\\n\\n\\nonly u nned to guess this  condition.............."
                    }
                ]
            },
            {
                "id": 2068211,
                "content": [
                    {
                        "username": "chriswebdv",
                        "content": "just a clue since this should be a medium difficulty problem. use CTEs"
                    },
                    {
                        "username": "Sarthak_Sriw",
                        "content": "with ct as \\n(select machine_id ,sum(case when activity_type = \\'end\\' then timestamp else -1 * timestamp end) as s1 ,count(*)/2 as c1 from Activity group by machine_id)\\n\\nselect machine_id,round(s1/c1,3) as processing_time from ct"
                    },
                    {
                        "username": "dineshyuga",
                        "content": "Easy Way Using Case Statement.\\n\\n/* Write your T-SQL query statement below */\\nselect \\nmachine_id,\\nround(sum(endtime - starttime)/count(distinct(process_id)),3) as processing_time\\nfrom\\n(\\nselect \\nmachine_id,\\nprocess_id,\\nmin(Case when activity_type = \\'start\\' then timestamp end) as starttime,\\nmax(Case when activity_type = \\'end\\' then timestamp end) as endtime\\nfrom Activity\\ngroup by machine_id, process_id\\n) as x\\ngroup by machine_id"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "with cte as\\n(\\nselect case activity_type when \\'start\\' then nvl(timestamp,0) end  start_timestamp,\\n       case activity_type when \\'end\\' then nvl(timestamp,0) end  end_timestamp,\\n       --(end_timestamp-start_timestamp) as diff_ts,\\n       machine_id,\\n       process_id,\\n       activity_type\\n       from activity\\n)\\nselect machine_id, round(sum(nvl(end_timestamp,0)-nvl(start_timestamp,0))/count(distinct process_id),3) as processing_time\\nfrom cte\\ngroup by machine_id\\norder by machine_id;"
                    },
                    {
                        "username": "anish_raja",
                        "content": "can anyone please tell me why we can\\'t use timediff() function here?"
                    },
                    {
                        "username": "sfan0037",
                        "content": "SELECT a1.machine_id, ROUND(AVG(a1.timestamp-a2.timestamp),3) AS processing_time\\nFROM Activity AS a1\\nInner join Activity AS a2\\nON a1.machine_id=a2.machine_id AND a1.process_id=a2.process_id AND a1.activity_type=\\'end\\' AND a2.activity_type=\\'start\\'\\nGROUP BY machine_id\\nORDER BY machine_id"
                    },
                    {
                        "username": "sunil93",
                        "content": "Oracle SQL:\n\nselect a.machine_id, round(avg (b.timestamp-a.timestamp),3) as processing_time\nfrom activity a,activity b\nwhere a.machine_id=b.machine_id AND \n    a.process_id=b.process_id AND\n    a.activity_type ='start' AND\n    b.activity_type ='end'\ngroup by  a.machine_id\norder by a.machine_id asc;"
                    },
                    {
                        "username": "1703Adish",
                        "content": "select machine_id, cast(avg(v) as decimal(10,3)) as processing_time from(select *, a.`timestamp`- lead(a.`timestamp`) over (partition by a.machine_id,a.process_id order by a.flag) v from (select machine_id, process_id,timestamp, case when activity_type=\"start\" then 1 else 0 end as flag  from Activity ) a)  b  group by machine_id"
                    },
                    {
                        "username": "Krithik77",
                        "content": " I used format function instead of round ,output is correct but it shows wrong why?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": " a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND a1.activity_type = \\'start\\' AND a2.activity_type = \\'end\\'\\n\\n\\n\\nonly u nned to guess this  condition.............."
                    }
                ]
            },
            {
                "id": 2058716,
                "content": [
                    {
                        "username": "chriswebdv",
                        "content": "just a clue since this should be a medium difficulty problem. use CTEs"
                    },
                    {
                        "username": "Sarthak_Sriw",
                        "content": "with ct as \\n(select machine_id ,sum(case when activity_type = \\'end\\' then timestamp else -1 * timestamp end) as s1 ,count(*)/2 as c1 from Activity group by machine_id)\\n\\nselect machine_id,round(s1/c1,3) as processing_time from ct"
                    },
                    {
                        "username": "dineshyuga",
                        "content": "Easy Way Using Case Statement.\\n\\n/* Write your T-SQL query statement below */\\nselect \\nmachine_id,\\nround(sum(endtime - starttime)/count(distinct(process_id)),3) as processing_time\\nfrom\\n(\\nselect \\nmachine_id,\\nprocess_id,\\nmin(Case when activity_type = \\'start\\' then timestamp end) as starttime,\\nmax(Case when activity_type = \\'end\\' then timestamp end) as endtime\\nfrom Activity\\ngroup by machine_id, process_id\\n) as x\\ngroup by machine_id"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "with cte as\\n(\\nselect case activity_type when \\'start\\' then nvl(timestamp,0) end  start_timestamp,\\n       case activity_type when \\'end\\' then nvl(timestamp,0) end  end_timestamp,\\n       --(end_timestamp-start_timestamp) as diff_ts,\\n       machine_id,\\n       process_id,\\n       activity_type\\n       from activity\\n)\\nselect machine_id, round(sum(nvl(end_timestamp,0)-nvl(start_timestamp,0))/count(distinct process_id),3) as processing_time\\nfrom cte\\ngroup by machine_id\\norder by machine_id;"
                    },
                    {
                        "username": "anish_raja",
                        "content": "can anyone please tell me why we can\\'t use timediff() function here?"
                    },
                    {
                        "username": "sfan0037",
                        "content": "SELECT a1.machine_id, ROUND(AVG(a1.timestamp-a2.timestamp),3) AS processing_time\\nFROM Activity AS a1\\nInner join Activity AS a2\\nON a1.machine_id=a2.machine_id AND a1.process_id=a2.process_id AND a1.activity_type=\\'end\\' AND a2.activity_type=\\'start\\'\\nGROUP BY machine_id\\nORDER BY machine_id"
                    },
                    {
                        "username": "sunil93",
                        "content": "Oracle SQL:\n\nselect a.machine_id, round(avg (b.timestamp-a.timestamp),3) as processing_time\nfrom activity a,activity b\nwhere a.machine_id=b.machine_id AND \n    a.process_id=b.process_id AND\n    a.activity_type ='start' AND\n    b.activity_type ='end'\ngroup by  a.machine_id\norder by a.machine_id asc;"
                    },
                    {
                        "username": "1703Adish",
                        "content": "select machine_id, cast(avg(v) as decimal(10,3)) as processing_time from(select *, a.`timestamp`- lead(a.`timestamp`) over (partition by a.machine_id,a.process_id order by a.flag) v from (select machine_id, process_id,timestamp, case when activity_type=\"start\" then 1 else 0 end as flag  from Activity ) a)  b  group by machine_id"
                    },
                    {
                        "username": "Krithik77",
                        "content": " I used format function instead of round ,output is correct but it shows wrong why?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": " a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND a1.activity_type = \\'start\\' AND a2.activity_type = \\'end\\'\\n\\n\\n\\nonly u nned to guess this  condition.............."
                    }
                ]
            },
            {
                "id": 2057459,
                "content": [
                    {
                        "username": "chriswebdv",
                        "content": "just a clue since this should be a medium difficulty problem. use CTEs"
                    },
                    {
                        "username": "Sarthak_Sriw",
                        "content": "with ct as \\n(select machine_id ,sum(case when activity_type = \\'end\\' then timestamp else -1 * timestamp end) as s1 ,count(*)/2 as c1 from Activity group by machine_id)\\n\\nselect machine_id,round(s1/c1,3) as processing_time from ct"
                    },
                    {
                        "username": "dineshyuga",
                        "content": "Easy Way Using Case Statement.\\n\\n/* Write your T-SQL query statement below */\\nselect \\nmachine_id,\\nround(sum(endtime - starttime)/count(distinct(process_id)),3) as processing_time\\nfrom\\n(\\nselect \\nmachine_id,\\nprocess_id,\\nmin(Case when activity_type = \\'start\\' then timestamp end) as starttime,\\nmax(Case when activity_type = \\'end\\' then timestamp end) as endtime\\nfrom Activity\\ngroup by machine_id, process_id\\n) as x\\ngroup by machine_id"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "with cte as\\n(\\nselect case activity_type when \\'start\\' then nvl(timestamp,0) end  start_timestamp,\\n       case activity_type when \\'end\\' then nvl(timestamp,0) end  end_timestamp,\\n       --(end_timestamp-start_timestamp) as diff_ts,\\n       machine_id,\\n       process_id,\\n       activity_type\\n       from activity\\n)\\nselect machine_id, round(sum(nvl(end_timestamp,0)-nvl(start_timestamp,0))/count(distinct process_id),3) as processing_time\\nfrom cte\\ngroup by machine_id\\norder by machine_id;"
                    },
                    {
                        "username": "anish_raja",
                        "content": "can anyone please tell me why we can\\'t use timediff() function here?"
                    },
                    {
                        "username": "sfan0037",
                        "content": "SELECT a1.machine_id, ROUND(AVG(a1.timestamp-a2.timestamp),3) AS processing_time\\nFROM Activity AS a1\\nInner join Activity AS a2\\nON a1.machine_id=a2.machine_id AND a1.process_id=a2.process_id AND a1.activity_type=\\'end\\' AND a2.activity_type=\\'start\\'\\nGROUP BY machine_id\\nORDER BY machine_id"
                    },
                    {
                        "username": "sunil93",
                        "content": "Oracle SQL:\n\nselect a.machine_id, round(avg (b.timestamp-a.timestamp),3) as processing_time\nfrom activity a,activity b\nwhere a.machine_id=b.machine_id AND \n    a.process_id=b.process_id AND\n    a.activity_type ='start' AND\n    b.activity_type ='end'\ngroup by  a.machine_id\norder by a.machine_id asc;"
                    },
                    {
                        "username": "1703Adish",
                        "content": "select machine_id, cast(avg(v) as decimal(10,3)) as processing_time from(select *, a.`timestamp`- lead(a.`timestamp`) over (partition by a.machine_id,a.process_id order by a.flag) v from (select machine_id, process_id,timestamp, case when activity_type=\"start\" then 1 else 0 end as flag  from Activity ) a)  b  group by machine_id"
                    },
                    {
                        "username": "Krithik77",
                        "content": " I used format function instead of round ,output is correct but it shows wrong why?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": " a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND a1.activity_type = \\'start\\' AND a2.activity_type = \\'end\\'\\n\\n\\n\\nonly u nned to guess this  condition.............."
                    }
                ]
            },
            {
                "id": 2054046,
                "content": [
                    {
                        "username": "chriswebdv",
                        "content": "just a clue since this should be a medium difficulty problem. use CTEs"
                    },
                    {
                        "username": "Sarthak_Sriw",
                        "content": "with ct as \\n(select machine_id ,sum(case when activity_type = \\'end\\' then timestamp else -1 * timestamp end) as s1 ,count(*)/2 as c1 from Activity group by machine_id)\\n\\nselect machine_id,round(s1/c1,3) as processing_time from ct"
                    },
                    {
                        "username": "dineshyuga",
                        "content": "Easy Way Using Case Statement.\\n\\n/* Write your T-SQL query statement below */\\nselect \\nmachine_id,\\nround(sum(endtime - starttime)/count(distinct(process_id)),3) as processing_time\\nfrom\\n(\\nselect \\nmachine_id,\\nprocess_id,\\nmin(Case when activity_type = \\'start\\' then timestamp end) as starttime,\\nmax(Case when activity_type = \\'end\\' then timestamp end) as endtime\\nfrom Activity\\ngroup by machine_id, process_id\\n) as x\\ngroup by machine_id"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "with cte as\\n(\\nselect case activity_type when \\'start\\' then nvl(timestamp,0) end  start_timestamp,\\n       case activity_type when \\'end\\' then nvl(timestamp,0) end  end_timestamp,\\n       --(end_timestamp-start_timestamp) as diff_ts,\\n       machine_id,\\n       process_id,\\n       activity_type\\n       from activity\\n)\\nselect machine_id, round(sum(nvl(end_timestamp,0)-nvl(start_timestamp,0))/count(distinct process_id),3) as processing_time\\nfrom cte\\ngroup by machine_id\\norder by machine_id;"
                    },
                    {
                        "username": "anish_raja",
                        "content": "can anyone please tell me why we can\\'t use timediff() function here?"
                    },
                    {
                        "username": "sfan0037",
                        "content": "SELECT a1.machine_id, ROUND(AVG(a1.timestamp-a2.timestamp),3) AS processing_time\\nFROM Activity AS a1\\nInner join Activity AS a2\\nON a1.machine_id=a2.machine_id AND a1.process_id=a2.process_id AND a1.activity_type=\\'end\\' AND a2.activity_type=\\'start\\'\\nGROUP BY machine_id\\nORDER BY machine_id"
                    },
                    {
                        "username": "sunil93",
                        "content": "Oracle SQL:\n\nselect a.machine_id, round(avg (b.timestamp-a.timestamp),3) as processing_time\nfrom activity a,activity b\nwhere a.machine_id=b.machine_id AND \n    a.process_id=b.process_id AND\n    a.activity_type ='start' AND\n    b.activity_type ='end'\ngroup by  a.machine_id\norder by a.machine_id asc;"
                    },
                    {
                        "username": "1703Adish",
                        "content": "select machine_id, cast(avg(v) as decimal(10,3)) as processing_time from(select *, a.`timestamp`- lead(a.`timestamp`) over (partition by a.machine_id,a.process_id order by a.flag) v from (select machine_id, process_id,timestamp, case when activity_type=\"start\" then 1 else 0 end as flag  from Activity ) a)  b  group by machine_id"
                    },
                    {
                        "username": "Krithik77",
                        "content": " I used format function instead of round ,output is correct but it shows wrong why?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": " a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND a1.activity_type = \\'start\\' AND a2.activity_type = \\'end\\'\\n\\n\\n\\nonly u nned to guess this  condition.............."
                    }
                ]
            },
            {
                "id": 2044604,
                "content": [
                    {
                        "username": "chriswebdv",
                        "content": "just a clue since this should be a medium difficulty problem. use CTEs"
                    },
                    {
                        "username": "Sarthak_Sriw",
                        "content": "with ct as \\n(select machine_id ,sum(case when activity_type = \\'end\\' then timestamp else -1 * timestamp end) as s1 ,count(*)/2 as c1 from Activity group by machine_id)\\n\\nselect machine_id,round(s1/c1,3) as processing_time from ct"
                    },
                    {
                        "username": "dineshyuga",
                        "content": "Easy Way Using Case Statement.\\n\\n/* Write your T-SQL query statement below */\\nselect \\nmachine_id,\\nround(sum(endtime - starttime)/count(distinct(process_id)),3) as processing_time\\nfrom\\n(\\nselect \\nmachine_id,\\nprocess_id,\\nmin(Case when activity_type = \\'start\\' then timestamp end) as starttime,\\nmax(Case when activity_type = \\'end\\' then timestamp end) as endtime\\nfrom Activity\\ngroup by machine_id, process_id\\n) as x\\ngroup by machine_id"
                    },
                    {
                        "username": "himanshumittal1095",
                        "content": "with cte as\\n(\\nselect case activity_type when \\'start\\' then nvl(timestamp,0) end  start_timestamp,\\n       case activity_type when \\'end\\' then nvl(timestamp,0) end  end_timestamp,\\n       --(end_timestamp-start_timestamp) as diff_ts,\\n       machine_id,\\n       process_id,\\n       activity_type\\n       from activity\\n)\\nselect machine_id, round(sum(nvl(end_timestamp,0)-nvl(start_timestamp,0))/count(distinct process_id),3) as processing_time\\nfrom cte\\ngroup by machine_id\\norder by machine_id;"
                    },
                    {
                        "username": "anish_raja",
                        "content": "can anyone please tell me why we can\\'t use timediff() function here?"
                    },
                    {
                        "username": "sfan0037",
                        "content": "SELECT a1.machine_id, ROUND(AVG(a1.timestamp-a2.timestamp),3) AS processing_time\\nFROM Activity AS a1\\nInner join Activity AS a2\\nON a1.machine_id=a2.machine_id AND a1.process_id=a2.process_id AND a1.activity_type=\\'end\\' AND a2.activity_type=\\'start\\'\\nGROUP BY machine_id\\nORDER BY machine_id"
                    },
                    {
                        "username": "sunil93",
                        "content": "Oracle SQL:\n\nselect a.machine_id, round(avg (b.timestamp-a.timestamp),3) as processing_time\nfrom activity a,activity b\nwhere a.machine_id=b.machine_id AND \n    a.process_id=b.process_id AND\n    a.activity_type ='start' AND\n    b.activity_type ='end'\ngroup by  a.machine_id\norder by a.machine_id asc;"
                    },
                    {
                        "username": "1703Adish",
                        "content": "select machine_id, cast(avg(v) as decimal(10,3)) as processing_time from(select *, a.`timestamp`- lead(a.`timestamp`) over (partition by a.machine_id,a.process_id order by a.flag) v from (select machine_id, process_id,timestamp, case when activity_type=\"start\" then 1 else 0 end as flag  from Activity ) a)  b  group by machine_id"
                    },
                    {
                        "username": "Krithik77",
                        "content": " I used format function instead of round ,output is correct but it shows wrong why?"
                    },
                    {
                        "username": "vkbhagat99",
                        "content": " a1.machine_id = a2.machine_id AND a1.process_id = a2.process_id AND a1.activity_type = \\'start\\' AND a2.activity_type = \\'end\\'\\n\\n\\n\\nonly u nned to guess this  condition.............."
                    }
                ]
            },
            {
                "id": 2044233,
                "content": [
                    {
                        "username": "adityy",
                        "content": "it\\'s definitely not an easy one ;_;"
                    },
                    {
                        "username": "RajaRajendran7777",
                        "content": "with CTE as(\\n  SELECT machine_id,process_id,\\n  ROUND(SUM(CASE WHEN activity_type=\\'end\\' THEN timestamp END),3)-\\n  ROUND(SUM(CASE WHEN activity_type=\\'start\\' THEN timestamp END),3) AS completion_time\\n  FROM Activity\\n  GROUP BY machine_id,process_id\\n)\\nSELECT machine_id,\\nROUND(SUM(completion_time)/COUNT(process_id),3) as processing_time\\nFROM CTE\\nGROUP BY machine_id;"
                    },
                    {
                        "username": "shaar_08",
                        "content": "This is not an easy question it should be categorized as Medium atleast.\\n"
                    },
                    {
                        "username": "pandyagunjan10",
                        "content": "why its not submitable but its acceptable   \n\nselect a1.machine_id, round(avg((a2.timestamp - a1.timestamp)+(a2.timestamp - a1.timestamp))/ count(*),3 ) as processing_time \nfrom Activity a1, Activity a2\nwhere a1.machine_id = a2.machine_id and a1.process_id = a2.process_id and a1.activity_type = 'start' and a2.activity_type = 'end'\ngroup by 1\n"
                    },
                    {
                        "username": "nkey-ops",
                        "content": "Use ROUND() in MySQL to format as a number rather than FORMAT() that formats as a string."
                    },
                    {
                        "username": "VikasC",
                        "content": "with cte as (select machine_id,process_id,\\nround(sum(case when activity_type=\\'end\\' then timestamp end),3)\\n-round(sum(case when activity_type=\\'start\\' then timestamp end),3)\\nas completion_time\\nfrom Activity group by machine_id,process_id)\\nselect machine_id,round(sum(completion_time)/count(machine_id),3) as processing_time  from cte group by machine_id"
                    },
                    {
                        "username": "harshbardhan1326348",
                        "content": "can people keep the discussion tab for discussions only? What\\'s so hard to understand in that? Also, why is the question categorized as easy ;-:"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "I see what you did there xD."
                    },
                    {
                        "username": "Roncartavio99",
                        "content": "SELECT \\n    a.machine_id,\\n    ROUND(AVG(b.timestamp - a.timestamp), 3) AS processing_time\\nFROM \\n    activity a\\nINNER JOIN \\n    activity b ON a.machine_id = b.machine_id\\nWHERE \\n    b.machine_id = a.machine_id AND \\n    b.process_id = a.process_id AND \\n    (a.activity_type = \\'start\\' AND b.activity_type = \\'end\\')\\nGROUP BY \\n    a.machine_id;\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "SQL Script does not create table in MS SQL Server first error comes is \"IF NOT EXISTS\" can someone guide what can be the alternative to this? \\n\\nSecond bigger problem is Failed to execute query. Error: Incorrect syntax near \\'start\\'. due to activity_type ENUM(\\'start\\', \\'end\\'). Can someone tell an MS SQL Server T-SQL alternative to this? \\n\\nI am using Azure SQL database. "
                    },
                    {
                        "username": "user0780E",
                        "content": "SELECT A.machine_id,ROUND(AVG(ABS(A.timestamp-B.timestamp)),3) as processing_time FROM Activity as A JOIN Activity as B WHERE A.machine_id = B.machine_id AND A.process_id = B.process_id AND A.activity_type != B.activity_type GROUP BY machine_id;"
                    }
                ]
            },
            {
                "id": 2032807,
                "content": [
                    {
                        "username": "adityy",
                        "content": "it\\'s definitely not an easy one ;_;"
                    },
                    {
                        "username": "RajaRajendran7777",
                        "content": "with CTE as(\\n  SELECT machine_id,process_id,\\n  ROUND(SUM(CASE WHEN activity_type=\\'end\\' THEN timestamp END),3)-\\n  ROUND(SUM(CASE WHEN activity_type=\\'start\\' THEN timestamp END),3) AS completion_time\\n  FROM Activity\\n  GROUP BY machine_id,process_id\\n)\\nSELECT machine_id,\\nROUND(SUM(completion_time)/COUNT(process_id),3) as processing_time\\nFROM CTE\\nGROUP BY machine_id;"
                    },
                    {
                        "username": "shaar_08",
                        "content": "This is not an easy question it should be categorized as Medium atleast.\\n"
                    },
                    {
                        "username": "pandyagunjan10",
                        "content": "why its not submitable but its acceptable   \n\nselect a1.machine_id, round(avg((a2.timestamp - a1.timestamp)+(a2.timestamp - a1.timestamp))/ count(*),3 ) as processing_time \nfrom Activity a1, Activity a2\nwhere a1.machine_id = a2.machine_id and a1.process_id = a2.process_id and a1.activity_type = 'start' and a2.activity_type = 'end'\ngroup by 1\n"
                    },
                    {
                        "username": "nkey-ops",
                        "content": "Use ROUND() in MySQL to format as a number rather than FORMAT() that formats as a string."
                    },
                    {
                        "username": "VikasC",
                        "content": "with cte as (select machine_id,process_id,\\nround(sum(case when activity_type=\\'end\\' then timestamp end),3)\\n-round(sum(case when activity_type=\\'start\\' then timestamp end),3)\\nas completion_time\\nfrom Activity group by machine_id,process_id)\\nselect machine_id,round(sum(completion_time)/count(machine_id),3) as processing_time  from cte group by machine_id"
                    },
                    {
                        "username": "harshbardhan1326348",
                        "content": "can people keep the discussion tab for discussions only? What\\'s so hard to understand in that? Also, why is the question categorized as easy ;-:"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "I see what you did there xD."
                    },
                    {
                        "username": "Roncartavio99",
                        "content": "SELECT \\n    a.machine_id,\\n    ROUND(AVG(b.timestamp - a.timestamp), 3) AS processing_time\\nFROM \\n    activity a\\nINNER JOIN \\n    activity b ON a.machine_id = b.machine_id\\nWHERE \\n    b.machine_id = a.machine_id AND \\n    b.process_id = a.process_id AND \\n    (a.activity_type = \\'start\\' AND b.activity_type = \\'end\\')\\nGROUP BY \\n    a.machine_id;\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "SQL Script does not create table in MS SQL Server first error comes is \"IF NOT EXISTS\" can someone guide what can be the alternative to this? \\n\\nSecond bigger problem is Failed to execute query. Error: Incorrect syntax near \\'start\\'. due to activity_type ENUM(\\'start\\', \\'end\\'). Can someone tell an MS SQL Server T-SQL alternative to this? \\n\\nI am using Azure SQL database. "
                    },
                    {
                        "username": "user0780E",
                        "content": "SELECT A.machine_id,ROUND(AVG(ABS(A.timestamp-B.timestamp)),3) as processing_time FROM Activity as A JOIN Activity as B WHERE A.machine_id = B.machine_id AND A.process_id = B.process_id AND A.activity_type != B.activity_type GROUP BY machine_id;"
                    }
                ]
            },
            {
                "id": 2030976,
                "content": [
                    {
                        "username": "adityy",
                        "content": "it\\'s definitely not an easy one ;_;"
                    },
                    {
                        "username": "RajaRajendran7777",
                        "content": "with CTE as(\\n  SELECT machine_id,process_id,\\n  ROUND(SUM(CASE WHEN activity_type=\\'end\\' THEN timestamp END),3)-\\n  ROUND(SUM(CASE WHEN activity_type=\\'start\\' THEN timestamp END),3) AS completion_time\\n  FROM Activity\\n  GROUP BY machine_id,process_id\\n)\\nSELECT machine_id,\\nROUND(SUM(completion_time)/COUNT(process_id),3) as processing_time\\nFROM CTE\\nGROUP BY machine_id;"
                    },
                    {
                        "username": "shaar_08",
                        "content": "This is not an easy question it should be categorized as Medium atleast.\\n"
                    },
                    {
                        "username": "pandyagunjan10",
                        "content": "why its not submitable but its acceptable   \n\nselect a1.machine_id, round(avg((a2.timestamp - a1.timestamp)+(a2.timestamp - a1.timestamp))/ count(*),3 ) as processing_time \nfrom Activity a1, Activity a2\nwhere a1.machine_id = a2.machine_id and a1.process_id = a2.process_id and a1.activity_type = 'start' and a2.activity_type = 'end'\ngroup by 1\n"
                    },
                    {
                        "username": "nkey-ops",
                        "content": "Use ROUND() in MySQL to format as a number rather than FORMAT() that formats as a string."
                    },
                    {
                        "username": "VikasC",
                        "content": "with cte as (select machine_id,process_id,\\nround(sum(case when activity_type=\\'end\\' then timestamp end),3)\\n-round(sum(case when activity_type=\\'start\\' then timestamp end),3)\\nas completion_time\\nfrom Activity group by machine_id,process_id)\\nselect machine_id,round(sum(completion_time)/count(machine_id),3) as processing_time  from cte group by machine_id"
                    },
                    {
                        "username": "harshbardhan1326348",
                        "content": "can people keep the discussion tab for discussions only? What\\'s so hard to understand in that? Also, why is the question categorized as easy ;-:"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "I see what you did there xD."
                    },
                    {
                        "username": "Roncartavio99",
                        "content": "SELECT \\n    a.machine_id,\\n    ROUND(AVG(b.timestamp - a.timestamp), 3) AS processing_time\\nFROM \\n    activity a\\nINNER JOIN \\n    activity b ON a.machine_id = b.machine_id\\nWHERE \\n    b.machine_id = a.machine_id AND \\n    b.process_id = a.process_id AND \\n    (a.activity_type = \\'start\\' AND b.activity_type = \\'end\\')\\nGROUP BY \\n    a.machine_id;\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "SQL Script does not create table in MS SQL Server first error comes is \"IF NOT EXISTS\" can someone guide what can be the alternative to this? \\n\\nSecond bigger problem is Failed to execute query. Error: Incorrect syntax near \\'start\\'. due to activity_type ENUM(\\'start\\', \\'end\\'). Can someone tell an MS SQL Server T-SQL alternative to this? \\n\\nI am using Azure SQL database. "
                    },
                    {
                        "username": "user0780E",
                        "content": "SELECT A.machine_id,ROUND(AVG(ABS(A.timestamp-B.timestamp)),3) as processing_time FROM Activity as A JOIN Activity as B WHERE A.machine_id = B.machine_id AND A.process_id = B.process_id AND A.activity_type != B.activity_type GROUP BY machine_id;"
                    }
                ]
            },
            {
                "id": 2030261,
                "content": [
                    {
                        "username": "adityy",
                        "content": "it\\'s definitely not an easy one ;_;"
                    },
                    {
                        "username": "RajaRajendran7777",
                        "content": "with CTE as(\\n  SELECT machine_id,process_id,\\n  ROUND(SUM(CASE WHEN activity_type=\\'end\\' THEN timestamp END),3)-\\n  ROUND(SUM(CASE WHEN activity_type=\\'start\\' THEN timestamp END),3) AS completion_time\\n  FROM Activity\\n  GROUP BY machine_id,process_id\\n)\\nSELECT machine_id,\\nROUND(SUM(completion_time)/COUNT(process_id),3) as processing_time\\nFROM CTE\\nGROUP BY machine_id;"
                    },
                    {
                        "username": "shaar_08",
                        "content": "This is not an easy question it should be categorized as Medium atleast.\\n"
                    },
                    {
                        "username": "pandyagunjan10",
                        "content": "why its not submitable but its acceptable   \n\nselect a1.machine_id, round(avg((a2.timestamp - a1.timestamp)+(a2.timestamp - a1.timestamp))/ count(*),3 ) as processing_time \nfrom Activity a1, Activity a2\nwhere a1.machine_id = a2.machine_id and a1.process_id = a2.process_id and a1.activity_type = 'start' and a2.activity_type = 'end'\ngroup by 1\n"
                    },
                    {
                        "username": "nkey-ops",
                        "content": "Use ROUND() in MySQL to format as a number rather than FORMAT() that formats as a string."
                    },
                    {
                        "username": "VikasC",
                        "content": "with cte as (select machine_id,process_id,\\nround(sum(case when activity_type=\\'end\\' then timestamp end),3)\\n-round(sum(case when activity_type=\\'start\\' then timestamp end),3)\\nas completion_time\\nfrom Activity group by machine_id,process_id)\\nselect machine_id,round(sum(completion_time)/count(machine_id),3) as processing_time  from cte group by machine_id"
                    },
                    {
                        "username": "harshbardhan1326348",
                        "content": "can people keep the discussion tab for discussions only? What\\'s so hard to understand in that? Also, why is the question categorized as easy ;-:"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "I see what you did there xD."
                    },
                    {
                        "username": "Roncartavio99",
                        "content": "SELECT \\n    a.machine_id,\\n    ROUND(AVG(b.timestamp - a.timestamp), 3) AS processing_time\\nFROM \\n    activity a\\nINNER JOIN \\n    activity b ON a.machine_id = b.machine_id\\nWHERE \\n    b.machine_id = a.machine_id AND \\n    b.process_id = a.process_id AND \\n    (a.activity_type = \\'start\\' AND b.activity_type = \\'end\\')\\nGROUP BY \\n    a.machine_id;\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "SQL Script does not create table in MS SQL Server first error comes is \"IF NOT EXISTS\" can someone guide what can be the alternative to this? \\n\\nSecond bigger problem is Failed to execute query. Error: Incorrect syntax near \\'start\\'. due to activity_type ENUM(\\'start\\', \\'end\\'). Can someone tell an MS SQL Server T-SQL alternative to this? \\n\\nI am using Azure SQL database. "
                    },
                    {
                        "username": "user0780E",
                        "content": "SELECT A.machine_id,ROUND(AVG(ABS(A.timestamp-B.timestamp)),3) as processing_time FROM Activity as A JOIN Activity as B WHERE A.machine_id = B.machine_id AND A.process_id = B.process_id AND A.activity_type != B.activity_type GROUP BY machine_id;"
                    }
                ]
            },
            {
                "id": 2027990,
                "content": [
                    {
                        "username": "adityy",
                        "content": "it\\'s definitely not an easy one ;_;"
                    },
                    {
                        "username": "RajaRajendran7777",
                        "content": "with CTE as(\\n  SELECT machine_id,process_id,\\n  ROUND(SUM(CASE WHEN activity_type=\\'end\\' THEN timestamp END),3)-\\n  ROUND(SUM(CASE WHEN activity_type=\\'start\\' THEN timestamp END),3) AS completion_time\\n  FROM Activity\\n  GROUP BY machine_id,process_id\\n)\\nSELECT machine_id,\\nROUND(SUM(completion_time)/COUNT(process_id),3) as processing_time\\nFROM CTE\\nGROUP BY machine_id;"
                    },
                    {
                        "username": "shaar_08",
                        "content": "This is not an easy question it should be categorized as Medium atleast.\\n"
                    },
                    {
                        "username": "pandyagunjan10",
                        "content": "why its not submitable but its acceptable   \n\nselect a1.machine_id, round(avg((a2.timestamp - a1.timestamp)+(a2.timestamp - a1.timestamp))/ count(*),3 ) as processing_time \nfrom Activity a1, Activity a2\nwhere a1.machine_id = a2.machine_id and a1.process_id = a2.process_id and a1.activity_type = 'start' and a2.activity_type = 'end'\ngroup by 1\n"
                    },
                    {
                        "username": "nkey-ops",
                        "content": "Use ROUND() in MySQL to format as a number rather than FORMAT() that formats as a string."
                    },
                    {
                        "username": "VikasC",
                        "content": "with cte as (select machine_id,process_id,\\nround(sum(case when activity_type=\\'end\\' then timestamp end),3)\\n-round(sum(case when activity_type=\\'start\\' then timestamp end),3)\\nas completion_time\\nfrom Activity group by machine_id,process_id)\\nselect machine_id,round(sum(completion_time)/count(machine_id),3) as processing_time  from cte group by machine_id"
                    },
                    {
                        "username": "harshbardhan1326348",
                        "content": "can people keep the discussion tab for discussions only? What\\'s so hard to understand in that? Also, why is the question categorized as easy ;-:"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "I see what you did there xD."
                    },
                    {
                        "username": "Roncartavio99",
                        "content": "SELECT \\n    a.machine_id,\\n    ROUND(AVG(b.timestamp - a.timestamp), 3) AS processing_time\\nFROM \\n    activity a\\nINNER JOIN \\n    activity b ON a.machine_id = b.machine_id\\nWHERE \\n    b.machine_id = a.machine_id AND \\n    b.process_id = a.process_id AND \\n    (a.activity_type = \\'start\\' AND b.activity_type = \\'end\\')\\nGROUP BY \\n    a.machine_id;\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "SQL Script does not create table in MS SQL Server first error comes is \"IF NOT EXISTS\" can someone guide what can be the alternative to this? \\n\\nSecond bigger problem is Failed to execute query. Error: Incorrect syntax near \\'start\\'. due to activity_type ENUM(\\'start\\', \\'end\\'). Can someone tell an MS SQL Server T-SQL alternative to this? \\n\\nI am using Azure SQL database. "
                    },
                    {
                        "username": "user0780E",
                        "content": "SELECT A.machine_id,ROUND(AVG(ABS(A.timestamp-B.timestamp)),3) as processing_time FROM Activity as A JOIN Activity as B WHERE A.machine_id = B.machine_id AND A.process_id = B.process_id AND A.activity_type != B.activity_type GROUP BY machine_id;"
                    }
                ]
            },
            {
                "id": 2012786,
                "content": [
                    {
                        "username": "adityy",
                        "content": "it\\'s definitely not an easy one ;_;"
                    },
                    {
                        "username": "RajaRajendran7777",
                        "content": "with CTE as(\\n  SELECT machine_id,process_id,\\n  ROUND(SUM(CASE WHEN activity_type=\\'end\\' THEN timestamp END),3)-\\n  ROUND(SUM(CASE WHEN activity_type=\\'start\\' THEN timestamp END),3) AS completion_time\\n  FROM Activity\\n  GROUP BY machine_id,process_id\\n)\\nSELECT machine_id,\\nROUND(SUM(completion_time)/COUNT(process_id),3) as processing_time\\nFROM CTE\\nGROUP BY machine_id;"
                    },
                    {
                        "username": "shaar_08",
                        "content": "This is not an easy question it should be categorized as Medium atleast.\\n"
                    },
                    {
                        "username": "pandyagunjan10",
                        "content": "why its not submitable but its acceptable   \n\nselect a1.machine_id, round(avg((a2.timestamp - a1.timestamp)+(a2.timestamp - a1.timestamp))/ count(*),3 ) as processing_time \nfrom Activity a1, Activity a2\nwhere a1.machine_id = a2.machine_id and a1.process_id = a2.process_id and a1.activity_type = 'start' and a2.activity_type = 'end'\ngroup by 1\n"
                    },
                    {
                        "username": "nkey-ops",
                        "content": "Use ROUND() in MySQL to format as a number rather than FORMAT() that formats as a string."
                    },
                    {
                        "username": "VikasC",
                        "content": "with cte as (select machine_id,process_id,\\nround(sum(case when activity_type=\\'end\\' then timestamp end),3)\\n-round(sum(case when activity_type=\\'start\\' then timestamp end),3)\\nas completion_time\\nfrom Activity group by machine_id,process_id)\\nselect machine_id,round(sum(completion_time)/count(machine_id),3) as processing_time  from cte group by machine_id"
                    },
                    {
                        "username": "harshbardhan1326348",
                        "content": "can people keep the discussion tab for discussions only? What\\'s so hard to understand in that? Also, why is the question categorized as easy ;-:"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "I see what you did there xD."
                    },
                    {
                        "username": "Roncartavio99",
                        "content": "SELECT \\n    a.machine_id,\\n    ROUND(AVG(b.timestamp - a.timestamp), 3) AS processing_time\\nFROM \\n    activity a\\nINNER JOIN \\n    activity b ON a.machine_id = b.machine_id\\nWHERE \\n    b.machine_id = a.machine_id AND \\n    b.process_id = a.process_id AND \\n    (a.activity_type = \\'start\\' AND b.activity_type = \\'end\\')\\nGROUP BY \\n    a.machine_id;\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "SQL Script does not create table in MS SQL Server first error comes is \"IF NOT EXISTS\" can someone guide what can be the alternative to this? \\n\\nSecond bigger problem is Failed to execute query. Error: Incorrect syntax near \\'start\\'. due to activity_type ENUM(\\'start\\', \\'end\\'). Can someone tell an MS SQL Server T-SQL alternative to this? \\n\\nI am using Azure SQL database. "
                    },
                    {
                        "username": "user0780E",
                        "content": "SELECT A.machine_id,ROUND(AVG(ABS(A.timestamp-B.timestamp)),3) as processing_time FROM Activity as A JOIN Activity as B WHERE A.machine_id = B.machine_id AND A.process_id = B.process_id AND A.activity_type != B.activity_type GROUP BY machine_id;"
                    }
                ]
            },
            {
                "id": 2000919,
                "content": [
                    {
                        "username": "adityy",
                        "content": "it\\'s definitely not an easy one ;_;"
                    },
                    {
                        "username": "RajaRajendran7777",
                        "content": "with CTE as(\\n  SELECT machine_id,process_id,\\n  ROUND(SUM(CASE WHEN activity_type=\\'end\\' THEN timestamp END),3)-\\n  ROUND(SUM(CASE WHEN activity_type=\\'start\\' THEN timestamp END),3) AS completion_time\\n  FROM Activity\\n  GROUP BY machine_id,process_id\\n)\\nSELECT machine_id,\\nROUND(SUM(completion_time)/COUNT(process_id),3) as processing_time\\nFROM CTE\\nGROUP BY machine_id;"
                    },
                    {
                        "username": "shaar_08",
                        "content": "This is not an easy question it should be categorized as Medium atleast.\\n"
                    },
                    {
                        "username": "pandyagunjan10",
                        "content": "why its not submitable but its acceptable   \n\nselect a1.machine_id, round(avg((a2.timestamp - a1.timestamp)+(a2.timestamp - a1.timestamp))/ count(*),3 ) as processing_time \nfrom Activity a1, Activity a2\nwhere a1.machine_id = a2.machine_id and a1.process_id = a2.process_id and a1.activity_type = 'start' and a2.activity_type = 'end'\ngroup by 1\n"
                    },
                    {
                        "username": "nkey-ops",
                        "content": "Use ROUND() in MySQL to format as a number rather than FORMAT() that formats as a string."
                    },
                    {
                        "username": "VikasC",
                        "content": "with cte as (select machine_id,process_id,\\nround(sum(case when activity_type=\\'end\\' then timestamp end),3)\\n-round(sum(case when activity_type=\\'start\\' then timestamp end),3)\\nas completion_time\\nfrom Activity group by machine_id,process_id)\\nselect machine_id,round(sum(completion_time)/count(machine_id),3) as processing_time  from cte group by machine_id"
                    },
                    {
                        "username": "harshbardhan1326348",
                        "content": "can people keep the discussion tab for discussions only? What\\'s so hard to understand in that? Also, why is the question categorized as easy ;-:"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "I see what you did there xD."
                    },
                    {
                        "username": "Roncartavio99",
                        "content": "SELECT \\n    a.machine_id,\\n    ROUND(AVG(b.timestamp - a.timestamp), 3) AS processing_time\\nFROM \\n    activity a\\nINNER JOIN \\n    activity b ON a.machine_id = b.machine_id\\nWHERE \\n    b.machine_id = a.machine_id AND \\n    b.process_id = a.process_id AND \\n    (a.activity_type = \\'start\\' AND b.activity_type = \\'end\\')\\nGROUP BY \\n    a.machine_id;\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "SQL Script does not create table in MS SQL Server first error comes is \"IF NOT EXISTS\" can someone guide what can be the alternative to this? \\n\\nSecond bigger problem is Failed to execute query. Error: Incorrect syntax near \\'start\\'. due to activity_type ENUM(\\'start\\', \\'end\\'). Can someone tell an MS SQL Server T-SQL alternative to this? \\n\\nI am using Azure SQL database. "
                    },
                    {
                        "username": "user0780E",
                        "content": "SELECT A.machine_id,ROUND(AVG(ABS(A.timestamp-B.timestamp)),3) as processing_time FROM Activity as A JOIN Activity as B WHERE A.machine_id = B.machine_id AND A.process_id = B.process_id AND A.activity_type != B.activity_type GROUP BY machine_id;"
                    }
                ]
            },
            {
                "id": 2000125,
                "content": [
                    {
                        "username": "adityy",
                        "content": "it\\'s definitely not an easy one ;_;"
                    },
                    {
                        "username": "RajaRajendran7777",
                        "content": "with CTE as(\\n  SELECT machine_id,process_id,\\n  ROUND(SUM(CASE WHEN activity_type=\\'end\\' THEN timestamp END),3)-\\n  ROUND(SUM(CASE WHEN activity_type=\\'start\\' THEN timestamp END),3) AS completion_time\\n  FROM Activity\\n  GROUP BY machine_id,process_id\\n)\\nSELECT machine_id,\\nROUND(SUM(completion_time)/COUNT(process_id),3) as processing_time\\nFROM CTE\\nGROUP BY machine_id;"
                    },
                    {
                        "username": "shaar_08",
                        "content": "This is not an easy question it should be categorized as Medium atleast.\\n"
                    },
                    {
                        "username": "pandyagunjan10",
                        "content": "why its not submitable but its acceptable   \n\nselect a1.machine_id, round(avg((a2.timestamp - a1.timestamp)+(a2.timestamp - a1.timestamp))/ count(*),3 ) as processing_time \nfrom Activity a1, Activity a2\nwhere a1.machine_id = a2.machine_id and a1.process_id = a2.process_id and a1.activity_type = 'start' and a2.activity_type = 'end'\ngroup by 1\n"
                    },
                    {
                        "username": "nkey-ops",
                        "content": "Use ROUND() in MySQL to format as a number rather than FORMAT() that formats as a string."
                    },
                    {
                        "username": "VikasC",
                        "content": "with cte as (select machine_id,process_id,\\nround(sum(case when activity_type=\\'end\\' then timestamp end),3)\\n-round(sum(case when activity_type=\\'start\\' then timestamp end),3)\\nas completion_time\\nfrom Activity group by machine_id,process_id)\\nselect machine_id,round(sum(completion_time)/count(machine_id),3) as processing_time  from cte group by machine_id"
                    },
                    {
                        "username": "harshbardhan1326348",
                        "content": "can people keep the discussion tab for discussions only? What\\'s so hard to understand in that? Also, why is the question categorized as easy ;-:"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "I see what you did there xD."
                    },
                    {
                        "username": "Roncartavio99",
                        "content": "SELECT \\n    a.machine_id,\\n    ROUND(AVG(b.timestamp - a.timestamp), 3) AS processing_time\\nFROM \\n    activity a\\nINNER JOIN \\n    activity b ON a.machine_id = b.machine_id\\nWHERE \\n    b.machine_id = a.machine_id AND \\n    b.process_id = a.process_id AND \\n    (a.activity_type = \\'start\\' AND b.activity_type = \\'end\\')\\nGROUP BY \\n    a.machine_id;\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "SQL Script does not create table in MS SQL Server first error comes is \"IF NOT EXISTS\" can someone guide what can be the alternative to this? \\n\\nSecond bigger problem is Failed to execute query. Error: Incorrect syntax near \\'start\\'. due to activity_type ENUM(\\'start\\', \\'end\\'). Can someone tell an MS SQL Server T-SQL alternative to this? \\n\\nI am using Azure SQL database. "
                    },
                    {
                        "username": "user0780E",
                        "content": "SELECT A.machine_id,ROUND(AVG(ABS(A.timestamp-B.timestamp)),3) as processing_time FROM Activity as A JOIN Activity as B WHERE A.machine_id = B.machine_id AND A.process_id = B.process_id AND A.activity_type != B.activity_type GROUP BY machine_id;"
                    }
                ]
            },
            {
                "id": 1993887,
                "content": [
                    {
                        "username": "adityy",
                        "content": "it\\'s definitely not an easy one ;_;"
                    },
                    {
                        "username": "RajaRajendran7777",
                        "content": "with CTE as(\\n  SELECT machine_id,process_id,\\n  ROUND(SUM(CASE WHEN activity_type=\\'end\\' THEN timestamp END),3)-\\n  ROUND(SUM(CASE WHEN activity_type=\\'start\\' THEN timestamp END),3) AS completion_time\\n  FROM Activity\\n  GROUP BY machine_id,process_id\\n)\\nSELECT machine_id,\\nROUND(SUM(completion_time)/COUNT(process_id),3) as processing_time\\nFROM CTE\\nGROUP BY machine_id;"
                    },
                    {
                        "username": "shaar_08",
                        "content": "This is not an easy question it should be categorized as Medium atleast.\\n"
                    },
                    {
                        "username": "pandyagunjan10",
                        "content": "why its not submitable but its acceptable   \n\nselect a1.machine_id, round(avg((a2.timestamp - a1.timestamp)+(a2.timestamp - a1.timestamp))/ count(*),3 ) as processing_time \nfrom Activity a1, Activity a2\nwhere a1.machine_id = a2.machine_id and a1.process_id = a2.process_id and a1.activity_type = 'start' and a2.activity_type = 'end'\ngroup by 1\n"
                    },
                    {
                        "username": "nkey-ops",
                        "content": "Use ROUND() in MySQL to format as a number rather than FORMAT() that formats as a string."
                    },
                    {
                        "username": "VikasC",
                        "content": "with cte as (select machine_id,process_id,\\nround(sum(case when activity_type=\\'end\\' then timestamp end),3)\\n-round(sum(case when activity_type=\\'start\\' then timestamp end),3)\\nas completion_time\\nfrom Activity group by machine_id,process_id)\\nselect machine_id,round(sum(completion_time)/count(machine_id),3) as processing_time  from cte group by machine_id"
                    },
                    {
                        "username": "harshbardhan1326348",
                        "content": "can people keep the discussion tab for discussions only? What\\'s so hard to understand in that? Also, why is the question categorized as easy ;-:"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "I see what you did there xD."
                    },
                    {
                        "username": "Roncartavio99",
                        "content": "SELECT \\n    a.machine_id,\\n    ROUND(AVG(b.timestamp - a.timestamp), 3) AS processing_time\\nFROM \\n    activity a\\nINNER JOIN \\n    activity b ON a.machine_id = b.machine_id\\nWHERE \\n    b.machine_id = a.machine_id AND \\n    b.process_id = a.process_id AND \\n    (a.activity_type = \\'start\\' AND b.activity_type = \\'end\\')\\nGROUP BY \\n    a.machine_id;\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "SQL Script does not create table in MS SQL Server first error comes is \"IF NOT EXISTS\" can someone guide what can be the alternative to this? \\n\\nSecond bigger problem is Failed to execute query. Error: Incorrect syntax near \\'start\\'. due to activity_type ENUM(\\'start\\', \\'end\\'). Can someone tell an MS SQL Server T-SQL alternative to this? \\n\\nI am using Azure SQL database. "
                    },
                    {
                        "username": "user0780E",
                        "content": "SELECT A.machine_id,ROUND(AVG(ABS(A.timestamp-B.timestamp)),3) as processing_time FROM Activity as A JOIN Activity as B WHERE A.machine_id = B.machine_id AND A.process_id = B.process_id AND A.activity_type != B.activity_type GROUP BY machine_id;"
                    }
                ]
            },
            {
                "id": 1989327,
                "content": [
                    {
                        "username": "adityy",
                        "content": "it\\'s definitely not an easy one ;_;"
                    },
                    {
                        "username": "RajaRajendran7777",
                        "content": "with CTE as(\\n  SELECT machine_id,process_id,\\n  ROUND(SUM(CASE WHEN activity_type=\\'end\\' THEN timestamp END),3)-\\n  ROUND(SUM(CASE WHEN activity_type=\\'start\\' THEN timestamp END),3) AS completion_time\\n  FROM Activity\\n  GROUP BY machine_id,process_id\\n)\\nSELECT machine_id,\\nROUND(SUM(completion_time)/COUNT(process_id),3) as processing_time\\nFROM CTE\\nGROUP BY machine_id;"
                    },
                    {
                        "username": "shaar_08",
                        "content": "This is not an easy question it should be categorized as Medium atleast.\\n"
                    },
                    {
                        "username": "pandyagunjan10",
                        "content": "why its not submitable but its acceptable   \n\nselect a1.machine_id, round(avg((a2.timestamp - a1.timestamp)+(a2.timestamp - a1.timestamp))/ count(*),3 ) as processing_time \nfrom Activity a1, Activity a2\nwhere a1.machine_id = a2.machine_id and a1.process_id = a2.process_id and a1.activity_type = 'start' and a2.activity_type = 'end'\ngroup by 1\n"
                    },
                    {
                        "username": "nkey-ops",
                        "content": "Use ROUND() in MySQL to format as a number rather than FORMAT() that formats as a string."
                    },
                    {
                        "username": "VikasC",
                        "content": "with cte as (select machine_id,process_id,\\nround(sum(case when activity_type=\\'end\\' then timestamp end),3)\\n-round(sum(case when activity_type=\\'start\\' then timestamp end),3)\\nas completion_time\\nfrom Activity group by machine_id,process_id)\\nselect machine_id,round(sum(completion_time)/count(machine_id),3) as processing_time  from cte group by machine_id"
                    },
                    {
                        "username": "harshbardhan1326348",
                        "content": "can people keep the discussion tab for discussions only? What\\'s so hard to understand in that? Also, why is the question categorized as easy ;-:"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "I see what you did there xD."
                    },
                    {
                        "username": "Roncartavio99",
                        "content": "SELECT \\n    a.machine_id,\\n    ROUND(AVG(b.timestamp - a.timestamp), 3) AS processing_time\\nFROM \\n    activity a\\nINNER JOIN \\n    activity b ON a.machine_id = b.machine_id\\nWHERE \\n    b.machine_id = a.machine_id AND \\n    b.process_id = a.process_id AND \\n    (a.activity_type = \\'start\\' AND b.activity_type = \\'end\\')\\nGROUP BY \\n    a.machine_id;\\n"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "SQL Script does not create table in MS SQL Server first error comes is \"IF NOT EXISTS\" can someone guide what can be the alternative to this? \\n\\nSecond bigger problem is Failed to execute query. Error: Incorrect syntax near \\'start\\'. due to activity_type ENUM(\\'start\\', \\'end\\'). Can someone tell an MS SQL Server T-SQL alternative to this? \\n\\nI am using Azure SQL database. "
                    },
                    {
                        "username": "user0780E",
                        "content": "SELECT A.machine_id,ROUND(AVG(ABS(A.timestamp-B.timestamp)),3) as processing_time FROM Activity as A JOIN Activity as B WHERE A.machine_id = B.machine_id AND A.process_id = B.process_id AND A.activity_type != B.activity_type GROUP BY machine_id;"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Number of Work Sessions to Finish the Tasks",
        "question_content": "<p>There are <code>n</code> tasks assigned to you. The task times are represented as an integer array <code>tasks</code> of length <code>n</code>, where the <code>i<sup>th</sup></code> task takes <code>tasks[i]</code> hours to finish. A <strong>work session</strong> is when you work for <strong>at most</strong> <code>sessionTime</code> consecutive hours and then take a break.</p>\n\n<p>You should finish the given tasks in a way that satisfies the following conditions:</p>\n\n<ul>\n\t<li>If you start a task in a work session, you must complete it in the <strong>same</strong> work session.</li>\n\t<li>You can start a new task <strong>immediately</strong> after finishing the previous one.</li>\n\t<li>You may complete the tasks in <strong>any order</strong>.</li>\n</ul>\n\n<p>Given <code>tasks</code> and <code>sessionTime</code>, return <em>the <strong>minimum</strong> number of <strong>work sessions</strong> needed to finish all the tasks following the conditions above.</em></p>\n\n<p>The tests are generated such that <code>sessionTime</code> is <strong>greater</strong> than or <strong>equal</strong> to the <strong>maximum</strong> element in <code>tasks[i]</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> tasks = [1,2,3], sessionTime = 3\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> You can finish the tasks in two work sessions.\n- First work session: finish the first and the second tasks in 1 + 2 = 3 hours.\n- Second work session: finish the third task in 3 hours.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> tasks = [3,1,3,1,1], sessionTime = 8\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> You can finish the tasks in two work sessions.\n- First work session: finish all the tasks except the last one in 3 + 1 + 3 + 1 = 8 hours.\n- Second work session: finish the last task in 1 hour.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> tasks = [1,2,3,4,5], sessionTime = 15\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> You can finish all the tasks in one work session.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == tasks.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 14</code></li>\n\t<li><code>1 &lt;= tasks[i] &lt;= 10</code></li>\n\t<li><code>max(tasks[i]) &lt;= sessionTime &lt;= 15</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1436811,
                "title": "c-java-python-from-straightforward-to-optimized-bitmask-dp-o-2-n-n-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Straightforward Bitmask DP**\\n- Let `dp(mask, remainTime)` is the minimum of work sessions needed to finish all the tasks represent by `mask` (where `i`th bit = 1 means tasks[i] need to proceed) with the `remainTime` we have for the current session.\\n- Then `dp((1 << n) - 1, 0)` is our result\\n\\t- We use `mask` as `111...1111`, represent we need to process all `n` tasks.\\n\\t- We pass `remainTime = 0`, which means there is no remain time for the current session; ask them to create a new session.\\n\\n<iframe src=\"https://leetcode.com/playground/CQvMZRS9/shared\" frameBorder=\"0\" width=\"100%\" height=\"530\"></iframe>\\n\\nComplexity:\\n- Time: `O(2^n * sessionTime * n)`, where `n <= 14` is length of tasks, `sessionTime <= 15`.\\n   Explain: There is total `2^n * sessionTime` dp states, they are `dp[0][0], dp[1][0]..., dp[2^n-1][remainTime]`. Each dp state needs an inner loop `O(n)` to calculate the result. \\n- Space: `O(2^n * sessionTime)`\\n\\n---\\n\\n**\\u2714\\uFE0F Solution 2: Bitmask DP - Optimized (Independence with SessionTime)**\\n- Let `dp(mask)` return `(the minimum of work sessions needed, remainTime)` to finish all the tasks represent by `mask` (where `i`th bit = 1 means tasks[i] need to proceed).\\n- Then `dp((1 << n) - 1)[0]` is our result\\n\\t- We use `mask` as `111...1111`, represent we need to process all `n` tasks.\\n\\n<iframe src=\"https://leetcode.com/playground/MkXWVVw2/shared\" frameBorder=\"0\" width=\"100%\" height=\"640\"></iframe>\\n\\nComplexity:\\n- Time: `O(2^n * n)`, where `n <= 14` is length of tasks.\\n   Explain: There is total `2^n` dp states, they are `dp[0], dp[1]..., dp[2^n-1]`. Each dp state needs an inner loop `O(n)` to calculate the result.\\n- Space: `O(2^n)`\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.",
                "solutionTags": [],
                "code": "**\\u2714\\uFE0F Solution 1: Straightforward Bitmask DP**\\n- Let `dp(mask, remainTime)` is the minimum of work sessions needed to finish all the tasks represent by `mask` (where `i`th bit = 1 means tasks[i] need to proceed) with the `remainTime` we have for the current session.\\n- Then `dp((1 << n) - 1, 0)` is our result\\n\\t- We use `mask` as `111...1111`, represent we need to process all `n` tasks.\\n\\t- We pass `remainTime = 0`, which means there is no remain time for the current session; ask them to create a new session.\\n\\n<iframe src=\"https://leetcode.com/playground/CQvMZRS9/shared\" frameBorder=\"0\" width=\"100%\" height=\"530\"></iframe>\\n\\nComplexity:\\n- Time: `O(2^n * sessionTime * n)`, where `n <= 14` is length of tasks, `sessionTime <= 15`.\\n   Explain: There is total `2^n * sessionTime` dp states, they are `dp[0][0], dp[1][0]..., dp[2^n-1][remainTime]`. Each dp state needs an inner loop `O(n)` to calculate the result. \\n- Space: `O(2^n * sessionTime)`\\n\\n---\\n\\n**\\u2714\\uFE0F Solution 2: Bitmask DP - Optimized (Independence with SessionTime)**\\n- Let `dp(mask)` return `(the minimum of work sessions needed, remainTime)` to finish all the tasks represent by `mask` (where `i`th bit = 1 means tasks[i] need to proceed).\\n- Then `dp((1 << n) - 1)[0]` is our result\\n\\t- We use `mask` as `111...1111`, represent we need to process all `n` tasks.\\n\\n<iframe src=\"https://leetcode.com/playground/MkXWVVw2/shared\" frameBorder=\"0\" width=\"100%\" height=\"640\"></iframe>\\n\\nComplexity:\\n- Time: `O(2^n * n)`, where `n <= 14` is length of tasks.\\n   Explain: There is total `2^n` dp states, they are `dp[0], dp[1]..., dp[2^n-1]`. Each dp state needs an inner loop `O(n)` to calculate the result.\\n- Space: `O(2^n)`\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.",
                "codeTag": "Unknown"
            },
            {
                "id": 1431836,
                "title": "c-solution-recursion-memoization",
                "content": "Wrong Greedy Approach:\\n\\n- Sort the `tasks` array and keep adding the task to the current session until the sum becomes equal to or more than the `sessionTime`.\\n- This approach fails on test cases like `tasks` = {3, 4, 7, 8, 10} `sessionTime` = 12\\n\\n**Solution:**\\n\\nWe have created a vector named `sessions`. The length of which denotes the number of work sessions we currently have, and the value at `ith` index `sessions[i]` denotes the number of work hours we have completed in the `ith` session. Now in such scenerio\\n\\n- Each task in the `tasks` array has two options:\\n  1. Get included in one of the session in `sessions`\\n  2. Get included in a new session by adding one to the `sessions`.\\n\\nThe minimum of the two above choices will be the answer. The below code shows the Rercursive solution.\\n\\n**Recursion (TLE):**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> sessions;\\n\\n    int solve(vector<int>& tasks, int n, int sessionTime, int pos) {\\n        if (pos >= n )\\n            return 0;\\n\\n        // adding the current task to a new session\\n        sessions.push_back(tasks[pos]);\\n        int ans = 1 + solve(tasks, n, sessionTime, pos + 1);\\n        sessions.pop_back();\\n        \\n        // trying to add it to the previous active session\\n        for (int i = 0; i < sessions.size();i++) {\\n            if (sessions[i] + tasks[pos] <= sessionTime) {\\n                sessions[i] += tasks[pos];\\n                ans = min(ans, solve(tasks, n, sessionTime, pos + 1));\\n                sessions[i] -= tasks[pos];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        int n = tasks.size();\\n        return solve(tasks, n, sessionTime, 0);\\n    }\\n};\\n```\\n\\n\\nIn order to memoize the solution, we use a unordered map from String to int `dp`. The two states which we need to memoize are the `pos` and the `sessions`. We encode both these state by concating them as string with `$` as a delimeter.\\n\\nNote: We first sort the `sessions` to reduce the number of repeated states.\\n\\n**Recursion + Memoization Code (Accepted):**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> sessions;\\n    unordered_map<string , int> dp;\\n    \\n    string encodeState(int pos, vector<int>& sessions) {\\n        vector<int> copy = sessions;\\n        sort(copy.begin(), copy.end());\\n        \\n        string key = to_string(pos) + \"$\";\\n        for (int i = 0; i < copy.size(); i++)\\n            key += to_string(copy[i]) + \"$\";\\n        \\n        return key;\\n    }\\n    \\n    int solve(vector<int>& tasks, int n, int sessionTime, int pos) {\\n        if (pos >= n )\\n            return 0;\\n        \\n        string key = encodeState(pos, sessions);\\n        \\n        if (dp.find(key) != dp.end())\\n            return dp[key];\\n        \\n        sessions.push_back(tasks[pos]);\\n        int ans = 1 + solve(tasks, n, sessionTime, pos + 1);\\n        sessions.pop_back();\\n        \\n        for (int i = 0; i < sessions.size();i++) {\\n            if (sessions[i] + tasks[pos] <= sessionTime) {\\n                sessions[i] += tasks[pos];\\n                ans = min(ans, solve(tasks, n, sessionTime, pos + 1));\\n                sessions[i] -= tasks[pos];\\n            }\\n        }\\n        \\n        return dp[key] = ans;\\n    }\\n    \\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        int n = tasks.size();\\n        return solve(tasks, n, sessionTime, 0);\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sessions;\\n\\n    int solve(vector<int>& tasks, int n, int sessionTime, int pos) {\\n        if (pos >= n )\\n            return 0;\\n\\n        // adding the current task to a new session\\n        sessions.push_back(tasks[pos]);\\n        int ans = 1 + solve(tasks, n, sessionTime, pos + 1);\\n        sessions.pop_back();\\n        \\n        // trying to add it to the previous active session\\n        for (int i = 0; i < sessions.size();i++) {\\n            if (sessions[i] + tasks[pos] <= sessionTime) {\\n                sessions[i] += tasks[pos];\\n                ans = min(ans, solve(tasks, n, sessionTime, pos + 1));\\n                sessions[i] -= tasks[pos];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        int n = tasks.size();\\n        return solve(tasks, n, sessionTime, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> sessions;\\n    unordered_map<string , int> dp;\\n    \\n    string encodeState(int pos, vector<int>& sessions) {\\n        vector<int> copy = sessions;\\n        sort(copy.begin(), copy.end());\\n        \\n        string key = to_string(pos) + \"$\";\\n        for (int i = 0; i < copy.size(); i++)\\n            key += to_string(copy[i]) + \"$\";\\n        \\n        return key;\\n    }\\n    \\n    int solve(vector<int>& tasks, int n, int sessionTime, int pos) {\\n        if (pos >= n )\\n            return 0;\\n        \\n        string key = encodeState(pos, sessions);\\n        \\n        if (dp.find(key) != dp.end())\\n            return dp[key];\\n        \\n        sessions.push_back(tasks[pos]);\\n        int ans = 1 + solve(tasks, n, sessionTime, pos + 1);\\n        sessions.pop_back();\\n        \\n        for (int i = 0; i < sessions.size();i++) {\\n            if (sessions[i] + tasks[pos] <= sessionTime) {\\n                sessions[i] += tasks[pos];\\n                ans = min(ans, solve(tasks, n, sessionTime, pos + 1));\\n                sessions[i] -= tasks[pos];\\n            }\\n        }\\n        \\n        return dp[key] = ans;\\n    }\\n    \\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        int n = tasks.size();\\n        return solve(tasks, n, sessionTime, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1432155,
                "title": "easier-than-top-voted-ones-legitclickbait-c",
                "content": "**Algorithm**\\n1. We use 2 things -> ```mask``` to denote which elements are processed. If ```ith``` bit is 1 means ```ith``` element is processed. -> ```currentTime``` we start with 0 as current time.\\n2. At each call go through all the unprocessed elements only.\\n3. We can choose to include the ith unprocessed element in current session like this -> ```help(a, mask | (1<<i), currTime + a[i])```\\n4.  Or choose to include it in next session like this -> ```1 + help(a, mask | (1<<i), a[i])```\\n5.  Take minimum of step 3 and 4 across all unprocessed elements like this -> ```ans = min({ans, includeInCurrentSession, includeInNextSession})``` .\\n2. If ```currentTime``` becomes more than targetTime it is invalid state.\\n3. If all elements are processed then its the end of our algorithm.\\n\\n***Note***: \\nWhen we do ```mask | (1<<i)``` we set the ith bit in mask to indicate element at ith position is processed.\\nWhen we do ```mask & (1<<i)``` we are checking if ith bit in mask is set or not.\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    int n, time, allOnes;\\n    int ans;\\n    int dp[1<<15][16];\\n    int minSessions(vector<int>& a, int t) {\\n        time = t;\\n        n = a.size();\\n        allOnes = (1<<n)-1;\\n        memset(dp, -1, sizeof dp);\\n        ans = help(a, 0, 0);\\n        return ans;\\n    }\\n    \\n    int help(vector<int> &a, int mask, int currTime){\\n        if(currTime > time) return INT_MAX;\\n        if(mask == allOnes) return 1;\\n        if(dp[mask][currTime] != -1) return dp[mask][currTime];\\n        int ans = INT_MAX;\\n        for(int i = 0 ; i < n ; i++){\\n            if( (mask & (1<<i)) == 0){\\n                int includeInCurrentSession = help(a, mask | (1<<i), currTime + a[i]);\\n                int includeInNextSession = 1 + help(a, mask | (1<<i), a[i]);\\n                ans = min({ans, includeInCurrentSession, includeInNextSession});\\n            }\\n        }\\n        return dp[mask][currTime] = ans;\\n    }\\n};\\n```\\n**Time Complexity**: ```O(2^N * sessionTime * N)``` Here N is length of array ```a i.e tasks``` and sessionTime  is ```time```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Bit Manipulation"
                ],
                "code": "```mask```\n```ith```\n```ith```\n```currentTime```\n```help(a, mask | (1<<i), currTime + a[i])```\n```1 + help(a, mask | (1<<i), a[i])```\n```ans = min({ans, includeInCurrentSession, includeInNextSession})```\n```currentTime```\n```mask | (1<<i)```\n```mask & (1<<i)```\n```\\nclass Solution {\\npublic:\\n    int n, time, allOnes;\\n    int ans;\\n    int dp[1<<15][16];\\n    int minSessions(vector<int>& a, int t) {\\n        time = t;\\n        n = a.size();\\n        allOnes = (1<<n)-1;\\n        memset(dp, -1, sizeof dp);\\n        ans = help(a, 0, 0);\\n        return ans;\\n    }\\n    \\n    int help(vector<int> &a, int mask, int currTime){\\n        if(currTime > time) return INT_MAX;\\n        if(mask == allOnes) return 1;\\n        if(dp[mask][currTime] != -1) return dp[mask][currTime];\\n        int ans = INT_MAX;\\n        for(int i = 0 ; i < n ; i++){\\n            if( (mask & (1<<i)) == 0){\\n                int includeInCurrentSession = help(a, mask | (1<<i), currTime + a[i]);\\n                int includeInNextSession = 1 + help(a, mask | (1<<i), a[i]);\\n                ans = min({ans, includeInCurrentSession, includeInNextSession});\\n            }\\n        }\\n        return dp[mask][currTime] = ans;\\n    }\\n};\\n```\n```O(2^N * sessionTime * N)```\n```a i.e tasks```\n```time```",
                "codeTag": "Java"
            },
            {
                "id": 1431829,
                "title": "python-dynamic-programming-on-subsets-explained",
                "content": "You can see that in this problem `n <= 14`, so we need to apply some kind of bruteforce algorithm. If we try just `n!` options, it will be too big, so the idea is to use dynamic programming on subsets. Let `dp(mask)`, where `mask` is bitmask of already used jobs be the tuple of numbers: first one is number of sessions we took so far and the second one is how much time we spend for the last session.\\n\\nTo calculate `dp(mask)`, let us say `dp(10110)`, we need to look at all places we have `0`, that is `1-th, 2-th, 4-th` and look at positions `dp(00110), dp(10010), dp(10100)`. We calculate `full = last + tasks[j] > T` is indicator that last session is full and we need to start new one. So, total number of sessions we have is `pieces + full` and what we have in the last session is `tasks[j]` if session is full: we start new one and `tasks[j] + last` if it is not full.\\n\\n#### Complexity\\nTime complexity is `O(2^n * n)`, because we have `2^n` masks and `O(n)` transitions from given mask. Space complexity is `O(2^n)`.\\n\\n```python\\nclass Solution:\\n    def minSessions(self, tasks, T):\\n        n = len(tasks)\\n\\n        @lru_cache(None)\\n        def dp(mask):\\n            if mask == 0: return (1, 0)\\n            ans = (float(\"inf\"), float(\"inf\"))\\n            for j in range(n):\\n                if mask & (1<<j):\\n                    pieces, last = dp(mask - (1 << j))\\n                    full = (last + tasks[j] > T)\\n                    ans = min(ans, (pieces + full, tasks[j] + (1-full)*last))  \\n            return ans\\n\\n        return dp((1<<n) - 1)[0]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```python\\nclass Solution:\\n    def minSessions(self, tasks, T):\\n        n = len(tasks)\\n\\n        @lru_cache(None)\\n        def dp(mask):\\n            if mask == 0: return (1, 0)\\n            ans = (float(\"inf\"), float(\"inf\"))\\n            for j in range(n):\\n                if mask & (1<<j):\\n                    pieces, last = dp(mask - (1 << j))\\n                    full = (last + tasks[j] > T)\\n                    ans = min(ans, (pieces + full, tasks[j] + (1-full)*last))  \\n            return ans\\n\\n        return dp((1<<n) - 1)[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1431960,
                "title": "python-clean-simple-no-bitmask",
                "content": "The full problem is NP-hard: https://en.wikipedia.org/wiki/Bin_packing_problem\\n\\nTo get the exact result, we have to recurse with some smart memorization techniques.\\n\\nI still find it challenging to use bitmask, so here is the dfs version.\\n\\nComparing to the default dfs which gets TLE, the trick here is to loop through the sessions, rather than the tasks themselves.\\n\\n```python\\nclass Solution:\\n    def minSessions(self, tasks: List[int], sessionTime: int) -> int:\\n        n = len(tasks)\\n        tasks.sort(reverse=True)\\n        sessions = []\\n        result = [n]\\n        \\n        def dfs(index):\\n            if len(sessions) > result[0]:\\n                return\\n            if index == n:\\n                result[0] = len(sessions)\\n                return\\n            for i in range(len(sessions)):\\n                if sessions[i] + tasks[index] <= sessionTime:\\n                    sessions[i] += tasks[index]\\n                    dfs(index + 1)\\n                    sessions[i] -= tasks[index]\\n            sessions.append(tasks[index])\\n            dfs(index + 1)\\n            sessions.pop()\\n        \\n        dfs(0)\\n        return result[0]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def minSessions(self, tasks: List[int], sessionTime: int) -> int:\\n        n = len(tasks)\\n        tasks.sort(reverse=True)\\n        sessions = []\\n        result = [n]\\n        \\n        def dfs(index):\\n            if len(sessions) > result[0]:\\n                return\\n            if index == n:\\n                result[0] = len(sessions)\\n                return\\n            for i in range(len(sessions)):\\n                if sessions[i] + tasks[index] <= sessionTime:\\n                    sessions[i] += tasks[index]\\n                    dfs(index + 1)\\n                    sessions[i] -= tasks[index]\\n            sessions.append(tasks[index])\\n            dfs(index + 1)\\n            sessions.pop()\\n        \\n        dfs(0)\\n        return result[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1431820,
                "title": "c-java-bitmask-dp-with-explanation-time-o-n-2-n-space-o-2-n",
                "content": "dp[mask] = {a, b} where\\na - minimum number of session\\nb - minimum time of last session\\nThe idea is to go through all tasks who belong to mask and optimally choose the last task \\'t\\' that was added to last session.\\n\\nSimilar problem: CSES Problem Set - Elevator Rides https://cses.fi/problemset/task/1653\\nThis is exactly the same problem if you change the capacity of elevator to \\'sessionTime\\' and weights of people to \\'task\\'.\\n```\\n// C++ Solution\\nclass Solution {\\npublic:\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        const int N = tasks.size();\\n        const int INF = 1e9;\\n        vector<pair<int, int>> dp(1 << N, {INF, INF});\\n        dp[0] = {0, INF};\\n        for(int mask = 1; mask < (1 << N); ++mask) {\\n            pair<int, int> best = {INF, INF};\\n            for(int i = 0; i < N; ++i) {\\n                if(mask & (1 << i)) {\\n                    pair<int, int> cur = dp[mask ^ (1 << i)];\\n                    if(cur.second + tasks[i] > sessionTime) {\\n                        cur = {cur.first + 1, tasks[i]};\\n                    } else\\n                        cur.second += tasks[i];\\n                    best = min(best, cur);\\n                }\\n            }\\n            dp[mask] = best;\\n        }\\n        return dp[(1 << N) - 1].first;\\n    }\\n};\\n```\\n```\\n// Java Solution\\nclass Solution {\\n    public int minSessions(int[] tasks, int sessionTime) {\\n        int n = tasks.length, MAX = Integer.MAX_VALUE;\\n        int[][] dp = new int[1<<n][2];\\n        dp[0][0] = 1;\\n        dp[0][1] = 0;\\n        \\n        for(int i = 1; i < (1 << n); i++) {\\n            dp[i][0] = MAX;\\n            dp[i][1] = 0;\\n            \\n            for(int t = 0; t < n; t++) {\\n                if(((1<<t) & i) == 0) continue;\\n                \\n                int[] prev = dp[(1<<t) ^ i];\\n                if(prev[1] + tasks[t] <= sessionTime) {\\n                    dp[i] = min(dp[i], new int[]{prev[0], prev[1] + tasks[t]});\\n                }else{\\n                    dp[i] = min(dp[i], new int[]{prev[0] + 1, tasks[t]});\\n                }\\n            }            \\n        }\\n        \\n        return dp[(1<<n) - 1][0];\\n    }\\n    \\n    private int[] min(int[] d1, int[] d2) {\\n        if(d1[0] > d2[0]) return d2;\\n        if(d1[0] < d2[0]) return d1;\\n        if(d1[1] > d2[1]) return d2;\\n        \\n        return d1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\n// C++ Solution\\nclass Solution {\\npublic:\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        const int N = tasks.size();\\n        const int INF = 1e9;\\n        vector<pair<int, int>> dp(1 << N, {INF, INF});\\n        dp[0] = {0, INF};\\n        for(int mask = 1; mask < (1 << N); ++mask) {\\n            pair<int, int> best = {INF, INF};\\n            for(int i = 0; i < N; ++i) {\\n                if(mask & (1 << i)) {\\n                    pair<int, int> cur = dp[mask ^ (1 << i)];\\n                    if(cur.second + tasks[i] > sessionTime) {\\n                        cur = {cur.first + 1, tasks[i]};\\n                    } else\\n                        cur.second += tasks[i];\\n                    best = min(best, cur);\\n                }\\n            }\\n            dp[mask] = best;\\n        }\\n        return dp[(1 << N) - 1].first;\\n    }\\n};\\n```\n```\\n// Java Solution\\nclass Solution {\\n    public int minSessions(int[] tasks, int sessionTime) {\\n        int n = tasks.length, MAX = Integer.MAX_VALUE;\\n        int[][] dp = new int[1<<n][2];\\n        dp[0][0] = 1;\\n        dp[0][1] = 0;\\n        \\n        for(int i = 1; i < (1 << n); i++) {\\n            dp[i][0] = MAX;\\n            dp[i][1] = 0;\\n            \\n            for(int t = 0; t < n; t++) {\\n                if(((1<<t) & i) == 0) continue;\\n                \\n                int[] prev = dp[(1<<t) ^ i];\\n                if(prev[1] + tasks[t] <= sessionTime) {\\n                    dp[i] = min(dp[i], new int[]{prev[0], prev[1] + tasks[t]});\\n                }else{\\n                    dp[i] = min(dp[i], new int[]{prev[0] + 1, tasks[t]});\\n                }\\n            }            \\n        }\\n        \\n        return dp[(1<<n) - 1][0];\\n    }\\n    \\n    private int[] min(int[] d1, int[] d2) {\\n        if(d1[0] > d2[0]) return d2;\\n        if(d1[0] < d2[0]) return d1;\\n        if(d1[1] > d2[1]) return d2;\\n        \\n        return d1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1432137,
                "title": "java-solution-15ms-dfs-pruning",
                "content": "The pruning - you only need to put the first k tasks in first k sessions.\\n\\nFor example, assume you are trying if the tasks can be assgiend to 5 sessions (i.e., n == 5).\\n\\n-  When you run DFS for the first task, you see 5 empty sessions. It doesn\\'t matter which session the task is assgiend to, becasue all of the 5 sessions are identical (/empty). If the DFS fails with the first taks assigned to session #1, there is no need to try the DFS with the first task assigned to session #2, #3, etc.\\n-  Similarly, for the first two tasks, you only need to consider assigning them to the first two sessions. For example, the following cases are all identical and there is no need to try all of them:\\n\\t-  | session #1 | session #2 | session #3 | session #4 | session #5 |\\n\\t-  |------------|------------|------------|------------|------------|\\n\\t-  | task 1     | task 2     |            |            |            |\\n\\t-  | task 1     |            | task 2     |            |            |\\n\\t-  |      |            |            | task 2     |   task 1    |\\n-  For the first 3 tasks, you only need to consider assigning them to the first 3 sessions.\\n-  etc.\\n\\n```JAVA\\nclass Solution {\\n    public int minSessions(int[] tasks, int sessionTime) {\\n        for (int n = 1; n < tasks.length; n++) {\\n            int[] remain = new int[n];\\n            for (int i = 0; i < n; i++) {\\n                remain[i] = sessionTime;\\n            }\\n            if (canWork(tasks, 0, remain)) {\\n                return n;\\n            }\\n        }\\n        return tasks.length;\\n    }\\n    \\n    public boolean canWork(int[] tasks, int curr, int[] remain) {\\n        if (curr == tasks.length) {\\n            return true;\\n        }\\n        for (int i = 0; i < remain.length; i++) {\\n            if (i > curr) continue;  // *pruning*\\n            if (remain[i] >= tasks[curr]) {\\n                remain[i] -= tasks[curr];\\n                if (canWork(tasks, curr + 1, remain)) {\\n                    return true;\\n                }\\n                remain[i] += tasks[curr];\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```JAVA\\nclass Solution {\\n    public int minSessions(int[] tasks, int sessionTime) {\\n        for (int n = 1; n < tasks.length; n++) {\\n            int[] remain = new int[n];\\n            for (int i = 0; i < n; i++) {\\n                remain[i] = sessionTime;\\n            }\\n            if (canWork(tasks, 0, remain)) {\\n                return n;\\n            }\\n        }\\n        return tasks.length;\\n    }\\n    \\n    public boolean canWork(int[] tasks, int curr, int[] remain) {\\n        if (curr == tasks.length) {\\n            return true;\\n        }\\n        for (int i = 0; i < remain.length; i++) {\\n            if (i > curr) continue;  // *pruning*\\n            if (remain[i] >= tasks[curr]) {\\n                remain[i] -= tasks[curr];\\n                if (canWork(tasks, curr + 1, remain)) {\\n                    return true;\\n                }\\n                remain[i] += tasks[curr];\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1433054,
                "title": "python-backtracking-664ms-100-time-and-space-explanation",
                "content": "* I think the test cases are little weak, because I just did backtracking and a little pruning and seems to be 4x faster than bitmask solutions.\\n* The question boils down to finding minimum number of subsets such that each subset sum <= sessionTime. I maintain a list called subsets, where I track each subset sum. For each tasks[i] try to fit it into one of the existing subsets or create a new subset with this tasks[i] and recurse further. Once I reach the end of the list, I compare the length of the subsets list with current best and record minimum.\\n* For pruning, I do the following - Once the length of subsets is larger than current best length, I backtrack. This doesn\\'t decrease complexity in mathematical terms but I think in implementation, it helps a lot.\\n\\n```\\nclass Solution:\\n    def minSessions(self, tasks: List[int], sessionTime: int) -> int:\\n        subsets = []\\n        self.ans = len(tasks)\\n        \\n        def func(idx):\\n            if len(subsets) >= self.ans:\\n                return\\n            \\n            if idx == len(tasks):\\n                self.ans = min(self.ans, len(subsets))\\n                return\\n            \\n            for i in range(len(subsets)):\\n                if subsets[i] + tasks[idx] <= sessionTime:\\n                    subsets[i] += tasks[idx]\\n                    func(idx + 1)\\n                    subsets[i] -= tasks[idx]\\n            \\n            subsets.append(tasks[idx])\\n            func(idx + 1)\\n            subsets.pop()\\n        \\n        func(0)\\n        return self.ans",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "* I think the test cases are little weak, because I just did backtracking and a little pruning and seems to be 4x faster than bitmask solutions.\\n* The question boils down to finding minimum number of subsets such that each subset sum <= sessionTime. I maintain a list called subsets, where I track each subset sum. For each tasks[i] try to fit it into one of the existing subsets or create a new subset with this tasks[i] and recurse further. Once I reach the end of the list, I compare the length of the subsets list with current best and record minimum.\\n* For pruning, I do the following - Once the length of subsets is larger than current best length, I backtrack. This doesn\\'t decrease complexity in mathematical terms but I think in implementation, it helps a lot.\\n\\n```\\nclass Solution:\\n    def minSessions(self, tasks: List[int], sessionTime: int) -> int:\\n        subsets = []\\n        self.ans = len(tasks)\\n        \\n        def func(idx):\\n            if len(subsets) >= self.ans:\\n                return\\n            \\n            if idx == len(tasks):\\n                self.ans = min(self.ans, len(subsets))\\n                return\\n            \\n            for i in range(len(subsets)):\\n                if subsets[i] + tasks[idx] <= sessionTime:\\n                    subsets[i] += tasks[idx]\\n                    func(idx + 1)\\n                    subsets[i] -= tasks[idx]\\n            \\n            subsets.append(tasks[idx])\\n            func(idx + 1)\\n            subsets.pop()\\n        \\n        func(0)\\n        return self.ans",
                "codeTag": "Java"
            },
            {
                "id": 1431846,
                "title": "c-dfs-with-pruning",
                "content": "```\\nclass Solution {\\n    vector<int> tasks;\\n    int sessionTime;\\n    int result;\\n    vector<int> sessions;\\n    void dfs(int idx) {\\n        if (sessions.size() >= result) {\\n            return;\\n        }\\n        if (idx == tasks.size()) {\\n            result = sessions.size();\\n            return;\\n        }\\n        for (int i = 0; i < sessions.size(); i++) {\\n            if (sessions[i] + tasks[idx] <= sessionTime) {\\n                sessions[i] += tasks[idx];\\n                dfs(idx + 1);\\n                sessions[i] -= tasks[idx];\\n            }\\n        }\\n        sessions.push_back(tasks[idx]);\\n        dfs(idx + 1);\\n        sessions.pop_back();\\n    }\\npublic:\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        this->tasks = tasks;\\n        this->sessionTime = sessionTime;\\n        result = tasks.size();\\n        dfs(0);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<int> tasks;\\n    int sessionTime;\\n    int result;\\n    vector<int> sessions;\\n    void dfs(int idx) {\\n        if (sessions.size() >= result) {\\n            return;\\n        }\\n        if (idx == tasks.size()) {\\n            result = sessions.size();\\n            return;\\n        }\\n        for (int i = 0; i < sessions.size(); i++) {\\n            if (sessions[i] + tasks[idx] <= sessionTime) {\\n                sessions[i] += tasks[idx];\\n                dfs(idx + 1);\\n                sessions[i] -= tasks[idx];\\n            }\\n        }\\n        sessions.push_back(tasks[idx]);\\n        dfs(idx + 1);\\n        sessions.pop_back();\\n    }\\npublic:\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        this->tasks = tasks;\\n        this->sessionTime = sessionTime;\\n        result = tasks.size();\\n        dfs(0);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1432363,
                "title": "c-backtracking",
                "content": "1.Here we will create **groups** of hours whose sum is less than `SessionTime` .\\n2.basically we will store only the sum of hours in `grps` array which is less than `SessionTime` .\\n3.Our aim is to minimize such number of groups to get minimum number of week sessions.\\n\\nSo, this is how  we gonna create `grps` array : \\ncase 1: if **current element + sum**  is less than `SessionTime` , then we will add the element in previously created grps.\\nelse \\ncase 2: we will create new group in grps array.\\n```\\nclass Solution {\\npublic:\\n    int ans=INT_MAX;\\n    void solve(int start, vector<int>& v, int target,vector<int>& grps){\\n        if(start>=v.size()){\\n            int temp = grps.size();\\n            ans=min(ans,temp);\\n            return ;\\n        }\\n        if(grps.size()>ans)return;  // if grps size is greater than previously found size then we dont need to check this answer \\n\\t\\t\\n        //Case 1\\n        int ans=INT_MAX;\\n        for(int i=0;i<grps.size();i++){\\n            if(grps[i]+v[start]<=target){\\n                grps[i]+=v[start];\\n                solve(start+1,v,target,grps);\\n                grps[i]-=v[start];\\n            }\\n        }\\n        //Case 2\\n        grps.push_back(v[start]);\\n        solve(start+1,v,target,grps);\\n        grps.pop_back();        \\n    }\\n    int minSessions(vector<int>& v, int target) {\\n        int n=v.size();\\n        vector<int>grps;\\n        solve(0,v,target,grps);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=INT_MAX;\\n    void solve(int start, vector<int>& v, int target,vector<int>& grps){\\n        if(start>=v.size()){\\n            int temp = grps.size();\\n            ans=min(ans,temp);\\n            return ;\\n        }\\n        if(grps.size()>ans)return;  // if grps size is greater than previously found size then we dont need to check this answer \\n\\t\\t\\n        //Case 1\\n        int ans=INT_MAX;\\n        for(int i=0;i<grps.size();i++){\\n            if(grps[i]+v[start]<=target){\\n                grps[i]+=v[start];\\n                solve(start+1,v,target,grps);\\n                grps[i]-=v[start];\\n            }\\n        }\\n        //Case 2\\n        grps.push_back(v[start]);\\n        solve(start+1,v,target,grps);\\n        grps.pop_back();        \\n    }\\n    int minSessions(vector<int>& v, int target) {\\n        int n=v.size();\\n        vector<int>grps;\\n        solve(0,v,target,grps);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1431851,
                "title": "c-tsp-variation-simple-explaination",
                "content": "variation of \"Travelling salesman Problem\"\\n     \\n            \\n    //  we will  choose a task from the set of  un-completed task using bit-mask.\\n    //  if time required to do this task + time exhuasted in prev task is less than or equal to  sessionTime then we can do this task in same session .\\n    // otherwise, we have to start new session.\\n    \\n    \\n    \\n    \\n    int target;\\n    int  fun(vector<int>&tasks,int mask,int curr_sum,int&T,vector<vector<int>>&dp){\\n         int n=tasks.size();\\n         if(mask==target){\\n             return  1;\\n         }\\n        \\n         // if already visited the current state then we will return from here only\\n         if(dp[mask][curr_sum]!=-1)\\n            return dp[mask][curr_sum];\\n        \\n        int ans= INT_MAX;\\n        int new_mask;\\n        \\n        for(int i=0;i<n;i++){\\n             if(mask&(1<<i))  continue;\\n            \\n            // if task[i]  has not been done yet then.....\\n             new_mask=mask|(1<<i);\\n             if((curr_sum+tasks[i])>T){\\n                   ans=min(ans,1+fun(tasks,new_mask,tasks[i],T,dp)); \\n             }\\n             else\\n                  ans=min(ans,fun(tasks,new_mask,curr_sum+tasks[i],T,dp)); \\n             \\n         }\\n        \\n        dp[mask][curr_sum]=ans;\\n        return dp[mask][curr_sum];\\n        \\n    }\\n    int minSessions(vector<int>& tasks, int T) {\\n         int n=tasks.size();\\n         target=(1<<n)-1;   \\n         int sum=0;\\n         for(auto& num:tasks){\\n             sum+=num;\\n         }\\n        \\n         \\n         vector<vector<int>>dp((1<<n)+5,vector<int>(sum+1,-1));\\n         return fun(tasks,0,0,T,dp);\\n          \\n    }\\n};",
                "solutionTags": [],
                "code": "variation of \"Travelling salesman Problem\"\\n     \\n            \\n    //  we will  choose a task from the set of  un-completed task using bit-mask.\\n    //  if time required to do this task + time exhuasted in prev task is less than or equal to  sessionTime then we can do this task in same session .\\n    // otherwise, we have to start new session.\\n    \\n    \\n    \\n    \\n    int target;\\n    int  fun(vector<int>&tasks,int mask,int curr_sum,int&T,vector<vector<int>>&dp){\\n         int n=tasks.size();\\n         if(mask==target){\\n             return  1;\\n         }\\n        \\n         // if already visited the current state then we will return from here only\\n         if(dp[mask][curr_sum]!=-1)\\n            return dp[mask][curr_sum];\\n        \\n        int ans= INT_MAX;\\n        int new_mask;\\n        \\n        for(int i=0;i<n;i++){\\n             if(mask&(1<<i))  continue;\\n            \\n            // if task[i]  has not been done yet then.....\\n             new_mask=mask|(1<<i);\\n             if((curr_sum+tasks[i])>T){\\n                   ans=min(ans,1+fun(tasks,new_mask,tasks[i],T,dp)); \\n             }\\n             else\\n                  ans=min(ans,fun(tasks,new_mask,curr_sum+tasks[i],T,dp)); \\n             \\n         }\\n        \\n        dp[mask][curr_sum]=ans;\\n        return dp[mask][curr_sum];\\n        \\n    }\\n    int minSessions(vector<int>& tasks, int T) {\\n         int n=tasks.size();\\n         target=(1<<n)-1;   \\n         int sum=0;\\n         for(auto& num:tasks){\\n             sum+=num;\\n         }\\n        \\n         \\n         vector<vector<int>>dp((1<<n)+5,vector<int>(sum+1,-1));\\n         return fun(tasks,0,0,T,dp);\\n          \\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1460197,
                "title": "c-dp-bitmask-recursion-memo-bitmask",
                "content": "Idea is to create a mask (n bits) to track if *ith* task has been performed or not. \\nIf not, then we have 2 choices : \\n1. Pick it and perform it in current running session : \\n2. Pick it and create a new session to perform it : \\n\\nHere dp(mask, time) is the minimum number of sessions needed to finish all the tasks represented by mask. Mask will have some/all bits set which means that tasks at that index of set bit are already performed. \\n\\nRemaining code is easy to understand. Just simple memoization and bitmask.\\n\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    int dp[16][1<<14];\\n    int solve(vector<int>& tasks, int mask, int time, const int& sessionTime)\\n    {\\n        if(mask == 0) return 0;         // mask is zero means all tasks are finished\\n        \\n        if(dp[time][mask] != -1) return dp[time][mask];\\n        \\n        int ans = INT_MAX;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            if((mask&(1<<i)))           // If ith task is available or not\\n            {\\n                if(time + tasks[i] <= sessionTime)        // If this task can be performed\\n                    ans = min(ans, solve(tasks, (mask^(1<<i)), time+tasks[i], sessionTime));    // Mark this as completed in ongoing session\\n                else  \\n                    ans = min(ans, 1 + solve(tasks, (mask^(1<<i)), tasks[i], sessionTime)); // Mark this as completed and create a new session\\n            }\\n        }\\n        return dp[time][mask] = ans;\\n    }\\n    \\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        n = tasks.size();\\n        memset(dp, -1, sizeof(dp));\\n        return solve(tasks, (1<<n)-1, 0, sessionTime) + 1;\\n    }\\n};\\n```\\n**Time: O(2^n * sessionTime * n) \\nSpace: O(2^n * sessionTime)**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int dp[16][1<<14];\\n    int solve(vector<int>& tasks, int mask, int time, const int& sessionTime)\\n    {\\n        if(mask == 0) return 0;         // mask is zero means all tasks are finished\\n        \\n        if(dp[time][mask] != -1) return dp[time][mask];\\n        \\n        int ans = INT_MAX;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            if((mask&(1<<i)))           // If ith task is available or not\\n            {\\n                if(time + tasks[i] <= sessionTime)        // If this task can be performed\\n                    ans = min(ans, solve(tasks, (mask^(1<<i)), time+tasks[i], sessionTime));    // Mark this as completed in ongoing session\\n                else  \\n                    ans = min(ans, 1 + solve(tasks, (mask^(1<<i)), tasks[i], sessionTime)); // Mark this as completed and create a new session\\n            }\\n        }\\n        return dp[time][mask] = ans;\\n    }\\n    \\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        n = tasks.size();\\n        memset(dp, -1, sizeof(dp));\\n        return solve(tasks, (1<<n)-1, 0, sessionTime) + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1431929,
                "title": "dfs-memo-pruning-12-ms",
                "content": "This is a multi-knapsack problem, which is very tough. Fortunately, it\\u2019s constrained to 14 tasks. We won\\u2019t have more than 14 sessions - each up to 15 hours long. Therefore, we can represent the sessions state using 64-bit.\\n\\nThe most important optimization is to sort sessions before computing the state. The order of sessions does not matter - it only matters how long they are.\\n\\nTo speed it up even more, we can prune our search if it exceeds some number of sessions (which we can find greedily).\\n\\n**C++**\\n```cpp\\nunordered_map<long long, int> m;\\nint dfs(vector<int>& tasks, vector<int> rem, int sessionTime, int i, int lim) {\\n    if (i >= tasks.size())\\n        return 0;\\n    if (rem.size() > lim)\\n        return 1000;\\n    long long cache = 0;\\n    sort(begin(rem), end(rem));\\n    for (auto r : rem)\\n        cache = (cache << 4) + r + 1;\\n    if (m.count(cache))\\n        return m[cache];\\n    rem.push_back(sessionTime - tasks[i]);\\n    int res = 1 + dfs(tasks, rem, sessionTime, i + 1, lim);\\n    rem.pop_back();\\n    for (int j = 0; j < rem.size(); ++j) {\\n        if (rem[j] >= tasks[i]) {\\n            rem[j] -= tasks[i];\\n            res = min(res, dfs(tasks, rem, sessionTime, i + 1, lim));\\n            rem[j] += tasks[i];\\n        }\\n    }\\n    return m[cache] = res;\\n}\\nint greedy(vector<int>& tasks, int sessionTime) {\\n    vector<int> sessions;\\n    for (int t : tasks) {\\n        bool found = false;\\n        for (int i = 0; !found && i < sessions.size(); ++i) {\\n            if (sessions[i] >= t) {\\n                sessions[i] -= t;\\n                found = true;\\n            }\\n        }\\n        if (!found)\\n            sessions.push_back(sessionTime - t);\\n    }\\n    return sessions.size();\\n}\\nint minSessions(vector<int>& tasks, int sessionTime) {\\n    sort(begin(tasks), end(tasks), greater<int>());\\n    return dfs(tasks, vector<int>() = {}, sessionTime, 0, greedy(tasks, sessionTime));\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nunordered_map<long long, int> m;\\nint dfs(vector<int>& tasks, vector<int> rem, int sessionTime, int i, int lim) {\\n    if (i >= tasks.size())\\n        return 0;\\n    if (rem.size() > lim)\\n        return 1000;\\n    long long cache = 0;\\n    sort(begin(rem), end(rem));\\n    for (auto r : rem)\\n        cache = (cache << 4) + r + 1;\\n    if (m.count(cache))\\n        return m[cache];\\n    rem.push_back(sessionTime - tasks[i]);\\n    int res = 1 + dfs(tasks, rem, sessionTime, i + 1, lim);\\n    rem.pop_back();\\n    for (int j = 0; j < rem.size(); ++j) {\\n        if (rem[j] >= tasks[i]) {\\n            rem[j] -= tasks[i];\\n            res = min(res, dfs(tasks, rem, sessionTime, i + 1, lim));\\n            rem[j] += tasks[i];\\n        }\\n    }\\n    return m[cache] = res;\\n}\\nint greedy(vector<int>& tasks, int sessionTime) {\\n    vector<int> sessions;\\n    for (int t : tasks) {\\n        bool found = false;\\n        for (int i = 0; !found && i < sessions.size(); ++i) {\\n            if (sessions[i] >= t) {\\n                sessions[i] -= t;\\n                found = true;\\n            }\\n        }\\n        if (!found)\\n            sessions.push_back(sessionTime - t);\\n    }\\n    return sessions.size();\\n}\\nint minSessions(vector<int>& tasks, int sessionTime) {\\n    sort(begin(tasks), end(tasks), greater<int>());\\n    return dfs(tasks, vector<int>() = {}, sessionTime, 0, greedy(tasks, sessionTime));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1431870,
                "title": "python-k-subset-sums",
                "content": "For a given value of `k` you can check if you can have `k`-subsets where none of the sums exceed `T`. Start from the lowest possible value of `k` and try if you can solve. `k`-subset sums can be checked with backtracking.\\n\\n```python\\nclass Solution:\\n    def minSessions(self, A, T):\\n        A.sort(reverse = True)\\n        \\n        if sum(A) <= T:\\n            return 1\\n        if min(A) == T:\\n            return len(A)\\n\\n        k_min = sum(A) // T\\n        k_max = len(A)\\n        \\n        for k in range(k_min, k_max):\\n            ks = [0] * k\\n            \\n            def can_partition(j):\\n                if j == len(A):\\n                    for i in range(k):\\n                        if ks[i] > T:\\n                            return False\\n                    return True\\n                for i in range(k):\\n                    if ks[i] + A[j] <= T:\\n                        ks[i] += A[j]\\n                        if can_partition(j + 1):\\n                            return True\\n                        ks[i] -= A[j]\\n                return False\\n            \\n            if can_partition(0):\\n                return k\\n        return len(A)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minSessions(self, A, T):\\n        A.sort(reverse = True)\\n        \\n        if sum(A) <= T:\\n            return 1\\n        if min(A) == T:\\n            return len(A)\\n\\n        k_min = sum(A) // T\\n        k_max = len(A)\\n        \\n        for k in range(k_min, k_max):\\n            ks = [0] * k\\n            \\n            def can_partition(j):\\n                if j == len(A):\\n                    for i in range(k):\\n                        if ks[i] > T:\\n                            return False\\n                    return True\\n                for i in range(k):\\n                    if ks[i] + A[j] <= T:\\n                        ks[i] += A[j]\\n                        if can_partition(j + 1):\\n                            return True\\n                        ks[i] -= A[j]\\n                return False\\n            \\n            if can_partition(0):\\n                return k\\n        return len(A)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1432180,
                "title": "clean-java",
                "content": "Use backtring and prune, we have a sessions buckets, we put each task into any one of \"not full\" one, we prefer to put into old buckets than into new empty buckets cause this would incrase speed.\\n\\n```\\n//1ms Accept\\nclass Solution {\\n    int res;\\n    int maxSessionTime;\\n    int[] tasks;\\n    int[] sessions;\\n    public int minSessions(int[] tasks, int sessionTime) {\\n\\t    Arrays.sort(tasks);\\n        this.res = tasks.length;\\n        this.maxSessionTime = sessionTime;\\n        this.tasks = tasks;\\n        this.sessions = new int[tasks.length];\\n        dfs(tasks.length - 1, 0);\\n        return res;\\n    }\\n    \\n    private void dfs(int taskID, int sessionCount) {\\n        if (sessionCount > res) return; //prune, if we didn\\'t use prune, it will be 2200ms, if lucky you get ac\\n        if (taskID == tasks.length) {\\n            res = Math.min(res, sessionCount);\\n            return;\\n        }\\n        for (int i = 0; i < sessionCount; i++)\\n            if (sessions[i] + tasks[taskID] <= maxSessionTime) { //put task into old session bucket\\n                sessions[i] += tasks[taskID];\\n                dfs(taskID - 1, sessionCount);\\n                sessions[i] -= tasks[taskID];\\n            }\\n        sessions[sessionCount] += tasks[taskID]; //put task into new empty session bucket\\n        dfs(taskID - 1, sessionCount + 1);\\n        sessions[sessionCount] -= tasks[taskID];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n//1ms Accept\\nclass Solution {\\n    int res;\\n    int maxSessionTime;\\n    int[] tasks;\\n    int[] sessions;\\n    public int minSessions(int[] tasks, int sessionTime) {\\n\\t    Arrays.sort(tasks);\\n        this.res = tasks.length;\\n        this.maxSessionTime = sessionTime;\\n        this.tasks = tasks;\\n        this.sessions = new int[tasks.length];\\n        dfs(tasks.length - 1, 0);\\n        return res;\\n    }\\n    \\n    private void dfs(int taskID, int sessionCount) {\\n        if (sessionCount > res) return; //prune, if we didn\\'t use prune, it will be 2200ms, if lucky you get ac\\n        if (taskID == tasks.length) {\\n            res = Math.min(res, sessionCount);\\n            return;\\n        }\\n        for (int i = 0; i < sessionCount; i++)\\n            if (sessions[i] + tasks[taskID] <= maxSessionTime) { //put task into old session bucket\\n                sessions[i] += tasks[taskID];\\n                dfs(taskID - 1, sessionCount);\\n                sessions[i] -= tasks[taskID];\\n            }\\n        sessions[sessionCount] += tasks[taskID]; //put task into new empty session bucket\\n        dfs(taskID - 1, sessionCount + 1);\\n        sessions[sessionCount] -= tasks[taskID];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1432211,
                "title": "simple-c-backtracking-dp-solution-with-comments",
                "content": "**Basic Idea**\\nThe idea here is to use **Backtracking + DP** in order to solve this problem under the given constraints.\\n\\n**Intution:**\\nThe basic intution we are going to use is that every element in the tasks array can either be included in its own separate session or in any one of the existing sessions. Whatever be the minimum of these two will be our answer.\\nWe\\'ll use a arr vector, where length of arr will denote the number of sessions we currently have and arr[i] will denote the number of hours we have worked in that ith session.\\n\\n**CODE:**\\n```\\n\\tvector<int> arr;\\n\\t//unordered map for our dp table\\n    unordered_map<string,int> dp;\\n    \\n\\t//function to make key to be used in dp map\\n\\t// note: here we first sort copy array to reduce the repeated states\\n    string makeKey(vector<int> &arr,int pos)\\n    {\\n        string str = to_string(pos) + \\'$\\';\\n        vector<int> copy = arr;\\n        sort(copy.begin(),copy.end());\\n        for(auto val : copy) str += to_string(val) + \\'$\\';\\n        \\n        return str;\\n    }\\n    \\n    int recur(vector<int> &tasks,int sessionTime,int pos)\\n    {\\n\\t\\t//if all tasks are finished , we return 0 indicating no more session is required\\n        if(pos >= tasks.size()) return 0;\\n        \\n\\t\\t//getting key from the function above\\n        string key = makeKey(arr,pos);\\n        \\n\\t\\t//if the key exists in our map, we\\'ll simpy use it\\'s value else we\\'ll continue\\n        if(dp.find(key) != dp.end()) return dp[key];\\n        \\n\\t\\t//Case 1: we make a separate session for our current task\\n\\t\\t//             and solve for rest of the array using backtracking\\n        arr.push_back(tasks[pos]);\\n        int ans = 1 + recur(tasks,sessionTime,pos+1);\\n        arr.pop_back();\\n        \\n\\t\\t//Case 2: we try to include the current session in any one of the previous sessions\\n\\t\\t//            and try to solve for rest of array using backtracking, keeping track of the minm\\n\\t\\t//            value and storing it in our ans variable\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if(arr[i] + tasks[pos] <= sessionTime)\\n            {\\n                arr[i] += tasks[pos];\\n                ans = min(ans,recur(tasks,sessionTime,pos+1));\\n                arr[i] -= tasks[pos];\\n            }\\n        }\\n        \\n\\t\\t//storing the ans for the current key and returning the ans calculated \\n        return dp[key] = ans;\\n    }\\n\\t\\n\\tint minSessions(vector<int>& tasks, int sessionTime) {\\n        return recur(tasks,sessionTime,0);\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\tvector<int> arr;\\n\\t//unordered map for our dp table\\n    unordered_map<string,int> dp;\\n    \\n\\t//function to make key to be used in dp map\\n\\t// note: here we first sort copy array to reduce the repeated states\\n    string makeKey(vector<int> &arr,int pos)\\n    {\\n        string str = to_string(pos) + \\'$\\';\\n        vector<int> copy = arr;\\n        sort(copy.begin(),copy.end());\\n        for(auto val : copy) str += to_string(val) + \\'$\\';\\n        \\n        return str;\\n    }\\n    \\n    int recur(vector<int> &tasks,int sessionTime,int pos)\\n    {\\n\\t\\t//if all tasks are finished , we return 0 indicating no more session is required\\n        if(pos >= tasks.size()) return 0;\\n        \\n\\t\\t//getting key from the function above\\n        string key = makeKey(arr,pos);\\n        \\n\\t\\t//if the key exists in our map, we\\'ll simpy use it\\'s value else we\\'ll continue\\n        if(dp.find(key) != dp.end()) return dp[key];\\n        \\n\\t\\t//Case 1: we make a separate session for our current task\\n\\t\\t//             and solve for rest of the array using backtracking\\n        arr.push_back(tasks[pos]);\\n        int ans = 1 + recur(tasks,sessionTime,pos+1);\\n        arr.pop_back();\\n        \\n\\t\\t//Case 2: we try to include the current session in any one of the previous sessions\\n\\t\\t//            and try to solve for rest of array using backtracking, keeping track of the minm\\n\\t\\t//            value and storing it in our ans variable\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if(arr[i] + tasks[pos] <= sessionTime)\\n            {\\n                arr[i] += tasks[pos];\\n                ans = min(ans,recur(tasks,sessionTime,pos+1));\\n                arr[i] -= tasks[pos];\\n            }\\n        }\\n        \\n\\t\\t//storing the ans for the current key and returning the ans calculated \\n        return dp[key] = ans;\\n    }\\n\\t\\n\\tint minSessions(vector<int>& tasks, int sessionTime) {\\n        return recur(tasks,sessionTime,0);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1455442,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans=INT_MAX;\\n    int minSessions(vector<int>& tasks, int sessions) {\\n         vector<int> subs;\\n         solve(0,tasks,subs,sessions);\\n         return ans;\\n    }\\n    void solve(int pos,vector<int> &tasks,vector<int>&subs,int sessions) {\\n           if(pos>=tasks.size()) {\\n                 ans=min(ans,(int)subs.size());\\n                 return; \\n           }\\n           if(subs.size()>ans) return;\\n           for(int set=0; set<subs.size(); set++) {\\n                  if(subs[set]+tasks[pos]<=sessions) {\\n                       subs[set]+=tasks[pos];\\n                       solve(pos+1,tasks,subs,sessions);\\n                       subs[set]-=tasks[pos];\\n                  }\\n           }\\n           subs.push_back(tasks[pos]);\\n           solve(pos+1,tasks,subs,sessions);\\n           subs.pop_back();\\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=INT_MAX;\\n    int minSessions(vector<int>& tasks, int sessions) {\\n         vector<int> subs;\\n         solve(0,tasks,subs,sessions);\\n         return ans;\\n    }\\n    void solve(int pos,vector<int> &tasks,vector<int>&subs,int sessions) {\\n           if(pos>=tasks.size()) {\\n                 ans=min(ans,(int)subs.size());\\n                 return; \\n           }\\n           if(subs.size()>ans) return;\\n           for(int set=0; set<subs.size(); set++) {\\n                  if(subs[set]+tasks[pos]<=sessions) {\\n                       subs[set]+=tasks[pos];\\n                       solve(pos+1,tasks,subs,sessions);\\n                       subs[set]-=tasks[pos];\\n                  }\\n           }\\n           subs.push_back(tasks[pos]);\\n           solve(pos+1,tasks,subs,sessions);\\n           subs.pop_back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1433782,
                "title": "java-o-n-log-n-binary-search-recursion-0ms-beats-100",
                "content": "Instead of searching for the best answer using classic recursion + pruning, assume the aswer and check if it\\'s possible to reach it. Search scope for given constraints is very small. Sorting elements desc, allows to verify asserted value much faster.\\n`sessions` store all times assigned to days `k` so far.\\n`si `- index of current last session, so `si + 1` - number of sessions.\\n\\nComplexity analysis:\\nIn recursive function, first task can go into first session only, second task can go to first session or new session, ... nth task can go to each `n` sessions. Recursion time complexity is then `O(n!)`. Binary search adds` log(n) `factor, so the overall time complexity is `O(n! log(n))`. \\n\\n```\\n   public int minSessions(int[] tasks, int sessionTime) {\\n        sortDescending(tasks);\\n        int l = 1;\\n        int r = tasks.length;\\n        while (l < r) {\\n            int maxSessions = (l + r) / 2;\\n            if (canSchedule(maxSessions, tasks, sessionTime, 0, 0, new int[tasks.length])) {\\n                r = maxSessions;\\n            } else {\\n                l = maxSessions + 1;\\n            }\\n        }\\n        return l;\\n    }\\n\\n    boolean canSchedule(int max, int[] tasks, int sessionTime, int k, int si, int sessions[]) {\\n        if (si + 1 > max) return false;\\n        else if (k == tasks.length || max == tasks.length) return true;\\n        else {\\n            int t = tasks[k]; \\n            for (int i = 0; i <= si + 1; i++) { //iterate all current started sessions and si + 1 (new empty session)\\n                if (sessions[i] + t <= sessionTime) {\\n                    sessions[i] += t;\\n                    if (canSchedule(max, tasks, sessionTime, k + 1, Math.max(si, i), sessions)) return true;\\n                    sessions[i] -= t;\\n                }\\n            }\\n            return false;\\n        }\\n    }\\n\\n    private void sortDescending(int[] tasks) {\\n        Arrays.sort(tasks);\\n        int i = 0;\\n        while (i < tasks.length / 2) {\\n            int j = tasks.length - i - 1;\\n            int tmp = tasks[i];\\n            tasks[i] = tasks[j];\\n            tasks[j] = tmp;\\n            i++;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n   public int minSessions(int[] tasks, int sessionTime) {\\n        sortDescending(tasks);\\n        int l = 1;\\n        int r = tasks.length;\\n        while (l < r) {\\n            int maxSessions = (l + r) / 2;\\n            if (canSchedule(maxSessions, tasks, sessionTime, 0, 0, new int[tasks.length])) {\\n                r = maxSessions;\\n            } else {\\n                l = maxSessions + 1;\\n            }\\n        }\\n        return l;\\n    }\\n\\n    boolean canSchedule(int max, int[] tasks, int sessionTime, int k, int si, int sessions[]) {\\n        if (si + 1 > max) return false;\\n        else if (k == tasks.length || max == tasks.length) return true;\\n        else {\\n            int t = tasks[k]; \\n            for (int i = 0; i <= si + 1; i++) { //iterate all current started sessions and si + 1 (new empty session)\\n                if (sessions[i] + t <= sessionTime) {\\n                    sessions[i] += t;\\n                    if (canSchedule(max, tasks, sessionTime, k + 1, Math.max(si, i), sessions)) return true;\\n                    sessions[i] -= t;\\n                }\\n            }\\n            return false;\\n        }\\n    }\\n\\n    private void sortDescending(int[] tasks) {\\n        Arrays.sort(tasks);\\n        int i = 0;\\n        while (i < tasks.length / 2) {\\n            int j = tasks.length - i - 1;\\n            int tmp = tasks[i];\\n            tasks[i] = tasks[j];\\n            tasks[j] = tmp;\\n            i++;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2148599,
                "title": "c-very-easy-binary-search-solution-k-subset-partition-prob",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>&nums,vector<int>&vec,int step,int val)\\n    {\\n        if(step>=nums.size()) return true;\\n        int cur=nums[step];\\n        for(int i=0;i<vec.size();i++)\\n        {\\n            if(vec[i]+cur<=val)\\n            {\\n                vec[i]+=cur;\\n                if(check(nums,vec,step+1,val)) return true;\\n                vec[i]-=cur;\\n            }\\n            if(vec[i]==0) break;\\n        }\\n        return false;\\n    }\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        \\n        int l=1,r=tasks.size();\\n        while(l<r)\\n        {\\n            int mid=(l+r)/2;\\n            vector<int>vec(mid,0);\\n            if(check(tasks,vec,0,sessionTime))\\n            {\\n                r=mid;\\n            }\\n            else\\n                l=mid+1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>&nums,vector<int>&vec,int step,int val)\\n    {\\n        if(step>=nums.size()) return true;\\n        int cur=nums[step];\\n        for(int i=0;i<vec.size();i++)\\n        {\\n            if(vec[i]+cur<=val)\\n            {\\n                vec[i]+=cur;\\n                if(check(nums,vec,step+1,val)) return true;\\n                vec[i]-=cur;\\n            }\\n            if(vec[i]==0) break;\\n        }\\n        return false;\\n    }\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        \\n        int l=1,r=tasks.size();\\n        while(l<r)\\n        {\\n            int mid=(l+r)/2;\\n            vector<int>vec(mid,0);\\n            if(check(tasks,vec,0,sessionTime))\\n            {\\n                r=mid;\\n            }\\n            else\\n                l=mid+1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1434885,
                "title": "java-bin-packing-problem",
                "content": "Problem at hand is essentially the well known [Bin Packing Problem](https://en.wikipedia.org/wiki/Bin_packing_problem) which is NP-hard.\\ntasks[i] \\u21D2 size of an item or items[i]\\nsessionTime \\u21D2 capacity of each bin\\nGoal: minimize the number of sessions \\u21D2 minimize the number of bins\\n\\nThere are couple of approximation algorithms for Bin packing like First-Fit, Best-Fit and Next-Fit which work well in practice but an efficient algorithm for optimal result is quite hard. This is where small input limits help us, we can just do a brute force i.e. enumerate all possibilities.\\n\\n**Basic approach**\\n1. Maintain an array of ```bins``` of size ```n``` (because we don\\'t need more than ```n``` bins for ```n``` items) and a counter ```used``` to keep track of bins used so far. ```bins[i]``` represents size occupied by all the items in ```i```\\'th bin. ```bins[i]``` should never exceed ```capacity```.\\n2. Do a backtracking and try to assign current item ```items[index]``` to all the available ```bins``` as long as they can accomodate it. Also explore the possibility of creating a new bin (```used++```) for this current item.\\n3. Once all the items have been assigned to some bins, take the minimum of number of bins used (use a global variable for result). That is our answer.\\n\\n**Optimization**\\n1. Use [Branch and bound](https://en.wikipedia.org/wiki/Branch_and_bound) technique. If we have already figured out through one of the terminal paths (i.e. valid assignments of all items) that **b** bins are sufficient, then we need not explore paths that we already know will lead to **>= b** bins as the result.\\n2. No need to try assigning an item to multiple bins with the same size. 2 bins ```bins[i]``` and ```bins[j]``` of equal size are both identical as far as the backtracking for rest of the items goes, so we just try assign the current item to only one of them and explore that path only. We can use a Set for this in the code.\\n3. Sort the items and try to assign items in larger to smaller order. This would help us to arrive at a reasonable estimate early.\\n*Note:* I hate the fact that Java doesn\\'t have ```Arrays.sort(int[], Comparator<Integer>)```. That\\'s the only reason I had to iterate ```index``` in reverse order otherwise I had no intention to confuse readers. :)\\n\\n```\\n// 2 ms. 100%\\nclass Solution {\\n    private int best;\\n    private void assign(int[] bins, int used, int[] items, int index, int capacity) {\\n        if(used >= best) return;\\n        if(index < 0) {\\n            best = used;\\n            return;\\n        }\\n\\t\\tSet<Integer> set = new HashSet<>();\\n        for(int i = 0; i < used; i++) {\\n\\t\\t\\tif(!set.add(bins[i]) continue;\\n            if(bins[i] + items[index] <= capacity) {\\n                bins[i] += items[index];\\n                assign(bins, used, items, index - 1, capacity);\\n                bins[i] -= items[index];\\n            }\\n        }\\n        bins[used] = items[index];\\n        assign(bins, used + 1, items, index - 1, capacity);\\n        bins[used] = 0;\\n    }\\n    public int minSessions(int[] tasks, int sessionTime) {\\n        Arrays.sort(tasks);\\n        best = tasks.length;\\n        assign(new int[tasks.length], 0, tasks, tasks.length - 1, sessionTime);\\n        return best;\\n    }\\n}\\n```\\n\\nTime complexity: O(n log n + n B<sub>n</sub>) = O(n B<sub>n</sub>) where B<sub>n</sub> represents n\\'th [Bell number](https://en.wikipedia.org/wiki/Bell_number). B<sub>n</sub> counts the number of different ways to partition a set of n elements.\\nSpace complexity: O(n<sup>2</sup>) [O(n) if we don\\'t use Set optimization]",
                "solutionTags": [],
                "code": "```bins```\n```n```\n```n```\n```n```\n```used```\n```bins[i]```\n```i```\n```bins[i]```\n```capacity```\n```items[index]```\n```bins```\n```used++```\n```bins[i]```\n```bins[j]```\n```Arrays.sort(int[], Comparator<Integer>)```\n```index```\n```\\n// 2 ms. 100%\\nclass Solution {\\n    private int best;\\n    private void assign(int[] bins, int used, int[] items, int index, int capacity) {\\n        if(used >= best) return;\\n        if(index < 0) {\\n            best = used;\\n            return;\\n        }\\n\\t\\tSet<Integer> set = new HashSet<>();\\n        for(int i = 0; i < used; i++) {\\n\\t\\t\\tif(!set.add(bins[i]) continue;\\n            if(bins[i] + items[index] <= capacity) {\\n                bins[i] += items[index];\\n                assign(bins, used, items, index - 1, capacity);\\n                bins[i] -= items[index];\\n            }\\n        }\\n        bins[used] = items[index];\\n        assign(bins, used + 1, items, index - 1, capacity);\\n        bins[used] = 0;\\n    }\\n    public int minSessions(int[] tasks, int sessionTime) {\\n        Arrays.sort(tasks);\\n        best = tasks.length;\\n        assign(new int[tasks.length], 0, tasks, tasks.length - 1, sessionTime);\\n        return best;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1584170,
                "title": "python-3-dfs-binary-search-32ms",
                "content": "```\\ndef minSessions(self, tasks: List[int], sessionTime: int) -> int:\\n        def dfs(i):\\n            if i == len(tasks):\\n                return True\\n            for j in range(mid):\\n                if cnt[j] >= tasks[i]:\\n                    cnt[j] -= tasks[i]\\n                    if dfs(i + 1):\\n                        return True\\n                    cnt[j] += tasks[i]\\n                    if cnt[j] == sessionTime:\\n                        break\\n            return False                    \\n        \\n        l, r = 1, len(tasks)\\n        tasks.sort(reverse=True)\\n        while l < r:\\n            mid = (l + r) // 2\\n            cnt = [sessionTime] * mid\\n            if not dfs(0):\\n                l = mid + 1\\n            else:\\n                r = mid\\n        return l",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\ndef minSessions(self, tasks: List[int], sessionTime: int) -> int:\\n        def dfs(i):\\n            if i == len(tasks):\\n                return True\\n            for j in range(mid):\\n                if cnt[j] >= tasks[i]:\\n                    cnt[j] -= tasks[i]\\n                    if dfs(i + 1):\\n                        return True\\n                    cnt[j] += tasks[i]\\n                    if cnt[j] == sessionTime:\\n                        break\\n            return False                    \\n        \\n        l, r = 1, len(tasks)\\n        tasks.sort(reverse=True)\\n        while l < r:\\n            mid = (l + r) // 2\\n            cnt = [sessionTime] * mid\\n            if not dfs(0):\\n                l = mid + 1\\n            else:\\n                r = mid\\n        return l",
                "codeTag": "Python3"
            },
            {
                "id": 1445414,
                "title": "java-dfs-solution-beating-100",
                "content": "```\\nclass Solution {\\n    public int minSessions(int[] tasks, int sessionTime) {\\n        // sort desendingly\\n        // we know that the minSessionTimes is between 1 to # number of tasks\\n        // then we can use dfs to find from 1 to n, which one works first\\n        // Copy Right to a classmate.\\n        Arrays.sort(tasks);\\n        int s = 0, t = tasks.length - 1;\\n        while (s <= t) {\\n            int temp = tasks[s];\\n            tasks[s] = tasks[t];\\n            tasks[t] = temp;\\n            s++;\\n            t--;\\n        }\\n        \\n        for (int n = 1; n < tasks.length; n++) {\\n            int[] remain = new int[n];\\n            for (int i = 0; i < n; i++) {\\n                remain[i] = sessionTime;\\n            }\\n            if (canWork(tasks, 0, remain)) return n;\\n        }\\n        return tasks.length;\\n    }\\n    \\n    private boolean canWork(int[] tasks, int curr, int[] remain) {\\n        if (curr == tasks.length) return true;\\n        for (int i = 0; i < remain.length; i++) {\\n            if (i > curr) continue; // if i th bucket\\'s index is bigger that current task\\'s index, we continue as it\\'s impossible bc the worst east is that i == index when worksession is equal to task time.\\n            if (remain[i] >= tasks[curr]) {\\n                remain[i] -= tasks[curr];\\n                if (canWork(tasks, curr + 1, remain)) return true;\\n                remain[i] += tasks[curr];\\n            }\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minSessions(int[] tasks, int sessionTime) {\\n        // sort desendingly\\n        // we know that the minSessionTimes is between 1 to # number of tasks\\n        // then we can use dfs to find from 1 to n, which one works first\\n        // Copy Right to a classmate.\\n        Arrays.sort(tasks);\\n        int s = 0, t = tasks.length - 1;\\n        while (s <= t) {\\n            int temp = tasks[s];\\n            tasks[s] = tasks[t];\\n            tasks[t] = temp;\\n            s++;\\n            t--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1436609,
                "title": "c-random-approach-works",
                "content": "People have pointed out that sorting the tasks and then greedily add each task cannot solve the problem, but we can try randomly shuffle the tasks and use the greedy approach. It works for this problem since the data set is not so large. \\n```\\nclass Solution {\\npublic:\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        \\n        int res = INT_MAX;\\n        \\n        for (int i = 0; i < 5000; ++i) {\\n            \\n            random_shuffle(tasks.begin(), tasks.end());\\n            \\n            res = min(res, calculate(tasks, sessionTime));\\n        }\\n        \\n        return res;\\n    }\\n    \\n    \\n    int calculate(vector<int> &tasks, int sessionTime) {\\n        \\n        int res = 1, crr = 0;\\n        \\n        for (auto &task : tasks) {\\n            \\n            if (crr + task <= sessionTime)\\n                crr += task;\\n            else {\\n                ++res;\\n                crr = task;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        \\n        int res = INT_MAX;\\n        \\n        for (int i = 0; i < 5000; ++i) {\\n            \\n            random_shuffle(tasks.begin(), tasks.end());\\n            \\n            res = min(res, calculate(tasks, sessionTime));\\n        }\\n        \\n        return res;\\n    }\\n    \\n    \\n    int calculate(vector<int> &tasks, int sessionTime) {\\n        \\n        int res = 1, crr = 0;\\n        \\n        for (auto &task : tasks) {\\n            \\n            if (crr + task <= sessionTime)\\n                crr += task;\\n            else {\\n                ++res;\\n                crr = task;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3628394,
                "title": "bit-mask-dp-c-solution",
                "content": "**Intution**\\n1. We can Solve this question with Recusion ( But it Takes a lot higher time) (Generally T.C. -> O( N ! * N))\\n2. In Recursive Solution of such type of Problems, we need to modify the original array OR take a **Visited array**  to Remember wich indices are visited.\\n3. so essentially the if we wanna memoize the state of Recursion, It needs a **Map(which memoizes values for each a visited array)** (T.C. Slightly Reduces) (still -TLE May Come ).\\n\\n**NOTE**\\n1. If the size of array (n<=22) we can mark visited indices in the first \\'n\\' bits of  a mask (Integer) Instead of visited array.\\n2. Which gives a lot quicker access, This is essentially The BIT_MASK DP.\\n3. ** STORING THE VISITED INDICES IN THE BITS OF INREGER ** ( Which Represents the State).\\n\\n```\\nclass Solution {\\npublic:\\n    int mx;\\n    int dp[1<<14][16];\\n    int solve(int wd,int time ,vector<int>& tasks,int idx){\\n        int n=tasks.size();        \\n        if(idx==n){\\n            return time<mx;\\n        }\\n        if(dp[wd][time]!=-1)return dp[wd][time];\\n        int ans=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            if((wd & (1<<i))){\\n                // wd[i]=true;\\n                wd=wd ^ (1<<i);\\n                if(tasks[i]>time){\\n                    int curr=1+solve(wd,mx-tasks[i],tasks,idx+1);\\n                    ans=min(ans,curr);\\n                }else if(tasks[i]==time){\\n                    ans=min(ans,1+solve(wd,mx,tasks,idx+1));\\n                }else{\\n                    ans=min(ans,solve(wd,time-tasks[i],tasks,idx+1));\\n                }\\n                wd=wd ^ (1<<i);\\n            }\\n        }\\n        return dp[wd][time]=ans;\\n    }\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        int n=tasks.size();\\n        // vector<bool> workdone(n,0);\\n        int workdone=1<<n;\\n        workdone--;\\n        mx=sessionTime;\\n        memset(dp,-1,sizeof(dp));\\n        return solve(workdone,sessionTime,tasks,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mx;\\n    int dp[1<<14][16];\\n    int solve(int wd,int time ,vector<int>& tasks,int idx){\\n        int n=tasks.size();        \\n        if(idx==n){\\n            return time<mx;\\n        }\\n        if(dp[wd][time]!=-1)return dp[wd][time];\\n        int ans=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            if((wd & (1<<i))){\\n                // wd[i]=true;\\n                wd=wd ^ (1<<i);\\n                if(tasks[i]>time){\\n                    int curr=1+solve(wd,mx-tasks[i],tasks,idx+1);\\n                    ans=min(ans,curr);\\n                }else if(tasks[i]==time){\\n                    ans=min(ans,1+solve(wd,mx,tasks,idx+1));\\n                }else{\\n                    ans=min(ans,solve(wd,time-tasks[i],tasks,idx+1));\\n                }\\n                wd=wd ^ (1<<i);\\n            }\\n        }\\n        return dp[wd][time]=ans;\\n    }\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        int n=tasks.size();\\n        // vector<bool> workdone(n,0);\\n        int workdone=1<<n;\\n        workdone--;\\n        mx=sessionTime;\\n        memset(dp,-1,sizeof(dp));\\n        return solve(workdone,sessionTime,tasks,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775164,
                "title": "backtracking-solution-java-simpler-to-understand",
                "content": "The idea is to populate the tasks in such groups such that we can fit in optimal tasks together and at the same time maintain the threshold for a given session. \\n\\nTo handle this, let us try to group them initially all independently and then backtrack to find space in any of the buckets and add the task to that bucket.\\n```\\nclass Solution {\\n    int minBucket = Integer.MAX_VALUE;\\n    public void helper(int[] tasks, int time, int index, List<Integer> buckets){\\n        \\n        //there has already been a setting when less buckets could satisfy requirements\\n        if(buckets.size() >= minBucket) \\n            return;\\n        if(index == tasks.length){\\n            minBucket = Math.min(minBucket, buckets.size());\\n            return;\\n        }\\n        \\n        buckets.add(tasks[index]);\\n        helper(tasks, time, index+1, buckets);\\n        buckets.remove(buckets.size() - 1);\\n        \\n        //now iterate over all the buckets and if there is space, put and backtrack again\\n        for(int i=0; i<buckets.size(); i++){\\n            if(tasks[index] + buckets.get(i) <= time){\\n                buckets.set(i, buckets.get(i) + tasks[index]);\\n                helper(tasks, time, index+1, buckets);\\n                buckets.set(i, buckets.get(i) - tasks[index]);\\n            }\\n        }    \\n    }\\n    \\n    private void reverse(int[] tasks){\\n        int i=0, j=tasks.length-1;\\n        while(i < j){\\n            int temp = tasks[i];\\n            tasks[i] = tasks[j];\\n            tasks[j] = temp;\\n            i++;\\n            j--;\\n        }\\n    }\\n    public int minSessions(int[] tasks, int sessionTime) {\\n        Arrays.sort(tasks);\\n        reverse(tasks);\\n        helper(tasks, sessionTime, 0, new ArrayList<Integer>());\\n        return minBucket;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    int minBucket = Integer.MAX_VALUE;\\n    public void helper(int[] tasks, int time, int index, List<Integer> buckets){\\n        \\n        //there has already been a setting when less buckets could satisfy requirements\\n        if(buckets.size() >= minBucket) \\n            return;\\n        if(index == tasks.length){\\n            minBucket = Math.min(minBucket, buckets.size());\\n            return;\\n        }\\n        \\n        buckets.add(tasks[index]);\\n        helper(tasks, time, index+1, buckets);\\n        buckets.remove(buckets.size() - 1);\\n        \\n        //now iterate over all the buckets and if there is space, put and backtrack again\\n        for(int i=0; i<buckets.size(); i++){\\n            if(tasks[index] + buckets.get(i) <= time){\\n                buckets.set(i, buckets.get(i) + tasks[index]);\\n                helper(tasks, time, index+1, buckets);\\n                buckets.set(i, buckets.get(i) - tasks[index]);\\n            }\\n        }    \\n    }\\n    \\n    private void reverse(int[] tasks){\\n        int i=0, j=tasks.length-1;\\n        while(i < j){\\n            int temp = tasks[i];\\n            tasks[i] = tasks[j];\\n            tasks[j] = temp;\\n            i++;\\n            j--;\\n        }\\n    }\\n    public int minSessions(int[] tasks, int sessionTime) {\\n        Arrays.sort(tasks);\\n        reverse(tasks);\\n        helper(tasks, sessionTime, 0, new ArrayList<Integer>());\\n        return minBucket;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1490309,
                "title": "java-bitmasking-dp-recursively",
                "content": "SUPPOSE YOU HAVE [9,6,9] AND SEESIONTIME=14\\nSO U CAN MAKE A BITMASK 000\\nWHEN YOU TAKE 9 BIT MASK BECOMES 1000 AS 9 IS LESS THAN 14 YOU SEND recursive(9,1000)\\nthen you got 6 adding 6+9 you get 15 so u send 1+recursive(6,110)\\nnow you have 9+6 you get 15 so u have greater than 14 so you send recursive(9,111)\\nas you base condition 111 which is 7 so you see the sum which is not 0 which is greater than 0 so you send 1 if it was equal to 0 you must have send 0\\n\\nsee my code below\\n\\n\\n```\\n public static int val(int arr[],int sessionTime,int sum,int n,int mask,int dp[][])\\n    {\\n        if(mask==(1<<n)-1)//base condition\\n        {\\n            if(sum==0)\\n            {\\n                return 0;\\n            }\\n            else\\n            if(sum>0)\\n            {\\n                return 1;\\n            }\\n        }\\n        if(dp[mask][sum]!=-1)// taken dp of mask and sum\\n        {\\n            return dp[mask][sum];\\n        }\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<n;i++)\\n        {\\n            if((mask&(1<<i))==0)\\n            {\\n                if(sum+arr[i]==sessionTime)//if sum+9==14\\n                {\\n                    int val1=val(arr,sessionTime,0,n,(mask|(1<<i)),dp);\\n                    if(val1!=Integer.MAX_VALUE)\\n                    {\\n                        val1=val1+1;\\n                    }\\n                    min=Math.min(val1,min);\\n                }\\n                else\\n                if(sum+arr[i]<sessionTime)//if sum+9<14\\n                { \\n                    int val1=val(arr,sessionTime,sum+arr[i],n,(mask|(1<<i)),dp);\\n                      min=Math.min(val1,min);\\n                }\\n                else\\n                if(sum+arr[i]>sessionTime)//if sum+9>14\\n                {\\n                    int val1=val(arr,sessionTime,arr[i],n,(mask|(1<<i)),dp);\\n                    if(val1!=Integer.MAX_VALUE)\\n                    {\\n                        val1=val1+1;\\n                    }\\n                    min=Math.min(val1,min);\\n                }\\n            }\\n        }\\n        return dp[mask][sum]=min;\\n    }\\n```\\n```\\n public int minSessions(int[] tasks, int sessionTime)\\n    {\\n        int n=tasks.length;\\n        int dp[][]=new int[1<<(n+1)-1][20];\\n        for(int i=0;i<(1<<n);i++)\\n        {\\n            for(int j=0;j<20;j++)\\n            {\\n                dp[i][j]=-1;\\n            }\\n        }\\n```\\n\\n**IF U LIKE THE SOLUTION ITS YOUR WISH TO UPVOTE BUT PLS DONT DOWNVOTE**",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Backtracking",
                    "Bitmask"
                ],
                "code": "```\\n public static int val(int arr[],int sessionTime,int sum,int n,int mask,int dp[][])\\n    {\\n        if(mask==(1<<n)-1)//base condition\\n        {\\n            if(sum==0)\\n            {\\n                return 0;\\n            }\\n            else\\n            if(sum>0)\\n            {\\n                return 1;\\n            }\\n        }\\n        if(dp[mask][sum]!=-1)// taken dp of mask and sum\\n        {\\n            return dp[mask][sum];\\n        }\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<n;i++)\\n        {\\n            if((mask&(1<<i))==0)\\n            {\\n                if(sum+arr[i]==sessionTime)//if sum+9==14\\n                {\\n                    int val1=val(arr,sessionTime,0,n,(mask|(1<<i)),dp);\\n                    if(val1!=Integer.MAX_VALUE)\\n                    {\\n                        val1=val1+1;\\n                    }\\n                    min=Math.min(val1,min);\\n                }\\n                else\\n                if(sum+arr[i]<sessionTime)//if sum+9<14\\n                { \\n                    int val1=val(arr,sessionTime,sum+arr[i],n,(mask|(1<<i)),dp);\\n                      min=Math.min(val1,min);\\n                }\\n                else\\n                if(sum+arr[i]>sessionTime)//if sum+9>14\\n                {\\n                    int val1=val(arr,sessionTime,arr[i],n,(mask|(1<<i)),dp);\\n                    if(val1!=Integer.MAX_VALUE)\\n                    {\\n                        val1=val1+1;\\n                    }\\n                    min=Math.min(val1,min);\\n                }\\n            }\\n        }\\n        return dp[mask][sum]=min;\\n    }\\n```\n```\\n public int minSessions(int[] tasks, int sessionTime)\\n    {\\n        int n=tasks.length;\\n        int dp[][]=new int[1<<(n+1)-1][20];\\n        for(int i=0;i<(1<<n);i++)\\n        {\\n            for(int j=0;j<20;j++)\\n            {\\n                dp[i][j]=-1;\\n            }\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1435104,
                "title": "c-3ms-greedy-binary-search-dfs",
                "content": "we alway choose the max of the tasks to fill in the session.\\nthen we use dfs to fill the remaining space in the session from the big to small,\\nand we use Binary Search to find the max one that less than remaining space.\\n3ms\\n```\\nclass Solution {\\npublic:\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        sort(tasks.begin(),tasks.end());\\n        int ans=0;\\n        int nowleft=sessionTime;\\n\\n        while (!tasks.empty()){\\n            vector<int> path;\\n            path.push_back(tasks.size()-1);\\n            int n=nowleft-int(*tasks.rbegin());\\n            dfs(tasks,tasks.size()-1,n,path,n,path);\\n            for(auto i:path){\\n                tasks.erase(tasks.begin()+i);\\n            }\\n            ans++;\\n            nowleft=sessionTime;\\n        }\\n            \\n        return(ans);\\n        \\n           \\n    }\\n    int lessmax(vector<int> tasks,int curr,int n){\\n            int l=0;\\n            int r=curr;\\n            if (tasks[curr]<=n){\\n               \\n                return r-1;\\n            }   \\n            while (l<r){\\n                int mid=(l+r)/2;\\n                if (tasks[mid]<=n and tasks[mid+1]>n){\\n                    return mid;\\n                }\\n                    \\n                else if (tasks[mid]>n){\\n                    \\n                    r=mid;\\n                }\\n                    \\n                else{\\n                    l=mid;\\n                }                    \\n            } \\n            return -1;\\n        }\\n    void dfs(vector<int> tasks,int curr,int nowleft,vector<int> nowpath,int &minleft,vector<int>& minpath){\\n\\n            int lm=lessmax(tasks,curr,nowleft);\\n            if (lm<0){\\n                if (nowleft<minleft){\\n                    minleft=nowleft;\\n                    minpath=nowpath;\\n                }\\n                return ;\\n            }\\n            for (int i=lm;i>=0;i--){\\n                nowpath.push_back(i);\\n                int tmp=nowleft-tasks[i];\\n                if (tmp==0){\\n                    minleft=0;\\n                    minpath=nowpath;\\n                    return;\\n                }else{\\n                    if (tmp<minleft){\\n                        minleft=tmp;\\n                        minpath=nowpath;\\n                    }                    \\n                    dfs(tasks,i,tmp,nowpath,minleft,minpath);\\n                    if(minleft==0){\\n                        return;\\n                    }\\n                }\\n                nowpath.pop_back();\\n            }\\n        }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        sort(tasks.begin(),tasks.end());\\n        int ans=0;\\n        int nowleft=sessionTime;\\n\\n        while (!tasks.empty()){\\n            vector<int> path;\\n            path.push_back(tasks.size()-1);\\n            int n=nowleft-int(*tasks.rbegin());\\n            dfs(tasks,tasks.size()-1,n,path,n,path);\\n            for(auto i:path){\\n                tasks.erase(tasks.begin()+i);\\n            }\\n            ans++;\\n            nowleft=sessionTime;\\n        }\\n            \\n        return(ans);\\n        \\n           \\n    }\\n    int lessmax(vector<int> tasks,int curr,int n){\\n            int l=0;\\n            int r=curr;\\n            if (tasks[curr]<=n){\\n               \\n                return r-1;\\n            }   \\n            while (l<r){\\n                int mid=(l+r)/2;\\n                if (tasks[mid]<=n and tasks[mid+1]>n){\\n                    return mid;\\n                }\\n                    \\n                else if (tasks[mid]>n){\\n                    \\n                    r=mid;\\n                }\\n                    \\n                else{\\n                    l=mid;\\n                }                    \\n            } \\n            return -1;\\n        }\\n    void dfs(vector<int> tasks,int curr,int nowleft,vector<int> nowpath,int &minleft,vector<int>& minpath){\\n\\n            int lm=lessmax(tasks,curr,nowleft);\\n            if (lm<0){\\n                if (nowleft<minleft){\\n                    minleft=nowleft;\\n                    minpath=nowpath;\\n                }\\n                return ;\\n            }\\n            for (int i=lm;i>=0;i--){\\n                nowpath.push_back(i);\\n                int tmp=nowleft-tasks[i];\\n                if (tmp==0){\\n                    minleft=0;\\n                    minpath=nowpath;\\n                    return;\\n                }else{\\n                    if (tmp<minleft){\\n                        minleft=tmp;\\n                        minpath=nowpath;\\n                    }                    \\n                    dfs(tasks,i,tmp,nowpath,minleft,minpath);\\n                    if(minleft==0){\\n                        return;\\n                    }\\n                }\\n                nowpath.pop_back();\\n            }\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1432543,
                "title": "c-simple-backtracking",
                "content": "**Algorithm**\\nBacktracking:\\nFor each task, we have two option\\n1. To accomodate this task in one of the earlier sessions, given that earlier session time + cur_task_time <= max session time.\\n2. To create a new session and allocate this task to that session.\\n\\nWe optimise the backtrack by breaking the recursion if our current session count exceeds that already calculated minimum session count\\n\\n```\\nclass Solution {\\npublic:\\n    int minSession = INT_MAX;\\n    vector<int> sessions;\\n    int minSessions(vector<int>& tasks, int sessionTime) \\n    {\\n        solve(0 ,tasks, sessionTime);\\n        return minSession;\\n    }\\n    \\n    void solve(int index, vector<int>& tasks, int target)\\n    {\\n        // All tasks are scheduled, if sessions is new minimum, update it.\\n        if(index >= tasks.size())\\n        {\\n            if(minSession > sessions.size())\\n                minSession = sessions.size();\\n            return ;\\n        }\\n        \\n        // if current session count is already greater than our min value, don\\'t proceed \\n        if(sessions.size() > minSession)\\n            return;  \\n\\t\\t\\n        //Case 1: Try to fit this task in one of the possible previous sessions.\\n        for(int sessionNum = 0; sessionNum < sessions.size(); sessionNum++)\\n        {\\n            if(sessions[sessionNum] + tasks[index] <= target)\\n            {\\n                sessions[sessionNum] += tasks[index];\\n                solve(index+1, tasks, target);\\n                sessions[sessionNum] -= tasks[index];\\n            }\\n        }\\n        \\n        //Case 2: Put task as part of new session\\n        sessions.push_back(tasks[index]);\\n        solve(index+1, tasks, target);\\n        sessions.pop_back();        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSession = INT_MAX;\\n    vector<int> sessions;\\n    int minSessions(vector<int>& tasks, int sessionTime) \\n    {\\n        solve(0 ,tasks, sessionTime);\\n        return minSession;\\n    }\\n    \\n    void solve(int index, vector<int>& tasks, int target)\\n    {\\n        // All tasks are scheduled, if sessions is new minimum, update it.\\n        if(index >= tasks.size())\\n        {\\n            if(minSession > sessions.size())\\n                minSession = sessions.size();\\n            return ;\\n        }\\n        \\n        // if current session count is already greater than our min value, don\\'t proceed \\n        if(sessions.size() > minSession)\\n            return;  \\n\\t\\t\\n        //Case 1: Try to fit this task in one of the possible previous sessions.\\n        for(int sessionNum = 0; sessionNum < sessions.size(); sessionNum++)\\n        {\\n            if(sessions[sessionNum] + tasks[index] <= target)\\n            {\\n                sessions[sessionNum] += tasks[index];\\n                solve(index+1, tasks, target);\\n                sessions[sessionNum] -= tasks[index];\\n            }\\n        }\\n        \\n        //Case 2: Put task as part of new session\\n        sessions.push_back(tasks[index]);\\n        solve(index+1, tasks, target);\\n        sessions.pop_back();        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1431961,
                "title": "c-solution-with-explanation-backtrack-dfs-type",
                "content": "As we are checking for all positions/arrangements of a task to be done hence it always give min answer. Any doubt ask in comment else if you like? upvote.\\n```\\nclass Solution {\\npublic:\\n    int ans; //stores answer\\n    void help(vector<int>& tasks,int idx,vector<int>& v,int Time)\\n    {\\n        if(v.size()>=ans)  // after this no optimal answer present\\n            return;   \\n        if(idx>=tasks.size())  // if we come to this then it only means v.size()<ans\\n        {\\n            ans=v.size();\\n            return;\\n        }\\n        for(int i=0; i<v.size(); i++)   // solving for each position in vector v to check \\n\\t\\t// if this gives us optimal answer \\n        {\\n            if(v[i]+tasks[idx]<=Time)\\n            {\\n                v[i]+=tasks[idx];\\n                help(tasks,idx+1,v,Time);\\n                v[i]-=tasks[idx];\\n            }\\n        }  \\n        // maybe optimal solution is after adding element to new position\\n \\t\\tv.push_back(tasks[idx]);\\n        help(tasks,idx+1,v,Time);\\n        v.pop_back();\\n    }\\n    int minSessions(vector<int>& tasks, int Time) {\\n        if(tasks.size()==1)\\n            return 1;\\n        int sum=0,i=0;\\n        while(i<tasks.size())\\n        {\\n            sum+=tasks[i];\\n            i++;\\n        }\\n        if(sum<=Time)\\n            return 1;\\n        ans=tasks.size(); // max answer possible\\n        vector<int> v; // to get arrangements of tasks to do\\n        help(tasks,0,v,Time); // starting from 0\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans; //stores answer\\n    void help(vector<int>& tasks,int idx,vector<int>& v,int Time)\\n    {\\n        if(v.size()>=ans)  // after this no optimal answer present\\n            return;   \\n        if(idx>=tasks.size())  // if we come to this then it only means v.size()<ans\\n        {\\n            ans=v.size();\\n            return;\\n        }\\n        for(int i=0; i<v.size(); i++)   // solving for each position in vector v to check \\n\\t\\t// if this gives us optimal answer \\n        {\\n            if(v[i]+tasks[idx]<=Time)\\n            {\\n                v[i]+=tasks[idx];\\n                help(tasks,idx+1,v,Time);\\n                v[i]-=tasks[idx];\\n            }\\n        }  \\n        // maybe optimal solution is after adding element to new position\\n \\t\\tv.push_back(tasks[idx]);\\n        help(tasks,idx+1,v,Time);\\n        v.pop_back();\\n    }\\n    int minSessions(vector<int>& tasks, int Time) {\\n        if(tasks.size()==1)\\n            return 1;\\n        int sum=0,i=0;\\n        while(i<tasks.size())\\n        {\\n            sum+=tasks[i];\\n            i++;\\n        }\\n        if(sum<=Time)\\n            return 1;\\n        ans=tasks.size(); // max answer possible\\n        vector<int> v; // to get arrangements of tasks to do\\n        help(tasks,0,v,Time); // starting from 0\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2517725,
                "title": "easy-to-understand-c-code",
                "content": "* ***Using Recursion && Memoization***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // declare a dp\\n    \\n    unordered_map<string, int> dp;\\n    \\n    // sessions will store the no. of active sessions\\n    \\n    vector<int> sessions;\\n    \\n    // function for creating key\\n    \\n    // we are sorting the arr to avoid duplicate states, [10, 20, 10, 30] and [10, 10, 20, 30] will form the same key\\n    \\n    string create_key(int i)\\n    {\\n        vector<int> arr = sessions;\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        string res = \"\";\\n        \\n        for(int i = 0; i < arr.size(); i++)\\n        {\\n            res += to_string(arr[i]);\\n            \\n            res += \\'#\\';\\n        }\\n        \\n        res += to_string(i);\\n        \\n        return res;\\n    }\\n    \\n    // dfs function\\n    \\n    int dfs(vector<int>& nums, int i, int n, int time_limit)\\n    {\\n        if(i == n)\\n        {\\n            return 0;\\n        }\\n        \\n        // if already calculated\\n        \\n        string key = create_key(i);\\n        \\n        if(dp.count(key))\\n            return dp[key];\\n        \\n        int ans = INT_MAX;\\n        \\n        // create a new session\\n        \\n        sessions.push_back(nums[i]);\\n        \\n        ans = min(ans, 1 + dfs(nums, i + 1, n, time_limit));\\n        \\n        // backtrack part\\n        \\n        sessions.pop_back();\\n        \\n        // include the curr task in the previously active sessions\\n        \\n        for(int k = 0; k < sessions.size(); k++)\\n        {\\n            if(sessions[k] + nums[i] <= time_limit)\\n            {\\n                sessions[k] += nums[i];\\n                \\n                ans = min(ans, dfs(nums, i + 1, n, time_limit));\\n                \\n                // backtrack part\\n                \\n                sessions[k] -= nums[i];\\n            }\\n        }\\n        \\n        // store the res in dp and return it\\n        \\n        return dp[key] = ans;\\n    }\\n    \\n    int minSessions(vector<int>& nums, int sessionTime) {\\n        \\n        int n = nums.size();\\n        \\n        return dfs(nums, 0, n, sessionTime);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // declare a dp\\n    \\n    unordered_map<string, int> dp;\\n    \\n    // sessions will store the no. of active sessions\\n    \\n    vector<int> sessions;\\n    \\n    // function for creating key\\n    \\n    // we are sorting the arr to avoid duplicate states, [10, 20, 10, 30] and [10, 10, 20, 30] will form the same key\\n    \\n    string create_key(int i)\\n    {\\n        vector<int> arr = sessions;\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        string res = \"\";\\n        \\n        for(int i = 0; i < arr.size(); i++)\\n        {\\n            res += to_string(arr[i]);\\n            \\n            res += \\'#\\';\\n        }\\n        \\n        res += to_string(i);\\n        \\n        return res;\\n    }\\n    \\n    // dfs function\\n    \\n    int dfs(vector<int>& nums, int i, int n, int time_limit)\\n    {\\n        if(i == n)\\n        {\\n            return 0;\\n        }\\n        \\n        // if already calculated\\n        \\n        string key = create_key(i);\\n        \\n        if(dp.count(key))\\n            return dp[key];\\n        \\n        int ans = INT_MAX;\\n        \\n        // create a new session\\n        \\n        sessions.push_back(nums[i]);\\n        \\n        ans = min(ans, 1 + dfs(nums, i + 1, n, time_limit));\\n        \\n        // backtrack part\\n        \\n        sessions.pop_back();\\n        \\n        // include the curr task in the previously active sessions\\n        \\n        for(int k = 0; k < sessions.size(); k++)\\n        {\\n            if(sessions[k] + nums[i] <= time_limit)\\n            {\\n                sessions[k] += nums[i];\\n                \\n                ans = min(ans, dfs(nums, i + 1, n, time_limit));\\n                \\n                // backtrack part\\n                \\n                sessions[k] -= nums[i];\\n            }\\n        }\\n        \\n        // store the res in dp and return it\\n        \\n        return dp[key] = ans;\\n    }\\n    \\n    int minSessions(vector<int>& nums, int sessionTime) {\\n        \\n        int n = nums.size();\\n        \\n        return dfs(nums, 0, n, sessionTime);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2434665,
                "title": "c-simple-c-code",
                "content": "\\n\\n# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\n    int n;\\n    int dfs(int ctime, vector<vector<int>> &dp, vector<int>& tasks, int stime, int bitmask)\\n    {\\n        if(bitmask == (1<<n)-1)\\n            return 0;\\n        if(dp[ctime][bitmask] != -1)\\n            return dp[ctime][bitmask];\\n        int val = INT_MAX;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(bitmask & (1 << i))\\n                continue;\\n            bitmask = (bitmask | (1<<i));\\n            if(ctime+tasks[i] <= stime)\\n            {\\n                val = min(val,dfs(ctime+tasks[i], dp, tasks, stime, bitmask));\\n            }\\n            else\\n            {\\n                val = min(val, 1+dfs(tasks[i], dp, tasks, stime, bitmask));\\n            }\\n            bitmask = (bitmask ^ (1<<i));\\n        }\\n        return dp[ctime][bitmask] = val;\\n    }\\n        \\npublic:\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        n = tasks.size();\\n        vector<vector<int>> dp(sessionTime+1,vector<int>( (1<<tasks.size())-1 , -1));\\n        return 1+dfs(0, dp, tasks, sessionTime, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Backtracking",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    int n;\\n    int dfs(int ctime, vector<vector<int>> &dp, vector<int>& tasks, int stime, int bitmask)\\n    {\\n        if(bitmask == (1<<n)-1)\\n            return 0;\\n        if(dp[ctime][bitmask] != -1)\\n            return dp[ctime][bitmask];\\n        int val = INT_MAX;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(bitmask & (1 << i))\\n                continue;\\n            bitmask = (bitmask | (1<<i));\\n            if(ctime+tasks[i] <= stime)\\n            {\\n                val = min(val,dfs(ctime+tasks[i], dp, tasks, stime, bitmask));\\n            }\\n            else\\n            {\\n                val = min(val, 1+dfs(tasks[i], dp, tasks, stime, bitmask));\\n            }\\n            bitmask = (bitmask ^ (1<<i));\\n        }\\n        return dp[ctime][bitmask] = val;\\n    }\\n        \\npublic:\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        n = tasks.size();\\n        vector<vector<int>> dp(sessionTime+1,vector<int>( (1<<tasks.size())-1 , -1));\\n        return 1+dfs(0, dp, tasks, sessionTime, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1437053,
                "title": "dp-bitmasking-cph",
                "content": "Page no. 103 of https://cses.fi/book/book.pdf  read from Permutations to subsets. \\n\\n```\\nclass Solution {\\npublic:\\n    int minSessions(vector<int>& tasks, int t) {\\n        int n=tasks.size();\\n        vector<pair<int,int>>best(1<<n,{n+1,t+1});\\n        // best[0]={1,0};\\n        best[0]={0,t+1};\\n        for(int i=1;i<(1<<n);++i){\\n            // best[i]={n+1,0};\\n            best[i]={n+1,t+1};\\n            for(int j=0;j<n;++j){\\n                if(i&(1<<j)){\\n                    auto opt=best[i^(1<<j)];\\n                    if(opt.second+tasks[j]<=t){\\n                        opt.second+=tasks[j];\\n                    }else{\\n                        opt.first++;\\n                        opt.second=tasks[j];\\n                    }\\n                    best[i]=min(best[i],opt);\\n                }\\n            }\\n        }\\n        return best[(1<<n)-1].first;\\n    }\\n};\\n```\\n\\n[felixhuang07 ](https://leetcode.com/problems/minimum-number-of-work-sessions-to-finish-the-tasks/discuss/1431820/C++-Bitmask-DP-with-Explanation-time:-O(n-*-2n)-space:-O(2n)/1065585) \\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSessions(vector<int>& tasks, int t) {\\n        int n=tasks.size();\\n        vector<pair<int,int>>best(1<<n,{n+1,t+1});\\n        // best[0]={1,0};\\n        best[0]={0,t+1};\\n        for(int i=1;i<(1<<n);++i){\\n            // best[i]={n+1,0};\\n            best[i]={n+1,t+1};\\n            for(int j=0;j<n;++j){\\n                if(i&(1<<j)){\\n                    auto opt=best[i^(1<<j)];\\n                    if(opt.second+tasks[j]<=t){\\n                        opt.second+=tasks[j];\\n                    }else{\\n                        opt.first++;\\n                        opt.second=tasks[j];\\n                    }\\n                    best[i]=min(best[i],opt);\\n                }\\n            }\\n        }\\n        return best[(1<<n)-1].first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1431954,
                "title": "dp-bit-masking-similar-to-travelling-salesman-problem-with-slight-modification",
                "content": "This problem can be easily solved using dynamic programming and bitmasking\\n\\nHere,  the ith bit in mask is 1 if the ith task has been completed otherwise it is 0\\nwhen all the tasks are done, the value of mask will be equal to the value of \\'done\\'\\n\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int> &tasks,int n,vector<vector<int> > &dp,int sessionTime,int cur_session,int mask,int done) {\\n        if(mask==done) {\\n            return 0;\\n        }\\n\\t\\t// if the value was calculated earlier, we return that value and save computation time\\n        if(dp[mask][cur_session]!=-1) {\\n            return dp[mask][cur_session];\\n        }\\n        int ans = INT_MAX; // let\\'s assume INT_MAX sessions are required\\n        for(int i=0;i<n;i++) {\\n            if(((mask>>i)&1)==0) { // if the task has not been completed\\n\\t\\t\\t\\t//cur_session stored the time used in the current session\\n                if(cur_session+tasks[i] <= sessionTime) { // if the task can be completed in current session\\n                    int tmp = mask;\\n                    mask = (mask|(1<<i)); // we mark that the task has been completed\\n                    ans = min(ans,solve(tasks,n,dp,sessionTime,cur_session+tasks[i],mask,done));\\n                    mask = tmp;\\n                }\\n            }\\n        }\\n        if(ans==INT_MAX) { // if no task can be completed in the current session, start a new session\\n            return dp[mask][cur_session] = 1 + solve(tasks,n,dp,sessionTime,0,mask,done);\\n        }\\n\\t\\t// store and return answer\\n        return dp[mask][cur_session] = ans;\\n    }\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        int n = tasks.size();\\n        int done = 0;\\n        for(int i=0;i<n;i++) {\\n            done = (done|(1<<i));\\n        }\\n        vector<vector<int> > dp((1<<n),vector<int>(sessionTime+1,-1));\\n        return 1+solve(tasks,n,dp,sessionTime,0,0,done);\\n    }\\n};\\n```\\n\\nTime complexity : ```(2^n)*n```\\nspace compexity:``` (2^n)*sessionTime```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int> &tasks,int n,vector<vector<int> > &dp,int sessionTime,int cur_session,int mask,int done) {\\n        if(mask==done) {\\n            return 0;\\n        }\\n\\t\\t// if the value was calculated earlier, we return that value and save computation time\\n        if(dp[mask][cur_session]!=-1) {\\n            return dp[mask][cur_session];\\n        }\\n        int ans = INT_MAX; // let\\'s assume INT_MAX sessions are required\\n        for(int i=0;i<n;i++) {\\n            if(((mask>>i)&1)==0) { // if the task has not been completed\\n\\t\\t\\t\\t//cur_session stored the time used in the current session\\n                if(cur_session+tasks[i] <= sessionTime) { // if the task can be completed in current session\\n                    int tmp = mask;\\n                    mask = (mask|(1<<i)); // we mark that the task has been completed\\n                    ans = min(ans,solve(tasks,n,dp,sessionTime,cur_session+tasks[i],mask,done));\\n                    mask = tmp;\\n                }\\n            }\\n        }\\n        if(ans==INT_MAX) { // if no task can be completed in the current session, start a new session\\n            return dp[mask][cur_session] = 1 + solve(tasks,n,dp,sessionTime,0,mask,done);\\n        }\\n\\t\\t// store and return answer\\n        return dp[mask][cur_session] = ans;\\n    }\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        int n = tasks.size();\\n        int done = 0;\\n        for(int i=0;i<n;i++) {\\n            done = (done|(1<<i));\\n        }\\n        vector<vector<int> > dp((1<<n),vector<int>(sessionTime+1,-1));\\n        return 1+solve(tasks,n,dp,sessionTime,0,0,done);\\n    }\\n};\\n```\n```(2^n)*n```\n``` (2^n)*sessionTime```",
                "codeTag": "Java"
            },
            {
                "id": 2444733,
                "title": "c-fully-detailed-intuitions-explained-no-dp-binary-search-backtracking-clean-code",
                "content": "## Intuition -> We want to divide into minimum no of partitions such that all the tasks gets finished.\\n\\n## What we are looking to implement is , max size of partitions of time can be at max n & min will be 1.\\n\\n## So we will apply binary search on that, mid will be the our current no. of partitions we taken , we will create a array of size mid for storing the (possible time value ) in each partitions such that max value of each partitions should be less than or equal to sessionTime.\\n\\n#### By coincidence i have taken the name of array of size mid as dp , it is just for storing it . there is no as such dp (repition thing in this solution).\\n\\n##  Now we will apply our approach of filling the mid no. of partitions , such that max value of partitions should be less than sessionTime , & each partitions must contain a non zero value in it (Some tasks must be done in each partionised set) , otherwise that case will be invalid .\\n\\n### so after computation , if dp[j]==0 ,we are return false (Invalid case).\\n\\n\\n## Similar problem :- Minimum Time to finish the Task (Hard)\\n\\n```\\n   int ans=INT_MAX;\\n    \\n    bool func(vector<int> &nums , int mid , int time , int i , vector<int> &dp )\\n    {\\n        if(i>=nums.size())\\n        {\\n            return true;\\n        }\\n        \\n        int val=*max_element(nums.begin() , nums.end());\\n        \\n        if(val>time)\\n        {\\n            return false;\\n        }\\n        \\n        for(int j=0;j<mid;j++ )\\n        {\\n            if(dp[j] + nums[i] <= time)\\n            {\\n                dp[j]+=nums[i];\\n                \\n                if(func(nums , mid , time , i+1 , dp))\\n                {\\n                    return true;\\n                }\\n                \\n                dp[j]-=nums[i];\\n                \\n                 if(dp[j]==0)\\n                {\\n                     // we can have all the partitions must have some non zero work value , if any partitions \\n\\t\\t\\t\\t\\t// value==0 , then no of partition is less than  mid which is invalid as we have to have mid \\n\\t\\t\\t\\t\\t// number of partitons , then we have to return false \\n                    return false;\\n                }\\n            }\\n        \\n        }\\n        \\n        return false;\\n    }\\n    \\n    int minSessions(vector<int>& nums, int time) {\\n        int n=nums.size();\\n        \\n        int l=1 , r=n;\\n        \\n        sort(nums.begin() , nums.end() , greater<int>());\\n        \\n        int ans=-1;\\n        \\n        while(l<=r)\\n        {\\n            int mid=(l+r)/2;\\n            \\n            vector<int> dp(mid , 0);\\n            \\n            if(func(nums , mid , time , 0 , dp))\\n            {\\n                ans=mid;\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Binary Tree"
                ],
                "code": "```\\n   int ans=INT_MAX;\\n    \\n    bool func(vector<int> &nums , int mid , int time , int i , vector<int> &dp )\\n    {\\n        if(i>=nums.size())\\n        {\\n            return true;\\n        }\\n        \\n        int val=*max_element(nums.begin() , nums.end());\\n        \\n        if(val>time)\\n        {\\n            return false;\\n        }\\n        \\n        for(int j=0;j<mid;j++ )\\n        {\\n            if(dp[j] + nums[i] <= time)\\n            {\\n                dp[j]+=nums[i];\\n                \\n                if(func(nums , mid , time , i+1 , dp))\\n                {\\n                    return true;\\n                }\\n                \\n                dp[j]-=nums[i];\\n                \\n                 if(dp[j]==0)\\n                {\\n                     // we can have all the partitions must have some non zero work value , if any partitions \\n\\t\\t\\t\\t\\t// value==0 , then no of partition is less than  mid which is invalid as we have to have mid \\n\\t\\t\\t\\t\\t// number of partitons , then we have to return false \\n                    return false;\\n                }\\n            }\\n        \\n        }\\n        \\n        return false;\\n    }\\n    \\n    int minSessions(vector<int>& nums, int time) {\\n        int n=nums.size();\\n        \\n        int l=1 , r=n;\\n        \\n        sort(nums.begin() , nums.end() , greater<int>());\\n        \\n        int ans=-1;\\n        \\n        while(l<=r)\\n        {\\n            int mid=(l+r)/2;\\n            \\n            vector<int> dp(mid , 0);\\n            \\n            if(func(nums , mid , time , 0 , dp))\\n            {\\n                ans=mid;\\n                r=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2265329,
                "title": "c-dp-bitmasking",
                "content": "class Solution {\\npublic:\\n    \\n    vector<vector<int>> dp;\\n    \\n    int fun(int curTime,vector<int>& arr,int t,int mask){\\n        if(mask == (1 << arr.size())-1)\\n            return 0;\\n        \\n        if(dp[curTime][mask] != -1)\\n            return dp[curTime][mask];\\n        \\n        \\n        int ans = 15;\\n        \\n        for(int i = 0; i < arr.size(); i++){\\n            \\n            if((mask & (1<<i)) == 0){\\n                mask = mask ^ (1 << i);\\n                \\n                if(curTime + arr[i] <= t)\\n                    ans = min(ans , fun(curTime + arr[i], arr, t , mask));\\n                else\\n                    ans = min(ans , 1+fun(arr[i], arr, t , mask));\\n                \\n                mask = mask ^ (1 << i);\\n            }\\n        }\\n        \\n        return dp[curTime][mask] = ans;\\n    }\\n    int minSessions(vector<int>& arr, int t) {\\n        int n = arr.size();\\n        \\n        dp = vector<vector<int>> (t+1,vector<int>( (1<<arr.size())-1 , -1));\\n        int mask = 0;\\n        return 1+fun(0,arr,t,mask);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    vector<vector<int>> dp;\\n    \\n    int fun(int curTime,vector<int>& arr,int t,int mask){\\n        if(mask == (1 << arr.size())-1)\\n            return 0;\\n        \\n        if(dp[curTime][mask] != -1)\\n            return dp[curTime][mask];\\n        \\n        \\n        int ans = 15;\\n        \\n        for(int i = 0; i < arr.size(); i++){\\n            \\n            if((mask & (1<<i)) == 0){\\n                mask = mask ^ (1 << i);\\n                \\n                if(curTime + arr[i] <= t)\\n                    ans = min(ans , fun(curTime + arr[i], arr, t , mask));\\n                else\\n                    ans = min(ans , 1+fun(arr[i], arr, t , mask));\\n                \\n                mask = mask ^ (1 << i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2166785,
                "title": "python-backtracking-w-pruning",
                "content": "```\\nclass Solution:\\n    def minSessions(self, tasks: List[int], sessionTime: int) -> int:\\n        \\n        sessions = []\\n        \\n        self.ans = n = len(tasks)\\n        \\n        def backtracking(i):\\n            \\n            # pruning\\n            if len(sessions) >= self.ans:\\n                return\\n            \\n            if i == n:\\n                self.ans = min(self.ans, len(sessions))\\n                return\\n\\n            # try to put it in every exist sesssions, or create a new one\\n            for s_idx in range(len(sessions)):\\n                if sessions[s_idx] + tasks[i] <= sessionTime:\\n                    sessions[s_idx] += tasks[i]\\n                    backtracking(i+1)\\n                    sessions[s_idx] -= tasks[i]\\n                    \\n            sessions.append(tasks[i])\\n            backtracking(i+1)\\n            sessions.pop()\\n            \\n        backtracking(0)\\n        return self.ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSessions(self, tasks: List[int], sessionTime: int) -> int:\\n        \\n        sessions = []\\n        \\n        self.ans = n = len(tasks)\\n        \\n        def backtracking(i):\\n            \\n            # pruning\\n            if len(sessions) >= self.ans:\\n                return\\n            \\n            if i == n:\\n                self.ans = min(self.ans, len(sessions))\\n                return\\n\\n            # try to put it in every exist sesssions, or create a new one\\n            for s_idx in range(len(sessions)):\\n                if sessions[s_idx] + tasks[i] <= sessionTime:\\n                    sessions[s_idx] += tasks[i]\\n                    backtracking(i+1)\\n                    sessions[s_idx] -= tasks[i]\\n                    \\n            sessions.append(tasks[i])\\n            backtracking(i+1)\\n            sessions.pop()\\n            \\n        backtracking(0)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1991054,
                "title": "o-n-logn-0-ms-100-faster-binary-search-recursion-c-solution",
                "content": "Problems for Idea Reference: https://leetcode.com/problems/partition-to-k-equal-sum-subsets/\\n2. Book Alloction Problem (similiar to this https://leetcode.com/problems/split-array-largest-sum/)\\n\\nSolution\\n```\\nclass Solution {\\npublic:\\n    bool solve(vector<int> &nums,int &target,int idx,vector<int>&map)\\n    {\\n        if(idx==nums.size())\\n            return true;\\n        for(int i=0;i<map.size();i++)\\n        {\\n            if(map[i] + nums[idx]<=target)\\n            {\\n                map[i] += nums[idx];\\n                if(solve(nums,target,idx+1,map))\\n                    return true;\\n                map[i] -= nums[idx];\\n                if(map[i]==0)\\n                    break;\\n            }\\n        }\\n        return false;\\n    }\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        sort(tasks.begin(),tasks.end(),greater<int>());\\n        int l = 1,h = tasks.size(),m;\\n        while(l<h)\\n        {\\n            m = (l+h)/2;\\n            vector<int> map(m,0);\\n            if(solve(tasks,sessionTime,0,map))\\n            {\\n                h = m;\\n            }\\n            else\\n                l = m + 1;\\n        }\\n        return h;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(vector<int> &nums,int &target,int idx,vector<int>&map)\\n    {\\n        if(idx==nums.size())\\n            return true;\\n        for(int i=0;i<map.size();i++)\\n        {\\n            if(map[i] + nums[idx]<=target)\\n            {\\n                map[i] += nums[idx];\\n                if(solve(nums,target,idx+1,map))\\n                    return true;\\n                map[i] -= nums[idx];\\n                if(map[i]==0)\\n                    break;\\n            }\\n        }\\n        return false;\\n    }\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        sort(tasks.begin(),tasks.end(),greater<int>());\\n        int l = 1,h = tasks.size(),m;\\n        while(l<h)\\n        {\\n            m = (l+h)/2;\\n            vector<int> map(m,0);\\n            if(solve(tasks,sessionTime,0,map))\\n            {\\n                h = m;\\n            }\\n            else\\n                l = m + 1;\\n        }\\n        return h;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1694260,
                "title": "java-share-my-simple-dfs-backtracking-solution-with-pruning-beats-91",
                "content": "\\n```\\nclass Solution {\\n    int min;\\n    public int minSessions(int[] tasks, int sessionTime) {\\n        min = tasks.length + 1; // upper bound, any result can\\'t over this upper bound\\n        \\n        Arrays.sort(tasks);\\n        reverse(tasks);\\n        dfs(tasks, 0, new int[tasks.length], sessionTime, 0);\\n        return min;\\n    }\\n    private void dfs(int[] tasks, int start, int[] bucket, int target, int count) {\\n        if(count >= min) {\\n            return; // pruning\\n        }\\n        \\n        if (start == tasks.length) {\\n            min = count;\\n            return;\\n        }\\n        \\n        // refer to this: https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/discuss/1009817/One-branch-cutting-trick-to-solve-three-LeetCode-questions\\n        Set<Integer> seen = new HashSet<>(); \\n        for (int i = 0; i < bucket.length; i++) {\\n            if (seen.contains(bucket[i])) {\\n                continue;\\n            }\\n            if (tasks[start] + bucket[i] > target) {\\n                continue;\\n            }\\n            if(bucket[i] == 0) {\\n                // new task period, count++\\n                count++;\\n            }\\n            seen.add(bucket[i]);\\n            \\n            bucket[i] += tasks[start];\\n            dfs(tasks, start+1, bucket, target, count);\\n            bucket[i] -= tasks[start];\\n        }\\n        \\n    }\\n   \\n    private void reverse(int[] nums) {\\n        int left = 0;\\n        int right = nums.length-1;\\n        while (left < right) {\\n            int temp = nums[left];\\n            nums[left] = nums[right];\\n            nums[right] = temp;\\n            left++;\\n            right--;\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int min;\\n    public int minSessions(int[] tasks, int sessionTime) {\\n        min = tasks.length + 1; // upper bound, any result can\\'t over this upper bound\\n        \\n        Arrays.sort(tasks);\\n        reverse(tasks);\\n        dfs(tasks, 0, new int[tasks.length], sessionTime, 0);\\n        return min;\\n    }\\n    private void dfs(int[] tasks, int start, int[] bucket, int target, int count) {\\n        if(count >= min) {\\n            return; // pruning\\n        }\\n        \\n        if (start == tasks.length) {\\n            min = count;\\n            return;\\n        }\\n        \\n        // refer to this: https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/discuss/1009817/One-branch-cutting-trick-to-solve-three-LeetCode-questions\\n        Set<Integer> seen = new HashSet<>(); \\n        for (int i = 0; i < bucket.length; i++) {\\n            if (seen.contains(bucket[i])) {\\n                continue;\\n            }\\n            if (tasks[start] + bucket[i] > target) {\\n                continue;\\n            }\\n            if(bucket[i] == 0) {\\n                // new task period, count++\\n                count++;\\n            }\\n            seen.add(bucket[i]);\\n            \\n            bucket[i] += tasks[start];\\n            dfs(tasks, start+1, bucket, target, count);\\n            bucket[i] -= tasks[start];\\n        }\\n        \\n    }\\n   \\n    private void reverse(int[] nums) {\\n        int left = 0;\\n        int right = nums.length-1;\\n        while (left < right) {\\n            int temp = nums[left];\\n            nums[left] = nums[right];\\n            nums[right] = temp;\\n            left++;\\n            right--;\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1446685,
                "title": "solved-without-skills",
                "content": "Honestly, I solved it by adding more and more conditions.\\n\\nThe basic idea is to check if `N` sessions are enough and do binary search on `N`.\\n\\nSome optimizations are:\\n- Sorts tasks. Processing heavy tasks first result in early rejections.\\n- The minimum possible \\'N\\' is `max(1, sum(tasks) // sessionTime)`.\\n- If a task is dispatched to an empty session, no need to check the other sessions. Because the remain (unchecked) sessions are also empty.\\n\\n```python\\nclass Solution:\\n    def minSessions(self, tasks: List[int], sessionTime: int) -> int:\\n        def process_task(idx_task, buckets):\\n            if idx_task == len(tasks):\\n                return True\\n            for i in range(len(buckets)):\\n                if buckets[i] + tasks[idx_task] <= sessionTime:\\n                    buckets[i] += tasks[idx_task]\\n                    if process_task(idx_task + 1, buckets):\\n                        return True\\n                    buckets[i] -= tasks[idx_task]\\n                    if buckets[i] == 0:\\n                        return False\\n            return False\\n\\n        def possible(num_buckets):\\n            buckets = [0 for _ in range(num_buckets)]\\n            buckets[0] = tasks[0]\\n            return process_task(1, buckets)\\n        \\n        tasks.sort(reverse=True)\\n        \\n        l, r = max(1, sum(tasks) // sessionTime), len(tasks)\\n\\n        while l < r:\\n            m = (l + r) // 2\\n            \\n            if possible(m):\\n                r = m\\n            else:\\n                l = m + 1\\n\\n        return l\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```python\\nclass Solution:\\n    def minSessions(self, tasks: List[int], sessionTime: int) -> int:\\n        def process_task(idx_task, buckets):\\n            if idx_task == len(tasks):\\n                return True\\n            for i in range(len(buckets)):\\n                if buckets[i] + tasks[idx_task] <= sessionTime:\\n                    buckets[i] += tasks[idx_task]\\n                    if process_task(idx_task + 1, buckets):\\n                        return True\\n                    buckets[i] -= tasks[idx_task]\\n                    if buckets[i] == 0:\\n                        return False\\n            return False\\n\\n        def possible(num_buckets):\\n            buckets = [0 for _ in range(num_buckets)]\\n            buckets[0] = tasks[0]\\n            return process_task(1, buckets)\\n        \\n        tasks.sort(reverse=True)\\n        \\n        l, r = max(1, sum(tasks) // sessionTime), len(tasks)\\n\\n        while l < r:\\n            m = (l + r) // 2\\n            \\n            if possible(m):\\n                r = m\\n            else:\\n                l = m + 1\\n\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1443055,
                "title": "example-why-sorting-and-greedy-is-not-enough",
                "content": "I see some examples like `tasks` = {3, 4, 7, 8, 10} `sessionTime` = 12, But sorting and greedy can give correct answer for that one. I manage to find on that greedy is not working right.\\n\\nthinking of case like `tasks` = {16, 9, 8, 7,6,6,3,2,2,1} `sessionTime` = 20,after first 6 tasks, u should have three session with 16/20, 17/20, 19/20 respectively, Now u have task with length of 3, if u use greedy u will choose to place it in the first one and ends up with 19/20, 17/20, 19/20. But obviously u can do better by put it in the second one.\\n\\nhope this is helpful.",
                "solutionTags": [],
                "code": "I see some examples like `tasks` = {3, 4, 7, 8, 10} `sessionTime` = 12, But sorting and greedy can give correct answer for that one. I manage to find on that greedy is not working right.\\n\\nthinking of case like `tasks` = {16, 9, 8, 7,6,6,3,2,2,1} `sessionTime` = 20,after first 6 tasks, u should have three session with 16/20, 17/20, 19/20 respectively, Now u have task with length of 3, if u use greedy u will choose to place it in the first one and ends up with 19/20, 17/20, 19/20. But obviously u can do better by put it in the second one.\\n\\nhope this is helpful.",
                "codeTag": "Unknown"
            },
            {
                "id": 1435080,
                "title": "c-dp-solution-using-mask",
                "content": "```\\nclass Solution {\\npublic:\\n    long long dp[1<<15][180];\\n    int find(vector<int>&nums,int mask,int sum,int se,int n)\\n    {\\n        if(mask==(1<<n)-1)\\n        {\\n            return 1;\\n        }\\n        int ans=INT_MAX;\\n        if(dp[mask][sum]!=-1)\\n        {\\n            return dp[mask][sum];\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if((mask&(1<<i))==0)\\n            {\\n                if(sum+nums[i]>se)\\n                {\\n                    ans=min(ans,1+find(nums,mask|(1<<i),nums[i],se,n));\\n                }\\n                else\\n                {\\n                    ans=min(ans,find(nums,mask|(1<<i),sum+nums[i],se,n));\\n                }\\n            }\\n        }\\n        return dp[mask][sum]=ans;\\n    }\\n    int minSessions(vector<int>&nums, int se)\\n    {\\n        memset(dp,-1,sizeof(dp));\\n        return find(nums,0,0,se,nums.size());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dp[1<<15][180];\\n    int find(vector<int>&nums,int mask,int sum,int se,int n)\\n    {\\n        if(mask==(1<<n)-1)\\n        {\\n            return 1;\\n        }\\n        int ans=INT_MAX;\\n        if(dp[mask][sum]!=-1)\\n        {\\n            return dp[mask][sum];\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if((mask&(1<<i))==0)\\n            {\\n                if(sum+nums[i]>se)\\n                {\\n                    ans=min(ans,1+find(nums,mask|(1<<i),nums[i],se,n));\\n                }\\n                else\\n                {\\n                    ans=min(ans,find(nums,mask|(1<<i),sum+nums[i],se,n));\\n                }\\n            }\\n        }\\n        return dp[mask][sum]=ans;\\n    }\\n    int minSessions(vector<int>&nums, int se)\\n    {\\n        memset(dp,-1,sizeof(dp));\\n        return find(nums,0,0,se,nums.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1433595,
                "title": "python-recursion-tuple-memoization-no-bitmask-simple-64ms",
                "content": "I thought some of the other python recursion answers were not that intuitive. Here we simply try each possibility and cache what we\\'ve done so far so no repetition. We take advantage of the tuple data structure which can be cached. The parameter x represents remaining sessiontime for this session. We reset it (plus add to session count) if we can\\'t fit anymore tasks in it. \\n\\n```\\nclass Solution:\\n    def minSessions(self, tasks: List[int], sessionTime: int) -> int:\\n        tasks = sorted(tasks)\\n\\n        @lru_cache(None)\\n        def recur_fn(x,tasks):\\n            if len(tasks) == 0:\\n                return 1\\n            ans = 0\\n            result = []\\n            if tasks[0] > x:\\n                ans += 1  #on to the new session as can\\'t fit anything in \\n                x = sessionTime #resets remaining session time to full session \\n            for i,val in enumerate(tasks):\\n                if val <= x:\\n                    result.append(recur_fn(x-val,tasks[0:i] + tasks[i+1:]))\\n                else:\\n                    break\\n            return ans + min(result)\\n        \\n        return recur_fn(sessionTime,tuple(tasks))",
                "solutionTags": [
                    "Python3",
                    "Recursion",
                    "Memoization"
                ],
                "code": "I thought some of the other python recursion answers were not that intuitive. Here we simply try each possibility and cache what we\\'ve done so far so no repetition. We take advantage of the tuple data structure which can be cached. The parameter x represents remaining sessiontime for this session. We reset it (plus add to session count) if we can\\'t fit anymore tasks in it. \\n\\n```\\nclass Solution:\\n    def minSessions(self, tasks: List[int], sessionTime: int) -> int:\\n        tasks = sorted(tasks)\\n\\n        @lru_cache(None)\\n        def recur_fn(x,tasks):\\n            if len(tasks) == 0:\\n                return 1\\n            ans = 0\\n            result = []\\n            if tasks[0] > x:\\n                ans += 1  #on to the new session as can\\'t fit anything in \\n                x = sessionTime #resets remaining session time to full session \\n            for i,val in enumerate(tasks):\\n                if val <= x:\\n                    result.append(recur_fn(x-val,tasks[0:i] + tasks[i+1:]))\\n                else:\\n                    break\\n            return ans + min(result)\\n        \\n        return recur_fn(sessionTime,tuple(tasks))",
                "codeTag": "Java"
            },
            {
                "id": 1433314,
                "title": "python3-bit-mask-dp",
                "content": "Please see this [commit](https://github.com/gaosanyong/leetcode/commit/7abfd85d1a68e375fcc0be60558909fd98b270f3) for solutions of weekly 256.\\n\\n```\\nclass Solution:\\n    def minSessions(self, tasks: List[int], sessionTime: int) -> int:\\n        \\n        @cache\\n        def fn(mask, rem):\\n            \"\"\"Return minimum work sessions to finish tasks indicated by set bits in mask.\"\"\"\\n            if not mask: return 0 # done \\n            ans = inf \\n            for i, x in enumerate(tasks): \\n                if mask & (1<<i): \\n                    if x <= rem: ans = min(ans, fn(mask ^ (1<<i), rem - x))\\n                    else: ans = min(ans, 1 + fn(mask ^ (1<<i), sessionTime - x))\\n            return ans\\n        \\n        return fn((1<<len(tasks))-1, 0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSessions(self, tasks: List[int], sessionTime: int) -> int:\\n        \\n        @cache\\n        def fn(mask, rem):\\n            \"\"\"Return minimum work sessions to finish tasks indicated by set bits in mask.\"\"\"\\n            if not mask: return 0 # done \\n            ans = inf \\n            for i, x in enumerate(tasks): \\n                if mask & (1<<i): \\n                    if x <= rem: ans = min(ans, fn(mask ^ (1<<i), rem - x))\\n                    else: ans = min(ans, 1 + fn(mask ^ (1<<i), sessionTime - x))\\n            return ans\\n        \\n        return fn((1<<len(tasks))-1, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1433227,
                "title": "java-solution-backtrack-recursion-memoization",
                "content": "Solution:\\n\\n```\\nArrayList<Integer> sessions;\\nHashMap<Pair<ArrayList<Integer>, Integer>,Integer> memo;\\n\\npublic int minSessions(int[] tasks, int sessionTime) {\\n\\tsessions = new ArrayList();\\n\\tmemo = new HashMap();\\n\\treturn recursive(tasks, sessionTime, 0);\\n}\\n\\nprivate int recursive(int[] tasks, int sessionTime, int currentPos){\\n\\t//Base case\\n\\tif(currentPos>=tasks.length){\\n\\t\\treturn 0; //No tasks take zero sessions\\n\\t}\\n\\tPair<ArrayList<Integer>, Integer> pair = new Pair(new ArrayList(sessions), currentPos);\\n\\tif(memo.containsKey(pair)){\\n\\t\\treturn memo.get(pair);\\n\\t}\\n\\n\\t//We can always add a new session\\n\\tsessions.add(tasks[currentPos]);\\n\\tint result = 1 + recursive(tasks, sessionTime, currentPos+1);\\n\\t//Backtrack\\n\\tsessions.remove(sessions.size()-1);\\n\\n\\t//Other cases are trying to add to current sessions\\n\\tfor(int i=0;i<sessions.size();i++){\\n\\t\\tif(sessions.get(i)+tasks[currentPos]<=sessionTime){\\n\\t\\t\\tsessions.set(i, sessions.get(i)+tasks[currentPos]);\\n\\t\\t\\tresult = Math.min(result, recursive(tasks, sessionTime, currentPos+1));\\n\\t\\t\\tsessions.set(i, sessions.get(i)-tasks[currentPos]);   //Backtrack\\n\\t\\t}\\n\\t}\\n\\tmemo.put(pair, result);\\n\\treturn result;\\n}\\n```\\n\\nInspired by C++ solution by @Invulnerable: https://leetcode.com/problems/minimum-number-of-work-sessions-to-finish-the-tasks/discuss/1431836/C%2B%2B-Solution-or-Recursion-%2B-Memoization",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nArrayList<Integer> sessions;\\nHashMap<Pair<ArrayList<Integer>, Integer>,Integer> memo;\\n\\npublic int minSessions(int[] tasks, int sessionTime) {\\n\\tsessions = new ArrayList();\\n\\tmemo = new HashMap();\\n\\treturn recursive(tasks, sessionTime, 0);\\n}\\n\\nprivate int recursive(int[] tasks, int sessionTime, int currentPos){\\n\\t//Base case\\n\\tif(currentPos>=tasks.length){\\n\\t\\treturn 0; //No tasks take zero sessions\\n\\t}\\n\\tPair<ArrayList<Integer>, Integer> pair = new Pair(new ArrayList(sessions), currentPos);\\n\\tif(memo.containsKey(pair)){\\n\\t\\treturn memo.get(pair);\\n\\t}\\n\\n\\t//We can always add a new session\\n\\tsessions.add(tasks[currentPos]);\\n\\tint result = 1 + recursive(tasks, sessionTime, currentPos+1);\\n\\t//Backtrack\\n\\tsessions.remove(sessions.size()-1);\\n\\n\\t//Other cases are trying to add to current sessions\\n\\tfor(int i=0;i<sessions.size();i++){\\n\\t\\tif(sessions.get(i)+tasks[currentPos]<=sessionTime){\\n\\t\\t\\tsessions.set(i, sessions.get(i)+tasks[currentPos]);\\n\\t\\t\\tresult = Math.min(result, recursive(tasks, sessionTime, currentPos+1));\\n\\t\\t\\tsessions.set(i, sessions.get(i)-tasks[currentPos]);   //Backtrack\\n\\t\\t}\\n\\t}\\n\\tmemo.put(pair, result);\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1432691,
                "title": "ruby-c-recursive-solution",
                "content": "# Solution\\n\\nAdd two arguments to the function: \\n `time` - remainning time in the current session;\\n `spent` - number of sessions already worked.\\n \\n# Explanation\\n\\nCheck all tasks that can feet in remaining `time` and choose minimum posible value recursivelly \\nor just start a new session if none feet (in remaining `time`).\\n# Ruby\\n\\n```ruby\\ndef min_sessions(tasks, session_time, time = 0, spent = 0)\\n  return spent if tasks.empty?\\n  return tasks[0] <= time ? spent : spent + 1 if tasks.one?\\n\\n  candidates = tasks.uniq.select { _1 <= time }\\n\\n  if candidates.empty?\\n    t = tasks.max\\n    arr = tasks.dup\\n    arr.delete_at(arr.index(t))\\n    min_sessions(arr, session_time, session_time - t, spent + 1)\\n  else\\n    candidates.map do |t|\\n      arr = tasks.dup\\n      arr.delete_at(arr.index(t))\\n      min_sessions(arr, session_time, time - t, spent)\\n    end.min\\n  end\\nend\\n```\\n\\n# C#\\n\\n```cs\\npublic class Solution {\\n    public int MinSessions(int[] tasks, int sessionTime, int time = 0, int spent = 0) {\\n        if (tasks.Length == 0) return spent;\\n        if (tasks.Length == 1) return tasks[0] <= time ? spent : spent + 1;\\n\\n        var candidates = tasks.Where(t => t <= time).Distinct().ToArray();\\n\\n        if (candidates.Length == 0) {\\n            int t = tasks.Max();\\n            var arr = tasks.ToList();\\n            arr.RemoveAt(arr.IndexOf(t));\\n            return MinSessions(arr.ToArray(), sessionTime, sessionTime - t, spent + 1);\\n        } else {\\n            return candidates.Min(t => {\\n                var arr = tasks.ToList();\\n                arr.RemoveAt(arr.IndexOf(t));\\n                return MinSessions(arr.ToArray(), sessionTime, time - t, spent);\\n            });\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Ruby",
                    "Recursion"
                ],
                "code": "```ruby\\ndef min_sessions(tasks, session_time, time = 0, spent = 0)\\n  return spent if tasks.empty?\\n  return tasks[0] <= time ? spent : spent + 1 if tasks.one?\\n\\n  candidates = tasks.uniq.select { _1 <= time }\\n\\n  if candidates.empty?\\n    t = tasks.max\\n    arr = tasks.dup\\n    arr.delete_at(arr.index(t))\\n    min_sessions(arr, session_time, session_time - t, spent + 1)\\n  else\\n    candidates.map do |t|\\n      arr = tasks.dup\\n      arr.delete_at(arr.index(t))\\n      min_sessions(arr, session_time, time - t, spent)\\n    end.min\\n  end\\nend\\n```\n```cs\\npublic class Solution {\\n    public int MinSessions(int[] tasks, int sessionTime, int time = 0, int spent = 0) {\\n        if (tasks.Length == 0) return spent;\\n        if (tasks.Length == 1) return tasks[0] <= time ? spent : spent + 1;\\n\\n        var candidates = tasks.Where(t => t <= time).Distinct().ToArray();\\n\\n        if (candidates.Length == 0) {\\n            int t = tasks.Max();\\n            var arr = tasks.ToList();\\n            arr.RemoveAt(arr.IndexOf(t));\\n            return MinSessions(arr.ToArray(), sessionTime, sessionTime - t, spent + 1);\\n        } else {\\n            return candidates.Min(t => {\\n                var arr = tasks.ToList();\\n                arr.RemoveAt(arr.IndexOf(t));\\n                return MinSessions(arr.ToArray(), sessionTime, time - t, spent);\\n            });\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1432120,
                "title": "c-solution-faster-than-100-of-c-soltutions-no-complex-algo-easy-to-understand",
                "content": "**Explanation:**\\nCreate an array `state` of size of `sessionTime` initialized as 1 for all the values in `tasks` and 0 elsewhere. Loop it out, trying to push as many `tasks` as possible with sum not more than `sessionTime`, else break. Decrement all the values of  `state` array that get executed to avoid repetitions. \\n\\n**Code:**\\n\\n```\\nclass Solution {\\npublic:\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        if(tasks.size() == 1) return 1;\\n        int ans = 0;\\n        vector<int> state(15, 0);\\n        for(int i=0; i<tasks.size(); i++) {\\n            state[tasks[i]]++;\\n        }\\n        int i = 14;\\n        while(i > 0) {\\n            if(state[i] > 0) {\\n                int curr = i;\\n                int diff = sessionTime - curr;\\n                state[i]--;\\n                while(curr < sessionTime) {\\n                    if(state[diff] > 0) {\\n                        curr += diff;\\n                        state[diff]--;\\n                    }\\n                    else {\\n                        diff--;\\n                        if(diff <= 0) {\\n                            break;\\n                        }\\n                    }\\n                }\\n                ans++;\\n            }\\n            if(state[i] == 0) {\\n                i--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        if(tasks.size() == 1) return 1;\\n        int ans = 0;\\n        vector<int> state(15, 0);\\n        for(int i=0; i<tasks.size(); i++) {\\n            state[tasks[i]]++;\\n        }\\n        int i = 14;\\n        while(i > 0) {\\n            if(state[i] > 0) {\\n                int curr = i;\\n                int diff = sessionTime - curr;\\n                state[i]--;\\n                while(curr < sessionTime) {\\n                    if(state[diff] > 0) {\\n                        curr += diff;\\n                        state[diff]--;\\n                    }\\n                    else {\\n                        diff--;\\n                        if(diff <= 0) {\\n                            break;\\n                        }\\n                    }\\n                }\\n                ans++;\\n            }\\n            if(state[i] == 0) {\\n                i--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1432094,
                "title": "java-1-ms-optimize-backtracking-solution-using-3-techniques",
                "content": "While trying my backtracking solution, I was getting TLE. The optimizations that helped me are shown below:\\n\\n1. Sort task array in descending order which helps in determining minimum number of sessions in less iterations.\\n\\n2. Create a global variable that stores the minimum number of sessions possible at any time. Before calling backtracking again, check that number of sessions must be less the the minimum till now. If it is not less than minimum, no need to call backtrack.\\n\\n3. Do not add a single task to multiple sessions with same timing till now. For example :\\n\\nSessions=[10,10,0,0,0] 5 sessions with 2 used and 3 unused. \\n\\nIf we have to add a task with time 3, we do not need to call two backtrack [13,10,0,0,0] and [10,13,0,0,0] by adding in each section, these both give same final answers. Only one is sufficient.\\n\\n\\n```\\nclass Solution {\\n    // 1st optimization\\n    int globe=Integer.MAX_VALUE;\\n    \\n    public int minSessions(int[] tasks, int sT) {\\n        \\n        // Sort the given tasks array in ascending order\\n        \\n        Arrays.sort(tasks);\\n        int n=tasks.length;\\n        int i=0,j=n-1;\\n        while(i<j){\\n            int temp=tasks[i];\\n            tasks[i]=tasks[j];\\n            tasks[j]=temp;\\n            i+=1;\\n            j-=1;\\n        }\\n        \\n        // create an array for maxium no. of sessions possible\\n        \\n        int[] session=new int[tasks.length+1];\\n        \\n        // call backtrack function\\n        return backtrack(session,tasks,sT,0);\\n        \\n    }\\n    public int backtrack(int[] session,int[] tasks,int sT,int index){\\n        \\n        if(index==tasks.length){\\n            \\n            int temp=count(session);\\n            globe=Math.min(globe,temp);\\n            return temp;\\n            \\n        }\\n        int ans=Integer.MAX_VALUE;\\n        \\n        //2nd optimization\\n        HashSet<Integer> done=new HashSet<>();\\n        \\n        for(int i=1;i<=tasks.length;i++){\\n            if(!done.contains(session[i]) && session[i]+tasks[index]<=sT){\\n                done.add(session[i]);\\n                session[i]=session[i]+tasks[index];\\n                if(count(session)<globe)\\n                    ans=Math.min(ans,backtrack(session,tasks,sT,index+1));\\n                session[i]=session[i]-tasks[index];\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    // method to check the number of sessions\\n    public int count(int[] session){\\n        int count=0;\\n        for(int a:session){\\n            if(a!=0) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    // 1st optimization\\n    int globe=Integer.MAX_VALUE;\\n    \\n    public int minSessions(int[] tasks, int sT) {\\n        \\n        // Sort the given tasks array in ascending order\\n        \\n        Arrays.sort(tasks);\\n        int n=tasks.length;\\n        int i=0,j=n-1;\\n        while(i<j){\\n            int temp=tasks[i];\\n            tasks[i]=tasks[j];\\n            tasks[j]=temp;\\n            i+=1;\\n            j-=1;\\n        }\\n        \\n        // create an array for maxium no. of sessions possible\\n        \\n        int[] session=new int[tasks.length+1];\\n        \\n        // call backtrack function\\n        return backtrack(session,tasks,sT,0);\\n        \\n    }\\n    public int backtrack(int[] session,int[] tasks,int sT,int index){\\n        \\n        if(index==tasks.length){\\n            \\n            int temp=count(session);\\n            globe=Math.min(globe,temp);\\n            return temp;\\n            \\n        }\\n        int ans=Integer.MAX_VALUE;\\n        \\n        //2nd optimization\\n        HashSet<Integer> done=new HashSet<>();\\n        \\n        for(int i=1;i<=tasks.length;i++){\\n            if(!done.contains(session[i]) && session[i]+tasks[index]<=sT){\\n                done.add(session[i]);\\n                session[i]=session[i]+tasks[index];\\n                if(count(session)<globe)\\n                    ans=Math.min(ans,backtrack(session,tasks,sT,index+1));\\n                session[i]=session[i]-tasks[index];\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    // method to check the number of sessions\\n    public int count(int[] session){\\n        int count=0;\\n        for(int a:session){\\n            if(a!=0) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1431952,
                "title": "ac-by-lucky",
                "content": "As the task length is pretty small, if we random shuffle a large number of times, we will have a high possibility to find the optimal result. The solution is simple:\\nRandom shuffle N times and find the minimum result.\\n\\nI guess the test cases are not that strong, so I can get the code AC by lucky.\\n\\n```python\\nclass Solution:\\n    def minSessions(self, tasks: List[int], sessionTime: int) -> int:\\n        ret = float(\"inf\")\\n        for i in range(10000):\\n            random.shuffle(tasks)\\n            thisret = 0\\n            j, curr = 0, 0\\n            while j < len(tasks):\\n                if curr + tasks[j] <= sessionTime:\\n                    curr += tasks[j]\\n                else:\\n                    thisret += 1\\n                    curr = tasks[j]\\n                j += 1\\n            if curr > 0:thisret += 1\\n            ret = min(ret, thisret)\\n        return ret\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minSessions(self, tasks: List[int], sessionTime: int) -> int:\\n        ret = float(\"inf\")\\n        for i in range(10000):\\n            random.shuffle(tasks)\\n            thisret = 0\\n            j, curr = 0, 0\\n            while j < len(tasks):\\n                if curr + tasks[j] <= sessionTime:\\n                    curr += tasks[j]\\n                else:\\n                    thisret += 1\\n                    curr = tasks[j]\\n                j += 1\\n            if curr > 0:thisret += 1\\n            ret = min(ret, thisret)\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1431951,
                "title": "java-bitmask",
                "content": "use bitmask to represent current works done. \\nfor example, if current state = 101111 means second job is not done. \\nTherefore, for the next state (111111), job 2 is done and you will have :\\n1. dp[111111][session+job2Time] = min(dp[111111][session+job2Time], dp[101111][session]) for currentJobsInTheSession+job2Time is smaller than sessionTime. \\n\\n2.  Otherwise, you will start a new session and it will be dp[111111][job2Time] = min(dp[111111][job2Time], dp[101111][session]+1)\\n```\\nclass Solution {\\n    public int minSessions(int[] tasks, int sessionTime) {\\n        Arrays.sort(tasks);\\n        int res = tasks.length;\\n        int n = tasks.length;\\n        int[][] dp = new int[1<<n][sessionTime+1];\\n        \\n        for (int i = 0; i<(1<<n); i++) {\\n            Arrays.fill(dp[i], 100);    \\n        }\\n        dp[0][0] = 1;\\n        for (int i = 0; i<(1<<n); i++) {\\n            for (int t = 0; t<n; t++) {\\n                if (((1<<t) & i)==0) {\\n                    int nextMask = i|(1<<t);\\n                    for (int s = 0; s<sessionTime+1; s++) {\\n                        if (s+tasks[t]<=sessionTime) {\\n                            dp[nextMask][s+tasks[t]] = Math.min(dp[nextMask][s+tasks[t]], dp[i][s]);\\n                        } else {\\n                            dp[nextMask][tasks[t]] = Math.min(dp[nextMask][tasks[t]], dp[i][s]+1);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        int len = dp.length;\\n        for (int i = 0; i<sessionTime+1; i++) {\\n            // System.out.println(dp[len-1][i]);\\n            res = Math.min(res, dp[len-1][i]);\\n        }\\n        return res;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSessions(int[] tasks, int sessionTime) {\\n        Arrays.sort(tasks);\\n        int res = tasks.length;\\n        int n = tasks.length;\\n        int[][] dp = new int[1<<n][sessionTime+1];\\n        \\n        for (int i = 0; i<(1<<n); i++) {\\n            Arrays.fill(dp[i], 100);    \\n        }\\n        dp[0][0] = 1;\\n        for (int i = 0; i<(1<<n); i++) {\\n            for (int t = 0; t<n; t++) {\\n                if (((1<<t) & i)==0) {\\n                    int nextMask = i|(1<<t);\\n                    for (int s = 0; s<sessionTime+1; s++) {\\n                        if (s+tasks[t]<=sessionTime) {\\n                            dp[nextMask][s+tasks[t]] = Math.min(dp[nextMask][s+tasks[t]], dp[i][s]);\\n                        } else {\\n                            dp[nextMask][tasks[t]] = Math.min(dp[nextMask][tasks[t]], dp[i][s]+1);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        int len = dp.length;\\n        for (int i = 0; i<sessionTime+1; i++) {\\n            // System.out.println(dp[len-1][i]);\\n            res = Math.min(res, dp[len-1][i]);\\n        }\\n        return res;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1431915,
                "title": "c-explanation-recursion-memo-bitmask",
                "content": "We will keep adding to current untill task[pos]+cur <=SessionTime, ans remains same since we are not starting new session.\\nIf cur+task[pos]>SessionTime, then we will start new session,and add 1 to ans since we are starting new session.\\nEverytime we start new session , we should add 1 to ans.\\n\\nHere, in dp[mask][cur], mask stands for all task, that has been completed, and cur stands for elapsed time for current session.\\n\\n\\nBonus point: Bitmasking works fine only for smaller input , for n<=16. Beacuse we have to iterate through every possible subset of size n. Number of subsets is 2^n, if n is the number of elements, and 2^16 is around 6 * 10^4\\nSo, next time when you see n<=16. Go for approach with the Bitmask.\\n```\\nclass Solution {\\npublic:\\n    int dp[1<<14][17];\\n    int INF=1e8;\\n    int m;\\n    int solve(int mask,int cur,vector<int> &t,int s)\\n    {\\n        if(mask==(1<<m)-1)      // If all the task is included mask becomes 11111....(m times) which (2^m -1) =(1<<m)-1\\n            return 0;\\n        else if(dp[mask][cur]!=-1)\\n            return dp[mask][cur];\\n        int ans=INF;\\n        for(int i=0;i<t.size();i++)\\n        {\\n            if(mask&(1<<i))    // If already included in any session, we just continue.\\n                continue;\\n            else if(cur+t[i]<=s)\\n                ans=min(ans,solve(mask|(1<<i),cur+t[i],t,s));  //Add to current session\\n            else\\n                ans=min(ans,solve(mask|(1<<i),t[i],t,s)+1);    // Start new session\\n        }\\n        return dp[mask][cur]=ans;\\n    }\\n    int minSessions(vector<int>& t, int s) {\\n        memset(dp,-1,sizeof dp);\\n        m=t.size();\\n        return solve(0,16,t,s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1<<14][17];\\n    int INF=1e8;\\n    int m;\\n    int solve(int mask,int cur,vector<int> &t,int s)\\n    {\\n        if(mask==(1<<m)-1)      // If all the task is included mask becomes 11111....(m times) which (2^m -1) =(1<<m)-1\\n            return 0;\\n        else if(dp[mask][cur]!=-1)\\n            return dp[mask][cur];\\n        int ans=INF;\\n        for(int i=0;i<t.size();i++)\\n        {\\n            if(mask&(1<<i))    // If already included in any session, we just continue.\\n                continue;\\n            else if(cur+t[i]<=s)\\n                ans=min(ans,solve(mask|(1<<i),cur+t[i],t,s));  //Add to current session\\n            else\\n                ans=min(ans,solve(mask|(1<<i),t[i],t,s)+1);    // Start new session\\n        }\\n        return dp[mask][cur]=ans;\\n    }\\n    int minSessions(vector<int>& t, int s) {\\n        memset(dp,-1,sizeof dp);\\n        m=t.size();\\n        return solve(0,16,t,s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1431832,
                "title": "python-self-inspired-only-work-on-leetcode-testcases",
                "content": "```\\nfrom itertools import combinations\\nclass Solution:\\n    def minSessions(self, tasks: List[int], sessionTime: int) -> int:\\n        \\n        tasks.sort()\\n        \\n        ans = 0\\n        i=1\\n        \\n        while tasks and i<=len(tasks): #get rid of all possible combination that results in sessionTime\\n            comb = combinations(tasks, i)\\n \\n            for pairs in list(comb):\\n                if sum(pairs) == sessionTime:\\n                    for val in pairs:\\n                        tasks.remove(val)\\n                    \\n                    i=1\\n                    ans+=1\\n                    break\\n            \\n            i+=1\\n            \\n        while tasks: #for the remaining that is not perfect, selecting from the greatest to lowest\\n            quota = sessionTime\\n            ans+=1\\n            \\n            while quota > 0:\\n                i = bisect.bisect_right(tasks, quota) #right most item greater than quota\\n                if tasks and tasks[i-1] <= quota:\\n                    quota -= tasks.pop(i-1)\\n                else:\\n                    quota = -1\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nfrom itertools import combinations\\nclass Solution:\\n    def minSessions(self, tasks: List[int], sessionTime: int) -> int:\\n        \\n        tasks.sort()\\n        \\n        ans = 0\\n        i=1\\n        \\n        while tasks and i<=len(tasks): #get rid of all possible combination that results in sessionTime\\n            comb = combinations(tasks, i)\\n \\n            for pairs in list(comb):\\n                if sum(pairs) == sessionTime:\\n                    for val in pairs:\\n                        tasks.remove(val)\\n                    \\n                    i=1\\n                    ans+=1\\n                    break\\n            \\n            i+=1\\n            \\n        while tasks: #for the remaining that is not perfect, selecting from the greatest to lowest\\n            quota = sessionTime\\n            ans+=1\\n            \\n            while quota > 0:\\n                i = bisect.bisect_right(tasks, quota) #right most item greater than quota\\n                if tasks and tasks[i-1] <= quota:\\n                    quota -= tasks.pop(i-1)\\n                else:\\n                    quota = -1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704096,
                "title": "java-beats-99-37-1ms-binary-search-backtracking-clear-and-simple-explanation",
                "content": "\\n## Minimum Number of Work Sessions to Finish the Tasks\\n\\n**Problem:**\\n\\nYou are given a set of tasks represented by an integer array `tasks`, where `tasks[i]` represents the number of hours required to finish the ith task. You work in sessions, where each session has a maximum duration of `sessionTime` hours. You need to find the minimum number of sessions required to finish all the tasks, while following these conditions:\\n- Once you start a task in a session, you must complete it in the same session.\\n- You can start a new task immediately after finishing the previous one.\\n- You may complete the tasks in any order.\\n\\n**Solution:**\\n\\nWe can use a binary search approach to find the minimum number of sessions. We sort the tasks array in descending order to prioritize longer tasks. Then, we perform binary search on the range of possible session counts, from 1 to the total number of tasks.\\n\\nIn each iteration of the binary search, we simulate the distribution of tasks among sessions using a backtracking approach. We check if it is possible to complete all tasks within the given session count. If it is possible, we update the answer and continue searching for a smaller session count. Otherwise, we increase the session count and continue searching.\\n\\nHere\\'s the Java implementation of the solution:\\n\\n```java\\nclass Solution {\\n    public int minSessions(int[] tasks, int sessionTime) {\\n        // Sort tasks in descending order to prioritize longer tasks\\n        Arrays.sort(tasks);\\n        reverse(tasks);\\n\\n        int left = 1; // Minimum session count\\n        int right = tasks.length; // Maximum session count\\n        int answer = 0; // Minimum number of sessions required\\n\\n        // Binary search on the range of possible session counts\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            int[] workSessions = new int[mid]; // Array to track tasks assigned to each session\\n\\n            // Check if it\\'s possible to complete all tasks within the given session count\\n            if (isPossible(0, mid, sessionTime, 0, tasks, workSessions, mid)) {\\n                answer = mid; // Update the answer\\n                right = mid - 1; // Continue searching for a smaller session count\\n            } else {\\n                left = mid + 1; // Increase the session count\\n            }\\n        }\\n\\n        return answer;\\n    }\\n\\n    // Backtracking function to simulate the distribution of tasks among sessions\\n    private static boolean isPossible(int idx, int k, int maxLen, int max, int[] tasks, int[] workSessions, int zeroCount) {\\n        if (tasks.length - idx < zeroCount) {\\n            return false; // Not enough tasks remaining to fill all sessions\\n        }\\n\\n        if (idx == tasks.length) {\\n            if (max > maxLen) {\\n                return false; // Current session duration exceeds the maximum session time\\n            }\\n            return true; // All tasks have been assigned to sessions successfully\\n        }\\n\\n        int currentTask = tasks[idx];\\n\\n        for (int i = 0; i < k; i++) {\\n            if (workSessions[i] + currentTask > maxLen) {\\n                continue; // Current task cannot be assigned to this session\\n            }\\n\\n            zeroCount -= workSessions[i] == 0 ? 1 : 0; // Decrement zeroCount if a session becomes non-empty\\n            workSessions[i] += currentTask; // Assign the task to the current session\\n\\n            // Recursively check if it\\'s possible to complete remaining tasks with the updated sessions\\n            if (isPossible(idx + 1, k, maxLen, Math.max(max, workSessions[i]), tasks, workSessions, zeroCount)) {\\n                return true; // Tasks can be completed with the current distribution of sessions\\n            }\\n\\n            workSessions[i] -= currentTask; // Backtrack: Remove the task from the current session\\n            zeroCount += workSessions[i] == 0 ? 1 : 0; // Increment zeroCount if a session becomes empty again\\n\\n            if (workSessions[i] == 0) {\\n                break; // Skip empty sessions to avoid redundant iterations\\n            }\\n        }\\n\\n        return false; // Unable to complete all tasks with the current distribution of sessions\\n    }\\n\\n    // Utility function to reverse an array\\n    private void reverse(int[] arr) {\\n        int i = 0, j = arr.length - 1;\\n\\n        while (i < j) {\\n            int temp = arr[i];\\n            arr[i] = arr[j];\\n            arr[j] = temp;\\n            i++;\\n            j--;\\n        }\\n    }\\n}\\n\\n```\\n\\n**Complexity Analysis:**\\n\\n- Time Complexity: O(N * log(N) * (2^N)), where N is the number of tasks. The algorithm performs binary search on the range of session counts, and for each iteration, it simulates the distribution of tasks using a backtracking approach. The backtracking has a complexity of O(2^N) in the worst case.\\n- Space Complexity: O(N), where N is the number of tasks. We use additional space for the workSessions array.\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```java\\nclass Solution {\\n    public int minSessions(int[] tasks, int sessionTime) {\\n        // Sort tasks in descending order to prioritize longer tasks\\n        Arrays.sort(tasks);\\n        reverse(tasks);\\n\\n        int left = 1; // Minimum session count\\n        int right = tasks.length; // Maximum session count\\n        int answer = 0; // Minimum number of sessions required\\n\\n        // Binary search on the range of possible session counts\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            int[] workSessions = new int[mid]; // Array to track tasks assigned to each session\\n\\n            // Check if it\\'s possible to complete all tasks within the given session count\\n            if (isPossible(0, mid, sessionTime, 0, tasks, workSessions, mid)) {\\n                answer = mid; // Update the answer\\n                right = mid - 1; // Continue searching for a smaller session count\\n            } else {\\n                left = mid + 1; // Increase the session count\\n            }\\n        }\\n\\n        return answer;\\n    }\\n\\n    // Backtracking function to simulate the distribution of tasks among sessions\\n    private static boolean isPossible(int idx, int k, int maxLen, int max, int[] tasks, int[] workSessions, int zeroCount) {\\n        if (tasks.length - idx < zeroCount) {\\n            return false; // Not enough tasks remaining to fill all sessions\\n        }\\n\\n        if (idx == tasks.length) {\\n            if (max > maxLen) {\\n                return false; // Current session duration exceeds the maximum session time\\n            }\\n            return true; // All tasks have been assigned to sessions successfully\\n        }\\n\\n        int currentTask = tasks[idx];\\n\\n        for (int i = 0; i < k; i++) {\\n            if (workSessions[i] + currentTask > maxLen) {\\n                continue; // Current task cannot be assigned to this session\\n            }\\n\\n            zeroCount -= workSessions[i] == 0 ? 1 : 0; // Decrement zeroCount if a session becomes non-empty\\n            workSessions[i] += currentTask; // Assign the task to the current session\\n\\n            // Recursively check if it\\'s possible to complete remaining tasks with the updated sessions\\n            if (isPossible(idx + 1, k, maxLen, Math.max(max, workSessions[i]), tasks, workSessions, zeroCount)) {\\n                return true; // Tasks can be completed with the current distribution of sessions\\n            }\\n\\n            workSessions[i] -= currentTask; // Backtrack: Remove the task from the current session\\n            zeroCount += workSessions[i] == 0 ? 1 : 0; // Increment zeroCount if a session becomes empty again\\n\\n            if (workSessions[i] == 0) {\\n                break; // Skip empty sessions to avoid redundant iterations\\n            }\\n        }\\n\\n        return false; // Unable to complete all tasks with the current distribution of sessions\\n    }\\n\\n    // Utility function to reverse an array\\n    private void reverse(int[] arr) {\\n        int i = 0, j = arr.length - 1;\\n\\n        while (i < j) {\\n            int temp = arr[i];\\n            arr[i] = arr[j];\\n            arr[j] = temp;\\n            i++;\\n            j--;\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2937235,
                "title": "golang-subset-traversal-problem",
                "content": "# Intuition\\n\\u8FD9\\u79CD\\u5C5E\\u4E8E\\u904D\\u5386\\u5B50\\u96C6\\u7684\\u95EE\\u9898 \\u6709\\u56FA\\u5B9A\\u7684\\u89E3\\u6CD5\\n# Complexity\\n- Time complexity: O(3^n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(2^n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc minSessions(tasks []int, sessionTime int) int {\\n    /* \\u904D\\u5386\\u5B50\\u96C6\\u7C7B\\u578B\\u95EE\\u9898 state: 00100011 \\u8868\\u793Atask 2 6 7 \\u88AB\\u9009\\u53D6\\n       dp[state]: Minimum Number of Work Sessions to Finish the state Tasks\\n       dp[state] = min(dp[state], dp[subset] + dp[state-subset])\\n       Time Complexity\\uFF1A O(3^n) \\u4EFB\\u4F55\\u4E00\\u4E2Atask\\u53EA\\u6709\\u53EF\\u80FD\\u5B58\\u57283\\u79CD\\u72B6\\u6001\\uFF1A\\n       1.\\u5728state\\u91CC\\u9762 \\u4E5F\\u5728subset\\u91CC  11\\n       2.\\u5728state\\u91CC\\u9762 \\u4E0D\\u5728subset\\u91CC  10\\n       3.\\u4E0D\\u5728state\\u91CC \\u4E0D\\u5728subset\\u91CC  00\\n    */\\n    num := len(tasks)\\n    dp := make([]int, 1 << num)\\n    for i := range dp {\\n        dp[i] = 15\\n    }\\n    // initialization \\u6240\\u6709\\u53EF\\u4EE5\\u4E00\\u4E2AsessionTime\\u91CC\\u5B8C\\u6210\\u7684sub tasks\\n    for state := 0; state < (1 << num); state++ {\\n        sumTime := 0\\n        for i := 0; i < num; i++ {\\n            if (state >> i) & 1 == 1 {\\n                sumTime += tasks[i]\\n            }\\n        }\\n        if sumTime <= sessionTime {\\n            dp[state] = 1\\n        }\\n    }\\n    /* \\u8F6C\\u79FB\\u65B9\\u7A0B substate\\u6BCF\\u6B21\\u51CF1\\uFF0C\\u7136\\u540E\\u548Cstate\\u53D6\\u5171\\u6709\\u7684tasks\\uFF0C\\n       \\u56E0\\u4E3A\\u662F\\u5728state\\u91CC\\u9762\\u53D6substate\\uFF0C state - substate\\u5C31\\u662F\\u5269\\u4E0B\\u6CA1\\u53D6\\u7684task\\n       eg\\uFF1A state\\uFF1A10010011  substate\\uFF1A10000001 \\u5269\\u4F59\\u6CA1\\u53D6\\u7684\\u5C31\\u662F 00010010\\n    */\\n    for state := 0; state < (1 << num); state++ {\\n        for substate := state; substate > 0; substate = (substate - 1) & state {\\n            dp[state] = min(dp[state], dp[state-substate] + dp[substate])\\n        }\\n    }\\n    return dp[(1<<num)-1]\\n}\\n\\nfunc min(i, j int) int {\\n    if i < j {\\n        return i\\n    }\\n    return j\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minSessions(tasks []int, sessionTime int) int {\\n    /* \\u904D\\u5386\\u5B50\\u96C6\\u7C7B\\u578B\\u95EE\\u9898 state: 00100011 \\u8868\\u793Atask 2 6 7 \\u88AB\\u9009\\u53D6\\n       dp[state]: Minimum Number of Work Sessions to Finish the state Tasks\\n       dp[state] = min(dp[state], dp[subset] + dp[state-subset])\\n       Time Complexity\\uFF1A O(3^n) \\u4EFB\\u4F55\\u4E00\\u4E2Atask\\u53EA\\u6709\\u53EF\\u80FD\\u5B58\\u57283\\u79CD\\u72B6\\u6001\\uFF1A\\n       1.\\u5728state\\u91CC\\u9762 \\u4E5F\\u5728subset\\u91CC  11\\n       2.\\u5728state\\u91CC\\u9762 \\u4E0D\\u5728subset\\u91CC  10\\n       3.\\u4E0D\\u5728state\\u91CC \\u4E0D\\u5728subset\\u91CC  00\\n    */\\n    num := len(tasks)\\n    dp := make([]int, 1 << num)\\n    for i := range dp {\\n        dp[i] = 15\\n    }\\n    // initialization \\u6240\\u6709\\u53EF\\u4EE5\\u4E00\\u4E2AsessionTime\\u91CC\\u5B8C\\u6210\\u7684sub tasks\\n    for state := 0; state < (1 << num); state++ {\\n        sumTime := 0\\n        for i := 0; i < num; i++ {\\n            if (state >> i) & 1 == 1 {\\n                sumTime += tasks[i]\\n            }\\n        }\\n        if sumTime <= sessionTime {\\n            dp[state] = 1\\n        }\\n    }\\n    /* \\u8F6C\\u79FB\\u65B9\\u7A0B substate\\u6BCF\\u6B21\\u51CF1\\uFF0C\\u7136\\u540E\\u548Cstate\\u53D6\\u5171\\u6709\\u7684tasks\\uFF0C\\n       \\u56E0\\u4E3A\\u662F\\u5728state\\u91CC\\u9762\\u53D6substate\\uFF0C state - substate\\u5C31\\u662F\\u5269\\u4E0B\\u6CA1\\u53D6\\u7684task\\n       eg\\uFF1A state\\uFF1A10010011  substate\\uFF1A10000001 \\u5269\\u4F59\\u6CA1\\u53D6\\u7684\\u5C31\\u662F 00010010\\n    */\\n    for state := 0; state < (1 << num); state++ {\\n        for substate := state; substate > 0; substate = (substate - 1) & state {\\n            dp[state] = min(dp[state], dp[state-substate] + dp[substate])\\n        }\\n    }\\n    return dp[(1<<num)-1]\\n}\\n\\nfunc min(i, j int) int {\\n    if i < j {\\n        return i\\n    }\\n    return j\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2357248,
                "title": "java-space-o-2-n-bottom-up-1d-dp",
                "content": "Saw a lot of the posts on the front most-upvoted page with 2D dp with space complexity `O(2^n * W)`. It\\'s unnecssary. We can do it in `O(2^n)` space.\\nBecause, for a given subset of tasks, there is only 1 optimal way - the minimum number of bin required and then followed by the minimum weight.\\nThere is no reason to try all the possible weights for the current bin subset. Try the best one will guarantee the optimal solution.\\n\\nFor example, bin `(0b101)` has a weight of `1`, and in another possibliity, bin `(0b101)`has a weight of 5. It is always more optimal to take the bin with weight of 1 and ignore the one with a weight of 5.\\n\\n#### Java\\n```Java\\n// Time Complexity O(2^n * n)\\n// Space O(2^n)\\nclass Solution {\\n    public int minSessions(int[] tasks, int sessionTime) {\\n        int n = tasks.length;\\n        int[] dp = new int[1<<n]; \\n        int[] w = new int[1<<n]; // best (min) weight for the current subset i\\n        Arrays.fill(dp, 100);\\n        Arrays.fill(w, 1000);\\n        dp[0]=0;\\n        for (int i = 1; i < 1<<n; i++){\\n            for (int j = 0; j < n; j++){\\n                if ((i & 1 << j) > 0){\\n                    int extra = 0, wh = w[i^1<<j]+tasks[j];\\n                    if (wh > sessionTime){ // need another bin\\n                        extra = 1;\\n                        wh=tasks[j];\\n                    }\\n                    dp[i] = Math.min(dp[i], dp[i^1<<j]+extra);\\n                    if (dp[i^1<<j]+extra==dp[i]){ // update weight to min\\n                        w[i]=Math.min(wh, w[i]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[(1<<n)-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```Java\\n// Time Complexity O(2^n * n)\\n// Space O(2^n)\\nclass Solution {\\n    public int minSessions(int[] tasks, int sessionTime) {\\n        int n = tasks.length;\\n        int[] dp = new int[1<<n]; \\n        int[] w = new int[1<<n]; // best (min) weight for the current subset i\\n        Arrays.fill(dp, 100);\\n        Arrays.fill(w, 1000);\\n        dp[0]=0;\\n        for (int i = 1; i < 1<<n; i++){\\n            for (int j = 0; j < n; j++){\\n                if ((i & 1 << j) > 0){\\n                    int extra = 0, wh = w[i^1<<j]+tasks[j];\\n                    if (wh > sessionTime){ // need another bin\\n                        extra = 1;\\n                        wh=tasks[j];\\n                    }\\n                    dp[i] = Math.min(dp[i], dp[i^1<<j]+extra);\\n                    if (dp[i^1<<j]+extra==dp[i]){ // update weight to min\\n                        w[i]=Math.min(wh, w[i]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[(1<<n)-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2275001,
                "title": "c-backtraking-without-dp-and-bitmasking-94-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSize = INT_MAX;\\n    void minHelper(vector<int> tasks,int time,int index,vector<int> assign){\\n        if(assign.size()>=minSize)return;\\n        \\n        if(index==tasks.size()){\\n            int size = assign.size();\\n            minSize = size<minSize?size:minSize;\\n            return;\\n        }\\n        \\n        assign.push_back(tasks[index]);\\n        minHelper(tasks,time,index+1,assign);\\n        assign.pop_back();\\n        \\n        for(int i=0;i<assign.size();i++){\\n            int task = tasks[index];\\n            if(assign[i]+task<=time){\\n                assign[i]+=task;\\n                minHelper(tasks,time,index+1,assign);\\n                assign[i]-=task;\\n            }\\n        }\\n        \\n    }\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        sort(tasks.begin(),tasks.end(),greater<int>());\\n        vector<int> assign;\\n        minHelper(tasks,sessionTime,0,assign);\\n        return minSize;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSize = INT_MAX;\\n    void minHelper(vector<int> tasks,int time,int index,vector<int> assign){\\n        if(assign.size()>=minSize)return;\\n        \\n        if(index==tasks.size()){\\n            int size = assign.size();\\n            minSize = size<minSize?size:minSize;\\n            return;\\n        }\\n        \\n        assign.push_back(tasks[index]);\\n        minHelper(tasks,time,index+1,assign);\\n        assign.pop_back();\\n        \\n        for(int i=0;i<assign.size();i++){\\n            int task = tasks[index];\\n            if(assign[i]+task<=time){\\n                assign[i]+=task;\\n                minHelper(tasks,time,index+1,assign);\\n                assign[i]-=task;\\n            }\\n        }\\n        \\n    }\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        sort(tasks.begin(),tasks.end(),greater<int>());\\n        vector<int> assign;\\n        minHelper(tasks,sessionTime,0,assign);\\n        return minSize;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2195348,
                "title": "1986-minimum-sessions-c-dp-with-bitmask-using-pairs",
                "content": "```\\ntypedef pair<int,int> pi;\\nclass Solution {\\npublic:\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        int n=tasks.size();\\n        pi masks[1<<n];\\n        masks[0]=make_pair(1,0);\\n        for(int i=1;i<1<<n;i++){\\n            masks[i]=pi{n+1,0};\\n            for(int j=0;j<n;j++){\\n                if((i&(1<<j)) > 0){\\n                    int oldmask=i - (1<<j);\\n                    pi t = masks[i];\\n                    if(masks[oldmask].second+tasks[j] <= sessionTime){\\n                        t.first = masks[oldmask].first;\\n                        t.second=masks[oldmask].second+tasks[j];\\n                    }else{\\n                        t.first = masks[oldmask].first+1;\\n                        t.second=tasks[j];\\n                    }\\n                    masks[i]=min(masks[i],t);\\n                }\\n            }\\n        }\\n        return masks[(1<<n) - 1].first;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef pair<int,int> pi;\\nclass Solution {\\npublic:\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        int n=tasks.size();\\n        pi masks[1<<n];\\n        masks[0]=make_pair(1,0);\\n        for(int i=1;i<1<<n;i++){\\n            masks[i]=pi{n+1,0};\\n            for(int j=0;j<n;j++){\\n                if((i&(1<<j)) > 0){\\n                    int oldmask=i - (1<<j);\\n                    pi t = masks[i];\\n                    if(masks[oldmask].second+tasks[j] <= sessionTime){\\n                        t.first = masks[oldmask].first;\\n                        t.second=masks[oldmask].second+tasks[j];\\n                    }else{\\n                        t.first = masks[oldmask].first+1;\\n                        t.second=tasks[j];\\n                    }\\n                    masks[i]=min(masks[i],t);\\n                }\\n            }\\n        }\\n        return masks[(1<<n) - 1].first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1975828,
                "title": "c-dp-top-down",
                "content": "```\\nclass Solution {\\npublic:\\n    typedef long long int64;\\n    int64 dp[1 << 15][16];\\n    int threshold;\\n    int64 solve(vector<int> &t, int mask, int currTime) {\\n        int n = t.size();\\n        if(mask == ((1 << n) - 1)) {\\n            return 1;\\n        }\\n        if(dp[mask][currTime] != -1) {\\n            return dp[mask][currTime];\\n        }\\n        int64 ans = 1 << 20;\\n        for(int i = 0; i < n; i++) {\\n            if((mask & (1 << i)) != 0) {\\n                continue;\\n            }\\n            // include in current session if possible\\n            if(currTime + t[i] <= threshold) {\\n                ans = min(ans, solve(t, mask | (1 << i), currTime + t[i]));\\n            }\\n            // use a new session\\n            ans = min(ans, (1LL + solve(t, mask | (1 << i), t[i])));\\n        }\\n        return dp[mask][currTime] = ans;\\n    }\\n    \\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        memset(dp, -1, sizeof(dp));\\n        threshold = sessionTime;\\n        return solve(tasks, 0, 0);\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long int64;\\n    int64 dp[1 << 15][16];\\n    int threshold;\\n    int64 solve(vector<int> &t, int mask, int currTime) {\\n        int n = t.size();\\n        if(mask == ((1 << n) - 1)) {\\n            return 1;\\n        }\\n        if(dp[mask][currTime] != -1) {\\n            return dp[mask][currTime];\\n        }\\n        int64 ans = 1 << 20;\\n        for(int i = 0; i < n; i++) {\\n            if((mask & (1 << i)) != 0) {\\n                continue;\\n            }\\n            // include in current session if possible\\n            if(currTime + t[i] <= threshold) {\\n                ans = min(ans, solve(t, mask | (1 << i), currTime + t[i]));\\n            }\\n            // use a new session\\n            ans = min(ans, (1LL + solve(t, mask | (1 << i), t[i])));\\n        }\\n        return dp[mask][currTime] = ans;\\n    }\\n    \\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        memset(dp, -1, sizeof(dp));\\n        threshold = sessionTime;\\n        return solve(tasks, 0, 0);\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1923026,
                "title": "sinkineben-c-binary-search-state-compression-dp",
                "content": "**Analysis**\\n\\nWe should put the `tasks` into `n` boxes, the size of each box is `sessionTime`. And we want to minimize such `n`.\\n\\n\\n\\n## Binary Search\\n\\n- The min number of sessions we need is `l = SUM(tasks) / sessionTime`.\\n- The max number of session we need is `n = tasks.size`.\\n- Perform a binary search on this range `[l, n]`, to test each `m` whether if it\\'s valid.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        int n = tasks.size();\\n        int total = accumulate(begin(tasks), end(tasks), 0);\\n        int l = total / sessionTime, r = n;\\n        while (l < r)\\n        {\\n            int m = l + (r - l) / 2;\\n            if (check(tasks, m, sessionTime)) r = m;\\n            else l = m + 1;\\n        }\\n        return l;\\n    }\\n    \\n    /* @sessions - The number of sessions.\\n     * @limit - Each session should have >= 1 task, but total time <= limit.\\n     */\\n    bool check(vector<int> &tasks, int sessions, int limit)\\n    {\\n        /* there are `sessions` work-sessions, and each session\\n         * `assign[i]` should be assigned with >= 1 task\\n         */\\n        vector<int> assign(sessions, 0);\\n        return backtrack(tasks, assign, 0, limit);\\n    }\\n\\n    bool backtrack(vector<int> &tasks, vector<int> &assign, int idx, int limit)\\n    {\\n        /* When all the tasks have been assigned, then return true. */\\n        int n = tasks.size();\\n        if (idx >= n) return true;\\n\\n        int task = tasks[idx];\\n        /* For each session `assign[i]`, try to put the `task` on it. */\\n        for (int &workload : assign)\\n        {\\n            if (workload + task <= limit)\\n            {\\n                workload += task;\\n                if (backtrack(tasks, assign, idx + 1, limit)) return true;\\n                workload -= task;\\n            }\\n            /* After assignments(backtracking), there is no task assigned to\\n             * current session, the false.\\n             */\\n            if (workload == 0) return false;\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n\\n\\n## State Compression DP\\n\\n**Get time of each subset**\\n\\n- Use an integer `x` to denote whether if `task[i]` is in the subset. If `(x >> j) & 1`, then `task[j]` is in the subset `x`.\\n\\n- Let `total[x]` denote the total time of tasks subset `x`, then we have\\n\\n  ```cpp\\n  total[x] = tasks[j] + total[x - (1 << j)] where ((x >> j) & 1) != 0\\n  ```\\n\\n**DP**\\n\\nLet `dp[x]` denote the min number of sessions, when we have a subset of tasks (denoted by `x`) . \\n\\nFor each subset `s` of `x`, we can assign `s` with a new session (if the `sessionTime` is large enough to put `s` in).\\n\\nThen we have\\n$$\\ndp[x] = \\\\min_{s \\\\sube x}\\\\{ {dp[x -s]} + 1 \\\\ \\\\ | \\\\ \\\\ \\\\text{total}[s] \\\\le \\\\text{sessionTime} \\\\}\\n$$\\n\\n```cpp\\nclass Solution {\\npublic:\\n    const int INF = INT_MAX / 2;\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        int n = tasks.size();\\n        vector<int> total(1 << n, 0);\\n        for (int x = 1; x < (1 << n); ++x)\\n        {\\n            int j = x & (-x);\\n            int idx = __builtin__ctz(j);\\n            total[x] = tasks[idx] + total[x - j];\\n        }\\n        vector<int> dp(1 << n, INF);\\n        dp[0] = 0;\\n        for (int x = 1; x < (1 << n); ++x)\\n        {\\n            for (int s = x; s; s = (s - 1) & x)\\n                if (total[s] <= sessionTime)\\n                \\tdp[x] = min(dp[x], dp[x - s] + 1);\\n        }\\n        return dp.back();\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        int n = tasks.size();\\n        int total = accumulate(begin(tasks), end(tasks), 0);\\n        int l = total / sessionTime, r = n;\\n        while (l < r)\\n        {\\n            int m = l + (r - l) / 2;\\n            if (check(tasks, m, sessionTime)) r = m;\\n            else l = m + 1;\\n        }\\n        return l;\\n    }\\n    \\n    /* @sessions - The number of sessions.\\n     * @limit - Each session should have >= 1 task, but total time <= limit.\\n     */\\n    bool check(vector<int> &tasks, int sessions, int limit)\\n    {\\n        /* there are `sessions` work-sessions, and each session\\n         * `assign[i]` should be assigned with >= 1 task\\n         */\\n        vector<int> assign(sessions, 0);\\n        return backtrack(tasks, assign, 0, limit);\\n    }\\n\\n    bool backtrack(vector<int> &tasks, vector<int> &assign, int idx, int limit)\\n    {\\n        /* When all the tasks have been assigned, then return true. */\\n        int n = tasks.size();\\n        if (idx >= n) return true;\\n\\n        int task = tasks[idx];\\n        /* For each session `assign[i]`, try to put the `task` on it. */\\n        for (int &workload : assign)\\n        {\\n            if (workload + task <= limit)\\n            {\\n                workload += task;\\n                if (backtrack(tasks, assign, idx + 1, limit)) return true;\\n                workload -= task;\\n            }\\n            /* After assignments(backtracking), there is no task assigned to\\n             * current session, the false.\\n             */\\n            if (workload == 0) return false;\\n        }\\n        return false;\\n    }\\n};\\n```\n```cpp\\n  total[x] = tasks[j] + total[x - (1 << j)] where ((x >> j) & 1) != 0\\n  ```\n```cpp\\nclass Solution {\\npublic:\\n    const int INF = INT_MAX / 2;\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        int n = tasks.size();\\n        vector<int> total(1 << n, 0);\\n        for (int x = 1; x < (1 << n); ++x)\\n        {\\n            int j = x & (-x);\\n            int idx = __builtin__ctz(j);\\n            total[x] = tasks[idx] + total[x - j];\\n        }\\n        vector<int> dp(1 << n, INF);\\n        dp[0] = 0;\\n        for (int x = 1; x < (1 << n); ++x)\\n        {\\n            for (int s = x; s; s = (s - 1) & x)\\n                if (total[s] <= sessionTime)\\n                \\tdp[x] = min(dp[x], dp[x - s] + 1);\\n        }\\n        return dp.back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1733258,
                "title": "c-backtracking-with-pruning-beats-95",
                "content": "```\\nclass Solution {\\nprivate:\\n    void backtrack(vector<int>&tasks,vector<int>&sessionTimes,int &ans,int index,int sessTime){\\n    if(sessionTimes.size()>=ans){\\n        return;\\n    } else if(index>=tasks.size()){\\n        ans=min(ans,(int)sessionTimes.size());\\n    } else {\\n        for(int i=0;i<sessionTimes.size();i++){\\n            if(sessionTimes[i]+tasks[index]<=sessTime){\\n                sessionTimes[i]=sessionTimes[i]+tasks[index];\\n                backtrack(tasks,sessionTimes,ans,index+1,sessTime);\\n                sessionTimes[i]=sessionTimes[i]-tasks[index];\\n            }\\n        }\\n        sessionTimes.push_back(tasks[index]);\\n        backtrack(tasks,sessionTimes,ans,index+1,sessTime);\\n        sessionTimes.pop_back();\\n    }\\n}\\npublic:\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        int ans=tasks.size();\\n        vector<int>sess;\\n        backtrack(tasks,sess,ans,0,sessionTime);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\nprivate:\\n    void backtrack(vector<int>&tasks,vector<int>&sessionTimes,int &ans,int index,int sessTime){\\n    if(sessionTimes.size()>=ans){\\n        return;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1679855,
                "title": "c-solution-backtracking-clean-and-concise",
                "content": "```\\nclass Solution {\\npublic:\\n    int mini;\\n    void backtrack(vector<int> tasks,int index,int st,int size,vector<int> count)\\n    {\\n        if(count.size()>mini)\\n            return;\\n        if(index==size)\\n        {\\n            mini=min(mini,(int)count.size() );\\n            return;\\n        }\\n        int sum=accumulate(tasks.begin()+index,tasks.end(),0);\\n        for(int i=0;i<count.size();i++)\\n        {\\n            if(count[i]+sum<=st)\\n            {\\n                backtrack(tasks,size,st,size,count);\\n                return;\\n            }\\n            if(count[i]+tasks[index]<=st)\\n            {\\n                count[i]+=tasks[index];\\n                backtrack(tasks,index+1,st,size,count);\\n                count[i]-=tasks[index];\\n            }\\n        }\\n        count.push_back(tasks[index]);\\n        backtrack(tasks,index+1,st,size,count);\\n        count.pop_back();\\n    }\\n    int minSessions(vector<int>& tasks, int sessionTime) \\n    {\\n        int n=tasks.size();\\n        sort(tasks.begin(),tasks.end(),greater<int>());\\n        if(accumulate(tasks.begin(),tasks.end(),0)<=sessionTime)\\n            return 1;\\n        vector<int> count; \\n        mini=INT_MAX;\\n        backtrack(tasks,0,sessionTime,n,count);\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mini;\\n    void backtrack(vector<int> tasks,int index,int st,int size,vector<int> count)\\n    {\\n        if(count.size()>mini)\\n            return;\\n        if(index==size)\\n        {\\n            mini=min(mini,(int)count.size() );\\n            return;\\n        }\\n        int sum=accumulate(tasks.begin()+index,tasks.end(),0);\\n        for(int i=0;i<count.size();i++)\\n        {\\n            if(count[i]+sum<=st)\\n            {\\n                backtrack(tasks,size,st,size,count);\\n                return;\\n            }\\n            if(count[i]+tasks[index]<=st)\\n            {\\n                count[i]+=tasks[index];\\n                backtrack(tasks,index+1,st,size,count);\\n                count[i]-=tasks[index];\\n            }\\n        }\\n        count.push_back(tasks[index]);\\n        backtrack(tasks,index+1,st,size,count);\\n        count.pop_back();\\n    }\\n    int minSessions(vector<int>& tasks, int sessionTime) \\n    {\\n        int n=tasks.size();\\n        sort(tasks.begin(),tasks.end(),greater<int>());\\n        if(accumulate(tasks.begin(),tasks.end(),0)<=sessionTime)\\n            return 1;\\n        vector<int> count; \\n        mini=INT_MAX;\\n        backtrack(tasks,0,sessionTime,n,count);\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1669856,
                "title": "c-recursion-memoization-with-bitmasking",
                "content": "```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<int> tasks;\\n    int sessionTime;\\n\\n    int bitMask;  //the standard BitMask\\n    \\n    vector<vector<int>> f; // the memoization matrix \\n\\n    int memo(int taskNo, int timeRemain){\\n        /*\\n        - taskNo: of all the remaining tasks, which task must be done as the \\'taskNo\\'th task\\n            Eg. TaskNo: 0, 1, 2, 3, 4, 5, 6....\\n            Tasks(i=) : 7, 10,5, 4, 13, 3,1...\\n            \\n            Note: taskNo is actually a function of bitMask\\n            \\n            ==> Note: taskNo = Number of 1\\'s in the bitMask\\n            \\n        - timeRemain: time time remaining/available in the current session\\n        */\\n        \\n        if(f[bitMask][timeRemain] != -1) return f[bitMask][timeRemain];\\n        \\n        \\n        if(taskNo == n)\\n            return  f[bitMask][timeRemain]=  0; // all tasks done!\\n        \\n        int mini = INT_MAX;\\n\\n        \\n        //Which task should I do as the \\'taskNo\\'th task?\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            //Is task[i] yet to be done?\\n            \\n            if( (bitMask & (1 << i)) == 0){ //Yes!, i\\'th task has yet to be done \\n                \\n                \\n                //Can I do task[i] in the current session ?\\n                \\n                if(tasks[i] <= timeRemain){  //Yes, you can!\\n                    \\n                    bitMask = (bitMask | (1 << i)); //since we\\'re doing task[i], set the i\\'th LSB\\n                    \\n                    //Option1. Do task[i] as the \\'taskNo\\'th task in current session\\n                    int a = memo(taskNo+1, timeRemain-tasks[i]);\\n                    \\n                    //Option2. End this session, and do task[i] as the \\'taskNo\\'th task in the next session\\n                    int b = 1 + memo(taskNo+1, sessionTime - tasks[i]);\\n                    \\n                    bitMask = (bitMask & (~(1 << i))); //BackTracking!, unset the i\\'th LSB\\n           \\n                    //the minimum sessions needed b/w option1 & option2\\n                    mini = min(mini, min(a, b));\\n                }\\n                else{ //No, I cannot do task[i] in the current session\\n                    \\n                    bitMask = (bitMask | (1 << i)); //since we\\'re doing task[i], set the i\\'th LSB\\n                    \\n                    //Hence, end this session here, and do it in the next session\\n                    int c = 1 + memo(taskNo+1, sessionTime - tasks[i]);\\n                    \\n                    bitMask = (bitMask & (~(1 << i))); //BackTracking!, unset the i\\'th LSB\\n                    \\n                    mini = min(mini, c);             \\n                }\\n            }\\n        }\\n        \\n        \\n        return  f[bitMask][timeRemain]=  mini;\\n    }\\n\\n\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        this->tasks = tasks;\\n        this->n = tasks.size();\\n        this->sessionTime = sessionTime;\\n\\n        this->bitMask = 0;\\n        this->f.resize((1<<n), vector<int>(sessionTime + 1, -1));\\n        \\n        return 1 + memo(0,sessionTime);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<int> tasks;\\n    int sessionTime;\\n\\n    int bitMask;  //the standard BitMask\\n    \\n    vector<vector<int>> f; // the memoization matrix \\n\\n    int memo(int taskNo, int timeRemain){\\n        /*\\n        - taskNo: of all the remaining tasks, which task must be done as the \\'taskNo\\'th task\\n            Eg. TaskNo: 0, 1, 2, 3, 4, 5, 6....\\n            Tasks(i=) : 7, 10,5, 4, 13, 3,1...\\n            \\n            Note: taskNo is actually a function of bitMask\\n            \\n            ==> Note: taskNo = Number of 1\\'s in the bitMask\\n            \\n        - timeRemain: time time remaining/available in the current session\\n        */\\n        \\n        if(f[bitMask][timeRemain] != -1) return f[bitMask][timeRemain];\\n        \\n        \\n        if(taskNo == n)\\n            return  f[bitMask][timeRemain]=  0; // all tasks done!\\n        \\n        int mini = INT_MAX;\\n\\n        \\n        //Which task should I do as the \\'taskNo\\'th task?\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            //Is task[i] yet to be done?\\n            \\n            if( (bitMask & (1 << i)) == 0){ //Yes!, i\\'th task has yet to be done \\n                \\n                \\n                //Can I do task[i] in the current session ?\\n                \\n                if(tasks[i] <= timeRemain){  //Yes, you can!\\n                    \\n                    bitMask = (bitMask | (1 << i)); //since we\\'re doing task[i], set the i\\'th LSB\\n                    \\n                    //Option1. Do task[i] as the \\'taskNo\\'th task in current session\\n                    int a = memo(taskNo+1, timeRemain-tasks[i]);\\n                    \\n                    //Option2. End this session, and do task[i] as the \\'taskNo\\'th task in the next session\\n                    int b = 1 + memo(taskNo+1, sessionTime - tasks[i]);\\n                    \\n                    bitMask = (bitMask & (~(1 << i))); //BackTracking!, unset the i\\'th LSB\\n           \\n                    //the minimum sessions needed b/w option1 & option2\\n                    mini = min(mini, min(a, b));\\n                }\\n                else{ //No, I cannot do task[i] in the current session\\n                    \\n                    bitMask = (bitMask | (1 << i)); //since we\\'re doing task[i], set the i\\'th LSB\\n                    \\n                    //Hence, end this session here, and do it in the next session\\n                    int c = 1 + memo(taskNo+1, sessionTime - tasks[i]);\\n                    \\n                    bitMask = (bitMask & (~(1 << i))); //BackTracking!, unset the i\\'th LSB\\n                    \\n                    mini = min(mini, c);             \\n                }\\n            }\\n        }\\n        \\n        \\n        return  f[bitMask][timeRemain]=  mini;\\n    }\\n\\n\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        this->tasks = tasks;\\n        this->n = tasks.size();\\n        this->sessionTime = sessionTime;\\n\\n        this->bitMask = 0;\\n        this->f.resize((1<<n), vector<int>(sessionTime + 1, -1));\\n        \\n        return 1 + memo(0,sessionTime);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1627054,
                "title": "c-easy-solution",
                "content": "\\tpublic class Solution\\n\\t{\\n\\t\\tpublic int MinSessions(int[] tasks, int sessionTime)\\n\\t\\t{\\n\\t\\t\\tint[,] dp = new int[(1 << tasks.Length), sessionTime + 1];\\n\\t\\t\\treturn Solve(tasks, sessionTime, dp, 0, 0);\\n\\t\\t}\\n\\n\\t\\tpublic int Solve(int[] tasks, int sessionTime, int[,] dp, int taken, int currTime)\\n\\t\\t{\\n\\t\\t\\tif (taken == (1 << tasks.Length) - 1)\\n\\t\\t\\t\\treturn 1;\\n\\n\\t\\t\\tif (dp[taken, currTime] != 0)\\n\\t\\t\\t\\treturn dp[taken, currTime];\\n\\n\\t\\t\\tint ans = int.MaxValue;\\n\\t\\t\\tfor(int i = 0; i < tasks.Length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif ((taken & (1 << i)) > 0)\\n\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\tif (currTime + tasks[i] <= sessionTime)\\n\\t\\t\\t\\t\\tans = Math.Min(ans, Solve(tasks, sessionTime, dp, taken | (1 << i), currTime + tasks[i]));\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tans = Math.Min(ans, 1 + Solve(tasks, sessionTime, dp, taken | (1 << i), tasks[i]));\\n\\t\\t\\t}\\n\\n\\t\\t\\tdp[taken, currTime] = ans;\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Backtracking",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "class Solution\\n\\t{\\n\\t\\tpublic int MinSessions(int[] tasks, int sessionTime)\\n\\t\\t{\\n\\t\\t\\tint[,] dp = new int[(1 << tasks.Length), sessionTime + 1];\\n\\t\\t\\treturn Solve(tasks, sessionTime, dp, 0, 0);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1559543,
                "title": "simple-c-using-dp",
                "content": "```\\nint minSessions_(int idx, int mask, int left, vector<int>& tasks, int sessionTime, vector<vector<int>>& dp) {\\n    \\n    if (mask == ((1 << tasks.size()) - 1))\\n        return 0;\\n    \\n    if (dp[left][mask] < INT_MAX) return dp[left][mask];\\n    \\n    int tot = INT_MAX;\\n    \\n    for (int i = 0; i < tasks.size(); ++i) {\\n        if (mask & (1 << i)) continue;\\n        if (tasks[i] > left) continue;\\n        tot = min(tot, minSessions_(i + 1, mask | (1 << i), left - tasks[i], tasks, sessionTime, dp));\\n    }\\n    \\n    if (tot == INT_MAX)\\n        tot = 1 + minSessions_(0, mask, sessionTime, tasks, sessionTime, dp);\\n    \\n    dp[left][mask] = tot;\\n    \\n    return tot;\\n}\\n\\nint minSessions(vector<int>& tasks, int sessionTime) {\\n    \\n    vector<vector<int>> dp(sessionTime + 1, vector<int>(1 << tasks.size(), INT_MAX));\\n    \\n    return minSessions_(0, 0, 0, tasks, sessionTime, dp);\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint minSessions_(int idx, int mask, int left, vector<int>& tasks, int sessionTime, vector<vector<int>>& dp) {\\n    \\n    if (mask == ((1 << tasks.size()) - 1))\\n        return 0;\\n    \\n    if (dp[left][mask] < INT_MAX) return dp[left][mask];\\n    \\n    int tot = INT_MAX;\\n    \\n    for (int i = 0; i < tasks.size(); ++i) {\\n        if (mask & (1 << i)) continue;\\n        if (tasks[i] > left) continue;\\n        tot = min(tot, minSessions_(i + 1, mask | (1 << i), left - tasks[i], tasks, sessionTime, dp));\\n    }\\n    \\n    if (tot == INT_MAX)\\n        tot = 1 + minSessions_(0, mask, sessionTime, tasks, sessionTime, dp);\\n    \\n    dp[left][mask] = tot;\\n    \\n    return tot;\\n}\\n\\nint minSessions(vector<int>& tasks, int sessionTime) {\\n    \\n    vector<vector<int>> dp(sessionTime + 1, vector<int>(1 << tasks.size(), INT_MAX));\\n    \\n    return minSessions_(0, 0, 0, tasks, sessionTime, dp);\\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1536913,
                "title": "python-backtracking-about-280ms-and-very-low-space-complexity",
                "content": "This was directly inspired by this solution:  https://leetcode.com/problems/minimum-number-of-work-sessions-to-finish-the-tasks/discuss/1433054/Python-or-Backtracking-or-664ms-or-100-time-and-space-or-Explanation\\n\\nBasically the idea is to formulate it as a problem of finding least number of sessions such that their sum is at most equal to session time.\\n\\nSo for every value, we have two choices:\\n\\t1. add it to any one of the sessions we\\'ve already made without exceeding the session time total\\n\\t2. put it in its own session\\n\\nWe try these choices in all combinations to find the least number.\\n\\nA couple of optimizations can be made to make the solution faster in certain cases.\\n\\nThe hardest part was figuring out looping over tasks will get you TLE. It is the sessions you need to loop over.\\n\\n```python\\nclass Solution:\\n    def minSessions(self, tasks: List[int], sessionTime: int) -> int:\\n\\t\\n        # if sum fully divisible, the answer can be directly calculated\\n        total_tasks = sum(tasks)\\n        quotient, remainder = divmod(total_tasks, sessionTime)\\n        \\n        sessions = []\\n        ans = len(tasks)  # cant be more sessions so start with that\\n        least_num_sessions = quotient + (remainder > 0)  # incase of a non-zero remainder, this is the least number of sessions possible\\n        \\n        def dfs(idx):\\n            nonlocal ans\\n            if len(sessions) >= ans:\\n                return\\n            \\n            if idx == len(tasks):\\n                if ans == least_num_sessions:\\n                    return True  # cant be lower so stop searching\\n                ans = min(ans, len(sessions))\\n                return\\n            \\n            # check if this value fits in any of the existing sessions\\n            for i in range(len(sessions)):\\n                if sessions[i] + tasks[idx] <= sessionTime:\\n                    sessions[i] += tasks[idx]\\n                    if dfs(idx + 1):\\n                        return True\\n                    sessions[i] -= tasks[idx]\\n            \\n            # give value its own session\\n            sessions.append(tasks[idx])\\n            if dfs(idx + 1):\\n                return True\\n            sessions.pop()\\n        \\n        dfs(0)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```python\\nclass Solution:\\n    def minSessions(self, tasks: List[int], sessionTime: int) -> int:\\n\\t\\n        # if sum fully divisible, the answer can be directly calculated\\n        total_tasks = sum(tasks)\\n        quotient, remainder = divmod(total_tasks, sessionTime)\\n        \\n        sessions = []\\n        ans = len(tasks)  # cant be more sessions so start with that\\n        least_num_sessions = quotient + (remainder > 0)  # incase of a non-zero remainder, this is the least number of sessions possible\\n        \\n        def dfs(idx):\\n            nonlocal ans\\n            if len(sessions) >= ans:\\n                return\\n            \\n            if idx == len(tasks):\\n                if ans == least_num_sessions:\\n                    return True  # cant be lower so stop searching\\n                ans = min(ans, len(sessions))\\n                return\\n            \\n            # check if this value fits in any of the existing sessions\\n            for i in range(len(sessions)):\\n                if sessions[i] + tasks[idx] <= sessionTime:\\n                    sessions[i] += tasks[idx]\\n                    if dfs(idx + 1):\\n                        return True\\n                    sessions[i] -= tasks[idx]\\n            \\n            # give value its own session\\n            sessions.append(tasks[idx])\\n            if dfs(idx + 1):\\n                return True\\n            sessions.pop()\\n        \\n        dfs(0)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1517718,
                "title": "c-backtracking-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int minSes(int session,long long int completedTasks,vector<int>& tasks,int sessionTime,vector<vector<int>>& dp)\\n    {\\n        int n = tasks.size();\\n        \\n        if(completedTasks==(pow(2,n)-1))\\n        {\\n            return dp[session][completedTasks]=1;\\n        }\\n        \\n        if(dp[session][completedTasks]!=-1)\\n            return dp[session][completedTasks];\\n            \\n        bool isAvail = false;\\n        int minSessions = INT_MAX;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if((completedTasks&(1<<i))==0 && tasks[i]<=session)\\n            {\\n                isAvail = true;\\n                minSessions = min(minSessions,minSes(session-tasks[i],completedTasks|(1<<i),tasks,sessionTime,dp));\\n            }\\n        }\\n        \\n        if(!isAvail)\\n        {\\n            return dp[session][completedTasks]=1+minSes(sessionTime,completedTasks,tasks,sessionTime,dp);\\n        }\\n        \\n        return dp[session][completedTasks]=minSessions;\\n    }\\n    \\n    int minSessions(vector<int>& tasks, int sessionTime)\\n    {\\n        long long int completedTasks = 0,n=tasks.size();\\n        vector<vector<int>> dp(sessionTime+5,vector<int>((1<<(n+1))+3,-1));\\n        \\n        return minSes(sessionTime,completedTasks,tasks,sessionTime,dp);\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minSes(int session,long long int completedTasks,vector<int>& tasks,int sessionTime,vector<vector<int>>& dp)\\n    {\\n        int n = tasks.size();\\n        \\n        if(completedTasks==(pow(2,n)-1))\\n        {\\n            return dp[session][completedTasks]=1;\\n        }\\n        \\n        if(dp[session][completedTasks]!=-1)\\n            return dp[session][completedTasks];\\n            \\n        bool isAvail = false;\\n        int minSessions = INT_MAX;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if((completedTasks&(1<<i))==0 && tasks[i]<=session)\\n            {\\n                isAvail = true;\\n                minSessions = min(minSessions,minSes(session-tasks[i],completedTasks|(1<<i),tasks,sessionTime,dp));\\n            }\\n        }\\n        \\n        if(!isAvail)\\n        {\\n            return dp[session][completedTasks]=1+minSes(sessionTime,completedTasks,tasks,sessionTime,dp);\\n        }\\n        \\n        return dp[session][completedTasks]=minSessions;\\n    }\\n    \\n    int minSessions(vector<int>& tasks, int sessionTime)\\n    {\\n        long long int completedTasks = 0,n=tasks.size();\\n        vector<vector<int>> dp(sessionTime+5,vector<int>((1<<(n+1))+3,-1));\\n        \\n        return minSes(sessionTime,completedTasks,tasks,sessionTime,dp);\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1438628,
                "title": "c-dp-with-bitmask",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[1<<14+1][16];\\n    int solve(vector<int>&tasks, int n, int mask, int time, int t){\\n        if(time>t)\\n            return INT_MAX;\\n        if(mask==0)\\n            return 1;\\n        if(dp[mask][time]!=-1)\\n            return dp[mask][time];\\n        \\n        //for each task, there are 2 options\\n        //include in the ongoing session\\n        //start a new session\\n        \\n        int ans = INT_MAX;\\n        for(int i=0;i<n;i++){\\n            if(mask & (1<<i)){\\n                int ongoing = solve(tasks,n,mask^(1<<i),time+tasks[i],t);\\n                int newSession = 1+solve(tasks,n,mask^(1<<i),tasks[i],t);\\n                ans = min(ans,min(ongoing,newSession));\\n            }\\n        }\\n        return dp[mask][time] = ans;\\n        \\n    }\\n    int minSessions(vector<int>& tasks, int t) {\\n        int n=tasks.size();\\n        int mask=(1<<n)-1;\\n        memset(dp,-1,sizeof(dp));\\n        int ans=solve(tasks,n,mask,0,t);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1<<14+1][16];\\n    int solve(vector<int>&tasks, int n, int mask, int time, int t){\\n        if(time>t)\\n            return INT_MAX;\\n        if(mask==0)\\n            return 1;\\n        if(dp[mask][time]!=-1)\\n            return dp[mask][time];\\n        \\n        //for each task, there are 2 options\\n        //include in the ongoing session\\n        //start a new session\\n        \\n        int ans = INT_MAX;\\n        for(int i=0;i<n;i++){\\n            if(mask & (1<<i)){\\n                int ongoing = solve(tasks,n,mask^(1<<i),time+tasks[i],t);\\n                int newSession = 1+solve(tasks,n,mask^(1<<i),tasks[i],t);\\n                ans = min(ans,min(ongoing,newSession));\\n            }\\n        }\\n        return dp[mask][time] = ans;\\n        \\n    }\\n    int minSessions(vector<int>& tasks, int t) {\\n        int n=tasks.size();\\n        int mask=(1<<n)-1;\\n        memset(dp,-1,sizeof(dp));\\n        int ans=solve(tasks,n,mask,0,t);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1436906,
                "title": "c-short-general-code-with-o-3-n",
                "content": "Create all possible subsets and keep assigning valid ones to sessions:\\n```\\nclass Solution {\\n    // sumMap is for faster subSet sum lookup:\\n    int getSum(int mask, const std::vector<int> &tasks, const int n)\\n    {\\n        int sum = 0;\\n        for(int i = 0; i < n && mask; ++i) {\\n            sum += (mask &1) ? tasks[i] : 0;\\n            mask >>= 1;\\n        }\\n        return sum;\\n    }   \\n    int enumerate(int state, std::vector<int> &resultMap, const std::vector<int> &sumMap,  const int sessionTime)\\n    {\\n        if(state == 0) return 0;\\n        if(resultMap[state] != -1) return resultMap[state];\\n        int result = INT_MAX;\\n        for (int s=state; s ; s=(s-1)&state) {\\n            if(sumMap[s] <= sessionTime) {\\n                result = std::min(result, 1+enumerate(state-s,resultMap,sumMap,sessionTime));\\n            }\\n        }\\n        return resultMap[state]=result;\\n    }\\npublic:\\t\\n    int minSessions(const std::vector<int> &tasks, const int sessionTime)\\n    {\\n        int n      = tasks.size();\\n        int state  = (1<<n)-1;\\n        \\n        std::vector<int> resultMap(std::vector<int>(1<<n, -1)); //result from each state\\n        std::vector<int> sumMap(1<<n,0);  // sum for each state.  \\n        for (int s=state; s ; s=(s-1)&state) sumMap[s] = getSum(s,tasks,n);\\n        return enumerate(state, resultMap,sumMap,sessionTime);\\n    }\\n};\\n```\\nComplexity is O(3^n) .. See this for details: https://cp-algorithms.com/algebra/all-submasks.html .\\n\\nI think this general approach is more effective from learning point of view. \\nLet me know if something is missing.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // sumMap is for faster subSet sum lookup:\\n    int getSum(int mask, const std::vector<int> &tasks, const int n)\\n    {\\n        int sum = 0;\\n        for(int i = 0; i < n && mask; ++i) {\\n            sum += (mask &1) ? tasks[i] : 0;\\n            mask >>= 1;\\n        }\\n        return sum;\\n    }   \\n    int enumerate(int state, std::vector<int> &resultMap, const std::vector<int> &sumMap,  const int sessionTime)\\n    {\\n        if(state == 0) return 0;\\n        if(resultMap[state] != -1) return resultMap[state];\\n        int result = INT_MAX;\\n        for (int s=state; s ; s=(s-1)&state) {\\n            if(sumMap[s] <= sessionTime) {\\n                result = std::min(result, 1+enumerate(state-s,resultMap,sumMap,sessionTime));\\n            }\\n        }\\n        return resultMap[state]=result;\\n    }\\npublic:\\t\\n    int minSessions(const std::vector<int> &tasks, const int sessionTime)\\n    {\\n        int n      = tasks.size();\\n        int state  = (1<<n)-1;\\n        \\n        std::vector<int> resultMap(std::vector<int>(1<<n, -1)); //result from each state\\n        std::vector<int> sumMap(1<<n,0);  // sum for each state.  \\n        for (int s=state; s ; s=(s-1)&state) sumMap[s] = getSum(s,tasks,n);\\n        return enumerate(state, resultMap,sumMap,sessionTime);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1435838,
                "title": "java-binary-search-2ms-solution-same-as-problem-1723-find-minimum-time-to-finish-all-jobs",
                "content": "1986. Minimum Number of Work Sessions to Finish the Tasks\\n```\\n    public int minSessions(int[] tasks, int sessionTime) {\\n        Arrays.sort(tasks);\\n        int lo = 1, hi = tasks.length;\\n\\n        while (lo < hi) {\\n            int numSessions = (lo + hi) / 2;\\n            if (canSchedule(tasks, new int[numSessions], tasks.length - 1, sessionTime))\\n                hi = numSessions;\\n            else\\n                lo = numSessions + 1;\\n        }\\n        return lo;\\n    }\\n\\n    private boolean canSchedule(int[] tasks, int[] sessions, int taskIdx, int sessionTime) {\\n        if (taskIdx == -1) return true;\\n\\n        Set<Integer> set = new HashSet<>();\\n        for (int i = 0; i < sessions.length; i++) {\\n            if (!set.add(sessions[i])) continue;\\n            if (tasks[taskIdx] + sessions[i] > sessionTime) continue;\\n\\n            sessions[i] += tasks[taskIdx];\\n            if (canSchedule(tasks, sessions, taskIdx - 1, sessionTime))\\n                return true;\\n            sessions[i] -= tasks[taskIdx];\\n        }\\n\\n        return false;\\n    }\\n```\\n\\n1723. Find Minimum Time to Finish All Jobs\\n```\\n        public int minimumTimeRequired(int[] jobs, int workers) {\\n            Arrays.sort(jobs);\\n            int n = jobs.length;\\n            int lo = jobs[n - 1], hi = Arrays.stream(jobs).sum();\\n\\n            while (lo < hi) {\\n                int maxTime = lo + (hi - lo) / 2;\\n                if (canSchedule(jobs, new int[workers], n - 1, maxTime))\\n                    hi = maxTime;\\n                else\\n                    lo = maxTime + 1;\\n            }\\n            return lo;\\n        }\\n\\n        private boolean canSchedule(int[] jobs, int[] workload, int jobIdx, int maxTime) {\\n            if (jobIdx == -1) return true;\\n\\n            Set<Integer> set = new HashSet<>();\\n            for (int i = 0; i < workload.length; i++) {\\n                if (!set.add(workload[i])) continue;\\n                if (jobs[jobIdx] + workload[i] > maxTime) continue;\\n\\n                workload[i] += jobs[jobIdx];\\n                if (canSchedule(jobs, workload, jobIdx - 1, maxTime))\\n                    return true;\\n                workload[i] -= jobs[jobIdx];\\n            }\\n\\n            return false;\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int minSessions(int[] tasks, int sessionTime) {\\n        Arrays.sort(tasks);\\n        int lo = 1, hi = tasks.length;\\n\\n        while (lo < hi) {\\n            int numSessions = (lo + hi) / 2;\\n            if (canSchedule(tasks, new int[numSessions], tasks.length - 1, sessionTime))\\n                hi = numSessions;\\n            else\\n                lo = numSessions + 1;\\n        }\\n        return lo;\\n    }\\n\\n    private boolean canSchedule(int[] tasks, int[] sessions, int taskIdx, int sessionTime) {\\n        if (taskIdx == -1) return true;\\n\\n        Set<Integer> set = new HashSet<>();\\n        for (int i = 0; i < sessions.length; i++) {\\n            if (!set.add(sessions[i])) continue;\\n            if (tasks[taskIdx] + sessions[i] > sessionTime) continue;\\n\\n            sessions[i] += tasks[taskIdx];\\n            if (canSchedule(tasks, sessions, taskIdx - 1, sessionTime))\\n                return true;\\n            sessions[i] -= tasks[taskIdx];\\n        }\\n\\n        return false;\\n    }\\n```\n```\\n        public int minimumTimeRequired(int[] jobs, int workers) {\\n            Arrays.sort(jobs);\\n            int n = jobs.length;\\n            int lo = jobs[n - 1], hi = Arrays.stream(jobs).sum();\\n\\n            while (lo < hi) {\\n                int maxTime = lo + (hi - lo) / 2;\\n                if (canSchedule(jobs, new int[workers], n - 1, maxTime))\\n                    hi = maxTime;\\n                else\\n                    lo = maxTime + 1;\\n            }\\n            return lo;\\n        }\\n\\n        private boolean canSchedule(int[] jobs, int[] workload, int jobIdx, int maxTime) {\\n            if (jobIdx == -1) return true;\\n\\n            Set<Integer> set = new HashSet<>();\\n            for (int i = 0; i < workload.length; i++) {\\n                if (!set.add(workload[i])) continue;\\n                if (jobs[jobIdx] + workload[i] > maxTime) continue;\\n\\n                workload[i] += jobs[jobIdx];\\n                if (canSchedule(jobs, workload, jobIdx - 1, maxTime))\\n                    return true;\\n                workload[i] -= jobs[jobIdx];\\n            }\\n\\n            return false;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1435085,
                "title": "c-runtime-0ms-sometimes-4ms-beats-100-size-7-6-mb-beats-100-dp-subset-sum",
                "content": "**Time Complexity: O(s*n^2)**, s=sessionTime, n= tasks length\\n\\nLets take this example **tasks=[2,3,4,4,5,6,7,10], sessionTime=12**\\n\\nWe can store number of times an element is appearing in tasks, to a vector (like a hash map).\\nLets create **hashVector=[0,0,1,1,2,1,1,1,0,0,1]** for elements 0 to 10 and initialise our answer as **ans=0**\\n\\nWe select elements from tasks having maximum sum upto **sessionTime** to create a new session for them. We can use DP to check **maxSum** and elements adding to **maxSum** as used in [Subset sum problem](http://leetcode.com/problems/partition-equal-subset-sum/) in a loop. We will update **hashVector** & loop until no task is remaining.\\n\\nUpdates after every loop:\\n* **Loop 1:** tasks=[2,3,4,4,5,6,7,10], **maxSum**=12, elements taken out to form a new session=(2,10), **ans=1**\\n* **Loop 2:** tasks=[3,4,4,5,6,7], **maxSum**=12, elements taken out to form a new session=(5,7), **ans=2**\\n* **Loop 3:** tasks=[3,4,4,6], **maxSum**=11, elements taken out to form a new session=(3,4,4), **ans=3**\\n* **Loop 4:** tasks=[6], **maxSum**=6, elements taken out to form a new session=(6), **ans=4**.\\n* **Loop 5:** tasks=[], loop breaks.\\n\\nAfter tasks=[], loop will not run.\\n\\n```\\nclass Solution {\\npublic:\\n    bool tasksRemaining(vector<int>& v, int s){\\n\\t\\t// Vector to store remaining tasks\\n        vector<int> vec;\\n        for(int i=1;i<v.size();i++){\\n            int count=v[i];\\n            while(count--) vec.push_back(i);\\n        }\\n        int n=vec.size();\\n\\t\\t// If no tasks remaining\\n        if(n==0) return false;\\n\\t\\t\\n\\t\\t// DP like subset sum problem\\n        bool dp[n+1][s+1];\\n\\t\\t// Max sum upto sessionTime from the remaining tasks\\n        int maxSum=0;\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<s+1;j++){\\n                if(j==0) dp[i][j]=true;\\n                else if(i==0) dp[i][j]=false;\\n                else{\\n                    if(vec[i-1]>j) dp[i][j]=dp[i-1][j];\\n                    else dp[i][j]=(dp[i-1][j]||dp[i-1][j-vec[i-1]]);\\n                }\\n                if(i==n && dp[i][j]) maxSum=j;\\n            }\\n        }\\n\\t\\t\\n\\t\\t// Selecting elements adding to \"maxSum\"\\n        int i=n;\\n        while(maxSum){\\n            while(vec[i-1]>maxSum) i--;\\n            if(dp[i-1][maxSum-vec[i-1]]){\\n\\t\\t\\t\\t// Removing them from hashVector\\n                v[vec[i-1]]--;\\n                maxSum-=vec[i-1];\\n            }\\n            i--;\\n        }\\n        return true;\\n    }\\n    \\n    int minSessions(vector<int>& t, int s) {\\n        int n=t.size(),ans=0,m=0;\\n        for(int i=0;i<n;i++) \\n\\t\\t\\tm=max(m,t[i]);\\n\\t\\t\\n\\t\\t// Create hash vector of size \"m+1\"(max element of array+1)\\n        vector<int> v(m+1,0);\\n        for(int i=0;i<n;i++)\\n            v[t[i]]++;\\n\\t\\t\\t\\n\\t\\t// Loop until all tasks are not done\\n        while(tasksRemaining(v,s)) ans++;\\n        return ans;\\n    }\\n};\\n```\\n\\nFeel free to correct me or add any improvements.\\nThis is my first post, please upvote if you like the solution",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool tasksRemaining(vector<int>& v, int s){\\n\\t\\t// Vector to store remaining tasks\\n        vector<int> vec;\\n        for(int i=1;i<v.size();i++){\\n            int count=v[i];\\n            while(count--) vec.push_back(i);\\n        }\\n        int n=vec.size();\\n\\t\\t// If no tasks remaining\\n        if(n==0) return false;\\n\\t\\t\\n\\t\\t// DP like subset sum problem\\n        bool dp[n+1][s+1];\\n\\t\\t// Max sum upto sessionTime from the remaining tasks\\n        int maxSum=0;\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<s+1;j++){\\n                if(j==0) dp[i][j]=true;\\n                else if(i==0) dp[i][j]=false;\\n                else{\\n                    if(vec[i-1]>j) dp[i][j]=dp[i-1][j];\\n                    else dp[i][j]=(dp[i-1][j]||dp[i-1][j-vec[i-1]]);\\n                }\\n                if(i==n && dp[i][j]) maxSum=j;\\n            }\\n        }\\n\\t\\t\\n\\t\\t// Selecting elements adding to \"maxSum\"\\n        int i=n;\\n        while(maxSum){\\n            while(vec[i-1]>maxSum) i--;\\n            if(dp[i-1][maxSum-vec[i-1]]){\\n\\t\\t\\t\\t// Removing them from hashVector\\n                v[vec[i-1]]--;\\n                maxSum-=vec[i-1];\\n            }\\n            i--;\\n        }\\n        return true;\\n    }\\n    \\n    int minSessions(vector<int>& t, int s) {\\n        int n=t.size(),ans=0,m=0;\\n        for(int i=0;i<n;i++) \\n\\t\\t\\tm=max(m,t[i]);\\n\\t\\t\\n\\t\\t// Create hash vector of size \"m+1\"(max element of array+1)\\n        vector<int> v(m+1,0);\\n        for(int i=0;i<n;i++)\\n            v[t[i]]++;\\n\\t\\t\\t\\n\\t\\t// Loop until all tasks are not done\\n        while(tasksRemaining(v,s)) ans++;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1434979,
                "title": "java-1ms-bitmask-backtracking-recursion-easy-recursive-thinking",
                "content": "**Idea / Intuition**\\n* I thought of having individual slots for each task as each of them is less than sessionTime, as that would be the requirement in worst case.\\n* So for each new element we need to recur for an old slot with time>= current element time and one full empty slot.\\n* To prune we can keep slotCount and when it is >= already found mincount we prune.\\n\\n***Improvement tip:***\\nWithout sorting - 950ms\\nSorting - 43ms\\nDescending sort - 1ms\\n\\n\\n```\\nclass Solution {\\n\\t//simple reversing array logic ignore\\n    public static void reverse(int[] input) { int last = input.length - 1; int middle = input.length / 2; for (int i = 0; i <= middle; i++) { int temp = input[i]; input[i] = input[last - i]; input[last - i] = temp; } }\\n    static int minSlotsNeeded;\\n    public int minSessions(int[] tasks, int sessionTime) {\\n        int n=tasks.length;\\n        minSlotsNeeded = 10000;\\n        Arrays.sort(tasks);\\n        reverse(tasks); // descending\\n        int[] allSlots = new int[n];\\n        Arrays.fill(allSlots, sessionTime);\\n        rec(tasks, 0, allSlots, sessionTime, 0);\\n        return minSlotsNeeded;\\n    }\\n    static int rec(int[] tasks, int elems, int[] slots, int limit, int slotCount) {\\n        if(slotCount>=minSlotsNeeded) return 10000; // pruning if current slot utilization exceeds already found min\\n        int elem=-1;\\n        for(int i=0;i<tasks.length && elem==-1;i++) // finding out first unselected element\\n            if((elems>>i & 1)==0) elem=i;\\n        if(elem==-1) { // if no element unselected then see if the slot count can better minSlotsNeeded\\n            int count = 0;\\n            for(int a: slots)\\n                if(a<limit) count++;\\n            minSlotsNeeded = Math.min(minSlotsNeeded, count);\\n            return count;\\n        }\\n        elems = elems | 1<<elem;\\n        //all non full to be attempted for unselected task until incl first full slot\\n        int minSlots = 10000;\\n        for(int i=0;i<tasks.length;i++) {\\n            if(slots[i]>=tasks[elem]) {\\n                slots[i]-=tasks[elem];\\n                int slcount = slots[i]+tasks[elem] == limit? slotCount+1 : slotCount; // to inc slotCount if new slot otherwise old count stays\\n                minSlots = Math.min(minSlots, rec(tasks, elems, Arrays.copyOf(slots, slots.length), limit, slcount));\\n                slots[i]+=tasks[elem];\\n                if(slots[i]==limit) break; // if this is the first full slot we finished recursion for then we can stop\\n            }\\n        }\\n        \\n        return minSlots;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n\\t//simple reversing array logic ignore\\n    public static void reverse(int[] input) { int last = input.length - 1; int middle = input.length / 2; for (int i = 0; i <= middle; i++) { int temp = input[i]; input[i] = input[last - i]; input[last - i] = temp; } }\\n    static int minSlotsNeeded;\\n    public int minSessions(int[] tasks, int sessionTime) {\\n        int n=tasks.length;\\n        minSlotsNeeded = 10000;\\n        Arrays.sort(tasks);\\n        reverse(tasks); // descending\\n        int[] allSlots = new int[n];\\n        Arrays.fill(allSlots, sessionTime);\\n        rec(tasks, 0, allSlots, sessionTime, 0);\\n        return minSlotsNeeded;\\n    }\\n    static int rec(int[] tasks, int elems, int[] slots, int limit, int slotCount) {\\n        if(slotCount>=minSlotsNeeded) return 10000; // pruning if current slot utilization exceeds already found min\\n        int elem=-1;\\n        for(int i=0;i<tasks.length && elem==-1;i++) // finding out first unselected element\\n            if((elems>>i & 1)==0) elem=i;\\n        if(elem==-1) { // if no element unselected then see if the slot count can better minSlotsNeeded\\n            int count = 0;\\n            for(int a: slots)\\n                if(a<limit) count++;\\n            minSlotsNeeded = Math.min(minSlotsNeeded, count);\\n            return count;\\n        }\\n        elems = elems | 1<<elem;\\n        //all non full to be attempted for unselected task until incl first full slot\\n        int minSlots = 10000;\\n        for(int i=0;i<tasks.length;i++) {\\n            if(slots[i]>=tasks[elem]) {\\n                slots[i]-=tasks[elem];\\n                int slcount = slots[i]+tasks[elem] == limit? slotCount+1 : slotCount; // to inc slotCount if new slot otherwise old count stays\\n                minSlots = Math.min(minSlots, rec(tasks, elems, Arrays.copyOf(slots, slots.length), limit, slcount));\\n                slots[i]+=tasks[elem];\\n                if(slots[i]==limit) break; // if this is the first full slot we finished recursion for then we can stop\\n            }\\n        }\\n        \\n        return minSlots;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1433953,
                "title": "track-all-possible-combinations-of-open-slots-python3",
                "content": "### Approach\\n* Keep track of all possible options which will contain slots of time to fit in a given `task`\\n* Start with one option of one slot of `sessionTime` \\n* For each new `task`, we have two choices:\\n\\t* Fit the `task` in one of the open slots in one of the available options, creating more opitons of slots\\n\\t* Allot an entirely new slot of `sessionTime`\\n* Using tuples and sorting slot options by slot size allows us to avoid duplicate slot options and also break out of the inner loop sooner\\n* At the end, the option with the least number of slots is the one that utilized all the slot in the most optimum way. So smallest length is the answer. \\n* This approach essentially explores all possible ways to schedule the tasks, so it\\'s an exhaustive search, similar to a DFS/BFS solution. \\n\\n\\n```\\ndef minSessions(self, tasks: List[int], sessionTime: int) -> int:\\n        tasks.sort(reverse=True)\\n        options = set([(sessionTime,)])\\n        for time in tasks:\\n            new_options = set()\\n            for slots in options:\\n                for i, slot in enumerate(slots):\\n                    if slot >= time:\\n                        new_option = list(slots)\\n                        new_option[i] = slot-time\\n                        new_options.add(tuple(sorted(new_option, reverse=True)))\\n                    else:\\n                        break\\n                new_options.add(tuple(sorted(slots + (sessionTime-time,), reverse=True)))\\n            options = new_options\\n        \\n        return min(map(len, options))\\n```\\n\\n*This consistently runs faster than all Python3 solutions at the time of posting this.*",
                "solutionTags": [],
                "code": "```\\ndef minSessions(self, tasks: List[int], sessionTime: int) -> int:\\n        tasks.sort(reverse=True)\\n        options = set([(sessionTime,)])\\n        for time in tasks:\\n            new_options = set()\\n            for slots in options:\\n                for i, slot in enumerate(slots):\\n                    if slot >= time:\\n                        new_option = list(slots)\\n                        new_option[i] = slot-time\\n                        new_options.add(tuple(sorted(new_option, reverse=True)))\\n                    else:\\n                        break\\n                new_options.add(tuple(sorted(slots + (sessionTime-time,), reverse=True)))\\n            options = new_options\\n        \\n        return min(map(len, options))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1433795,
                "title": "python-top-down-dp-and-thinking-process",
                "content": "Inspired by this top voted post:\\nhttps://leetcode.com/problems/minimum-number-of-work-sessions-to-finish-the-tasks/discuss/1432155/Easier-than-top-voted-ones-or-LegitClickbait-or-c%2B%2B\\nWhich has a great explanation of how does bit masks works for this problem.\\n\\nThe brutal recursive solution is finding all possible combinations. We take every un-taken task and pass it to the next level recursive call for any given list. There are two possibilities when we made the recursive call:\\n1) Keep in the current working session\\n2) Start a new working session\\n\\nAnd if all tasks are done, we return 1\\n\\n```\\ndef recur_f(c_session_time, c_tasks):\\n            \\n            if(c_session_time > sessionTime):\\n                return math.inf\\n            \\n            if(sum(c_tasks) == len(c_tasks)*-1):\\n                return 1\\n            \\n            result = math.inf\\n            for i in range(0, len(c_tasks)):\\n                if(c_tasks[i] != -1):\\n\\t\\t\\t\\t\\t#avoid calling by reference so we made an copy of the current task list\\n                    n_tasks = c_tasks.copy()\\n                    n_tasks[i] = -1\\n                    result = min(result, \\n\\t\\t\\t\\t\\tmin(\\n\\t\\t\\t\\t\\t\\t#keep the current working session\\n\\t\\t\\t\\t\\t\\trecur_f(c_session_time + tasks[i], n_tasks),\\n\\t\\t\\t\\t\\t\\t#start a new working session\\n\\t\\t\\t\\t\\t\\t1+recur_f(tasks[i], n_tasks)))  \\n\\t\\t\\t\\t\\t\\n            return result\\n        \\n        return recur_f(0, tasks)\\n```\\n\\nBut this will get TLE. So we need to optimize it by \\n1) Using the bit string to represent the task status instead of using a list\\n2) Using memorization (Top-Down DP)\\n\\nPlease check https://leetcode.com/problems/minimum-number-of-work-sessions-to-finish-the-tasks/discuss/1432155/Easier-than-top-voted-ones-or-LegitClickbait-or-c%2B%2B for explanation for bit mask. \\n\\nBasically we use a binary representation of a integer, which is a bit string to represent the tasks status. E.g. 11111 means all five tasks are processed.\\n\\nAnd tasks | (1<<i) means set ith task as one, tasks & (1<<i) means check whether ith task is 1.\\n\\nSo we modified our brutal force recursive solution, and used an array with **current tasks bit string and current session time** as the variables. \\n\\nQuestions: Is anyone came up with a bottom-up version DP for this problem? \\n\\n```\\nclass Solution:\\n    result = math.inf\\n    n_tasks = 0\\n    all_ones = 0\\n    def minSessions(self, tasks: List[int], sessionTime: int) -> int:\\n\\n        num_possible_schedule = (1 << 15)\\n        self.n_tasks = len(tasks)\\n        self.all_ones = (1<<self.n_tasks)-1\\n       \\n        def recur_f(c_session_time, c_tasks, dp_array):\\n\\n            if(c_session_time > sessionTime):\\n                return math.inf\\n            \\n            if(c_tasks == self.all_ones):\\n                dp_array[c_tasks][c_session_time] = 1\\n                return 1\\n            \\n            if(dp_array[c_tasks][c_session_time] != -1):\\n                return dp_array[c_tasks][c_session_time]\\n            \\n            result = math.inf\\n            for i in range(0, self.n_tasks):\\n                if(c_tasks & (1<<i) == 0):\\n                    \\n                    n_tasks = c_tasks | (1<<i)\\n                    \\n                    result = min(result, \\n                                 min(recur_f(c_session_time + tasks[i], n_tasks, dp_array),1+recur_f(tasks[i], n_tasks, dp_array)))                                \\n                                \\n            dp_array[c_tasks][c_session_time] = result\\n            return result\\n\\n        dp_array = [[-1 for i in range(0, 16)] for j in range(0, num_possible_schedule)]\\n\\n        return recur_f(0, 0, dp_array)\\n```",
                "solutionTags": [],
                "code": "```\\ndef recur_f(c_session_time, c_tasks):\\n            \\n            if(c_session_time > sessionTime):\\n                return math.inf\\n            \\n            if(sum(c_tasks) == len(c_tasks)*-1):\\n                return 1\\n            \\n            result = math.inf\\n            for i in range(0, len(c_tasks)):\\n                if(c_tasks[i] != -1):\\n\\t\\t\\t\\t\\t#avoid calling by reference so we made an copy of the current task list\\n                    n_tasks = c_tasks.copy()\\n                    n_tasks[i] = -1\\n                    result = min(result, \\n\\t\\t\\t\\t\\tmin(\\n\\t\\t\\t\\t\\t\\t#keep the current working session\\n\\t\\t\\t\\t\\t\\trecur_f(c_session_time + tasks[i], n_tasks),\\n\\t\\t\\t\\t\\t\\t#start a new working session\\n\\t\\t\\t\\t\\t\\t1+recur_f(tasks[i], n_tasks)))  \\n\\t\\t\\t\\t\\t\\n            return result\\n        \\n        return recur_f(0, tasks)\\n```\n```\\nclass Solution:\\n    result = math.inf\\n    n_tasks = 0\\n    all_ones = 0\\n    def minSessions(self, tasks: List[int], sessionTime: int) -> int:\\n\\n        num_possible_schedule = (1 << 15)\\n        self.n_tasks = len(tasks)\\n        self.all_ones = (1<<self.n_tasks)-1\\n       \\n        def recur_f(c_session_time, c_tasks, dp_array):\\n\\n            if(c_session_time > sessionTime):\\n                return math.inf\\n            \\n            if(c_tasks == self.all_ones):\\n                dp_array[c_tasks][c_session_time] = 1\\n                return 1\\n            \\n            if(dp_array[c_tasks][c_session_time] != -1):\\n                return dp_array[c_tasks][c_session_time]\\n            \\n            result = math.inf\\n            for i in range(0, self.n_tasks):\\n                if(c_tasks & (1<<i) == 0):\\n                    \\n                    n_tasks = c_tasks | (1<<i)\\n                    \\n                    result = min(result, \\n                                 min(recur_f(c_session_time + tasks[i], n_tasks, dp_array),1+recur_f(tasks[i], n_tasks, dp_array)))                                \\n                                \\n            dp_array[c_tasks][c_session_time] = result\\n            return result\\n\\n        dp_array = [[-1 for i in range(0, 16)] for j in range(0, num_possible_schedule)]\\n\\n        return recur_f(0, 0, dp_array)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1433475,
                "title": "python-walk-bucket-solution-easy-to-understand",
                "content": "this problem is similar to problem 1723.\\nthe solution is straightforward. there are n tasks, so we create n bucket. each task[i] will be placed to one of the bucket. the non-empty bucket is the number of sessions and we want to find the min.\\nBelow is the code. \\nfunction walk will walk through every task and try to place it to one bucket(session), k is the current non empty  bucket, which is the sessions we used so far.\\nself.res is the current best result\\nI did several pruning here\\n1. if k larger than self.res, then we don\\'t need to search forward anymore.\\n2. for each task ,when we iterate all bucket, if the bucket value is the same, then we only need to calcuate one of them. this why I used seen set to track bucket value that has been used.\\n\\n\\n\\n```\\nclass Solution:\\n    def minSessions(self, tasks: List[int], sessionTime: int) -> int:\\n        n=len(tasks)\\n        tasks.sort(reverse=True)\\n        self.res=n\\n        sessions=[0]*n\\n        def walk(i,k):\\n            if k>=self.res:\\n                return\\n            if i==n:\\n                self.res=min(self.res,k)\\n                return\\n            seen=set()\\n            for j in range(n):\\n                if sessions[j] in seen:\\n                    continue\\n                if sessions[j]+tasks[i]<=sessionTime:\\n                    seen.add(sessions[j])\\n                    if sessions[j]==0:\\n                        sessions[j]+=tasks[i]\\n                        walk(i+1,k+1)\\n                    else:\\n                        sessions[j]+=tasks[i]\\n                        walk(i+1,k)\\n                    sessions[j]-=tasks[i]\\n            return \\n        walk(0,0)\\n        return self.res\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSessions(self, tasks: List[int], sessionTime: int) -> int:\\n        n=len(tasks)\\n        tasks.sort(reverse=True)\\n        self.res=n\\n        sessions=[0]*n\\n        def walk(i,k):\\n            if k>=self.res:\\n                return\\n            if i==n:\\n                self.res=min(self.res,k)\\n                return\\n            seen=set()\\n            for j in range(n):\\n                if sessions[j] in seen:\\n                    continue\\n                if sessions[j]+tasks[i]<=sessionTime:\\n                    seen.add(sessions[j])\\n                    if sessions[j]==0:\\n                        sessions[j]+=tasks[i]\\n                        walk(i+1,k+1)\\n                    else:\\n                        sessions[j]+=tasks[i]\\n                        walk(i+1,k)\\n                    sessions[j]-=tasks[i]\\n            return \\n        walk(0,0)\\n        return self.res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1433303,
                "title": "knapsack-like-0-ms-o-s-n-2-worst-case",
                "content": "**Step 1: Build DP Matrix**\\n\\nBuild a knapsack-like matrix to find how many ways we can spend X time with our current tasks.\\n\\nEx. [1,2,3]    sessionTime = 3\\n\\n**0 1 2 3** \\n1 0 0 0  |  *looking at 0 tasks*\\n1 1 0 0  |  *including task 1*\\n1 1 1 1  |  *including task 2*\\n1 1 1 2  |  *including task 3*\\n\\n#Ways to spend s time with tasks 0->t =\\n#Ways to spend s time with tasks 0->(t-1) +\\n#Ways to spend s-(time of task t) time with tasks 0->(t-1).\\n\\n**Step 2: Extrapolate Tasks from Matrix**\\n\\nLook for the bottom-right-most, non-zero cell in our matrix (in this case [3,3]).\\nFind the task that caused this cell to increase to its current value (task #3).\\nAdd that task to the list of used tasks and decrease our column idx by that task\\'s value.\\n\\n**Step 3: Remove Tasks, Increment Sessions, Repeat**\\n\\n[1,2,3] becomes [1,2]. Sessions = 1\\nOur matrix becomes\\n\\n1 0 0 0   |  *looking at 0 tasks*\\n1 1 0 0   |  *including task 1*\\n1 1 1 1   |  *including task 2*\\n\\nWe can extrapolate tasks 2 & 1 from this.\\n\\n[1,2] becomes []. Sessions = 2\\n\\n**Time Complexity**\\n\\nEach iteration has a complexity of O(sn), where s is sessionTime and n is the number of tasks.\\nWorst case scenario, each session only includes one task, giving worst case O(s*n^2)\\n\\n```\\nclass Solution {\\npublic:\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        int sessions = 0;\\n        \\n        while (!tasks.empty()) {\\n\\t\\t\\t// Create dp matrix.\\n            vector<vector<int>> dp (tasks.size()+1, vector<int> (sessionTime+1, 0));\\n            \\n            for (auto& row : dp)\\n                row[0] = 1;\\n            \\n            for (int t=1; t<dp.size(); t++) {\\n                for (int s=1; s<dp[0].size(); s++) {\\n                    int curTask = tasks[t-1];\\n                    \\n\\t\\t\\t\\t\\tdp[t][s] = dp[t-1][s];\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tif (curTask <= s)\\n                        dp[t][s] += dp[t-1][s-curTask];\\n                }\\n            }\\n            \\n\\t\\t\\t// Build idx list from dp matrix.\\n            int row = dp.size()-1;\\n            int col = dp[0].size()-1;\\n            vector<int> indices;\\n            \\n            while (col>0 && row>0) {\\n                while (col > 0 && dp[row][col] == 0)\\n                    col--;\\n                \\n                while (row > 0 && dp[row][col] == dp[row-1][col])\\n                    row--;\\n                \\n                if (col==0 && row==0)\\n                    continue;\\n                \\n                indices.push_back(row-1);\\n                col -= tasks[row-1];\\n                row--;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// Remove used tasks.\\n            for (auto idx : indices)\\n                tasks.erase(tasks.begin() + idx);\\n            \\n            sessions++;\\n        }\\n        \\n        return sessions;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        int sessions = 0;\\n        \\n        while (!tasks.empty()) {\\n\\t\\t\\t// Create dp matrix.\\n            vector<vector<int>> dp (tasks.size()+1, vector<int> (sessionTime+1, 0));\\n            \\n            for (auto& row : dp)\\n                row[0] = 1;\\n            \\n            for (int t=1; t<dp.size(); t++) {\\n                for (int s=1; s<dp[0].size(); s++) {\\n                    int curTask = tasks[t-1];\\n                    \\n\\t\\t\\t\\t\\tdp[t][s] = dp[t-1][s];\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tif (curTask <= s)\\n                        dp[t][s] += dp[t-1][s-curTask];\\n                }\\n            }\\n            \\n\\t\\t\\t// Build idx list from dp matrix.\\n            int row = dp.size()-1;\\n            int col = dp[0].size()-1;\\n            vector<int> indices;\\n            \\n            while (col>0 && row>0) {\\n                while (col > 0 && dp[row][col] == 0)\\n                    col--;\\n                \\n                while (row > 0 && dp[row][col] == dp[row-1][col])\\n                    row--;\\n                \\n                if (col==0 && row==0)\\n                    continue;\\n                \\n                indices.push_back(row-1);\\n                col -= tasks[row-1];\\n                row--;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// Remove used tasks.\\n            for (auto idx : indices)\\n                tasks.erase(tasks.begin() + idx);\\n            \\n            sessions++;\\n        }\\n        \\n        return sessions;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1433015,
                "title": "javascript-and-typescript-bitmask-dp",
                "content": "DP[mask][time] = Minimum number of work sessions after assigning task by `mask` and it remains `time` session time\\n\\nJavaScript\\n```js\\n/**\\n * @param {number[]} tasks\\n * @param {number} sessionTime\\n * @return {number}\\n */\\nvar minSessions = function(tasks, sessionTime) {\\n  const n = tasks.length;\\n  const dp = Array(1 << n).fill().map(() => Array(16).fill(-1));\\n  \\n  const solve = (mask, time) => {\\n    if (mask === (1 << n) - 1) {\\n      return 1;\\n    }\\n    \\n    if (dp[mask][time] !== -1) {\\n      return dp[mask][time];\\n    }\\n    \\n    let min = Infinity;\\n    for (let i = 0; i < n; ++i) {\\n      if (mask & (1 << i)) {\\n        continue;\\n      }\\n\\n      if (time >= tasks[i]) {\\n        min = Math.min(\\n          min,\\n          solve(mask | (1 << i), time - tasks[i]),\\n        );\\n      } else {\\n        min = Math.min(\\n          min,\\n          1 + solve(mask | (1 << i), sessionTime - tasks[i]),\\n        );\\n      }\\n    }\\n    \\n    dp[mask][time] = min;\\n    return min;\\n  }\\n  \\n  return solve(0, sessionTime);\\n};\\n\\n```\\n\\nTypeScript\\n```ts\\nfunction minSessions(tasks: number[], sessionTime: number): number {\\n  const n = tasks.length;\\n  const dp = Array(1 << n).fill(null).map(() => Array(16).fill(-1));\\n  \\n  const solve = (mask, time) => {\\n    if (mask === (1 << n) - 1) {\\n      return 1;\\n    }\\n    \\n    if (dp[mask][time] !== -1) {\\n      return dp[mask][time];\\n    }\\n    \\n    let min = Infinity;\\n    for (let i = 0; i < n; ++i) {\\n      if (mask & (1 << i)) {\\n        continue;\\n      }\\n\\n      if (time >= tasks[i]) {\\n        min = Math.min(\\n          min,\\n          solve(mask | (1 << i), time - tasks[i]),\\n        );\\n      } else {\\n        min = Math.min(\\n          min,\\n          1 + solve(mask | (1 << i), sessionTime - tasks[i]),\\n        );\\n      }\\n    }\\n    \\n    dp[mask][time] = min;\\n    return min;\\n  }\\n  \\n  return solve(0, sessionTime);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```js\\n/**\\n * @param {number[]} tasks\\n * @param {number} sessionTime\\n * @return {number}\\n */\\nvar minSessions = function(tasks, sessionTime) {\\n  const n = tasks.length;\\n  const dp = Array(1 << n).fill().map(() => Array(16).fill(-1));\\n  \\n  const solve = (mask, time) => {\\n    if (mask === (1 << n) - 1) {\\n      return 1;\\n    }\\n    \\n    if (dp[mask][time] !== -1) {\\n      return dp[mask][time];\\n    }\\n    \\n    let min = Infinity;\\n    for (let i = 0; i < n; ++i) {\\n      if (mask & (1 << i)) {\\n        continue;\\n      }\\n\\n      if (time >= tasks[i]) {\\n        min = Math.min(\\n          min,\\n          solve(mask | (1 << i), time - tasks[i]),\\n        );\\n      } else {\\n        min = Math.min(\\n          min,\\n          1 + solve(mask | (1 << i), sessionTime - tasks[i]),\\n        );\\n      }\\n    }\\n    \\n    dp[mask][time] = min;\\n    return min;\\n  }\\n  \\n  return solve(0, sessionTime);\\n};\\n\\n```\n```ts\\nfunction minSessions(tasks: number[], sessionTime: number): number {\\n  const n = tasks.length;\\n  const dp = Array(1 << n).fill(null).map(() => Array(16).fill(-1));\\n  \\n  const solve = (mask, time) => {\\n    if (mask === (1 << n) - 1) {\\n      return 1;\\n    }\\n    \\n    if (dp[mask][time] !== -1) {\\n      return dp[mask][time];\\n    }\\n    \\n    let min = Infinity;\\n    for (let i = 0; i < n; ++i) {\\n      if (mask & (1 << i)) {\\n        continue;\\n      }\\n\\n      if (time >= tasks[i]) {\\n        min = Math.min(\\n          min,\\n          solve(mask | (1 << i), time - tasks[i]),\\n        );\\n      } else {\\n        min = Math.min(\\n          min,\\n          1 + solve(mask | (1 << i), sessionTime - tasks[i]),\\n        );\\n      }\\n    }\\n    \\n    dp[mask][time] = min;\\n    return min;\\n  }\\n  \\n  return solve(0, sessionTime);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1432856,
                "title": "c-dp-bitmasking",
                "content": "```\\n/*\\n   Kind of Problem where we have the option to Pick now or Pick later but we definatley have to pick all items.\\n   We are using dp with bitmasking here where a ith bit in mask represents that element isPicked or not.\\n   if 1 that means picked if 0 means not picked Yet.\\n   We will do memoization to save time and store the result on two changing states mask(isTaken) and currTime\\n   The constraints given that array is of size 14 atMax and sessionTime is 15 atMax so that means we will only need mask of size 1<<15\\n   and second column is made of size 16 (1 grater than specified size of sessionTime)\\n   \\n   Approach : We are taking a mask intially and picking elements and setting ith bit of mask to represent we have picked and currTime should be atMax <= SessionTime\\n              so we are adding tasks values in this variable(currentTime) once it exceeds the sessionTime we will break recursion, we also have the option to not pick\\n              for that we are also setting the ith bit because it will also be picked (we are including this but including in next work session) and adding 1 that represents \\n              that we have created 1 more session by sending this element to be picked in next session and as we have created the next session so currentTime will be zero for this\\n              these recursion calls will give us work sessions which are created so we selecting minimum as asked in question and caching it with dp and returning min number of work \\n              sessions.\\n              we have One condition (isTaken == (1<<N)-1) that represents that we picked all elements (because Nth bit will be set only we reached last element of array and we subtracted 1\\n              beacuse we are accesding bits by N in number 1 which has already a set bit in simple terms to counter the effect of 1 we reduced this 1) \\n              will return 1 (as consider a case) - Input: tasks = [1,2,3,4,5], sessionTime = 15, in this all tasks will be counted in single work session so includeInNext will never be counted\\n              hence we never added 1 in whole program to represent that this is a session so for that we returned 1 in condition (isTaken == (1<<N)-1)\\n*/\\nclass Solution {\\npublic:\\n    int dp[1<<15][16];\\n    int Sessions(vector<int> &tasks, int sessionTime, int isTaken, int currentTime, int N){\\n        //exceding the boundraies\\n        if(currentTime>sessionTime)\\n            return INT_MAX;\\n        //checking if all elements are selected\\n        if(isTaken == (1<<N)-1)\\n            return 1;\\n        //returning cached results if they are already calcultated\\n        if(dp[isTaken][currentTime] != -1)\\n            return dp[isTaken][currentTime];\\n        int ans = INT_MAX;\\n        for(int i=0; i<N; i++){\\n            //Means this index element is not picked yet\\n            if(!(isTaken&(1<<i))){\\n                //include in current work session so for that we added taks[i] in currentTime\\n                int includeNow = Sessions(tasks, sessionTime, isTaken|(1<<i), currentTime+tasks[i], N);\\n                //creating a new work session\\n                int includeInNext = 1 + Sessions(tasks, sessionTime, isTaken|(1<<i), 0+tasks[i], N);\\n                ans = min({ans, includeNow, includeInNext});\\n            }\\n        }\\n        dp[isTaken][currentTime] = ans;\\n        return dp[isTaken][currentTime];\\n    }\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        memset(dp, -1, sizeof(dp));\\n        return Sessions(tasks, sessionTime, 0, 0, tasks.size());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n   Kind of Problem where we have the option to Pick now or Pick later but we definatley have to pick all items.\\n   We are using dp with bitmasking here where a ith bit in mask represents that element isPicked or not.\\n   if 1 that means picked if 0 means not picked Yet.\\n   We will do memoization to save time and store the result on two changing states mask(isTaken) and currTime\\n   The constraints given that array is of size 14 atMax and sessionTime is 15 atMax so that means we will only need mask of size 1<<15\\n   and second column is made of size 16 (1 grater than specified size of sessionTime)\\n   \\n   Approach : We are taking a mask intially and picking elements and setting ith bit of mask to represent we have picked and currTime should be atMax <= SessionTime\\n              so we are adding tasks values in this variable(currentTime) once it exceeds the sessionTime we will break recursion, we also have the option to not pick\\n              for that we are also setting the ith bit because it will also be picked (we are including this but including in next work session) and adding 1 that represents \\n              that we have created 1 more session by sending this element to be picked in next session and as we have created the next session so currentTime will be zero for this\\n              these recursion calls will give us work sessions which are created so we selecting minimum as asked in question and caching it with dp and returning min number of work \\n              sessions.\\n              we have One condition (isTaken == (1<<N)-1) that represents that we picked all elements (because Nth bit will be set only we reached last element of array and we subtracted 1\\n              beacuse we are accesding bits by N in number 1 which has already a set bit in simple terms to counter the effect of 1 we reduced this 1) \\n              will return 1 (as consider a case) - Input: tasks = [1,2,3,4,5], sessionTime = 15, in this all tasks will be counted in single work session so includeInNext will never be counted\\n              hence we never added 1 in whole program to represent that this is a session so for that we returned 1 in condition (isTaken == (1<<N)-1)\\n*/\\nclass Solution {\\npublic:\\n    int dp[1<<15][16];\\n    int Sessions(vector<int> &tasks, int sessionTime, int isTaken, int currentTime, int N){\\n        //exceding the boundraies\\n        if(currentTime>sessionTime)\\n            return INT_MAX;\\n        //checking if all elements are selected\\n        if(isTaken == (1<<N)-1)\\n            return 1;\\n        //returning cached results if they are already calcultated\\n        if(dp[isTaken][currentTime] != -1)\\n            return dp[isTaken][currentTime];\\n        int ans = INT_MAX;\\n        for(int i=0; i<N; i++){\\n            //Means this index element is not picked yet\\n            if(!(isTaken&(1<<i))){\\n                //include in current work session so for that we added taks[i] in currentTime\\n                int includeNow = Sessions(tasks, sessionTime, isTaken|(1<<i), currentTime+tasks[i], N);\\n                //creating a new work session\\n                int includeInNext = 1 + Sessions(tasks, sessionTime, isTaken|(1<<i), 0+tasks[i], N);\\n                ans = min({ans, includeNow, includeInNext});\\n            }\\n        }\\n        dp[isTaken][currentTime] = ans;\\n        return dp[isTaken][currentTime];\\n    }\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        memset(dp, -1, sizeof(dp));\\n        return Sessions(tasks, sessionTime, 0, 0, tasks.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1432602,
                "title": "clean-dp-with-memoization",
                "content": "credit to @shourabhpayal\\nfor c++ https://leetcode.com/problems/minimum-number-of-work-sessions-to-finish-the-tasks/discuss/1431836/C%2B%2B-Solution-or-Recursion-%2B-Memoization\\n\\n\\nidea\\n1. use bit mask  to represent array  \\n   1) for selected element, set ith index to 1\\n   2) for unselected element, is ith index is 0\\n\\t\\n\\te.g: [1,2,3,4,5,6]   \\n\\t      if 0 and 4th element selected , 100010\\n\\n2. use memoization to store interim result \\n  e.g:   in #1 above example , \\n          10010 binary equals to 18 ,         \\n          therefore, minimum value is in between memo[18][0] to memo[18][sessionTime]\\n\\t\\t  \\n3. final result is  in between memo[(1<<n)-1][0] and memo[(1<<n)-1][sessionTime]\\n4. \\n\\t\\t  \\n```\\n\\n\\npublic int minSessions(int[] tasks, int sessionTime) {        \\n        int n=tasks.length;\\n        Integer[][] memo= new Integer[1<<n][sessionTime+1];        \\n        return dp(tasks,memo,0,0,sessionTime,(1<<n)-1);                \\n    }\\n    \\n    private int dp(int[] tasks,Integer[][] memo,int mask,int currTime,int sessionTime,int all){\\n        if(currTime>sessionTime)\\n            return Integer.MAX_VALUE;\\n        \\n        if(mask==all)\\n            return 1;        \\n        \\n        if(memo[mask][currTime]!=null)\\n            return memo[mask][currTime];\\n        \\n        int res=Integer.MAX_VALUE;\\n        for(int i=0;i<tasks.length;i++){\\n            if((mask&(1<<i))==0){\\n                int a=dp(tasks,memo,mask|(1<<i),currTime+tasks[i],sessionTime,all);                \\n                int b=dp(tasks,memo,mask|(1<<i),tasks[i],sessionTime,all)+1;\\n                res=Math.min(res,Math.min(a,b));\\n            }                        \\n        }\\n        \\n        return memo[mask][currTime]=res;\\n    }\\n\\n\\n\\n```\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\n\\n\\npublic int minSessions(int[] tasks, int sessionTime) {        \\n        int n=tasks.length;\\n        Integer[][] memo= new Integer[1<<n][sessionTime+1];        \\n        return dp(tasks,memo,0,0,sessionTime,(1<<n)-1);                \\n    }\\n    \\n    private int dp(int[] tasks,Integer[][] memo,int mask,int currTime,int sessionTime,int all){\\n        if(currTime>sessionTime)\\n            return Integer.MAX_VALUE;\\n        \\n        if(mask==all)\\n            return 1;        \\n        \\n        if(memo[mask][currTime]!=null)\\n            return memo[mask][currTime];\\n        \\n        int res=Integer.MAX_VALUE;\\n        for(int i=0;i<tasks.length;i++){\\n            if((mask&(1<<i))==0){\\n                int a=dp(tasks,memo,mask|(1<<i),currTime+tasks[i],sessionTime,all);                \\n                int b=dp(tasks,memo,mask|(1<<i),tasks[i],sessionTime,all)+1;\\n                res=Math.min(res,Math.min(a,b));\\n            }                        \\n        }\\n        \\n        return memo[mask][currTime]=res;\\n    }\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1432517,
                "title": "c-dynamic-programming-with-bit-masking-commented",
                "content": "```\\nclass Solution\\n{\\n  public:\\n    int n, k;\\n    vector<int> a;\\n    int dp[(1 << 14) + 5][16];\\n    int find(int mask, int left)\\n    {\\n    \\t// mask = to store the state of already selected items\\n    \\t// left = how much sessionTime is still left to consume\\n        if (mask == (1 << n) - 1)\\n            return 0;\\n        int &mn = dp[mask][left];\\n        // memoization\\n        if (mn != -1)\\n            return mn;\\n        mn = 1e9;\\n        for (int i = 0; i < n; i++)\\n        {\\n        \\t// if ith item is not selected in mask the select it\\n            if (((mask >> i) & 1) == 0)\\n            {\\n            \\t// if sessionTime is still left to consume the simply subtract from it \\n            \\t// and set the ith item in the mask\\n                if (left - a[i] >= 0)\\n                    mn = min({mn, find((mask | (1 << i)), left - a[i])});\\n                // since every item is greater tha sessionTime i.e. (a[i]>=k), then\\n                // consume it from fresh sessionTime and increse the session by 1. \\n                mn = min(mn, 1 + find((mask | (1 << i)), k - a[i]));\\n            }\\n        }\\n        return mn;\\n    }\\n    int minSessions(vector<int> &tasks, int sessionTime)\\n    {\\n        a = tasks;\\n        n = size(a), k = sessionTime;\\n        for (auto &x : dp)\\n            for (auto &y : x)\\n                y = -1;\\n        return find(0, k) + 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n  public:\\n    int n, k;\\n    vector<int> a;\\n    int dp[(1 << 14) + 5][16];\\n    int find(int mask, int left)\\n    {\\n    \\t// mask = to store the state of already selected items\\n    \\t// left = how much sessionTime is still left to consume\\n        if (mask == (1 << n) - 1)\\n            return 0;\\n        int &mn = dp[mask][left];\\n        // memoization\\n        if (mn != -1)\\n            return mn;\\n        mn = 1e9;\\n        for (int i = 0; i < n; i++)\\n        {\\n        \\t// if ith item is not selected in mask the select it\\n            if (((mask >> i) & 1) == 0)\\n            {\\n            \\t// if sessionTime is still left to consume the simply subtract from it \\n            \\t// and set the ith item in the mask\\n                if (left - a[i] >= 0)\\n                    mn = min({mn, find((mask | (1 << i)), left - a[i])});\\n                // since every item is greater tha sessionTime i.e. (a[i]>=k), then\\n                // consume it from fresh sessionTime and increse the session by 1. \\n                mn = min(mn, 1 + find((mask | (1 << i)), k - a[i]));\\n            }\\n        }\\n        return mn;\\n    }\\n    int minSessions(vector<int> &tasks, int sessionTime)\\n    {\\n        a = tasks;\\n        n = size(a), k = sessionTime;\\n        for (auto &x : dp)\\n            for (auto &y : x)\\n                y = -1;\\n        return find(0, k) + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1432343,
                "title": "c-sub-mask-enumeration-o-3-n",
                "content": "We can reach a mask from all of its submasks.\\n```\\nclass Solution {\\npublic:\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        int n = tasks.size();\\n        vector<int> dp(1 << n, 100000);\\n        for (int mask = 0; mask < 1 << n; mask++) {\\n            int req = 0;\\n            for (int i = 0; i < n; i++) {\\n                if (mask & 1 << i) req += tasks[i];\\n            }\\n            if (req <= sessionTime) dp[mask] = 1;\\n            \\n            for (int smask = mask; ; smask = mask & (smask - 1)) {\\n                if (dp[smask] + dp[mask - smask] < dp[mask])\\n                    dp[mask] = dp[smask] + dp[mask - smask];\\n                if (smask == 0) break;\\n            }\\n        }\\n        return dp[(1 << n) - 1];\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        int n = tasks.size();\\n        vector<int> dp(1 << n, 100000);\\n        for (int mask = 0; mask < 1 << n; mask++) {\\n            int req = 0;\\n            for (int i = 0; i < n; i++) {\\n                if (mask & 1 << i) req += tasks[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1432220,
                "title": "c-binary-search-dfs-memo",
                "content": "If x is the minimum number  of work sessions to finish the tasks, then any value of work sessions larger than x would also be enough to finish the tasks. Thus, we can apply binary search to this question.\\n\\nThe initial `left` can be 0, and `right` is the size of the tasks (why?).\\n\\nThe first guess could be `mid = left + (right - left) / 2`.\\n\\nThen the question becomes: if we have `mid` work sesssions (each has sessionTime hours), can we finsih all the tasks?\\n\\nSo it becomes a multi-knapsack problem.\\n\\nThe good news is that the numbe rof tasks and sessionTime are very small, so we can memorize all the possible states. For example, the bits of an integer can be used to record whether each tasks has been finished or not.\\n\\nSee the code below:\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        int n = tasks.size(), left = 0, right = n;\\n        sort(tasks.begin(), tasks.end(), greater());\\n        vector<vector<vector<int>>> memo(1<<n, vector<vector<int>>(n+1, vector<int>(sessionTime+1, -1)));\\n        while(left < right) {\\n            int mid = left + (right - left) / 2;\\n            if(!valid(tasks, 0, 0, sessionTime, mid, memo)) left = mid + 1;\\n            else right = mid;\\n           // cout<<mid<<\" \"<<left<<\" \"<<right<<endl;\\n        }\\n        return left;\\n    }\\nprivate:\\n    bool valid(vector<int>& ts, int state, int sum, int& tm, int mid, vector<vector<vector<int>>>& memo) {\\n        int n = ts.size();\\n        if(state + 1 == (1<<n)) return sum > 0 ? mid > 0 : mid >= 0;\\n        if(mid<=0) return false;\\n        if(memo[state][mid][sum] != -1) return memo[state][mid][sum];\\n        for(int i=0; i<n; ++i) {\\n            if((state>>i) & 1) continue;\\n            if(tm < sum + ts[i]) continue;\\n            if(valid(ts, state | (1<<i), sum + ts[i], tm, mid, memo)) return memo[state][mid][sum] = 1;\\n        }\\n        return memo[state][mid][sum] = valid(ts, state, 0, tm, mid - 1, memo);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        int n = tasks.size(), left = 0, right = n;\\n        sort(tasks.begin(), tasks.end(), greater());\\n        vector<vector<vector<int>>> memo(1<<n, vector<vector<int>>(n+1, vector<int>(sessionTime+1, -1)));\\n        while(left < right) {\\n            int mid = left + (right - left) / 2;\\n            if(!valid(tasks, 0, 0, sessionTime, mid, memo)) left = mid + 1;\\n            else right = mid;\\n           // cout<<mid<<\" \"<<left<<\" \"<<right<<endl;\\n        }\\n        return left;\\n    }\\nprivate:\\n    bool valid(vector<int>& ts, int state, int sum, int& tm, int mid, vector<vector<vector<int>>>& memo) {\\n        int n = ts.size();\\n        if(state + 1 == (1<<n)) return sum > 0 ? mid > 0 : mid >= 0;\\n        if(mid<=0) return false;\\n        if(memo[state][mid][sum] != -1) return memo[state][mid][sum];\\n        for(int i=0; i<n; ++i) {\\n            if((state>>i) & 1) continue;\\n            if(tm < sum + ts[i]) continue;\\n            if(valid(ts, state | (1<<i), sum + ts[i], tm, mid, memo)) return memo[state][mid][sum] = 1;\\n        }\\n        return memo[state][mid][sum] = valid(ts, state, 0, tm, mid - 1, memo);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1432139,
                "title": "c-solution-dp-bit-masking",
                "content": "We denote which tasks have been done and which are yet to be done by the binary representation of a variable mask (basic masking). Now everytime we have to select a task to do, we have the following choices : \\n1. If the current task requires time <= the time remaining in your current session, you can either select this task to be done or we can move on to some other undone task.\\n2. If the current task requires time > the time remaining in your current session, to do this task, you need a new session.\\n\\nOur answer is the minimum of these three cases.\\n\\nIn this case a state of dp is defined by two variables, mask and time remaining in your current session, and stores the value of the number of new sessions required to do all tasks from current state.\\n\\n\\'\\'\\'\\n\\nclass Solution {\\npublic:\\n    int sto; \\n\\t\\n    int dp[(1<<14)-1][18]; int n;\\n\\t\\n    vector<int> tasks;\\n\\t\\n    int solve(int mask,int st){\\n        if(mask==(1<<n)-1){//If all the tasks are done, return 0;\\n            return 0;\\n        }\\n        if(dp[mask][st]!=-1) return dp[mask][st]; //If dp has the value of present state, no need to recalculate\\n\\t\\t\\n        int ans=INT_MAX; \\n\\t\\t\\n        for(int i=0;i<tasks.size();i++){\\n            if(tasks[i]<=st&&((mask&(1<<i))==0)){//case 1\\n                ans=min(ans,solve(mask|(1<<i),st-tasks[i]));\\n            }\\n            else if(((mask&(1<<i))==0)){//case 2\\n                ans=min(ans,solve(mask|(1<<i),sto-tasks[i])+1);\\n            }\\n        }\\n        return dp[mask][st]=ans;\\n    }\\n    \\n    int minSessions(vector<int>& task, int sessionTime) {\\n        tasks=task;\\n        sto=sessionTime; n=tasks.size();\\n        memset(dp,-1,sizeof(dp));\\n        int mask=0;\\n        return solve(mask,sto)+1; // + 1 for the initial session\\n        \\n    }\\n};\\n\\n\\'\\'\\'\\n\\n**If you found this helpful, please consider upvoting.**",
                "solutionTags": [
                    "Bit Manipulation",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    int sto; \\n\\t\\n    int dp[(1<<14)-1][18]; int n;\\n\\t\\n    vector<int> tasks;\\n\\t\\n    int solve(int mask,int st){\\n        if(mask==(1<<n)-1){//If all the tasks are done, return 0;\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1432132,
                "title": "javascript-bitmask-dp-144ms",
                "content": "```\\nconst minSessions = (tasks, sessionTime) => {\\n    let n = tasks.length;\\n    let dp = Array(1 << n).fill(Number.MAX_SAFE_INTEGER);\\n    let valid = Array(1 << n).fill(false);\\n    for (let i = 0; i < 1 << n; i++) {\\n        let sum = 0;\\n        for (let j = 0; j < n; j++) {\\n            if (1 & (i >> j)) sum += tasks[j];\\n            // OR if (i << ~j < 0) sum += tasks[j];\\n        }\\n        valid[i] = sum <= sessionTime;\\n    }\\n    dp[0] = 0;\\n    for (let i = 0; i < 1 << n; i++) {\\n        for (let j = i; j > 0; j = (j - 1) & i) {\\n            if (valid[j]) {\\n                dp[i] = Math.min(dp[i], dp[i - j] + 1);\\n            }\\n        }\\n    }\\n    return dp[(1 << n) - 1];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nconst minSessions = (tasks, sessionTime) => {\\n    let n = tasks.length;\\n    let dp = Array(1 << n).fill(Number.MAX_SAFE_INTEGER);\\n    let valid = Array(1 << n).fill(false);\\n    for (let i = 0; i < 1 << n; i++) {\\n        let sum = 0;\\n        for (let j = 0; j < n; j++) {\\n            if (1 & (i >> j)) sum += tasks[j];\\n            // OR if (i << ~j < 0) sum += tasks[j];\\n        }\\n        valid[i] = sum <= sessionTime;\\n    }\\n    dp[0] = 0;\\n    for (let i = 0; i < 1 << n; i++) {\\n        for (let j = i; j > 0; j = (j - 1) & i) {\\n            if (valid[j]) {\\n                dp[i] = Math.min(dp[i], dp[i - j] + 1);\\n            }\\n        }\\n    }\\n    return dp[(1 << n) - 1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1432070,
                "title": "c-o-n-2-n-3-n-dynamic-programming-bit-masking",
                "content": "```csharp\\npublic int MinSessions(int[] tasks, int sessionTime)\\n{\\n\\tint mask = 1 << tasks.Length;\\n\\tint[] sum = new int[mask];\\n\\tint[] d = new int[mask];\\n\\tArray.Fill(d, 1000);\\n\\td[0] = 0;\\n\\n\\tfor (int i = 1; i < mask; i++)\\n\\t{            \\n\\t\\tfor (int j = 0; j < tasks.Length; j++)\\n\\t\\t{\\n\\t\\t\\tif ((i & (1 << j)) != 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsum[i] += tasks[j];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfor (int i = 1; i < mask; i++)\\n\\t{            \\n\\t\\t// Enumerate all submasks\\n\\t\\tfor (int j = i; j != 0; j = (j - 1) & i)\\n\\t\\t{\\n\\t\\t\\tif (sum[j] <= sessionTime)\\n\\t\\t\\t{\\n\\t\\t\\t\\td[i] = Math.Min(d[i], d[j ^ i] + 1);               \\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn d[^1];\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int MinSessions(int[] tasks, int sessionTime)\\n{\\n\\tint mask = 1 << tasks.Length;\\n\\tint[] sum = new int[mask];\\n\\tint[] d = new int[mask];\\n\\tArray.Fill(d, 1000);\\n\\td[0] = 0;\\n\\n\\tfor (int i = 1; i < mask; i++)\\n\\t{            \\n\\t\\tfor (int j = 0; j < tasks.Length; j++)\\n\\t\\t{\\n\\t\\t\\tif ((i & (1 << j)) != 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsum[i] += tasks[j];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfor (int i = 1; i < mask; i++)\\n\\t{            \\n\\t\\t// Enumerate all submasks\\n\\t\\tfor (int j = i; j != 0; j = (j - 1) & i)\\n\\t\\t{\\n\\t\\t\\tif (sum[j] <= sessionTime)\\n\\t\\t\\t{\\n\\t\\t\\t\\td[i] = Math.Min(d[i], d[j ^ i] + 1);               \\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn d[^1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1432042,
                "title": "java-bitmask-dp-o-n2-n",
                "content": "Let us let a bitmask represent the available tasks and the unavaliable tasks where a `1` bit represents that a task is still available and `0` bit represents a task that is unavailable. \\n\\nThen, we can let `dp[bitmask]` represent the minimum sessions required to fullfill all the tasks of that bitmask. \\n\\nTo solve for `dp[bitmask]`, we can iterate through all submasks, (subsets of the avaliable masks), and let all the available tasks of that submask be one session. We need to check first if that is a valid one session by summing up the task time and making sure its less than sessionTime. We can then recurse on `dp[bitmask ^ submask`].\\n\\n\\n```\\nclass Solution {\\n    int res = Integer.MAX_VALUE;\\n    Integer[] dp;\\n    \\n    // 1 == unused, 0 == used\\n    public int dp(int[] tasks, int sessionTime, int mask){\\n        if(mask == 0) return 0;\\n        if(dp[mask] != null) return dp[mask];\\n        int res = Integer.MAX_VALUE;\\n        int n = tasks.length;\\n        for (int submask = mask;; submask = (submask - 1) & mask) {\\n            if (submask == 0)\\n                break;\\n            int totalTime = 0;\\n            for(int i=0; i<n; i++){\\n                if((submask & (1 << i)) != 0){\\n                    totalTime += tasks[i];\\n                }\\n            }\\n            if(totalTime <= sessionTime){\\n                int next_mask = mask ^ submask;\\n                res = Math.min(res, 1 + dp(tasks, sessionTime, next_mask));\\n            }\\n        }\\n        return dp[mask] = res;\\n    }\\n    \\n    public int minSessions(int[] tasks, int sessionTime) {\\n        int n = tasks.length;\\n        dp = new Integer[(1 << n)+1];\\n        return dp(tasks, sessionTime, (1 << n) - 1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int res = Integer.MAX_VALUE;\\n    Integer[] dp;\\n    \\n    // 1 == unused, 0 == used\\n    public int dp(int[] tasks, int sessionTime, int mask){\\n        if(mask == 0) return 0;\\n        if(dp[mask] != null) return dp[mask];\\n        int res = Integer.MAX_VALUE;\\n        int n = tasks.length;\\n        for (int submask = mask;; submask = (submask - 1) & mask) {\\n            if (submask == 0)\\n                break;\\n            int totalTime = 0;\\n            for(int i=0; i<n; i++){\\n                if((submask & (1 << i)) != 0){\\n                    totalTime += tasks[i];\\n                }\\n            }\\n            if(totalTime <= sessionTime){\\n                int next_mask = mask ^ submask;\\n                res = Math.min(res, 1 + dp(tasks, sessionTime, next_mask));\\n            }\\n        }\\n        return dp[mask] = res;\\n    }\\n    \\n    public int minSessions(int[] tasks, int sessionTime) {\\n        int n = tasks.length;\\n        dp = new Integer[(1 << n)+1];\\n        return dp(tasks, sessionTime, (1 << n) - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1432000,
                "title": "simple-backtracking-avoiding-repeated-recursive-calls-using-hash-set-c",
                "content": "Just note that only backtracking will lead to TLE as there will be many repeated calls - you just need to skip those.\\nHope this helps!\\n\\n    void fun(vector<int>tasks,int s,int k,int session,set<pair<vector<int>,int>>&st,vector<int>&v){\\n        if(tasks.empty()){\\n                v.push_back(k+1);\\n            return;\\n        }\\n        \\n        if(st.find(make_pair(tasks,s))!=st.end())\\n            return;\\n        \\n        st.insert(make_pair(tasks,s));\\n        \\n        if(!tasks.empty()){\\n            int flag=0;\\n            for(int i=0;i<tasks.size();i++){\\n                if(s+tasks[i]<=session){\\n                    flag=1;\\n                    int p=tasks[i];\\n                    tasks.erase(tasks.begin()+i);\\n                    if(s+p<=session)\\n                        fun(tasks,s+p,k,session,st,v);\\n\\n                    tasks.insert(tasks.begin()+i,p);\\n                }\\n            }\\n            if(!flag){\\n                fun(tasks,0,k+1,session,st,v);\\n            }\\n        }\\n    }\\n    \\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        set<pair<vector<int>,int>>st;\\n        vector<int>v;\\n        fun(tasks,0,0,sessionTime,st,v);\\n        for(auto i:v)\\n            cout<<i<<\" \";\\n        cout<<endl;\\n        return *min_element(v.begin(),v.end());\\n    }",
                "solutionTags": [],
                "code": "Just note that only backtracking will lead to TLE as there will be many repeated calls - you just need to skip those.\\nHope this helps!\\n\\n    void fun(vector<int>tasks,int s,int k,int session,set<pair<vector<int>,int>>&st,vector<int>&v){\\n        if(tasks.empty()){\\n                v.push_back(k+1);\\n            return;\\n        }\\n        \\n        if(st.find(make_pair(tasks,s))!=st.end())\\n            return;\\n        \\n        st.insert(make_pair(tasks,s));\\n        \\n        if(!tasks.empty()){\\n            int flag=0;\\n            for(int i=0;i<tasks.size();i++){\\n                if(s+tasks[i]<=session){\\n                    flag=1;\\n                    int p=tasks[i];\\n                    tasks.erase(tasks.begin()+i);\\n                    if(s+p<=session)\\n                        fun(tasks,s+p,k,session,st,v);\\n\\n                    tasks.insert(tasks.begin()+i,p);\\n                }\\n            }\\n            if(!flag){\\n                fun(tasks,0,k+1,session,st,v);\\n            }\\n        }\\n    }\\n    \\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        set<pair<vector<int>,int>>st;\\n        vector<int>v;\\n        fun(tasks,0,0,sessionTime,st,v);\\n        for(auto i:v)\\n            cout<<i<<\" \";\\n        cout<<endl;\\n        return *min_element(v.begin(),v.end());\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 1431993,
                "title": "bottom-up-bitmask-dp",
                "content": "Let `dp[state][sessionTimeLeft]` equals to the number of session we need, example: `dp[1101][10]` (binary `1101`) means the number of sessions we need when selecting first, second and the third item, and there are 10 seconds left.\\n\\nNow, if `time >= tasks[i]`, `dp[state][time - tasks[i]] = dp[prevState][time]`.\\nOtherwise, we need to start a new session, so `dp[state][sessionTime - tasks[i]] = min(dp[prevState][for t = 0 to sessionTime])`, (we choose the minimum amount of sessions required to transform from prevState to the current state)\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        const int N = tasks.size();\\n        vector<vector<int>> dp(1 << N, vector<int>(sessionTime + 1, INT_MAX / 2));\\n        dp[0][sessionTime] = 1;\\n        for (int state = 0; state < (1 << N); state++) {\\n            for (int t = 1; t <= sessionTime; t++) {\\n                for (int i = 0; i < tasks.size(); i++) {\\n                    if (((state >> i) & 1) == 0) continue;\\n                    const int prevState = state - (1 << i);\\n                    if (t >= tasks[i]) {\\n                        dp[state][t - tasks[i]] = min(\\n                            dp[state][t - tasks[i]], \\n                            dp[prevState][t]\\n                        );\\n                    } else {\\n                        dp[state][sessionTime - tasks[i]] = min(\\n                            dp[state][sessionTime - tasks[i]], \\n                            *min_element(begin(dp[prevState]), end(dp[prevState])) + 1\\n                        );\\n                    }\\n                }\\n            }\\n        }\\n        return *min_element(begin(dp[(1 << N) - 1]), end(dp[(1 << N) - 1]));\\n    }\\n};\\n```\\n\\nTime complexity: `O(NT 2^N)`, where `N` is `tasks.size()`, `T` is `sessionTime`",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        const int N = tasks.size();\\n        vector<vector<int>> dp(1 << N, vector<int>(sessionTime + 1, INT_MAX / 2));\\n        dp[0][sessionTime] = 1;\\n        for (int state = 0; state < (1 << N); state++) {\\n            for (int t = 1; t <= sessionTime; t++) {\\n                for (int i = 0; i < tasks.size(); i++) {\\n                    if (((state >> i) & 1) == 0) continue;\\n                    const int prevState = state - (1 << i);\\n                    if (t >= tasks[i]) {\\n                        dp[state][t - tasks[i]] = min(\\n                            dp[state][t - tasks[i]], \\n                            dp[prevState][t]\\n                        );\\n                    } else {\\n                        dp[state][sessionTime - tasks[i]] = min(\\n                            dp[state][sessionTime - tasks[i]], \\n                            *min_element(begin(dp[prevState]), end(dp[prevState])) + 1\\n                        );\\n                    }\\n                }\\n            }\\n        }\\n        return *min_element(begin(dp[(1 << N) - 1]), end(dp[(1 << N) - 1]));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1431953,
                "title": "python3-greedy-dp",
                "content": "1. Finish large tasks first ==> Sort tasks reversely\\n2. Use DP to put as many tasks as possible into one session\\n3. Log the DP path such that those tasks done in the current session can be removed before starting the next session\\n\\n```\\nclass Solution:\\n    def minSessions(self, tasks: List[int], sessionTime: int) -> int:\\n        # dp[ntasks+1][sesstionTime+1]\\n\\t\\t# Put large tasks first\\n        tasks.sort(reverse=True)\\n        \\n        tasks_ = [tasks[i] for i in range(len(tasks))]\\n        nSession = 0\\n        while len(tasks_) > 0:\\n            # Put as many task as possible into one session\\n            dp = [[0] * (sessionTime+1) for _ in range(len(tasks_)+1)]\\n            path = [[False] * (sessionTime+1) for _ in range(len(tasks_)+1)]\\n            \\n            delete = [False] * len(tasks_)\\n            nNew = len(tasks_)\\n            \\n            for i in range(1,len(tasks_)+1):\\n                for j in range(1,sessionTime+1):\\n                    dp[i][j] = dp[i-1][j]\\n                    if (j-tasks_[i-1] >= 0):\\n                        # Put in tasks[i-1]\\n                        if dp[i][j] < dp[i-1][j-tasks_[i-1]] + tasks_[i-1]:\\n                            dp[i][j] = dp[i-1][j-tasks_[i-1]] + tasks_[i-1]\\n                            path[i][j] = True\\n                            nNew -= 1\\n\\n\\t\\t\\t# Remove those tasks in the current session            \\n            k = sessionTime;\\n            for i in range(len(tasks_), 0, -1):\\n                if path[i][k] and k >= 1:\\n                    delete[i-1] = True\\n                    k = k - tasks_[i-1]\\n                        \\n            newtasks_ = []\\n            count = 0\\n            for i in range(len(tasks_)):\\n                if not delete[i]:\\n                    newtasks_.append(tasks_[i])\\n        \\n            tasks_ = newtasks_\\n            \\n            nSession += 1\\n            \\n        return nSession\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSessions(self, tasks: List[int], sessionTime: int) -> int:\\n        # dp[ntasks+1][sesstionTime+1]\\n\\t\\t# Put large tasks first\\n        tasks.sort(reverse=True)\\n        \\n        tasks_ = [tasks[i] for i in range(len(tasks))]\\n        nSession = 0\\n        while len(tasks_) > 0:\\n            # Put as many task as possible into one session\\n            dp = [[0] * (sessionTime+1) for _ in range(len(tasks_)+1)]\\n            path = [[False] * (sessionTime+1) for _ in range(len(tasks_)+1)]\\n            \\n            delete = [False] * len(tasks_)\\n            nNew = len(tasks_)\\n            \\n            for i in range(1,len(tasks_)+1):\\n                for j in range(1,sessionTime+1):\\n                    dp[i][j] = dp[i-1][j]\\n                    if (j-tasks_[i-1] >= 0):\\n                        # Put in tasks[i-1]\\n                        if dp[i][j] < dp[i-1][j-tasks_[i-1]] + tasks_[i-1]:\\n                            dp[i][j] = dp[i-1][j-tasks_[i-1]] + tasks_[i-1]\\n                            path[i][j] = True\\n                            nNew -= 1\\n\\n\\t\\t\\t# Remove those tasks in the current session            \\n            k = sessionTime;\\n            for i in range(len(tasks_), 0, -1):\\n                if path[i][k] and k >= 1:\\n                    delete[i-1] = True\\n                    k = k - tasks_[i-1]\\n                        \\n            newtasks_ = []\\n            count = 0\\n            for i in range(len(tasks_)):\\n                if not delete[i]:\\n                    newtasks_.append(tasks_[i])\\n        \\n            tasks_ = newtasks_\\n            \\n            nSession += 1\\n            \\n        return nSession\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1431938,
                "title": "python-dp-compression",
                "content": "Use f to record number of sessions, use g to record remaning time of current session. \\n\\n```python 3\\nclass Solution:\\n    def minSessions(self, tasks: List[int], sessionTime: int) -> int:        \\n        n = len(tasks)      \\n        f = [float(\\'inf\\')] * (1 << n)\\n        g = [float(\\'inf\\')] * (1 << n)\\n        f[0] = 1\\n        g[0] = 0\\n        for mask in range(1, 1 << n):\\n            for i in range(n):\\n                cur = tasks[i]\\n                if mask & (1 << i):\\n                    premask = mask - (1 << i)\\n                    if cur + g[premask] <= sessionTime:\\n                        f[mask], g[mask] = min((f[premask], cur + g[premask]), (f[mask], g[mask]))\\n                    else:\\n                        f[mask], g[mask] = min((f[premask] + 1, cur), (f[mask], g[mask]))\\n        return f[(1 << n) - 1] \\n```",
                "solutionTags": [],
                "code": "```python 3\\nclass Solution:\\n    def minSessions(self, tasks: List[int], sessionTime: int) -> int:        \\n        n = len(tasks)      \\n        f = [float(\\'inf\\')] * (1 << n)\\n        g = [float(\\'inf\\')] * (1 << n)\\n        f[0] = 1\\n        g[0] = 0\\n        for mask in range(1, 1 << n):\\n            for i in range(n):\\n                cur = tasks[i]\\n                if mask & (1 << i):\\n                    premask = mask - (1 << i)\\n                    if cur + g[premask] <= sessionTime:\\n                        f[mask], g[mask] = min((f[premask], cur + g[premask]), (f[mask], g[mask]))\\n                    else:\\n                        f[mask], g[mask] = min((f[premask] + 1, cur), (f[mask], g[mask]))\\n        return f[(1 << n) - 1] \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1431931,
                "title": "c-dp-bitmask",
                "content": "```\\nint dp[16][1<<15];\\n\\nclass Solution {\\npublic:\\nint help(vector<int>& ar,int jobPos,int curTime,int k,int mask){\\n    int n=ar.size();\\n    if(jobPos==n) return 0;             //  all jobs selected\\n    if(dp[curTime][mask]!=-1) return dp[curTime][mask];\\n    int minSessions = pow(10,8);\\n    for(int i=0;i<n;i++){\\n        if((mask&(1<<i))==0){\\n            // can take this job\\n            mask^=(1<<i);\\n            if(curTime+ar[i]>k) minSessions = min(minSessions , 1+help(ar,jobPos+1,ar[i],k,mask)  );\\n            else minSessions = min(minSessions , help(ar,jobPos+1,ar[i]+curTime,k,mask)  );\\n            mask^=(1<<i);\\n        }\\n    }\\n\\n    dp[curTime][mask]=minSessions;\\n    return minSessions;\\n}\\n\\nint minSessions(vector<int>& ar, int k) {\\n    memset(dp,-1,sizeof(dp));\\n    int curTime=0,mask=0;\\n    return help(ar,0,0,k,mask)+1;           //  select the 0th job such that curTime = 0 and curTime must not exceed \\'k\\'\\n}\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nint dp[16][1<<15];\\n\\nclass Solution {\\npublic:\\nint help(vector<int>& ar,int jobPos,int curTime,int k,int mask){\\n    int n=ar.size();\\n    if(jobPos==n) return 0;             //  all jobs selected\\n    if(dp[curTime][mask]!=-1) return dp[curTime][mask];\\n    int minSessions = pow(10,8);\\n    for(int i=0;i<n;i++){\\n        if((mask&(1<<i))==0){\\n            // can take this job\\n            mask^=(1<<i);\\n            if(curTime+ar[i]>k) minSessions = min(minSessions , 1+help(ar,jobPos+1,ar[i],k,mask)  );\\n            else minSessions = min(minSessions , help(ar,jobPos+1,ar[i]+curTime,k,mask)  );\\n            mask^=(1<<i);\\n        }\\n    }\\n\\n    dp[curTime][mask]=minSessions;\\n    return minSessions;\\n}\\n\\nint minSessions(vector<int>& ar, int k) {\\n    memset(dp,-1,sizeof(dp));\\n    int curTime=0,mask=0;\\n    return help(ar,0,0,k,mask)+1;           //  select the 0th job such that curTime = 0 and curTime must not exceed \\'k\\'\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1431927,
                "title": "python-backtracking-dp-with-mask",
                "content": "My solution is pretty straightforward. \\nThe problem is a bin packing, so at least we need to traverse all the combinations to find the optimal solution, which is O(n!). \\nTo traverse all the combinations, we can go through the tasks by backtracking, which tries to put one task and then take it back. \\nTo optimize the time complexity of backtracking, we can use DP (directly @functools.cache on the backtracking function) by a mask (visited array). \\nI know there are a lot of fancy solutions using bitmask, but I just directly use a boolean array. \\nBecause if we want to use @functools.cache, we need a tuple instead of list, so I transformed the tuple to list if I want to edit it and transform the list back to tuple when going to the next round.  \\nThe complexity of my solution is O(2^n * n), which because we use a visited mask to filter the solution space to O(2^n), and for each possible solution, we just traverse all the unvisited task, which takes O(n) (to sum the visited array).\\n```\\nclass Solution:\\n    res = 10**9\\n    def minSessions(self, tasks: List[int], sessionTime: int) -> int:\\n        n = len(tasks)\\n        @functools.cache\\n        def dfs(cur, visited, bins):\\n            if bins >= self.res: return\\n            for i, t in enumerate(tasks):\\n                if not visited[i]:\\n                    visited = list(visited)\\n                    visited[i] = True\\n                    if t <= cur:\\n                        if sum(visited) == n:\\n                            self.res = min(self.res,  bins)\\n                        dfs(cur - t, tuple(visited), bins)\\n                    else:\\n                        bins += 1\\n                        if sum(visited) == n:\\n                            self.res = min(self.res, bins)\\n                        dfs(sessionTime-t, tuple(visited),  bins)\\n                        bins -= 1\\n                    visited[i] = False\\n        dfs(sessionTime, tuple([False]*n), 1)\\n        return self.res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    res = 10**9\\n    def minSessions(self, tasks: List[int], sessionTime: int) -> int:\\n        n = len(tasks)\\n        @functools.cache\\n        def dfs(cur, visited, bins):\\n            if bins >= self.res: return\\n            for i, t in enumerate(tasks):\\n                if not visited[i]:\\n                    visited = list(visited)\\n                    visited[i] = True\\n                    if t <= cur:\\n                        if sum(visited) == n:\\n                            self.res = min(self.res,  bins)\\n                        dfs(cur - t, tuple(visited), bins)\\n                    else:\\n                        bins += 1\\n                        if sum(visited) == n:\\n                            self.res = min(self.res, bins)\\n                        dfs(sessionTime-t, tuple(visited),  bins)\\n                        bins -= 1\\n                    visited[i] = False\\n        dfs(sessionTime, tuple([False]*n), 1)\\n        return self.res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1431924,
                "title": "java-0ms-solution-greedy-backtrack",
                "content": "\\tclass Solution {\\n\\t\\n\\t\\tboolean[] visited;\\n\\t\\t\\n\\t\\tpublic int minSessions(int[] tasks, int sessionTime) {\\n\\t\\t\\tArrays.sort(tasks);\\n\\t\\t\\tvisited = new boolean[tasks.length];\\n\\t\\t\\tvisited[tasks.length - 1] = true;\\n\\t\\t\\tint ans = 1;\\n\\t\\t\\tint count = 1, currSessionRemainTime = sessionTime - tasks[tasks.length - 1];\\n\\t\\t\\tLoop: while (count < tasks.length) {\\n\\t\\t\\t\\tfor (int i = currSessionRemainTime; i > 0; i--) {\\n\\t\\t\\t\\t\\tint toAdd = hasCombinationHasSumOf(i, tasks, tasks.length - 2);\\n\\t\\t\\t\\t\\tif (toAdd > -1) {\\n\\t\\t\\t\\t\\t\\tcount += toAdd;\\n\\t\\t\\t\\t\\t\\tif (count == tasks.length) {\\n\\t\\t\\t\\t\\t\\t\\treturn ans;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t\\t\\t\\tcurrSessionRemainTime = sessionTime;\\n\\t\\t\\t\\t\\t\\tcontinue Loop;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcurrSessionRemainTime = sessionTime;\\n\\t\\t\\t\\tans++;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t\\t\\n\\n\\t\\tprivate int hasCombinationHasSumOf(int value, int[] tasks, int lastIdx) {\\n\\t\\t\\tfor (int i = lastIdx; i >= 0 ; i--) {\\n\\t\\t\\t\\tif (!visited[i]) {\\n\\t\\t\\t\\t\\tif (tasks[i] == value) {\\n\\t\\t\\t\\t\\t\\tvisited[i] = true;\\n\\t\\t\\t\\t\\t\\treturn 1;\\n\\t\\t\\t\\t\\t} else if (tasks[i] < value) {\\n\\t\\t\\t\\t\\t\\tvisited[i] = true;\\n\\t\\t\\t\\t\\t\\tint toAdd = hasCombinationHasSumOf(value - tasks[i], tasks, i - 1);\\n\\t\\t\\t\\t\\t\\tif (toAdd > -1) {\\n\\t\\t\\t\\t\\t\\t\\treturn 1 + toAdd;\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tvisited[i] = false;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\n\\t\\tboolean[] visited;\\n\\t\\t\\n\\t\\tpublic int minSessions(int[] tasks, int sessionTime) {\\n\\t\\t\\tArrays.sort(tasks);\\n\\t\\t\\tvisited = new boolean[tasks.length];\\n\\t\\t\\tvisited[tasks.length - 1] = true;\\n\\t\\t\\tint ans = 1;\\n\\t\\t\\tint count = 1, currSessionRemainTime = sessionTime - tasks[tasks.length - 1];\\n\\t\\t\\tLoop: while (count < tasks.length) {\\n\\t\\t\\t\\tfor (int i = currSessionRemainTime; i > 0; i--) {\\n\\t\\t\\t\\t\\tint toAdd = hasCombinationHasSumOf(i, tasks, tasks.length - 2);\\n\\t\\t\\t\\t\\tif (toAdd > -1) {\\n\\t\\t\\t\\t\\t\\tcount += toAdd;\\n\\t\\t\\t\\t\\t\\tif (count == tasks.length) {\\n\\t\\t\\t\\t\\t\\t\\treturn ans;\\n\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 4089290,
                "title": "typescript-dfs-time-o-n-2-n-space-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N*2^N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code 1 - DFS\\n```Typescript\\nfunction minSessions(tasks: number[], sessionTime: number): number {\\n    const N = tasks.length;\\n    const sessions: number[] = new Array(N).fill(sessionTime);\\n    return helper(tasks, sessions, N, N, 0);\\n};\\n\\nfunction helper(tasks: number[], sessions: number[], min: number, T: number, S: number): number {\\n\\n    // If we\\'ve run out of tasks, return # of sessions\\n    if (T <= 0) {\\n        return S;\\n    }\\n\\n    // Get the current task\\n    const task = tasks[--T];\\n\\n    // For each existing session:\\n    for (let j = 0; j < S && S < min; ++j) {\\n        // Add task to session (if it fits)\\n        if (sessions[j] >= task) {\\n            sessions[j] -= task;\\n            min = helper(tasks, sessions, min, T, S);\\n            sessions[j] += task;\\n        }\\n    }\\n\\n    // Add task to a new session\\n    if (S + 1 < min) {\\n        sessions[S] -= task;\\n        min = helper(tasks, sessions, min, T, S + 1);\\n        sessions[S] += task;\\n    }\\n\\n    // Return min sessions\\n    return min;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Depth-First Search"
                ],
                "code": "```Typescript\\nfunction minSessions(tasks: number[], sessionTime: number): number {\\n    const N = tasks.length;\\n    const sessions: number[] = new Array(N).fill(sessionTime);\\n    return helper(tasks, sessions, N, N, 0);\\n};\\n\\nfunction helper(tasks: number[], sessions: number[], min: number, T: number, S: number): number {\\n\\n    // If we\\'ve run out of tasks, return # of sessions\\n    if (T <= 0) {\\n        return S;\\n    }\\n\\n    // Get the current task\\n    const task = tasks[--T];\\n\\n    // For each existing session:\\n    for (let j = 0; j < S && S < min; ++j) {\\n        // Add task to session (if it fits)\\n        if (sessions[j] >= task) {\\n            sessions[j] -= task;\\n            min = helper(tasks, sessions, min, T, S);\\n            sessions[j] += task;\\n        }\\n    }\\n\\n    // Add task to a new session\\n    if (S + 1 < min) {\\n        sessions[S] -= task;\\n        min = helper(tasks, sessions, min, T, S + 1);\\n        sessions[S] += task;\\n    }\\n\\n    // Return min sessions\\n    return min;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4073978,
                "title": "simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCheck one-bu-one through every sssion time.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs it is given that sessionTime is greater than or equal to the maximum element in tasks[i] : it means that there can be maximum of tasks.length sessions , not more than that.\\n\\nNow approach is very clear, check from 1 to the length of tasks, the smallest length at which tasks will be completed willl b the answer.\\n\\n---\\nHave a look at the code , still have any confusion then please let me know in the comments\\nKeep Solving.:)\\n\\n# Complexity\\n- Time complexity : $$O(n*2^n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : $$O(n*2^n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static int minSessions(int[] tasks, int sessionTime) {\\n        \\n        for( int i = 1; i <= tasks.length; i++){\\n            if( checkifcanbecompleted_i( tasks, new int[i], 0, sessionTime)){\\n                return i;\\n            }\\n        }\\n        throw new IllegalArgumentException();\\n    }\\n\\n    // this function checks whether tasks can be completed or not : given \\'c\\' tasks are completed\\n    static boolean checkifcanbecompleted_i( int[] tasks, int[] curSession, int c, int sessionTime){\\n        if( c == tasks.length){\\n            return true;\\n        }\\n        for( int i = 0; i < curSession.length; i++){\\n            // if task assigning not possible then proceed to next iterations\\n            if( curSession[i] + tasks[c] > sessionTime){\\n                continue;\\n            }\\n            // assigning task to this session\\n            curSession[i] += tasks[c];\\n            if( checkifcanbecompleted_i(tasks, curSession, c+1, sessionTime)){\\n                return true;\\n            }\\n            //backtrack\\n            curSession[i] -= tasks[c];\\n            // if reached here without going further it means cann\\'t solve any more\\n            if( curSession[i] == 0){\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int minSessions(int[] tasks, int sessionTime) {\\n        \\n        for( int i = 1; i <= tasks.length; i++){\\n            if( checkifcanbecompleted_i( tasks, new int[i], 0, sessionTime)){\\n                return i;\\n            }\\n        }\\n        throw new IllegalArgumentException();\\n    }\\n\\n    // this function checks whether tasks can be completed or not : given \\'c\\' tasks are completed\\n    static boolean checkifcanbecompleted_i( int[] tasks, int[] curSession, int c, int sessionTime){\\n        if( c == tasks.length){\\n            return true;\\n        }\\n        for( int i = 0; i < curSession.length; i++){\\n            // if task assigning not possible then proceed to next iterations\\n            if( curSession[i] + tasks[c] > sessionTime){\\n                continue;\\n            }\\n            // assigning task to this session\\n            curSession[i] += tasks[c];\\n            if( checkifcanbecompleted_i(tasks, curSession, c+1, sessionTime)){\\n                return true;\\n            }\\n            //backtrack\\n            curSession[i] -= tasks[c];\\n            // if reached here without going further it means cann\\'t solve any more\\n            if( curSession[i] == 0){\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4028461,
                "title": "python-2sum-hack-36ms-99-main-algo-credit-sorrow-dada",
                "content": "# Intuition\\nMain idea of the algorithm is borrowed from @sorrow_data\\'s solution, which currently should have the best runtime performance for Python\\n\\n# Approach\\nSimple: \\n1. Keep removing pairs of tasks that sum exactly to session time\\n2. This can be achieved using similar methods as 2Sum, where we keep a hashtable\\n3. Once we removed these elements, it will greatly significantly speed up the algorithm. Since for each removed pair we are reducing the amount of calculation by 2N, since in this algorithm, we have to try all N positions in the work sessions array for each task\\n4. I\\'ve changed the work_sessions array to become increasingly sorted, in order to perform an early exit when we find that it is impossible to add the current task to the current session\\n5. m is used to keep track of the amount of sessions in the bucket array, since there is no straightforward way of getting this info efficiently\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N^2), since for each task we try a maximum of N positions, and m is just used for tracking and does not correlate with the recursion process\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N) bound by either the dictionary we used to remove pairs or the work_sessions array\\n# Code\\n```\\nclass Solution:\\n    def minSessions(self, tasks: List[int], sessionTime: int) -> int:\\n        ct = collections.Counter(tasks)\\n        res = 0\\n        if sessionTime in ct:\\n            res += ct[sessionTime]\\n            del ct[sessionTime]\\n        half = sessionTime // 2\\n        if sessionTime % 2 == 0 and half in ct:\\n            res += ct[half] // 2\\n            ct[half] = int(ct[half] % 2 != 0)\\n        for k, v in ct.items():\\n            target = sessionTime - k\\n            if ct[k] > 0 and target in ct and ct[target] > 0 and k != target:\\n                tempmin =  min(ct[k], ct[target])\\n                res += tempmin\\n                ct[k] -= tempmin\\n                ct[target] -= tempmin\\n        tasks = []\\n        for k, v in ct.items():\\n            if v > 0:\\n                tasks.extend([k] * v)\\n        n = len(tasks)\\n        if n == 0:\\n            return res\\n        if n == 1:\\n            return res + 1\\n        tasks.sort(reverse=True)\\n        task_count = len(tasks)\\n        work_sessions = [0] * (sessionTime + 1)\\n        \\n        # Initialize a variable to store the minimum number of sessions needed\\n        min_sessions = task_count\\n        \\n        def dfs(current_task_index, m):\\n            # Make the variable min_sessions accessible to the function\\n            nonlocal min_sessions\\n            # If the number of work sessions is greater than or equal to the minimum number of sessions, return\\n            if m >= min_sessions: \\n                return\\n            # If we have reached the end of the tasks, update the minimum number of sessions\\n            if current_task_index == task_count:\\n                min_sessions = m\\n                return\\n            cur_time = tasks[current_task_index]\\n            found = False\\n            for i in range(sessionTime + 1):\\n                # If the current task can be added to the session without exceeding the session time, add it\\n                if work_sessions[i] != 0:\\n                    next = i + cur_time\\n                    if next <= sessionTime:\\n                        found = True\\n                        work_sessions[i] -= 1\\n                        work_sessions[next] += 1\\n                        # Recursively call the function to check the next task\\n                        dfs(current_task_index + 1, m)\\n                        # Remove the task from the session to check other possibilities\\n                        work_sessions[next] -= 1\\n                        work_sessions[i] += 1\\n                    else:\\n                        break\\n            # If the task cannot be added to any existing session, create a new session\\n            work_sessions[cur_time] += 1\\n            dfs(current_task_index + 1, m + 1)\\n            # Remove the newly created session to check other possibilities\\n            work_sessions[cur_time] -= 1\\n        # Start the function from the first task\\n        dfs(0, 0)\\n        \\n        return res + min_sessions\\n```",
                "solutionTags": [
                    "Python3",
                    "Bucket Sort"
                ],
                "code": "```\\nclass Solution:\\n    def minSessions(self, tasks: List[int], sessionTime: int) -> int:\\n        ct = collections.Counter(tasks)\\n        res = 0\\n        if sessionTime in ct:\\n            res += ct[sessionTime]\\n            del ct[sessionTime]\\n        half = sessionTime // 2\\n        if sessionTime % 2 == 0 and half in ct:\\n            res += ct[half] // 2\\n            ct[half] = int(ct[half] % 2 != 0)\\n        for k, v in ct.items():\\n            target = sessionTime - k\\n            if ct[k] > 0 and target in ct and ct[target] > 0 and k != target:\\n                tempmin =  min(ct[k], ct[target])\\n                res += tempmin\\n                ct[k] -= tempmin\\n                ct[target] -= tempmin\\n        tasks = []\\n        for k, v in ct.items():\\n            if v > 0:\\n                tasks.extend([k] * v)\\n        n = len(tasks)\\n        if n == 0:\\n            return res\\n        if n == 1:\\n            return res + 1\\n        tasks.sort(reverse=True)\\n        task_count = len(tasks)\\n        work_sessions = [0] * (sessionTime + 1)\\n        \\n        # Initialize a variable to store the minimum number of sessions needed\\n        min_sessions = task_count\\n        \\n        def dfs(current_task_index, m):\\n            # Make the variable min_sessions accessible to the function\\n            nonlocal min_sessions\\n            # If the number of work sessions is greater than or equal to the minimum number of sessions, return\\n            if m >= min_sessions: \\n                return\\n            # If we have reached the end of the tasks, update the minimum number of sessions\\n            if current_task_index == task_count:\\n                min_sessions = m\\n                return\\n            cur_time = tasks[current_task_index]\\n            found = False\\n            for i in range(sessionTime + 1):\\n                # If the current task can be added to the session without exceeding the session time, add it\\n                if work_sessions[i] != 0:\\n                    next = i + cur_time\\n                    if next <= sessionTime:\\n                        found = True\\n                        work_sessions[i] -= 1\\n                        work_sessions[next] += 1\\n                        # Recursively call the function to check the next task\\n                        dfs(current_task_index + 1, m)\\n                        # Remove the task from the session to check other possibilities\\n                        work_sessions[next] -= 1\\n                        work_sessions[i] += 1\\n                    else:\\n                        break\\n            # If the task cannot be added to any existing session, create a new session\\n            work_sessions[cur_time] += 1\\n            dfs(current_task_index + 1, m + 1)\\n            # Remove the newly created session to check other possibilities\\n            work_sessions[cur_time] -= 1\\n        # Start the function from the first task\\n        dfs(0, 0)\\n        \\n        return res + min_sessions\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3996021,
                "title": "tc-o-logn-n-sc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSessions(int[] tasks, int sessionTime) {\\n       int n=tasks.length;\\n      int l=1;\\n      int h=n;\\n\\n      int ans=-1;\\n      while(l<=h){\\n          int mid=l+(h-l)/2;\\n          int time[]=new int[mid];\\n\\n          if(isPossible(tasks,0,sessionTime,time))\\n          {\\n              ans=mid;\\n              h=mid-1;\\n          }\\n          else{\\n              l=mid+1;\\n          }\\n\\n      }\\n      return ans;\\n        \\n    }\\n    boolean isPossible(int tasks[],int ind,int sessionTime,int time[]){\\n        if(ind>=tasks.length)\\n        return true;\\n\\n\\n\\nfor(int i=0;i<time.length;i++){\\n    \\n    if(time[i]+tasks[ind]<=sessionTime){\\n        \\n        time[i]+=tasks[ind];\\n        if(isPossible(tasks,ind+1,sessionTime,time)){\\n            return true;\\n        }\\n        time[i]-=tasks[ind];\\n\\n    }\\n    if(time[i]==0)\\n    break;\\n}\\nreturn false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int minSessions(int[] tasks, int sessionTime) {\\n       int n=tasks.length;\\n      int l=1;\\n      int h=n;\\n\\n      int ans=-1;\\n      while(l<=h){\\n          int mid=l+(h-l)/2;\\n          int time[]=new int[mid];\\n\\n          if(isPossible(tasks,0,sessionTime,time))\\n          {\\n              ans=mid;\\n              h=mid-1;\\n          }\\n          else{\\n              l=mid+1;\\n          }\\n\\n      }\\n      return ans;\\n        \\n    }\\n    boolean isPossible(int tasks[],int ind,int sessionTime,int time[]){\\n        if(ind>=tasks.length)\\n        return true;\\n\\n\\n\\nfor(int i=0;i<time.length;i++){\\n    \\n    if(time[i]+tasks[ind]<=sessionTime){\\n        \\n        time[i]+=tasks[ind];\\n        if(isPossible(tasks,ind+1,sessionTime,time)){\\n            return true;\\n        }\\n        time[i]-=tasks[ind];\\n\\n    }\\n    if(time[i]==0)\\n    break;\\n}\\nreturn false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988158,
                "title": "straight-forward-solution-easy-approach-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(int x , int time , int mx , vector<int> &a , vector<vector<int>>&dp , int n) {\\n      if(x == (1 << n)-1) return 1;\\n      if(dp[x][time] != -1) return dp[x][time];\\n      int ans = 1e8;\\n      for(int i = 0 ; i < n ; i++) {\\n        if(!(x & (1 << i))) {\\n            if(time + a[i] <= mx) {\\n                ans = min(ans,solve(x|(1<<i),time+a[i],mx,a,dp,n));\\n            }\\n            ans = min(ans,1 + solve(x|(1<<i),a[i],mx,a,dp,n));\\n        }\\n      }\\n      return dp[x][time] = ans;\\n    }\\n    \\n    int minSessions(vector<int>& a, int sessionTime) {\\n        int n = (int)a.size();\\n        vector<vector<int>>dp((1 << 16)+10,vector<int>(sessionTime+2,-1));\\n        return solve(0,0,sessionTime,a,dp,n);\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int x , int time , int mx , vector<int> &a , vector<vector<int>>&dp , int n) {\\n      if(x == (1 << n)-1) return 1;\\n      if(dp[x][time] != -1) return dp[x][time];\\n      int ans = 1e8;\\n      for(int i = 0 ; i < n ; i++) {\\n        if(!(x & (1 << i))) {\\n            if(time + a[i] <= mx) {\\n                ans = min(ans,solve(x|(1<<i),time+a[i],mx,a,dp,n));\\n            }\\n            ans = min(ans,1 + solve(x|(1<<i),a[i],mx,a,dp,n));\\n        }\\n      }\\n      return dp[x][time] = ans;\\n    }\\n    \\n    int minSessions(vector<int>& a, int sessionTime) {\\n        int n = (int)a.size();\\n        vector<vector<int>>dp((1 << 16)+10,vector<int>(sessionTime+2,-1));\\n        return solve(0,0,sessionTime,a,dp,n);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3970218,
                "title": "dp-with-bitmasking-solution-fastest-shortest-clean-code-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhat if we try to find best way for completing only one work and then two and then three so on so that we can use the previous generated result to compute new result ......\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSessions(int[] tasks, int st) {\\n        int visited=0;\\n\\n        //to check that we have completed all elements\\n        int target=(int)Math.pow(2,tasks.length)-1;\\n\\n        //to store intermediate results\\n        int[][] dp=new int[target+1][2];\\n        //base\\n        dp[0]=new int[]{1,st};\\n\\n\\n\\n        //this is the main heart of algorithm \\n        //1---0001.    3---0011----1st took(0010)--and then (0001)   means  whatever we took first if space remaining in that we can use that space else create new\\n        //2---0010               or 1st took(0001)--and then (0010)\\n        for(int bits=1;bits<=target;bits++){\\n            int[] dem=new int[]{Integer.MAX_VALUE,0};\\n\\n            //checking only for bits that are set\\n            for(int i=0;i<tasks.length;i++){\\n                  int ele=tasks[i];\\n\\n                  if((bits & (1<<i)) !=0){\\n                       int temp=bits ^ (1<<i);\\n                   \\n                   //if space exist\\n                       if(dp[temp][1]>=ele){\\n                           int[] pair=new int[]{dp[temp][0],dp[temp][1]-ele};\\n                           if(dem[0]>pair[0]){\\n                               dem=pair;\\n                           }else if(dem[0]==pair[0] && dem[1]<pair[1]){\\n                               dem=pair;\\n                           }\\n                       }\\n                       //if not\\n                       else{\\n                           int[] pair=new int[]{dp[temp][0]+1,st-ele};\\n                           if(dem[0]>pair[0]){\\n                               dem=pair;\\n                           }else if(dem[0]==pair[0] && dem[1]<pair[1]){\\n                               dem=pair;\\n                           }\\n                       }\\n                 }\\n   \\n            }\\n\\n            //storing the best possible result\\n            dp[bits]=dem;\\n\\n        }\\n      \\n        return dp[target][0];\\n    }\\n\\n   \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Backtracking",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    public int minSessions(int[] tasks, int st) {\\n        int visited=0;\\n\\n        //to check that we have completed all elements\\n        int target=(int)Math.pow(2,tasks.length)-1;\\n\\n        //to store intermediate results\\n        int[][] dp=new int[target+1][2];\\n        //base\\n        dp[0]=new int[]{1,st};\\n\\n\\n\\n        //this is the main heart of algorithm \\n        //1---0001.    3---0011----1st took(0010)--and then (0001)   means  whatever we took first if space remaining in that we can use that space else create new\\n        //2---0010               or 1st took(0001)--and then (0010)\\n        for(int bits=1;bits<=target;bits++){\\n            int[] dem=new int[]{Integer.MAX_VALUE,0};\\n\\n            //checking only for bits that are set\\n            for(int i=0;i<tasks.length;i++){\\n                  int ele=tasks[i];\\n\\n                  if((bits & (1<<i)) !=0){\\n                       int temp=bits ^ (1<<i);\\n                   \\n                   //if space exist\\n                       if(dp[temp][1]>=ele){\\n                           int[] pair=new int[]{dp[temp][0],dp[temp][1]-ele};\\n                           if(dem[0]>pair[0]){\\n                               dem=pair;\\n                           }else if(dem[0]==pair[0] && dem[1]<pair[1]){\\n                               dem=pair;\\n                           }\\n                       }\\n                       //if not\\n                       else{\\n                           int[] pair=new int[]{dp[temp][0]+1,st-ele};\\n                           if(dem[0]>pair[0]){\\n                               dem=pair;\\n                           }else if(dem[0]==pair[0] && dem[1]<pair[1]){\\n                               dem=pair;\\n                           }\\n                       }\\n                 }\\n   \\n            }\\n\\n            //storing the best possible result\\n            dp[bits]=dem;\\n\\n        }\\n      \\n        return dp[target][0];\\n    }\\n\\n   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3949628,
                "title": "easy-bitmasking-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int f(int currTime,int bitset,vector<int>&tasks,int n,vector<vector<int>>&dp,int &sessionTime){\\n        cout<<bitset<<endl;\\n        if(bitset==((1<<n)-1))\\n        return 1;\\n        if(dp[currTime][bitset]!=-1)\\n        return dp[currTime][bitset];\\n        int ans=INT_MAX;\\n        bool taskSelected=false;\\n        for(int i=0;i<n;i++){\\n            if(currTime+tasks[i]<=sessionTime && (bitset&(1<<i))==0)\\n            {\\n            ans=min(ans,f(currTime+tasks[i],bitset | (1<<i),tasks,n,dp,sessionTime));\\n            taskSelected=true;\\n            }\\n        }\\n        if(taskSelected)\\n        return dp[currTime][bitset]=ans;\\n        return dp[currTime][bitset]=1+f(0,bitset,tasks,n,dp,sessionTime);\\n    }\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        int n=tasks.size();\\n        vector<vector<int>>dp(sessionTime+1,vector<int>(1<<n,-1));\\n         f(0,0,tasks,n,dp,sessionTime);\\n         return dp[0][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int currTime,int bitset,vector<int>&tasks,int n,vector<vector<int>>&dp,int &sessionTime){\\n        cout<<bitset<<endl;\\n        if(bitset==((1<<n)-1))\\n        return 1;\\n        if(dp[currTime][bitset]!=-1)\\n        return dp[currTime][bitset];\\n        int ans=INT_MAX;\\n        bool taskSelected=false;\\n        for(int i=0;i<n;i++){\\n            if(currTime+tasks[i]<=sessionTime && (bitset&(1<<i))==0)\\n            {\\n            ans=min(ans,f(currTime+tasks[i],bitset | (1<<i),tasks,n,dp,sessionTime));\\n            taskSelected=true;\\n            }\\n        }\\n        if(taskSelected)\\n        return dp[currTime][bitset]=ans;\\n        return dp[currTime][bitset]=1+f(0,bitset,tasks,n,dp,sessionTime);\\n    }\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        int n=tasks.size();\\n        vector<vector<int>>dp(sessionTime+1,vector<int>(1<<n,-1));\\n         f(0,0,tasks,n,dp,sessionTime);\\n         return dp[0][0];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3935173,
                "title": "simply-java-dfs-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\napproach 1 : dfs + dp of visited using mask \\n\\n    - basically every node has the edge of every another node \\n    - keep track of visited using concept of mask \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n * 2^n * sessionTime)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\n\\napproach 1 : dfs + dp of visited using mask \\n\\n    - basically every node has the edge of every another node \\n    - keep track of visited using concept of mask \\n*/\\n\\nclass Solution {\\n\\n    // approach 1 : dfs + dp \\n    int time;\\n    int[] tasks;\\n    int totalTasks;\\n    int[][] cache;\\n\\n    public int minSessions(int[] tasks, int sessionTime) {\\n        this.time = sessionTime;\\n        this.tasks = tasks;\\n        this.totalTasks = tasks.length;\\n\\n        // limits\\n        cache = new int[1 << 15][16];\\n        for(int[] row : cache) {\\n            Arrays.fill(row, -1);\\n        }\\n\\n        // 1 for not visited \\n        int mask = (1 << this.totalTasks) - 1;\\n\\n\\n        return doDFS(this.time, 0, mask);\\n       \\n    }\\n\\n    public int doDFS(int curTime, int count, int mask) {\\n\\n        if(cache[mask][curTime] != -1) {\\n            return cache[mask][curTime];\\n        }\\n\\n        // all tasks have been added\\n        if(count == totalTasks) {\\n            return 0;\\n        }\\n        \\n        int result = Integer.MAX_VALUE;\\n        for(int i = 0; i < this.totalTasks; i++) {\\n\\n            if((mask & (1<<i)) == (1<<i)) {\\n                // mark visited\\n                mask =  mask ^ (1<<i);\\n                // add this to current time \\n                if(curTime + this.tasks[i] > time) {\\n                    result = Math.min(result, 1 + doDFS(this.tasks[i], count + 1, mask));\\n                } else {\\n                    result = Math.min(result,  doDFS(curTime + this.tasks[i], count + 1, mask));\\n                }\\n                // unmark visited\\n                mask =  mask ^ (1<<i);\\n            }\\n        }\\n\\n        cache[mask][curTime] = result;\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\n\\napproach 1 : dfs + dp of visited using mask \\n\\n    - basically every node has the edge of every another node \\n    - keep track of visited using concept of mask \\n*/\\n\\nclass Solution {\\n\\n    // approach 1 : dfs + dp \\n    int time;\\n    int[] tasks;\\n    int totalTasks;\\n    int[][] cache;\\n\\n    public int minSessions(int[] tasks, int sessionTime) {\\n        this.time = sessionTime;\\n        this.tasks = tasks;\\n        this.totalTasks = tasks.length;\\n\\n        // limits\\n        cache = new int[1 << 15][16];\\n        for(int[] row : cache) {\\n            Arrays.fill(row, -1);\\n        }\\n\\n        // 1 for not visited \\n        int mask = (1 << this.totalTasks) - 1;\\n\\n\\n        return doDFS(this.time, 0, mask);\\n       \\n    }\\n\\n    public int doDFS(int curTime, int count, int mask) {\\n\\n        if(cache[mask][curTime] != -1) {\\n            return cache[mask][curTime];\\n        }\\n\\n        // all tasks have been added\\n        if(count == totalTasks) {\\n            return 0;\\n        }\\n        \\n        int result = Integer.MAX_VALUE;\\n        for(int i = 0; i < this.totalTasks; i++) {\\n\\n            if((mask & (1<<i)) == (1<<i)) {\\n                // mark visited\\n                mask =  mask ^ (1<<i);\\n                // add this to current time \\n                if(curTime + this.tasks[i] > time) {\\n                    result = Math.min(result, 1 + doDFS(this.tasks[i], count + 1, mask));\\n                } else {\\n                    result = Math.min(result,  doDFS(curTime + this.tasks[i], count + 1, mask));\\n                }\\n                // unmark visited\\n                mask =  mask ^ (1<<i);\\n            }\\n        }\\n\\n        cache[mask][curTime] = result;\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3863888,
                "title": "dp-bitmask-complete-code-walkthrough-c",
                "content": "# Intuition\\nFirst thoughts seeing the problem I got was that I have to try all the permutations possible for `tasks` array. Thus DP + Bitmask came to my mind. Since using a visited array will be very slow + it would require a map to store and access saved results.\\n\\n# Approach\\nCreated a mask storing the tasks that has been done. If the `ith bit` of mask is set it means the `tasks[i]` is not done yet and vice versa.\\n\\nThere are three cases possible after we find a task which hasn\\'t been done yet :\\n1. The time that the task takes is more than the remaining time of ongoing session, in this case we have to move this task to a new session.\\n```\\nif(a[i] > time){\\n    ans = min(ans , 1 + helper(mask^(1<<i) , a, res - a[i]));\\n}\\n```\\n2. The time that the task takes is exactly equal to the remaining time of ongoing session, in this case we start a new session with the default sessionTime.\\n```\\nelse if(a[i] == time){\\n    ans = min(ans , 1 + helper(mask^(1<<i) , a, res));\\n}\\n```\\n3. Lastly if the time that the task takes is less than the remaining time of ongoing session, tn this case we subtract the time of task from the remaining time.\\n```\\nelse{\\n    ans = min(ans , helper(mask^(1<<i) , a, time - a[i]));\\n}\\n```\\n\\n# Code\\n```\\nint res;\\nclass Solution {\\npublic:\\n    int dp[1<<14][16];\\n    int helper(int mask, vector<int>&a, int time){\\n        if(mask == 0){\\n            return time < res;\\n        }\\n\\n        if(dp[mask][time] != -1)\\n            return dp[mask][time];\\n\\n        int ans = INT_MAX;\\n        for(int i = 0;i<a.size();i++){\\n            if(mask&(1<<i)){\\n                if(a[i] > time){\\n                    ans = min(ans , 1 + helper(mask^(1<<i) , a, res - a[i]));\\n                }else if(a[i] == time){\\n                    ans = min(ans , 1 + helper(mask^(1<<i) , a, res));\\n                }else{\\n                    ans = min(ans , helper(mask^(1<<i) , a, time - a[i]));\\n                }\\n            }\\n        }\\n\\n        return dp[mask][time] = ans;\\n    }\\n\\n\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        int n = tasks.size();\\n        int mask = (1<<n);\\n        res = sessionTime;\\n        mask--;\\n        memset(dp,-1,sizeof(dp));\\n\\n        return helper(mask, tasks, sessionTime);\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nif(a[i] > time){\\n    ans = min(ans , 1 + helper(mask^(1<<i) , a, res - a[i]));\\n}\\n```\n```\\nelse if(a[i] == time){\\n    ans = min(ans , 1 + helper(mask^(1<<i) , a, res));\\n}\\n```\n```\\nelse{\\n    ans = min(ans , helper(mask^(1<<i) , a, time - a[i]));\\n}\\n```\n```\\nint res;\\nclass Solution {\\npublic:\\n    int dp[1<<14][16];\\n    int helper(int mask, vector<int>&a, int time){\\n        if(mask == 0){\\n            return time < res;\\n        }\\n\\n        if(dp[mask][time] != -1)\\n            return dp[mask][time];\\n\\n        int ans = INT_MAX;\\n        for(int i = 0;i<a.size();i++){\\n            if(mask&(1<<i)){\\n                if(a[i] > time){\\n                    ans = min(ans , 1 + helper(mask^(1<<i) , a, res - a[i]));\\n                }else if(a[i] == time){\\n                    ans = min(ans , 1 + helper(mask^(1<<i) , a, res));\\n                }else{\\n                    ans = min(ans , helper(mask^(1<<i) , a, time - a[i]));\\n                }\\n            }\\n        }\\n\\n        return dp[mask][time] = ans;\\n    }\\n\\n\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        int n = tasks.size();\\n        int mask = (1<<n);\\n        res = sessionTime;\\n        mask--;\\n        memset(dp,-1,sizeof(dp));\\n\\n        return helper(mask, tasks, sessionTime);\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3755651,
                "title": "dp-bitmask",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTake or not take approach\\n\\n# Complexity\\n- Time complexity: O(sessionTime*(2^n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(sessionTime*(2^n))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector <int> tasks;\\n    int n, cap;\\n    int dp[17384][16];\\n    int f(int mask, int sum){\\n        if(mask==(1<<n)-1) return 1;\\n        if(dp[mask][sum]!=-1) return dp[mask][sum];\\n        int ans = INT_MAX-100;\\n        for(int i=0; i<n; i++){\\n            if(mask&(1<<i)) continue;\\n            int temp;\\n            if(sum+tasks[i]<=cap){\\n                temp = min(f(mask|(1<<i), sum+tasks[i]), 1+f(mask|(1<<i), tasks[i]));\\n            }else temp = 1+f(mask|(1<<i), tasks[i]);\\n            ans = min(ans, temp);\\n        }\\n        return dp[mask][sum] = ans;\\n    }\\n\\n    int minSessions(vector<int>& Tasks, int sessionTime) {\\n        memset(dp, -1, sizeof(dp));\\n        tasks = Tasks;\\n        n = tasks.size();\\n        cap = sessionTime;\\n        return f(0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector <int> tasks;\\n    int n, cap;\\n    int dp[17384][16];\\n    int f(int mask, int sum){\\n        if(mask==(1<<n)-1) return 1;\\n        if(dp[mask][sum]!=-1) return dp[mask][sum];\\n        int ans = INT_MAX-100;\\n        for(int i=0; i<n; i++){\\n            if(mask&(1<<i)) continue;\\n            int temp;\\n            if(sum+tasks[i]<=cap){\\n                temp = min(f(mask|(1<<i), sum+tasks[i]), 1+f(mask|(1<<i), tasks[i]));\\n            }else temp = 1+f(mask|(1<<i), tasks[i]);\\n            ans = min(ans, temp);\\n        }\\n        return dp[mask][sum] = ans;\\n    }\\n\\n    int minSessions(vector<int>& Tasks, int sessionTime) {\\n        memset(dp, -1, sizeof(dp));\\n        tasks = Tasks;\\n        n = tasks.size();\\n        cap = sessionTime;\\n        return f(0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738248,
                "title": "super-simple-javascript-backtracking-solution",
                "content": "```js\\nconst minSessions = (tasks, k) => {\\n    let min = Infinity;\\n    sessions = [];\\n\\n    const bt = (i = 0) => {\\n        // prune paths that are not better than best so far\\n        if (sessions.length >= min) return;\\n        // reached end of tasks, capture minimum session count\\n        if (i === tasks.length) {\\n            min = Math.min(min, sessions.length);\\n            return;\\n        }\\n        // consider all open sessions\\n        for (let j = 0; j < sessions.length; j++) {\\n            // try all sessions current task fits in\\n            if (sessions[j] + tasks[i] <= k) {\\n                sessions[j] += tasks[i];\\n                // don\\'t create session for task\\n                bt(i + 1);\\n                // backtrack\\n                sessions[j] -= tasks[i];\\n            }\\n        }\\n        // create a new session for task\\n        sessions.push(tasks[i]);\\n        bt(i + 1);\\n        // backtrack\\n        sessions.pop();\\n    }\\n    \\n    bt();\\n    return min;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```js\\nconst minSessions = (tasks, k) => {\\n    let min = Infinity;\\n    sessions = [];\\n\\n    const bt = (i = 0) => {\\n        // prune paths that are not better than best so far\\n        if (sessions.length >= min) return;\\n        // reached end of tasks, capture minimum session count\\n        if (i === tasks.length) {\\n            min = Math.min(min, sessions.length);\\n            return;\\n        }\\n        // consider all open sessions\\n        for (let j = 0; j < sessions.length; j++) {\\n            // try all sessions current task fits in\\n            if (sessions[j] + tasks[i] <= k) {\\n                sessions[j] += tasks[i];\\n                // don\\'t create session for task\\n                bt(i + 1);\\n                // backtrack\\n                sessions[j] -= tasks[i];\\n            }\\n        }\\n        // create a new session for task\\n        sessions.push(tasks[i]);\\n        bt(i + 1);\\n        // backtrack\\n        sessions.pop();\\n    }\\n    \\n    bt();\\n    return min;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3728792,
                "title": "simple-c-solution-dynamic-programming-bitmask",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint hope(int time,vector<int>&tasks,int mask,int &session,vector<vector<int>>&dp){\\n    if(mask==pow(2,tasks.size())-1)return 0;\\n    if(dp[time][mask]!=-1)return dp[time][mask];\\nint ans=1e9;\\nint curr1=1e9;\\nint curr2=1e9;\\nfor(int i=0;i<tasks.size();i++){\\n    if(((1<<i)&(mask))==0){\\n        if(mask==0){\\n            curr1=1+hope(session-tasks[i],tasks,((mask)|(1<<i)),session,dp);\\n        }\\n        else if(mask!=0){\\n        if(tasks[i]<=time){\\n            curr1=hope(time-tasks[i],tasks,((mask)|(1<<i)),session,dp);\\n        }\\n        else if(tasks[i]>time){\\n            curr2=1+hope(session-tasks[i],tasks,((mask)|(1<<i)),session,dp);\\n        }\\n        }\\n    }\\n    ans=min({ans,curr1,curr2});\\n}\\nreturn dp[time][mask]=ans;\\n}\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        vector<vector<int>>dp(16,vector<int>(pow(2,15)+1,-1));\\n        return hope(sessionTime,tasks,0,sessionTime,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint hope(int time,vector<int>&tasks,int mask,int &session,vector<vector<int>>&dp){\\n    if(mask==pow(2,tasks.size())-1)return 0;\\n    if(dp[time][mask]!=-1)return dp[time][mask];\\nint ans=1e9;\\nint curr1=1e9;\\nint curr2=1e9;\\nfor(int i=0;i<tasks.size();i++){\\n    if(((1<<i)&(mask))==0){\\n        if(mask==0){\\n            curr1=1+hope(session-tasks[i],tasks,((mask)|(1<<i)),session,dp);\\n        }\\n        else if(mask!=0){\\n        if(tasks[i]<=time){\\n            curr1=hope(time-tasks[i],tasks,((mask)|(1<<i)),session,dp);\\n        }\\n        else if(tasks[i]>time){\\n            curr2=1+hope(session-tasks[i],tasks,((mask)|(1<<i)),session,dp);\\n        }\\n        }\\n    }\\n    ans=min({ans,curr1,curr2});\\n}\\nreturn dp[time][mask]=ans;\\n}\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        vector<vector<int>>dp(16,vector<int>(pow(2,15)+1,-1));\\n        return hope(sessionTime,tasks,0,sessionTime,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3704465,
                "title": "easy-js-solution",
                "content": "# Code\\n```\\nvar minSessions = function(tasks, sessionTime) {\\n    let ans = Infinity;\\n    const buckets = []\\n    const solve = (idx = 0) => {\\n        if (idx === tasks.length) {\\n            ans = Math.min(ans, buckets.length);\\n            return;\\n        }\\n        if (buckets.length >= ans) return;\\n        // try to fit it in any existing bucket\\n        for(let i = 0; i < buckets.length; i++) {\\n            const bucket = buckets[i];\\n            if (bucket + tasks[idx] <= sessionTime) {\\n                buckets[i] += tasks[idx];\\n                solve(idx + 1);\\n                buckets[i] -= tasks[idx];\\n            }\\n        }\\n\\n        // OR\\n\\n        // create one\\n        buckets.push(tasks[idx]);\\n        solve(idx + 1);\\n        buckets.pop();\\n    }\\n    solve();\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minSessions = function(tasks, sessionTime) {\\n    let ans = Infinity;\\n    const buckets = []\\n    const solve = (idx = 0) => {\\n        if (idx === tasks.length) {\\n            ans = Math.min(ans, buckets.length);\\n            return;\\n        }\\n        if (buckets.length >= ans) return;\\n        // try to fit it in any existing bucket\\n        for(let i = 0; i < buckets.length; i++) {\\n            const bucket = buckets[i];\\n            if (bucket + tasks[idx] <= sessionTime) {\\n                buckets[i] += tasks[idx];\\n                solve(idx + 1);\\n                buckets[i] -= tasks[idx];\\n            }\\n        }\\n\\n        // OR\\n\\n        // create one\\n        buckets.push(tasks[idx]);\\n        solve(idx + 1);\\n        buckets.pop();\\n    }\\n    solve();\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3695839,
                "title": "dynamic-programming-bit-manipulation-solution",
                "content": "```\\nclass Solution:\\n    def minSessions(self, tasks: List[int], sessionTime: int) -> int:\\n        n = len(tasks)\\n        allVisited = (1 << n) - 1\\n        \\n        @lru_cache(None)\\n        def dfs(currentNumber, currentSession, visited):\\n            if visited == allVisited:\\n                return currentNumber if currentSession == 0 else currentNumber + 1\\n            if currentSession == sessionTime:\\n                currentNumber += 1\\n                currentSession = 0\\n            currentMin = float(\\'inf\\')\\n            for i in range(n):\\n                if visited & (1 << i) == 0:\\n                    if currentSession + tasks[i] <= sessionTime:\\n                        visited |= (1 << i)\\n                        currentMin = min(currentMin, dfs(currentNumber, currentSession + tasks[i], visited))\\n                        visited ^= (1 << i)\\n            if currentMin == float(\\'inf\\'):\\n                currentNumber += 1\\n                currentSession = 0\\n                return dfs(currentNumber, currentSession, visited)\\n            return currentMin\\n        \\n        return dfs(0, 0, 0)\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Bit Manipulation",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minSessions(self, tasks: List[int], sessionTime: int) -> int:\\n        n = len(tasks)\\n        allVisited = (1 << n) - 1\\n        \\n        @lru_cache(None)\\n        def dfs(currentNumber, currentSession, visited):\\n            if visited == allVisited:\\n                return currentNumber if currentSession == 0 else currentNumber + 1\\n            if currentSession == sessionTime:\\n                currentNumber += 1\\n                currentSession = 0\\n            currentMin = float(\\'inf\\')\\n            for i in range(n):\\n                if visited & (1 << i) == 0:\\n                    if currentSession + tasks[i] <= sessionTime:\\n                        visited |= (1 << i)\\n                        currentMin = min(currentMin, dfs(currentNumber, currentSession + tasks[i], visited))\\n                        visited ^= (1 << i)\\n            if currentMin == float(\\'inf\\'):\\n                currentNumber += 1\\n                currentSession = 0\\n                return dfs(currentNumber, currentSession, visited)\\n            return currentMin\\n        \\n        return dfs(0, 0, 0)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689661,
                "title": "3d-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n   int ans1;\\n   int f(int ind,vector<int>&task,int st,int mask,int wt,int ans,vector<vector<vector<int>>>&dp){\\n      if(mask==0){ return 1;}\\n     if(ind>=task.size())return INT_MAX;\\n     if(dp[ind][wt][mask]!=-1)return dp[ind][wt][mask];\\n      int pick=INT_MAX;\\n      if(mask&(1<<ind)){\\n       if(wt+task[ind]<=st)\\n       pick=  f(ind+1,task,st,mask^(1<<ind),wt+task[ind],ans,dp);\\n       else pick=1+f(0,task,st,mask,0,ans+1,dp);\\n      }\\n     int nopick=  f(ind+1,task,st,mask,wt,ans,dp);\\n   return  dp[ind][wt][mask]=min(pick,nopick);\\n\\n   }\\n\\n    int minSessions(vector<int>& task, int st) {\\n       int n=task.size();\\n vector<vector<vector<int>>>dp(n,vector<vector<int>>(20,vector<int>(1<<n,-1)));\\n    return f(0,task,st,(1<<n)-1,0,1,dp);\\n     \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n   int ans1;\\n   int f(int ind,vector<int>&task,int st,int mask,int wt,int ans,vector<vector<vector<int>>>&dp){\\n      if(mask==0){ return 1;}\\n     if(ind>=task.size())return INT_MAX;\\n     if(dp[ind][wt][mask]!=-1)return dp[ind][wt][mask];\\n      int pick=INT_MAX;\\n      if(mask&(1<<ind)){\\n       if(wt+task[ind]<=st)\\n       pick=  f(ind+1,task,st,mask^(1<<ind),wt+task[ind],ans,dp);\\n       else pick=1+f(0,task,st,mask,0,ans+1,dp);\\n      }\\n     int nopick=  f(ind+1,task,st,mask,wt,ans,dp);\\n   return  dp[ind][wt][mask]=min(pick,nopick);\\n\\n   }\\n\\n    int minSessions(vector<int>& task, int st) {\\n       int n=task.size();\\n vector<vector<vector<int>>>dp(n,vector<vector<int>>(20,vector<int>(1<<n,-1)));\\n    return f(0,task,st,(1<<n)-1,0,1,dp);\\n     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3666418,
                "title": "bitmasking-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[1<<14][20];\\n    int find(vector<int>&tasks,int vis,int timeSpent,int time)\\n    {\\n        if(__builtin_popcount(vis) == tasks.size()) return 0;\\n        if(dp[vis][timeSpent]!=-1) return dp[vis][timeSpent];\\n        int a = 1e9;\\n        for(int i=0;i<tasks.size();++i)\\n        {\\n            if(((1<<i)&vis) == 0)\\n            {\\n                if(timeSpent-tasks[i]>=0)\\n                {\\n                    int temp = vis;\\n                    vis|=1<<i;\\n                    a=min(a,find(tasks,vis,timeSpent-tasks[i],time));\\n                    vis=temp;\\n                }\\n                else\\n                {\\n                    int temp = vis;\\n                    vis|=1<<i;\\n                    a=min(a,1+find(tasks,vis,time-tasks[i],time));\\n                    vis=temp;\\n                }\\n            }\\n        }\\n         return dp[vis][timeSpent]=a;\\n        \\n        \\n    }\\n    int minSessions(vector<int>& tasks, int time) {\\n        memset(dp,-1,sizeof(dp));\\n        return 1+find(tasks,0,time,time);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Memoization",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1<<14][20];\\n    int find(vector<int>&tasks,int vis,int timeSpent,int time)\\n    {\\n        if(__builtin_popcount(vis) == tasks.size()) return 0;\\n        if(dp[vis][timeSpent]!=-1) return dp[vis][timeSpent];\\n        int a = 1e9;\\n        for(int i=0;i<tasks.size();++i)\\n        {\\n            if(((1<<i)&vis) == 0)\\n            {\\n                if(timeSpent-tasks[i]>=0)\\n                {\\n                    int temp = vis;\\n                    vis|=1<<i;\\n                    a=min(a,find(tasks,vis,timeSpent-tasks[i],time));\\n                    vis=temp;\\n                }\\n                else\\n                {\\n                    int temp = vis;\\n                    vis|=1<<i;\\n                    a=min(a,1+find(tasks,vis,time-tasks[i],time));\\n                    vis=temp;\\n                }\\n            }\\n        }\\n         return dp[vis][timeSpent]=a;\\n        \\n        \\n    }\\n    int minSessions(vector<int>& tasks, int time) {\\n        memset(dp,-1,sizeof(dp));\\n        return 1+find(tasks,0,time,time);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3582785,
                "title": "python-simple-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minSessions(self, tasks, sessionTime):\\n        n, ans = len(tasks), []\\n\\n        self.min = n\\n\\n        tasks.sort(reverse = True)\\n\\n        def backtrack(i):\\n            if len(ans) >= self.min:\\n                return\\n\\n            if i == n:\\n                self.min = min(self.min,len(ans))\\n                return\\n\\n            for j in range(len(ans)):\\n                if tasks[i] + ans[j] <= sessionTime:\\n                    ans[j] += tasks[i]\\n                    backtrack(i+1)\\n                    ans[j] -= tasks[i]\\n                    if not ans[j]: break\\n\\n            ans.append(tasks[i])\\n            backtrack(i+1)\\n            ans.pop()\\n\\n            \\n        res = []\\n        backtrack(0)\\n        return self.min\\n\\n\\n        \\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSessions(self, tasks, sessionTime):\\n        n, ans = len(tasks), []\\n\\n        self.min = n\\n\\n        tasks.sort(reverse = True)\\n\\n        def backtrack(i):\\n            if len(ans) >= self.min:\\n                return\\n\\n            if i == n:\\n                self.min = min(self.min,len(ans))\\n                return\\n\\n            for j in range(len(ans)):\\n                if tasks[i] + ans[j] <= sessionTime:\\n                    ans[j] += tasks[i]\\n                    backtrack(i+1)\\n                    ans[j] -= tasks[i]\\n                    if not ans[j]: break\\n\\n            ans.append(tasks[i])\\n            backtrack(i+1)\\n            ans.pop()\\n\\n            \\n        res = []\\n        backtrack(0)\\n        return self.min\\n\\n\\n        \\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581022,
                "title": "c-easy-solution-dp-bitmask",
                "content": "```\\nclass Solution {\\nprivate:\\n    int limit;\\n    int dp[20000][150];\\n    int f(vector<int>& a, int mask, int curr){\\n        if(mask == (1<<a.size()) - 1) return 1;\\n        if(dp[mask][curr] != -1) return dp[mask][curr];\\n        int ans = 1e9;\\n        bool ok = 0;\\n        for(int i = 0; i<a.size(); ++i){\\n            if(mask & (1<<i)) continue;\\n            if(curr + a[i] <= limit){\\n                ok = 1;\\n                ans = min(ans, f(a, mask | (1<<i), curr + a[i]));\\n            }\\n        }\\n        if(ok== 0){\\n            ans = min(ans, 1 + f(a, mask, 0));\\n        }\\n        return dp[mask][curr] = ans;\\n    }\\npublic:\\n    int minSessions(vector<int>& a, int k) {\\n        memset(dp, -1, sizeof(dp));\\n        limit = k;\\n       return f(a, 0, 0); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int limit;\\n    int dp[20000][150];\\n    int f(vector<int>& a, int mask, int curr){\\n        if(mask == (1<<a.size()) - 1) return 1;\\n        if(dp[mask][curr] != -1) return dp[mask][curr];\\n        int ans = 1e9;\\n        bool ok = 0;\\n        for(int i = 0; i<a.size(); ++i){\\n            if(mask & (1<<i)) continue;\\n            if(curr + a[i] <= limit){\\n                ok = 1;\\n                ans = min(ans, f(a, mask | (1<<i), curr + a[i]));\\n            }\\n        }\\n        if(ok== 0){\\n            ans = min(ans, 1 + f(a, mask, 0));\\n        }\\n        return dp[mask][curr] = ans;\\n    }\\npublic:\\n    int minSessions(vector<int>& a, int k) {\\n        memset(dp, -1, sizeof(dp));\\n        limit = k;\\n       return f(a, 0, 0); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3540668,
                "title": "java-backtrack-implementation-with-a-clear-intuition-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe are looking for all possible ways of grouping tasks in groups so that total time of each group is smaller or equal to the sessionTime. Optimal solution has smallest number of groups. \\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe loop through the list of tasks:\\n1. Starting with the tasks[0]. We need to create a group for it.\\n2. Move to task[k]. It can be put in any the existing groups (if total time of that group + tasks[k]<= sessionTime), or it can be put in a new group.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int result = Integer.MAX_VALUE;\\n    public int minSessions(int[] tasks, int sessionTime) {\\n        backtrack(tasks, -1, 0, new int[tasks.length], sessionTime);\\n        return result;\\n    }\\n    private void backtrack(int[] tasks, int curTask, int curSize, int[] session, int sessionTime){\\n        if (curSize >= result) return;//Dont continue if number of groups is already large. This greatly improves performance.\\n        if (curTask == tasks.length - 1){\\n            result = Math.min(result, curSize);\\n            return;\\n        }\\n\\n        for(int i = 0; i<= curSize; i++){//nextTask = curTask + 1 can be placed in any groups, or in a new group.\\n            if (session[i] + tasks[curTask + 1] <= sessionTime){\\n                \\n                //Place\\n                session[i] += tasks[curTask + 1];\\n                boolean increaseSize = false;\\n                if (i == curSize) {\\n                    curSize++; increaseSize=true;\\n                }\\n\\n                backtrack(tasks, curTask + 1, curSize, session, sessionTime);\\n                \\n                //Remove\\n                session[i]-= tasks[curTask + 1];\\n                if (increaseSize){\\n                    curSize--;\\n                    }\\n                }\\n            }\\n        }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int result = Integer.MAX_VALUE;\\n    public int minSessions(int[] tasks, int sessionTime) {\\n        backtrack(tasks, -1, 0, new int[tasks.length], sessionTime);\\n        return result;\\n    }\\n    private void backtrack(int[] tasks, int curTask, int curSize, int[] session, int sessionTime){\\n        if (curSize >= result) return;//Dont continue if number of groups is already large. This greatly improves performance.\\n        if (curTask == tasks.length - 1){\\n            result = Math.min(result, curSize);\\n            return;\\n        }\\n\\n        for(int i = 0; i<= curSize; i++){//nextTask = curTask + 1 can be placed in any groups, or in a new group.\\n            if (session[i] + tasks[curTask + 1] <= sessionTime){\\n                \\n                //Place\\n                session[i] += tasks[curTask + 1];\\n                boolean increaseSize = false;\\n                if (i == curSize) {\\n                    curSize++; increaseSize=true;\\n                }\\n\\n                backtrack(tasks, curTask + 1, curSize, session, sessionTime);\\n                \\n                //Remove\\n                session[i]-= tasks[curTask + 1];\\n                if (increaseSize){\\n                    curSize--;\\n                    }\\n                }\\n            }\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531184,
                "title": "c-the-easiest-solution-there-is",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach and explination (TLE)\\n<!-- Describe your approach to solving the problem. -->\\n# Example (TLE)\\n\\n# Complexity (TLE)\\n\\n# Approach and explination \\n<!-- Describe your approach to solving the problem. -->\\n# Example \\n\\n# Complexity\\n\\n# Code\\n```\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3492070,
                "title": "my-solution",
                "content": "**Solution I**\\n```\\n/**\\n * Time Complexity: O((2 ^ n) + (3 ^ n))\\n * Space Complexity: O(2 ^ n)\\n * where `n` is the length of the vector `tasks`\\n */\\nclass Solution {\\n public:\\n  int minSessions(const vector<int> &tasks, const int sessionTime) {\\n    const int n = static_cast<int>(tasks.size());\\n    const int layouts = 1 << n;\\n    int tasks_time[layouts];\\n    memset(tasks_time, 0, sizeof(tasks_time));\\n    for (int task_to_finish = 0; task_to_finish < n; ++task_to_finish) {\\n      for (int subtasks = 0; subtasks < (1 << task_to_finish); ++subtasks) {\\n        tasks_time[(1 << task_to_finish) | subtasks] = tasks[task_to_finish] + tasks_time[subtasks];\\n      }\\n    }\\n    \\n    uint32_t dp[layouts];\\n    memset(dp, -1, sizeof(dp));\\n    dp[0] = 0;\\n    for (int tasks_to_finish = 1; tasks_to_finish < layouts; ++tasks_to_finish) {\\n      for (int subtasks = tasks_to_finish; subtasks > 0; subtasks = (subtasks - 1) & tasks_to_finish) {\\n        if (tasks_time[subtasks] <= sessionTime) {\\n          dp[tasks_to_finish] = min(dp[tasks_to_finish], 1 + dp[tasks_to_finish ^ subtasks]);\\n        }\\n      }\\n    }\\n    return dp[layouts - 1];\\n  }\\n};\\n```\\n**Solution II**\\n```\\n/**\\n * Time Complexity: O((2 ^ n) * sessionTime)\\n * Space Complexity: O((2 ^ n) * sessionTime)\\n * where `n` is the length of the vector `tasks`\\n */\\nclass Solution {\\n public:\\n  int minSessions(const vector<int> &tasks, const int sessionTime) {\\n    const int n_tasks = static_cast<int>(tasks.size());\\n    const int layouts = 1 << n_tasks;\\n    uint32_t dp[layouts][sessionTime + 1];\\n    memset(dp, -1, sizeof(dp));\\n    dp[0][0] = 1;\\n    for (int layout = 0; layout < layouts - 1; ++layout) {\\n      for (int time = 0; time < sessionTime + 1; ++time) {\\n        if (dp[layout][time] == -1) {\\n          continue;\\n        }\\n        \\n        for (int i_task = 0; i_task < n_tasks; ++i_task) {\\n          if (((layout >> i_task) & 0b1) == 0b0) {\\n            const int next_layout = layout | (1 << i_task);\\n            if (tasks[i_task] + time <= sessionTime) {\\n              dp[next_layout][tasks[i_task] + time] = min(dp[next_layout][tasks[i_task] + time], dp[layout][time]);\\n            } else {\\n              dp[next_layout][tasks[i_task]] = min(dp[next_layout][tasks[i_task]], dp[layout][time] + 1);\\n            }\\n          }\\n        }\\n      }\\n    }\\n    return static_cast<int>(*min_element(dp[layouts - 1], dp[layouts - 1] + sessionTime + 1));\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O((2 ^ n) + (3 ^ n))\\n * Space Complexity: O(2 ^ n)\\n * where `n` is the length of the vector `tasks`\\n */\\nclass Solution {\\n public:\\n  int minSessions(const vector<int> &tasks, const int sessionTime) {\\n    const int n = static_cast<int>(tasks.size());\\n    const int layouts = 1 << n;\\n    int tasks_time[layouts];\\n    memset(tasks_time, 0, sizeof(tasks_time));\\n    for (int task_to_finish = 0; task_to_finish < n; ++task_to_finish) {\\n      for (int subtasks = 0; subtasks < (1 << task_to_finish); ++subtasks) {\\n        tasks_time[(1 << task_to_finish) | subtasks] = tasks[task_to_finish] + tasks_time[subtasks];\\n      }\\n    }\\n    \\n    uint32_t dp[layouts];\\n    memset(dp, -1, sizeof(dp));\\n    dp[0] = 0;\\n    for (int tasks_to_finish = 1; tasks_to_finish < layouts; ++tasks_to_finish) {\\n      for (int subtasks = tasks_to_finish; subtasks > 0; subtasks = (subtasks - 1) & tasks_to_finish) {\\n        if (tasks_time[subtasks] <= sessionTime) {\\n          dp[tasks_to_finish] = min(dp[tasks_to_finish], 1 + dp[tasks_to_finish ^ subtasks]);\\n        }\\n      }\\n    }\\n    return dp[layouts - 1];\\n  }\\n};\\n```\n```\\n/**\\n * Time Complexity: O((2 ^ n) * sessionTime)\\n * Space Complexity: O((2 ^ n) * sessionTime)\\n * where `n` is the length of the vector `tasks`\\n */\\nclass Solution {\\n public:\\n  int minSessions(const vector<int> &tasks, const int sessionTime) {\\n    const int n_tasks = static_cast<int>(tasks.size());\\n    const int layouts = 1 << n_tasks;\\n    uint32_t dp[layouts][sessionTime + 1];\\n    memset(dp, -1, sizeof(dp));\\n    dp[0][0] = 1;\\n    for (int layout = 0; layout < layouts - 1; ++layout) {\\n      for (int time = 0; time < sessionTime + 1; ++time) {\\n        if (dp[layout][time] == -1) {\\n          continue;\\n        }\\n        \\n        for (int i_task = 0; i_task < n_tasks; ++i_task) {\\n          if (((layout >> i_task) & 0b1) == 0b0) {\\n            const int next_layout = layout | (1 << i_task);\\n            if (tasks[i_task] + time <= sessionTime) {\\n              dp[next_layout][tasks[i_task] + time] = min(dp[next_layout][tasks[i_task] + time], dp[layout][time]);\\n            } else {\\n              dp[next_layout][tasks[i_task]] = min(dp[next_layout][tasks[i_task]], dp[layout][time] + 1);\\n            }\\n          }\\n        }\\n      }\\n    }\\n    return static_cast<int>(*min_element(dp[layouts - 1], dp[layouts - 1] + sessionTime + 1));\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485974,
                "title": "python-simple",
                "content": "```\\nclass Solution:\\n    def minSessions(self, tasks: List[int], sessionTime: int) -> int:\\n        n=len(tasks)\\n        dici={}\\n        def rec(temp,mask):\\n            if temp in dici:\\n                if mask in dici[temp]:\\n                    return dici[temp][mask]\\n            else:\\n                dici[temp]={}\\n            nonlocal sessionTime,n\\n            if mask==0:\\n                if temp>0:\\n                    \\treturn 1\\n                return 0\\n            ans=float(\"inf\")\\n            for i in range(n):\\n                if temp+tasks[i]<=sessionTime and ((2**i)&mask)!=0:\\n                    \\n                    ans=min(ans,rec(temp+tasks[i],(~(2**i))&mask))\\n                    \\n            if ans==float(\"inf\"):\\n                dici[temp][mask]= 1+rec(0,mask)\\n                return dici[temp][mask]\\n            dici[temp][mask]=ans\\n            return ans\\n        mask=0\\n        for i in range(n):\\n            mask=mask<<1\\n            mask|=1          \\n        return rec(0,mask)\\n                    \\n                    \\n            \\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSessions(self, tasks: List[int], sessionTime: int) -> int:\\n        n=len(tasks)\\n        dici={}\\n        def rec(temp,mask):\\n            if temp in dici:\\n                if mask in dici[temp]:\\n                    return dici[temp][mask]\\n            else:\\n                dici[temp]={}\\n            nonlocal sessionTime,n\\n            if mask==0:\\n                if temp>0:\\n                    \\treturn 1\\n                return 0\\n            ans=float(\"inf\")\\n            for i in range(n):\\n                if temp+tasks[i]<=sessionTime and ((2**i)&mask)!=0:\\n                    \\n                    ans=min(ans,rec(temp+tasks[i],(~(2**i))&mask))\\n                    \\n            if ans==float(\"inf\"):\\n                dici[temp][mask]= 1+rec(0,mask)\\n                return dici[temp][mask]\\n            dici[temp][mask]=ans\\n            return ans\\n        mask=0\\n        for i in range(n):\\n            mask=mask<<1\\n            mask|=1          \\n        return rec(0,mask)\\n                    \\n                    \\n            \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3411625,
                "title": "c-dp-o-n-2-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe intuitively want to brute force all options. But we can prune many of them. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor each state we store two parameters: time remaining in the current session and number of used sessions. From each state we try to enter to the next state and update its parameters by executing some new task not previously executed. If both states have the same number of sessions we pick the state that has more remaining time. If not then we pick the state with the least number of sessions.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n*2^n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(2^n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSessions(vector<int>& tasks, int session) {\\n\\t\\t\\tstruct state_t {\\n\\t\\t\\t\\tint remaining{};\\n\\t\\t\\t\\tint sessions{};\\n\\t\\t\\t};\\n\\n\\t\\t\\tint n = tasks.size();\\n\\n            vector<state_t> states(1 << n, {0, n});\\n            states[0] = {session, 1};\\n            for (unsigned i = 0; i < states.size(); i++) {\\n                for (unsigned k = 0; k < n; k++) {\\n                    if (i & (1u << k)) {\\n                        continue;\\n                    }\\n\\n                    unsigned j = i | (1u << k);\\n\\n                    state_t new_state = states[i];\\n                    if (new_state.remaining < tasks[k]) {\\n                        new_state.remaining = session;\\n                        new_state.sessions++;\\n                    } new_state.remaining -= tasks[k];\\n\\n                    state_t next_state = states[j];\\n                    if (new_state.sessions == next_state.sessions) {\\n                        next_state = (new_state.remaining > next_state.remaining ? new_state : next_state);\\n                    } else {\\n                        next_state = (new_state.sessions < next_state.sessions ? new_state : next_state);\\n                    }\\n                    \\n                    states[j] = next_state;\\n                }\\n            } return states.back().sessions;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSessions(vector<int>& tasks, int session) {\\n\\t\\t\\tstruct state_t {\\n\\t\\t\\t\\tint remaining{};\\n\\t\\t\\t\\tint sessions{};\\n\\t\\t\\t};\\n\\n\\t\\t\\tint n = tasks.size();\\n\\n            vector<state_t> states(1 << n, {0, n});\\n            states[0] = {session, 1};\\n            for (unsigned i = 0; i < states.size(); i++) {\\n                for (unsigned k = 0; k < n; k++) {\\n                    if (i & (1u << k)) {\\n                        continue;\\n                    }\\n\\n                    unsigned j = i | (1u << k);\\n\\n                    state_t new_state = states[i];\\n                    if (new_state.remaining < tasks[k]) {\\n                        new_state.remaining = session;\\n                        new_state.sessions++;\\n                    } new_state.remaining -= tasks[k];\\n\\n                    state_t next_state = states[j];\\n                    if (new_state.sessions == next_state.sessions) {\\n                        next_state = (new_state.remaining > next_state.remaining ? new_state : next_state);\\n                    } else {\\n                        next_state = (new_state.sessions < next_state.sessions ? new_state : next_state);\\n                    }\\n                    \\n                    states[j] = next_state;\\n                }\\n            } return states.back().sessions;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3285588,
                "title": "o-n2-n-solution-bitmask-subset-dp",
                "content": "\\n# Approach\\n    \\n\\nfor each subset mask  , we need to know how many sessions are needed for that mask and what is the last session that is filled with some task duration . i.e. the current used total time in last session . from this we can get the remaining time of this session . Now , one key point is all the sessions used for this mask except the last session are filled completely . \\n\\ndp[i].first -> minimum number of sessions used in subset mask i\\ndp[i].second -> total time used  in last session\\n\\nnow all the setbits in mask  (i.e. all tasks in this subset) , will contribute to the mask and we have nubmer of set bits options . out of which we will take minimum first value one and if first value is same then minimum second value one\\n\\nso for each set bit , we are calculating dp[x] value without that set bit that is x=mask^(1<<j)\\n\\nnow if dp[x].second+tasks[j] > sessionTime that means the current mask needs one more session than the mask x and that new session will be filled with task[j] time and that will be the new second value\\nOtherwise,\\nwe include that task time in the last session of the x mask \\n\\nnow we have to take the best among the options\\n\\n \\n\\n# #Time complexity:\\n    O(n*2^n)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        int n=tasks.size();\\n\\n    vector<pair<long long,long long>> dp(1<<n,{1e17,1e17});\\n\\n    // dp[i][0] -> minimum number of sessions used in subset mask i\\n    // dp[i][1] -> total time used  in last session \\n\\n    dp[0]={1,0};\\n\\n    for(int mask=1;mask<(1<<n);mask++)\\n    {\\n    \\tpair<long long,long long>best={1e17,1e17};\\n    \\tfor(int j=0;j<n;j++)\\n    \\t{\\n    \\t\\tif(mask&(1<<j))\\n    \\t\\t{\\n\\t\\t    \\tpair<int,int>curr;\\n    \\t\\t\\tif(dp[mask^(1<<j)].second+tasks[j]>sessionTime)\\n    \\t\\t\\t{\\n    \\t\\t\\t\\tcurr.first=dp[mask^(1<<j)].first+1;\\n    \\t\\t\\t\\tcurr.second=tasks[j];\\n    \\t\\t\\t}\\n    \\t\\t\\telse\\n    \\t\\t\\t{\\n    \\t\\t\\t\\tcurr.first=dp[mask^(1<<j)].first;\\n    \\t\\t\\t\\tcurr.second=dp[mask^(1<<j)].second+tasks[j];\\n    \\t\\t\\t}\\n\\t    \\t\\tif(curr.first<best.first)\\n\\t    \\t\\t\\tbest=curr;\\n\\t    \\t\\telse if(curr.first==best.first && curr.second<best.second)\\n\\t    \\t\\t\\tbest=curr;\\n    \\t\\t}\\n    \\t}\\n    \\tdp[mask]=best;\\n    }\\n\\n    return dp[(1<<n)-1].first;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        int n=tasks.size();\\n\\n    vector<pair<long long,long long>> dp(1<<n,{1e17,1e17});\\n\\n    // dp[i][0] -> minimum number of sessions used in subset mask i\\n    // dp[i][1] -> total time used  in last session \\n\\n    dp[0]={1,0};\\n\\n    for(int mask=1;mask<(1<<n);mask++)\\n    {\\n    \\tpair<long long,long long>best={1e17,1e17};\\n    \\tfor(int j=0;j<n;j++)\\n    \\t{\\n    \\t\\tif(mask&(1<<j))\\n    \\t\\t{\\n\\t\\t    \\tpair<int,int>curr;\\n    \\t\\t\\tif(dp[mask^(1<<j)].second+tasks[j]>sessionTime)\\n    \\t\\t\\t{\\n    \\t\\t\\t\\tcurr.first=dp[mask^(1<<j)].first+1;\\n    \\t\\t\\t\\tcurr.second=tasks[j];\\n    \\t\\t\\t}\\n    \\t\\t\\telse\\n    \\t\\t\\t{\\n    \\t\\t\\t\\tcurr.first=dp[mask^(1<<j)].first;\\n    \\t\\t\\t\\tcurr.second=dp[mask^(1<<j)].second+tasks[j];\\n    \\t\\t\\t}\\n\\t    \\t\\tif(curr.first<best.first)\\n\\t    \\t\\t\\tbest=curr;\\n\\t    \\t\\telse if(curr.first==best.first && curr.second<best.second)\\n\\t    \\t\\t\\tbest=curr;\\n    \\t\\t}\\n    \\t}\\n    \\tdp[mask]=best;\\n    }\\n\\n    return dp[(1<<n)-1].first;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259609,
                "title": "c",
                "content": "```\\nclass Solution {\\nprivate:\\n    bool dfs(vector<int>& tasks, int group, int sessionTime, int cur, vector<int>&section){\\n        if(cur == tasks.size()) \\n            return true ;\\n        for(int i = 0; i < group; i++){\\n            if((section[i] + tasks[cur] )> sessionTime)\\n                continue ;\\n            section[i] += tasks[cur] ;\\n            if(dfs(tasks, group, sessionTime, cur+1, section))\\n                return true ;\\n            section[i] -= tasks[cur] ;\\n        }\\n        return false ;\\n    }\\npublic:\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        \\n        long long sum = 0 ;\\n        for(auto& t : tasks)\\n            sum += t ;\\n        if(sum <= sessionTime)\\n            return 1 ;\\n        sort(tasks.begin(), tasks.end(), greater()) ;\\n\\n        int k = 0 ;\\n        for(auto it = tasks.begin(); it < tasks.end(); ++it ){\\n            if(*it == sessionTime){\\n                tasks.erase(it) ;\\n                k++ ;\\n            }\\n            else\\n                break ;\\n        }\\n        int left = 1 , right = tasks.size();\\n        while(left < right){            \\n            int mid = left + (right - left) / 2 ;\\n            vector<int>section(mid) ;\\n            if(dfs(tasks, mid, sessionTime , 0, section))\\n                right = mid ;\\n            else\\n                left = mid + 1 ;\\n        }\\n        return left + k ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool dfs(vector<int>& tasks, int group, int sessionTime, int cur, vector<int>&section){\\n        if(cur == tasks.size()) \\n            return true ;\\n        for(int i = 0; i < group; i++){\\n            if((section[i] + tasks[cur] )> sessionTime)\\n                continue ;\\n            section[i] += tasks[cur] ;\\n            if(dfs(tasks, group, sessionTime, cur+1, section))\\n                return true ;\\n            section[i] -= tasks[cur] ;\\n        }\\n        return false ;\\n    }\\npublic:\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        \\n        long long sum = 0 ;\\n        for(auto& t : tasks)\\n            sum += t ;\\n        if(sum <= sessionTime)\\n            return 1 ;\\n        sort(tasks.begin(), tasks.end(), greater()) ;\\n\\n        int k = 0 ;\\n        for(auto it = tasks.begin(); it < tasks.end(); ++it ){\\n            if(*it == sessionTime){\\n                tasks.erase(it) ;\\n                k++ ;\\n            }\\n            else\\n                break ;\\n        }\\n        int left = 1 , right = tasks.size();\\n        while(left < right){            \\n            int mid = left + (right - left) / 2 ;\\n            vector<int>section(mid) ;\\n            if(dfs(tasks, mid, sessionTime , 0, section))\\n                right = mid ;\\n            else\\n                left = mid + 1 ;\\n        }\\n        return left + k ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257866,
                "title": "easy-c-dp-bitmasking",
                "content": "```\\nclass Solution {\\npublic:\\n    int rec(vector<int>&tasks, int time, int sessionTime, int mask, vector<vector<int>>&dp)\\n    { \\n           if( mask == ((1<<tasks.size())-1) )\\n               return 0;\\n        int ans=INT_MAX;\\n        \\n        if(dp[time][mask]!=-1)\\n            return dp[time][mask];\\n        \\n         for(int i=0;i<tasks.size();i++)\\n         {\\n               if( (mask&(1<<i))==0)\\n               {\\n                    int temp;\\n                      if(time +tasks[i] <=sessionTime)\\n                      {\\n                           temp= rec(tasks,time+tasks[i],sessionTime, mask|(1<<i),dp);\\n                      }\\n                   else\\n                   {\\n                        temp= 1+ rec(tasks, tasks[i],sessionTime, mask|(1<<i) ,dp);\\n                   }\\n                   ans=min(ans,temp);\\n               }\\n         }\\n        dp[time][mask] =ans;\\n        return dp[time][mask];\\n       \\n    }\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        int n=tasks.size();\\n        int time=0;\\n        int mask=0;\\n        vector<vector<int>>dp(sessionTime+1,vector<int>((1<<n),-1));\\n        return rec(tasks,time, sessionTime, mask,dp)+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rec(vector<int>&tasks, int time, int sessionTime, int mask, vector<vector<int>>&dp)\\n    { \\n           if( mask == ((1<<tasks.size())-1) )\\n               return 0;\\n        int ans=INT_MAX;\\n        \\n        if(dp[time][mask]!=-1)\\n            return dp[time][mask];\\n        \\n         for(int i=0;i<tasks.size();i++)\\n         {\\n               if( (mask&(1<<i))==0)\\n               {\\n                    int temp;\\n                      if(time +tasks[i] <=sessionTime)\\n                      {\\n                           temp= rec(tasks,time+tasks[i],sessionTime, mask|(1<<i),dp);\\n                      }\\n                   else\\n                   {\\n                        temp= 1+ rec(tasks, tasks[i],sessionTime, mask|(1<<i) ,dp);\\n                   }\\n                   ans=min(ans,temp);\\n               }\\n         }\\n        dp[time][mask] =ans;\\n        return dp[time][mask];\\n       \\n    }\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        int n=tasks.size();\\n        int time=0;\\n        int mask=0;\\n        vector<vector<int>>dp(sessionTime+1,vector<int>((1<<n),-1));\\n        return rec(tasks,time, sessionTime, mask,dp)+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111395,
                "title": "dfs-easy-to-understand-python-50ms-solution-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFeel free to correct me with any improvements, or making the code more accessible.\\n\\n\\n# Code\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def minSessions(self, tasks: List[int], sessionTime: int) -> int:\\n    \\n        # Sort the tasks in descending order, to speed up the algorithm\\n        tasks.sort(reverse=True)\\n        task_count = len(tasks)\\n        work_sessions = []\\n        \\n        # Initialize a variable to store the minimum number of sessions needed\\n        min_sessions = task_count\\n        \\n        def dfs(current_task_index):\\n            # Make the variable min_sessions accessible to the function\\n            nonlocal min_sessions\\n            # If the number of work sessions is greater than or equal to the minimum number of sessions, return\\n            if len(work_sessions) >= min_sessions: \\n                return\\n            # If we have reached the end of the tasks, update the minimum number of sessions\\n            if current_task_index == task_count:\\n                min_sessions = len(work_sessions)\\n                return\\n            \\n            for session_index in range(len(work_sessions)):\\n                # If the current task can be added to the session without exceeding the session time, add it\\n                if tasks[current_task_index] + work_sessions[session_index] <= sessionTime:\\n                    work_sessions[session_index] += tasks[current_task_index]\\n                    # Recursively call the function to check the next task\\n                    dfs(current_task_index + 1)\\n                    # Remove the task from the session to check other possibilities\\n                    work_sessions[session_index] -= tasks[current_task_index]\\n            \\n            # If the task cannot be added to any existing session, create a new session\\n            work_sessions.append(tasks[current_task_index])\\n            dfs(current_task_index + 1)\\n            # Remove the newly created session to check other possibilities\\n            work_sessions.pop()\\n        \\n        # Start the function from the first task\\n        dfs(0)\\n        return min_sessions\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def minSessions(self, tasks: List[int], sessionTime: int) -> int:\\n    \\n        # Sort the tasks in descending order, to speed up the algorithm\\n        tasks.sort(reverse=True)\\n        task_count = len(tasks)\\n        work_sessions = []\\n        \\n        # Initialize a variable to store the minimum number of sessions needed\\n        min_sessions = task_count\\n        \\n        def dfs(current_task_index):\\n            # Make the variable min_sessions accessible to the function\\n            nonlocal min_sessions\\n            # If the number of work sessions is greater than or equal to the minimum number of sessions, return\\n            if len(work_sessions) >= min_sessions: \\n                return\\n            # If we have reached the end of the tasks, update the minimum number of sessions\\n            if current_task_index == task_count:\\n                min_sessions = len(work_sessions)\\n                return\\n            \\n            for session_index in range(len(work_sessions)):\\n                # If the current task can be added to the session without exceeding the session time, add it\\n                if tasks[current_task_index] + work_sessions[session_index] <= sessionTime:\\n                    work_sessions[session_index] += tasks[current_task_index]\\n                    # Recursively call the function to check the next task\\n                    dfs(current_task_index + 1)\\n                    # Remove the task from the session to check other possibilities\\n                    work_sessions[session_index] -= tasks[current_task_index]\\n            \\n            # If the task cannot be added to any existing session, create a new session\\n            work_sessions.append(tasks[current_task_index])\\n            dfs(current_task_index + 1)\\n            # Remove the newly created session to check other possibilities\\n            work_sessions.pop()\\n        \\n        # Start the function from the first task\\n        dfs(0)\\n        return min_sessions\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3078601,
                "title": "simplest-explanation-with-traditional-pick-notpick-technique-memoization-bitmasking-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince we can\\'t arrange the given tasks in some pattern and apply some greedy approach, we need to try out **all possible patterns**.\\n\\nWe will use the **traditonal pick/not pick** technqiue with a slight modification.\\n\\nWe will sweep through array and do the tasks which are valid (under session time limit) and not done yet. (maitaining a visited array)\\nThis will be called as one session.\\n\\nNow will check if all tasks are done, if so: will return 1, else will start a new session: return 1 + solveNext().\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMaintain:\\n**curTme** -> how much time already consumed from completed tasks.\\n**mask** -> keep track of tasks done.\\n**tasks** -> input array.\\n\\nWith these variables, we will write a function which will return **minimum number of sessions** required to do all tasks.\\n\\n**Steps**:\\n1. check if all true.\\n2. try out doing all valid tasks using for loop (pick/not pick).\\n3. take the minimum one from it as ans.\\n4. at last, check if ans remains same (=infinity), if so: start new session, else: return ans.\\n\\n**Optimization**: Use a **DP** with **curTime** and **mask** as states.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(2^n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(2^n)\\n\\n# Code 1 (TLE, without DP):\\n```\\nclass Solution {\\npublic:\\n\\n    int limit;\\n    int allTrue;\\n\\n    int solve(int curTime, int mask, vector<int> &tasks){\\n        if(mask == allTrue) return 1;       //if all tasks done, return 1 session required only.\\n        \\n        int minSessions = 1e9;\\n        for(int j=0;j<tasks.size();j++){\\n            if(!(mask & (1<<j)) and curTime + tasks[j] <= limit){   //check if valid and not done yet\\n                minSessions = min(minSessions, solve(curTime + tasks[j], mask + (1<<j), tasks));\\n            }\\n        }\\n        \\n        //no task can be done and all tasks are still not done yet, \\n        //so start a new session:\\n        if(minSessions == 1e9){     \\n            minSessions = 1 + solve(0, mask, tasks);\\n            return minSessions;\\n        }\\n        else return minSessions;\\n    }\\n\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        limit = sessionTime;\\n        allTrue = pow(2, tasks.size()) - 1;     // for n bits, we require 2^n - 1 number in INT.\\n        return solve(0, 0, tasks);\\n    }\\n};\\n```\\n\\n\\n# Bitmasking Notes:\\n1. for n bits, we required integer of value = `2^n - 1`. It also represents all bits true. \\n2. for checking if ith bit is true, `(1<<i)`. Checking ith bit true in n, `n & (1<<i)`.\\n3. for setting ith bit true in n, `n + (1<<i)`.\\n\\n\\n# Code 2 (Accepted, with DP):\\n\\n```\\nclass Solution {\\npublic:\\n\\n    int limit;\\n    int allTrue;\\n    \\n    vector<vector<int>> dp;\\n    \\n    int solve(int curTime, int mask, vector<int> &tasks){\\n        if(mask == allTrue) return 1;\\n        if(dp[curTime][mask] != -1) return dp[curTime][mask];\\n        \\n        int minSessions = 1e9;\\n        for(int j=0;j<tasks.size();j++){\\n            if(!(mask & (1<<j)) and curTime + tasks[j] <= limit){\\n                minSessions = min(minSessions, solve(curTime + tasks[j], mask + (1<<j), tasks));\\n            }\\n        }\\n        \\n        if(minSessions == 1e9){\\n            minSessions = 1 + solve(0, mask, tasks);\\n            return dp[curTime][mask] = minSessions;\\n        }\\n        else return dp[curTime][mask] = minSessions;\\n    }\\n\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        limit = sessionTime;\\n        allTrue = pow(2, tasks.size()) - 1;\\n                \\n        int M = pow(2, tasks.size()) - 1;\\n        dp = vector<vector<int>> (200, vector<int>(M, -1));\\n        return solve(0, 0, tasks);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int limit;\\n    int allTrue;\\n\\n    int solve(int curTime, int mask, vector<int> &tasks){\\n        if(mask == allTrue) return 1;       //if all tasks done, return 1 session required only.\\n        \\n        int minSessions = 1e9;\\n        for(int j=0;j<tasks.size();j++){\\n            if(!(mask & (1<<j)) and curTime + tasks[j] <= limit){   //check if valid and not done yet\\n                minSessions = min(minSessions, solve(curTime + tasks[j], mask + (1<<j), tasks));\\n            }\\n        }\\n        \\n        //no task can be done and all tasks are still not done yet, \\n        //so start a new session:\\n        if(minSessions == 1e9){     \\n            minSessions = 1 + solve(0, mask, tasks);\\n            return minSessions;\\n        }\\n        else return minSessions;\\n    }\\n\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        limit = sessionTime;\\n        allTrue = pow(2, tasks.size()) - 1;     // for n bits, we require 2^n - 1 number in INT.\\n        return solve(0, 0, tasks);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\n    int limit;\\n    int allTrue;\\n    \\n    vector<vector<int>> dp;\\n    \\n    int solve(int curTime, int mask, vector<int> &tasks){\\n        if(mask == allTrue) return 1;\\n        if(dp[curTime][mask] != -1) return dp[curTime][mask];\\n        \\n        int minSessions = 1e9;\\n        for(int j=0;j<tasks.size();j++){\\n            if(!(mask & (1<<j)) and curTime + tasks[j] <= limit){\\n                minSessions = min(minSessions, solve(curTime + tasks[j], mask + (1<<j), tasks));\\n            }\\n        }\\n        \\n        if(minSessions == 1e9){\\n            minSessions = 1 + solve(0, mask, tasks);\\n            return dp[curTime][mask] = minSessions;\\n        }\\n        else return dp[curTime][mask] = minSessions;\\n    }\\n\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        limit = sessionTime;\\n        allTrue = pow(2, tasks.size()) - 1;\\n                \\n        int M = pow(2, tasks.size()) - 1;\\n        dp = vector<vector<int>> (200, vector<int>(M, -1));\\n        return solve(0, 0, tasks);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2964835,
                "title": "js-backtracking-beat-100",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} tasks\\n * @param {number} sessionTime\\n * @return {number}\\n */\\nvar minSessions = function(tasks, sessionTime) {\\n    tasks.sort((a,b) => a - b)\\n    let result = Infinity;\\n    const sessionArr = [];\\n    backtrack(tasks.length - 1, 0);\\n    return result;\\n\\n    function backtrack(lastTasksIndex, sessionCount){\\n      if(lastTasksIndex < 0){\\n        result = Math.min(result, sessionCount);\\n        return;\\n      }\\n      if(sessionCount > result) return;\\n      for(let i = 0; i < sessionCount; i++){\\n        if(sessionArr[i] + tasks[lastTasksIndex] <= sessionTime){\\n          sessionArr[i] += tasks[lastTasksIndex];\\n          backtrack(lastTasksIndex - 1, sessionCount);\\n          sessionArr[i] -= tasks[lastTasksIndex];\\n        }\\n      }\\n      sessionArr.push(0)\\n      sessionArr[sessionCount] += tasks[lastTasksIndex];\\n      backtrack(lastTasksIndex - 1, sessionCount + 1);\\n      sessionArr[sessionCount] -= tasks[lastTasksIndex];\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\n/**\\n * @param {number[]} tasks\\n * @param {number} sessionTime\\n * @return {number}\\n */\\nvar minSessions = function(tasks, sessionTime) {\\n    tasks.sort((a,b) => a - b)\\n    let result = Infinity;\\n    const sessionArr = [];\\n    backtrack(tasks.length - 1, 0);\\n    return result;\\n\\n    function backtrack(lastTasksIndex, sessionCount){\\n      if(lastTasksIndex < 0){\\n        result = Math.min(result, sessionCount);\\n        return;\\n      }\\n      if(sessionCount > result) return;\\n      for(let i = 0; i < sessionCount; i++){\\n        if(sessionArr[i] + tasks[lastTasksIndex] <= sessionTime){\\n          sessionArr[i] += tasks[lastTasksIndex];\\n          backtrack(lastTasksIndex - 1, sessionCount);\\n          sessionArr[i] -= tasks[lastTasksIndex];\\n        }\\n      }\\n      sessionArr.push(0)\\n      sessionArr[sessionCount] += tasks[lastTasksIndex];\\n      backtrack(lastTasksIndex - 1, sessionCount + 1);\\n      sessionArr[sessionCount] -= tasks[lastTasksIndex];\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2911857,
                "title": "dfs-back-tracking-with-binary-search-100-faster-and-intuitive-explanation",
                "content": "1)We will search between 1 session to tasks.size() number of session.(left=1,right=tasks.size())\\n2)If current_value plus current task is greater than session time then it wont be possible this way which is why we pruned the branch there.\\n3)and if we can reach the end that means we can complete the tasks this way which is why we returned true.\\n4)Using binary search we find the lowest size by which we can satisfy our tasks.\\n\\n```\\nclass Solution {\\npublic:\\n    bool dfs(vector<int>& cur,int time,vector<int>& tasks,int cur_index){\\n        if(cur_index==tasks.size())\\n        {\\n            return true;\\n        }\\n        int res=false;\\n        for(int j=0;j<cur.size();j++)\\n        {\\n            if(cur[j]+tasks[cur_index]<=time)\\n            {\\n                cur[j]=cur[j]+tasks[cur_index];\\n                res=res||dfs(cur,time,tasks,cur_index+1);\\n                cur[j]=cur[j]-tasks[cur_index];\\n\\t\\t\\t\\tif(cur[j]==0)break;\\n            }\\n            \\n        }\\n        return res;\\n    }\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        \\n        int left=1;\\n        int right=tasks.size();\\n        while(left<right)\\n        {\\n            int middle=left+(right-left)/2;\\n            vector<int> cur(middle,0);\\n            bool ret=dfs(cur,sessionTime,tasks,0);\\n           \\n            if(ret==true)\\n            {\\n                right=middle;\\n            }\\n            else\\n            {\\n                left=middle+1;\\n            }\\n        }\\n      \\n        return right;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(vector<int>& cur,int time,vector<int>& tasks,int cur_index){\\n        if(cur_index==tasks.size())\\n        {\\n            return true;\\n        }\\n        int res=false;\\n        for(int j=0;j<cur.size();j++)\\n        {\\n            if(cur[j]+tasks[cur_index]<=time)\\n            {\\n                cur[j]=cur[j]+tasks[cur_index];\\n                res=res||dfs(cur,time,tasks,cur_index+1);\\n                cur[j]=cur[j]-tasks[cur_index];\\n\\t\\t\\t\\tif(cur[j]==0)break;\\n            }\\n            \\n        }\\n        return res;\\n    }\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        \\n        int left=1;\\n        int right=tasks.size();\\n        while(left<right)\\n        {\\n            int middle=left+(right-left)/2;\\n            vector<int> cur(middle,0);\\n            bool ret=dfs(cur,sessionTime,tasks,0);\\n           \\n            if(ret==true)\\n            {\\n                right=middle;\\n            }\\n            else\\n            {\\n                left=middle+1;\\n            }\\n        }\\n      \\n        return right;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2864325,
                "title": "java-dfs-pruning-additional-optimizations",
                "content": "Original inspiration from [kge](https://leetcode.com/problems/minimum-number-of-work-sessions-to-finish-the-tasks/solutions/1432137/java-solution-15ms-dfs-pruning/).\\n\\nOptimizations done:\\n1.) Calculated minimum sessions required instead of trying from 1.\\n2.) Reverse sorted the tasks array, so that failure happens sooner rather than later in the method \"canWork\", when it is not going to work out.\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSessions(int[] tasks, int sessionTime) {\\n        int total = Arrays.stream(tasks).sum();\\n        int min = (int)Math.ceil((total * 1.0) / sessionTime);\\n        sortInDescending(tasks);\\n        for (int n = min; n < tasks.length; n++) {\\n            int[] sessions = new int[n];\\n            Arrays.fill(sessions, sessionTime);\\n            if (canWork(0, tasks, sessions)) {\\n                return n;\\n            }\\n        }\\n        return tasks.length;\\n    }\\n\\n    private boolean canWork(int curr, int[] tasks, int[] sessions) {\\n        if (curr == tasks.length) return true;\\n        for (int i = 0; i < sessions.length; i++) {\\n            if (i > curr) continue;\\n            if (sessions[i] >= tasks[curr]) {\\n                sessions[i] -= tasks[curr];\\n                if (canWork(curr + 1, tasks, sessions)) {\\n                    return true;\\n                }\\n                sessions[i] += tasks[curr];\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private void sortInDescending(int[] tasks) {\\n        Arrays.sort(tasks);\\n        int n = tasks.length;\\n        for (int i = 0; i < n / 2; i++) {\\n            int temp = tasks[i];\\n            tasks[i] = tasks[n - 1 - i];\\n            tasks[n - 1 - i] = temp;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int minSessions(int[] tasks, int sessionTime) {\\n        int total = Arrays.stream(tasks).sum();\\n        int min = (int)Math.ceil((total * 1.0) / sessionTime);\\n        sortInDescending(tasks);\\n        for (int n = min; n < tasks.length; n++) {\\n            int[] sessions = new int[n];\\n            Arrays.fill(sessions, sessionTime);\\n            if (canWork(0, tasks, sessions)) {\\n                return n;\\n            }\\n        }\\n        return tasks.length;\\n    }\\n\\n    private boolean canWork(int curr, int[] tasks, int[] sessions) {\\n        if (curr == tasks.length) return true;\\n        for (int i = 0; i < sessions.length; i++) {\\n            if (i > curr) continue;\\n            if (sessions[i] >= tasks[curr]) {\\n                sessions[i] -= tasks[curr];\\n                if (canWork(curr + 1, tasks, sessions)) {\\n                    return true;\\n                }\\n                sessions[i] += tasks[curr];\\n            }\\n        }\\n        return false;\\n    }\\n\\n    private void sortInDescending(int[] tasks) {\\n        Arrays.sort(tasks);\\n        int n = tasks.length;\\n        for (int i = 0; i < n / 2; i++) {\\n            int temp = tasks[i];\\n            tasks[i] = tasks[n - 1 - i];\\n            tasks[n - 1 - i] = temp;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2843252,
                "title": "java-binary-search-to-guess-number-of-sessions-and-dfs-backtrack-to-see-if-tasks-can-be-assigned",
                "content": "# Intuition\\nThis problem is similar to 698, 1723, and 2305, i.e., a constraint satisfaction problem to see if jobs can be assigned with the contraint. For this problem, one constraint is sessionTime and the other is number of sessions.\\n\\n- key 1: binary search to guess number of sessions;\\n- key 2: use dfs/backtrack to see if all tasks can be distributed with the number of sessions and sessionTime;\\n- key 3: for if achievable dfs, use boolean instead of void.\\n\\n\\n\\n- optimization 1: reverse sort tasks so a larger task is used first and constraint is hit earlier to avoid unnecessary work;\\n- optimization 2: pruning if the current session cannot take the task at the current session;\\n- optimization 3: after backtracking if the current session is empty, which means that it won\\'t work for remaining empty sessions either. No need to continue iterating. Break out of the loop and return false.\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    int[] tasks, sums; // my preference is to make some variables global so I don\\'t need to pass them as parameters for dfs/backtrack\\n    int sessionTime, n, mid;\\n    \\n    public int minSessions(int[] tasks, int sessionTime) {\\n        \\n        this.tasks = tasks;\\n        this.sessionTime = sessionTime;\\n        this.n = tasks.length;\\n        Arrays.sort(tasks); \\n        reverse(tasks); // optimization 1: sort from large to small so larger values can hit sessionTime limit first\\n\\n        int left = 1, right = n; // binary search to guess the number of sessions\\n        while(left<right){\\n            this.mid = left + (right - left)/2;\\n            this.sums = new int[mid]; // sums is the number of sessions to track if we can distribute all tasks\\n            if(dfs(0)) right = mid;\\n            else left = mid + 1;\\n        }\\n        return left; // there is an answer for sure\\n    }\\n\\n    private boolean dfs(int index){ // boolean instead of void to give an early feedback\\n        if(index==n) return true; // return true after all tasks are distributed\\n\\n        for(int i=0;i<mid;i++){\\n            if(sums[i]+tasks[index]>sessionTime) continue; // optimization 2: pruning if not enough space in the current session, to to next session\\n            sums[i] += tasks[index];\\n            if(dfs(index+1)) return true;\\n            sums[i] -= tasks[index];\\n            if(sums[i]==0) break; // optimization 3: after backtrack if sums[i] is 0, which means that it will not work either for the remaining empty sessions\\n        }\\n\\n        return false;\\n    }\\n\\n    private void reverse(int[] arr){\\n        int i = 0, j = arr.length-1;\\n        while(i<j){\\n            int temp = arr[i];\\n            arr[i] = arr[j];\\n            arr[j] = temp;\\n            i++;\\n            j--;\\n        }\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int[] tasks, sums; // my preference is to make some variables global so I don\\'t need to pass them as parameters for dfs/backtrack\\n    int sessionTime, n, mid;\\n    \\n    public int minSessions(int[] tasks, int sessionTime) {\\n        \\n        this.tasks = tasks;\\n        this.sessionTime = sessionTime;\\n        this.n = tasks.length;\\n        Arrays.sort(tasks); \\n        reverse(tasks); // optimization 1: sort from large to small so larger values can hit sessionTime limit first\\n\\n        int left = 1, right = n; // binary search to guess the number of sessions\\n        while(left<right){\\n            this.mid = left + (right - left)/2;\\n            this.sums = new int[mid]; // sums is the number of sessions to track if we can distribute all tasks\\n            if(dfs(0)) right = mid;\\n            else left = mid + 1;\\n        }\\n        return left; // there is an answer for sure\\n    }\\n\\n    private boolean dfs(int index){ // boolean instead of void to give an early feedback\\n        if(index==n) return true; // return true after all tasks are distributed\\n\\n        for(int i=0;i<mid;i++){\\n            if(sums[i]+tasks[index]>sessionTime) continue; // optimization 2: pruning if not enough space in the current session, to to next session\\n            sums[i] += tasks[index];\\n            if(dfs(index+1)) return true;\\n            sums[i] -= tasks[index];\\n            if(sums[i]==0) break; // optimization 3: after backtrack if sums[i] is 0, which means that it will not work either for the remaining empty sessions\\n        }\\n\\n        return false;\\n    }\\n\\n    private void reverse(int[] arr){\\n        int i = 0, j = arr.length-1;\\n        while(i<j){\\n            int temp = arr[i];\\n            arr[i] = arr[j];\\n            arr[j] = temp;\\n            i++;\\n            j--;\\n        }\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2841842,
                "title": "eliminate-overlapping-calculation-top-down-memo-python-simple-solution",
                "content": "# Intuition\\nGiven remaining task and remaining working sessionTime, no need to recalculate number of sessions again.\\n\\n# Approach\\nTop-down memo\\n\\n# Complexity\\n- Time complexity:\\nO(N * sessionTime), N is number of task\\n\\n- Space complexity:\\nO(N * sessionTime)\\n\\n# Code\\n```\\nclass Solution:\\n    def minSessions(self, tasks: List[int], sessionTime: int) -> int:\\n        memo = dict()\\n\\n        def dfs(candidate, remain):\\n            if not candidate:\\n                return 1\\n                \\n            if min(candidate) > remain:\\n                return dfs(candidate, sessionTime) + 1\\n            \\n            if tuple(candidate + [remain]) in memo:\\n                return memo[tuple(candidate + [remain])]\\n            \\n            ans = math.inf\\n            for i in range(len(candidate)):\\n                if candidate[i] <= remain:\\n                    new_candidate = [val for idx, val in enumerate(candidate) if idx != i]\\n                    ans = min(ans, dfs(new_candidate, remain - candidate[i]))\\n\\n            memo[tuple(candidate + [remain])] = ans\\n            return ans\\n        \\n        return dfs(tasks, sessionTime)\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def minSessions(self, tasks: List[int], sessionTime: int) -> int:\\n        memo = dict()\\n\\n        def dfs(candidate, remain):\\n            if not candidate:\\n                return 1\\n                \\n            if min(candidate) > remain:\\n                return dfs(candidate, sessionTime) + 1\\n            \\n            if tuple(candidate + [remain]) in memo:\\n                return memo[tuple(candidate + [remain])]\\n            \\n            ans = math.inf\\n            for i in range(len(candidate)):\\n                if candidate[i] <= remain:\\n                    new_candidate = [val for idx, val in enumerate(candidate) if idx != i]\\n                    ans = min(ans, dfs(new_candidate, remain - candidate[i]))\\n\\n            memo[tuple(candidate + [remain])] = ans\\n            return ans\\n        \\n        return dfs(tasks, sessionTime)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831426,
                "title": "simple-backtracking-beats-100-python",
                "content": "Given the constraints of the problem: `n <= 14`, I realised that backtracking solution is possible and its probably going to perform better than DP if you apply the optimisations.\\n\\n**Backtraking Approach**\\n```\\ndef minSessions(self, tasks: List[int], sessionTime: int) -> int:\\n    n = len(tasks)\\n    tasks.sort(reverse=True) #optimisation 1\\n    \\n    ans = len(tasks)\\n    def choose(i, buckets):\\n        nonlocal ans\\n\\n        workSessions = sum([bucket>0 for bucket in buckets])\\n\\n        if workSessions >= ans: return #optimisation 2\\n\\n        if i == n:\\n            ans = min(ans, workSessions)\\n            return\\n        \\n        for b_i in range(n):\\n            #optimisation 3\\n            if b_i and buckets[b_i-1] == buckets[b_i]:\\n                continue\\n\\n            if buckets[b_i] + tasks[i] <= sessionTime:\\n                buckets[b_i] += tasks[i]\\n                choose(i+1, buckets)\\n                buckets[b_i] -= tasks[i]\\n    \\n    choose(0, [0]*n)\\n    return ans\\n```\\n\\n**Dynamic Programming Approach**\\ncredit @DBabichev\\n```\\ndef minSessions(self, tasks: List[int], sessionTime: int) -> int:\\n    n = len(tasks)\\n    \\n    @lru_cache(None)\\n    def dp(mask):\\n        if not mask:\\n            return [1, 0]\\n\\n        ans = [n, 0]\\n        \\n        for i in range(n):\\n            if mask & (1<<i):\\n                workSessions, c_time = dp(mask & ~(1<<i))\\n                newSession = c_time + tasks[i] > sessionTime\\n                ans = min(ans, [workSessions + newSession, tasks[i] + (1-newSession)*c_time])\\n\\n        return ans\\n    \\n    return dp((1<<n) - 1)[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Backtracking",
                    "Bitmask"
                ],
                "code": "```\\ndef minSessions(self, tasks: List[int], sessionTime: int) -> int:\\n    n = len(tasks)\\n    tasks.sort(reverse=True) #optimisation 1\\n    \\n    ans = len(tasks)\\n    def choose(i, buckets):\\n        nonlocal ans\\n\\n        workSessions = sum([bucket>0 for bucket in buckets])\\n\\n        if workSessions >= ans: return #optimisation 2\\n\\n        if i == n:\\n            ans = min(ans, workSessions)\\n            return\\n        \\n        for b_i in range(n):\\n            #optimisation 3\\n            if b_i and buckets[b_i-1] == buckets[b_i]:\\n                continue\\n\\n            if buckets[b_i] + tasks[i] <= sessionTime:\\n                buckets[b_i] += tasks[i]\\n                choose(i+1, buckets)\\n                buckets[b_i] -= tasks[i]\\n    \\n    choose(0, [0]*n)\\n    return ans\\n```\n```\\ndef minSessions(self, tasks: List[int], sessionTime: int) -> int:\\n    n = len(tasks)\\n    \\n    @lru_cache(None)\\n    def dp(mask):\\n        if not mask:\\n            return [1, 0]\\n\\n        ans = [n, 0]\\n        \\n        for i in range(n):\\n            if mask & (1<<i):\\n                workSessions, c_time = dp(mask & ~(1<<i))\\n                newSession = c_time + tasks[i] > sessionTime\\n                ans = min(ans, [workSessions + newSession, tasks[i] + (1-newSession)*c_time])\\n\\n        return ans\\n    \\n    return dp((1<<n) - 1)[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2826718,
                "title": "python-dfs-binary-search-bitmask-dp-faster-than-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust don\\'t want to use bitmask and dynamic programming.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- How to find the minimum number of sessions? We can use binary search to do this. But different from typical binary search, we use `mid` as the number of sessions we\\u2019ll have. If we can successfully allocate time for all the tasks with `mid` sessions, that means we still have the chance to minimize `mid`, i.e., upgrade `r = mid`; otherwise, we have to use larger `mid`, i.e., upgrade `l = mid + 1`. We stop when `l == r`.\\n\\n- How to determine whether the allocation of time is successful? We design a DFS function called `canFinish(i)`. It upgrades `remainTime` list each time and returns whether `tasks[i]` can be finished.\\n- The base case is: if we\\u2019ve reached the end of `tasks`, that means all the tasks can be finished, so we return True.\\n- The basic idea of `canFinish` is that this function takes care of one task `tasks[i]` each time, allocating time to finish it. Specifically, we traverse the `remainTime` list, if the current `remainTime[j]` is still enough to finish the task `tasks[i]` that we\\u2019re about to arrange, there are a few things we need to do:\\n  - allocate the time and upgrade the remain time (`remainTime[j] -= tasks[i]`) for next task\\u2019s schedule.\\n  - since we\\u2019ve done with task `tasks[i]`, it\\u2019s time to think about whether we can allocate time for the next task `tasks[i+1]`, if it is, return `True`.\\n  - But if the deeper level returns `False` to the if statement (`canFinish[i+1]` returns `False`), we know that the allocation won\\u2019t let the task been finished, so we have to add back `tasks[i]` to `remainTime[j]`. So only tasks that can be finished are allocated the time they need (subtract `tasks[i]` from remain time).\\n  - Then, `j` will move to the next index and  use another session time for allocation, the remaining part is kind of repetitive.\\n  - After we add back `tasks[i]`, if `remainTime[j] == sessionTime`, we know that the next task cannot be finished and the remain time is only enough to finish the current task. So, we can just break from the loop and return `False`.\\n# Complexity\\nMaybe someone could help me with complexity analysis, I\\'m really bad at this.\\n\\n# Code\\n```\\nclass Solution:\\n    def minSessions(self, tasks: List[int], sessionTime: int) -> int:\\n        def canFinish(i):\\n            if i == nTask:\\n                return True\\n            for j in range(mid):\\n                if remainTime[j] >= tasks[i]:\\n                    remainTime[j] -= tasks[i]\\n                    if canFinish(i + 1):\\n                        return True\\n                    remainTime[j] += tasks[i]\\n                    if remainTime[j] == sessionTime:\\n                        break\\n            return False                    \\n        \\n        nTask = len(tasks)\\n        l, r = 1, nTask\\n        tasks.sort(reverse=True)\\n        while l < r:            \\n            mid = (l + r) // 2\\n            remainTime = [sessionTime] * mid\\n            if not canFinish(0):\\n                l = mid + 1\\n            else:\\n                r = mid\\n        return l\\n```\\n# Walk-through\\nLet\\u2019s walk through an example to help understanding.\\n\\n```python\\ntasks = [5, 4, 5, 2, 1, 3]\\nsessionTime = 15\\n\\n# reversely sorted tasks:\\ntasks = [5, 5, 4, 3, 2, 1]\\n\\n# iter 1\\nl = 1\\nr = 6\\nmid = 3\\nremainTime = [15, 15, 15]\\n\\n#canFinish(0), tasks[0] = 5, j = 0\\n remianTime = [10, 15, 15]\\n#--canFinish(1), tasks[1] = 5, j = 0\\n   remianTime = [5, 15, 15]\\n#----canFinish(2), tasks[2] = 4, j = 0\\n     remianTime = [1, 15, 15]\\n#------canFinish(3), tasks[3] = 3, j = 0\\n#      remainTime[j] < tasks[i], j += 1\\n#------canFinish(3), tasks[3] = 3, j = 1\\n       remianTime = [1, 12, 15]\\n#--------canFinish(4), tasks[4] = 2, j = 0\\n#        remainTime[j] < tasks[i], j += 1\\n#--------canFinish(4), tasks[4] = 2, j = 1\\n         remianTime = [1, 10, 15]\\n#----------canFinish(5), tasks[5] = 1, j = 0\\n           remainTime[j] = [0, 10, 15]   \\n#------------canFinish(6), i == nTask, return True\\n\\n# upgrade r\\nr = 3\\n---------------------------------------------------\\n# iter 2\\nl = 1\\nr = 3\\nmid = 2\\nremainTime = [15, 15]\\n\\n#canFinish(0), tasks[0] = 5, j = 0\\n remianTime = [10, 15]\\n#--canFinish(1), tasks[1] = 5, j = 0\\n   remianTime = [5, 15]\\n#----canFinish(2), tasks[2] = 4, j = 0\\n     remianTime = [1, 15]\\n#------canFinish(3), tasks[3] = 3, j = 0\\n#      remainTime[j] < tasks[i], j += 1\\n#------canFinish(3), tasks[3] = 3, j = 1\\n       remianTime = [1, 12]\\n#--------canFinish(4), tasks[4] = 2, j = 0\\n#        remainTime[j] < tasks[i], j += 1\\n#--------canFinish(4), tasks[4] = 2, j = 1\\n         remianTime = [1, 10]\\n#----------canFinish(5), tasks[5] = 1, j = 0\\n           remainTime[j] = [0, 10]   \\n#------------canFinish(6), i == nTask, return True\\n\\n# upgrade r\\nr = 2\\n---------------------------------------------------\\n# iter 3\\nl = 1\\nr = 2\\nmid = 1\\nremainTime = [15]\\n\\n#canFinish(0), tasks[0] = 5, j = 0\\n remianTime = [10]\\n#--canFinish(1), tasks[1] = 5, j = 0\\n   remianTime = [5]\\n#----canFinish(2), tasks[2] = 4, j = 0\\n     remianTime = [1]\\n#------canFinish(3), tasks[3] = 3, j = 0\\n       remianTime = [1]\\n#      remainTime[j] < tasks[i], j += 1\\n#------canFinish(3), tasks[3] = 3, j = 1\\n#      exit for loop, return False\\n#----canFinish(2), tasks[2] = 4, j = 0\\n\\t remianTime = [5]\\n#--canFinish(1), tasks[1] = 5, j = 0\\n   remianTime = [10]    \\n#canFinish(0), tasks[0] = 5, j = 0    \\nremianTime = [15]\\n\\n# remainTime[j] == sessionTime\\n# break for loop, return False\\n\\n# upgrade l\\nl = 2 = r\\n\\n# exit while loop, return 2\\n```\\n\\n![1668760528355.jpg](https://assets.leetcode.com/users/images/0a18f277-be5e-4e3f-8437-0eade10d9c6b_1668760745.4470515.png)\\n",
                "solutionTags": [
                    "Python3",
                    "Binary Search",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minSessions(self, tasks: List[int], sessionTime: int) -> int:\\n        def canFinish(i):\\n            if i == nTask:\\n                return True\\n            for j in range(mid):\\n                if remainTime[j] >= tasks[i]:\\n                    remainTime[j] -= tasks[i]\\n                    if canFinish(i + 1):\\n                        return True\\n                    remainTime[j] += tasks[i]\\n                    if remainTime[j] == sessionTime:\\n                        break\\n            return False                    \\n        \\n        nTask = len(tasks)\\n        l, r = 1, nTask\\n        tasks.sort(reverse=True)\\n        while l < r:            \\n            mid = (l + r) // 2\\n            remainTime = [sessionTime] * mid\\n            if not canFinish(0):\\n                l = mid + 1\\n            else:\\n                r = mid\\n        return l\\n```\n```python\\ntasks = [5, 4, 5, 2, 1, 3]\\nsessionTime = 15\\n\\n# reversely sorted tasks:\\ntasks = [5, 5, 4, 3, 2, 1]\\n\\n# iter 1\\nl = 1\\nr = 6\\nmid = 3\\nremainTime = [15, 15, 15]\\n\\n#canFinish(0), tasks[0] = 5, j = 0\\n remianTime = [10, 15, 15]\\n#--canFinish(1), tasks[1] = 5, j = 0\\n   remianTime = [5, 15, 15]\\n#----canFinish(2), tasks[2] = 4, j = 0\\n     remianTime = [1, 15, 15]\\n#------canFinish(3), tasks[3] = 3, j = 0\\n#      remainTime[j] < tasks[i], j += 1\\n#------canFinish(3), tasks[3] = 3, j = 1\\n       remianTime = [1, 12, 15]\\n#--------canFinish(4), tasks[4] = 2, j = 0\\n#        remainTime[j] < tasks[i], j += 1\\n#--------canFinish(4), tasks[4] = 2, j = 1\\n         remianTime = [1, 10, 15]\\n#----------canFinish(5), tasks[5] = 1, j = 0\\n           remainTime[j] = [0, 10, 15]   \\n#------------canFinish(6), i == nTask, return True\\n\\n# upgrade r\\nr = 3\\n---------------------------------------------------\\n# iter 2\\nl = 1\\nr = 3\\nmid = 2\\nremainTime = [15, 15]\\n\\n#canFinish(0), tasks[0] = 5, j = 0\\n remianTime = [10, 15]\\n#--canFinish(1), tasks[1] = 5, j = 0\\n   remianTime = [5, 15]\\n#----canFinish(2), tasks[2] = 4, j = 0\\n     remianTime = [1, 15]\\n#------canFinish(3), tasks[3] = 3, j = 0\\n#      remainTime[j] < tasks[i], j += 1\\n#------canFinish(3), tasks[3] = 3, j = 1\\n       remianTime = [1, 12]\\n#--------canFinish(4), tasks[4] = 2, j = 0\\n#        remainTime[j] < tasks[i], j += 1\\n#--------canFinish(4), tasks[4] = 2, j = 1\\n         remianTime = [1, 10]\\n#----------canFinish(5), tasks[5] = 1, j = 0\\n           remainTime[j] = [0, 10]   \\n#------------canFinish(6), i == nTask, return True\\n\\n# upgrade r\\nr = 2\\n---------------------------------------------------\\n# iter 3\\nl = 1\\nr = 2\\nmid = 1\\nremainTime = [15]\\n\\n#canFinish(0), tasks[0] = 5, j = 0\\n remianTime = [10]\\n#--canFinish(1), tasks[1] = 5, j = 0\\n   remianTime = [5]\\n#----canFinish(2), tasks[2] = 4, j = 0\\n     remianTime = [1]\\n#------canFinish(3), tasks[3] = 3, j = 0\\n       remianTime = [1]\\n#      remainTime[j] < tasks[i], j += 1\\n#------canFinish(3), tasks[3] = 3, j = 1\\n#      exit for loop, return False\\n#----canFinish(2), tasks[2] = 4, j = 0\\n\\t remianTime = [5]\\n#--canFinish(1), tasks[1] = 5, j = 0\\n   remianTime = [10]    \\n#canFinish(0), tasks[0] = 5, j = 0    \\nremianTime = [15]\\n\\n# remainTime[j] == sessionTime\\n# break for loop, return False\\n\\n# upgrade l\\nl = 2 = r\\n\\n# exit while loop, return 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2790079,
                "title": "java-simple-solution-with-binarysearch",
                "content": "```\\nclass Solution {\\n    public int minSessions(int[] tasks, int sessionTime) {\\n        int n = tasks.length;\\n        int l=1;\\n        int r =n;\\n        int ans=-1;\\n        while(l<=r){\\n            int mid = (l+r)/2;\\n            int[] time = new int[mid] ;\\n            if(solve(tasks, sessionTime, 0, time)){\\n                ans = mid;\\n                r=mid-1;\\n            }else{\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    public boolean solve(int[] tasks, int sessionTime, int index, int[] time){\\n        if(index >= tasks.length){\\n            return true;\\n        }\\n        for(int i=0;i<time.length;i++){\\n            if(time[i]+tasks[index]<=sessionTime){\\n                time[i] += tasks[index]; \\n                if(solve(tasks, sessionTime, index+1, time)){\\n                    return true;\\n                }\\n                time[i] -= tasks[index]; \\n            }\\n            if(time[i]==0){\\n                break;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int minSessions(int[] tasks, int sessionTime) {\\n        int n = tasks.length;\\n        int l=1;\\n        int r =n;\\n        int ans=-1;\\n        while(l<=r){\\n            int mid = (l+r)/2;\\n            int[] time = new int[mid] ;\\n            if(solve(tasks, sessionTime, 0, time)){\\n                ans = mid;\\n                r=mid-1;\\n            }else{\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    public boolean solve(int[] tasks, int sessionTime, int index, int[] time){\\n        if(index >= tasks.length){\\n            return true;\\n        }\\n        for(int i=0;i<time.length;i++){\\n            if(time[i]+tasks[index]<=sessionTime){\\n                time[i] += tasks[index]; \\n                if(solve(tasks, sessionTime, index+1, time)){\\n                    return true;\\n                }\\n                time[i] -= tasks[index]; \\n            }\\n            if(time[i]==0){\\n                break;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2751958,
                "title": "c-11-lines-bitmask-beats-69",
                "content": "```\\nclass Solution {\\npublic:\\n    int memo[16385][16] = {};\\n    int RESET = -1;\\n    int dfs(vector<int>& tasks, int time, int mask, int last){\\n        if(__builtin_popcount(mask) >= tasks.size()) return 1;\\n        if(time < 0) time = RESET-tasks[last];\\n        if(memo[mask][time] != -1) return memo[mask][time];\\n        int ans = 10e8;\\n        for(int i = 0; i < tasks.size(); i++) if(!((mask>>i)&1)) ans = min(ans, dfs(tasks, time-tasks[i], mask+(1<<i), i)+((time-tasks[i]) < 0)); \\n        return memo[mask][time] = ans;\\n    }\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        RESET = sessionTime;\\n        memset(memo, -1, sizeof memo);\\n        return dfs(tasks, sessionTime, 0, 0);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int memo[16385][16] = {}",
                "codeTag": "Java"
            },
            {
                "id": 2726506,
                "title": "binary-search-to-find-the-minimum-session",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        \\n        int n=tasks.size();\\n        \\n        int left=1;\\n        int right=n;\\n        \\n        while(left<right){\\n            int mid=left+(right-left)/2;\\n            \\n            vector<int> session(mid, 0);\\n            \\n            if(dfs(tasks, sessionTime, 0, session)==false){\\n                left=mid+1;\\n            }else{\\n                right=mid;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n    \\nprivate:\\n    \\n    bool dfs(vector<int>& tasks, int& sessionTime, int idx, vector<int>& session){\\n        \\n        if(idx>=tasks.size()) return true;\\n        \\n        int flag=0;\\n        \\n        for(int i=0;i<session.size();++i){\\n            \\n            if(session[i]+tasks[idx]>sessionTime) continue;\\n            \\n            if(session[i]==0){\\n                if(flag==1) continue;\\n                flag=1;\\n            }\\n            \\n            session[i]+=tasks[idx];\\n            if(dfs(tasks, sessionTime, idx+1, session)==true) return true;\\n            session[i]-=tasks[idx];\\n            \\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        \\n        int n=tasks.size();\\n        \\n        int left=1;\\n        int right=n;\\n        \\n        while(left<right){\\n            int mid=left+(right-left)/2;\\n            \\n            vector<int> session(mid, 0);\\n            \\n            if(dfs(tasks, sessionTime, 0, session)==false){\\n                left=mid+1;\\n            }else{\\n                right=mid;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n    \\nprivate:\\n    \\n    bool dfs(vector<int>& tasks, int& sessionTime, int idx, vector<int>& session){\\n        \\n        if(idx>=tasks.size()) return true;\\n        \\n        int flag=0;\\n        \\n        for(int i=0;i<session.size();++i){\\n            \\n            if(session[i]+tasks[idx]>sessionTime) continue;\\n            \\n            if(session[i]==0){\\n                if(flag==1) continue;\\n                flag=1;\\n            }\\n            \\n            session[i]+=tasks[idx];\\n            if(dfs(tasks, sessionTime, idx+1, session)==true) return true;\\n            session[i]-=tasks[idx];\\n            \\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2723379,
                "title": "easy-and-clean-java-code",
                "content": "The idea of this question is similar to Leetcode 1723. Just one step simpler. \\n- In 1723, we want to get the min(max(all worker\\'s time)) and need to keep track of a current max value workers. min(max([worker1, worker2...]))\\n- In this question, we don\\'t need to track the min/max of current visited workers/sessions, only need to count the total session spent.\\n\\n```\\n    int min = Integer.MAX_VALUE;\\n    public int minSessions(int[] tasks, int sessionTime) {\\n        Arrays.sort(tasks);\\n        dfs(tasks.length-1, new int[tasks.length], tasks, 0, sessionTime);\\n        return min;\\n    }\\n    private void dfs(int pos, int[] session, int[] tasks, int count, int sessionTime){\\n        if(pos < 0) {\\n            min = Math.min(min, count);\\n            return;\\n        }\\n        if(count > min) return; //pruning 1: if current result has been worse than the min, no need to futher explore\\n        for(int i = 0; i < session.length; i++){\\n            if(session[i] + tasks[pos] > sessionTime) continue; \\n            if(i > 0 && session[i] == session[i-1]) continue; // pruning 2: same idea of how we pruning permutation with duplicates: leetcode 47\\n            count += session[i] == 0 ? 1 : 0;\\n            session[i] +=  tasks[pos];\\n            dfs(pos - 1, session, tasks, count, sessionTime);\\n            session[i] -= tasks[pos];\\n        }\\n    }\\n\\t```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\n    int min = Integer.MAX_VALUE;\\n    public int minSessions(int[] tasks, int sessionTime) {\\n        Arrays.sort(tasks);\\n        dfs(tasks.length-1, new int[tasks.length], tasks, 0, sessionTime);\\n        return min;\\n    }\\n    private void dfs(int pos, int[] session, int[] tasks, int count, int sessionTime){\\n        if(pos < 0) {\\n            min = Math.min(min, count);\\n            return;\\n        }\\n        if(count > min) return; //pruning 1: if current result has been worse than the min, no need to futher explore\\n        for(int i = 0; i < session.length; i++){\\n            if(session[i] + tasks[pos] > sessionTime) continue; \\n            if(i > 0 && session[i] == session[i-1]) continue; // pruning 2: same idea of how we pruning permutation with duplicates: leetcode 47\\n            count += session[i] == 0 ? 1 : 0;\\n            session[i] +=  tasks[pos];\\n            dfs(pos - 1, session, tasks, count, sessionTime);\\n            session[i] -= tasks[pos];\\n        }\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2702955,
                "title": "can-anyone-explain-why-this-cant-be-solved-by-greedy-like-we-did-in-881",
                "content": "Okay.....so I am not the only one who tried by Greedy and failed. So an humble request to all fellow coders how did you guys figure out Greedy won\\'t work? I hope you guys had done 881. Boats to Save People (https://leetcode.com/problems/boats-to-save-people/). I tried to solve this way exactly removing the constraint of 2. That is \\n\\n1. Sort the array\\n2. keep taking from right hand if session exceeds\\n3. Keep filling(if possible) from left\\n4. Increased session count\\n5. Kept doing from2 -> 4 until all elements processed \\n\\nNow this failed for 2 3 4 4 7 session 10\\n\\nMine gave 3 ( [7,2],[4.3],[4]) while optimal would be 2 ([7,3],[4,4,2]).\\n\\nNow please share your insights how to identify 881 as Greedy but this one as DP ? \\n\\nThank you in advance :)",
                "solutionTags": [],
                "code": "Okay.....so I am not the only one who tried by Greedy and failed. So an humble request to all fellow coders how did you guys figure out Greedy won\\'t work? I hope you guys had done 881. Boats to Save People (https://leetcode.com/problems/boats-to-save-people/). I tried to solve this way exactly removing the constraint of 2. That is \\n\\n1. Sort the array\\n2. keep taking from right hand if session exceeds\\n3. Keep filling(if possible) from left\\n4. Increased session count\\n5. Kept doing from2 -> 4 until all elements processed \\n\\nNow this failed for 2 3 4 4 7 session 10\\n\\nMine gave 3 ( [7,2],[4.3],[4]) while optimal would be 2 ([7,3],[4,4,2]).\\n\\nNow please share your insights how to identify 881 as Greedy but this one as DP ? \\n\\nThank you in advance :)",
                "codeTag": "Unknown"
            },
            {
                "id": 2700323,
                "title": "c-binary-search-backtracking-beats-97",
                "content": "The solution to this problem is the same as:\\n[473. Matchsticks to Square](https://leetcode.com/problems/matchsticks-to-square/description/), [Solution Here](https://leetcode.com/problems/matchsticks-to-square/solutions/2701070/c-same-as-1986-minimum-number-of-work-sessions-to-finish-the-tasks/).\\n[698. Partition to K Equal Sum Subsets](https://leetcode.com/problems/partition-to-k-equal-sum-subsets/solutions/), [Solotion Here](https://leetcode.com/problems/partition-to-k-equal-sum-subsets/solutions/2705299/c-backtracking/).\\n[1723. Find Minimum Time to Finish All Jobs](https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/description/), [Solotion Here](https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/solutions/2698784/c-binary-search-backtracking/).\\n[2305. Fair Distribution of Cookies](https://leetcode.com/problems/fair-distribution-of-cookies/description/), [Solution Here](https://leetcode.com/problems/fair-distribution-of-cookies/solutions/2632745/c-solution-dfs-bit-mask/).\\n\\n# Performance\\n![\\u622A\\u5C4F2022-10-14 08.37.22.png](https://assets.leetcode.com/users/images/868a65d1-ae4c-4f6d-ab6e-2ac659493296_1665708033.2394817.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static int minSessions(vector<int> tasks, const int sessionTime) {\\n        const int n = size(tasks);\\n        int h = n;\\n        int l = 1;\\n        sort(begin(tasks), end(tasks), greater());\\n        vector<int> dist(n, 0);\\n\\n        function<bool(int, int)> isPossible = [&] (int i, int limit) {\\n            if (i == n)\\n                return true;\\n            for (int j = 0; j < limit; ++j) {\\n                if (dist[j] + tasks[i] <= sessionTime) {\\n                    dist[j] += tasks[i];\\n                    if (isPossible(i + 1, limit)) {\\n                        dist[j] -= tasks[i];\\n                        return true;\\n                    }\\n                    dist[j] -= tasks[i];\\n                }\\n                if (!dist[j])\\n                    break;\\n            }\\n            return false;\\n        };\\n\\n        while (l < h)\\n            if (int m = ((h - l) >> 1) + l;\\n                isPossible(0, m))\\n                h = m;\\n            else\\n                l = m + 1;\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static int minSessions(vector<int> tasks, const int sessionTime) {\\n        const int n = size(tasks);\\n        int h = n;\\n        int l = 1;\\n        sort(begin(tasks), end(tasks), greater());\\n        vector<int> dist(n, 0);\\n\\n        function<bool(int, int)> isPossible = [&] (int i, int limit) {\\n            if (i == n)\\n                return true;\\n            for (int j = 0; j < limit; ++j) {\\n                if (dist[j] + tasks[i] <= sessionTime) {\\n                    dist[j] += tasks[i];\\n                    if (isPossible(i + 1, limit)) {\\n                        dist[j] -= tasks[i];\\n                        return true;\\n                    }\\n                    dist[j] -= tasks[i];\\n                }\\n                if (!dist[j])\\n                    break;\\n            }\\n            return false;\\n        };\\n\\n        while (l < h)\\n            if (int m = ((h - l) >> 1) + l;\\n                isPossible(0, m))\\n                h = m;\\n            else\\n                l = m + 1;\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683160,
                "title": "python-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef minSessions(self, tasks, T):\\n\\t\\t\\tn = len(tasks)\\n\\n\\t\\t\\t@lru_cache(None)\\n\\t\\t\\tdef dp(mask):\\n\\t\\t\\t\\tif mask == 0: return (1, 0)\\n\\t\\t\\t\\tans = (float(\"inf\"), float(\"inf\"))\\n\\t\\t\\t\\tfor j in range(n):\\n\\t\\t\\t\\t\\tif mask & (1<<j):\\n\\t\\t\\t\\t\\t\\tpieces, last = dp(mask - (1 << j))\\n\\t\\t\\t\\t\\t\\tfull = (last + tasks[j] > T)\\n\\t\\t\\t\\t\\t\\tans = min(ans, (pieces + full, tasks[j] + (1-full)*last))  \\n\\t\\t\\t\\treturn ans\\n\\n\\t\\t\\treturn dp((1<<n) - 1)[0]",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef minSessions(self, tasks, T):\\n\\t\\t\\tn = len(tasks)\\n\\n\\t\\t\\t@lru_cache(None)\\n\\t\\t\\tdef dp(mask):\\n\\t\\t\\t\\tif mask == 0: return (1, 0)\\n\\t\\t\\t\\tans = (float(\"inf\"), float(\"inf\"))\\n\\t\\t\\t\\tfor j in range(n):\\n\\t\\t\\t\\t\\tif mask & (1<<j):\\n\\t\\t\\t\\t\\t\\tpieces, last = dp(mask - (1 << j))\\n\\t\\t\\t\\t\\t\\tfull = (last + tasks[j] > T)\\n\\t\\t\\t\\t\\t\\tans = min(ans, (pieces + full, tasks[j] + (1-full)*last))  \\n\\t\\t\\t\\treturn ans\\n\\n\\t\\t\\treturn dp((1<<n) - 1)[0]",
                "codeTag": "Java"
            },
            {
                "id": 2668704,
                "title": "python-dp-backtracking-approach-faster-than-80",
                "content": "```\\nclass Solution:\\n    def minSessions(self, tasks: List[int], sessionTime: int) -> int:\\n        sessions, dp, sz = [], defaultdict(int), len(tasks)\\n        \\n        def encodeState(pos: int, sessions: List[int]) -> str:\\n            copy = sessions[:]; copy.sort()\\n            key = str(pos) + \\'$\\'\\n            for session in copy:\\n                key += str(session) + \\'$\\'\\n            return key\\n        \\n        def solve(tasks: List[int], sz: int, sessionTime: int, pos: int) -> int:\\n            nonlocal dp, sessions\\n            if pos >= sz:\\n                return 0\\n            key = encodeState(pos, sessions)\\n            if key in dp:\\n                return dp[key]\\n            sessions.append(tasks[pos])\\n            ans = 1 + solve(tasks, sz, sessionTime, pos + 1)\\n            sessions.pop()\\n            for i in range(len(sessions)):\\n                if sessions[i] + tasks[pos] <= sessionTime:\\n                    sessions[i] += tasks[pos]\\n                    ans = min(ans, solve(tasks, sz, sessionTime, pos + 1))\\n                    sessions[i] -= tasks[pos]\\n            dp[key] = ans\\n            return ans\\n        \\n        return solve(tasks, sz, sessionTime, 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def minSessions(self, tasks: List[int], sessionTime: int) -> int:\\n        sessions, dp, sz = [], defaultdict(int), len(tasks)\\n        \\n        def encodeState(pos: int, sessions: List[int]) -> str:\\n            copy = sessions[:]; copy.sort()\\n            key = str(pos) + \\'$\\'\\n            for session in copy:\\n                key += str(session) + \\'$\\'\\n            return key\\n        \\n        def solve(tasks: List[int], sz: int, sessionTime: int, pos: int) -> int:\\n            nonlocal dp, sessions\\n            if pos >= sz:\\n                return 0\\n            key = encodeState(pos, sessions)\\n            if key in dp:\\n                return dp[key]\\n            sessions.append(tasks[pos])\\n            ans = 1 + solve(tasks, sz, sessionTime, pos + 1)\\n            sessions.pop()\\n            for i in range(len(sessions)):\\n                if sessions[i] + tasks[pos] <= sessionTime:\\n                    sessions[i] += tasks[pos]\\n                    ans = min(ans, solve(tasks, sz, sessionTime, pos + 1))\\n                    sessions[i] -= tasks[pos]\\n            dp[key] = ans\\n            return ans\\n        \\n        return solve(tasks, sz, sessionTime, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2607750,
                "title": "java-clear-explanation-with-top-down-dp-and-memorization",
                "content": "```\\n    int[][] dp;\\n    int allones, sessionTime;\\n    public int minSessions(int[] tasks, int sessionTime) {\\n        this.sessionTime = sessionTime;\\n        int n = tasks.length;\\n        //dp[i][j] means with tasks status i, and current used Time, what\\'s the min\\n        //sessions have been used.\\n        dp = new int[1<<n][16];\\n        allones = (1<<n) - 1;\\n        for(int i = 0 ; i < 1<<n; i++) {\\n            Arrays.fill(dp[i], -1);\\n        }\\n        //top-down to calculate how many sessions are needed.\\n        return helper(tasks, 0, 0);\\n    }\\n    \\n    //mask == 0 means null jobs are processed\\n    private int helper(int[] t, int mask, int accumuledTime) {\\n        //it means accumuledTime should not exceed sessionTime, need a new session to process\\n        if(accumuledTime > sessionTime)  {\\n            return Integer.MAX_VALUE;\\n        }\\n        //ending case: no matter what\\'s the value of acuumulatedTime, it is capped to 1.\\n        if(mask == allones) return 1;\\n        if(dp[mask][accumuledTime] != -1) return dp[mask][accumuledTime];\\n        \\n        int ans = Integer.MAX_VALUE;\\n        for(int i = 0 ; i < t.length ; i++){\\n            if( (mask & (1<<i)) == 0){\\n                int includeInCurrentSession = helper(t, mask | (1<<i), accumuledTime + t[i]);\\n                int includeInNextSession = 1 + helper(t, mask | (1<<i), t[i]);\\n                ans = Math.min(ans, Math.min(includeInCurrentSession, includeInNextSession));\\n            }\\n        }\\n        return dp[mask][accumuledTime] = ans;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\n    int[][] dp;\\n    int allones, sessionTime;\\n    public int minSessions(int[] tasks, int sessionTime) {\\n        this.sessionTime = sessionTime;\\n        int n = tasks.length;\\n        //dp[i][j] means with tasks status i, and current used Time, what\\'s the min\\n        //sessions have been used.\\n        dp = new int[1<<n][16];\\n        allones = (1<<n) - 1;\\n        for(int i = 0 ; i < 1<<n; i++) {\\n            Arrays.fill(dp[i], -1);\\n        }\\n        //top-down to calculate how many sessions are needed.\\n        return helper(tasks, 0, 0);\\n    }\\n    \\n    //mask == 0 means null jobs are processed\\n    private int helper(int[] t, int mask, int accumuledTime) {\\n        //it means accumuledTime should not exceed sessionTime, need a new session to process\\n        if(accumuledTime > sessionTime)  {\\n            return Integer.MAX_VALUE;\\n        }\\n        //ending case: no matter what\\'s the value of acuumulatedTime, it is capped to 1.\\n        if(mask == allones) return 1;\\n        if(dp[mask][accumuledTime] != -1) return dp[mask][accumuledTime];\\n        \\n        int ans = Integer.MAX_VALUE;\\n        for(int i = 0 ; i < t.length ; i++){\\n            if( (mask & (1<<i)) == 0){\\n                int includeInCurrentSession = helper(t, mask | (1<<i), accumuledTime + t[i]);\\n                int includeInNextSession = 1 + helper(t, mask | (1<<i), t[i]);\\n                ans = Math.min(ans, Math.min(includeInCurrentSession, includeInNextSession));\\n            }\\n        }\\n        return dp[mask][accumuledTime] = ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2584993,
                "title": "template-very-simple-and-clean-code-o-n-2-n",
                "content": "```\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        int N = tasks.size();\\n        int M = 1 << N;\\n        vector<pair<int,int>> dp(M, {INT_MAX, 0});\\n        dp[0] = {0, 0};\\n        \\n        for (int i = 0; i < M; i++) {\\n            for (int j = 0; j < N; j++) {\\n                int sup = i | (1 << j);\\n                if (i == sup) {\\n                    continue;\\n                }\\n                auto [cnt, remain] = dp[i];\\n                if (remain >= tasks[j]) {\\n                    // reuse remain time\\n                    remain -= tasks[j];\\n                } else {\\n                    // add a new session\\n                    cnt++;\\n                    remain = sessionTime - tasks[j];\\n                }\\n                \\n                if (dp[sup].first > cnt || (dp[sup].first == cnt && dp[sup].second < remain)) {\\n                    dp[sup] = {cnt, remain};\\n                }\\n            }\\n        }\\n        return dp[M-1].first;\\n    }\\n```\\n\\nTemplate can be used for other DP+bit mask questions: https://leetcode.com/list?selectedList=5nrq4g32",
                "solutionTags": [],
                "code": "```\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        int N = tasks.size();\\n        int M = 1 << N;\\n        vector<pair<int,int>> dp(M, {INT_MAX, 0});\\n        dp[0] = {0, 0};\\n        \\n        for (int i = 0; i < M; i++) {\\n            for (int j = 0; j < N; j++) {\\n                int sup = i | (1 << j);\\n                if (i == sup) {\\n                    continue;\\n                }\\n                auto [cnt, remain] = dp[i];\\n                if (remain >= tasks[j]) {\\n                    // reuse remain time\\n                    remain -= tasks[j];\\n                } else {\\n                    // add a new session\\n                    cnt++;\\n                    remain = sessionTime - tasks[j];\\n                }\\n                \\n                if (dp[sup].first > cnt || (dp[sup].first == cnt && dp[sup].second < remain)) {\\n                    dp[sup] = {cnt, remain};\\n                }\\n            }\\n        }\\n        return dp[M-1].first;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2563019,
                "title": "c-memoization-bitmasking",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minSessions(vector<int>& a, int sessionTime) {\\n\\t\\t\\tint n=a.size();\\n\\t\\t\\tint target=(1<<n)-1;\\n\\t\\t\\tvector<vector<int>> dp(sessionTime+1,vector<int>((1<<n),-1));\\n\\t\\t\\tfunction<int(int,int)> recur=[&](int k,int mask){\\n\\t\\t\\t\\tif(mask==target) {\\n\\t\\t\\t\\t\\treturn 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(dp[k][mask]!=-1) return dp[k][mask];\\n\\t\\t\\t\\tint res=INT_MAX;\\n\\t\\t\\t\\tfor(int i=0;i<n;i++) {\\n\\t\\t\\t\\t\\tif(mask&(1<<i)) continue;\\n\\t\\t\\t\\t\\tint newMask=mask|(1<<i);\\n\\t\\t\\t\\t\\tif(k>=a[i]) res=min(res,recur(k-a[i],newMask));\\n\\t\\t\\t\\t\\tres=min(res,1+recur(sessionTime-a[i],newMask));\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn dp[k][mask]=res;\\n\\t\\t\\t};\\n\\t\\t\\treturn recur(sessionTime,0);\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization",
                    "Bitmask"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint minSessions(vector<int>& a, int sessionTime) {\\n\\t\\t\\tint n=a.size();\\n\\t\\t\\tint target=(1<<n)-1;\\n\\t\\t\\tvector<vector<int>> dp(sessionTime+1,vector<int>((1<<n),-1));\\n\\t\\t\\tfunction<int(int,int)> recur=[&](int k,int mask){\\n\\t\\t\\t\\tif(mask==target) {\\n\\t\\t\\t\\t\\treturn 1;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2559915,
                "title": "c-binary-search-and-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPossi(vector<int> &parSum, vector<int> &tasks, int index, int target, int k){\\n        if(index == tasks.size())\\n            return true;\\n        for(int i=0;i<k;i++){\\n            if(parSum[i] + tasks[index] <= target){\\n                parSum[i] += tasks[index];\\n                if(isPossi(parSum, tasks, index + 1, target, k))\\n                    return true;\\n                parSum[i]-=tasks[index];\\n            }\\n            if(parSum[i] == 0)\\n                return false;\\n            \\n        }\\n        return false;\\n    }\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        int l = 0;\\n        int r = tasks.size();\\n        int res = 0;\\n        while(l<=r){\\n            int mid = (l+r)/2;\\n            vector<int> parSum(mid, 0);\\n            if(isPossi(parSum, tasks, 0, sessionTime, mid)){\\n                res = mid;\\n                r = mid - 1;\\n            }\\n            else\\n                l = mid +1;\\n            \\n        }\\nreturn res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossi(vector<int> &parSum, vector<int> &tasks, int index, int target, int k){\\n        if(index == tasks.size())\\n            return true;\\n        for(int i=0;i<k;i++){\\n            if(parSum[i] + tasks[index] <= target){\\n                parSum[i] += tasks[index];\\n                if(isPossi(parSum, tasks, index + 1, target, k))\\n                    return true;\\n                parSum[i]-=tasks[index];\\n            }\\n            if(parSum[i] == 0)\\n                return false;\\n            \\n        }\\n        return false;\\n    }\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        int l = 0;\\n        int r = tasks.size();\\n        int res = 0;\\n        while(l<=r){\\n            int mid = (l+r)/2;\\n            vector<int> parSum(mid, 0);\\n            if(isPossi(parSum, tasks, 0, sessionTime, mid)){\\n                res = mid;\\n                r = mid - 1;\\n            }\\n            else\\n                l = mid +1;\\n            \\n        }\\nreturn res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2522462,
                "title": "2-approaches-with-dp-and-without-it",
                "content": "```\\nclass Solution {\\n    int best = INT_MAX;\\npublic:\\n    void helper(vector<int>& tasks, int curTask, vector<int> &slots,int sessionTime, int curBest) {\\n        // if running best is exceeding the already calculated best\\n        // then no point in tracing further\\n        if (curBest >= best) return;\\n        int n = tasks.size();\\n        \\n        // if we reached end of the task list, compute the best case\\n        if (curTask == n) {\\n            best = min(best,curBest);\\n            return;\\n        }\\n        \\n        int curTaskTime = tasks[curTask];\\n        bool isEmptySlot = false;\\n        // Try out all session slots until we reach first empty slot\\n        for (int i = 0; (i < n) && !isEmptySlot ; i++) {\\n            if (slots[i] + curTaskTime > sessionTime) continue;\\n            \\n            if (slots[i] == 0) isEmptySlot = true;\\n            \\n            slots[i] += curTaskTime;\\n            // if considering empty slot then increase the curSlots by 1 as \\n            // we are consuming new slot\\n            helper(tasks,curTask+1,slots,sessionTime, isEmptySlot ? curBest+1 : curBest);\\n            slots[i] -= curTaskTime;\\n        }\\n        \\n    }\\n    \\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        sort(tasks.begin(), tasks.end());\\n        vector<int> slots(tasks.size(),0);\\n        helper(tasks,0,slots,sessionTime,0);\\n        return best;\\n    }\\n};\\n\\n\\nclass Solution1 {\\n    unordered_map<string,int> dp;\\n    int curBest = INT_MAX;\\npublic:\\n    string encode(int curTask, vector<int> st) {\\n        sort(st.begin(),st.end());\\n        string result;\\n        result =to_string(curTask) + \"_\";\\n        for (auto &n : st) {\\n            result += to_string(n) + \"_\";\\n        }\\n        return result;\\n        \\n    }\\n    int helper(vector<int> &tasks, vector<int> &st, int sessionTime, int curTask) {\\n        int n = tasks.size();\\n        if (st.size() >= curBest)\\n            return 200;\\n        \\n        if (curTask == n) {\\n            int t = st.size();\\n            curBest = min(curBest,t);\\n            return 0;\\n        }\\n        \\n        string key = encode(curTask,st);\\n        auto it = dp.find(key);\\n        if (it != dp.end()) return it->second;\\n       \\n        int curTaskTime = tasks[curTask];\\n        st.push_back(curTaskTime);\\n        int result = 1 + helper(tasks,st,sessionTime,curTask+1);\\n        st.pop_back();\\n        \\n        for (int i = 0; i < st.size(); i++) {\\n            if (curTaskTime + st[i] <= sessionTime) {\\n                st[i] += curTaskTime;\\n                int t = helper(tasks,st,sessionTime,curTask+1);\\n                st[i] -= curTaskTime;\\n                result = min(t,result);\\n            }\\n        }\\n        dp[key] = result;\\n        return result;\\n    }\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        sort(tasks.begin(),tasks.end());\\n        vector<int> st;\\n        return helper(tasks,st,sessionTime,0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int best = INT_MAX;\\npublic:\\n    void helper(vector<int>& tasks, int curTask, vector<int> &slots,int sessionTime, int curBest) {\\n        // if running best is exceeding the already calculated best\\n        // then no point in tracing further\\n        if (curBest >= best) return;\\n        int n = tasks.size();\\n        \\n        // if we reached end of the task list, compute the best case\\n        if (curTask == n) {\\n            best = min(best,curBest);\\n            return;\\n        }\\n        \\n        int curTaskTime = tasks[curTask];\\n        bool isEmptySlot = false;\\n        // Try out all session slots until we reach first empty slot\\n        for (int i = 0; (i < n) && !isEmptySlot ; i++) {\\n            if (slots[i] + curTaskTime > sessionTime) continue;\\n            \\n            if (slots[i] == 0) isEmptySlot = true;\\n            \\n            slots[i] += curTaskTime;\\n            // if considering empty slot then increase the curSlots by 1 as \\n            // we are consuming new slot\\n            helper(tasks,curTask+1,slots,sessionTime, isEmptySlot ? curBest+1 : curBest);\\n            slots[i] -= curTaskTime;\\n        }\\n        \\n    }\\n    \\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        sort(tasks.begin(), tasks.end());\\n        vector<int> slots(tasks.size(),0);\\n        helper(tasks,0,slots,sessionTime,0);\\n        return best;\\n    }\\n};\\n\\n\\nclass Solution1 {\\n    unordered_map<string,int> dp;\\n    int curBest = INT_MAX;\\npublic:\\n    string encode(int curTask, vector<int> st) {\\n        sort(st.begin(),st.end());\\n        string result;\\n        result =to_string(curTask) + \"_\";\\n        for (auto &n : st) {\\n            result += to_string(n) + \"_\";\\n        }\\n        return result;\\n        \\n    }\\n    int helper(vector<int> &tasks, vector<int> &st, int sessionTime, int curTask) {\\n        int n = tasks.size();\\n        if (st.size() >= curBest)\\n            return 200;\\n        \\n        if (curTask == n) {\\n            int t = st.size();\\n            curBest = min(curBest,t);\\n            return 0;\\n        }\\n        \\n        string key = encode(curTask,st);\\n        auto it = dp.find(key);\\n        if (it != dp.end()) return it->second;\\n       \\n        int curTaskTime = tasks[curTask];\\n        st.push_back(curTaskTime);\\n        int result = 1 + helper(tasks,st,sessionTime,curTask+1);\\n        st.pop_back();\\n        \\n        for (int i = 0; i < st.size(); i++) {\\n            if (curTaskTime + st[i] <= sessionTime) {\\n                st[i] += curTaskTime;\\n                int t = helper(tasks,st,sessionTime,curTask+1);\\n                st[i] -= curTaskTime;\\n                result = min(t,result);\\n            }\\n        }\\n        dp[key] = result;\\n        return result;\\n    }\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        sort(tasks.begin(),tasks.end());\\n        vector<int> st;\\n        return helper(tasks,st,sessionTime,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2514715,
                "title": "c-memoization-dynamic-programming-bitmask-permutation-backtracking-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[50000][150];\\n    int ok(vector<int>&tasks,int &st,int sum,int count,int &vis){\\n        if(count==tasks.size()) return 1;\\n        if(dp[vis][sum]!=-1) return dp[vis][sum];\\n        int ans=1e9;\\n        for(int a=0;a<tasks.size();a++){\\n            int mask=(1<<a);\\n            if((vis & mask)!=0) continue;\\n            vis^=mask;\\n            if(sum+tasks[a]<=st){\\n                ans=min(ans,ok(tasks,st,sum+tasks[a],count+1,vis));\\n            }\\n            ans=min(ans,1+ok(tasks,st,tasks[a],count+1,vis));\\n            vis^=mask;\\n        }\\n        return dp[vis][sum]=ans;\\n    }\\n    int minSessions(vector<int>& tasks, int st) {\\n        //jai shri ram\\n        int vis=0;\\n        memset(dp,-1,sizeof(dp));\\n        return ok(tasks,st,0,0,vis);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[50000][150];\\n    int ok(vector<int>&tasks,int &st,int sum,int count,int &vis){\\n        if(count==tasks.size()) return 1;\\n        if(dp[vis][sum]!=-1) return dp[vis][sum];\\n        int ans=1e9;\\n        for(int a=0;a<tasks.size();a++){\\n            int mask=(1<<a);\\n            if((vis & mask)!=0) continue;\\n            vis^=mask;\\n            if(sum+tasks[a]<=st){\\n                ans=min(ans,ok(tasks,st,sum+tasks[a],count+1,vis));\\n            }\\n            ans=min(ans,1+ok(tasks,st,tasks[a],count+1,vis));\\n            vis^=mask;\\n        }\\n        return dp[vis][sum]=ans;\\n    }\\n    int minSessions(vector<int>& tasks, int st) {\\n        //jai shri ram\\n        int vis=0;\\n        memset(dp,-1,sizeof(dp));\\n        return ok(tasks,st,0,0,vis);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2502492,
                "title": "binary-search-back-tracking-with-pruning-runtime-608-ms-faster-than-82-69-of-python3",
                "content": "idea: it is like another question about distrubuting cookies to people.\\nwe know the boundaries of the sessions. so try them one by one. binary search can speed the process.\\nfor back tracking, we only allow one empty buffer session to be tried.\\n\\n\\n\\tclass Solution:\\n\\t\\tdef minSessions(self, tasks: List[int], sessionTime: int) -> int:\\n\\t\\t\\tk_min = sum(tasks) // sessionTime\\n\\t\\t\\tk_max = len(tasks)\\n\\t\\t\\tdef backtrack(buffer, j):\\n\\t\\t\\t\\tif j == len(tasks):\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\tfor i in range(len(buffer)):\\n\\t\\t\\t\\t\\tif buffer[i] + tasks[j] <= sessionTime:\\n\\t\\t\\t\\t\\t\\tbuffer[i] += tasks[j]\\n\\t\\t\\t\\t\\t\\tif backtrack(buffer, j+1):\\n\\t\\t\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\t\\t\\tbuffer[i] -= tasks[j]\\n\\t\\t\\t\\t\\t\\tif buffer[i]==0:\\n\\t\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\treturn False        \\n\\t\\t\\twhile k_min<=k_max:\\n\\t\\t\\t\\tmid = k_min+(k_max-k_min)//2\\n\\t\\t\\t\\tbuffer = [0] * mid\\n\\t\\t\\t\\tif backtrack(buffer,0):\\n\\t\\t\\t\\t\\tk_max = mid-1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tk_min=mid+1\\n\\t\\t\\treturn k_min",
                "solutionTags": [],
                "code": "idea: it is like another question about distrubuting cookies to people.\\nwe know the boundaries of the sessions. so try them one by one. binary search can speed the process.\\nfor back tracking, we only allow one empty buffer session to be tried.\\n\\n\\n\\tclass Solution:\\n\\t\\tdef minSessions(self, tasks: List[int], sessionTime: int) -> int:\\n\\t\\t\\tk_min = sum(tasks) // sessionTime\\n\\t\\t\\tk_max = len(tasks)\\n\\t\\t\\tdef backtrack(buffer, j):\\n\\t\\t\\t\\tif j == len(tasks):\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\tfor i in range(len(buffer)):\\n\\t\\t\\t\\t\\tif buffer[i] + tasks[j] <= sessionTime:\\n\\t\\t\\t\\t\\t\\tbuffer[i] += tasks[j]\\n\\t\\t\\t\\t\\t\\tif backtrack(buffer, j+1):\\n\\t\\t\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\t\\t\\tbuffer[i] -= tasks[j]\\n\\t\\t\\t\\t\\t\\tif buffer[i]==0:\\n\\t\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\treturn False        \\n\\t\\t\\twhile k_min<=k_max:\\n\\t\\t\\t\\tmid = k_min+(k_max-k_min)//2\\n\\t\\t\\t\\tbuffer = [0] * mid\\n\\t\\t\\t\\tif backtrack(buffer,0):\\n\\t\\t\\t\\t\\tk_max = mid-1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tk_min=mid+1\\n\\t\\t\\treturn k_min",
                "codeTag": "Java"
            },
            {
                "id": 2472576,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\n    typedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\n    ll sz;\\n    vi(vi(ll))dp;\\n    ll func(const vi(int)& v, ll bm, const int& n, ll cur) {\\n        if (dp[bm][cur] == -1) {\\n            ll& res = dp[bm][cur];\\n            for (ll i = 0;i < sz;++i) {\\n                if (bm & (1 << i)) { // ith done already\\n                    continue;\\n                }\\n                ll rem = cur, ans = 0;\\n                if (rem < v[i]) {\\n                    ++ans;\\n                    rem = n;\\n                }\\n                ans += func(v, bm | (1 << i), n, rem - v[i]);\\n                if (res == -1 || res > ans) {\\n                    res = ans;\\n                }\\n            }\\n            res = max(res, 0LL); // all visited\\n        }\\n        return dp[bm][cur];\\n    }\\n    int minSessions(vector<int>& v, int n) {\\n        sz = v.size();\\n        dp.resize(1 << 14, vi(ll)(16, -1)); // max possible\\n        return func(v, 0, n, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    typedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\n    ll sz;\\n    vi(vi(ll))dp;\\n    ll func(const vi(int)& v, ll bm, const int& n, ll cur) {\\n        if (dp[bm][cur] == -1) {\\n            ll& res = dp[bm][cur];\\n            for (ll i = 0;i < sz;++i) {\\n                if (bm & (1 << i)) { // ith done already\\n                    continue;\\n                }\\n                ll rem = cur, ans = 0;\\n                if (rem < v[i]) {\\n                    ++ans;\\n                    rem = n;\\n                }\\n                ans += func(v, bm | (1 << i), n, rem - v[i]);\\n                if (res == -1 || res > ans) {\\n                    res = ans;\\n                }\\n            }\\n            res = max(res, 0LL); // all visited\\n        }\\n        return dp[bm][cur];\\n    }\\n    int minSessions(vector<int>& v, int n) {\\n        sz = v.size();\\n        dp.resize(1 << 14, vi(ll)(16, -1)); // max possible\\n        return func(v, 0, n, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2471919,
                "title": "why-is-this-going-wrong",
                "content": "```\\nclass Solution {\\n    int n;\\n    int ans = Integer.MAX_VALUE;\\n    int sessionTime;\\n    boolean vis[];\\n    \\n    public int minSessions(int[] tasks, int sessionTime) {\\n        n = tasks.length;\\n        this.sessionTime = sessionTime;\\n        \\n        vis = new boolean[n];\\n        \\n        dfs(tasks, sessionTime, 1, 0);\\n        \\n        return ans;\\n            \\n    }\\n    \\n    void dfs(int tasks[], int currTime, int sessionsTook, int done){\\n        if(done == n){\\n            ans = Math.min(ans, sessionsTook);\\n            return;\\n        }\\n        \\n        if(currTime==0){\\n            currTime = sessionTime;\\n            sessionsTook++;\\n        }\\n            \\n        for(int i=0;i<n;i++){\\n            if(!vis[i] && tasks[i]<=currTime){\\n                vis[i] = true;\\n                dfs(tasks, currTime-tasks[i], sessionsTook, done+1);\\n                vis[i] = false;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int n;\\n    int ans = Integer.MAX_VALUE;\\n    int sessionTime;\\n    boolean vis[];\\n    \\n    public int minSessions(int[] tasks, int sessionTime) {\\n        n = tasks.length;\\n        this.sessionTime = sessionTime;\\n        \\n        vis = new boolean[n];\\n        \\n        dfs(tasks, sessionTime, 1, 0);\\n        \\n        return ans;\\n            \\n    }\\n    \\n    void dfs(int tasks[], int currTime, int sessionsTook, int done){\\n        if(done == n){\\n            ans = Math.min(ans, sessionsTook);\\n            return;\\n        }\\n        \\n        if(currTime==0){\\n            currTime = sessionTime;\\n            sessionsTook++;\\n        }\\n            \\n        for(int i=0;i<n;i++){\\n            if(!vis[i] && tasks[i]<=currTime){\\n                vis[i] = true;\\n                dfs(tasks, currTime-tasks[i], sessionsTook, done+1);\\n                vis[i] = false;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2439448,
                "title": "without-bitmask-only-k-subset-division-optimisation",
                "content": "# class Solution {\\npublic:\\n    bool solve(vector<int> &tasks,int ind,vector<int> &boxes,int time){\\n        int k=boxes.size();\\n        if(ind==tasks.size()){\\n            return true;\\n        }\\n        for(int i=0;i<k;i++){\\n            boxes[i]+=tasks[ind];\\n            if(boxes[i]>time){\\n                boxes[i]-=tasks[ind];\\n                continue ;\\n            }\\n            if(solve(tasks,ind+1,boxes,time)==true){\\n                return true;\\n            }\\n            boxes[i]-=tasks[ind];\\n            if(boxes[i]==0){\\n                break ;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    bool is_poss(vector<int> &tasks,int time,int k){\\n        vector<int> v(k,0);\\n        return solve(tasks,0,v,time);\\n    }\\n    int minSessions(vector<int>& tasks, int sessionTime) {\\n        int n=tasks.size();\\n        int st=1;\\n        int en=tasks.size();\\n        int ans;\\n        while(st<=en){\\n            int mid=st+(en-st)/2;\\n            if(is_poss(tasks,sessionTime,mid)==true){\\n                ans=mid;\\n                en=mid-1;\\n            }\\n            else{\\n                st=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool solve(vector<int> &tasks,int ind,vector<int> &boxes,int time){\\n        int k=boxes.size();\\n        if(ind==tasks.size()){\\n            return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2400180,
                "title": "java-o-2-n-n-2",
                "content": "```\\nclass Solution {\\n    public int minSessions(int[] tasks, int sessionTime) {\\n        int len = tasks.length;\\n        int[][] dp = new int[1 << len][sessionTime + 1];\\n        for(int st = (1 << len) - 2; st >= 0; st--) {\\n            for(int t = sessionTime; t >= 0; t--) {\\n                dp[st][t] = len;\\n                for(int i = 0; i < len; i++) {\\n                    if((st & (1 << i)) != 0) continue;\\n                    if(t + tasks[i] > sessionTime) {\\n                        dp[st][t] = Math.min(dp[st][t], 1 + dp[st | (1 << i)][tasks[i]]);\\n                    }\\n                    else {\\n                        dp[st][t] = Math.min(dp[st][t], dp[st | (1 << i)][t + tasks[i]]);\\n                    }\\n                }\\n            }\\n        }\\n        return 1 + dp[0][0];\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minSessions(int[] tasks, int sessionTime) {\\n        int len = tasks.length;\\n        int[][] dp = new int[1 << len][sessionTime + 1];\\n        for(int st = (1 << len) - 2; st >= 0; st--) {\\n            for(int t = sessionTime; t >= 0; t--) {\\n                dp[st][t] = len;\\n                for(int i = 0; i < len; i++) {\\n                    if((st & (1 << i)) != 0) continue;\\n                    if(t + tasks[i] > sessionTime) {\\n                        dp[st][t] = Math.min(dp[st][t], 1 + dp[st | (1 << i)][tasks[i]]);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2368699,
                "title": "c-solution-dp-bitmasking",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int session_time;\\n    int dp[1<<14][16];\\n    int solve(vector<int> &tasks,int time,int mask){\\n        if(mask == (1<<tasks.size())-1)\\n            return 0;\\n        if(dp[mask][time]!=-1)\\n            return dp[mask][time];\\n        int ans=1e9;\\n        for(int i=0;i<tasks.size();i++){\\n            if(mask&(1<<i))\\n                continue;\\n            if(tasks[i]<=time)\\n                ans=min(ans,solve(tasks,time-tasks[i],mask|(1<<i)));\\n            else\\n                ans=min(ans,1+solve(tasks,session_time-tasks[i],mask|(1<<i)));\\n        }\\n        return dp[mask][time]=ans;\\n    }\\n    int minSessions(vector<int>& tasks, int session_time) {\\n        this->session_time=session_time;\\n        memset(dp,-1,sizeof(dp));\\n        return solve(tasks,session_time,0)+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int session_time;\\n    int dp[1<<14][16];\\n    int solve(vector<int> &tasks,int time,int mask){\\n        if(mask == (1<<tasks.size())-1)\\n            return 0;\\n        if(dp[mask][time]!=-1)\\n            return dp[mask][time];\\n        int ans=1e9;\\n        for(int i=0;i<tasks.size();i++){\\n            if(mask&(1<<i))\\n                continue;\\n            if(tasks[i]<=time)\\n                ans=min(ans,solve(tasks,time-tasks[i],mask|(1<<i)));\\n            else\\n                ans=min(ans,1+solve(tasks,session_time-tasks[i],mask|(1<<i)));\\n        }\\n        return dp[mask][time]=ans;\\n    }\\n    int minSessions(vector<int>& tasks, int session_time) {\\n        this->session_time=session_time;\\n        memset(dp,-1,sizeof(dp));\\n        return solve(tasks,session_time,0)+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2339029,
                "title": "java-backtracking-bitmasking-dp-explained",
                "content": "First intuition was greedy but this is a optimization problem and we need to consider all possible arrangements. Now, we know we need to recurse for all possible arrangements but defining the recurence relation is a bit tricky as we have N different states at each step.\\n\\nBitmasking helps us define n possible states in form of an integer. How do we know that one integer can handle all states? The answer lies in the problem constraints. The maximum possible value of n is 14. \\n14 states can easlily fir into 32 bit integer.\\n\\nInitially mask will be zero so the original problem drills down to :\\n\\nf(0,0) -> starting from zero time and no set state find the minimum number of work.\\n\\nHow do we know that we have considered all states ?, if we mantain an extra state  for count our memo array will be 3 dimmensions and will result in memory limit error.  \\n((mask ^ ((1<<tasks.length)-1))==0)   ---> if all bits are set then we know all possible task has been considered.\\n\\n```\\nclass Solution {\\n     Integer[][] dp;\\n    public int minSessions(int[] tasks, int sessionTime) {\\n        \\n        dp = new Integer[1<<tasks.length][sessionTime + 1];\\n        return bt(tasks, 0,  0, sessionTime);      \\n    }\\n    \\n    int bt(int[] tasks, int mask,int time, int st ){\\n              \\n    if((mask ^ ((1<<tasks.length)-1))==0){\\n       if ( time == 0) return 0;\\n        return 1; \\n    } \\n    if(dp[mask][time] != null) return dp[mask][time];\\n    if(time == st){        \\n        return 1 + bt(tasks, mask,0, st);\\n    }\\n           \\n    int min =Integer.MAX_VALUE;\\n    for( int i = 0; i < tasks.length; i++){\\n        \\n        if ((mask & 1 <<i) !=0 ) continue;\\n            \\n            mask = (mask ^ 1<<i);\\n        \\n            if(time + tasks[i] > st)\\n            min = Math.min(min ,1+  bt(tasks, mask, tasks[i], st));\\n        \\n            else\\n            min = Math.min(min , bt(tasks, mask, time + tasks[i], st));\\n            mask = (mask ^ 1<<i);       \\n            \\n        }\\n        \\n        return dp[mask][time] = min;\\n}\\n}\\n```\\n\\nTC 2^N * N -> all possible arrangement * time to iterate over each task for validity.\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n     Integer[][] dp;\\n    public int minSessions(int[] tasks, int sessionTime) {\\n        \\n        dp = new Integer[1<<tasks.length][sessionTime + 1];\\n        return bt(tasks, 0,  0, sessionTime);      \\n    }\\n    \\n    int bt(int[] tasks, int mask,int time, int st ){\\n              \\n    if((mask ^ ((1<<tasks.length)-1))==0){\\n       if ( time == 0) return 0;\\n        return 1; \\n    } \\n    if(dp[mask][time] != null) return dp[mask][time];\\n    if(time == st){        \\n        return 1 + bt(tasks, mask,0, st);\\n    }\\n           \\n    int min =Integer.MAX_VALUE;\\n    for( int i = 0; i < tasks.length; i++){\\n        \\n        if ((mask & 1 <<i) !=0 ) continue;\\n            \\n            mask = (mask ^ 1<<i);\\n        \\n            if(time + tasks[i] > st)\\n            min = Math.min(min ,1+  bt(tasks, mask, tasks[i], st));\\n        \\n            else\\n            min = Math.min(min , bt(tasks, mask, time + tasks[i], st));\\n            mask = (mask ^ 1<<i);       \\n            \\n        }\\n        \\n        return dp[mask][time] = min;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2283222,
                "title": "python-bitmask-solution",
                "content": "```\\nclass Solution:\\n    def minSessions(self, tasks: List[int], sessionTime: int) -> int:\\n        if not tasks:\\n            return 0\\n        n = len(tasks)\\n        @lru_cache(None)\\n        def dp(mask, s):\\n            if mask == (1 << n) - 1:\\n                return 0\\n            else:\\n                result = float(\\'inf\\')\\n                flag = True\\n                for i in range(0, n):\\n                    if (mask >> i) % 2 == 0 and s >= tasks[i]:\\n                        result = min(result, dp(mask | 2**i, s-tasks[i]))\\n                        flag = False\\n                if flag:\\n                    return 1 + dp(mask, sessionTime)\\n                return result\\n        return dp(0, sessionTime) + 1\\n```\\n\\nUsing the bitmask to evaluate which tasks have been completed or not.",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def minSessions(self, tasks: List[int], sessionTime: int) -> int:\\n        if not tasks:\\n            return 0\\n        n = len(tasks)\\n        @lru_cache(None)\\n        def dp(mask, s):\\n            if mask == (1 << n) - 1:\\n                return 0\\n            else:\\n                result = float(\\'inf\\')\\n                flag = True\\n                for i in range(0, n):\\n                    if (mask >> i) % 2 == 0 and s >= tasks[i]:\\n                        result = min(result, dp(mask | 2**i, s-tasks[i]))\\n                        flag = False\\n                if flag:\\n                    return 1 + dp(mask, sessionTime)\\n                return result\\n        return dp(0, sessionTime) + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2213090,
                "title": "c-code-dp-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[145][16390];\\n    \\n    int func(vector<int> &v,int curr,int key,int time){\\n        if (key==pow(2,v.size())-1){\\n            return 1;\\n        }\\n        \\n        if (dp[curr][key]!=-1){\\n            return dp[curr][key];\\n        }\\n        \\n        int ele=1e9+5;\\n        \\n        for (int j=0; j<v.size(); j++){\\n            int val=key;\\n            if ((val&(1<<j))){\\n                continue;\\n            }\\n           \\n            if (curr+v[j]<=time){\\n                ele=min(ele,func(v,curr+v[j],(val|(1<<j)),time));\\n            }\\n        \\n            ele=min(ele,1+func(v,v[j],(val|(1<<j)),time));\\n            \\n        }\\n        \\n        \\n     return dp[curr][key]=ele;\\n    }\\n    \\n    int minSessions(vector<int>& v, int time) {\\n        memset(dp,-1,sizeof(dp));\\n        return func(v,0,0,time);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[145][16390];\\n    \\n    int func(vector<int> &v,int curr,int key,int time){\\n        if (key==pow(2,v.size())-1){\\n            return 1;\\n        }\\n        \\n        if (dp[curr][key]!=-1){\\n            return dp[curr][key];\\n        }\\n        \\n        int ele=1e9+5;\\n        \\n        for (int j=0; j<v.size(); j++){\\n            int val=key;\\n            if ((val&(1<<j))){\\n                continue;\\n            }\\n           \\n            if (curr+v[j]<=time){\\n                ele=min(ele,func(v,curr+v[j],(val|(1<<j)),time));\\n            }\\n        \\n            ele=min(ele,1+func(v,v[j],(val|(1<<j)),time));\\n            \\n        }\\n        \\n        \\n     return dp[curr][key]=ele;\\n    }\\n    \\n    int minSessions(vector<int>& v, int time) {\\n        memset(dp,-1,sizeof(dp));\\n        return func(v,0,0,time);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2201783,
                "title": "c-solution",
                "content": "\\tpublic class Solution {\\n\\t\\tprivate bool CanAssignWork(int[] tasks, int[] availability, int taskId){\\n\\t\\t\\tif(taskId == tasks.Length)\\n\\t\\t\\t\\treturn true;\\n\\n\\t\\t\\tfor(int i=0;i<availability.Length;i++){\\n\\t\\t\\t\\tif(taskId<i)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tif(availability[i]>=tasks[taskId]){\\n\\t\\t\\t\\t\\tavailability[i] -= tasks[taskId];\\n\\t\\t\\t\\t\\tif(CanAssignWork(tasks,availability,taskId+1))\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\tavailability[i] += tasks[taskId];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tpublic int MinSessions(int[] tasks, int sessionTime) {\\n\\t\\t\\tfor(int i=1;i<=tasks.Length;i++){\\n\\t\\t\\t\\tint[] availability = new int[i];\\n\\t\\t\\t\\tfor(int j=0;j<i;j++){\\n\\t\\t\\t\\t\\tavailability[j]=sessionTime;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(CanAssignWork(tasks,availability,0))\\n\\t\\t\\t\\t\\treturn i;\\n\\t\\t\\t}\\n\\t\\t\\treturn tasks.Length;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tprivate bool CanAssignWork(int[] tasks, int[] availability, int taskId){\\n\\t\\t\\tif(taskId == tasks.Length)\\n\\t\\t\\t\\treturn true;\\n\\n\\t\\t\\tfor(int i=0;i<availability.Length;i++){\\n\\t\\t\\t\\tif(taskId<i)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tif(availability[i]>=tasks[taskId]){\\n\\t\\t\\t\\t\\tavailability[i] -= tasks[taskId];\\n\\t\\t\\t\\t\\tif(CanAssignWork(tasks,availability,taskId+1))\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\tavailability[i] += tasks[taskId];\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 2040605,
                "content": [
                    {
                        "username": "unordered_set",
                        "content": "First!!"
                    }
                ]
            }
        ]
    }
]