[
    {
        "title": "Sort Array By Parity II",
        "question_content": "Given an array of integers nums, half of the integers in nums are odd, and the other half are even.\nSort the array so that whenever nums[i] is odd, i is odd, and whenever nums[i] is even, i is even.\nReturn any answer array that satisfies this condition.\n&nbsp;\nExample 1:\n\nInput: nums = [4,2,5,7]\nOutput: [4,5,2,7]\nExplanation: [4,7,2,5], [2,5,4,7], [2,7,4,5] would also have been accepted.\n\nExample 2:\n\nInput: nums = [2,3]\nOutput: [2,3]\n\n&nbsp;\nConstraints:\n\n\t2 <= nums.length <= 2 * 104\n\tnums.length is even.\n\tHalf of the integers in nums are even.\n\t0 <= nums[i] <= 1000\n\n&nbsp;\nFollow Up: Could you solve it in-place?",
        "solutions": [
            {
                "id": 181160,
                "title": "java-two-pointer-one-pass-inplace",
                "content": "```\\n\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] A) {\\n        int i = 0, j = 1, n = A.length;\\n        while (i < n && j < n) {\\n            while (i < n && A[i] % 2 == 0) {\\n                i += 2;\\n            }\\n            while (j < n && A[j] % 2 == 1) {\\n                j += 2;\\n            }\\n            if (i < n && j < n) {\\n                swap(A, i, j);\\n            }\\n        }\\n        return A;\\n    }\\n    private void swap(int[] A, int i, int j) {\\n        int temp = A[i];\\n        A[i] = A[j];\\n        A[j] = temp;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] A) {\\n        int i = 0, j = 1, n = A.length;\\n        while (i < n && j < n) {\\n            while (i < n && A[i] % 2 == 0) {\\n                i += 2;\\n            }\\n            while (j < n && A[j] % 2 == 1) {\\n                j += 2;\\n            }\\n            if (i < n && j < n) {\\n                swap(A, i, j);\\n            }\\n        }\\n        return A;\\n    }\\n    private void swap(int[] A, int i, int j) {\\n        int temp = A[i];\\n        A[i] = A[j];\\n        A[j] = temp;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 205903,
                "title": "python-one-pass-o-1-memory-simple-code-beats-90",
                "content": "```\\nclass Solution:\\n    def sortArrayByParityII(self, a):\\n        i = 0 # pointer for even misplaced\\n        j = 1 # pointer for odd misplaced\\n        sz = len(a)\\n        \\n        # invariant: for every misplaced odd there is misplaced even\\n        # since there is just enough space for odds and evens\\n\\n        while i < sz and j < sz:\\n            if a[i] % 2 == 0:\\n                i += 2\\n            elif a[j] % 2 == 1:\\n                j += 2\\n            else:\\n                # a[i] % 2 == 1 AND a[j] % 2 == 0\\n                a[i],a[j] = a[j],a[i]\\n                i += 2\\n                j += 2\\n\\n        return a\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, a):\\n        i = 0 # pointer for even misplaced\\n        j = 1 # pointer for odd misplaced\\n        sz = len(a)\\n        \\n        # invariant: for every misplaced odd there is misplaced even\\n        # since there is just enough space for odds and evens\\n\\n        while i < sz and j < sz:\\n            if a[i] % 2 == 0:\\n                i += 2\\n            elif a[j] % 2 == 1:\\n                j += 2\\n            else:\\n                # a[i] % 2 == 1 AND a[j] % 2 == 0\\n                a[i],a[j] = a[j],a[i]\\n                i += 2\\n                j += 2\\n\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 181158,
                "title": "c-5-lines-two-pointers-2-liner-bonus",
                "content": "Use two pointers to search for missplaced odd and even elements, and swap them.\\n```\\nvector<int> sortArrayByParityII(vector<int>& A) {\\n    for (int i = 0, j = 1; i < A.size(); i += 2, j += 2) {\\n        while (i < A.size() && A[i] % 2 == 0) i += 2;\\n        while (j < A.size() && A[j] % 2 == 1) j += 2;\\n        if (i < A.size()) swap(A[i], A[j]);\\n    }\\n    return A;\\n}\\n```\\nNow, some fun for for my minimalistic functional friends. It\\'s techically a two-liner, though I split ```swap``` into 3 lines for readability :) It actually may even look a bit cleaner, as you do not have to do \"plus 2\".\\n```\\nvector<int> sortArrayByParityII(vector<int>& A) {\\n  for (int i = 0, j = 0; i < A.size() && j < A.size(); ) swap(\\n      *find_if(begin(A) + i, end(A), [&] (int v) { return (i++ % 2 == 0 && v % 2 != 0) || i == A.size(); }),\\n      *find_if(begin(A) + j, end(A), [&] (int v) { return (j++ % 2 != 0 && v % 2 == 0) || j == A.size(); }));\\n  return A;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> sortArrayByParityII(vector<int>& A) {\\n    for (int i = 0, j = 1; i < A.size(); i += 2, j += 2) {\\n        while (i < A.size() && A[i] % 2 == 0) i += 2;\\n        while (j < A.size() && A[j] % 2 == 1) j += 2;\\n        if (i < A.size()) swap(A[i], A[j]);\\n    }\\n    return A;\\n}\\n```\n```swap```\n```\\nvector<int> sortArrayByParityII(vector<int>& A) {\\n  for (int i = 0, j = 0; i < A.size() && j < A.size(); ) swap(\\n      *find_if(begin(A) + i, end(A), [&] (int v) { return (i++ % 2 == 0 && v % 2 != 0) || i == A.size(); }),\\n      *find_if(begin(A) + j, end(A), [&] (int v) { return (j++ % 2 != 0 && v % 2 == 0) || j == A.size(); }));\\n  return A;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1252502,
                "title": "c-o-n-time-o-1-space-solution-with-intuition-for-building-the-solution",
                "content": "## Basic Idea of Question\\nWe are given an array in which half of the numbers are odd, and the other half are even. So the length of the array is always even, and the first index is even (0), while the last index is odd (n-1). We have to arrange the numbers in the array such that at every even index, there is an even number, while at every odd index, there is an odd number.\\n\\nThe most naive solution to this question is to just traverse the array, and upon finding an out-of-place element, find its replacement in the array by traversing the subarray after it. This algorithm will cost us **O(n<sup>2</sup>)** in time and **O(1)** in space, but it isn\\'t enough. It just seems too naive of a solution.\\n<br>\\n\\n## Approach 1: Separate even and odd numbers\\nThe next approach that might come to mind is to just iterate over the array and separate the numbers into two groups, even and odd.\\nThen we build the array again from the start by choosing an even number for each even index and an odd number for each odd index.\\nThis is a good solution, and it does fit in with the least runtime possible for such an algorithm, which is **O(n)** since we have to at least check every element, so that they are all at their place, but it also requires extra space of O(n) for storing the even and odd numbers.\\n\\nThe code for the approach is as follows:\\n```\\nvector<int> sortByParityII(vector<int>& nums) {\\n\\tint n = nums.size();\\n\\tvector<int> evens, odds;\\n\\tevens.reserve(n/2);\\n\\todds.reserve(n/2);\\n\\tfor(int i = 0; i<n; i++) {\\n\\t\\tif(nums[i] % 2 == 0) {\\n\\t\\t\\tevens.push_back(nums[i]);\\n\\t\\telse {\\n\\t\\t\\todds.push_back(nums[i]);\\n\\t}\\n\\t//filling even spaces\\n\\tfor(int i = 0; i<n; i+=2) {\\n\\t\\tnums[i] = evens[i/2];\\n\\t}\\n\\t//filling odd spaces\\n\\tfor(int i = 1; i<n; i+=2) {\\n\\t\\tnums[i] = odds[i/2];\\n\\t}\\n\\treturn nums;\\n}\\n```\\nIf you are confused by the lines ```evens.reserve(n/2)``` and ```odds.reserve(n/2)```, they are just ensuring beforehand that our vectors have adequate capacities, so that all push back operations are completed in O(1).\\n\\n**Time: O(n)** as we just iterate the array two times.\\n**Space: O(n)**, the extra space required for the two arrays.\\n<br>\\n\\n## Approach 2: Swap outliers\\nWe can think of this question in another way as well. Since the number of even and odd numbers in the array is equal, if there is one outlier (even number at odd index or vice versa), there must be another outlier somewhere, since if there isn\\'t, then this place has no rightful element which can fill it.\\nIf we find and swap such pairs, we wouldn\\'t have to care about finding the odd or even numbers and separating them. In fact, we can even do it in one iteration only, using two pointers.\\n\\nComing back to the question statement, as n is even,, so index 0 is even and the index (n-1) is odd. So starting at index 0 for the even pointer, and n-1 for the odd pointer would be just fine.\\nWe follow the below algorithm until one of the pointers reaches the other end of the array (here i represents the even pointer, and j represents the odd pointer):\\n\\n1. Keep incrementing i by 2 until either it reaches the other end, or an outlier (odd number at even index).\\n2. Keep decrementing j by 2 until either it reaches the other end, or an outlier (even number at odd index).\\n3. Swap nums[i] and nums[j]\\n\\nYou might be thinking, what happens if i stops at an outlier and j reaches the other end, or vice versa?\\nWell, the fact that n is even, and there being equal number of even and odd numbers prevents that situation from happening (as explained above). If there will be a pair, it will be a valid pair, otherwise both of them will reach the ends.\\n\\nThe code for this approach is as follows:\\n```\\nvector<int> sortByParityII(vector<int>& nums) {\\n\\tint n = nums.size();\\n\\tint i = 0, j = n-1;\\n\\twhile(i<n) {\\n\\t\\twhile(i<n && nums[i]%2==0) i+=2;\\n\\t\\tif(i==n) break;\\n\\t\\twhile(j>=0 && nums[j]%2==1) j-=2;\\n\\t\\t//swap the outliers\\n\\t\\tswap(nums[i], nums[j]);\\n\\t}\\n\\treturn nums;\\n}\\n```\\n\\n**Time: O(n)** as we traverse the array once.\\n**Space: O(1)** as we only use two pointers, and no other space.\\n\\n<br>\\n\\n**Don\\'t forget to upvote** if you liked this post and learned something from it, and feel free to ask any doubts, or suggest any corrections/improvements in the comments.\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nvector<int> sortByParityII(vector<int>& nums) {\\n\\tint n = nums.size();\\n\\tvector<int> evens, odds;\\n\\tevens.reserve(n/2);\\n\\todds.reserve(n/2);\\n\\tfor(int i = 0; i<n; i++) {\\n\\t\\tif(nums[i] % 2 == 0) {\\n\\t\\t\\tevens.push_back(nums[i]);\\n\\t\\telse {\\n\\t\\t\\todds.push_back(nums[i]);\\n\\t}\\n\\t//filling even spaces\\n\\tfor(int i = 0; i<n; i+=2) {\\n\\t\\tnums[i] = evens[i/2];\\n\\t}\\n\\t//filling odd spaces\\n\\tfor(int i = 1; i<n; i+=2) {\\n\\t\\tnums[i] = odds[i/2];\\n\\t}\\n\\treturn nums;\\n}\\n```\n```evens.reserve(n/2)```\n```odds.reserve(n/2)```\n```\\nvector<int> sortByParityII(vector<int>& nums) {\\n\\tint n = nums.size();\\n\\tint i = 0, j = n-1;\\n\\twhile(i<n) {\\n\\t\\twhile(i<n && nums[i]%2==0) i+=2;\\n\\t\\tif(i==n) break;\\n\\t\\twhile(j>=0 && nums[j]%2==1) j-=2;\\n\\t\\t//swap the outliers\\n\\t\\tswap(nums[i], nums[j]);\\n\\t}\\n\\treturn nums;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1490877,
                "title": "python-o-1-space-solution-explained",
                "content": "`O(n)` space complexity soluiton is straightforward. It is more interseting to investigate `O(1)` solution. The idea is to use two pointers approach, where we start with index `0` for even numbers and with index `1` for odd numbers. We traverse our numbers, where we can have the following options:\\n\\n1. if `nums[i] % 2 == 0`, then number is already on place, so we look at the next place for `i`.\\n2. if `nums[j] % 2 == 1`, then number is already on place, so we look ate the next place for `j`.\\n3. In the opposite case we need to sweich elements.\\n\\n\\n#### Complexity\\nTime complexity is `O(n)`, space complexity is `O(1)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def sortArrayByParityII(self, nums):\\n        i, j, n = 0, 1, len(nums)\\n        while j < n and i < n:\\n            if nums[i] % 2 == 0:\\n                i += 2\\n            elif nums[j] % 2 == 1:\\n                j += 2\\n            else:\\n                nums[i], nums[j] = nums[j], nums[i]\\n        return nums\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```python\\nclass Solution:\\n    def sortArrayByParityII(self, nums):\\n        i, j, n = 0, 1, len(nums)\\n        while j < n and i < n:\\n            if nums[i] % 2 == 0:\\n                i += 2\\n            elif nums[j] % 2 == 1:\\n                j += 2\\n            else:\\n                nums[i], nums[j] = nums[j], nums[i]\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1490847,
                "title": "c-two-pointers-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> sortArrayByParityII(vector<int>& nums) {\\n\\t\\t\\tint n = nums.size();\\n\\t\\t\\tint i = 0, j = 1;\\n\\t\\t\\twhile(i < n && j < n){\\n\\t\\t\\t\\tif(nums[i] % 2 == 0){\\n\\t\\t\\t\\t\\ti += 2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(nums[j] % 2 == 1){\\n\\t\\t\\t\\t\\tj += 2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tswap(nums[i], nums[j]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn nums;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> sortArrayByParityII(vector<int>& nums) {\\n\\t\\t\\tint n = nums.size();\\n\\t\\t\\tint i = 0, j = 1;\\n\\t\\t\\twhile(i < n && j < n){\\n\\t\\t\\t\\tif(nums[i] % 2 == 0){\\n\\t\\t\\t\\t\\ti += 2;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 181500,
                "title": "java-two-pointers-inplace-o-n-time-simple-straightforward",
                "content": "```\\npublic int[] sortArrayByParityII(int[] A) {\\n        int e = 0;\\n        int o = 1;\\n        \\n        while(e < A.length && o < A.length) {\\n            if(A[e]%2 != 0) {\\n                swap(A, e, o);\\n                o += 2;\\n            } else {\\n                e += 2;\\n            }\\n        }\\n\\n        return A;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] sortArrayByParityII(int[] A) {\\n        int e = 0;\\n        int o = 1;\\n        \\n        while(e < A.length && o < A.length) {\\n            if(A[e]%2 != 0) {\\n                swap(A, e, o);\\n                o += 2;\\n            } else {\\n                e += 2;\\n            }\\n        }\\n\\n        return A;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 193854,
                "title": "linear-pass-using-2-pointers-in-c",
                "content": "We need to maintain a following invariant: `A[i]` is an even number at even position and `A[j]` is an odd number at odd position. As soon as this invariant is violated, it\\'s possible to swap numbers to restore it.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& A) {\\n        for (int i = 0, j = 1; j < A.size() && i < A.size();) {\\n            if (A[i] % 2 == 0) {\\n                i += 2;\\n            } else if (A[j] % 2 == 1) {\\n                j += 2;\\n            } else {\\n                swap(A[i], A[j]);\\n            }\\n        }\\n        return A;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& A) {\\n        for (int i = 0, j = 1; j < A.size() && i < A.size();) {\\n            if (A[i] % 2 == 0) {\\n                i += 2;\\n            } else if (A[j] % 2 == 1) {\\n                j += 2;\\n            } else {\\n                swap(A[i], A[j]);\\n            }\\n        }\\n        return A;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 319267,
                "title": "python-o-n-t-o-1-s-easy-to-understand-with-explanation",
                "content": "The idea: \\nGetting odd numbers on odd indices, after which, even numbers would also stand right positions;\\n**i** as even index starts from 0 (2, 4, 6...), **j** as odd index starts from 1 (3, 5, 7...)\\n\\nA half of A is odd, so the length of A - **L**  so 2|L, also means **L - 1** is odd;\\n\\nJudging every number on odd indices if it is odd, if it is, it stands at a right position, then j = j + 2 (jumping to next odd index), and \\'i\\' keep the same. \\nOtherwise, exchanging the values between index j and i,  then index \\'i\\'  has a right value and can point to next even position i = i + 2, but we don\\'t know the original value on i is odd, so j keep unchanged.\\n\\nAfter processing all odd indices, we get the result we want.\\n```\\nclass Solution(object):\\n    def sortArrayByParityII(self, A):\\n        i, j, L = 0, 1, len(A)              # i - even index, j - odd index, L - length of A\\n        while j < L:                          # (L - 1) is odd, j can reach the last element, so this condition is enough\\n            if A[j] % 2 == 0:              # judge if the value on odd indices is odd\\n                A[j], A[i] = A[i], A[j]     # if it is even, exchange the values between index j and i\\n                i += 2                         # even indices get a right value, then i pointer jump to next even index\\n            else:\\n                j += 2                         # if it is odd, odd indices get a right value, then j pointer jump to next odd index\\n        return A\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def sortArrayByParityII(self, A):\\n        i, j, L = 0, 1, len(A)              # i - even index, j - odd index, L - length of A\\n        while j < L:                          # (L - 1) is odd, j can reach the last element, so this condition is enough\\n            if A[j] % 2 == 0:              # judge if the value on odd indices is odd\\n                A[j], A[i] = A[i], A[j]     # if it is even, exchange the values between index j and i\\n                i += 2                         # even indices get a right value, then i pointer jump to next even index\\n            else:\\n                j += 2                         # if it is odd, odd indices get a right value, then j pointer jump to next odd index\\n        return A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 234994,
                "title": "javascript-o-n",
                "content": "```\\n/**\\n * @param {number[]} A\\n * @return {number[]}\\n */\\nvar sortArrayByParityII = function(A) {\\n    let result = new Array(A.length);\\n    \\n    for(let i = 0, even = 0, odd = 1; i < A.length; i ++) {\\n        if(A[i] % 2 === 0) {\\n            result[even] = A[i];\\n            even += 2;\\n        } else {\\n            result[odd] = A[i];\\n            odd += 2;\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} A\\n * @return {number[]}\\n */\\nvar sortArrayByParityII = function(A) {\\n    let result = new Array(A.length);\\n    \\n    for(let i = 0, even = 0, odd = 1; i < A.length; i ++) {\\n        if(A[i] % 2 === 0) {\\n            result[even] = A[i];\\n            even += 2;\\n        } else {\\n            result[odd] = A[i];\\n            odd += 2;\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 181261,
                "title": "python-easy-2-liner",
                "content": "```\\nclass Solution:\\n    def sortArrayByParityII(self, A):\\n        even, odd = [a for a in A if not a % 2], [a for a in A if a % 2]\\n        return [even.pop() if not i % 2 else odd.pop() for i in range(len(A))]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, A):\\n        even, odd = [a for a in A if not a % 2], [a for a in A if a % 2]\\n        return [even.pop() if not i % 2 else odd.pop() for i in range(len(A))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 283369,
                "title": "java-2ms-99-76-faster",
                "content": "1. Get first even entry at the wrong index\\n2. Get first odd entry at the wrong index\\n3. swap\\n4. repeat\\n```\\npublic int[] sortArrayByParityII(int[] A) {\\n        int even = 0, odd = 1;\\n        while(true){\\n            while(even < A.length && A[even] % 2 == 0) /*(1)*/\\n                even += 2;\\n            while(odd < A.length && A[odd] % 2 != 0) /*(2)*/\\n                odd += 2;\\n            if(odd >= A.length || even >= A.length) return A;\\n\\t\\t\\t\\n\\t\\t\\t/*(3)*/\\n            int temp = A[even];\\n            A[even] = A[odd];\\n            A[odd] = temp;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] sortArrayByParityII(int[] A) {\\n        int even = 0, odd = 1;\\n        while(true){\\n            while(even < A.length && A[even] % 2 == 0) /*(1)*/\\n                even += 2;\\n            while(odd < A.length && A[odd] % 2 != 0) /*(2)*/\\n                odd += 2;\\n            if(odd >= A.length || even >= A.length) return A;\\n\\t\\t\\t\\n\\t\\t\\t/*(3)*/\\n            int temp = A[even];\\n            A[even] = A[odd];\\n            A[odd] = temp;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1491154,
                "title": "python-two-pointers-o-1-space-clean-concise",
                "content": "**Idea**\\n- Let `iEven` point to the first number which has an even index but the value is odd.\\n- Let `iOdd` point to the first number which has an odd index but the value is even.\\n- We need to swap `nums[iEven]` and `nums[iOdd]` together since they are mismatch.\\n```python\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        iEven = 0\\n        iOdd = 1\\n        while True:\\n            while iEven < n and nums[iEven] % 2 == 0:\\n                iEven += 2\\n            while iOdd < n and nums[iOdd] % 2 == 1:\\n                iOdd += 2\\n            if iEven >= n or iOdd >= n:\\n                break\\n\\n            nums[iEven], nums[iOdd] = nums[iOdd], nums[iEven]\\n            iEven += 2\\n            iOdd += 2\\n        return nums\\n```\\nComplexity:\\n- Time: `O(N)`, where `N <= 2*10^4` is length of `nums` array.\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        iEven = 0\\n        iOdd = 1\\n        while True:\\n            while iEven < n and nums[iEven] % 2 == 0:\\n                iEven += 2\\n            while iOdd < n and nums[iOdd] % 2 == 1:\\n                iOdd += 2\\n            if iEven >= n or iOdd >= n:\\n                break\\n\\n            nums[iEven], nums[iOdd] = nums[iOdd], nums[iEven]\\n            iEven += 2\\n            iOdd += 2\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 213068,
                "title": "3-lines-javascript-solution",
                "content": "```\\n  let evenArray = A.filter(x => x % 2 === 0);\\n  let oddArray = A.filter(x => x % 2 === 1);\\n  return A.map((x, index) => index % 2 === 0 ? evenArray.pop() : oddArray.pop());\\n```",
                "solutionTags": [],
                "code": "```\\n  let evenArray = A.filter(x => x % 2 === 0);\\n  let oddArray = A.filter(x => x % 2 === 1);\\n  return A.map((x, index) => index % 2 === 0 ? evenArray.pop() : oddArray.pop());\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1490850,
                "title": "simple-to-understand-for-beginners-91-faster",
                "content": "## IDEA:\\n* Separate all even and odd numbers Once.\\n* Then now replace original arr with alternate even and odd numbers.\\n* Here flag denotes you are at even index.\\n\\n**For Biginners:**\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        \\n        odd,even = [],[]\\n        for n in nums:\\n            if n%2: odd.append(n)\\n            else: even.append(n)\\n        \\n        o,e = 0,0\\n        for i in range(len(nums)):\\n            if i%2==0:\\n                nums[i]=even[e]\\n                e+=1\\n            else:\\n                nums[i]=odd[o]\\n                o+=1\\n        \\n        return nums\\n\\n**Most Efficient:**\\n\\'\\'\\'\\n\\t\\n\\tclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        \\n        e = 0                            #even_index\\n        o = 1                            #odd_index\\n        \\n        while e<len(nums) and o<len(nums):\\n            if nums[e]%2==0:\\n                e+=2\\n            else:\\n                if nums[o]%2!=0:\\n                    o+=2\\n                else:\\n                    nums[e],nums[o] = nums[o],nums[e]\\n                    e+=2\\n                    o+=2\\n                                \\n        return num\\n\\n### Thanks and Upvote If you got any help !!\\uD83E\\uDD1E",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "## IDEA:\\n* Separate all even and odd numbers Once.\\n* Then now replace original arr with alternate even and odd numbers.\\n* Here flag denotes you are at even index.\\n\\n**For Biginners:**\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        \\n        odd,even = [],[]\\n        for n in nums:\\n            if n%2: odd.append(n)\\n            else: even.append(n)\\n        \\n        o,e = 0,0\\n        for i in range(len(nums)):\\n            if i%2==0:\\n                nums[i]=even[e]\\n                e+=1\\n            else:\\n                nums[i]=odd[o]\\n                o+=1\\n        \\n        return nums\\n\\n**Most Efficient:**\\n\\'\\'\\'\\n\\t\\n\\tclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        \\n        e = 0                            #even_index\\n        o = 1                            #odd_index\\n        \\n        while e<len(nums) and o<len(nums):\\n            if nums[e]%2==0:\\n                e+=2\\n            else:\\n                if nums[o]%2!=0:\\n                    o+=2\\n                else:\\n                    nums[e],nums[o] = nums[o],nums[e]\\n                    e+=2\\n                    o+=2\\n                                \\n        return num\\n\\n### Thanks and Upvote If you got any help !!\\uD83E\\uDD1E",
                "codeTag": "Java"
            },
            {
                "id": 1235041,
                "title": "swift-sort-array-by-parity-ii-test-cases",
                "content": "```swift\\nclass Solution {\\n    func sortArrayByParityII(_ nums: [Int]) -> [Int] {\\n        var map = [Int](repeating: 0, count: nums.count)\\n        var i = 0, j = 1\\n        nums.forEach({\\n            if $0 % 2 == 0 {\\n                map[i] = $0\\n                i += 2\\n            } else {\\n                map[j] = $0\\n                j += 2\\n            }\\n        })\\n        return map\\n    }\\n}\\n```\\n\\n```swift\\nimport XCTest\\n\\n// Executed 2 tests, with 0 failures (0 unexpected) in 0.005 (0.007) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test1() {\\n        XCTAssertEqual(s.sortArrayByParityII([4,2,5,7]), [4,5,2,7])\\n    }\\n    func test2() {\\n        XCTAssertEqual(s.sortArrayByParityII([2,3]), [2,3])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func sortArrayByParityII(_ nums: [Int]) -> [Int] {\\n        var map = [Int](repeating: 0, count: nums.count)\\n        var i = 0, j = 1\\n        nums.forEach({\\n            if $0 % 2 == 0 {\\n                map[i] = $0\\n                i += 2\\n            } else {\\n                map[j] = $0\\n                j += 2\\n            }\\n        })\\n        return map\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\n// Executed 2 tests, with 0 failures (0 unexpected) in 0.005 (0.007) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test1() {\\n        XCTAssertEqual(s.sortArrayByParityII([4,2,5,7]), [4,5,2,7])\\n    }\\n    func test2() {\\n        XCTAssertEqual(s.sortArrayByParityII([2,3]), [2,3])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 181075,
                "title": "java-simple-code-swap-odd-and-even-indices-elements",
                "content": "Use i and j to denote even and odd indices, respectively.\\nLoop through input array,\\n1. locate next wrongly placed item with odd index j;\\n2. if current even-index item, A[i], is wrongly placed, swap it with A[j]; otherwise, forward to the next even index;\\n\\nTime: O(n), space: O(1).\\n\\n```\\n    public int[] sortArrayByParityII(int[] A) {\\n        for (int i = 0, j = 1; i < A.length; i += 2) {\\n            while (j < A.length && A[j] % 2 == 1) { j += 2; } //find next odd-index item A[j] with even value.\\n            if (A[i] % 2 == 1) { // if odd-index item A[i] is odd, swap it with A[j].\\n                int t = A[i];\\n                A[i] = A[j];\\n                A[j] = t;\\n                j += 2;\\n            }\\n        }\\n        return A;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] sortArrayByParityII(int[] A) {\\n        for (int i = 0, j = 1; i < A.length; i += 2) {\\n            while (j < A.length && A[j] % 2 == 1) { j += 2; } //find next odd-index item A[j] with even value.\\n            if (A[i] % 2 == 1) { // if odd-index item A[i] is odd, swap it with A[j].\\n                int t = A[i];\\n                A[i] = A[j];\\n                A[j] = t;\\n                j += 2;\\n            }\\n        }\\n        return A;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3420962,
                "title": "c-easy-to-understand-simple-logic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O[n]\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O[1]\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n    \\n        vector<int> ans(nums.size());\\n        int e=0,o=1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]%2==0)\\n            {\\n                ans[e]=nums[i];\\n                    e+=2;\\n            }\\n            else if(nums[i]%2!=0)\\n            \\n                {\\n                    ans[o]=nums[i];\\n                    o+=2;\\n                }\\n            \\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n    \\n        vector<int> ans(nums.size());\\n        int e=0,o=1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]%2==0)\\n            {\\n                ans[e]=nums[i];\\n                    e+=2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2431242,
                "title": "100-t-c-short-solution-easy-to-undesrtand",
                "content": "```\\nPLEASE UPVOTE IF YOU LIKE.\\n```\\n        int[] ans = new int[nums.length];\\n        int even = -2, odd = -1;\\n\\n        for (int  i: nums){\\n            if (i % 2 == 0) ans[even+=2] = i;\\n            else ans[odd+=2] = i;\\n        }\\n\\n        return ans;",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nPLEASE UPVOTE IF YOU LIKE.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 224767,
                "title": "python-two-pointers-one-pass",
                "content": "one pointer is used to remember the odd position, the other is to remember the even position\\n```\\nclass Solution:\\n    def sortArrayByParityII(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        odd = 1\\n        even = 0\\n        result = [0]*len(A)\\n        for num in A:\\n            if num%2==0:\\n                result[even] = num\\n                even += 2\\n            else:\\n                result[odd] = num\\n                odd += 2\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        odd = 1\\n        even = 0\\n        result = [0]*len(A)\\n        for num in A:\\n            if num%2==0:\\n                result[even] = num\\n                even += 2\\n            else:\\n                result[odd] = num\\n                odd += 2\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 182347,
                "title": "python-beginner-solution",
                "content": "Tried to make a simple solution. \\n1. Loop through initial list, check for odd/even, and append to an odd_list or even list\\n2. Combine the lists with slicing to alternate odd/even lists\\n\\n```class Solution:\\n    def sortArrayByParityII(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        odd_list = []\\n        even_list = []\\n        \\n        for i in A:\\n            if i % 2 == 1:\\n                odd_list.append(i)\\n            else:\\n                even_list.append(i)\\n\\n        result = [None]*(len(odd_list)+len(even_list))\\n        result[::2] = even_list\\n        result[1::2] = odd_list\\n        return result",
                "solutionTags": [],
                "code": "Tried to make a simple solution. \\n1. Loop through initial list, check for odd/even, and append to an odd_list or even list\\n2. Combine the lists with slicing to alternate odd/even lists\\n\\n```class Solution:\\n    def sortArrayByParityII(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        odd_list = []\\n        even_list = []\\n        \\n        for i in A:\\n            if i % 2 == 1:\\n                odd_list.append(i)\\n            else:\\n                even_list.append(i)\\n\\n        result = [None]*(len(odd_list)+len(even_list))\\n        result[::2] = even_list\\n        result[1::2] = odd_list\\n        return result",
                "codeTag": "Java"
            },
            {
                "id": 3253084,
                "title": "python3-easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        even = []\\n        odd = []\\n        lst=[]\\n        for i in range(len(nums)):\\n            if nums[i]%2 == 0:\\n                even.append(nums[i])\\n            else:\\n                odd.append(nums[i])\\n        for i in range(len(even)):\\n            lst.append(even[i])\\n            lst.append(odd[i])\\n        return lst\\n```\\n![image.png](https://assets.leetcode.com/users/images/d1d1fa02-4b7b-4404-b577-ebef47fd1b2f_1677865820.3052886.png)\\n",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        even = []\\n        odd = []\\n        lst=[]\\n        for i in range(len(nums)):\\n            if nums[i]%2 == 0:\\n                even.append(nums[i])\\n            else:\\n                odd.append(nums[i])\\n        for i in range(len(even)):\\n            lst.append(even[i])\\n            lst.append(odd[i])\\n        return lst\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1665223,
                "title": "c-three-o-n-solutions",
                "content": "**Solution #1:** Two-pass solution using two-pointer technique [O(n) Time & O(1) Space]\\n```\\nvector<int> sortArrayByParityII(vector<int>& nums) {\\n\\tfor (int i = 0, c = 0; i < nums.size(); i++) {\\n\\t\\tif (nums[i] % 2 != 0) c++;\\n\\t\\telse if (c > 0) swap(nums[i], nums[i - c]);\\n\\t}\\n\\tfor (int i = 1; i < nums.size() / 2; i += 2) swap(nums[i], nums[nums.size() - i - 1]);\\n\\treturn nums;\\n}\\n```\\n\\n**Solution #2:** One-pass solution using two-pointer technique [O(n) Time & O(1) Space]\\n```\\nvector<int> sortArrayByParityII(vector<int>& nums) {\\n\\tint i = 0, j = nums.size() - 1;\\n\\twhile (i < nums.size() && j >= 0) {\\n\\t\\tif (nums[i] % 2 == 0) i += 2;\\n\\t\\telse if (nums[j] % 2 != 0) j -= 2;\\n\\t\\telse swap(nums[i], nums[j]);\\n\\t}\\n\\treturn nums;\\n}\\n```\\n\\n**Solution #3:** One-pass solution [O(n) Time & O(n) Space] \\n```\\nvector<int> sortArrayByParityII(vector<int>& nums) {\\n\\tvector<int> result(nums.size());\\n\\tfor (int i = 0, j = 0, k = 1; i < nums.size(); i++) {\\n\\t\\tif (nums[i] % 2 == 0) {\\n\\t\\t\\tresult[j] = nums[i];\\n\\t\\t\\tj += 2;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tresult[k] = nums[i];\\n\\t\\t\\tk += 2;\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\n```\\n**Note:** Not an in-place solution.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<int> sortArrayByParityII(vector<int>& nums) {\\n\\tfor (int i = 0, c = 0; i < nums.size(); i++) {\\n\\t\\tif (nums[i] % 2 != 0) c++;\\n\\t\\telse if (c > 0) swap(nums[i], nums[i - c]);\\n\\t}\\n\\tfor (int i = 1; i < nums.size() / 2; i += 2) swap(nums[i], nums[nums.size() - i - 1]);\\n\\treturn nums;\\n}\\n```\n```\\nvector<int> sortArrayByParityII(vector<int>& nums) {\\n\\tint i = 0, j = nums.size() - 1;\\n\\twhile (i < nums.size() && j >= 0) {\\n\\t\\tif (nums[i] % 2 == 0) i += 2;\\n\\t\\telse if (nums[j] % 2 != 0) j -= 2;\\n\\t\\telse swap(nums[i], nums[j]);\\n\\t}\\n\\treturn nums;\\n}\\n```\n```\\nvector<int> sortArrayByParityII(vector<int>& nums) {\\n\\tvector<int> result(nums.size());\\n\\tfor (int i = 0, j = 0, k = 1; i < nums.size(); i++) {\\n\\t\\tif (nums[i] % 2 == 0) {\\n\\t\\t\\tresult[j] = nums[i];\\n\\t\\t\\tj += 2;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tresult[k] = nums[i];\\n\\t\\t\\tk += 2;\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 404663,
                "title": "python3-2-pointer",
                "content": "Even & odd indices \\n1) maintain two indices \"even\" and \"odd\" which start at 0 and 1 spectively;\\n2) loop through elements in array;\\n3) if element is of odd parity, copy it to position of \"odd\" index and increase odd by two; if element is of even parity, copy it to positon of \"even\" index and increase even by two.\\n```\\nclass Solution:\\n    def sortArrayByParityII(self, A: List[int]) -> List[int]:\\n        ans = [None] * len(A)\\n        index = [0, 1] #even & odd indices\\n        for x in A:\\n            ans[index[x%2]] = x\\n            index[x%2] += 2\\n        return ans \\n```\\n\\nAn alternative implementation which updates A in place is as below. \\n```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        ii, i = 0, 1\\n        while ii < len(nums) and i < len(nums): \\n            if not nums[ii] & 1: ii += 2\\n            elif nums[i] & 1: i += 2\\n            else: \\n                nums[ii], nums[i] = nums[i], nums[ii]\\n                ii += 2\\n                i += 2\\n        return nums\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, A: List[int]) -> List[int]:\\n        ans = [None] * len(A)\\n        index = [0, 1] #even & odd indices\\n        for x in A:\\n            ans[index[x%2]] = x\\n            index[x%2] += 2\\n        return ans \\n```\n```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        ii, i = 0, 1\\n        while ii < len(nums) and i < len(nums): \\n            if not nums[ii] & 1: ii += 2\\n            elif nums[i] & 1: i += 2\\n            else: \\n                nums[ii], nums[i] = nums[i], nums[ii]\\n                ii += 2\\n                i += 2\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 184608,
                "title": "javascript-beats-100",
                "content": "```\\n    var ans = new Array(A.length);\\n    var odd = 1, even = 0;\\n    \\n    for (var i = 0; i < A.length ; i++){\\n        if (A[i] % 2 === 0){\\n            ans[even] = A[i];\\n            even += 2;\\n        }else{\\n            ans[odd] = A[i];\\n            odd += 2;\\n        }\\n    }\\n\\n    return ans;",
                "solutionTags": [],
                "code": "```\\n    var ans = new Array(A.length);\\n    var odd = 1, even = 0;\\n    \\n    for (var i = 0; i < A.length ; i++){\\n        if (A[i] % 2 === 0){\\n            ans[even] = A[i];\\n            even += 2;\\n        }else{\\n            ans[odd] = A[i];\\n            odd += 2;\\n        }\\n    }\\n\\n    return ans;",
                "codeTag": "Unknown"
            },
            {
                "id": 3440920,
                "title": "smartest-solution-with-java-beats-99-90-1-way",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int odd = 1;\\n        int even = 0;\\n        int[] ret = new int[nums.length];\\n        for(int a: nums){\\n            if(a%2==0){\\n                ret[even] = a;\\n                even += 2;\\n            }else{\\n                ret[odd] = a;\\n                odd+=2;\\n            }\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int odd = 1;\\n        int even = 0;\\n        int[] ret = new int[nums.length];\\n        for(int a: nums){\\n            if(a%2==0){\\n                ret[even] = a;\\n                even += 2;\\n            }else{\\n                ret[odd] = a;\\n                odd+=2;\\n            }\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499431,
                "title": "one-pass-two-pointer-solution",
                "content": "Consider two pointers, one **oddIx**, pointing to odd position and the other **evenIx**, pointing to even position.\\nBegining with **oddIx at 1** and **evenIx at 0**, we will increment these **until one exceeds the length** of the array.\\nIf we have odd number at even position or even number at odd position, we will like to change this, so we will **swap** only **when both**, oddIx and evenIx, **holds number of opposite category(even/odd)**.\\nElse, we would simply skip the position for oddIx and evenIx if they hold number belonging to their category.\\n\\n\\n```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int oddIx = 1, evenIx = 0;\\n        while(oddIx < nums.length && evenIx < nums.length){\\n            if (nums[oddIx] % 2 < nums[evenIx] % 2){\\n                int temp = nums[oddIx];\\n                nums[oddIx] = nums[evenIx];\\n                nums[evenIx] = temp;\\n            }\\n            if (nums[oddIx] % 2 == 1)\\n                oddIx = oddIx + 2;\\n            if (nums[evenIx] % 2 == 0)\\n                evenIx = evenIx + 2;\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int oddIx = 1, evenIx = 0;\\n        while(oddIx < nums.length && evenIx < nums.length){\\n            if (nums[oddIx] % 2 < nums[evenIx] % 2){\\n                int temp = nums[oddIx];\\n                nums[oddIx] = nums[evenIx];\\n                nums[evenIx] = temp;\\n            }\\n            if (nums[oddIx] % 2 == 1)\\n                oddIx = oddIx + 2;\\n            if (nums[evenIx] % 2 == 0)\\n                evenIx = evenIx + 2;\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1476301,
                "title": "c-simpler-than-top-voted-answer",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 0, j = n-1;\\n        //i stands for even\\n        //j stands for odd\\n        while(i < n && j >= 0) {\\n            if   (nums[i]%2 == 0)    i += 2;\\n            else if(nums[j] %2 == 1) j -= 2;\\n            else                     swap(nums[i], nums[j]);\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 0, j = n-1;\\n        //i stands for even\\n        //j stands for odd\\n        while(i < n && j >= 0) {\\n            if   (nums[i]%2 == 0)    i += 2;\\n            else if(nums[j] %2 == 1) j -= 2;\\n            else                     swap(nums[i], nums[j]);\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1156067,
                "title": "java-faster-than-99",
                "content": "\\tclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int oddindex = 1;\\n       int evenindex = 0;\\n       int res[] = new int[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i]%2==0) {\\n                res[evenindex]=nums[i];\\n                evenindex+=2;\\n            }\\n            else\\n            {\\n                res[oddindex]=nums[i];\\n                oddindex+=2;\\n            }\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int oddindex = 1;\\n       int evenindex = 0;\\n       int res[] = new int[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i]%2==0) {\\n                res[evenindex]=nums[i];\\n                evenindex+=2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 397526,
                "title": "javascript-one-loop-solution",
                "content": "```\\nconst sortArrayByParityII = arr => {\\n    let res = []\\n    let evenIndex = 0\\n    let oddIndex = 1\\n    for (let i = 0; i < arr.length; i++) {\\n        if (arr[i] % 2 === 0) {\\n            res[evenIndex] = arr[i]\\n            evenIndex = evenIndex + 2\\n        } else {\\n            res[oddIndex] = arr[i]\\n            oddIndex = oddIndex + 2\\n        }\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst sortArrayByParityII = arr => {\\n    let res = []\\n    let evenIndex = 0\\n    let oddIndex = 1\\n    for (let i = 0; i < arr.length; i++) {\\n        if (arr[i] % 2 === 0) {\\n            res[evenIndex] = arr[i]\\n            evenIndex = evenIndex + 2\\n        } else {\\n            res[oddIndex] = arr[i]\\n            oddIndex = oddIndex + 2\\n        }\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2169529,
                "title": "python3-o-n-o-1",
                "content": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        even, odd = 0, 1\\n        \\n        while even < len(nums) and odd < len(nums):\\n            while even < len(nums) and nums[even] % 2 == 0:\\n                even += 2\\n            while odd < len(nums) and nums[odd] % 2 != 0:\\n                odd += 2\\n                \\n            if even < len(nums) and odd < len(nums):\\n                nums[even], nums[odd] = nums[odd], nums[even]\\n                \\n            even += 2\\n            odd += 2\\n        \\n        return nums\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        even, odd = 0, 1\\n        \\n        while even < len(nums) and odd < len(nums):\\n            while even < len(nums) and nums[even] % 2 == 0:\\n                even += 2\\n            while odd < len(nums) and nums[odd] % 2 != 0:\\n                odd += 2\\n                \\n            if even < len(nums) and odd < len(nums):\\n                nums[even], nums[odd] = nums[odd], nums[even]\\n                \\n            even += 2\\n            odd += 2\\n        \\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1049238,
                "title": "simple-c-two-pointers-solution",
                "content": "Simple two pointers solution\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& A) {\\n      int n = A.size();\\n        for(int i = 0, j = 1; j < A.size() && i < A.size();){\\n            if(A[i]%2==0 )\\n                i+=2;\\n            else if(A[j]%2==1)\\n                j+=2;\\n            else(swap(A[i],A[j]));\\n            \\n        }\\n        return A;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& A) {\\n      int n = A.size();\\n        for(int i = 0, j = 1; j < A.size() && i < A.size();){\\n            if(A[i]%2==0 )\\n                i+=2;\\n            else if(A[j]%2==1)\\n                j+=2;\\n            else(swap(A[i],A[j]));\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3519592,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int n=nums.size();\\n        int i=0;\\n        int j=1;\\n        while(i<n && j<n){\\n            if(nums[i]%2==0)\\n                i=i+2;\\n            else if(nums[j]%2==1)\\n                j=j+2;\\n            else\\n                swap(nums[i],nums[j]);\\n        }\\n        return nums;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n\\n        j=1\\n\\n        for i in range(0,len(nums),2):\\n            if nums[i]%2:\\n                while nums[j]%2:\\n                    j+=2\\n                nums[i],nums[j]=nums[j],nums[i]\\n\\n        return nums\\n```\\n\\n```Java []\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int[] freq = new int[1001];\\n        for (int n : nums){\\n            freq[n]++;\\n        }\\n        for (int k = 0; k < 2; k++) {\\n            int cur = k;\\n            for (int i = k; i < nums.length; i += 2) {\\n                while (freq[cur] == 0) cur += 2;\\n                freq[cur]--;\\n                nums[i] = cur;\\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int n=nums.size();\\n        int i=0;\\n        int j=1;\\n        while(i<n && j<n){\\n            if(nums[i]%2==0)\\n                i=i+2;\\n            else if(nums[j]%2==1)\\n                j=j+2;\\n            else\\n                swap(nums[i],nums[j]);\\n        }\\n        return nums;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n\\n        j=1\\n\\n        for i in range(0,len(nums),2):\\n            if nums[i]%2:\\n                while nums[j]%2:\\n                    j+=2\\n                nums[i],nums[j]=nums[j],nums[i]\\n\\n        return nums\\n```\n```Java []\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int[] freq = new int[1001];\\n        for (int n : nums){\\n            freq[n]++;\\n        }\\n        for (int k = 0; k < 2; k++) {\\n            int cur = k;\\n            for (int i = k; i < nums.length; i += 2) {\\n                while (freq[cur] == 0) cur += 2;\\n                freq[cur]--;\\n                nums[i] = cur;\\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2722158,
                "title": "c-easy-even-odd-vector",
                "content": "### Simple Solution using Even & Odd Vector \\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& a) {\\n        vector<int>even;\\n        vector<int>odd;\\n        vector<int>ans;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            if(a[i]%2==0)\\n                even.push_back(a[i]);\\n            else\\n                odd.push_back(a[i]);\\n        }\\n        int n=even.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(even[i]);\\n            ans.push_back(odd[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& a) {\\n        vector<int>even;\\n        vector<int>odd;\\n        vector<int>ans;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            if(a[i]%2==0)\\n                even.push_back(a[i]);\\n            else\\n                odd.push_back(a[i]);\\n        }\\n        int n=even.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(even[i]);\\n            ans.push_back(odd[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2628372,
                "title": "2-solutions-using-extra-space-and-without-extra-space-c",
                "content": "# **Using Extra Space : O(N)** #\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        \\n        vector<int> odd, even;\\n        for(int i = 0 ; i < nums.size(); i++)\\n        {\\n            if((nums[i]&1) == 1)\\n                odd.push_back(nums[i]);\\n            else\\n                even.push_back(nums[i]);\\n        }\\n        int e = 0, o = 0;\\n        for(int i = 0 ; i < nums.size(); i++)\\n        {\\n            if((i & 1) == 0){\\n                nums[i] = even[e];\\n                e++;\\n            }\\n            else\\n            {\\n                nums[i] = odd[o];\\n                o++;\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```\\n# **Without Using Extra Space : O(1)** #\\n```\\nclass Solution{\\npublic:\\n    vector<int> sortArrayByParityII(vector<int> &nums)\\n    {\\n        int i = 0, j = 1, n = nums.size();\\n        while (i < n && j < n)\\n        {\\n            if (nums[i] % 2 == 0)\\n                i += 2;\\n            else if (nums[j] % 2 != 0)\\n                j += 2;\\n            else\\n            {\\n                swap(nums[i], nums[j]);\\n                i += 2;\\n                j += 2;\\n            }\\n        }\\n        return nums;\\n    }\\n\\t```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        \\n        vector<int> odd, even;\\n        for(int i = 0 ; i < nums.size(); i++)\\n        {\\n            if((nums[i]&1) == 1)\\n                odd.push_back(nums[i]);\\n            else\\n                even.push_back(nums[i]);\\n        }\\n        int e = 0, o = 0;\\n        for(int i = 0 ; i < nums.size(); i++)\\n        {\\n            if((i & 1) == 0){\\n                nums[i] = even[e];\\n                e++;\\n            }\\n            else\\n            {\\n                nums[i] = odd[o];\\n                o++;\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```\n```\\nclass Solution{\\npublic:\\n    vector<int> sortArrayByParityII(vector<int> &nums)\\n    {\\n        int i = 0, j = 1, n = nums.size();\\n        while (i < n && j < n)\\n        {\\n            if (nums[i] % 2 == 0)\\n                i += 2;\\n            else if (nums[j] % 2 != 0)\\n                j += 2;\\n            else\\n            {\\n                swap(nums[i], nums[j]);\\n                i += 2;\\n                j += 2;\\n            }\\n        }\\n        return nums;\\n    }\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1774458,
                "title": "c-easy-to-understand-step-by-step-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        \\n        vector<int> result(nums.size());\\n        int even=0,odd=1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]%2==0)\\n            {\\n                result[even]=nums[i];\\n                    even+=2;\\n            }\\n            else if(nums[i]%2!=0)\\n            \\n                {\\n                    result[odd]=nums[i];\\n                    odd+=2;\\n                }\\n            \\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        \\n        vector<int> result(nums.size());\\n        int even=0,odd=1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]%2==0)\\n            {\\n                result[even]=nums[i];\\n                    even+=2;\\n            }\\n            else if(nums[i]%2!=0)\\n            \\n                {\\n                    result[odd]=nums[i];\\n                    odd+=2;\\n                }\\n            \\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1498698,
                "title": "very-easy-two-pointer-solution-in-java-for-beginners",
                "content": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int even = 0 ;\\n        int odd =  1 ;\\n        \\n        while(even < nums.length && odd < nums.length){\\n            \\n            if(nums[even]%2 != 0){\\n                swap(nums , even , odd);\\n                odd += 2 ;\\n            } else{\\n                even += 2 ;\\n            }\\n        }\\n        \\n        return nums ;\\n    }\\n    \\n    public void swap(int[] arr , int e1 , int e2){\\n        int temp = arr[e1];\\n        arr[e1] = arr[e2];\\n        arr[e2] = temp ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int even = 0 ;\\n        int odd =  1 ;\\n        \\n        while(even < nums.length && odd < nums.length){\\n            \\n            if(nums[even]%2 != 0){\\n                swap(nums , even , odd);\\n                odd += 2 ;\\n            } else{\\n                even += 2 ;\\n            }\\n        }\\n        \\n        return nums ;\\n    }\\n    \\n    public void swap(int[] arr , int e1 , int e2){\\n        int temp = arr[e1];\\n        arr[e1] = arr[e2];\\n        arr[e2] = temp ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330742,
                "title": "two-pointer-solution-python-3-beats-90",
                "content": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        \\n        e = 0 #even_index\\n        o = 1 #odd_index\\n        \\n        while e<len(nums) and o<len(nums):\\n            if nums[e]%2==0:\\n                e+=2\\n            else:\\n                if nums[o]%2!=0:\\n                    o+=2\\n                else:\\n                    nums[e],nums[o] = nums[o],nums[e]\\n                    e+=2\\n                    o+=2\\n                                \\n        return nums\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        \\n        e = 0 #even_index\\n        o = 1 #odd_index\\n        \\n        while e<len(nums) and o<len(nums):\\n            if nums[e]%2==0:\\n                e+=2\\n            else:\\n                if nums[o]%2!=0:\\n                    o+=2\\n                else:\\n                    nums[e],nums[o] = nums[o],nums[e]\\n                    e+=2\\n                    o+=2\\n                                \\n        return nums\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1210032,
                "title": "c-in-place-solution-for-90-faster-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n         \\n        for(int i =0 , j =1 ; j < nums.size() && i <nums.size();)\\n        {\\n            if(nums[i] %2 ==0)\\n            i+=2;\\n            else if(nums[j] % 2 ==1)\\n            j+=2;\\n            else\\n            swap(nums[i],nums[j]);\\n        }\\n        return nums;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n         \\n        for(int i =0 , j =1 ; j < nums.size() && i <nums.size();)\\n        {\\n            if(nums[i] %2 ==0)\\n            i+=2;\\n            else if(nums[j] % 2 ==1)\\n            j+=2;\\n            else\\n            swap(nums[i],nums[j]);\\n        }\\n        return nums;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1197747,
                "title": "c-12ms-98-two-pointers-in-place",
                "content": "Runtime: 12 ms, faster than 98.13% of C++ online submissions for Sort Array By Parity II.\\nMemory Usage: 21.5 MB, less than 29.09% of C++ online submissions for Sort Array By Parity II.\\n```\\nclass Solution {\\npublic:\\n  vector<int> sortArrayByParityII(vector<int>& A) {\\n    int i = 0, ni = A.size(), j = 1, nj = A.size() + 1;\\n    \\n    while(true){\\n      while(i != ni && A[i]%2 == 0) i+=2;\\n      while(j != nj && A[j]%2 == 1) j+=2;\\n      if(i == ni) break;\\n      swap(A[i],A[j]);\\n    }\\n    return A;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  vector<int> sortArrayByParityII(vector<int>& A) {\\n    int i = 0, ni = A.size(), j = 1, nj = A.size() + 1;\\n    \\n    while(true){\\n      while(i != ni && A[i]%2 == 0) i+=2;\\n      while(j != nj && A[j]%2 == 1) j+=2;\\n      if(i == ni) break;\\n      swap(A[i],A[j]);\\n    }\\n    return A;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 919338,
                "title": "python3-easy-to-understand-solution",
                "content": "class Solution:\\n    def sortArrayByParityII(self, A: List[int]) -> List[int]:\\n\\t\\n        op=[0]*len(A)\\n        e=0\\n        o=1\\n        for i in A:\\n            if i%2==0:\\n                op[e]=i\\n                e+=2\\n            else:\\n                op[o]=i\\n                o+=2\\n        return op\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def sortArrayByParityII(self, A: List[int]) -> List[int]:\\n\\t\\n        op=[0]*len(A)\\n        e=0\\n        o=1\\n        for i in A:\\n            if i%2==0:\\n                op[e]=i\\n                e+=2\\n            else:\\n                op[o]=i\\n                o+=2\\n        return op\\n",
                "codeTag": "Java"
            },
            {
                "id": 764104,
                "title": "c-o-n-solution",
                "content": "```\\nint* sortArrayByParityII(int* A, int ASize, int* returnSize)\\n{\\n    int *res = malloc(sizeof(int) * ASize);\\n    *returnSize = ASize;\\n    int *odd, *even, i = 0;\\n    \\n    odd = res + 1;\\n    even = res;\\n    \\n    while(i < ASize)\\n    {\\n        if(A[i] % 2)\\n        {\\n            *odd = A[i];\\n            odd +=2;\\n            i++;\\n            \\n        }\\n        else\\n        {\\n            *even = A[i];\\n            even += 2;\\n            i++;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint* sortArrayByParityII(int* A, int ASize, int* returnSize)\\n{\\n    int *res = malloc(sizeof(int) * ASize);\\n    *returnSize = ASize;\\n    int *odd, *even, i = 0;\\n    \\n    odd = res + 1;\\n    even = res;\\n    \\n    while(i < ASize)\\n    {\\n        if(A[i] % 2)\\n        {\\n            *odd = A[i];\\n            odd +=2;\\n            i++;\\n            \\n        }\\n        else\\n        {\\n            *even = A[i];\\n            even += 2;\\n            i++;\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 558016,
                "title": "java-faster-than-99-63",
                "content": "```\\nclass Solution {\\n    \\n    void swap(int[] A, int i, int j){\\n         int tmp = A[i];\\n         A[i] = A[j];\\n         A[j] = tmp;\\n    }\\n    \\n    public int[] sortArrayByParityII(int[] A) {\\n        int odd_p = 1;\\n        int n = A.length;\\n        \\n        for(int i=0;i<n;i+=2){\\n            if(A[i]%2 == 1){\\n                while(A[odd_p]%2 == 1)\\n                    odd_p += 2;\\n                swap(A, i, odd_p);\\n            }\\n        }\\n        \\n        return A;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    void swap(int[] A, int i, int j){\\n         int tmp = A[i];\\n         A[i] = A[j];\\n         A[j] = tmp;\\n    }\\n    \\n    public int[] sortArrayByParityII(int[] A) {\\n        int odd_p = 1;\\n        int n = A.length;\\n        \\n        for(int i=0;i<n;i+=2){\\n            if(A[i]%2 == 1){\\n                while(A[odd_p]%2 == 1)\\n                    odd_p += 2;\\n                swap(A, i, odd_p);\\n            }\\n        }\\n        \\n        return A;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 349213,
                "title": "solution-in-python-3-beats-100-two-pointer-space-o-1",
                "content": "```\\nclass Solution:\\n    def sortArrayByParityII(self, A: List[int]) -> List[int]:\\n    \\tj = 1\\n    \\tfor i in range(0,len(A),2):\\n    \\t\\tif A[i] % 2 == 0: continue\\n    \\t\\twhile A[j] % 2 != 0: j += 2\\n    \\t\\tA[i], A[j] = A[j], A[i]\\n    \\treturn A\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, A: List[int]) -> List[int]:\\n    \\tj = 1\\n    \\tfor i in range(0,len(A),2):\\n    \\t\\tif A[i] % 2 == 0: continue\\n    \\t\\twhile A[j] % 2 != 0: j += 2\\n    \\t\\tA[i], A[j] = A[j], A[i]\\n    \\treturn A\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri",
                "codeTag": "Java"
            },
            {
                "id": 266823,
                "title": "java-two-pointers-one-pass-beats-99",
                "content": "```\\n`public int[] sortArrayByParityII(int[] A) {\\n        int[] res = new int[A.length];\\n        int i = 0, k = 1;\\n        for (int j = 0; j < A.length; j++) {\\n            if (A[j] % 2 == 0) {\\n                res[i] = A[j];\\n                i+=2;\\n            } \\n            else {\\n                res[k] = A[j];\\n                k+=2;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n`public int[] sortArrayByParityII(int[] A) {\\n        int[] res = new int[A.length];\\n        int i = 0, k = 1;\\n        for (int j = 0; j < A.length; j++) {\\n            if (A[j] % 2 == 0) {\\n                res[i] = A[j];\\n                i+=2;\\n            } \\n            else {\\n                res[k] = A[j];\\n                k+=2;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 208169,
                "title": "c-this-problem-is-so-easy-that-i-code-it-fluently-with-no-change",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& A) {\\n        \\n        for(int i=0,j=1;j<A.size();){\\n            if(A[i]%2 == 1 && A[j]%2 == 0){\\n                swap(A[i],A[j]);\\n                i=i+2;\\n                j=j+2;\\n            }else if(A[i]%2 == 0 && A[j]%2 == 0){\\n                i=i+2;\\n            }else if(A[i]%2 == 1 && A[j]%2 == 1){\\n                j=j+2;\\n            }else{\\n                i=i+2;\\n                j=j+2;\\n            }\\n        }\\n        return A;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& A) {\\n        \\n        for(int i=0,j=1;j<A.size();){\\n            if(A[i]%2 == 1 && A[j]%2 == 0){\\n                swap(A[i],A[j]);\\n                i=i+2;\\n                j=j+2;\\n            }else if(A[i]%2 == 0 && A[j]%2 == 0){\\n                i=i+2;\\n            }else if(A[i]%2 == 1 && A[j]%2 == 1){\\n                j=j+2;\\n            }else{\\n                i=i+2;\\n                j=j+2;\\n            }\\n        }\\n        return A;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 182755,
                "title": "javascript",
                "content": "```\nvar sortArrayByParityII = function(A) {\n    let oddIndex = 1;\n    let evenIndex = 0;\n    \n    let result = new Array(A.length);\n    for(let i = 0; i < A.length; i++) {\n        if(A[i] % 2 == 0) {\n            result[evenIndex] = A[i];\n            evenIndex += 2;\n        } else {\n            result[oddIndex] = A[i];\n            oddIndex += 2;\n        }\n    }\n    return result;\n};\n```",
                "solutionTags": [],
                "code": "```\nvar sortArrayByParityII = function(A) {\n    let oddIndex = 1;\n    let evenIndex = 0;\n    \n    let result = new Array(A.length);\n    for(let i = 0; i < A.length; i++) {\n        if(A[i] % 2 == 0) {\n            result[evenIndex] = A[i];\n            evenIndex += 2;\n        } else {\n            result[oddIndex] = A[i];\n            oddIndex += 2;\n        }\n    }\n    return result;\n};\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3733555,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int even = 0 , odd=1;\\n\\t\\t\\t\\tint n = nums.size() ;\\n\\t\\t\\t\\twhile(even < n && odd < n){\\n\\t\\t\\t\\t\\tif(nums[even]%2==0){\\n\\t\\t\\t\\t\\t\\teven += 2;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(nums[odd]%2 == 1){\\n\\t\\t\\t\\t\\t\\todd+=2;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\tswap(nums[even],nums[odd]);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int even = 0 , odd=1;\\n\\t\\t\\t\\tint n = nums.size() ;\\n\\t\\t\\t\\twhile(even < n && odd < n){\\n\\t\\t\\t\\t\\tif(nums[even]%2==0){\\n\\t\\t\\t\\t\\t\\teven += 2;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(nums[odd]%2 == 1){\\n\\t\\t\\t\\t\\t\\todd+=2;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\tswap(nums[even],nums[odd]);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3440934,
                "title": "smartest-solution-with-java-beats-99-50-2-way",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int even = 0;\\n        int odd = 1;\\n\\n        while(true){\\n            while(even<nums.length && nums[even]%2 == 0){\\n                even += 2;\\n            }\\n            while(odd<nums.length && nums[odd]%2 == 1){\\n                odd += 2;\\n            }\\n            if(odd >= nums.length || even >= nums.length) break;\\n\\n            int temp = nums[odd];\\n            nums[odd] = nums[even];\\n            nums[even] = temp;\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int even = 0;\\n        int odd = 1;\\n\\n        while(true){\\n            while(even<nums.length && nums[even]%2 == 0){\\n                even += 2;\\n            }\\n            while(odd<nums.length && nums[odd]%2 == 1){\\n                odd += 2;\\n            }\\n            if(odd >= nums.length || even >= nums.length) break;\\n\\n            int temp = nums[odd];\\n            nums[odd] = nums[even];\\n            nums[even] = temp;\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3304439,
                "title": "most-easy-way-efficient-approach-beats-95",
                "content": "# Intuition\\nAs soon as i saw the problem it was clear that we have to swap any unwanted element with respect to its index. i.e even element in odd index and odd element in even index.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTwo pointers approach. Here we will take two pointers i and j, i is to find any odd element in even index, so i will start from 0 (i=0), j is to find even any element in odd index. When these both condition are true just swap i and j.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int n=nums.size();\\n        int i=0,j=1;\\n        while(i<n && j<n)\\n        {\\n            while(i<n && nums[i]%2==0)\\n                i+=2;\\n            while(j<n && nums[j]%2!=0)\\n                j+=2;\\n            if(i<n)\\n                swap(nums[i],nums[j]);\\n            i+=2;j+=2;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int n=nums.size();\\n        int i=0,j=1;\\n        while(i<n && j<n)\\n        {\\n            while(i<n && nums[i]%2==0)\\n                i+=2;\\n            while(j<n && nums[j]%2!=0)\\n                j+=2;\\n            if(i<n)\\n                swap(nums[i],nums[j]);\\n            i+=2;j+=2;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3121590,
                "title": "beats-99-optimization-two-solution-o-2n-o-n",
                "content": "# Intuition One\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. since half of array contains even and odd numbers, and we have to place even at even elements indexes and odd elements at odd indexes so to avoid complexity we declare another vector for even and odd for easy way.\\n# Approach Number One\\n<!-- Describe your approach to solving the problem. -->\\n1. declare even and odd vector. if nums[i] is even array, pushback it in even and if it is odd then in odd array\\n2. now, in loop, check whether i is even or odd, accordingly set even elements at even indexes and odd elements at odd indexes respectively.\\n3. I have taken k and m so that i can excess even and odd array elements\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(2N)-> O(N)\\n\\n# Code One\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        vector<int> even;\\n        vector<int> odd;\\n\\n        //seperating even and odd elements\\n        for(int i=0; i < nums.size(); i++)\\n        {\\n            if(nums[i] & 1)\\n            odd.push_back(nums[i]);\\n            else \\n            even.push_back(nums[i]);\\n        }\\n        int k=0, m=0;\\n        inserting even element at even index and odd at odd index.\\n        for(int i=0; i < nums.size(); i++)\\n        {\\n            if(i&1)//odd\\n                nums[i]= odd[m++];\\n            else//even\\n                nums[i]= even[k++];\\n        }\\n        return nums;\\n    }\\n};\\n```\\n# Intuition Two\\nWe can solve this without declaring extra arrays, that is, even and odd. We will check directly nums[i] is even or odd and directly place it at its respective index in ans vector.\\n\\n# Approach Number Two(OPTIMIZED)\\n1. iterate throughout the array, check nums[i] is even or odd. \\n2. if nums[i] is even set it to even index and if it is odd set it to odd index.\\n\\n# Time Complexity -> O(N)\\n# Space Complexity ->O(1)\\nCode block\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        vector<int> ans;\\n        int k=1, m=0;\\n        for(int i=0; i < nums.size(); i++)\\n        {\\n            if(nums[i] & 1) //odd\\n            {\\n                ans[k]= nums[i];\\n                k=k+2;\\n            }\\n            else//even\\n            {\\n                ans[m]=nums[i];\\n                m=m+2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n// hope you like it. Upvote it please. If you find any problem, do let me know in the comment section.\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        vector<int> even;\\n        vector<int> odd;\\n\\n        //seperating even and odd elements\\n        for(int i=0; i < nums.size(); i++)\\n        {\\n            if(nums[i] & 1)\\n            odd.push_back(nums[i]);\\n            else \\n            even.push_back(nums[i]);\\n        }\\n        int k=0, m=0;\\n        inserting even element at even index and odd at odd index.\\n        for(int i=0; i < nums.size(); i++)\\n        {\\n            if(i&1)//odd\\n                nums[i]= odd[m++];\\n            else//even\\n                nums[i]= even[k++];\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2821154,
                "title": "cpp-two-pointer-in-place",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        \\n        int odd = 1; // pointer at odd index\\n        int even = 0; //pointer at even index \\n        \\n        while(even<nums.size()){\\n            if(nums[even] % 2 == 0){ // if even place has even value \\n                even += 2; // increment even pointer\\n            }\\n            else{ // else even place has odd value\\n                swap(nums[even], nums[odd]); // swap values such that odd pointer will surely have odd value\\n                odd += 2; // increment odd pointer\\n            }\\n        }\\n        return nums; // return your in-place solution \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        \\n        int odd = 1; // pointer at odd index\\n        int even = 0; //pointer at even index \\n        \\n        while(even<nums.size()){\\n            if(nums[even] % 2 == 0){ // if even place has even value \\n                even += 2; // increment even pointer\\n            }\\n            else{ // else even place has odd value\\n                swap(nums[even], nums[odd]); // swap values such that odd pointer will surely have odd value\\n                odd += 2; // increment odd pointer\\n            }\\n        }\\n        return nums; // return your in-place solution \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755990,
                "title": "js",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar sortArrayByParityII = function(nums) {\\nlet res = [];\\nnums = nums.sort()\\n\\n\\nlet odd = [];\\nlet even = [];\\nfor (let i = 0; i < nums.length; i++) {\\n  if(nums[i] % 2 === 0) odd.push(nums[i]);\\n  else {\\n    even.push(nums[i])\\n  }  \\n}\\nfor (let i = 0; i < nums.length; i++) {\\n  if(i % 2 === 0)\\n    res.push(odd.pop())\\n  else  res.push(even.pop())\\n}\\nreturn res\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar sortArrayByParityII = function(nums) {\\nlet res = [];\\nnums = nums.sort()\\n\\n\\nlet odd = [];\\nlet even = [];\\nfor (let i = 0; i < nums.length; i++) {\\n  if(nums[i] % 2 === 0) odd.push(nums[i]);\\n  else {\\n    even.push(nums[i])\\n  }  \\n}\\nfor (let i = 0; i < nums.length; i++) {\\n  if(i % 2 === 0)\\n    res.push(odd.pop())\\n  else  res.push(even.pop())\\n}\\nreturn res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2703647,
                "title": "85ms-java-solution-but-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] A) {\\n        \\n        List<Integer> even = new ArrayList<>();\\n        List<Integer> odd = new ArrayList<>();\\n        \\n        for (int n : A) {\\n            if (n % 2 == 0)\\n                even.add(n);\\n            else \\n                odd.add(n);\\n        }\\n        int[] result = new int[A.length];\\n        for (int i = 0; i < A.length; i++) {\\n            if (i % 2 == 0) {\\n                result[i] = even.remove(0);\\n            } else {\\n                result[i] = odd.remove(0);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] A) {\\n        \\n        List<Integer> even = new ArrayList<>();\\n        List<Integer> odd = new ArrayList<>();\\n        \\n        for (int n : A) {\\n            if (n % 2 == 0)\\n                even.add(n);\\n            else \\n                odd.add(n);\\n        }\\n        int[] result = new int[A.length];\\n        for (int i = 0; i < A.length; i++) {\\n            if (i % 2 == 0) {\\n                result[i] = even.remove(0);\\n            } else {\\n                result[i] = odd.remove(0);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2702239,
                "title": "java-easiest-solution-2-approaches-faster-than-80-online-submission-easy-understanding",
                "content": "```\\n//Approch :- 1 Runtime 9Ms Faster Than 33.3%\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int even = 0,odd = 1;\\n        int[] arr = new int[nums.length];\\n        for(int i: nums){\\n            if(i%2 == 0){\\n                arr[even] = i;\\n                even+=2;\\n            }\\n            else{\\n                arr[odd] = i;\\n                odd+=2;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n\\n\\n//Approch :- 2 Runtime 4Ms Faster Than 77.63%\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int even=0,odd=1;\\n        int[] arr = new int[nums.length];\\n        while(even<nums.length && odd<nums.length){\\n            while(even<nums.length && nums[even]%2 == 0){\\n                even+=2;\\n            }\\n            while(odd<nums.length && nums[odd]%2 == 1){\\n                odd+=2;\\n            }\\n            if(even<nums.length && odd<nums.length){\\n                int temp = nums[even];\\n                nums[even] = nums[odd];\\n                nums[odd] = temp;\\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//Approch :- 1 Runtime 9Ms Faster Than 33.3%\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int even = 0,odd = 1;\\n        int[] arr = new int[nums.length];\\n        for(int i: nums){\\n            if(i%2 == 0){\\n                arr[even] = i;\\n                even+=2;\\n            }\\n            else{\\n                arr[odd] = i;\\n                odd+=2;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n\\n\\n//Approch :- 2 Runtime 4Ms Faster Than 77.63%\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int even=0,odd=1;\\n        int[] arr = new int[nums.length];\\n        while(even<nums.length && odd<nums.length){\\n            while(even<nums.length && nums[even]%2 == 0){\\n                even+=2;\\n            }\\n            while(odd<nums.length && nums[odd]%2 == 1){\\n                odd+=2;\\n            }\\n            if(even<nums.length && odd<nums.length){\\n                int temp = nums[even];\\n                nums[even] = nums[odd];\\n                nums[odd] = temp;\\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2106494,
                "title": "c-easy-two-pointer-solution-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) \\n    {\\n     vector<int>ans;\\n        vector<int>even;\\n        vector<int>odd;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]%2==0){\\n                even.push_back(nums[i]);\\n            }\\n            if(nums[i]%2==1){\\n                odd.push_back(nums[i]);\\n            }\\n        }\\n            int j=0;\\n            int k=0;\\n            for(int i=0;i<nums.size();i++){\\n                if(i%2==0){\\n                    ans.push_back(even[j]);\\n                    j++;\\n                }\\n                else{\\n                    ans.push_back(odd[k]);\\n                    k++;\\n                }\\n            }\\n return ans;\\n        \\n    }\\n};\\n \\n           \\n",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) \\n    {\\n     vector<int>ans;\\n        vector<int>even;\\n        vector<int>odd;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]%2==0){\\n                even.push_back(nums[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2074974,
                "title": "c-solution-simply-explained-constant-space-fast-algorithm",
                "content": "```\\nclass Solution {\\n  public:\\n    void reArrange(int arr[], int n) {\\n        //I have tried writing a simple while-loop method to swap wrongly placed odd and wrongly placed even elements.\\n        \\n        int x = 0;\\n        int y = 0;\\n        \\n        while(x<n && y<n){\\n            \\n            //wrongly placed odd\\n            if(x%2==0 and arr[x]%2==1){\\n                x++;\\n            }\\n            //rightly placed even\\n            else if(x%2==0 and arr[x]%2==0){\\n                x++;\\n            }\\n            //rightly placed odd\\n            else if(x%2==1 and arr[x]%2==1){\\n                x++;\\n            }\\n            \\n            //wrongly placed even\\n            if(y%2==1 and arr[y]%2==0){\\n                y++;\\n            }\\n            //rightly placed even\\n            else if(y%2==0 and arr[y]%2==0){\\n                y++;\\n            }\\n            //rightly placed odd\\n            else if(y%2==1 and arr[y]%2==1){\\n                y++;\\n            }\\n            \\n            //swap wrongly placed even and wrongly placed odd\\n            if(x%2==1 and arr[x]%2==0 and y%2==0 and arr[y]%2==1){\\n                swap(arr[x],arr[y]);\\n                x++;\\n                y++;\\n            }\\n        }\\n    }\\n};\\n```\\nDo upvote and comment. Thanks.",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n  public:\\n    void reArrange(int arr[], int n) {\\n        //I have tried writing a simple while-loop method to swap wrongly placed odd and wrongly placed even elements.\\n        \\n        int x = 0;\\n        int y = 0;\\n        \\n        while(x<n && y<n){\\n            \\n            //wrongly placed odd\\n            if(x%2==0 and arr[x]%2==1){\\n                x++;\\n            }\\n            //rightly placed even\\n            else if(x%2==0 and arr[x]%2==0){\\n                x++;\\n            }\\n            //rightly placed odd\\n            else if(x%2==1 and arr[x]%2==1){\\n                x++;\\n            }\\n            \\n            //wrongly placed even\\n            if(y%2==1 and arr[y]%2==0){\\n                y++;\\n            }\\n            //rightly placed even\\n            else if(y%2==0 and arr[y]%2==0){\\n                y++;\\n            }\\n            //rightly placed odd\\n            else if(y%2==1 and arr[y]%2==1){\\n                y++;\\n            }\\n            \\n            //swap wrongly placed even and wrongly placed odd\\n            if(x%2==1 and arr[x]%2==0 and y%2==0 and arr[y]%2==1){\\n                swap(arr[x],arr[y]);\\n                x++;\\n                y++;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2057475,
                "title": "python-two-pointers-o-n-time-explanation",
                "content": "<b>Success</b>\\nDetails \\nRuntime: 228 ms, faster than <b>73.41% </b>of Python3 online submissions for Sort Array By Parity II.\\nMemory Usage: 16.1 MB, less than <b>91.62%</b> of Python3 online submissions for Sort Array By Parity II.\\n\\n\\n1. Itterating i pointer over the array starting from zero and skipping one element so i will be always even.\\n2. Check if the current element is odd or even\\n3. If even we dont have to do anything\\n4. if odd chek j pointer which was initillized at 1.\\n5. Itterating j pointer over the array starting from one and skipping one element so i will be always odd.\\n6. if jth element is even we have to swap jth element with ith.\\n\\n```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        j=1\\n        for i in range(0,len(nums),2):\\n            if nums[i]%2!=0:\\n                while nums[j]%2!=0:\\n                    j=j+2\\n                nums[i],nums[j]=nums[j],nums[i]\\n        return nums\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        j=1\\n        for i in range(0,len(nums),2):\\n            if nums[i]%2!=0:\\n                while nums[j]%2!=0:\\n                    j=j+2\\n                nums[i],nums[j]=nums[j],nums[i]\\n        return nums\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1552138,
                "title": "c-solution-two-pointer-using-bitwise-operator",
                "content": "**If the Solution helps you,please do consider upvoting it.**\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) \\n    {\\n      for(int i=0,j=1;i<nums.size() and j<nums.size();)\\n      {\\n          if(!(nums[i]&1))\\n              i+=2;\\n          else if(nums[j]&1)\\n              j+=2;\\n          else\\n              swap(nums[i],nums[j]);\\n      }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) \\n    {\\n      for(int i=0,j=1;i<nums.size() and j<nums.size();)\\n      {\\n          if(!(nums[i]&1))\\n              i+=2;\\n          else if(nums[j]&1)\\n              j+=2;\\n          else\\n              swap(nums[i],nums[j]);\\n      }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1493808,
                "title": "c-solution",
                "content": "```\\nclass Solution \\n{\\n    public:\\n\\tvector<int> sortArrayByParityII(vector<int>& nums) \\n    {\\n\\t\\tint n = nums.size();\\n\\t\\tint i = 0, j = 1;\\n\\t\\twhile(i < n && j < n)\\n        {\\n\\t\\t\\tif(nums[i] % 2 == 0)\\n            {\\n\\t\\t\\t\\ti += 2;\\n\\t\\t\\t}\\n\\t\\t\\telse if(nums[j] % 2 == 1)\\n            {\\n\\t\\t\\t\\tj += 2;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n            {\\n\\t\\t\\t\\tswap(nums[i], nums[j]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn nums;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\n    public:\\n\\tvector<int> sortArrayByParityII(vector<int>& nums) \\n    {\\n\\t\\tint n = nums.size();\\n\\t\\tint i = 0, j = 1;\\n\\t\\twhile(i < n && j < n)\\n        {\\n\\t\\t\\tif(nums[i] % 2 == 0)\\n            {\\n\\t\\t\\t\\ti += 2;\\n\\t\\t\\t}\\n\\t\\t\\telse if(nums[j] % 2 == 1)\\n            {\\n\\t\\t\\t\\tj += 2;\\n\\t\\t\\t}\\n\\t\\t\\telse\\n            {\\n\\t\\t\\t\\tswap(nums[i], nums[j]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn nums;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1491669,
                "title": "inplace-solution-using-two-pointers-java",
                "content": "It is given that the array will have same count of even and odd numbers which means that the length of the array will always be even. \\nIf we maintain two pointers `left` and `right` at opposite ends of the array, i.e.,\\n\\n```java\\nleft = 0\\nright = n - 1\\n```\\n\\nThen we can safely say that `left` will be at even index and `right` will be at odd index. We will use this property and always make sure that the element at `left` will always be even and element at `right` will always be odd. We will move both pointers two steps ahead and behind respectively. It will result in the following three cases -\\n\\n1. If both the elements are violating the constraint, we will swap them and move both pointers\\n2. If only a single element is violating the constraint, we will move that pointer only.\\n3. If both the elements are not violating the constraint, we will just move both the pointers.\\n\\n```java\\npublic class Problem28_SortArrayByParityII {\\n\\n    public int[] sortArrayByParityII(int[] nums) {\\n        // Special case\\n        if (nums == null || nums.length == 0) {\\n            return nums;\\n        }\\n        // Length of the array\\n        int n = nums.length;\\n        // Left and right pointers\\n        int left = 0;\\n        int right = n - 1;\\n        // Loop until the condition is met\\n        while (left < n && right >= 0) {\\n            // If both the numbers at wrong positions, we will swap them\\n            if (nums[left] % 2 == 1 && nums[right] % 2 == 0) {\\n                int temp = nums[left];\\n                nums[left] = nums[right];\\n                nums[right] = temp;\\n                left += 2;\\n                right -= 2;\\n            }\\n            // If the left number is at wrong position but right\\n            // number is at correct position, we will move right\\n            // pointer two steps before\\n            else if (nums[left] % 2 == 1 && nums[right] % 2 == 1) {\\n                right -= 2;\\n            }\\n            // If the right number is at wrong position but left\\n            // number is at correct position, we will move left\\n            // pointer two steps after\\n            else if (nums[left] % 2 == 0 && nums[right] % 2 == 0) {\\n                left += 2;\\n            }\\n            // If both the numbers are at correct position, we just move\\n            // both the pointers\\n            else {\\n                left += 2;\\n                right -= 2;\\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```java\\nleft = 0\\nright = n - 1\\n```\n```java\\npublic class Problem28_SortArrayByParityII {\\n\\n    public int[] sortArrayByParityII(int[] nums) {\\n        // Special case\\n        if (nums == null || nums.length == 0) {\\n            return nums;\\n        }\\n        // Length of the array\\n        int n = nums.length;\\n        // Left and right pointers\\n        int left = 0;\\n        int right = n - 1;\\n        // Loop until the condition is met\\n        while (left < n && right >= 0) {\\n            // If both the numbers at wrong positions, we will swap them\\n            if (nums[left] % 2 == 1 && nums[right] % 2 == 0) {\\n                int temp = nums[left];\\n                nums[left] = nums[right];\\n                nums[right] = temp;\\n                left += 2;\\n                right -= 2;\\n            }\\n            // If the left number is at wrong position but right\\n            // number is at correct position, we will move right\\n            // pointer two steps before\\n            else if (nums[left] % 2 == 1 && nums[right] % 2 == 1) {\\n                right -= 2;\\n            }\\n            // If the right number is at wrong position but left\\n            // number is at correct position, we will move left\\n            // pointer two steps after\\n            else if (nums[left] % 2 == 0 && nums[right] % 2 == 0) {\\n                left += 2;\\n            }\\n            // If both the numbers are at correct position, we just move\\n            // both the pointers\\n            else {\\n                left += 2;\\n                right -= 2;\\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1491222,
                "title": "c-two-pointers-inplace-o-n-time",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        for(int i=0,j=0;i<nums.size();){\\n\\t\\t\\t// If we get an odd number or  an even number which is already processed then leave that number  \\n            if(nums[i]&1 || (i<j && !(i&1))){ \\n                i++;\\n            }\\n            else{\\n                swap(nums[i],nums[j]); // Placing even numbers at their right place. By doing this, the odd numbers will come in their place automatically\\n                j+=2;\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        for(int i=0,j=0;i<nums.size();){\\n\\t\\t\\t// If we get an odd number or  an even number which is already processed then leave that number  \\n            if(nums[i]&1 || (i<j && !(i&1))){ \\n                i++;\\n            }\\n            else{\\n                swap(nums[i],nums[j]); // Placing even numbers at their right place. By doing this, the odd numbers will come in their place automatically\\n                j+=2;\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1335190,
                "title": "c-solution-two-pointer-in-place",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int evenPointer = 0, oddPointer = 1;\\n        while(evenPointer < nums.size() && oddPointer <nums.size()){\\n            if(nums[evenPointer] %2 == 1 && nums[oddPointer]%2==0){\\n                swap(nums[evenPointer],nums[oddPointer]);\\n                evenPointer+=2;\\n                oddPointer+=2;\\n                continue;\\n            }\\n            if(nums[evenPointer]%2==0){\\n                evenPointer+=2;\\n            }\\n            if(nums[oddPointer]%2==1){\\n                oddPointer+=2;\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int evenPointer = 0, oddPointer = 1;\\n        while(evenPointer < nums.size() && oddPointer <nums.size()){\\n            if(nums[evenPointer] %2 == 1 && nums[oddPointer]%2==0){\\n                swap(nums[evenPointer],nums[oddPointer]);\\n                evenPointer+=2;\\n                oddPointer+=2;\\n                continue;\\n            }\\n            if(nums[evenPointer]%2==0){\\n                evenPointer+=2;\\n            }\\n            if(nums[oddPointer]%2==1){\\n                oddPointer+=2;\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1003699,
                "title": "python-3-two-pointers-o-n",
                "content": "```\\nclass Solution:\\n    def sortArrayByParityII(self, A: List[int]) -> List[int]:\\n\\t\\tans = [None] * len(A)\\n\\t\\tk = 0\\n\\t\\tt = 1\\n\\t\\tfor i in A:\\n\\t\\t\\tif i % 2 == 0:\\n\\t\\t\\t\\tans[k] = i\\n\\t\\t\\t\\tk += 2\\n\\t\\t\\telse:\\n\\t\\t\\t\\tans[t] = i\\n\\t\\t\\t\\tt += 2\\n\\t\\treturn ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, A: List[int]) -> List[int]:\\n\\t\\tans = [None] * len(A)\\n\\t\\tk = 0\\n\\t\\tt = 1\\n\\t\\tfor i in A:\\n\\t\\t\\tif i % 2 == 0:\\n\\t\\t\\t\\tans[k] = i\\n\\t\\t\\t\\tk += 2\\n\\t\\t\\telse:\\n\\t\\t\\t\\tans[t] = i\\n\\t\\t\\t\\tt += 2\\n\\t\\treturn ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 767628,
                "title": "c-o-n-solution",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& A) {\\n        int i,even=0,odd=1;\\n        vector<int> B(A.size());\\n        for(i=0;i<A.size();i++)\\n        {\\n            if((A[i]%2)==0)\\n            {\\n               B[even]=A[i];\\n                even+=2;\\n            } \\n            else\\n            {\\n               B[odd]=A[i];\\n                odd+=2; \\n            }\\n        }\\n        return B;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& A) {\\n        int i,even=0,odd=1;\\n        vector<int> B(A.size());\\n        for(i=0;i<A.size();i++)\\n        {\\n            if((A[i]%2)==0)\\n            {\\n               B[even]=A[i];\\n                even+=2;\\n            } \\n            else\\n            {\\n               B[odd]=A[i];\\n                odd+=2; \\n            }\\n        }\\n        return B;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 755362,
                "title": "javascript-simple-using-filter",
                "content": "```\\nvar sortArrayByParityII = function(A) {\\n    let evenNums = A.filter((i) => i % 2 === 0);\\n    let oddNums = A.filter((i) => i % 2 !== 0);\\n    \\n    let res = [];\\n    for (let i = 0; i < A.length / 2; i++) {\\n        res.push(evenNums[i], oddNums[i]);\\n    }\\n    \\n    return res;\\n};\\n```\\n\\nStats:\\nRuntime: 100 ms, faster than 88.97% of JavaScript online submissions for Sort Array By Parity II.\\nMemory Usage: 44.3 MB, less than 12.50% of JavaScript online submissions for Sort Array By Parity II.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar sortArrayByParityII = function(A) {\\n    let evenNums = A.filter((i) => i % 2 === 0);\\n    let oddNums = A.filter((i) => i % 2 !== 0);\\n    \\n    let res = [];\\n    for (let i = 0; i < A.length / 2; i++) {\\n        res.push(evenNums[i], oddNums[i]);\\n    }\\n    \\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 308659,
                "title": "efficient-python-solution-with-generator",
                "content": "We only need to check every other element for violating the problem statement invariant. If that happens, we can use generator to find matching pair to swap and to also pick up where we left off on next mismatch.\\n\\n```\\ndef sortArrayByParityII(self, A: List[int]) -> List[int]:\\n\\t\\n        def gen_odd():\\n            for j in range(1, len(A), 2):\\n                if not A[j] % 2: yield j\\n\\n        odd = gen_odd()\\n        for i in range(0,len(A),2):\\n            if A[i] % 2:\\n                j = next(odd)\\n                A[i], A[j] = A[j], A[i]\\n\\n        return A\\n```",
                "solutionTags": [],
                "code": "```\\ndef sortArrayByParityII(self, A: List[int]) -> List[int]:\\n\\t\\n        def gen_odd():\\n            for j in range(1, len(A), 2):\\n                if not A[j] % 2: yield j\\n\\n        odd = gen_odd()\\n        for i in range(0,len(A),2):\\n            if A[i] % 2:\\n                j = next(odd)\\n                A[i], A[j] = A[j], A[i]\\n\\n        return A\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 223835,
                "title": "java-solutions",
                "content": "**Solution 1:**\\n\\nTime complexity: `O(n)`\\nSpace complexity: `O(1)`\\n\\n```\\nclass Solution \\n{\\n    public int[] sortArrayByParityII(int[] A) \\n    {\\n        int i = 0;\\n        int j = 1;\\n        \\n        while(i < A.length && j < A.length)\\n        {\\n            while(i < A.length && A[i] % 2 == 0) i += 2;\\n            while(j < A.length && A[j] % 2 == 1) j += 2;\\n            \\n            if(i < A.length && j < A.length)\\n                swap(A, i, j);\\n        }\\n        return A;\\n    }\\n    \\n    private void swap(int[] A, int i, int j)\\n    {\\n        int temp = A[i];\\n        A[i] = A[j];\\n        A[j] = temp;\\n    }\\n}\\n```\\n\\n**Solution 2:**\\n\\nTime complexity: `O(n)`\\nSpace complexity: `O(1)`\\n\\n```\\nclass Solution \\n{\\n    public int[] sortArrayByParityII(int[] A) \\n    {\\n        int evenIndex = 0;\\n        int oddIndex = A.length - 1;\\n        \\n        while(evenIndex < A.length && oddIndex > 0)\\n        {\\n            if(A[evenIndex] % 2 > A[oddIndex] % 2)\\n                swap(A, evenIndex, oddIndex);\\n            \\n            if(A[evenIndex] % 2 == 0) evenIndex += 2;\\n            if(A[oddIndex] % 2 == 1)  oddIndex -= 2;\\n        }\\n        return A;\\n    }\\n    \\n    private void swap(int[] A, int i, int j)\\n    {\\n        int temp = A[i];\\n        A[i] = A[j];\\n        A[j] = temp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public int[] sortArrayByParityII(int[] A) \\n    {\\n        int i = 0;\\n        int j = 1;\\n        \\n        while(i < A.length && j < A.length)\\n        {\\n            while(i < A.length && A[i] % 2 == 0) i += 2;\\n            while(j < A.length && A[j] % 2 == 1) j += 2;\\n            \\n            if(i < A.length && j < A.length)\\n                swap(A, i, j);\\n        }\\n        return A;\\n    }\\n    \\n    private void swap(int[] A, int i, int j)\\n    {\\n        int temp = A[i];\\n        A[i] = A[j];\\n        A[j] = temp;\\n    }\\n}\\n```\n```\\nclass Solution \\n{\\n    public int[] sortArrayByParityII(int[] A) \\n    {\\n        int evenIndex = 0;\\n        int oddIndex = A.length - 1;\\n        \\n        while(evenIndex < A.length && oddIndex > 0)\\n        {\\n            if(A[evenIndex] % 2 > A[oddIndex] % 2)\\n                swap(A, evenIndex, oddIndex);\\n            \\n            if(A[evenIndex] % 2 == 0) evenIndex += 2;\\n            if(A[oddIndex] % 2 == 1)  oddIndex -= 2;\\n        }\\n        return A;\\n    }\\n    \\n    private void swap(int[] A, int i, int j)\\n    {\\n        int temp = A[i];\\n        A[i] = A[j];\\n        A[j] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 204664,
                "title": "c-solution",
                "content": "```\\nint *sortArrayByParityII(int const *A, int ASize, int *returnSize) {\\n    int odd = 1, even = 0;\\n    int *ret = (int *) malloc(sizeof(int) * (*returnSize = ASize));\\n    for (int i = 0; i < *returnSize; ++i) {\\n        if (A[i] % 2 == 0) {\\n            ret[even] = A[i];\\n            even += 2;\\n        } else {\\n            ret[odd] = A[i];\\n            odd += 2;\\n        }\\n    }\\n    return ret;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint *sortArrayByParityII(int const *A, int ASize, int *returnSize) {\\n    int odd = 1, even = 0;\\n    int *ret = (int *) malloc(sizeof(int) * (*returnSize = ASize));\\n    for (int i = 0; i < *returnSize; ++i) {\\n        if (A[i] % 2 == 0) {\\n            ret[even] = A[i];\\n            even += 2;\\n        } else {\\n            ret[odd] = A[i];\\n            odd += 2;\\n        }\\n    }\\n    return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3733546,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        \\n        vector<int> ans(nums.size(),0);\\n        int even=0;\\n        int odd=1;\\n\\n        cout<<\"Hello\";\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] % 2==0){\\n                ans[even]=nums[i];\\n                if(even+2 <= nums.size()-1){\\n                    even+=2;\\n                }\\n                // cout<<ans[i]<<\" \";\\n            }\\n            else{\\n                ans[odd]=nums[i];\\n                if(odd+2 <= nums.size()-1){\\n                    odd+=2;\\n                }\\n                // cout<<ans[i]<<\" \";\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        \\n        vector<int> ans(nums.size(),0);\\n        int even=0;\\n        int odd=1;\\n\\n        cout<<\"Hello\";\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] % 2==0){\\n                ans[even]=nums[i];\\n                if(even+2 <= nums.size()-1){\\n                    even+=2;\\n                }\\n                // cout<<ans[i]<<\" \";\\n            }\\n            else{\\n                ans[odd]=nums[i];\\n                if(odd+2 <= nums.size()-1){\\n                    odd+=2;\\n                }\\n                // cout<<ans[i]<<\" \";\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2952911,
                "title": "python3-simple-solution-beats-99",
                "content": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n\\n        answer=[]\\n\\n        # We split nums into even entries and odd entries\\n        even = [n for n in nums if n%2 == 0]\\n        odd =  [n for n in nums if n%2 == 1]\\n\\n        # We fill answer with even and odd entries \\n        for a, b in zip(even, odd):\\n            answer.append(a)\\n            answer.append(b)\\n        \\n        return answer\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n\\n        answer=[]\\n\\n        # We split nums into even entries and odd entries\\n        even = [n for n in nums if n%2 == 0]\\n        odd =  [n for n in nums if n%2 == 1]\\n\\n        # We fill answer with even and odd entries \\n        for a, b in zip(even, odd):\\n            answer.append(a)\\n            answer.append(b)\\n        \\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2933111,
                "title": "easy-with-two-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n       \\n       /* int temp=0;\\n        int k=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n        \\n        if(i%2==0&&nums[i]%2==0||i%2!=0&&nums[i]%2!=0)\\n        {\\n            continue;\\n        }\\n        temp=i;\\n        for(int j=i+1;j<nums.length;j++)\\n        {\\n            if((i%2!=0 && nums[i]%2==0)||(i%2==0 && nums[i]%2!=0))\\n            {\\n               k= nums[temp];\\n               nums[temp]=nums[j];\\n               nums[j]=k;\\n                \\n\\n            }\\n        }\\n        }\\n\\n        return nums;\\n    }*/\\n    \\n        int i = 0, j = 1;\\n        int l = nums.length;\\n        int[] B = new int[l];\\n        for(int k = 0; k < nums.length; k++){\\n            if(nums[k]%2 == 0){\\n                B[i] = nums[k];\\n                i+=2;\\n            }else{\\n                B[j] = nums[k];\\n                j+=2;\\n            } \\n        }\\n        return B;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n       \\n       /* int temp=0;\\n        int k=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n        \\n        if(i%2==0&&nums[i]%2==0||i%2!=0&&nums[i]%2!=0)\\n        {\\n            continue;\\n        }\\n        temp=i;\\n        for(int j=i+1;j<nums.length;j++)\\n        {\\n            if((i%2!=0 && nums[i]%2==0)||(i%2==0 && nums[i]%2!=0))\\n            {\\n               k= nums[temp];\\n               nums[temp]=nums[j];\\n               nums[j]=k;\\n                \\n\\n            }\\n        }\\n        }\\n\\n        return nums;\\n    }*/\\n    \\n        int i = 0, j = 1;\\n        int l = nums.length;\\n        int[] B = new int[l];\\n        for(int k = 0; k < nums.length; k++){\\n            if(nums[k]%2 == 0){\\n                B[i] = nums[k];\\n                i+=2;\\n            }else{\\n                B[j] = nums[k];\\n                j+=2;\\n            } \\n        }\\n        return B;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2896465,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int[]ans= new int[nums.length];\\n\\t\\tint even=0;\\n        int odd=1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]%2==0){\\n                ans[even]=nums[i];\\n                even=even+2;\\n            }else{\\n                ans[odd]=nums[i];\\n                odd=odd+2;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int[]ans= new int[nums.length];\\n\\t\\tint even=0;\\n        int odd=1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]%2==0){\\n                ans[even]=nums[i];\\n                even=even+2;\\n            }else{\\n                ans[odd]=nums[i];\\n                odd=odd+2;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2655409,
                "title": "java-two-solutions-extra-space-and-in-place",
                "content": "### ***Please Upvote !!!*** **(\\u25E0\\u203F\\u25E0)**\\n##### 1. Using extra-space (stack):\\n```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        Stack<Integer> evens = new Stack<>();\\n        Stack<Integer> odds = new Stack<>();\\n\\n        for (int n : nums) {\\n            if (n % 2 == 0) evens.add(n);\\n            else odds.add(n);\\n        }\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (i % 2 == 0) nums[i] = evens.pop();\\n            else nums[i] = odds.pop();\\n        }\\n\\n        return nums;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```\\n##### 2. In-place: \\n```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int i = 0, j = 1;\\n        int n = nums.length;\\n\\n        while (i < n && j < n) {\\n            while (i < n && nums[i] % 2 == 0) i += 2;\\n            while (j < n && nums[j] % 2 == 1) j += 2;\\n\\n            if (i < n && j < n) {\\n                int temp = nums[i];\\n                nums[i] = nums[j];\\n                nums[j] = temp;\\n            }\\n        }\\n\\n        return nums;\\n    }\\n}\\n\\n// TC: O(N), SC: O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        Stack<Integer> evens = new Stack<>();\\n        Stack<Integer> odds = new Stack<>();\\n\\n        for (int n : nums) {\\n            if (n % 2 == 0) evens.add(n);\\n            else odds.add(n);\\n        }\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (i % 2 == 0) nums[i] = evens.pop();\\n            else nums[i] = odds.pop();\\n        }\\n\\n        return nums;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```\n```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int i = 0, j = 1;\\n        int n = nums.length;\\n\\n        while (i < n && j < n) {\\n            while (i < n && nums[i] % 2 == 0) i += 2;\\n            while (j < n && nums[j] % 2 == 1) j += 2;\\n\\n            if (i < n && j < n) {\\n                int temp = nums[i];\\n                nums[i] = nums[j];\\n                nums[j] = temp;\\n            }\\n        }\\n\\n        return nums;\\n    }\\n}\\n\\n// TC: O(N), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2586768,
                "title": "both-approach-optimized-brute-force-two-pointer-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n\\t\\n\\t***METHOD-1***\\n** 2 ptr --> Brute Force using additional space**\\n\\n       int odd = 1  ; \\n        int even = 0 ; \\n        vector<int>ans(nums.size());\\n        for(int i=0 ; i<nums.size();i++) {\\n            if(nums[i]&1) {\\n                ans[odd] = nums[i];\\n                odd+=2;\\n            }\\n           else if(!(nums[i]&1)) {\\n                ans[even] = nums[i];\\n                even+=2;\\n            }     \\n        }\\n        return ans;    \\n        \\n     \\t***METHOD-2***\\n   ** 2 ptr -->  optimized Approach  Without using additional space**\\n\\n    \\n        int odd = 1  ; \\n        int even = 0 ; \\n        int n = nums.size();\\n        while(odd<n and even<n){\\n            // odd element at odd pos \\n            if(nums[odd]&1) { odd+=2;}\\n        // even element at even pos \\n             else if(!(nums[even]&1)) {even+=2;    }\\n            // odd element at even position and even element at odd position \\n            else if(!(nums[odd]&1) || nums[even]&1){\\n                swap(nums[odd],nums[even]);\\n            }\\n\\n        }\\n        return nums;\\n    }\\n};\\n```\\n\\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n\\t\\n\\t***METHOD-1***\\n** 2 ptr --> Brute Force using additional space**\\n\\n       int odd = 1  ; \\n        int even = 0 ; \\n        vector<int>ans(nums.size());\\n        for(int i=0 ; i<nums.size();i++) {\\n            if(nums[i]&1) {\\n                ans[odd] = nums[i];\\n                odd+=2;\\n            }\\n           else if(!(nums[i]&1)) {\\n                ans[even] = nums[i];\\n                even+=2;\\n            }     \\n        }\\n        return ans;    \\n        \\n     \\t***METHOD-2***\\n   ** 2 ptr -->  optimized Approach  Without using additional space**\\n\\n    \\n        int odd = 1  ; \\n        int even = 0 ; \\n        int n = nums.size();\\n        while(odd<n and even<n){\\n            // odd element at odd pos \\n            if(nums[odd]&1) { odd+=2;}\\n        // even element at even pos \\n             else if(!(nums[even]&1)) {even+=2;    }\\n            // odd element at even position and even element at odd position \\n            else if(!(nums[odd]&1) || nums[even]&1){\\n                swap(nums[odd],nums[even]);\\n            }\\n\\n        }\\n        return nums;\\n    }\\n};\\n```\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2417872,
                "title": "python-simple-solution",
                "content": "```\\nresult = [0]*len(nums)\\n        even = 0\\n        odd = 1\\n        for i in nums:\\n            if i % 2 == 0:\\n                result[even] = i\\n                even += 2\\n            else:\\n                result[odd] = i\\n                odd += 2\\n        return (result)\\n```",
                "solutionTags": [],
                "code": "```\\nresult = [0]*len(nums)\\n        even = 0\\n        odd = 1\\n        for i in nums:\\n            if i % 2 == 0:\\n                result[even] = i\\n                even += 2\\n            else:\\n                result[odd] = i\\n                odd += 2\\n        return (result)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2403590,
                "title": "java-o-1-space-o-n-time-90-faster-easy-explained",
                "content": "A brief about logical approach:\\n* We have two poiters,\\n\\t* `i` at index 0 (for even indices)\\n\\t* `j` at index 1 (for odd indices)\\n* Now we check whether `i` has an `even` number,\\n\\t* if `nums[i]` is even : `i+=2` (move to next even index)\\n\\t* if `nums[i]` is odd: we check whether `j` has an `odd` number,\\n\\t\\t* if `nums[j]` is odd : `j+=2` (move to next odd index)\\n\\t\\t* if `nums[j]` is even: swap `nums[i]` and `nums[j]`\\n\\nThats it!\\n\\nIf you found it helpful upvote. And if you have any doubts or suggestions, comment them down. \\u270C\\n\\n\\n```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int i=0,j=1;\\n\\t\\t\\n        while(i<nums.length && j<nums.length){\\n            if(nums[i]%2==0) i+=2;\\n            else{\\n                if(nums[j]%2!=0) j+=2;\\n                else{\\n                    int temp = nums[i];\\n                    nums[i]=nums[j];\\n                    nums[j] = temp;\\n                }\\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int i=0,j=1;\\n\\t\\t\\n        while(i<nums.length && j<nums.length){\\n            if(nums[i]%2==0) i+=2;\\n            else{\\n                if(nums[j]%2!=0) j+=2;\\n                else{\\n                    int temp = nums[i];\\n                    nums[i]=nums[j];\\n                    nums[j] = temp;\\n                }\\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2387565,
                "title": "c-solution-easy-and-simple",
                "content": "class Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n\\t\\n        int n=nums.size();\\n        vector<int>v(n); // ans vector will be of same size as nums\\n\\t\\t\\n        int i=0; // even index\\n        int j=1; // odd index\\n\\t\\t\\n        for(int k=0; k<n; k++){\\n            if(nums[k]%2==0){\\n                v[i]=nums[k];\\n                i+=2;\\n            }\\n            else if(nums[k]%2!=0){\\n                v[j]=nums[k];\\n                j+=2;\\n            }\\n        }\\n        return v;\\n    }\\n\\t// dry run to understand best!\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n\\t\\n        int n=nums.size();\\n        vector<int>v(n); // ans vector will be of same size as nums\\n\\t\\t\\n        int i=0; // even index\\n        int j=1; // odd index\\n\\t\\t\\n        for(int k=0; k<n; k++){\\n            if(nums[k]%2==0){\\n                v[i]=nums[k];\\n                i+=2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2349723,
                "title": "100-faster-code-for-the-problem",
                "content": "class Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int result[]=new int[nums.length];\\n        int j=0,k=1;\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]%2==0)\\n            {\\n                result[j]=nums[i];\\n                j+=2;\\n            }\\n            else{\\n                \\n            result[k]=nums[i];\\n            k+=2;\\n            }\\n        }\\n        return(result);\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int result[]=new int[nums.length];\\n        int j=0,k=1;\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]%2==0)\\n            {\\n                result[j]=nums[i];\\n                j+=2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2280745,
                "title": "python-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n\\t\\t\\tnums.sort()\\n\\t\\t\\tprint(nums)\\n\\n\\t\\t\\ts=0\\n\\t\\t\\te=1\\n\\n\\t\\t\\twhile s<len(nums) and e<len(nums):\\n\\t\\t\\t\\twhile nums[s]%2==0:\\n\\t\\t\\t\\t\\ts+=2\\n\\t\\t\\t\\t\\tif s>=len(nums):\\n\\t\\t\\t\\t\\t\\treturn nums\\n\\t\\t\\t\\twhile nums[e]%2!=0:\\n\\t\\t\\t\\t\\te+=2\\n\\t\\t\\t\\t\\tif e>=len(nums):\\n\\t\\t\\t\\t\\t\\treturn nums\\n\\n\\t\\t\\t\\tif s<len(nums) and e<len(nums):\\n\\t\\t\\t\\t\\tnums[e],nums[s]=nums[s],nums[e]\\n\\t\\t\\t\\t\\ts+=2\\n\\t\\t\\t\\t\\te+=2\\n\\t\\t\\treturn nums",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n\\t\\t\\tnums.sort()\\n\\t\\t\\tprint(nums)\\n\\n\\t\\t\\ts=0\\n\\t\\t\\te=1\\n\\n\\t\\t\\twhile s<len(nums) and e<len(nums):\\n\\t\\t\\t\\twhile nums[s]%2==0:\\n\\t\\t\\t\\t\\ts+=2\\n\\t\\t\\t\\t\\tif s>=len(nums):\\n\\t\\t\\t\\t\\t\\treturn nums\\n\\t\\t\\t\\twhile nums[e]%2!=0:\\n\\t\\t\\t\\t\\te+=2\\n\\t\\t\\t\\t\\tif e>=len(nums):\\n\\t\\t\\t\\t\\t\\treturn nums\\n\\n\\t\\t\\t\\tif s<len(nums) and e<len(nums):\\n\\t\\t\\t\\t\\tnums[e],nums[s]=nums[s],nums[e]\\n\\t\\t\\t\\t\\ts+=2\\n\\t\\t\\t\\t\\te+=2\\n\\t\\t\\treturn nums",
                "codeTag": "Java"
            },
            {
                "id": 2209673,
                "title": "basic-swapping",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        \\n        for(int i = 0, j = 1; i < nums.size();){\\n            if(nums[i]%2==0)   i+=2; //for even index we are checking whether the number is even or not \\n            else if(nums[j]%2!=0)   j+=2; //here we are checking for odd index\\n            else swap(nums[i],nums[j]);// swap if both condition doesn\\'t match\\n        }\\n        return nums;\\n    }\\n};\\n```\\n\\nDon\\'t forget to like:)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        \\n        for(int i = 0, j = 1; i < nums.size();){\\n            if(nums[i]%2==0)   i+=2; //for even index we are checking whether the number is even or not \\n            else if(nums[j]%2!=0)   j+=2; //here we are checking for odd index\\n            else swap(nums[i],nums[j]);// swap if both condition doesn\\'t match\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2123940,
                "title": "simple-c-solution-one-pass",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int a=0,b=1;\\n        while (b<nums.size()&&a<nums.size()) {\\n            if (nums[a]%2==0) a+=2;\\n            else {\\n                if (nums[b]%2==0) {\\n                    swap(nums[a],nums[b]);\\n                    a+=2;\\n                    b+=2;\\n                }\\n                else b+=2;\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int a=0,b=1;\\n        while (b<nums.size()&&a<nums.size()) {\\n            if (nums[a]%2==0) a+=2;\\n            else {\\n                if (nums[b]%2==0) {\\n                    swap(nums[a],nums[b]);\\n                    a+=2;\\n                    b+=2;\\n                }\\n                else b+=2;\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2110301,
                "title": "c-easy-solution-2-pointers",
                "content": "The basic intuition is, whenever we find element at odd index as even and element at even index as odd simultaneously, we just swap them them to their original positions , else we move even and odd pointers forward.\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int evenIndex = 0 , oddIndex = 1 ; \\n        while (evenIndex < nums.size() && oddIndex < nums.size()) {\\n            if (nums[evenIndex] % 2 == 0)  evenIndex += 2 ;\\n            else if (nums[oddIndex] % 2 != 0) oddIndex += 2 ;\\n            else  swap(nums[evenIndex] , nums[oddIndex]) ; \\n        }\\n        return nums ; \\n    }\\n};\\n```\\nPlease do **upvote** if you found this helpful",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int evenIndex = 0 , oddIndex = 1 ; \\n        while (evenIndex < nums.size() && oddIndex < nums.size()) {\\n            if (nums[evenIndex] % 2 == 0)  evenIndex += 2 ;\\n            else if (nums[oddIndex] % 2 != 0) oddIndex += 2 ;\\n            else  swap(nums[evenIndex] , nums[oddIndex]) ; \\n        }\\n        return nums ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2058266,
                "title": "js-easiest",
                "content": "```\\nvar sortArrayByParityII = function(nums) {\\n    \\n    let res = new Array(nums.length) ;\\n    let e = 0, o = 1;\\n    \\n    for(i = 0; i < nums.length; i++){\\n        if(nums[i] % 2 === 0){\\n            res[e] = nums[i];\\n            e += 2\\n        }\\n        else{\\n            res[o] = nums[i];\\n            o += 2\\n        }\\n    }    \\n     return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar sortArrayByParityII = function(nums) {\\n    \\n    let res = new Array(nums.length) ;\\n    let e = 0, o = 1;\\n    \\n    for(i = 0; i < nums.length; i++){\\n        if(nums[i] % 2 === 0){\\n            res[e] = nums[i];\\n            e += 2\\n        }\\n        else{\\n            res[o] = nums[i];\\n            o += 2\\n        }\\n    }    \\n     return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2052518,
                "title": "java-o-n-complexity-with-faster-than-99-94-submission",
                "content": "```\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int even = 0 , odd = 1;\\n        while( even < nums.length && odd < nums.length) {\\n            if(nums[even] % 2 != 0) {\\n                swap(nums, even, odd);\\n                odd += 2;\\n            } else even += 2;\\n        }\\n        return nums;\\n    }\\n    \\n    private void swap(int[] A, int i, int j) {\\n        int temp = A[i];\\n        A[i] = A[j];\\n        A[j] = temp;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int even = 0 , odd = 1;\\n        while( even < nums.length && odd < nums.length) {\\n            if(nums[even] % 2 != 0) {\\n                swap(nums, even, odd);\\n                odd += 2;\\n            } else even += 2;\\n        }\\n        return nums;\\n    }\\n    \\n    private void swap(int[] A, int i, int j) {\\n        int temp = A[i];\\n        A[i] = A[j];\\n        A[j] = temp;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1945828,
                "title": "sort-array-by-parity-i-ii-c-explanation",
                "content": "**C++ solutions**\\n\\n**1. [Sort Array By Parity I](https://leetcode.com/problems/sort-array-by-parity)**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParity(vector<int>& nums) {\\n        int l = 0, r = nums.size()-1;\\n        \\n        while (l < r) {\\n            // skip even numbers from left\\n            // until an odd number is found\\n            while (l < r && nums[l] & 1 == 0) l++;\\n            // skip odd numbers from right\\n            // until an even number is found\\n            while (l < r && nums[r] & 1) r--;\\n            \\n            // now swap the numbers\\n            swap(nums[l], nums[r]);\\n            // loop until all numbers have been exhausted\\n            l++, r--;\\n        }\\n        \\n        return nums;\\n    }\\n};\\n```\\n\\n<br>\\n\\n**2. [Sort Array By Parity II](https://leetcode.com/problems/sort-array-by-parity-ii/)**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int i = 0, j = 1, n = nums.size();\\n        \\n        while (i < n && j < n) {\\n            // skip even numbers which are at even positions\\n            while (i < n && nums[i]%2 == 0) i += 2;\\n            // skip odd numbers which are at odd positions\\n            while (j < n && nums[j]%2 != 0) j += 2;\\n            \\n            // swap numbers which weren\\'t skipped\\n            // these numbers are obviously:\\n            // even at odd position & odd at even position\\n            if (i < n && j < n) swap(nums[i], nums[j]);\\n        }\\n        \\n        return nums;\\n    }\\n};\\n```\\n\\nFor both:\\nTime comlexity: **O(n)**\\nSpace complexity: **O(1)**\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParity(vector<int>& nums) {\\n        int l = 0, r = nums.size()-1;\\n        \\n        while (l < r) {\\n            // skip even numbers from left\\n            // until an odd number is found\\n            while (l < r && nums[l] & 1 == 0) l++;\\n            // skip odd numbers from right\\n            // until an even number is found\\n            while (l < r && nums[r] & 1) r--;\\n            \\n            // now swap the numbers\\n            swap(nums[l], nums[r]);\\n            // loop until all numbers have been exhausted\\n            l++, r--;\\n        }\\n        \\n        return nums;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int i = 0, j = 1, n = nums.size();\\n        \\n        while (i < n && j < n) {\\n            // skip even numbers which are at even positions\\n            while (i < n && nums[i]%2 == 0) i += 2;\\n            // skip odd numbers which are at odd positions\\n            while (j < n && nums[j]%2 != 0) j += 2;\\n            \\n            // swap numbers which weren\\'t skipped\\n            // these numbers are obviously:\\n            // even at odd position & odd at even position\\n            if (i < n && j < n) swap(nums[i], nums[j]);\\n        }\\n        \\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1929768,
                "title": "c-solution-beats-97-92-o-n-complexity",
                "content": "**922. Sort Array By Parity II**\\n\\nHere, we have considered two variables **o** and **e** for odd and even respectively, and going to increment \\nit by 2 so that the element at index i if even then we will increment **e** by 2 and if odd then increment **o** \\nby 2.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n      vector<int>v(nums.size());\\n        int o=1,e=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]%2==0)\\n            {\\n                v[e]=nums[i];\\n                e+=2;\\n            }\\n            else\\n            {\\n                v[o]=nums[i];\\n                o+=2;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/fb0273e4-5cfb-4fdc-9cbb-7767d42ca7a9_1649523099.3406916.png)\\n\\n**Please do upvote**\\uD83E\\uDD17\\n**Keep Codin\\' **\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n      vector<int>v(nums.size());\\n        int o=1,e=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]%2==0)\\n            {\\n                v[e]=nums[i];\\n                e+=2;\\n            }\\n            else\\n            {\\n                v[o]=nums[i];\\n                o+=2;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1892677,
                "title": "python-tc-o-n-sc-o-1-easy-solution-explained",
                "content": "**Please upvote if it is useful. Thanks!**\\n```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        j = 1 # j is used to check all the odd indexes\\n        \\n        # check all the even indexes with i\\n        for i in range(0, len(nums), 2):\\n            # nums[i] is odd while it should be even\\n            if nums[i] & 1:\\n                # look for the next even number in an odd index\\n                # it\\'s guaranteed to exist because we already found\\n                # ad odd number with even index\\n                while (j < len(nums)) and (nums[j] & 1):\\n                    j += 2\\n                # now swap them\\n                # by putting even numbers in positions with even indexes\\n                # we are also putting odd numbers in odd indexes as a\\n                # consequence of the swap, all in one pass\\n                nums[i], nums[j] = nums[j], nums[i]\\n        return nums\\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        j = 1 # j is used to check all the odd indexes\\n        \\n        # check all the even indexes with i\\n        for i in range(0, len(nums), 2):\\n            # nums[i] is odd while it should be even\\n            if nums[i] & 1:\\n                # look for the next even number in an odd index\\n                # it\\'s guaranteed to exist because we already found\\n                # ad odd number with even index\\n                while (j < len(nums)) and (nums[j] & 1):\\n                    j += 2\\n                # now swap them\\n                # by putting even numbers in positions with even indexes\\n                # we are also putting odd numbers in odd indexes as a\\n                # consequence of the swap, all in one pass\\n                nums[i], nums[j] = nums[j], nums[i]\\n        return nums\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1883643,
                "title": "java-in-place-solution",
                "content": "```\\n    \\n    // given array with half even and half odd nums\\n    // place even nums in even indices and odd nums in odd indices\\n    \\n    public int[] sortArrayByParityII(int[] nums) {\\n        \\n        // in a loop check if index is even or odd - this tells us whether we need to put even or odd number in that place\\n        // if correct num is in that place move to next index\\n        // if not, have a pointer move to the next correct val and swap those two and move to next index\\n        // O(1) space O(n) time\\n        \\n        int evenIndex = 0;\\n        int oddIndex = 1;\\n        \\n        while(true) {\\n            while(evenIndex < nums.length) {\\n                if(nums[evenIndex] % 2 == 0) {\\n                    evenIndex += 2;\\n                    continue;\\n                }\\n                break;\\n            }\\n\\n            while(oddIndex < nums.length) {\\n                if(nums[oddIndex] % 2 != 0) {\\n                    oddIndex += 2;\\n                    continue;\\n                }\\n                break;\\n            }\\n\\n            if(evenIndex < nums.length) { // or oddIndex doesn\\'t matter\\n                int temp = nums[evenIndex];\\n                nums[evenIndex] = nums[oddIndex];\\n                nums[oddIndex] = temp;\\n                evenIndex += 2;\\n                oddIndex += 2;\\n            } else {\\n                break;\\n            }\\n        }\\n        \\n        \\n        return nums;\\n        \\n    }",
                "solutionTags": [],
                "code": "```\\n    \\n    // given array with half even and half odd nums\\n    // place even nums in even indices and odd nums in odd indices\\n    \\n    public int[] sortArrayByParityII(int[] nums) {\\n        \\n        // in a loop check if index is even or odd - this tells us whether we need to put even or odd number in that place\\n        // if correct num is in that place move to next index\\n        // if not, have a pointer move to the next correct val and swap those two and move to next index\\n        // O(1) space O(n) time\\n        \\n        int evenIndex = 0;\\n        int oddIndex = 1;\\n        \\n        while(true) {\\n            while(evenIndex < nums.length) {\\n                if(nums[evenIndex] % 2 == 0) {\\n                    evenIndex += 2;\\n                    continue;\\n                }\\n                break;\\n            }\\n\\n            while(oddIndex < nums.length) {\\n                if(nums[oddIndex] % 2 != 0) {\\n                    oddIndex += 2;\\n                    continue;\\n                }\\n                break;\\n            }\\n\\n            if(evenIndex < nums.length) { // or oddIndex doesn\\'t matter\\n                int temp = nums[evenIndex];\\n                nums[evenIndex] = nums[oddIndex];\\n                nums[oddIndex] = temp;\\n                evenIndex += 2;\\n                oddIndex += 2;\\n            } else {\\n                break;\\n            }\\n        }\\n        \\n        \\n        return nums;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1755746,
                "title": "c-in-place-o-1-space-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int i = 0, j = 1;\\n        while(i < nums.size() and j < nums.size()) {\\n            while(i < nums.size() and nums[i]%2 == 0) i += 2;\\n            while(j < nums.size() and nums[j]%2 == 1) j += 2;\\n            if(i < nums.size() and j < nums.size()) swap(nums[i],nums[j]);\\n            i += 2; j += 2;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int i = 0, j = 1;\\n        while(i < nums.size() and j < nums.size()) {\\n            while(i < nums.size() and nums[i]%2 == 0) i += 2;\\n            while(j < nums.size() and nums[j]%2 == 1) j += 2;\\n            if(i < nums.size() and j < nums.size()) swap(nums[i],nums[j]);\\n            i += 2; j += 2;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1716736,
                "title": "simple-java-solution-using-two-index-variables-and-o-n-space-complexity",
                "content": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n\\t\\n        int even_index = 0;\\n        int odd_index = 0;\\n        \\n        int[] returned_array = new int[nums.length];\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            \\n            if(i%2 == 0){\\n                while(nums[even_index]%2 != 0){\\n                    even_index++;\\n                }\\n                \\n                returned_array[i] = nums[even_index];\\n                even_index++;\\n                \\n            } else {\\n                while(nums[odd_index]%2 == 0){\\n                    odd_index++;\\n                }\\n                \\n                returned_array[i] = nums[odd_index];\\n                odd_index++;\\n            }\\n        }\\n        \\n        return returned_array;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "class Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n\\t\\n        int even_index = 0;\\n        int odd_index = 0;\\n        \\n        int[] returned_array = new int[nums.length];\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            \\n            if(i%2 == 0){\\n                while(nums[even_index]%2 != 0){\\n                    even_index++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1694517,
                "title": "python-easy-solution-using-two-pointers-beats-90-solutions",
                "content": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        \\n        l,r=0,len(nums)-1\\n        \\n        while l<len(nums) and r>0:\\n            \\n            if nums[l]%2==0: l+=2\\n                \\n            elif nums[r]%2!=0: r-=2\\n            \\n            else:\\n                nums[l],nums[r]=nums[r],nums[l]\\n                l+=2\\n                r-=2\\n               \\n        return nums\\n     \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        \\n        l,r=0,len(nums)-1\\n        \\n        while l<len(nums) and r>0:\\n            \\n            if nums[l]%2==0: l+=2\\n                \\n            elif nums[r]%2!=0: r-=2\\n            \\n            else:\\n                nums[l],nums[r]=nums[r],nums[l]\\n                l+=2\\n                r-=2\\n               \\n        return nums\\n     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1621556,
                "title": "java-solution",
                "content": "```\\npublic int[] sortArrayByParityII(int[] nums) {\\n        \\n        int length = nums.length;\\n        int[] result = new int[length];\\n        int e = 0; //for even\\n        int o = 1; //for odd\\n        \\n        for(int num: nums) {\\n            \\n            if(num%2 == 0) {\\n                result[e] = num;\\n                e+=2;\\n\\n            }\\n            else {\\n                result[o] = num;\\n                o+=2;\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] sortArrayByParityII(int[] nums) {\\n        \\n        int length = nums.length;\\n        int[] result = new int[length];\\n        int e = 0; //for even\\n        int o = 1; //for odd\\n        \\n        for(int num: nums) {\\n            \\n            if(num%2 == 0) {\\n                result[e] = num;\\n                e+=2;\\n\\n            }\\n            else {\\n                result[o] = num;\\n                o+=2;\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1558853,
                "title": "python-simple-sloution",
                "content": "\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        a=[]\\n        b=[]\\n        c=[]\\n        for i in nums:\\n            if i%2==0:\\n                a.append(i)\\n            if i%2!=0:\\n                b.append(i)\\n        for i in range(len(a)):\\n            c.append(a[i])\\n            c.append(b[i])\\n        return c",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        a=[]\\n        b=[]\\n        c=[]\\n        for i in nums:\\n            if i%2==0:\\n                a.append(i)\\n            if i%2!=0:\\n                b.append(i)\\n        for i in range(len(a)):\\n            c.append(a[i])\\n            c.append(b[i])\\n        return c",
                "codeTag": "Python3"
            },
            {
                "id": 1538449,
                "title": "c-easiest-solution",
                "content": "class Solution {\\npublic:\\n\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> result(n);\\n        int a = 0 , b = 1;\\n        for(int i=0 ; i<n ; ++i)\\n        {\\n            if(nums[i]%2==0)\\n            {\\n                result[a] = nums[i];\\n                a += 2;\\n            }\\n            else\\n            {\\n                result[b] = nums[i];\\n                b += 2;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n**leave a like.**",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> result(n);\\n        int a = 0 , b = 1;\\n        for(int i=0 ; i<n ; ++i)\\n        {\\n            if(nums[i]%2==0)\\n            {\\n                result[a] = nums[i];\\n                a += 2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1492732,
                "title": "rust-two-pointers",
                "content": "Solution - [github](https://github.com/An7One/lc_soln_rust_leon/tree/main/src/leetcode/lvl2/lc0922)\\n\\n<b>Problem List</b>\\n#TwoPointers - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/tree/main/txt/by_technique/n_pointers/by_pointer_amount/2_pointers)\\n\\n```\\n/// @author: Leon\\n/// https://leetcode.com/problems/sort-array-by-parity-ii/\\n/// Time Complexity:    O(`len_n`)\\n/// Space Complexity:   O(1)\\nimpl Solution {\\n    pub fn sort_array_by_parity_ii(nums: Vec<i32>) -> Vec<i32> {\\n        let len_n = nums.len();\\n        let mut nums = nums;\\n        let mut idx_even: usize = 0;\\n        let mut idx_odd: usize = 1;\\n        while idx_even < len_n && idx_odd < len_n {\\n            if nums[idx_even] % 2 == 0 {\\n                idx_even += 2;\\n            }\\n            if nums[idx_odd] % 2 == 1 {\\n                idx_odd += 2;\\n            }\\n            if idx_even < len_n && idx_odd < len_n {\\n                nums.swap(idx_even, idx_odd);\\n            }\\n        }\\n        nums\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Two Pointers"
                ],
                "code": "```\\n/// @author: Leon\\n/// https://leetcode.com/problems/sort-array-by-parity-ii/\\n/// Time Complexity:    O(`len_n`)\\n/// Space Complexity:   O(1)\\nimpl Solution {\\n    pub fn sort_array_by_parity_ii(nums: Vec<i32>) -> Vec<i32> {\\n        let len_n = nums.len();\\n        let mut nums = nums;\\n        let mut idx_even: usize = 0;\\n        let mut idx_odd: usize = 1;\\n        while idx_even < len_n && idx_odd < len_n {\\n            if nums[idx_even] % 2 == 0 {\\n                idx_even += 2;\\n            }\\n            if nums[idx_odd] % 2 == 1 {\\n                idx_odd += 2;\\n            }\\n            if idx_even < len_n && idx_odd < len_n {\\n                nums.swap(idx_even, idx_odd);\\n            }\\n        }\\n        nums\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1492207,
                "title": "c-2-pointer-in-place-solution-explained-100-time-99-space",
                "content": "This problem is not too hard even when you consider operating in place (and it would be rather trivial otherwise: just creating a new array of the same size and populating it with of 2 pointers to write there in alternate order).\\n\\nIn order to solve it, we will use 3 variables:\\n* `i` and `j` will be our pointers, respectively set to `0` and `1` initially, with the goal to find odd (the former) or even value (the latter);\\n* `lmt` is going to be the limit of our search, set to be the length of our input.\\n\\nWe will then ran an infinite loop and inside it:\\n* move `i` to find the first odd value in even positions (if any such is left);\\n* move `j` to find the first even value in odd positions (if any such is left);\\n* check if we reached the end of the input and:\\n\\t* if not, we swap the values pointed by `i` and `j`;\\n\\t* otherwise, it means we are done parsing and just `break` out of the loop.\\n\\nOnce done, we can just `return` `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& ns) {\\n        // support variables\\n        int i = 0, j = 1, lmt = ns.size();\\n        // parsing ns\\n        while (true) {\\n            // moving i in even positions with odd values\\n            while (i < lmt && !(ns[i] & 1)) i += 2;\\n            // moving j in odd positions with even values\\n            while (j < lmt && (ns[j] & 1)) j += 2;\\n            // swapping if needed\\n            if (i < lmt && j < lmt) swap(ns[i], ns[j]);\\n            else break;\\n        }\\n        return ns;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& ns) {\\n        // support variables\\n        int i = 0, j = 1, lmt = ns.size();\\n        // parsing ns\\n        while (true) {\\n            // moving i in even positions with odd values\\n            while (i < lmt && !(ns[i] & 1)) i += 2;\\n            // moving j in odd positions with even values\\n            while (j < lmt && (ns[j] & 1)) j += 2;\\n            // swapping if needed\\n            if (i < lmt && j < lmt) swap(ns[i], ns[j]);\\n            else break;\\n        }\\n        return ns;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1491779,
                "title": "c-easy-solution-two-pointer-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int i = 0  , j = 1;\\n        while(i<nums.size() and j <nums.size()-1 || i<nums.size()-1 and j<nums.size())\\n        {\\n            if(nums[i]%2 == 0 and nums[j]%2==1)\\n            {\\n                i += 2;\\n                j += 2;\\n            }\\n            else if(nums[i]%2==1 and nums[j]%2==0 )\\n            {\\n                swap(nums[i],nums[j]);\\n                i += 2;\\n                j += 2;\\n            }\\n            else if(nums[i]%2==0 and nums[j]%2==0)\\n            {\\n                i += 2;\\n            }else \\n            {\\n                j += 2;\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int i = 0  , j = 1;\\n        while(i<nums.size() and j <nums.size()-1 || i<nums.size()-1 and j<nums.size())\\n        {\\n            if(nums[i]%2 == 0 and nums[j]%2==1)\\n            {\\n                i += 2;\\n                j += 2;\\n            }\\n            else if(nums[i]%2==1 and nums[j]%2==0 )\\n            {\\n                swap(nums[i],nums[j]);\\n                i += 2;\\n                j += 2;\\n            }\\n            else if(nums[i]%2==0 and nums[j]%2==0)\\n            {\\n                i += 2;\\n            }else \\n            {\\n                j += 2;\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1491589,
                "title": "2-solution-inc-in-place-c-solution-easy-to-understand",
                "content": "```\\n// Solution I - In place\\nvector<int> ans;\\n        for(int i=0; i<nums.size()-1; i++) {\\n            if(i%2==0) {\\n                if(nums[i]%2==0) continue;\\n                for(int j=i+1; j<nums.size(); j++) {\\n                    if(nums[j]%2==0) {\\n                        swap(nums[i],nums[j]);\\n                        break;\\n                    } else continue;\\n                }\\n            }\\n            else {\\n                if(nums[i]%2!=0) continue;\\n                for(int j=i+1; j<nums.size(); j++) {\\n                    if(nums[j]%2!=0) {\\n                        swap(nums[i], nums[j]);\\n                        break;\\n                    }\\n                    else continue;\\n                }\\n            }\\n        }\\n        return nums;\\n\\t\\t// Solution 2\\n\\t\\tclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        vector<int> ans;\\n        vector<int> odd, even;\\n        for(int i=0; i<nums.size(); i++) {\\n            if(nums[i]%2==0) even.push_back(nums[i]);\\n            else odd.push_back(nums[i]);\\n        }\\n        int i=0,j=0;\\n        while(i<odd.size() && j<even.size()) {\\n            if(j<even.size()) {\\n                ans.push_back(even[j]);\\n                j++;\\n            }\\n            if(i<odd.size()) {\\n                ans.push_back(odd[i]);\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// Solution I - In place\\nvector<int> ans;\\n        for(int i=0; i<nums.size()-1; i++) {\\n            if(i%2==0) {\\n                if(nums[i]%2==0) continue;\\n                for(int j=i+1; j<nums.size(); j++) {\\n                    if(nums[j]%2==0) {\\n                        swap(nums[i],nums[j]);\\n                        break;\\n                    } else continue;\\n                }\\n            }\\n            else {\\n                if(nums[i]%2!=0) continue;\\n                for(int j=i+1; j<nums.size(); j++) {\\n                    if(nums[j]%2!=0) {\\n                        swap(nums[i], nums[j]);\\n                        break;\\n                    }\\n                    else continue;\\n                }\\n            }\\n        }\\n        return nums;\\n\\t\\t// Solution 2\\n\\t\\tclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        vector<int> ans;\\n        vector<int> odd, even;\\n        for(int i=0; i<nums.size(); i++) {\\n            if(nums[i]%2==0) even.push_back(nums[i]);\\n            else odd.push_back(nums[i]);\\n        }\\n        int i=0,j=0;\\n        while(i<odd.size() && j<even.size()) {\\n            if(j<even.size()) {\\n                ans.push_back(even[j]);\\n                j++;\\n            }\\n            if(i<odd.size()) {\\n                ans.push_back(odd[i]);\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1491123,
                "title": "c-easy-solution",
                "content": "class Solution\\n{\\npublic:\\n\\n    vector<int> sortArrayByParityII(vector<int> &nums)\\n    {\\n        vector<int> v;\\n        vector<int> v1;\\n        vector<int> v2;\\n\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            if (nums[i] & 1)\\n            {\\n                v2.push_back(nums[i]);\\n            }\\n            else\\n            {\\n                v1.push_back(nums[i]);\\n            }\\n        }\\n\\n        for (int i = 0; i < nums.size() / 2; i++)\\n        {\\n            v.push_back(v1[i]);\\n            v.push_back(v2[i]);\\n        }\\n        return v;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution\\n{\\npublic:\\n\\n    vector<int> sortArrayByParityII(vector<int> &nums)\\n    {\\n        vector<int> v;\\n        vector<int> v1;\\n        vector<int> v2;\\n\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            if (nums[i] & 1)\\n            {\\n                v2.push_back(nums[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1491089,
                "title": "rust-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn sort_array_by_parity_ii(nums: Vec<i32>) -> Vec<i32> {\\n        nums.iter()\\n            .filter(|&num| num % 2 == 0)\\n            .zip(nums.iter().filter(|&num| num % 2 != 0))\\n            .flat_map(|(&even, &odd)| vec![even, odd].into_iter())\\n            .collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn sort_array_by_parity_ii(nums: Vec<i32>) -> Vec<i32> {\\n        nums.iter()\\n            .filter(|&num| num % 2 == 0)\\n            .zip(nums.iter().filter(|&num| num % 2 != 0))\\n            .flat_map(|(&even, &odd)| vec![even, odd].into_iter())\\n            .collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1491039,
                "title": "sort-array-by-parity-ii-inplace-o-n-time-c",
                "content": "explanation:\\nfor every no. there are two possibilities: either its correct on its position or not correct.\\nalso as there are equal no. of odd and even nos, so for every incorrect odd, there will be one incorrect even and vice-versa.\\n\\nSo we will just keep two pointers : one for odd positions and one for even positions.\\nIgnore those which are already at correct position.\\nSwap those which are at incorrect.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        \\n        int i=0;\\n        int j=1;\\n        \\n        while(i<nums.size() && j<nums.size())\\n        {\\n            while(i<nums.size() && nums[i]%2==0)\\n                i+=2;\\n            while(j<nums.size() && nums[j]%2==1)\\n                j+=2;\\n            \\n            if(i<nums.size() && j<nums.size())\\n            {\\n                int temp = nums[i];\\n                nums[i] = nums[j];\\n                nums[j] = temp;\\n            }\\n            \\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        \\n        int i=0;\\n        int j=1;\\n        \\n        while(i<nums.size() && j<nums.size())\\n        {\\n            while(i<nums.size() && nums[i]%2==0)\\n                i+=2;\\n            while(j<nums.size() && nums[j]%2==1)\\n                j+=2;\\n            \\n            if(i<nums.size() && j<nums.size())\\n            {\\n                int temp = nums[i];\\n                nums[i] = nums[j];\\n                nums[j] = temp;\\n            }\\n            \\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1490976,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        \\n        \\n        for(int i=0;i<nums.length;i++){\\n            \\n            if(i%2==0){\\n                if(nums[i]%2==0)continue;\\n                \\n                for(int j = i+1;j<nums.length;j++){\\n                    if(nums[j]%2==0){\\n                        int temp = nums[i];\\n                        nums[i] = nums[j];\\n                        nums[j] = temp;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            else{\\n                if(nums[i]%2!=0)continue;\\n                \\n                for(int j = i+1;j<nums.length;j++){\\n                    if(nums[j]%2!=0){\\n                        int temp = nums[i];\\n                        nums[i] = nums[j];\\n                        nums[j] = temp;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        \\n        return nums;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        \\n        \\n        for(int i=0;i<nums.length;i++){\\n            \\n            if(i%2==0){\\n                if(nums[i]%2==0)continue;\\n                \\n                for(int j = i+1;j<nums.length;j++){\\n                    if(nums[j]%2==0){\\n                        int temp = nums[i];\\n                        nums[i] = nums[j];\\n                        nums[j] = temp;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            else{\\n                if(nums[i]%2!=0)continue;\\n                \\n                for(int j = i+1;j<nums.length;j++){\\n                    if(nums[j]%2!=0){\\n                        int temp = nums[i];\\n                        nums[i] = nums[j];\\n                        nums[j] = temp;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        \\n        return nums;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1490897,
                "title": "java-one-pass-inplace",
                "content": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] n) {\\n        int e = 0,o = 1;\\n        while(e<n.length && o<n.length){\\n            while(e<n.length && n[e]%2 == 0) e += 2;\\n            while(o<n.length && n[o]%2 == 1) o += 2;\\n            \\n            if(o<n.length && e<n.length){\\n                int t = n[o];\\n                n[o] = n[e];\\n                n[e] = t;\\n                o += 2;\\n                e += 2;\\n            }\\n        }\\n        return n;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] n) {\\n        int e = 0,o = 1;\\n        while(e<n.length && o<n.length){\\n            while(e<n.length && n[e]%2 == 0) e += 2;\\n            while(o<n.length && n[o]%2 == 1) o += 2;\\n            \\n            if(o<n.length && e<n.length){\\n                int t = n[o];\\n                n[o] = n[e];\\n                n[e] = t;\\n                o += 2;\\n                e += 2;\\n            }\\n        }\\n        return n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1445385,
                "title": "simple-java-solution-o-n-time",
                "content": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int out[]=new int[nums.length];\\n        int evenIndex=0,oddIndex=1;\\n        for(int i:nums){\\n            if(i%2==1){\\n                out[oddIndex]=i;\\n                oddIndex+=2;\\n            }else{\\n                out[evenIndex]=i;\\n                evenIndex+=2;\\n            }\\n        }\\n        return out;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        int out[]=new int[nums.length];\\n        int evenIndex=0,oddIndex=1;\\n        for(int i:nums){\\n            if(i%2==1){\\n                out[oddIndex]=i;\\n                oddIndex+=2;\\n            }else{\\n                out[evenIndex]=i;\\n                evenIndex+=2;\\n            }\\n        }\\n        return out;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345921,
                "title": "c-simple-solution",
                "content": "```\\nvector<int> sortArrayByParityII(vector<int>& a) {\\n        vector<int>v1,v2;\\n        for(int i=0; i<a.size(); i++)\\n        {\\n            if(a[i]%2==0)\\n                v1.push_back(a[i]);\\n            else\\n                v2.push_back(a[i]);\\n        }\\n        vector<int>res(a.size());\\n        int k=0,j=0;\\n        for(int i=0; i<a.size(); i++)\\n        {\\n            if(i%2==0)\\n                res[i]=v1[k++];\\n            else\\n                res[i]=v2[j++];\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<int> sortArrayByParityII(vector<int>& a) {\\n        vector<int>v1,v2;\\n        for(int i=0; i<a.size(); i++)\\n        {\\n            if(a[i]%2==0)\\n                v1.push_back(a[i]);\\n            else\\n                v2.push_back(a[i]);\\n        }\\n        vector<int>res(a.size());\\n        int k=0,j=0;\\n        for(int i=0; i<a.size(); i++)\\n        {\\n            if(i%2==0)\\n                res[i]=v1[k++];\\n            else\\n                res[i]=v2[j++];\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1291804,
                "title": "in-place-python-easy-100-faster-o-n-time-o-1-space",
                "content": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        i = 0\\n        j = 1\\n        n = len(nums)\\n        while i < n and j < n:\\n            if nums[i]%2 == 0:\\n                i += 2\\n            elif nums[j]%2 != 0:\\n                j += 2\\n            else:\\n                nums[i], nums[j] = nums[j], nums[i]\\n        return nums\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        i = 0\\n        j = 1\\n        n = len(nums)\\n        while i < n and j < n:\\n            if nums[i]%2 == 0:\\n                i += 2\\n            elif nums[j]%2 != 0:\\n                j += 2\\n            else:\\n                nums[i], nums[j] = nums[j], nums[i]\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206155,
                "title": "javascript-inplace-and-using-space-90-faster",
                "content": "**Please upvote if you find this solution useful**\\n\\n**In place**\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar sortArrayByParityII = function(nums) {\\n  let even = 0;\\n    let odd = nums.length - 1;\\n    while(even < nums.length && odd >= 0){\\n        \\n        if(nums[even] % 2==0 && nums[odd] % 2 !== 0){\\n            even = even + 2;\\n            odd = odd - 2\\n        }else if(nums[even] % 2 !== 0 && nums[odd] % 2 == 0){\\n            [ nums[even] , nums[odd] ] = [ nums[odd] , nums[even] ]\\n        }else if(nums[even] % 2 ==0 ){\\n            even = even+2;\\n        }else{\\n            odd = odd - 2;\\n        }\\n    }\\n    return nums\\n};\\n```\\n\\n\\n**Using space**\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar sortArrayByParityII = function(nums) {\\n    var arr = new Array(nums.length);\\n    var even  =0;\\n    var odd = 1;\\n    for(let i=0; i<nums.length; i++){\\n        if(nums[i] % 2 === 0){\\n            arr[even] = nums[i];\\n            even +=2;\\n        }else{\\n            arr[odd] = nums[i]\\n            odd +=2\\n        }\\n    }\\n    return arr\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar sortArrayByParityII = function(nums) {\\n  let even = 0;\\n    let odd = nums.length - 1;\\n    while(even < nums.length && odd >= 0){\\n        \\n        if(nums[even] % 2==0 && nums[odd] % 2 !== 0){\\n            even = even + 2;\\n            odd = odd - 2\\n        }else if(nums[even] % 2 !== 0 && nums[odd] % 2 == 0){\\n            [ nums[even] , nums[odd] ] = [ nums[odd] , nums[even] ]\\n        }else if(nums[even] % 2 ==0 ){\\n            even = even+2;\\n        }else{\\n            odd = odd - 2;\\n        }\\n    }\\n    return nums\\n};\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar sortArrayByParityII = function(nums) {\\n    var arr = new Array(nums.length);\\n    var even  =0;\\n    var odd = 1;\\n    for(let i=0; i<nums.length; i++){\\n        if(nums[i] % 2 === 0){\\n            arr[even] = nums[i];\\n            even +=2;\\n        }else{\\n            arr[odd] = nums[i]\\n            odd +=2\\n        }\\n    }\\n    return arr\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1126788,
                "title": "javascript-clean-solution",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar sortArrayByParityII = function(nums) {\\n    const [odds, evens] = [nums.filter(n => n%2===1), nums.filter(n => n%2 === 0)]\\n    const retArr = []\\n    for(let i = 0; i<nums.length; i++){\\n       i%2 ? retArr.push(odds.pop()) : retArr.push(evens.pop())\\n    }\\n    return retArr\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar sortArrayByParityII = function(nums) {\\n    const [odds, evens] = [nums.filter(n => n%2===1), nums.filter(n => n%2 === 0)]\\n    const retArr = []\\n    for(let i = 0; i<nums.length; i++){\\n       i%2 ? retArr.push(odds.pop()) : retArr.push(evens.pop())\\n    }\\n    return retArr\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1095123,
                "title": "python-using-slicing",
                "content": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        N = len(nums)\\n        ans = [0] * N\\n        ans[::2] = (x for x in nums if x % 2 == 0)\\n        ans[1::2] = (x for x in nums if x % 2 == 1)\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        N = len(nums)\\n        ans = [0] * N\\n        ans[::2] = (x for x in nums if x % 2 == 0)\\n        ans[1::2] = (x for x in nums if x % 2 == 1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1050619,
                "title": "python-sorted-runtime-73-memory-78",
                "content": "Do upvote it if you liked it\\n\\n\\n\\n\\t\\tA = sorted(A)\\n        \\n\\t\\todd = []\\n        even = []\\n\\t\\t\\n        for num in A:\\n            if num % 2 == 0:\\n                even.append(num)\\n            else:\\n                odd.append(num)\\n                \\n        A[0 : : 2], A[1 : : 2]  = even, odd\\n        \\n        return A",
                "solutionTags": [
                    "Python3",
                    "Sorting"
                ],
                "code": "Do upvote it if you liked it\\n\\n\\n\\n\\t\\tA = sorted(A)\\n        \\n\\t\\todd = []\\n        even = []\\n\\t\\t\\n        for num in A:\\n            if num % 2 == 0:\\n                even.append(num)\\n            else:\\n                odd.append(num)\\n                \\n        A[0 : : 2], A[1 : : 2]  = even, odd\\n        \\n        return A",
                "codeTag": "Unknown"
            },
            {
                "id": 971488,
                "title": "javascript-solution",
                "content": "\\tvar sortArrayByParityII = function(A) {\\n    \\n    let odd = [];\\n    let even = []\\n    \\n    for(let i = 0 ; i < A.length; i++){\\n        \\n        if(A[i] % 2 !== 0){\\n            odd.push(A[i])\\n        }else{\\n            even.push(A[i])\\n        }\\n        \\n    }\\n    \\n    let arr = [];\\n    \\n    for(let i = 0 ; i < odd.length ; i++){\\n    \\n        arr.push(even[i]);\\n        arr.push(odd[i])\\n      \\n    }\\n\\n    \\n    return arr\\n    \\n    \\n\\t};",
                "solutionTags": [],
                "code": "\\tvar sortArrayByParityII = function(A) {\\n    \\n    let odd = [];\\n    let even = []\\n    \\n    for(let i = 0 ; i < A.length; i++){\\n        \\n        if(A[i] % 2 !== 0){\\n            odd.push(A[i])\\n        }else{\\n            even.push(A[i])\\n        }\\n        \\n    }\\n    \\n    let arr = [];\\n    \\n    for(let i = 0 ; i < odd.length ; i++){\\n    \\n        arr.push(even[i]);\\n        arr.push(odd[i])\\n      \\n    }\\n\\n    \\n    return arr\\n    \\n    \\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 797027,
                "title": "c-easy-and-fast",
                "content": "**Please upvote my solution if you like it**\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n\\n    vector<int> sortArrayByParityII(vector<int>& A) {\\n        int n=A.size();\\n        vector<int>ans(n);\\n        int ec=0,oc=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(A[i]%2==0)\\n            {\\n                ans[ec]=A[i];\\n                ec+=2;\\n            }\\n            else\\n            {\\n                ans[oc]=A[i];\\n                oc+=2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<int> sortArrayByParityII(vector<int>& A) {\\n        int n=A.size();\\n        vector<int>ans(n);\\n        int ec=0,oc=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(A[i]%2==0)\\n            {\\n                ans[ec]=A[i];\\n                ec+=2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 764082,
                "title": "c-o-n-solution",
                "content": "```\\nint* sortArrayByParityII(int* A, int ASize, int* returnSize){\\n    *returnSize = ASize;\\n    int odd = 1;\\n    int even = 0;\\n    int* arr = malloc(sizeof(int)*ASize);\\n    for (int i=0; i < ASize; i++)\\n    {\\n        if (A[i] % 2 == 0)\\n        {\\n            arr[even] = A[i];\\n            even +=2;\\n        }\\n        else\\n        {\\n            arr[odd] = A[i];\\n            odd +=2;\\n        }\\n    }\\n    return arr;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint* sortArrayByParityII(int* A, int ASize, int* returnSize){\\n    *returnSize = ASize;\\n    int odd = 1;\\n    int even = 0;\\n    int* arr = malloc(sizeof(int)*ASize);\\n    for (int i=0; i < ASize; i++)\\n    {\\n        if (A[i] % 2 == 0)\\n        {\\n            arr[even] = A[i];\\n            even +=2;\\n        }\\n        else\\n        {\\n            arr[odd] = A[i];\\n            odd +=2;\\n        }\\n    }\\n    return arr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 755487,
                "title": "c-single-pass-inplace-o-n-97-runtime-without-extra-space",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& A) {\\n    int i=0;\\n    int j=1;\\n    while(i<A.size() && j<A.size()){\\n        if(A[i]%2!=0 && A[j]%2==0){\\n            swap(A[i],A[j]);\\n            i=i+2;\\n            j=j+2;\\n            continue;\\n        }\\n        if(A[i]%2==0){\\n            i=i+2;\\n        }\\n        if(A[j]%2==1){\\n            j=j+2;\\n        }\\n    }\\n        return A;\\n    }\\n};```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& A) {\\n    int i=0;\\n    int j=1;\\n    while(i<A.size() && j<A.size()){\\n        if(A[i]%2!=0 && A[j]%2==0){\\n            swap(A[i],A[j]);\\n            i=i+2;\\n            j=j+2;\\n            continue;\\n        }\\n        if(A[i]%2==0){\\n            i=i+2;\\n        }\\n        if(A[j]%2==1){\\n            j=j+2;\\n        }\\n    }\\n        return A;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 727212,
                "title": "python-3-explanation",
                "content": "* Initialise an empty array `parityArray` of the same length as `A`.\\n* Keep track of two pointers, one `even` and one `odd`, that will be incremented when a new `num` is inserted into `parityArray`.\\n```\\nclass Solution:\\n    def sortArrayByParityII(self, A: List[int]) -> List[int]:\\n        parityArray = [None] * len(A)\\n        even, odd = 0, 1\\n        \\n        for num in A:\\n            if num % 2 == 0:\\n                parityArray[even] = num\\n                even += 2\\n            else:\\n                parityArray[odd] = num\\n                odd += 2\\n            \\n        return parityArray\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, A: List[int]) -> List[int]:\\n        parityArray = [None] * len(A)\\n        even, odd = 0, 1\\n        \\n        for num in A:\\n            if num % 2 == 0:\\n                parityArray[even] = num\\n                even += 2\\n            else:\\n                parityArray[odd] = num\\n                odd += 2\\n            \\n        return parityArray\\n```",
                "codeTag": "Java"
            },
            {
                "id": 592182,
                "title": "python-3-faster-than-97-98",
                "content": "```\\nclass Solution:\\n    def sortArrayByParityII(self, A: List[int]) -> List[int]:\\n        e = 0\\n        o = 1\\n        op = []\\n        for a in A:\\n            if a%2==0:\\n                op.insert(e,a)\\n                e+= 2\\n            else:\\n                op.insert(o,a)\\n                o+= 2\\n        return op\\n```\\nDo upvote it if you liked it :)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, A: List[int]) -> List[int]:\\n        e = 0\\n        o = 1\\n        op = []\\n        for a in A:\\n            if a%2==0:\\n                op.insert(e,a)\\n                e+= 2\\n            else:\\n                op.insert(o,a)\\n                o+= 2\\n        return op\\n```",
                "codeTag": "Java"
            },
            {
                "id": 576924,
                "title": "o-n-time-with-two-pointers-javascript",
                "content": "```\\nvar sortArrayByParityII = (A) => {\\n    let oddP = 1;\\n    \\n    const swap = (i, j) => {\\n        let buf = A[i];\\n        A[i] = A[j];\\n        A[j] = buf;\\n    }\\n    \\n    for (let i = 0 ; i < A.length; i += 2) {\\n        if (A[i] & 1) {\\n            while (A[oddP] & 1) {\\n                oddP += 2;\\n            }\\n            swap(i, oddP);\\n        }\\n    }\\n    \\n    return A;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nvar sortArrayByParityII = (A) => {\\n    let oddP = 1;\\n    \\n    const swap = (i, j) => {\\n        let buf = A[i];\\n        A[i] = A[j];\\n        A[j] = buf;\\n    }\\n    \\n    for (let i = 0 ; i < A.length; i += 2) {\\n        if (A[i] & 1) {\\n            while (A[oddP] & 1) {\\n                oddP += 2;\\n            }\\n            swap(i, oddP);\\n        }\\n    }\\n    \\n    return A;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 520221,
                "title": "very-simple-in-place-c-solution-68ms-100",
                "content": "See also my copying solution here: https://leetcode.com/problems/sort-array-by-parity-ii/discuss/520235/C%2B%2B-Copy-out-to-odd-or-even-addresses-68ms100\\n# Algorithm\\n\\nThis is a very simple modify in-place approach.\\nThe overall flow is to step 2 index counters through the input array. One indexes odd locations and the other indexes even locations, so their paths interleave and never touch the same location.\\n* Advance even indexes by 2 until an odd value is hit\\n* Advance odd indexes by 2 until an even value is hit\\n* Swap the elements at these indexes to restore the desired state of even values at even indexes and odd values at odd indexes.\\n\\n# Code\\n```\\n        static vector<int> sortArrayByParityII(vector<int> A)\\n        {\\n            const unsigned len = A.size();\\n            unsigned odd = 1u;\\n            unsigned even = 0u;\\n            while(even < len)\\n            {\\n                // Skip even numbers at even indexes:\\n                while(even < len  && (A[even] & 1u) == 0u){\\n                    even += 2u;\\n                }\\n                // Skip odd numbers at odd indexes:\\n                while((odd < len) && (A[odd]  & 1u)){\\n                    odd += 2u;\\n                }\\n                // Either we hit the end of the input or an odd number at an even address\\n                // and an even number at an odd address. If the latter, swap them:\\n                if(even < len){\\n                    swap(A[even], A[odd]);\\n                }\\n                // We always increment so that as little code as possible is inside\\n                // the branch above even though logically the increment belongs inside\\n                // it:\\n                even += 2u;\\n                odd += 2u;\\n            }\\n            return A;\\n        }\\n```\\n\\n# Results\\n\\n> Runtime: 68 ms, faster than 100.00% of C++ online submissions for Sort Array By Parity II.\\n> Memory Usage: 12 MB, less than 25.00% of C++ online submissions for Sort Array By Parity II.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n        static vector<int> sortArrayByParityII(vector<int> A)\\n        {\\n            const unsigned len = A.size();\\n            unsigned odd = 1u;\\n            unsigned even = 0u;\\n            while(even < len)\\n            {\\n                // Skip even numbers at even indexes:\\n                while(even < len  && (A[even] & 1u) == 0u){\\n                    even += 2u;\\n                }\\n                // Skip odd numbers at odd indexes:\\n                while((odd < len) && (A[odd]  & 1u)){\\n                    odd += 2u;\\n                }\\n                // Either we hit the end of the input or an odd number at an even address\\n                // and an even number at an odd address. If the latter, swap them:\\n                if(even < len){\\n                    swap(A[even], A[odd]);\\n                }\\n                // We always increment so that as little code as possible is inside\\n                // the branch above even though logically the increment belongs inside\\n                // it:\\n                even += 2u;\\n                odd += 2u;\\n            }\\n            return A;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 515483,
                "title": "cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& A) {\\n        int i=0,j=0;\\n        while (i< A.size() && j < A.size()){\\n            while (i< A.size() ){\\n                if (i%2==0 && A[i]%2==1) break;\\n                else i++;\\n            } \\n            while (j< A.size()){\\n                if (j%2==1 && A[j]%2==0) break;\\n                else j++;\\n            }\\n            if (i<A.size() && j<A.size()){\\n                int temp = A[i];\\n                A[i] = A[j];\\n                A[j] = temp;\\n            }\\n        }\\n        return A;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& A) {\\n        int i=0,j=0;\\n        while (i< A.size() && j < A.size()){\\n            while (i< A.size() ){\\n                if (i%2==0 && A[i]%2==1) break;\\n                else i++;\\n            } \\n            while (j< A.size()){\\n                if (j%2==1 && A[j]%2==0) break;\\n                else j++;\\n            }\\n            if (i<A.size() && j<A.size()){\\n                int temp = A[i];\\n                A[i] = A[j];\\n                A[j] = temp;\\n            }\\n        }\\n        return A;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 475103,
                "title": "python-o-n-sol-based-on-two-pointers-run-time-95-with-explanation",
                "content": "Python O( n ) sol. based on two-pointers\\n\\n```\\nclass Solution:\\n    def sortArrayByParityII(self, A: List[int]) -> List[int]:\\n        \\n        size = len(A)\\n        \\n        sorted_array = [0]*size\\n        \\n        # two pointers for even numbers, as well as odd numbers, respectively.\\n        even_index, odd_index = 0, 1\\n        \\n        for x in A:\\n            \\n            if x & 1:\\n                # odd numbers\\n                sorted_array[odd_index] = x\\n                odd_index += 2\\n            else:\\n                # even numbers\\n                sorted_array[even_index] = x\\n                even_index += 2\\n                \\n        return sorted_array\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, A: List[int]) -> List[int]:\\n        \\n        size = len(A)\\n        \\n        sorted_array = [0]*size\\n        \\n        # two pointers for even numbers, as well as odd numbers, respectively.\\n        even_index, odd_index = 0, 1\\n        \\n        for x in A:\\n            \\n            if x & 1:\\n                # odd numbers\\n                sorted_array[odd_index] = x\\n                odd_index += 2\\n            else:\\n                # even numbers\\n                sorted_array[even_index] = x\\n                even_index += 2\\n                \\n        return sorted_array\\n```",
                "codeTag": "Java"
            },
            {
                "id": 459869,
                "title": "simplest-c-code",
                "content": "```\\nvector<int> sortArrayByParityII(vector<int>& A) {\\n\\tint oddIndex = 1, evenIndex = 0;\\n\\tvector<int> res(A.size());\\n\\tfor (int i = 0; i < A.size(); i++)\\n\\t{\\n\\t\\tif (A[i] % 2 == 0)\\n\\t\\t{\\n\\t\\t\\tres[evenIndex] = A[i];\\n\\t\\t\\tevenIndex += 2;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tres[oddIndex] = A[i];\\n\\t\\t\\toddIndex += 2;\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<int> sortArrayByParityII(vector<int>& A) {\\n\\tint oddIndex = 1, evenIndex = 0;\\n\\tvector<int> res(A.size());\\n\\tfor (int i = 0; i < A.size(); i++)\\n\\t{\\n\\t\\tif (A[i] % 2 == 0)\\n\\t\\t{\\n\\t\\t\\tres[evenIndex] = A[i];\\n\\t\\t\\tevenIndex += 2;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tres[oddIndex] = A[i];\\n\\t\\t\\toddIndex += 2;\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 410428,
                "title": "python-3-o-n-time-and-o-n-space-using-stack",
                "content": "```\\n    def sortArrayByParityII(self, A: List[int]) -> List[int]:\\n        d = {0:[],1:[]}\\n        for i in A:\\n            d[i%2].append(i)\\n        r= []\\n        for _ in range(0,len(A)//2):\\n            r.append(d[0].pop())\\n            r.append(d[1].pop())\\n        return r\\n```",
                "solutionTags": [],
                "code": "```\\n    def sortArrayByParityII(self, A: List[int]) -> List[int]:\\n        d = {0:[],1:[]}\\n        for i in A:\\n            d[i%2].append(i)\\n        r= []\\n        for _ in range(0,len(A)//2):\\n            r.append(d[0].pop())\\n            r.append(d[1].pop())\\n        return r\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 383747,
                "title": "rust-8ms-o-n-time-o-1-space",
                "content": "```\\nimpl Solution {\\n    pub fn sort_array_by_parity_ii(a: Vec<i32>) -> Vec<i32> {\\n        let mut even_ptr = 0;\\n        let mut odd_ptr = 1;\\n        let size = a.len();\\n        let mut res = a.clone();\\n        \\n        while even_ptr < size && odd_ptr < size {\\n            if a[even_ptr] % 2 == 0 {\\n                even_ptr += 2;\\n            } else if a[odd_ptr] % 2 != 0 {\\n                odd_ptr += 2;\\n            } else {\\n                res[even_ptr] = a[odd_ptr];\\n                res[odd_ptr] = a[even_ptr];\\n                \\n                even_ptr += 2;\\n                odd_ptr += 2;\\n            }\\n        }\\n        \\n        res\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn sort_array_by_parity_ii(a: Vec<i32>) -> Vec<i32> {\\n        let mut even_ptr = 0;\\n        let mut odd_ptr = 1;\\n        let size = a.len();\\n        let mut res = a.clone();\\n        \\n        while even_ptr < size && odd_ptr < size {\\n            if a[even_ptr] % 2 == 0 {\\n                even_ptr += 2;\\n            } else if a[odd_ptr] % 2 != 0 {\\n                odd_ptr += 2;\\n            } else {\\n                res[even_ptr] = a[odd_ptr];\\n                res[odd_ptr] = a[even_ptr];\\n                \\n                even_ptr += 2;\\n                odd_ptr += 2;\\n            }\\n        }\\n        \\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 265141,
                "title": "java-beats-99-2ms-quick-sort",
                "content": "```\\npublic int[] sortArrayByParityII(int[] array) {\\n    int len = 0;\\n    if(array == null || ((len = array.length) & 1) == 1){\\n        return null;\\n    }\\n    int even = 0;\\n    int odd = len - 1;\\n    while(true){\\n        while(even < len && (array[even] & 1) == 0){\\n            even += 2;\\n        }\\n        if(even == len){\\n            break;\\n        }\\n        while(odd > -1 && (array[odd] & 1) == 1){\\n            odd -= 2;\\n        }\\n        if(odd == -1){\\n            break;\\n        }\\n        swap(array, even, odd);\\n    }\\n    return array;\\n}\\n private void swap(int[] array, int i, int j){\\n    int temp = array[i];\\n    array[i] = array[j];\\n    array[j] = temp;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] sortArrayByParityII(int[] array) {\\n    int len = 0;\\n    if(array == null || ((len = array.length) & 1) == 1){\\n        return null;\\n    }\\n    int even = 0;\\n    int odd = len - 1;\\n    while(true){\\n        while(even < len && (array[even] & 1) == 0){\\n            even += 2;\\n        }\\n        if(even == len){\\n            break;\\n        }\\n        while(odd > -1 && (array[odd] & 1) == 1){\\n            odd -= 2;\\n        }\\n        if(odd == -1){\\n            break;\\n        }\\n        swap(array, even, odd);\\n    }\\n    return array;\\n}\\n private void swap(int[] array, int i, int j){\\n    int temp = array[i];\\n    array[i] = array[j];\\n    array[j] = temp;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 255898,
                "title": "go-golang-o-n-in-place-beat-100",
                "content": "```\\nfunc sortArrayByParityII(A []int) []int {\\n\\tfor i, j := 0, 1; i< len(A); i+=2{\\n\\t\\tif A[i]&1 == 0 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tfor ;A[j]&1 != 0; j += 2 {}\\n\\t\\tA[i], A[j] = A[j], A[i]\\n\\t}\\n\\treturn A\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc sortArrayByParityII(A []int) []int {\\n\\tfor i, j := 0, 1; i< len(A); i+=2{\\n\\t\\tif A[i]&1 == 0 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tfor ;A[j]&1 != 0; j += 2 {}\\n\\t\\tA[i], A[j] = A[j], A[i]\\n\\t}\\n\\treturn A\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 255048,
                "title": "python-two-pointer-922",
                "content": "### 922. Sort Array By Parity II\\n\\n#### Two Pointer\\nTime: O(N) | Space: O(1)\\n\\nOdd\\u6307\\u9488\\u7269\\u7406\\u610F\\u4E49\\uFF1A\\u505C\\u7559\\u5728A[odd] % 2 \\u662F\\u5076\\u6570\\u7684\\u4F4D\\u7F6E\\uFF0C\\u7B49\\u5F85\\u4EA4\\u6362\\nEven\\u6307\\u9488\\u7269\\u7406\\u610F\\u4E49\\uFF1A\\u505C\\u7559\\u5728A[odd] % 2 \\u662F\\u57FA\\u6570\\u7684\\u4F4D\\u7F6E\\uFF0C\\u7B49\\u5F85\\u4EA4\\u6362\\n\\n\\u5F53\\u5185\\u7F6E\\u4E24\\u4E2AWhile Loop\\u8D70\\u5B8C\\uFF0C\\u4E14\\u4E24\\u4E2A\\u6307\\u9488\\u90FD\\u6709\\u505C\\u7559\\uFF0C\\u8BF4\\u660E\\u4ED6\\u4EEC\\u5BF9\\u5E94\\u7684Value\\u53EF\\u4EE5\\u88AB\\u5151\\u6362\\uFF0CSwap\\u5373\\u53EF\\u3002\\n\\n```python\\nclass Solution(object):\\n    def sortArrayByParityII(self, A):\\n        odd, even = 1 , 0\\n        size = len(A)\\n        \\n        while odd < size and even < size:\\n            while odd < size and A[odd] % 2 == 1: \\n                odd += 2\\n            while even < size and A[even] % 2 == 0: \\n                even += 2\\n            if odd < size and even < size:\\n                A[odd], A[even] = A[even], A[odd]\\n                odd += 2 ; even += 2  # Optional Line\\n        return A\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def sortArrayByParityII(self, A):\\n        odd, even = 1 , 0\\n        size = len(A)\\n        \\n        while odd < size and even < size:\\n            while odd < size and A[odd] % 2 == 1: \\n                odd += 2\\n            while even < size and A[even] % 2 == 0: \\n                even += 2\\n            if odd < size and even < size:\\n                A[odd], A[even] = A[even], A[odd]\\n                odd += 2 ; even += 2  # Optional Line\\n        return A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 247428,
                "title": "java-simple-solution-beats-100-4ms",
                "content": "I am using 2 pointers corresponding to the even and odd indices. \\n```\\npublic int[] sortArrayByParityII(int[] A) {\\n\\tif(A.length<2)\\n\\t\\treturn A;\\n\\tint oddPointer = 1, evenPointer = 0;\\n\\tint result[] = new int[A.length];\\n\\tfor(int i=0;i<A.length;i++)\\n\\t{\\n\\t\\tif(A[i]%2==0)\\n\\t\\t{\\n\\t\\t\\tresult[evenPointer] = A[i];\\n\\t\\t\\tevenPointer+=2;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tresult[oddPointer] = A[i];\\n\\t\\t\\toddPointer+=2;\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] sortArrayByParityII(int[] A) {\\n\\tif(A.length<2)\\n\\t\\treturn A;\\n\\tint oddPointer = 1, evenPointer = 0;\\n\\tint result[] = new int[A.length];\\n\\tfor(int i=0;i<A.length;i++)\\n\\t{\\n\\t\\tif(A[i]%2==0)\\n\\t\\t{\\n\\t\\t\\tresult[evenPointer] = A[i];\\n\\t\\t\\tevenPointer+=2;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tresult[oddPointer] = A[i];\\n\\t\\t\\toddPointer+=2;\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 230388,
                "title": "python-one-pass-in-place-two-pointers-o-n-time-o-1-memory",
                "content": "```python\\ndef sortArrayByParityII(self, A): \\n    odd, even, n = 1, 0, len(A)\\n    while odd < n and even < n:\\n        if A[odd] % 2 == 0 and A[even] % 2:\\n            A[odd], A[even] = A[even], A[odd]\\n        if A[odd] % 2 == 1: odd += 2\\n        if A[even] % 2 == 0: even += 2\\n    return A\\n```\\n\\nInspired by awice\\'s solution to Sort Array By Parity.",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```python\\ndef sortArrayByParityII(self, A): \\n    odd, even, n = 1, 0, len(A)\\n    while odd < n and even < n:\\n        if A[odd] % 2 == 0 and A[even] % 2:\\n            A[odd], A[even] = A[even], A[odd]\\n        if A[odd] % 2 == 1: odd += 2\\n        if A[even] % 2 == 0: even += 2\\n    return A\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 209017,
                "title": "java-easy-understand-solution",
                "content": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] A) {\\n        int[] result = new int[A.length];\\n        List<Integer> evens = new ArrayList<Integer>();\\n        List<Integer> odds = new ArrayList<Integer>();\\n        for(int i = 0; i < A.length; i++) {\\n            if(A[i] % 2 == 0) {\\n                evens.add(A[i]);\\n            } else {\\n                odds.add(A[i]);\\n            }\\n        }\\n        \\n        for(int i = 0; i < A.length; i += 2) {\\n            result[i] = evens.get(i / 2);\\n        }\\n        \\n        for(int i = 1; i < A.length; i += 2) {\\n            result[i] = odds.get(i / 2);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] A) {\\n        int[] result = new int[A.length];\\n        List<Integer> evens = new ArrayList<Integer>();\\n        List<Integer> odds = new ArrayList<Integer>();\\n        for(int i = 0; i < A.length; i++) {\\n            if(A[i] % 2 == 0) {\\n                evens.add(A[i]);\\n            } else {\\n                odds.add(A[i]);\\n            }\\n        }\\n        \\n        for(int i = 0; i < A.length; i += 2) {\\n            result[i] = evens.get(i / 2);\\n        }\\n        \\n        for(int i = 1; i < A.length; i += 2) {\\n            result[i] = odds.get(i / 2);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 203920,
                "title": "java-5ms-99-09",
                "content": "```\\n int [] res = new int[A.length];\\n        int even = 0,odd = 1;\\n        for (int i = 0;i < A.length;i++) {\\n            if (A[i]%2==0){\\n                res[even]=A[i];\\n                even += 2;\\n            } else {\\n                res[odd]=A[i];\\n                odd += 2;\\n            }\\n        }\\n        return res;",
                "solutionTags": [],
                "code": "```\\n int [] res = new int[A.length];\\n        int even = 0,odd = 1;\\n        for (int i = 0;i < A.length;i++) {\\n            if (A[i]%2==0){\\n                res[even]=A[i];\\n                even += 2;\\n            } else {\\n                res[odd]=A[i];\\n                odd += 2;\\n            }\\n        }\\n        return res;",
                "codeTag": "Unknown"
            },
            {
                "id": 203083,
                "title": "ruby-beats-100",
                "content": "```\\n# @param {Integer[]} a\\n# @return {Integer[]}\\ndef sort_array_by_parity_ii(arr)\\n  e,o = 0,1\\n  newarr = []\\n  arr.each do |i| \\n    if i % 2 == 0\\n      newarr[e] = i\\n      e+=2\\n    else \\n      newarr[o] = i \\n      o += 2\\n    end\\n  end\\n  newarr  \\nend\\n```",
                "solutionTags": [],
                "code": "```\\n# @param {Integer[]} a\\n# @return {Integer[]}\\ndef sort_array_by_parity_ii(arr)\\n  e,o = 0,1\\n  newarr = []\\n  arr.each do |i| \\n    if i % 2 == 0\\n      newarr[e] = i\\n      e+=2\\n    else \\n      newarr[o] = i \\n      o += 2\\n    end\\n  end\\n  newarr  \\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 182806,
                "title": "kotlin-solution",
                "content": "```\\nclass Solution {\\n    fun sortArrayByParityII(A: IntArray): IntArray {\\n        val even = A.filter { it % 2 == 0 }\\n        val odd = A.filter { it % 2 == 1 }\\n        return even.zip(odd).flatMap { listOf(it.first, it.second) }.toIntArray()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun sortArrayByParityII(A: IntArray): IntArray {\\n        val even = A.filter { it % 2 == 0 }\\n        val odd = A.filter { it % 2 == 1 }\\n        return even.zip(odd).flatMap { listOf(it.first, it.second) }.toIntArray()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4027701,
                "title": "easy-java-solution",
                "content": "class Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n     \\n       int n=nums.length;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n        \\n        if(i%2==0 && nums[i]%2!=0)\\n        {\\n                for(int j=i+1;j<n;j++)\\n                {\\n                    if(nums[j]%2==0)\\n                    {\\n                        int temp=nums[i];\\n                        nums[i]=nums[j];\\n                        nums[j]=temp;\\n                        break;\\n                }\\n            }\\n        }\\n            \\n        if(i%2==1 && nums[i]%2!=1)\\n        {\\n            {\\n                for(int j=i+1;j<n;j++)\\n                {\\n                    if(nums[j]%2==1)\\n                    {\\n                        int temp=nums[i];\\n                        nums[i]=nums[j];\\n                        nums[j]=temp;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        }\\n        return nums;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n     \\n       int n=nums.length;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n        \\n        if(i%2==0 && nums[i]%2!=0)\\n        {\\n                for(int j=i+1;j<n;j++)\\n                {\\n                    if(nums[j]%2==0)\\n                    {\\n                        int temp=nums[i];\\n                        nums[i]=nums[j];\\n                        nums[j]=temp;\\n                        break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3658073,
                "title": "java-0ms-runtime-99-faster-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        \\n        int o = 1;  \\n        int e = 0;\\n        \\n        int[] result = new int[nums.length];\\n        \\n        for(int i : nums){\\n            if(i % 2 == 0){\\n                result[e] = i;\\n                e += 2;\\n            }else{\\n                result[o] = i;\\n                o += 2;       \\n            } \\n        }\\n\\n        return result;\\n\\n    }\\n    // boolean odd(int n, int i){\\n    //     return n % 2 != 0 || i % 2 != 0;\\n    // }\\n    // boolean even(int n, int i){\\n    //     return n % 2 == 0 || i % 2 == 0;\\n    // }\\n    // int odd(int[] arr, int idx){\\n    //     for(int i = idx; i < arr.length; i++)\\n    //         if(i % 2 != 0 && arr[i] % 2 != 0)\\n    //          return i;\\n\\n    //     return -1;\\n    // }\\n    // int even(int[] arr, int idx){\\n    //     for(int i = idx; i < arr.length; i++)\\n    //         if(i % 2 == 0 && arr[i] % 2 == 0)\\n    //          return i;\\n             \\n    //     return -1;\\n    // }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n        \\n        int o = 1;  \\n        int e = 0;\\n        \\n        int[] result = new int[nums.length];\\n        \\n        for(int i : nums){\\n            if(i % 2 == 0){\\n                result[e] = i;\\n                e += 2;\\n            }else{\\n                result[o] = i;\\n                o += 2;       \\n            } \\n        }\\n\\n        return result;\\n\\n    }\\n    // boolean odd(int n, int i){\\n    //     return n % 2 != 0 || i % 2 != 0;\\n    // }\\n    // boolean even(int n, int i){\\n    //     return n % 2 == 0 || i % 2 == 0;\\n    // }\\n    // int odd(int[] arr, int idx){\\n    //     for(int i = idx; i < arr.length; i++)\\n    //         if(i % 2 != 0 && arr[i] % 2 != 0)\\n    //          return i;\\n\\n    //     return -1;\\n    // }\\n    // int even(int[] arr, int idx){\\n    //     for(int i = idx; i < arr.length; i++)\\n    //         if(i % 2 == 0 && arr[i] % 2 == 0)\\n    //          return i;\\n             \\n    //     return -1;\\n    // }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531705,
                "title": "c-o-1-easy-approach",
                "content": "Here is my c++ code for thsi problem.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity:$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int i=0, j=1;\\n        while(i<nums.size() && j<nums.size()){\\n            if(!(nums[i]&1)){i+=2;}\\n            else if(nums[j]&1){j+=2;}\\n            else{\\n                swap(nums[i], nums[j]);\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int i=0, j=1;\\n        while(i<nums.size() && j<nums.size()){\\n            if(!(nums[i]&1)){i+=2;}\\n            else if(nums[j]&1){j+=2;}\\n            else{\\n                swap(nums[i], nums[j]);\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3354227,
                "title": "simple-c-code-easy-understanding",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        vector<int>even;\\n        vector<int>odd;\\n        vector<int>v;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]%2==0) even.push_back(nums[i]);\\n            else odd.push_back(nums[i]);\\n        }\\n        int k=0;\\n        int l=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i%2==0) \\n            {\\n                v.push_back(even[k]);\\n                k++;\\n            }\\n            else\\n            {\\n                v.push_back(odd[l]);\\n                l++;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        vector<int>even;\\n        vector<int>odd;\\n        vector<int>v;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]%2==0) even.push_back(nums[i]);\\n            else odd.push_back(nums[i]);\\n        }\\n        int k=0;\\n        int l=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i%2==0) \\n            {\\n                v.push_back(even[k]);\\n                k++;\\n            }\\n            else\\n            {\\n                v.push_back(odd[l]);\\n                l++;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3334621,
                "title": "c-2-pointer-approch-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) \\n    {\\n       int i=0,j=nums.size()-1;\\n       while(i<nums.size()) \\n       {\\n           while(i<nums.size()&&nums[i]%2==0)\\n           {\\n            i+=2;\\n           }\\n           if(i==nums.size())\\n           break;\\n           while(j>=0&&nums[j]%2==1)\\n           {\\n            j-=2;\\n           }\\n           swap(nums[i],nums[j]);\\n       }\\n       return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) \\n    {\\n       int i=0,j=nums.size()-1;\\n       while(i<nums.size()) \\n       {\\n           while(i<nums.size()&&nums[i]%2==0)\\n           {\\n            i+=2;\\n           }\\n           if(i==nums.size())\\n           break;\\n           while(j>=0&&nums[j]%2==1)\\n           {\\n            j-=2;\\n           }\\n           swap(nums[i],nums[j]);\\n       }\\n       return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3324326,
                "title": "sort-array-by-parity-ii-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        vector<int> ans;\\n        int i, j=0, k=1;\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            ans.push_back(0);\\n        }\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i]%2==0)\\n            {\\n                ans[j] = nums[i];\\n                j += 2;\\n            }\\n            else\\n            {\\n                ans[k] = nums[i];\\n                k += 2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        vector<int> ans;\\n        int i, j=0, k=1;\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            ans.push_back(0);\\n        }\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i]%2==0)\\n            {\\n                ans[j] = nums[i];\\n                j += 2;\\n            }\\n            else\\n            {\\n                ans[k] = nums[i];\\n                k += 2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3166647,
                "title": "simple-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) \\n    {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]%2==0)\\n            {\\n                swap(nums[i],nums[count]);\\n                count++;\\n            }\\n            \\n        }\\n        \\n       int j=nums.size()-2;\\n        for(int i=0;i<nums.size()/2;i++)\\n        {\\n            if(i%2!=0)\\n            {\\n                swap(nums[i],nums[j]);\\n                j-=2;\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) \\n    {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]%2==0)\\n            {\\n                swap(nums[i],nums[count]);\\n                count++;\\n            }\\n            \\n        }\\n        \\n       int j=nums.size()-2;\\n        for(int i=0;i<nums.size()/2;i++)\\n        {\\n            if(i%2!=0)\\n            {\\n                swap(nums[i],nums[j]);\\n                j-=2;\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158910,
                "title": "parity-done-easily",
                "content": "i hope you like the solution,if any doubt feel free to comment :)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        vector<int>odd;\\n        vector<int>even;\\n        int e=0,o=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]%2==0)\\n            even.push_back(nums[i]);\\n            else\\n            odd.push_back(nums[i]);\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            if(i%2==0)\\n            {\\n                nums[i]=even[e];\\n                e++;\\n            }\\n            else if(i%2!=0)\\n            {\\n                nums[i]=odd[o];\\n                o++;\\n            }\\n\\n        }\\n        \\n\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        vector<int>odd;\\n        vector<int>even;\\n        int e=0,o=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]%2==0)\\n            even.push_back(nums[i]);\\n            else\\n            odd.push_back(nums[i]);\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            if(i%2==0)\\n            {\\n                nums[i]=even[e];\\n                e++;\\n            }\\n            else if(i%2!=0)\\n            {\\n                nums[i]=odd[o];\\n                o++;\\n            }\\n\\n        }\\n        \\n\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944868,
                "title": "beats-99-92-11ms-o-n",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int n=nums.size(),i,ev=0,od=1;\\n        vector<int> result(n,1);\\n        for(i=0;i<n;i++){\\n            if(nums[i]%2==0){\\n                result[ev]=nums[i];\\n                ev=ev+2;\\n            }\\n            else{\\n                result[od]=nums[i];\\n                od=od+2;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int n=nums.size(),i,ev=0,od=1;\\n        vector<int> result(n,1);\\n        for(i=0;i<n;i++){\\n            if(nums[i]%2==0){\\n                result[ev]=nums[i];\\n                ev=ev+2;\\n            }\\n            else{\\n                result[od]=nums[i];\\n                od=od+2;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2657326,
                "title": "python-easy-solution-in-o-n-time-complexity",
                "content": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        a=[]\\n        b=[]\\n        for i in range(len(nums)):\\n            if nums[i]%2==0:\\n                a.append(nums[i])\\n            else:\\n                b.append(nums[i])\\n        j=0\\n        for i in range(0,len(nums),2):\\n            nums[i]=a[j]\\n            nums[i+1]=b[j]\\n            j+=1\\n        return nums\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        a=[]\\n        b=[]\\n        for i in range(len(nums)):\\n            if nums[i]%2==0:\\n                a.append(nums[i])\\n            else:\\n                b.append(nums[i])\\n        j=0\\n        for i in range(0,len(nums),2):\\n            nums[i]=a[j]\\n            nums[i+1]=b[j]\\n            j+=1\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2636042,
                "title": "two-pointers-one-for-left-and-one-for-right-one-pass",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& a) {\\n        \\n        int n  = a.size();\\n        int l = 0;\\n        int r = n-1;\\n        int sa, sb;\\n        sa = sb = -1;\\n        while(l<n && r>=0)\\n        {\\n            while(l<n && r>=0 && (l%2 ==0 && a[l]%2 == 0) || l%2)\\n            {\\n                l++;  \\n            }\\n            \\n            if(l<n && r>=0 && (l%2 ==0 && a[l]%2 != 0))\\n            {\\n                sa = l;\\n            }\\n            \\n            \\n            while(l<n && r>=0 && (r%2 && a[r]%2) || r%2==0)\\n            {\\n                r--;\\n            }\\n            if(l<n && r>=0 && (r%2 && a[r]%2 == 0))\\n            {\\n                sb = r;\\n            }\\n            \\n            if(sa >=0 && sa < n && sb>=0 && sb< n)\\n            {\\n                swap(a[sa] , a[sb]);\\n                sa = sb = -1;\\n                l++;\\n                r--;\\n            }    \\n            \\n        }\\n        \\n        return a;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& a) {\\n        \\n        int n  = a.size();\\n        int l = 0;\\n        int r = n-1;\\n        int sa, sb;\\n        sa = sb = -1;\\n        while(l<n && r>=0)\\n        {\\n            while(l<n && r>=0 && (l%2 ==0 && a[l]%2 == 0) || l%2)\\n            {\\n                l++;  \\n            }\\n            \\n            if(l<n && r>=0 && (l%2 ==0 && a[l]%2 != 0))\\n            {\\n                sa = l;\\n            }\\n            \\n            \\n            while(l<n && r>=0 && (r%2 && a[r]%2) || r%2==0)\\n            {\\n                r--;\\n            }\\n            if(l<n && r>=0 && (r%2 && a[r]%2 == 0))\\n            {\\n                sb = r;\\n            }\\n            \\n            if(sa >=0 && sa < n && sb>=0 && sb< n)\\n            {\\n                swap(a[sa] , a[sb]);\\n                sa = sb = -1;\\n                l++;\\n                r--;\\n            }    \\n            \\n        }\\n        \\n        return a;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2618009,
                "title": "two-pointers-217-ms",
                "content": "![image](https://assets.leetcode.com/users/images/193c8f75-84fc-4083-932f-a0e85e9ddf5d_1664021649.5232708.png)\\n\\n```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        even = 0\\n        odd = 1\\n        while (odd < n or even <n):\\n            while odd < n and nums[odd] % 2:\\n                odd += 2\\n            while even < n and not nums[even] % 2:\\n                even += 2\\n            if even < n and odd < n:\\n                nums[even], nums[odd] = nums[odd], nums[even]\\n        return nums\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        even = 0\\n        odd = 1\\n        while (odd < n or even <n):\\n            while odd < n and nums[odd] % 2:\\n                odd += 2\\n            while even < n and not nums[even] % 2:\\n                even += 2\\n            if even < n and odd < n:\\n                nums[even], nums[odd] = nums[odd], nums[even]\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2609225,
                "title": "c-two-clean-in-place-approaches-with-explanation",
                "content": "**1st Approach: Two Pointers**\\nThe idea behind the first approach is to to use two pointers starting from 0 and 1 respectively.\\n1. If the value in the even pointer is even then no need to swap, just increment it by 2.\\n2. Same applies for the odd value and pointer.\\n3. If those conditions aren\\'t true, then swap the values to set them in the correct position.\\n\\n**Complexity Analysis**\\nTime Complexity: `O(n)` where `n` is the size of the array.\\nSpace Complexity: `O(1)`.\\n```\\nvector<int> sortArrayByParityII(vector<int>& nums) {\\n    int i = 0, j = 1, n = nums.size();\\n    while(i < n && j < n) {\\n        if(nums[i] % 2 == 0)\\n            i += 2;\\n        else if(nums[j] % 2 != 0)\\n            j += 2;\\n        else {\\n            swap(nums[i], nums[j]);\\n            i += 2;\\n            j += 2;\\n        }\\n    }\\n    return nums;\\n}\\n```\\n\\n**2nd Approach: Partitioning and Sorting**\\nThis key of this approach is to split the array into two sorted parts. The preprocessed array should look like the following <kbd>a = {e<sub>1</sub>, e<sub>2</sub>, ..., e<sub>n/2</sub>, o<sub>1</sub>, o<sub>2</sub>, ..., o<sub>n/2</sub>}</kbd>.\\n1. Partition the array with even numbers.\\n2. Sort the array in-place based on the partitioning iterator.\\n3. Now, the array is split into even then odd numbers respectively.\\n4. Only swap the values to their corresponding position.\\n\\n**Complexity Analysis**\\nTime Complexity: `O(n)` where `n` is the size of the array.\\nSpace Complexity: `O(1)`.\\n\\n```\\nvoid sortByParity(vector<int>& nums) {\\n    auto itr = partition(nums.begin(), nums.end(), [](const int val) {\\n        return val % 2 == 0;\\n    });\\n    sort(itr, nums.end());\\n}\\n\\nvector<int> sortArrayByParityII_2(vector<int>& nums) {\\n    sortByParity(nums);\\n    int i = 1, j = nums.size() / 2;\\n    while(i < j && j < nums.size()) {\\n        swap(nums[i], nums[j]);\\n        i += 2;\\n        ++j;\\n    }\\n    return nums;\\n}\\n```\\n\\n**Please upvote if you found this helpful.**\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Array",
                    "Iterator"
                ],
                "code": "```\\nvector<int> sortArrayByParityII(vector<int>& nums) {\\n    int i = 0, j = 1, n = nums.size();\\n    while(i < n && j < n) {\\n        if(nums[i] % 2 == 0)\\n            i += 2;\\n        else if(nums[j] % 2 != 0)\\n            j += 2;\\n        else {\\n            swap(nums[i], nums[j]);\\n            i += 2;\\n            j += 2;\\n        }\\n    }\\n    return nums;\\n}\\n```\n```\\nvoid sortByParity(vector<int>& nums) {\\n    auto itr = partition(nums.begin(), nums.end(), [](const int val) {\\n        return val % 2 == 0;\\n    });\\n    sort(itr, nums.end());\\n}\\n\\nvector<int> sortArrayByParityII_2(vector<int>& nums) {\\n    sortByParity(nums);\\n    int i = 1, j = nums.size() / 2;\\n    while(i < j && j < nums.size()) {\\n        swap(nums[i], nums[j]);\\n        i += 2;\\n        ++j;\\n    }\\n    return nums;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2594685,
                "title": "python-solution-runtime-263-ms-memory-usage-16-7-mb",
                "content": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        \\n        arr = [0] * len(nums)\\n        even, odd = 0,  1\\n        \\n        for num in nums:\\n            if num % 2 == 0:\\n                arr[even] = num\\n                even += 2\\n            else:\\n                arr[odd] = num\\n                odd += 2\\n        \\n        return arr\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        \\n        arr = [0] * len(nums)\\n        even, odd = 0,  1\\n        \\n        for num in nums:\\n            if num % 2 == 0:\\n                arr[even] = num\\n                even += 2\\n            else:\\n                arr[odd] = num\\n                odd += 2\\n        \\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2586921,
                "title": "easy-python-solution",
                "content": "**Please upvote \\uD83D\\uDC4D**\\n```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        odd = [x for x in nums if x%2!=0]\\n        even = [x for x in nums if x%2==0]\\n        \\n        nums = []\\n        for x,y in zip(odd,even):\\n            nums.append(y)\\n            nums.append(x)\\n        return nums\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def sortArrayByParityII(self, nums: List[int]) -> List[int]:\\n        odd = [x for x in nums if x%2!=0]\\n        even = [x for x in nums if x%2==0]\\n        \\n        nums = []\\n        for x,y in zip(odd,even):\\n            nums.append(y)\\n            nums.append(x)\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2578925,
                "title": "js-simple-solution-o-n",
                "content": "```\\nvar sortArrayByParityII = function(nums) {\\n    const output = new Array(nums.length);\\n    let cursorOdd = 1;\\n    let cursorEven = 0;\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i]%2) {\\n            output[cursorOdd] = nums[i];\\n            cursorOdd+=2;\\n        } else {\\n            output[cursorEven] = nums[i];\\n            cursorEven+=2;\\n        }\\n    }\\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar sortArrayByParityII = function(nums) {\\n    const output = new Array(nums.length);\\n    let cursorOdd = 1;\\n    let cursorEven = 0;\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i]%2) {\\n            output[cursorOdd] = nums[i];\\n            cursorOdd+=2;\\n        } else {\\n            output[cursorEven] = nums[i];\\n            cursorEven+=2;\\n        }\\n    }\\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2512918,
                "title": "c-cool-ans",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int j = 1;\\n        int n = nums.size();\\n        for(int i = 0; i < n ; i+=2){// even\\n            if(nums[i] % 2 != 0){\\n                while(nums[i] % 2 != 0){\\n                    swap(nums[i] , nums[j]);\\n                    j+=2;\\n                }\\n            }\\n        }\\n        return nums;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int j = 1;\\n        int n = nums.size();\\n        for(int i = 0; i < n ; i+=2){// even\\n            if(nums[i] % 2 != 0){\\n                while(nums[i] % 2 != 0){\\n                    swap(nums[i] , nums[j]);\\n                    j+=2;\\n                }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1860513,
                "content": [
                    {
                        "username": "NAMANNIMBLE",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        vector<int>ans;\\n\\n        for(int i = 0 ; i < nums.size() ; i+=2){\\n            if(i%2 == 0){\\n                ans.push_back(nums[i]);\\n            }\\n        }\\n        \\n        for(int j = 1 ; j < nums.size() ; j+=2){\\n            if(j%2 == 1){\\n                ans.push_back(nums[j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nwhats wrong in my code , ??? its failing on some test case like [3,4]"
                    },
                    {
                        "username": "vishnu_0220",
                        "content": "INPUT : [3,4]\\nnums.size() ==> 2\\n==>For the first loop i = 0; i % 2 == 0 which tends to be \"True\"\\ni. nums[i] i.e 3 will be pushed to stack\\nii. i will be 2\\niii. exit from the loop\\n\\n==>For the second loop i = 1; i % 2 == 1 which tends to be \"True\"\\ni. nums[i] i.e 4 will be pushed to stack\\nii. i will be 3\\niii. exit from the loop\\n\\nand then you are returning the same input\\n\\n\\nTry the below code... It is implemented in cpp\\n\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int even = 0;   // even index\\n        int odd = 1;    // odd index\\n        vector <int> v(nums.size(),0);\\n        int index = 0;\\n        for( int i = 0; i < nums.size(); i++)\\n        {\\n            if(nums[i] % 2 == 0)\\n            {\\n                v[even] = nums[i];\\n                even+=2;\\n            }\\n            else\\n            {\\n                v[odd] = nums[i];\\n                odd+=2;\\n            }\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "Examples should be more clear !!"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "What u want to discuss??? "
                    },
                    {
                        "username": "brandon0458",
                        "content": "I am unsure why when input is [3, 4] that the output of [3, 4] is incorrect? "
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "indexes does not start with 1s, they start with 0s, and 0 is even, so [3,4] is incorrect, but [4,3] is correct"
                    },
                    {
                        "username": "wf5432",
                        "content": "The first index is even and the second is odd, so the numbers must also be even and odd, so [4, 3]."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "// How to reduce it time complexcity\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n      int left =0, right=nums.length-1;\\n      while(left<right){\\n               if(left%2==0 && right%2!=0 && nums[left]%2==0 && nums[right]%2!=0)\\n               {\\n                   left++; \\n                   right--;\\n               }\\n               if(left%2 !=0 && right%2==0 && nums[left]%2==0 && nums[right]%2!=0)\\n               {\\n                   swap(nums,left,right);\\n                   left++; \\n                   right--;\\n               }\\n           }\\n           return nums;\\n       }\\n    private void swap(int [] arr ,int left , int right){\\n        int temp = arr[left]; \\n            arr[left] = arr[right]; \\n            arr[right]=temp;\\n    }\\n}"
                    },
                    {
                        "username": "bunshu",
                        "content": "bruh TLE \\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "TLE \\nif 1st element is odd then it will stuck in the loop\\n "
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "Please, render it: no one wants to read it."
                    }
                ]
            },
            {
                "id": 2038925,
                "content": [
                    {
                        "username": "NAMANNIMBLE",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        vector<int>ans;\\n\\n        for(int i = 0 ; i < nums.size() ; i+=2){\\n            if(i%2 == 0){\\n                ans.push_back(nums[i]);\\n            }\\n        }\\n        \\n        for(int j = 1 ; j < nums.size() ; j+=2){\\n            if(j%2 == 1){\\n                ans.push_back(nums[j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nwhats wrong in my code , ??? its failing on some test case like [3,4]"
                    },
                    {
                        "username": "vishnu_0220",
                        "content": "INPUT : [3,4]\\nnums.size() ==> 2\\n==>For the first loop i = 0; i % 2 == 0 which tends to be \"True\"\\ni. nums[i] i.e 3 will be pushed to stack\\nii. i will be 2\\niii. exit from the loop\\n\\n==>For the second loop i = 1; i % 2 == 1 which tends to be \"True\"\\ni. nums[i] i.e 4 will be pushed to stack\\nii. i will be 3\\niii. exit from the loop\\n\\nand then you are returning the same input\\n\\n\\nTry the below code... It is implemented in cpp\\n\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int even = 0;   // even index\\n        int odd = 1;    // odd index\\n        vector <int> v(nums.size(),0);\\n        int index = 0;\\n        for( int i = 0; i < nums.size(); i++)\\n        {\\n            if(nums[i] % 2 == 0)\\n            {\\n                v[even] = nums[i];\\n                even+=2;\\n            }\\n            else\\n            {\\n                v[odd] = nums[i];\\n                odd+=2;\\n            }\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "Examples should be more clear !!"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "What u want to discuss??? "
                    },
                    {
                        "username": "brandon0458",
                        "content": "I am unsure why when input is [3, 4] that the output of [3, 4] is incorrect? "
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "indexes does not start with 1s, they start with 0s, and 0 is even, so [3,4] is incorrect, but [4,3] is correct"
                    },
                    {
                        "username": "wf5432",
                        "content": "The first index is even and the second is odd, so the numbers must also be even and odd, so [4, 3]."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "// How to reduce it time complexcity\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n      int left =0, right=nums.length-1;\\n      while(left<right){\\n               if(left%2==0 && right%2!=0 && nums[left]%2==0 && nums[right]%2!=0)\\n               {\\n                   left++; \\n                   right--;\\n               }\\n               if(left%2 !=0 && right%2==0 && nums[left]%2==0 && nums[right]%2!=0)\\n               {\\n                   swap(nums,left,right);\\n                   left++; \\n                   right--;\\n               }\\n           }\\n           return nums;\\n       }\\n    private void swap(int [] arr ,int left , int right){\\n        int temp = arr[left]; \\n            arr[left] = arr[right]; \\n            arr[right]=temp;\\n    }\\n}"
                    },
                    {
                        "username": "bunshu",
                        "content": "bruh TLE \\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "TLE \\nif 1st element is odd then it will stuck in the loop\\n "
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "Please, render it: no one wants to read it."
                    }
                ]
            },
            {
                "id": 2035838,
                "content": [
                    {
                        "username": "NAMANNIMBLE",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        vector<int>ans;\\n\\n        for(int i = 0 ; i < nums.size() ; i+=2){\\n            if(i%2 == 0){\\n                ans.push_back(nums[i]);\\n            }\\n        }\\n        \\n        for(int j = 1 ; j < nums.size() ; j+=2){\\n            if(j%2 == 1){\\n                ans.push_back(nums[j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nwhats wrong in my code , ??? its failing on some test case like [3,4]"
                    },
                    {
                        "username": "vishnu_0220",
                        "content": "INPUT : [3,4]\\nnums.size() ==> 2\\n==>For the first loop i = 0; i % 2 == 0 which tends to be \"True\"\\ni. nums[i] i.e 3 will be pushed to stack\\nii. i will be 2\\niii. exit from the loop\\n\\n==>For the second loop i = 1; i % 2 == 1 which tends to be \"True\"\\ni. nums[i] i.e 4 will be pushed to stack\\nii. i will be 3\\niii. exit from the loop\\n\\nand then you are returning the same input\\n\\n\\nTry the below code... It is implemented in cpp\\n\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int even = 0;   // even index\\n        int odd = 1;    // odd index\\n        vector <int> v(nums.size(),0);\\n        int index = 0;\\n        for( int i = 0; i < nums.size(); i++)\\n        {\\n            if(nums[i] % 2 == 0)\\n            {\\n                v[even] = nums[i];\\n                even+=2;\\n            }\\n            else\\n            {\\n                v[odd] = nums[i];\\n                odd+=2;\\n            }\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "Examples should be more clear !!"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "What u want to discuss??? "
                    },
                    {
                        "username": "brandon0458",
                        "content": "I am unsure why when input is [3, 4] that the output of [3, 4] is incorrect? "
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "indexes does not start with 1s, they start with 0s, and 0 is even, so [3,4] is incorrect, but [4,3] is correct"
                    },
                    {
                        "username": "wf5432",
                        "content": "The first index is even and the second is odd, so the numbers must also be even and odd, so [4, 3]."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "// How to reduce it time complexcity\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n      int left =0, right=nums.length-1;\\n      while(left<right){\\n               if(left%2==0 && right%2!=0 && nums[left]%2==0 && nums[right]%2!=0)\\n               {\\n                   left++; \\n                   right--;\\n               }\\n               if(left%2 !=0 && right%2==0 && nums[left]%2==0 && nums[right]%2!=0)\\n               {\\n                   swap(nums,left,right);\\n                   left++; \\n                   right--;\\n               }\\n           }\\n           return nums;\\n       }\\n    private void swap(int [] arr ,int left , int right){\\n        int temp = arr[left]; \\n            arr[left] = arr[right]; \\n            arr[right]=temp;\\n    }\\n}"
                    },
                    {
                        "username": "bunshu",
                        "content": "bruh TLE \\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "TLE \\nif 1st element is odd then it will stuck in the loop\\n "
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "Please, render it: no one wants to read it."
                    }
                ]
            },
            {
                "id": 1937791,
                "content": [
                    {
                        "username": "NAMANNIMBLE",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        vector<int>ans;\\n\\n        for(int i = 0 ; i < nums.size() ; i+=2){\\n            if(i%2 == 0){\\n                ans.push_back(nums[i]);\\n            }\\n        }\\n        \\n        for(int j = 1 ; j < nums.size() ; j+=2){\\n            if(j%2 == 1){\\n                ans.push_back(nums[j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nwhats wrong in my code , ??? its failing on some test case like [3,4]"
                    },
                    {
                        "username": "vishnu_0220",
                        "content": "INPUT : [3,4]\\nnums.size() ==> 2\\n==>For the first loop i = 0; i % 2 == 0 which tends to be \"True\"\\ni. nums[i] i.e 3 will be pushed to stack\\nii. i will be 2\\niii. exit from the loop\\n\\n==>For the second loop i = 1; i % 2 == 1 which tends to be \"True\"\\ni. nums[i] i.e 4 will be pushed to stack\\nii. i will be 3\\niii. exit from the loop\\n\\nand then you are returning the same input\\n\\n\\nTry the below code... It is implemented in cpp\\n\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int even = 0;   // even index\\n        int odd = 1;    // odd index\\n        vector <int> v(nums.size(),0);\\n        int index = 0;\\n        for( int i = 0; i < nums.size(); i++)\\n        {\\n            if(nums[i] % 2 == 0)\\n            {\\n                v[even] = nums[i];\\n                even+=2;\\n            }\\n            else\\n            {\\n                v[odd] = nums[i];\\n                odd+=2;\\n            }\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "Examples should be more clear !!"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "What u want to discuss??? "
                    },
                    {
                        "username": "brandon0458",
                        "content": "I am unsure why when input is [3, 4] that the output of [3, 4] is incorrect? "
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "indexes does not start with 1s, they start with 0s, and 0 is even, so [3,4] is incorrect, but [4,3] is correct"
                    },
                    {
                        "username": "wf5432",
                        "content": "The first index is even and the second is odd, so the numbers must also be even and odd, so [4, 3]."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "// How to reduce it time complexcity\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n      int left =0, right=nums.length-1;\\n      while(left<right){\\n               if(left%2==0 && right%2!=0 && nums[left]%2==0 && nums[right]%2!=0)\\n               {\\n                   left++; \\n                   right--;\\n               }\\n               if(left%2 !=0 && right%2==0 && nums[left]%2==0 && nums[right]%2!=0)\\n               {\\n                   swap(nums,left,right);\\n                   left++; \\n                   right--;\\n               }\\n           }\\n           return nums;\\n       }\\n    private void swap(int [] arr ,int left , int right){\\n        int temp = arr[left]; \\n            arr[left] = arr[right]; \\n            arr[right]=temp;\\n    }\\n}"
                    },
                    {
                        "username": "bunshu",
                        "content": "bruh TLE \\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "TLE \\nif 1st element is odd then it will stuck in the loop\\n "
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "Please, render it: no one wants to read it."
                    }
                ]
            },
            {
                "id": 1700145,
                "content": [
                    {
                        "username": "NAMANNIMBLE",
                        "content": " `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        vector<int>ans;\\n\\n        for(int i = 0 ; i < nums.size() ; i+=2){\\n            if(i%2 == 0){\\n                ans.push_back(nums[i]);\\n            }\\n        }\\n        \\n        for(int j = 1 ; j < nums.size() ; j+=2){\\n            if(j%2 == 1){\\n                ans.push_back(nums[j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nwhats wrong in my code , ??? its failing on some test case like [3,4]"
                    },
                    {
                        "username": "vishnu_0220",
                        "content": "INPUT : [3,4]\\nnums.size() ==> 2\\n==>For the first loop i = 0; i % 2 == 0 which tends to be \"True\"\\ni. nums[i] i.e 3 will be pushed to stack\\nii. i will be 2\\niii. exit from the loop\\n\\n==>For the second loop i = 1; i % 2 == 1 which tends to be \"True\"\\ni. nums[i] i.e 4 will be pushed to stack\\nii. i will be 3\\niii. exit from the loop\\n\\nand then you are returning the same input\\n\\n\\nTry the below code... It is implemented in cpp\\n\\nclass Solution {\\npublic:\\n    vector<int> sortArrayByParityII(vector<int>& nums) {\\n        int even = 0;   // even index\\n        int odd = 1;    // odd index\\n        vector <int> v(nums.size(),0);\\n        int index = 0;\\n        for( int i = 0; i < nums.size(); i++)\\n        {\\n            if(nums[i] % 2 == 0)\\n            {\\n                v[even] = nums[i];\\n                even+=2;\\n            }\\n            else\\n            {\\n                v[odd] = nums[i];\\n                odd+=2;\\n            }\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "RajuBudhoju",
                        "content": "Examples should be more clear !!"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "What u want to discuss??? "
                    },
                    {
                        "username": "brandon0458",
                        "content": "I am unsure why when input is [3, 4] that the output of [3, 4] is incorrect? "
                    },
                    {
                        "username": "Yixiu_Hugh",
                        "content": "indexes does not start with 1s, they start with 0s, and 0 is even, so [3,4] is incorrect, but [4,3] is correct"
                    },
                    {
                        "username": "wf5432",
                        "content": "The first index is even and the second is odd, so the numbers must also be even and odd, so [4, 3]."
                    },
                    {
                        "username": "niteshkumar61725",
                        "content": "// How to reduce it time complexcity\\nclass Solution {\\n    public int[] sortArrayByParityII(int[] nums) {\\n      int left =0, right=nums.length-1;\\n      while(left<right){\\n               if(left%2==0 && right%2!=0 && nums[left]%2==0 && nums[right]%2!=0)\\n               {\\n                   left++; \\n                   right--;\\n               }\\n               if(left%2 !=0 && right%2==0 && nums[left]%2==0 && nums[right]%2!=0)\\n               {\\n                   swap(nums,left,right);\\n                   left++; \\n                   right--;\\n               }\\n           }\\n           return nums;\\n       }\\n    private void swap(int [] arr ,int left , int right){\\n        int temp = arr[left]; \\n            arr[left] = arr[right]; \\n            arr[right]=temp;\\n    }\\n}"
                    },
                    {
                        "username": "bunshu",
                        "content": "bruh TLE \\uD83D\\uDC80\\uD83D\\uDC80"
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "TLE \\nif 1st element is odd then it will stuck in the loop\\n "
                    },
                    {
                        "username": "Sergei_Gusev",
                        "content": "Please, render it: no one wants to read it."
                    }
                ]
            }
        ]
    }
]