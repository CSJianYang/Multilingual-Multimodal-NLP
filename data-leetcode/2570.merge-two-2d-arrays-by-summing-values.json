[
    {
        "title": "Merge Two 2D Arrays by Summing Values",
        "question_content": "You are given two 2D integer arrays nums1 and nums2.\n\n\tnums1[i] = [idi, vali]&nbsp;indicate that the number with the id idi has a value equal to vali.\n\tnums2[i] = [idi, vali]&nbsp;indicate that the number with the id idi has a value equal to vali.\n\nEach array contains unique ids and is sorted in ascending order by id.\nMerge the two arrays into one array that is sorted in ascending order by id, respecting the following conditions:\n\n\tOnly ids that appear in at least one of the two arrays should be included in the resulting array.\n\tEach id should be included only once and its value should be the sum of the values of this id in the two arrays. If the id does not exist in one of the two arrays then its value in that array is considered to be 0.\n\nReturn the resulting array. The returned array must be sorted in ascending order by id.\n&nbsp;\nExample 1:\n\nInput: nums1 = [[1,2],[2,3],[4,5]], nums2 = [[1,4],[3,2],[4,1]]\nOutput: [[1,6],[2,3],[3,2],[4,6]]\nExplanation: The resulting array contains the following:\n- id = 1, the value of this id is 2 + 4 = 6.\n- id = 2, the value of this id is 3.\n- id = 3, the value of this id is 2.\n- id = 4, the value of this id is 5 + 1 = 6.\n\nExample 2:\n\nInput: nums1 = [[2,4],[3,6],[5,5]], nums2 = [[1,3],[4,3]]\nOutput: [[1,3],[2,4],[3,6],[4,3],[5,5]]\nExplanation: There are no common ids, so we just include each id with its value in the resulting list.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums1.length, nums2.length <= 200\n\tnums1[i].length == nums2[j].length == 2\n\t1 <= idi, vali <= 1000\n\tBoth arrays contain unique ids.\n\tBoth arrays are in&nbsp;strictly ascending order by id.",
        "solutions": [
            {
                "id": 3203773,
                "title": "using-map-very-simple-easy-to-understand-solution",
                "content": "# Approach\\nWe just need to put the element to ordered hash map, and keep incrementing the value for all elements in the array.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n        vector<vector<int>> ans;\\n        map<int, int> mp;\\n        for(auto n: nums1) mp[n[0]] += n[1];\\n        for(auto n: nums2) mp[n[0]] += n[1];\\n        for(auto m: mp) ans.push_back({m.first, m.second});\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n        vector<vector<int>> ans;\\n        map<int, int> mp;\\n        for(auto n: nums1) mp[n[0]] += n[1];\\n        for(auto n: nums2) mp[n[0]] += n[1];\\n        for(auto m: mp) ans.push_back({m.first, m.second});\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203809,
                "title": "two-pointers",
                "content": "We use two pointers to get the next smallest `id`.\\n\\nThen, we add that `id` to the result, sum the value and advance the pointer of one or two arrays with matching id.\\n\\n**C++**\\n```cpp\\nvector<vector<int>> mergeArrays(vector<vector<int>>& n1, vector<vector<int>>& n2) {\\n    int i = 0, j = 0, sz1 = n1.size(), sz2 = n2.size();\\n    vector<vector<int>> res;\\n    while (i < sz1 || j < sz2) {\\n        int id = min(i < sz1 ? n1[i][0] : INT_MAX, j < sz2 ? n2[j][0] : INT_MAX);\\n        res.push_back({id, 0});\\n        if (i < sz1 && n1[i][0] == id)\\n            res.back()[1] += n1[i++][1];\\n        if (j < sz2 && n2[j][0] == id)\\n            res.back()[1] += n2[j++][1];\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nvector<vector<int>> mergeArrays(vector<vector<int>>& n1, vector<vector<int>>& n2) {\\n    int i = 0, j = 0, sz1 = n1.size(), sz2 = n2.size();\\n    vector<vector<int>> res;\\n    while (i < sz1 || j < sz2) {\\n        int id = min(i < sz1 ? n1[i][0] : INT_MAX, j < sz2 ? n2[j][0] : INT_MAX);\\n        res.push_back({id, 0});\\n        if (i < sz1 && n1[i][0] == id)\\n            res.back()[1] += n1[i++][1];\\n        if (j < sz2 && n2[j][0] == id)\\n            res.back()[1] += n2[j++][1];\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3205271,
                "title": "java-hashmap-explained",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIt creates a hashmap with the first array and then iterates through the second array. If there is a key in the map that matches, then it adds to its value. Otherwise, it adds a new entry to the map.\\n\\nAfter then we are creating other array and stored all of the id and values in that array. Then sorted it in the ascending order.\\n\\n# Complexity\\n- Time complexity: $$O(4n + n log n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n    Map<Integer,Integer> map = new HashMap<>();\\n        for(int[] a : nums1){\\n            map.put(a[0],a[1]);\\n        }\\n        for(int[] a : nums2){\\n            if(map.containsKey(a[0])){\\n                map.put(a[0], map.get(a[0])+a[1]);\\n            }\\n            else{\\n                map.put(a[0],a[1]);\\n            }\\n        }\\n        int ans[][] = new int[map.size()][2];\\n        int i=0;\\n        for(int key : map.keySet()){\\n            ans[i++] = new int[] {key,map.get(key)};\\n        }\\n        Arrays.sort(ans, (a,b) -> a[0]-b[0]);\\n        return ans;\\n    }\\n}\\n```\\n### If you like the solution and explanation then upvote me.\\n#### You can also give me suggestion that what can I do better.",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n    Map<Integer,Integer> map = new HashMap<>();\\n        for(int[] a : nums1){\\n            map.put(a[0],a[1]);\\n        }\\n        for(int[] a : nums2){\\n            if(map.containsKey(a[0])){\\n                map.put(a[0], map.get(a[0])+a[1]);\\n            }\\n            else{\\n                map.put(a[0],a[1]);\\n            }\\n        }\\n        int ans[][] = new int[map.size()][2];\\n        int i=0;\\n        for(int key : map.keySet()){\\n            ans[i++] = new int[] {key,map.get(key)};\\n        }\\n        Arrays.sort(ans, (a,b) -> a[0]-b[0]);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205601,
                "title": "javascript-2570-merge-two-2d-arrays-by-summing-values",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n1\\n```\\nvar mergeArrays = function (a, b) {\\n    let o = {};\\n\\n    for (let [i, v] of a) {\\n        o[i] = v;\\n    }\\n    for (let [i, v] of b) {\\n        o[i] = (o[i] || 0) + v;\\n    }\\n\\n    return Object.entries(o) //\\n        .sort((a, b) => a[0] - b[0]);\\n};\\n```\\n\\n2\\n```\\nvar mergeArrays = function (a, b) {\\n    let o = {};\\n    for (let [i, v] of [...a, ...b]) {\\n        o[i] = (o[i] || 0) + v;\\n    }\\n\\n    return Object.entries(o) //\\n        .sort((a, b) => a[0] - b[0]);\\n};\\n```\\n\\n3\\n```\\nvar mergeArrays = function (a, b) {\\n    let o = {};\\n    for (let [i, v] of a) o[i] = 0;\\n    for (let [i, v] of b) o[i] = 0;\\n\\n    for (let [i, v] of a) o[i] += v;\\n    for (let [i, v] of b) o[i] += v;\\n\\n    return Object.entries(o) //\\n        .sort((a, b) => a[0] - b[0]);\\n};\\n```\\n\\n4\\n```\\nvar mergeArrays = function (a, b) {\\n    let o = {};\\n\\n    for (let [i, v] of a) o[i] = (o[i] || 0) + v;\\n    for (let [i, v] of b) o[i] = (o[i] || 0) + v;\\n\\n    return Object.entries(o) //\\n        .sort((a, b) => a[0] - b[0]);\\n};\\n```\\n\\n5\\n```\\nvar mergeArrays = function (a, b) {\\n    let o = new Map(a);\\n    for (let [i, v] of b) {\\n        o.set(i, (o.get(i) || 0) + v);\\n    }\\n    return [...o].sort((a, b) => a[0] - b[0]);\\n};\\n```\\n\\n6\\n```\\nvar mergeArrays = function (a, b) {\\n    let i = 0,\\n        j = 0,\\n        m = a.length,\\n        n = b.length,\\n        o = [];\\n    while (i < m && j < n) {\\n        let [id1, v1] = a[i];\\n        let [id2, v2] = b[j];\\n\\n        if (id1 === id2) {\\n            o.push([id1, v1 + v2]);\\n            i++;\\n            j++;\\n        } else if (id1 < id2) {\\n            o.push([id1, v1]);\\n            i++;\\n        } else {\\n            o.push([id2, v2]);\\n            j++;\\n        }\\n    }\\n    for (; i < m; i++) o.push(a[i]); // remain a\\n    for (; j < n; j++) o.push(b[j]); // remain b\\n    return o;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar mergeArrays = function (a, b) {\\n    let o = {};\\n\\n    for (let [i, v] of a) {\\n        o[i] = v;\\n    }\\n    for (let [i, v] of b) {\\n        o[i] = (o[i] || 0) + v;\\n    }\\n\\n    return Object.entries(o) //\\n        .sort((a, b) => a[0] - b[0]);\\n};\\n```\n```\\nvar mergeArrays = function (a, b) {\\n    let o = {};\\n    for (let [i, v] of [...a, ...b]) {\\n        o[i] = (o[i] || 0) + v;\\n    }\\n\\n    return Object.entries(o) //\\n        .sort((a, b) => a[0] - b[0]);\\n};\\n```\n```\\nvar mergeArrays = function (a, b) {\\n    let o = {};\\n    for (let [i, v] of a) o[i] = 0;\\n    for (let [i, v] of b) o[i] = 0;\\n\\n    for (let [i, v] of a) o[i] += v;\\n    for (let [i, v] of b) o[i] += v;\\n\\n    return Object.entries(o) //\\n        .sort((a, b) => a[0] - b[0]);\\n};\\n```\n```\\nvar mergeArrays = function (a, b) {\\n    let o = {};\\n\\n    for (let [i, v] of a) o[i] = (o[i] || 0) + v;\\n    for (let [i, v] of b) o[i] = (o[i] || 0) + v;\\n\\n    return Object.entries(o) //\\n        .sort((a, b) => a[0] - b[0]);\\n};\\n```\n```\\nvar mergeArrays = function (a, b) {\\n    let o = new Map(a);\\n    for (let [i, v] of b) {\\n        o.set(i, (o.get(i) || 0) + v);\\n    }\\n    return [...o].sort((a, b) => a[0] - b[0]);\\n};\\n```\n```\\nvar mergeArrays = function (a, b) {\\n    let i = 0,\\n        j = 0,\\n        m = a.length,\\n        n = b.length,\\n        o = [];\\n    while (i < m && j < n) {\\n        let [id1, v1] = a[i];\\n        let [id2, v2] = b[j];\\n\\n        if (id1 === id2) {\\n            o.push([id1, v1 + v2]);\\n            i++;\\n            j++;\\n        } else if (id1 < id2) {\\n            o.push([id1, v1]);\\n            i++;\\n        } else {\\n            o.push([id2, v2]);\\n            j++;\\n        }\\n    }\\n    for (; i < m; i++) o.push(a[i]); // remain a\\n    for (; j < n; j++) o.push(b[j]); // remain b\\n    return o;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3203774,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) \\n    {\\n        vector<vector<int >> res;\\n        int i=0;\\n        int j=0;\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        \\n        while(i < n && j < m)\\n        {\\n            int id1 = nums1[i][0];\\n            int id2 = nums2[j][0];\\n            \\n            if(id1 == id2)\\n            {\\n                int sum = nums1[i][1] + nums2[j][1];\\n                res.push_back({id1,sum});\\n                i++;\\n                j++;\\n            }\\n            \\n            else if(id1 > id2)\\n            {\\n                res.push_back({id2,nums2[j][1]});\\n                j++;\\n            }\\n            \\n            else if(id1 < id2)\\n            {\\n                res.push_back({id1,nums1[i][1]});\\n                i++;\\n            }                     \\n        }\\n        \\n        while(i < n)\\n        {\\n            int id1 = nums1[i][0];\\n            res.push_back({id1,nums1[i][1]});\\n            \\n            i++;\\n        }\\n        \\n        while(j < m)\\n        {\\n            int id2 = nums2[j][0];\\n            res.push_back({id2,nums2[j][1]});\\n        \\n            j++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) \\n    {\\n        vector<vector<int >> res;\\n        int i=0;\\n        int j=0;\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        \\n        while(i < n && j < m)\\n        {\\n            int id1 = nums1[i][0];\\n            int id2 = nums2[j][0];\\n            \\n            if(id1 == id2)\\n            {\\n                int sum = nums1[i][1] + nums2[j][1];\\n                res.push_back({id1,sum});\\n                i++;\\n                j++;\\n            }\\n            \\n            else if(id1 > id2)\\n            {\\n                res.push_back({id2,nums2[j][1]});\\n                j++;\\n            }\\n            \\n            else if(id1 < id2)\\n            {\\n                res.push_back({id1,nums1[i][1]});\\n                i++;\\n            }                     \\n        }\\n        \\n        while(i < n)\\n        {\\n            int id1 = nums1[i][0];\\n            res.push_back({id1,nums1[i][1]});\\n            \\n            i++;\\n        }\\n        \\n        while(j < m)\\n        {\\n            int id2 = nums2[j][0];\\n            res.push_back({id2,nums2[j][1]});\\n        \\n            j++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204945,
                "title": "python-two-pointers-merge-two-sorted-arrays",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMerge two sorted array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTwo pointers.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n + m)$$, where $$n$$ and $$m$$ stand for the length of two input arrays.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n + m)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        res = []\\n        i = 0\\n        j = 0\\n        while i < len(nums1) or j < len(nums2):\\n            if i == len(nums1):\\n                res.append(nums2[j])\\n                j += 1\\n            elif j == len(nums2):\\n                res.append(nums1[i])\\n                i += 1\\n            else:\\n                if nums1[i][0] == nums2[j][0]:\\n                    res.append([nums1[i][0], nums1[i][1] + nums2[j][1]])\\n                    i += 1\\n                    j += 1\\n                elif nums1[i][0] < nums2[j][0]:\\n                    res.append(nums1[i])\\n                    i += 1\\n                else:\\n                    res.append(nums2[j])\\n                    j += 1\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        res = []\\n        i = 0\\n        j = 0\\n        while i < len(nums1) or j < len(nums2):\\n            if i == len(nums1):\\n                res.append(nums2[j])\\n                j += 1\\n            elif j == len(nums2):\\n                res.append(nums1[i])\\n                i += 1\\n            else:\\n                if nums1[i][0] == nums2[j][0]:\\n                    res.append([nums1[i][0], nums1[i][1] + nums2[j][1]])\\n                    i += 1\\n                    j += 1\\n                elif nums1[i][0] < nums2[j][0]:\\n                    res.append(nums1[i])\\n                    i += 1\\n                else:\\n                    res.append(nums2[j])\\n                    j += 1\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203787,
                "title": "merge-sort-java",
                "content": "```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        int n1=nums1.length,n2=nums2.length,i=0,j=0;\\n        ArrayList<int []>ans=new ArrayList();\\n        while(i<n1&& j<n2){\\n            if(nums1[i][0]==nums2[j][0]){\\n                ans.add(new int[]{nums1[i][0],nums1[i][1]+nums2[j][1]});\\n                i++;\\n                j++;\\n            }\\n            else if(nums1[i][0]<nums2[j][0]){\\n                ans.add(nums1[i]);\\n                i++;\\n            }\\n            else{\\n                ans.add(nums2[j]);\\n                j++;\\n            }\\n        }\\n        while(i<n1){\\n            ans.add(nums1[i++]);\\n        }\\n        while(j<n2){\\n            ans.add(nums2[j++]);\\n        }\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}\\n```\\n# Upvoting is much Appreciated",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        int n1=nums1.length,n2=nums2.length,i=0,j=0;\\n        ArrayList<int []>ans=new ArrayList();\\n        while(i<n1&& j<n2){\\n            if(nums1[i][0]==nums2[j][0]){\\n                ans.add(new int[]{nums1[i][0],nums1[i][1]+nums2[j][1]});\\n                i++;\\n                j++;\\n            }\\n            else if(nums1[i][0]<nums2[j][0]){\\n                ans.add(nums1[i]);\\n                i++;\\n            }\\n            else{\\n                ans.add(nums2[j]);\\n                j++;\\n            }\\n        }\\n        while(i<n1){\\n            ans.add(nums1[i++]);\\n        }\\n        while(j<n2){\\n            ans.add(nums2[j++]);\\n        }\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204676,
                "title": "video-solution-both-map-2-pointer-approach-c",
                "content": "# Video Solution\\nhttps://www.youtube.com/watch?v=QNilkNu5NGU&feature=youtu.be\\n\\n\\n# 2-Pointer Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n        vector<vector<int>> ans;\\n        \\n        int n = nums1.size();\\n        int m = nums2.size();\\n        \\n        int i=0, j=0;\\n        while(i<n && j<m){\\n            if(nums1[i][0] == nums2[j][0]){\\n                ans.push_back({nums1[i][0] ,nums1[i][1] + nums2[j][1]});\\n                i++;\\n                j++;\\n            }else if(nums1[i][0] < nums2[j][0]){\\n                ans.push_back({nums1[i][0] ,  nums1[i][1]});\\n                i++;\\n            }else{\\n                ans.push_back({nums2[j][0] ,nums2[j][1]});\\n                j++;\\n            }\\n        }\\n        \\n        while(i<n){\\n            ans.push_back({nums1[i][0] ,nums1[i][1]});\\n            i++;\\n        }\\n        \\n        while(j<m){\\n            ans.push_back({nums2[j][0] ,nums2[j][1]});\\n            j++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n# Map Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n        vector<vector<int>> ans;\\n        \\n        int n = nums1.size();\\n        int m = nums2.size();\\n        \\n        map<int, int> mp;\\n        for(auto el : nums1){\\n            mp[el[0]] += el[1];\\n        }\\n        \\n        for(auto el : nums2){\\n            mp[el[0]] += el[1];\\n        }\\n        \\n        for(auto p : mp){\\n            ans.push_back({p.first, p.second});\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n        vector<vector<int>> ans;\\n        \\n        int n = nums1.size();\\n        int m = nums2.size();\\n        \\n        int i=0, j=0;\\n        while(i<n && j<m){\\n            if(nums1[i][0] == nums2[j][0]){\\n                ans.push_back({nums1[i][0] ,nums1[i][1] + nums2[j][1]});\\n                i++;\\n                j++;\\n            }else if(nums1[i][0] < nums2[j][0]){\\n                ans.push_back({nums1[i][0] ,  nums1[i][1]});\\n                i++;\\n            }else{\\n                ans.push_back({nums2[j][0] ,nums2[j][1]});\\n                j++;\\n            }\\n        }\\n        \\n        while(i<n){\\n            ans.push_back({nums1[i][0] ,nums1[i][1]});\\n            i++;\\n        }\\n        \\n        while(j<m){\\n            ans.push_back({nums2[j][0] ,nums2[j][1]});\\n            j++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n        vector<vector<int>> ans;\\n        \\n        int n = nums1.size();\\n        int m = nums2.size();\\n        \\n        map<int, int> mp;\\n        for(auto el : nums1){\\n            mp[el[0]] += el[1];\\n        }\\n        \\n        for(auto el : nums2){\\n            mp[el[0]] += el[1];\\n        }\\n        \\n        for(auto p : mp){\\n            ans.push_back({p.first, p.second});\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203704,
                "title": "simple-java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n+m)$$ where n is the length of nums1 and m is the length of nums2\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        int m=nums1.length,n=nums2.length;\\n        int i=0,j=0,c=0;\\n        while(i<m && j<n)\\n        {\\n            if(nums1[i][0]==nums2[j][0])\\n            {\\n                c++;\\n                i++;\\n                j++;\\n            }\\n            else if(nums1[i][0]>nums2[j][0])\\n            {\\n                c++;\\n                j++;\\n            }\\n            else\\n            {\\n                c++;\\n                i++;\\n            }\\n        }\\n        while(i<m)\\n        {\\n            c++;\\n            i++;\\n        }\\n        while(j<n)\\n        {\\n            c++;\\n            j++;\\n        }\\n        int nums[][] = new int[c][2];\\n        int k=0;\\n        i=0;\\n        j=0;\\n        while(i<m && j<n)\\n        {\\n            if(nums1[i][0]==nums2[j][0])\\n            {\\n                nums[k][0]=nums1[i][0];\\n                nums[k][1]=nums1[i][1]+nums2[j][1];\\n                k++;\\n                i++;\\n                j++;\\n            }\\n            else if(nums1[i][0]>nums2[j][0])\\n            {\\n                nums[k][0]=nums2[j][0];\\n                nums[k][1]=nums2[j][1];\\n                k++;\\n                j++;\\n            }\\n            else\\n            {\\n                nums[k][0]=nums1[i][0];\\n                nums[k][1]=nums1[i][1];\\n                k++;\\n                i++;\\n            }\\n        }\\n        while(i<m)\\n        {\\n            nums[k][0]=nums1[i][0];\\n                nums[k][1]=nums1[i][1];\\n                k++;\\n                i++;\\n        }\\n        while(j<n)\\n        {\\n           nums[k][0]=nums2[j][0];\\n                nums[k][1]=nums2[j][1];\\n                k++;\\n                j++;\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        int m=nums1.length,n=nums2.length;\\n        int i=0,j=0,c=0;\\n        while(i<m && j<n)\\n        {\\n            if(nums1[i][0]==nums2[j][0])\\n            {\\n                c++;\\n                i++;\\n                j++;\\n            }\\n            else if(nums1[i][0]>nums2[j][0])\\n            {\\n                c++;\\n                j++;\\n            }\\n            else\\n            {\\n                c++;\\n                i++;\\n            }\\n        }\\n        while(i<m)\\n        {\\n            c++;\\n            i++;\\n        }\\n        while(j<n)\\n        {\\n            c++;\\n            j++;\\n        }\\n        int nums[][] = new int[c][2];\\n        int k=0;\\n        i=0;\\n        j=0;\\n        while(i<m && j<n)\\n        {\\n            if(nums1[i][0]==nums2[j][0])\\n            {\\n                nums[k][0]=nums1[i][0];\\n                nums[k][1]=nums1[i][1]+nums2[j][1];\\n                k++;\\n                i++;\\n                j++;\\n            }\\n            else if(nums1[i][0]>nums2[j][0])\\n            {\\n                nums[k][0]=nums2[j][0];\\n                nums[k][1]=nums2[j][1];\\n                k++;\\n                j++;\\n            }\\n            else\\n            {\\n                nums[k][0]=nums1[i][0];\\n                nums[k][1]=nums1[i][1];\\n                k++;\\n                i++;\\n            }\\n        }\\n        while(i<m)\\n        {\\n            nums[k][0]=nums1[i][0];\\n                nums[k][1]=nums1[i][1];\\n                k++;\\n                i++;\\n        }\\n        while(j<n)\\n        {\\n           nums[k][0]=nums2[j][0];\\n                nums[k][1]=nums2[j][1];\\n                k++;\\n                j++;\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203710,
                "title": "two-pointers-easiest-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& n1, vector<vector<int>>& n2) {\\n        int m=n1.size(),n=n2.size();\\n        vector<vector<int>> ans;\\n        \\n        int i=0,j=0;\\n        while(i<m && j<n){\\n            \\n            if(n1[i][0] < n2[j][0]){\\n                ans.push_back(n1[i]);\\n                i++;\\n            }\\n            \\n            else if(n1[i][0] > n2[j][0]){\\n                ans.push_back(n2[j]);\\n                j++;    \\n            }\\n            \\n            else{\\n                vector<int> r(2);\\n                r[0]=n2[j][0];\\n                r[1]=n1[i][1]+n2[j][1];\\n                ans.push_back(r);\\n                j++;\\n                i++;\\n            }\\n        }\\n        \\n        if(i<m){\\n            while(i<m){\\n                ans.push_back(n1[i]);\\n                i++;\\n            }\\n        }\\n        \\n        if(j<n){\\n            while(j < n){\\n                ans.push_back(n2[j]);\\n                j++;\\n            }   \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n# Please Do Upvote, if you understood the code!",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& n1, vector<vector<int>>& n2) {\\n        int m=n1.size(),n=n2.size();\\n        vector<vector<int>> ans;\\n        \\n        int i=0,j=0;\\n        while(i<m && j<n){\\n            \\n            if(n1[i][0] < n2[j][0]){\\n                ans.push_back(n1[i]);\\n                i++;\\n            }\\n            \\n            else if(n1[i][0] > n2[j][0]){\\n                ans.push_back(n2[j]);\\n                j++;    \\n            }\\n            \\n            else{\\n                vector<int> r(2);\\n                r[0]=n2[j][0];\\n                r[1]=n1[i][1]+n2[j][1];\\n                ans.push_back(r);\\n                j++;\\n                i++;\\n            }\\n        }\\n        \\n        if(i<m){\\n            while(i<m){\\n                ans.push_back(n1[i]);\\n                i++;\\n            }\\n        }\\n        \\n        if(j<n){\\n            while(j < n){\\n                ans.push_back(n2[j]);\\n                j++;\\n            }   \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3545433,
                "title": "using-map-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n        unordered_map<int,int> mp;\\n        for(auto &i: nums1)mp[i[0]] += i[1];\\n        for(auto &i: nums2)mp[i[0]] += i[1];\\n        vector<vector<int>> v;\\n        for(auto &i: mp){\\n            v.push_back({i.first,i.second});\\n        }\\n        sort(v.begin(),v.end());\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n        unordered_map<int,int> mp;\\n        for(auto &i: nums1)mp[i[0]] += i[1];\\n        for(auto &i: nums2)mp[i[0]] += i[1];\\n        vector<vector<int>> v;\\n        for(auto &i: mp){\\n            v.push_back({i.first,i.second});\\n        }\\n        sort(v.begin(),v.end());\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203716,
                "title": "c-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n        for(int i=0;i<nums1.size();i++){\\n            int x = nums1[i][0];\\n            for(int j=0;j<nums2.size();j++){\\n                if(nums2[j][0]==x){\\n                    nums1[i][1] += nums2[j][1];\\n                    nums2[j] = {-1,-1};\\n                }\\n            }\\n        }\\n        for(int i=0;i<nums2.size();i++){\\n            if(nums2[i][0] !=-1 && nums2[i][1] !=-1){\\n                nums1.push_back(nums2[i]);\\n            }\\n        }\\n        sort(nums1.begin(),nums1.end(),[](vector<int> a,vector<int> b){\\n           return a[0]<b[0]; \\n        });\\n        return nums1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n        for(int i=0;i<nums1.size();i++){\\n            int x = nums1[i][0];\\n            for(int j=0;j<nums2.size();j++){\\n                if(nums2[j][0]==x){\\n                    nums1[i][1] += nums2[j][1];\\n                    nums2[j] = {-1,-1};\\n                }\\n            }\\n        }\\n        for(int i=0;i<nums2.size();i++){\\n            if(nums2[i][0] !=-1 && nums2[i][1] !=-1){\\n                nums1.push_back(nums2[i]);\\n            }\\n        }\\n        sort(nums1.begin(),nums1.end(),[](vector<int> a,vector<int> b){\\n           return a[0]<b[0]; \\n        });\\n        return nums1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782785,
                "title": "python-3-using-counters-2-lines",
                "content": "```python3 []\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        d = Counter(dict(nums1)) + Counter(dict(nums2))\\n        return [[k, v] for k, v in sorted(d.items())]\\n```\\n```python3 []\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        return [[k, v] for k, v in sorted((Counter(dict(nums1)) + Counter(dict(nums2))).items())]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        d = Counter(dict(nums1)) + Counter(dict(nums2))\\n        return [[k, v] for k, v in sorted(d.items())]\\n```\n```python3 []\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        return [[k, v] for k, v in sorted((Counter(dict(nums1)) + Counter(dict(nums2))).items())]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268436,
                "title": "python-two-pointers-easy-understanding",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```python []\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n\\n        res = []\\n        l, r = 0, 0\\n        while l < len(nums1) and r < len(nums2):\\n            if nums1[l][0] < nums2[r][0]:\\n                res.append(nums1[l])\\n                l += 1\\n            elif nums1[l][0] > nums2[r][0]:\\n                res.append(nums2[r])\\n                r += 1\\n            else:\\n                val = nums1[l][1] + nums2[r][1]\\n                res.append([nums1[l][0], val])\\n                l, r = l + 1, r + 1\\n    \\n        if l < len(nums1):\\n            res.extend(nums1[l:])\\n        elif r < len(nums2):\\n            res.extend(nums2[r:])\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```python []\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n\\n        res = []\\n        l, r = 0, 0\\n        while l < len(nums1) and r < len(nums2):\\n            if nums1[l][0] < nums2[r][0]:\\n                res.append(nums1[l])\\n                l += 1\\n            elif nums1[l][0] > nums2[r][0]:\\n                res.append(nums2[r])\\n                r += 1\\n            else:\\n                val = nums1[l][1] + nums2[r][1]\\n                res.append([nums1[l][0], val])\\n                l, r = l + 1, r + 1\\n    \\n        if l < len(nums1):\\n            res.extend(nums1[l:])\\n        elif r < len(nums2):\\n            res.extend(nums2[r:])\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3229817,
                "title": "java-solution-1ms",
                "content": "# Intuition\\nWe can use Collection Framework (HashSet) but it takes extra time as it uses hashing techniques ,as it says max length is 1000, we can create a int array and use index as id and its(index) value  as idval. \\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        List<int[]> al = new ArrayList<>();\\n       \\n        int max = 0;\\n        for(int i =0;i < nums1.length; i++){\\n            if(nums1[i][0] > max){\\n                max = nums1[i][0];\\n            }\\n        }\\n        for(int i =0;i < nums2.length; i++){\\n            if(nums2[i][0] > max){\\n                max = nums2[i][0];\\n            }\\n        }\\n        \\n        int hashT[] = new int[max+1];\\n        for(int i =0;i < nums1.length; i++){\\n            hashT[nums1[i][0]] += nums1[i][1];\\n        }\\n        for(int i =0;i < nums2.length; i++){\\n            hashT[nums2[i][0]] += nums2[i][1];\\n        }\\n        \\n        for(int i=0; i < hashT.length;i++){\\n            if(hashT[i] > 0){\\n                int k[] = {i,hashT[i]};\\n                al.add(k);\\n            }\\n        }\\n        \\n        int ans[][] = new int[al.size()][2];\\n        \\n        int x = 0;\\n        for(int aa[]:al){\\n            ans[x++] = aa;\\n        }\\n        \\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        List<int[]> al = new ArrayList<>();\\n       \\n        int max = 0;\\n        for(int i =0;i < nums1.length; i++){\\n            if(nums1[i][0] > max){\\n                max = nums1[i][0];\\n            }\\n        }\\n        for(int i =0;i < nums2.length; i++){\\n            if(nums2[i][0] > max){\\n                max = nums2[i][0];\\n            }\\n        }\\n        \\n        int hashT[] = new int[max+1];\\n        for(int i =0;i < nums1.length; i++){\\n            hashT[nums1[i][0]] += nums1[i][1];\\n        }\\n        for(int i =0;i < nums2.length; i++){\\n            hashT[nums2[i][0]] += nums2[i][1];\\n        }\\n        \\n        for(int i=0; i < hashT.length;i++){\\n            if(hashT[i] > 0){\\n                int k[] = {i,hashT[i]};\\n                al.add(k);\\n            }\\n        }\\n        \\n        int ans[][] = new int[al.size()][2];\\n        \\n        int x = 0;\\n        for(int aa[]:al){\\n            ans[x++] = aa;\\n        }\\n        \\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204987,
                "title": "c-merge-and-sort-clean-and-easy-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n        vector<vector<int>> ans;\\n        for(auto it: nums2){\\n            nums1.push_back(it);\\n        }\\n        sort(nums1.begin(),nums1.end());\\n        int n = nums1.size();\\n        int i=0;\\n        while(i<n){\\n            ans.push_back(nums1[i]);\\n            while(++i<n and nums1[i-1][0]==nums1[i][0]){\\n                int ind = ans.size()-1;\\n                ans[ind][1]+=nums1[i][1];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n        vector<vector<int>> ans;\\n        for(auto it: nums2){\\n            nums1.push_back(it);\\n        }\\n        sort(nums1.begin(),nums1.end());\\n        int n = nums1.size();\\n        int i=0;\\n        while(i<n){\\n            ans.push_back(nums1[i]);\\n            while(++i<n and nums1[i-1][0]==nums1[i][0]){\\n                int ind = ans.size()-1;\\n                ans[ind][1]+=nums1[i][1];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204177,
                "title": "two-pointers-easy-c-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n        vector<vector<int>> ans;\\n        int i=0,j=0,n = nums1.size(),m = nums2.size();\\n        while(i<n&&j<m){\\n            if(nums1[i][0]==nums2[j][0]){\\n                ans.push_back({nums1[i][0],nums1[i][1]+nums2[j][1]});\\n                i++;\\n                j++;\\n            }else if(nums1[i][0]<nums2[j][0]){\\n                ans.push_back(nums1[i]);\\n                i++;\\n            }else{\\n                ans.push_back(nums2[j]);\\n                j++;\\n            }\\n        }\\n        while(i<n){\\n                ans.push_back(nums1[i]);\\n                i++;\\n        }while(j<m){\\n                ans.push_back(nums2[j]);\\n                j++;\\n        }\\n        return ans;\\n    }\\n};```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n        vector<vector<int>> ans;\\n        int i=0,j=0,n = nums1.size(),m = nums2.size();\\n        while(i<n&&j<m){\\n            if(nums1[i][0]==nums2[j][0]){\\n                ans.push_back({nums1[i][0],nums1[i][1]+nums2[j][1]});\\n                i++;\\n                j++;\\n            }else if(nums1[i][0]<nums2[j][0]){\\n                ans.push_back(nums1[i]);\\n                i++;\\n            }else{\\n                ans.push_back(nums2[j]);\\n                j++;\\n            }\\n        }\\n        while(i<n){\\n                ans.push_back(nums1[i]);\\n                i++;\\n        }while(j<m){\\n                ans.push_back(nums2[j]);\\n                j++;\\n        }\\n        return ans;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 3204068,
                "title": "java-easy-approach",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        \\n      List<int[]> res = new ArrayList<>();\\n\\n      for(int i=0, j=0; i < nums1.length  || j < nums2.length ;){\\n        \\n        if(i >= nums1.length) { res.add(nums2[j++]); continue; }\\n\\n        if(j >= nums2.length) { res.add(nums1[i++]); continue; }\\n\\n        if(nums1[i][0] == nums2[j][0]){\\n            res.add(new int[] {nums1[i][0], nums1[i++][1] + nums2[j++][1]});\\n        }\\n        else if(nums1[i][0] < nums2[j][0] ){\\n            res.add(nums1[i++]);\\n        }\\n        else{\\n            res.add(nums2[j++]);\\n        }\\n\\n      }\\n        return res.toArray(int[][] :: new);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        \\n      List<int[]> res = new ArrayList<>();\\n\\n      for(int i=0, j=0; i < nums1.length  || j < nums2.length ;){\\n        \\n        if(i >= nums1.length) { res.add(nums2[j++]); continue; }\\n\\n        if(j >= nums2.length) { res.add(nums1[i++]); continue; }\\n\\n        if(nums1[i][0] == nums2[j][0]){\\n            res.add(new int[] {nums1[i][0], nums1[i++][1] + nums2[j++][1]});\\n        }\\n        else if(nums1[i][0] < nums2[j][0] ){\\n            res.add(nums1[i++]);\\n        }\\n        else{\\n            res.add(nums2[j++]);\\n        }\\n\\n      }\\n        return res.toArray(int[][] :: new);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203952,
                "title": "concise-java-tree-map-4-lines-two-pointers",
                "content": "```java\\npublic int[][] mergeArrays(int[][] a1, int[][] a2) {//tree map\\n        Map<Integer, Integer> m = new TreeMap<>();\\n        Arrays.stream(a1).forEach(n -> m.put(n[0], n[1]));\\n        Arrays.stream(a2).forEach(n -> m.put(n[0], m.getOrDefault(n[0], 0) + n[1]));\\n        return m.keySet().stream().map(k -> new int[]{k, m.get(k)}).toList().toArray(new int[0][]);\\n    }\\n\\npublic int[][] mergeArrays(int[][] a1, int[][] a2) {//two pointers\\n        List<int[]> r = new ArrayList<>();\\n        int i = 0, j = 0;\\n        while (i < a1.length && j < a2.length)\\n            if (a1[i][0] == a2[j][0])\\n                r.add(new int[]{a1[i][0], a1[i++][1] + a2[j++][1]});\\n            else if (a1[i][0] < a2[j][0])\\n                r.add(a1[i++]);\\n            else r.add(a2[j++]);\\n        while (i < a1.length)\\n            r.add(a1[i++]);\\n        while (j < a2.length)\\n            r.add(a2[j++]);\\n        return r.toArray(new int[0][]);\\n    }\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\npublic int[][] mergeArrays(int[][] a1, int[][] a2) {//tree map\\n        Map<Integer, Integer> m = new TreeMap<>();\\n        Arrays.stream(a1).forEach(n -> m.put(n[0], n[1]));\\n        Arrays.stream(a2).forEach(n -> m.put(n[0], m.getOrDefault(n[0], 0) + n[1]));\\n        return m.keySet().stream().map(k -> new int[]{k, m.get(k)}).toList().toArray(new int[0][]);\\n    }\\n\\npublic int[][] mergeArrays(int[][] a1, int[][] a2) {//two pointers\\n        List<int[]> r = new ArrayList<>();\\n        int i = 0, j = 0;\\n        while (i < a1.length && j < a2.length)\\n            if (a1[i][0] == a2[j][0])\\n                r.add(new int[]{a1[i][0], a1[i++][1] + a2[j++][1]});\\n            else if (a1[i][0] < a2[j][0])\\n                r.add(a1[i++]);\\n            else r.add(a2[j++]);\\n        while (i < a1.length)\\n            r.add(a1[i++]);\\n        while (j < a2.length)\\n            r.add(a2[j++]);\\n        return r.toArray(new int[0][]);\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3203875,
                "title": "java-two-pointers-simple-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(m+n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m+n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n    var ans = new ArrayList<int[]>();\\n    var m = nums1.length;\\n    var n = nums2.length;\\n    int i = 0, j = 0;\\n    \\n    while (i < m || j < n) {\\n      if (i == m || (j != n && nums2[j][0] < nums1[i][0]))\\n        ans.add(new int[] {nums2[j][0], nums2[j++][1]});\\n      else if (j == n || (i != m && nums1[i][0] < nums2[j][0]))\\n        ans.add(new int[] {nums1[i][0], nums1[i++][1]});\\n      else\\n        ans.add(new int[] {nums1[i][0], nums1[i++][1] + nums2[j++][1]});\\n    }\\n    return ans.toArray(new int[ans.size()][2]);\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n  public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n    var ans = new ArrayList<int[]>();\\n    var m = nums1.length;\\n    var n = nums2.length;\\n    int i = 0, j = 0;\\n    \\n    while (i < m || j < n) {\\n      if (i == m || (j != n && nums2[j][0] < nums1[i][0]))\\n        ans.add(new int[] {nums2[j][0], nums2[j++][1]});\\n      else if (j == n || (i != m && nums1[i][0] < nums2[j][0]))\\n        ans.add(new int[] {nums1[i][0], nums1[i++][1]});\\n      else\\n        ans.add(new int[] {nums1[i][0], nums1[i++][1] + nums2[j++][1]});\\n    }\\n    return ans.toArray(new int[ans.size()][2]);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203740,
                "title": "python",
                "content": "# Python\\n```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        \\n        res = []\\n        \\n        while nums1 and nums2:\\n            \\n            a = nums1[0]\\n            b = nums2[0]\\n            if a[0] == b[0]:\\n                nums1.pop(0)\\n                nums2.pop(0)\\n                res.append([a[0], a[1]+b[1]])\\n            \\n            elif a[0] > b[0]:\\n                nums2.pop(0)\\n                res.append(b)\\n            \\n            else:\\n                nums1.pop(0)\\n                res.append(a)\\n        \\n        while nums1: res.append(nums1.pop(0))\\n        while nums2: res.append(nums2.pop(0))\\n            \\n        return res\\n                \\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        \\n        res = []\\n        \\n        while nums1 and nums2:\\n            \\n            a = nums1[0]\\n            b = nums2[0]\\n            if a[0] == b[0]:\\n                nums1.pop(0)\\n                nums2.pop(0)\\n                res.append([a[0], a[1]+b[1]])\\n            \\n            elif a[0] > b[0]:\\n                nums2.pop(0)\\n                res.append(b)\\n            \\n            else:\\n                nums1.pop(0)\\n                res.append(a)\\n        \\n        while nums1: res.append(nums1.pop(0))\\n        while nums2: res.append(nums2.pop(0))\\n            \\n        return res\\n                \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4030661,
                "title": "merge-two-2d-arrays-o-n-javascript-memory-95-45-meaningful-vars",
                "content": "Time Complexity: O(N)\\nSpace Complexity: O(N)\\n```\\nvar mergeArrays = function (nums1, nums2) {\\n  const sumObject = {};\\n  for (const [key, value] of nums1) {\\n    if (sumObject[key] === undefined) {\\n      sumObject[key] = 0;\\n    }\\n    sumObject[key] += value;\\n  }\\n  for (const [key, value] of nums2) {\\n    if (sumObject[key] === undefined) {\\n      sumObject[key] = 0;\\n    }\\n    sumObject[key] += value;\\n  }\\n  const output = [];\\n  for (const key in sumObject) {\\n    output.push([Number(key), sumObject[key]]);\\n  }\\n  return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar mergeArrays = function (nums1, nums2) {\\n  const sumObject = {};\\n  for (const [key, value] of nums1) {\\n    if (sumObject[key] === undefined) {\\n      sumObject[key] = 0;\\n    }\\n    sumObject[key] += value;\\n  }\\n  for (const [key, value] of nums2) {\\n    if (sumObject[key] === undefined) {\\n      sumObject[key] = 0;\\n    }\\n    sumObject[key] += value;\\n  }\\n  const output = [];\\n  for (const key in sumObject) {\\n    output.push([Number(key), sumObject[key]]);\\n  }\\n  return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3331002,
                "title": "easy-solution-without-sorting",
                "content": "# Code\\n```\\n/**\\n * @param {number[][]} nums1\\n * @param {number[][]} nums2\\n * @return {number[][]}\\n */\\nvar mergeArrays = function(nums1, nums2) {\\n    const numsMap = {};\\n    nums1.forEach(([id, num]) => {\\n        numsMap[id] = num;\\n    });\\n    nums2.forEach(([id, num]) => {\\n        numsMap[id] = (numsMap[id] ?? 0) + num;\\n    });\\n    // no need to sort entries because if keys in object is integers\\n    // (of course they are strings but if they are strings from integers)\\n    // they are sorted automatically\\n    return Object.entries(numsMap);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} nums1\\n * @param {number[][]} nums2\\n * @return {number[][]}\\n */\\nvar mergeArrays = function(nums1, nums2) {\\n    const numsMap = {};\\n    nums1.forEach(([id, num]) => {\\n        numsMap[id] = num;\\n    });\\n    nums2.forEach(([id, num]) => {\\n        numsMap[id] = (numsMap[id] ?? 0) + num;\\n    });\\n    // no need to sort entries because if keys in object is integers\\n    // (of course they are strings but if they are strings from integers)\\n    // they are sorted automatically\\n    return Object.entries(numsMap);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3209759,
                "title": "java-solution-step-by-step-approach",
                "content": "First of all let\\'s try to understand our input and output data:\\n\\n**Input: ***nums1*** = [[1,2],[2,3],[4,5]], *nums2* = [[1,4],[3,2],[4,1]]\\nOutput: [[1,6],[2,3],[3,2],[4,6]]**\\n\\nNote: every single element inside these arrays will be counted as a[0,1] for better understanding.\\n\\nAs we can see we need to merge these two arrays into single one and to add a[1] if a[0] are the same or just add a[0,1] to the result array if they are not.\\n\\nSo, my first guess was to merge them, but this way leads us nowhere. We need to find something else.\\n\\n1. Let\\'s use a hashmap to store *num1* as key-value pairs. At this step we have a hashmap with a[0,1] inside it. This hashmap helps us to find all dublicates and treat them the right way.\\n2. Iterate over *num2* with the simple logic: if our map does not contain a[0] of a nums2 we add a new pair a[0] as a key, a[1] as a value. If our hashmap contains a key, literally else in my code, we will add to the current element of num2 a[1] the value of the element in the map, namely map.get(a[0]). \\n\\n    *Please note that we cannot use map.get(i) here if we have a simple for loop because our hashmap has \\'holes\\' inside it. For instance we do not have elements 0 and 3, thus we will get NPE.*\\n\\n3. Iterate over every entry in the map and add each key-value pair as a new array to our result array, namely new int[]{entry.getKey(), entry.getValue()}.\\n\\n4. Sorting our result array into int[][] and submit the answer.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public static int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        List<int[]> arr = new ArrayList<>();\\n\\n        for (int[] a : nums1) {\\n            map.put(a[0], a[1]);\\n        }\\n        for (int[] a : nums2) {\\n            if (!map.containsKey(a[0])) {\\n                map.put(a[0], a[1]);\\n            } else {\\n                a[1] += map.get(a[0]);\\n                map.put(a[0], a[1]);\\n            }\\n        }\\n        for (var entry : map.entrySet()) {\\n            arr.add(new int[]{entry.getKey(), entry.getValue()});\\n        }\\n        arr.sort(Comparator.comparingInt(a -> a[0]));\\n        return arr.toArray(new int[0][]);\\n    }\\n}\\n```\\n![4x5hdv.jpeg](https://assets.leetcode.com/users/images/9ddc5f71-0d4e-4bf2-bfc6-42196e718711_1677435418.504396.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        List<int[]> arr = new ArrayList<>();\\n\\n        for (int[] a : nums1) {\\n            map.put(a[0], a[1]);\\n        }\\n        for (int[] a : nums2) {\\n            if (!map.containsKey(a[0])) {\\n                map.put(a[0], a[1]);\\n            } else {\\n                a[1] += map.get(a[0]);\\n                map.put(a[0], a[1]);\\n            }\\n        }\\n        for (var entry : map.entrySet()) {\\n            arr.add(new int[]{entry.getKey(), entry.getValue()});\\n        }\\n        arr.sort(Comparator.comparingInt(a -> a[0]));\\n        return arr.toArray(new int[0][]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3208912,
                "title": "c-using-linq",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int[][] MergeArrays(int[][] nums1, int[][] nums2) => nums1\\n        .Concat(nums2)\\n        .GroupBy(num => num[0])\\n        .Select(g => g.Aggregate(new int[2], (sum, item) => new [] { item[0], sum[1] + item[1] }))\\n        .OrderBy(item => item[0])\\n        .ToArray();\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[][] MergeArrays(int[][] nums1, int[][] nums2) => nums1\\n        .Concat(nums2)\\n        .GroupBy(num => num[0])\\n        .Select(g => g.Aggregate(new int[2], (sum, item) => new [] { item[0], sum[1] + item[1] }))\\n        .OrderBy(item => item[0])\\n        .ToArray();\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207378,
                "title": "python-defaultdict-4-lines",
                "content": "```python\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        d = defaultdict(int)\\n        \\n        for i, v in nums1 + nums2:\\n            d[i] += v\\n            \\n        return sorted(d.items(), key=lambda t: t[0])\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        d = defaultdict(int)\\n        \\n        for i, v in nums1 + nums2:\\n            d[i] += v\\n            \\n        return sorted(d.items(), key=lambda t: t[0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205110,
                "title": "java-easy-solution-treemap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing TreeMap so that  the elements are in sorted form\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPut all the elements of both the map into the tree map and then update the values in it by traversing into both the array\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) \\n    {\\n       int n1=nums1.length;\\n       int m1=nums1.length;\\n       int n2=nums2.length;\\n       int m2=nums2.length;\\n       TreeMap<Integer,Integer>map=new TreeMap<>();\\n        for(int i=0;i<n1;i++)\\n        {\\n            if(map.containsKey(nums1[i][0])==true)\\n            {\\n                map.put(nums1[i][0],map.get(nums1[i][0])+nums1[i][1]);\\n            }\\n            else\\n                map.put(nums1[i][0],nums1[i][1]);\\n        }\\n         for(int i=0;i<n2;i++)\\n        {\\n            if(map.containsKey(nums2[i][0])==true)\\n            {\\n                map.put(nums2[i][0],map.get(nums2[i][0])+nums2[i][1]);\\n            }\\n            else\\n                map.put(nums2[i][0],nums2[i][1]);\\n        }\\n        //System.out.print(map);\\n         int ans[][]=new int[map.size()][2];\\n         int c=0;\\n        \\n        for (Map.Entry<Integer,Integer> mapElement : map.entrySet())\\n        {\\n             \\n            ans[c][0]=mapElement.getKey();\\n            ans[c][1]=(mapElement.getValue());\\n            c++;\\n        }\\n        return ans;\\n    }\\n\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) \\n    {\\n       int n1=nums1.length;\\n       int m1=nums1.length;\\n       int n2=nums2.length;\\n       int m2=nums2.length;\\n       TreeMap<Integer,Integer>map=new TreeMap<>();\\n        for(int i=0;i<n1;i++)\\n        {\\n            if(map.containsKey(nums1[i][0])==true)\\n            {\\n                map.put(nums1[i][0],map.get(nums1[i][0])+nums1[i][1]);\\n            }\\n            else\\n                map.put(nums1[i][0],nums1[i][1]);\\n        }\\n         for(int i=0;i<n2;i++)\\n        {\\n            if(map.containsKey(nums2[i][0])==true)\\n            {\\n                map.put(nums2[i][0],map.get(nums2[i][0])+nums2[i][1]);\\n            }\\n            else\\n                map.put(nums2[i][0],nums2[i][1]);\\n        }\\n        //System.out.print(map);\\n         int ans[][]=new int[map.size()][2];\\n         int c=0;\\n        \\n        for (Map.Entry<Integer,Integer> mapElement : map.entrySet())\\n        {\\n             \\n            ans[c][0]=mapElement.getKey();\\n            ans[c][1]=(mapElement.getValue());\\n            c++;\\n        }\\n        return ans;\\n    }\\n\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204269,
                "title": "c-straightforward-clean-code-map-stl",
                "content": "![image](https://assets.leetcode.com/users/images/66b6ff4f-c2df-4453-9116-5c86f46cae8c_1676784278.2605484.png)\\n\\n**n==size of map**\\n**T->O(n) && S->O(n)**\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2){\\n\\t\\t\\t\\tmap<int,int> mp;\\n\\t\\t\\t\\tvector<vector<int>> ans;\\n\\t\\t\\t\\tfor(auto i:nums1) mp[i[0]]+=i[1];\\n\\t\\t\\t\\tfor(auto i:nums2) mp[i[0]]+=i[1];\\n\\t\\t\\t\\tfor(auto i:mp) ans.push_back({i.first,i.second}); \\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2){\\n\\t\\t\\t\\tmap<int,int> mp;\\n\\t\\t\\t\\tvector<vector<int>> ans;\\n\\t\\t\\t\\tfor(auto i:nums1) mp[i[0]]+=i[1];\\n\\t\\t\\t\\tfor(auto i:nums2) mp[i[0]]+=i[1];\\n\\t\\t\\t\\tfor(auto i:mp) ans.push_back({i.first,i.second}",
                "codeTag": "Java"
            },
            {
                "id": 3203793,
                "title": "two-pointer-approach-similar-to-merge-two-sorted-arrays",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n        vector<vector<int>>ans;\\n        int i=0,j=0;\\n        int n=nums1.size(),m=nums2.size();\\n        while(i<n && j<m)\\n        {\\n            if(nums1[i][0]==nums2[j][0])\\n            {\\n                ans.push_back({nums1[i][0],nums1[i][1]+nums2[j][1]});\\n                i++;\\n                j++;\\n            }else if(nums1[i][0]<nums2[j][0])\\n            {\\n                ans.push_back({nums1[i][0],nums1[i][1]});\\n                i++;\\n            }else{\\n                ans.push_back({nums2[j][0],nums2[j][1]});\\n                j++;\\n            }\\n        }\\n        while(i<n)\\n        {\\n            ans.push_back({nums1[i][0],nums1[i][1]});\\n            i++;\\n        }\\n        while(j<m)\\n        {\\n            ans.push_back({nums2[j][0],nums2[j][1]});\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n        vector<vector<int>>ans;\\n        int i=0,j=0;\\n        int n=nums1.size(),m=nums2.size();\\n        while(i<n && j<m)\\n        {\\n            if(nums1[i][0]==nums2[j][0])\\n            {\\n                ans.push_back({nums1[i][0],nums1[i][1]+nums2[j][1]});\\n                i++;\\n                j++;\\n            }else if(nums1[i][0]<nums2[j][0])\\n            {\\n                ans.push_back({nums1[i][0],nums1[i][1]});\\n                i++;\\n            }else{\\n                ans.push_back({nums2[j][0],nums2[j][1]});\\n                j++;\\n            }\\n        }\\n        while(i<n)\\n        {\\n            ans.push_back({nums1[i][0],nums1[i][1]});\\n            i++;\\n        }\\n        while(j<m)\\n        {\\n            ans.push_back({nums2[j][0],nums2[j][1]});\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203784,
                "title": "python3-2-pointer-approach",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/485c537c6fa9056ce656959ea352d2a68cef473f) for solutions of weekly 333. \\n\\n```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        ans = []\\n        i = j = 0 \\n        while i < len(nums1) or j < len(nums2): \\n            if j == len(nums2) or i < len(nums1) and nums1[i][0] <= nums2[j][0]: \\n                ans.append(nums1[i])\\n                i += 1\\n            else: \\n                if ans and ans[-1][0] == nums2[j][0]: ans[-1][1] += nums2[j][1]\\n                else: ans.append(nums2[j])\\n                j += 1\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        ans = []\\n        i = j = 0 \\n        while i < len(nums1) or j < len(nums2): \\n            if j == len(nums2) or i < len(nums1) and nums1[i][0] <= nums2[j][0]: \\n                ans.append(nums1[i])\\n                i += 1\\n            else: \\n                if ans and ans[-1][0] == nums2[j][0]: ans[-1][1] += nums2[j][1]\\n                else: ans.append(nums2[j])\\n                j += 1\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203737,
                "title": "best-solution-in-c-o-1-sc-mergesortalgo",
                "content": "# Complexity\\n- Time complexity:\\nO(n) where n is max(n1,n2)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n#### **PLease Upvote if u liked my Solution**\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n        vector<vector<int>> ans;\\n        int i=0,j=0,n1=nums1.size(),n2=nums2.size();\\n        while(i<n1 && j<n2){\\n            if(nums1[i][0]==nums2[j][0]){\\n                ans.push_back({nums1[i][0],nums1[i][1]+nums2[j][1]});\\n                i++;j++;\\n            }\\n            else if(nums1[i][0]<nums2[j][0]){\\n                ans.push_back(nums1[i]);\\n                i++;\\n            }\\n            else{\\n                ans.push_back(nums2[j]);\\n                j++;\\n            }\\n        }\\n        while(i<n1){\\n            ans.push_back(nums1[i++]);\\n        }\\n        while(j<n2){\\n            ans.push_back(nums2[j++]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n        vector<vector<int>> ans;\\n        int i=0,j=0,n1=nums1.size(),n2=nums2.size();\\n        while(i<n1 && j<n2){\\n            if(nums1[i][0]==nums2[j][0]){\\n                ans.push_back({nums1[i][0],nums1[i][1]+nums2[j][1]});\\n                i++;j++;\\n            }\\n            else if(nums1[i][0]<nums2[j][0]){\\n                ans.push_back(nums1[i]);\\n                i++;\\n            }\\n            else{\\n                ans.push_back(nums2[j]);\\n                j++;\\n            }\\n        }\\n        while(i<n1){\\n            ans.push_back(nums1[i++]);\\n        }\\n        while(j<n2){\\n            ans.push_back(nums2[j++]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4008729,
                "title": "java-simple-and-clear-solution",
                "content": "# Approach\\n\\n1. Initialize an empty ans list to store the merged results.\\n\\n2. Initialize counters i and j to track positions in nums1 and nums2.\\n\\n3. Start a loop that continues as long as there are elements in either nums1 or nums2 to process.\\n\\n4. Create a temporary list al to represent a merged element.\\n\\n5. If both nums1 and nums2 have an element with the same id at positions i and j, merge their values and add the id and merged value to al. Increment both i and j.\\n\\n6. If the ids are not equal, add the smaller id and its corresponding value to al, depending on which array has the smaller id. Increment the corresponding index (i or j) accordingly.\\n\\n7. Add al to the ans list.\\n\\n8. After processing all elements, determine the number of rows and columns in ans and create a new 2D array nums. Copy the values from ans to nums.\\n\\n9. Return nums as the merged and sorted 2D array.\\n\\n# Complexity\\n-n1 = length of nums1\\n-n2 = length of nums2\\n- Time complexity:  Time complexity of the code is O(n1 + n2).\\n\\n- Space complexity: Space complexity of the code is O(n1 + n2).\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        ArrayList<ArrayList<Integer>> ans=new ArrayList<>();\\n        int n1=nums1.length;\\n        int n2=nums2.length;\\n        int i=0,j=0;\\n        while(i<n1 || j<n2){\\n            ArrayList<Integer> al=new ArrayList<>();\\n            if(i<n1 && j<n2 && nums1[i][0]==nums2[j][0]){\\n                al.add(nums1[i][0]);\\n                int c=nums1[i][1]+nums2[j][1];\\n                al.add(c);\\n                i++;\\n                j++;\\n                ans.add(al);\\n            }\\n            else if(i<n1 && (j>=n2 || nums1[i][0]<nums2[j][0])){\\n                al.add(nums1[i][0]);\\n                al.add(nums1[i][1]);\\n                ans.add(al);\\n                i++;\\n            }\\n            else if(j<n2){\\n                al.add(nums2[j][0]);\\n                al.add(nums2[j][1]);\\n                ans.add(al);\\n                j++;\\n            }\\n        }\\n        int n=ans.size();\\n        int c1=ans.get(0).size();\\n        int nums[][]=new int[n][c1];\\n        for(int r=0;r<n;r++){\\n            for(int ci=0;ci<c1;ci++){\\n                nums[r][ci]=ans.get(r).get(ci);\\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        ArrayList<ArrayList<Integer>> ans=new ArrayList<>();\\n        int n1=nums1.length;\\n        int n2=nums2.length;\\n        int i=0,j=0;\\n        while(i<n1 || j<n2){\\n            ArrayList<Integer> al=new ArrayList<>();\\n            if(i<n1 && j<n2 && nums1[i][0]==nums2[j][0]){\\n                al.add(nums1[i][0]);\\n                int c=nums1[i][1]+nums2[j][1];\\n                al.add(c);\\n                i++;\\n                j++;\\n                ans.add(al);\\n            }\\n            else if(i<n1 && (j>=n2 || nums1[i][0]<nums2[j][0])){\\n                al.add(nums1[i][0]);\\n                al.add(nums1[i][1]);\\n                ans.add(al);\\n                i++;\\n            }\\n            else if(j<n2){\\n                al.add(nums2[j][0]);\\n                al.add(nums2[j][1]);\\n                ans.add(al);\\n                j++;\\n            }\\n        }\\n        int n=ans.size();\\n        int c1=ans.get(0).size();\\n        int nums[][]=new int[n][c1];\\n        for(int r=0;r<n;r++){\\n            for(int ci=0;ci<c1;ci++){\\n                nums[r][ci]=ans.get(r).get(ci);\\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4008582,
                "title": "easy-solution-in-python-beats-98-of-users-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def mergeArrays(self, nums1, nums2):\\n        nums3 = []\\n        i,j=0,0\\n        while i<len(nums1) and j<len(nums2):\\n            id1 = nums1[i][0]\\n            id2 = nums2[j][0]\\n            if id1 == id2:\\n                nums1[i][-1] += nums2[j][-1]\\n                nums3.append(nums1[i])\\n                i += 1\\n                j += 1\\n            \\n            elif id1 < id2:\\n                nums3.append(nums1[i])\\n                i += 1\\n            else:\\n                nums3.append(nums2[j])\\n                j += 1\\n        \\n    \\n        nums3.extend(nums1[i:])\\n        nums3.extend(nums2[j:])\\n        \\n        return nums3\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def mergeArrays(self, nums1, nums2):\\n        nums3 = []\\n        i,j=0,0\\n        while i<len(nums1) and j<len(nums2):\\n            id1 = nums1[i][0]\\n            id2 = nums2[j][0]\\n            if id1 == id2:\\n                nums1[i][-1] += nums2[j][-1]\\n                nums3.append(nums1[i])\\n                i += 1\\n                j += 1\\n            \\n            elif id1 < id2:\\n                nums3.append(nums1[i])\\n                i += 1\\n            else:\\n                nums3.append(nums2[j])\\n                j += 1\\n        \\n    \\n        nums3.extend(nums1[i:])\\n        nums3.extend(nums2[j:])\\n        \\n        return nums3\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4008573,
                "title": "easy-solution-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def mergeArrays(self, nums1, nums2):\\n        nums3 = []\\n        i,j=0,0\\n        while i<len(nums1) and j<len(nums2):\\n            id1 = nums1[i][0]\\n            id2 = nums2[j][0]\\n            if id1 == id2:\\n                nums1[i][-1] += nums2[j][-1]\\n                nums3.append(nums1[i])\\n                i += 1\\n                j += 1\\n            \\n            elif id1 < id2:\\n                nums3.append(nums1[i])\\n                i += 1\\n            else:\\n                nums3.append(nums2[j])\\n                j += 1\\n        \\n    \\n        nums3.extend(nums1[i:])\\n        nums3.extend(nums2[j:])\\n        \\n        return nums3\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def mergeArrays(self, nums1, nums2):\\n        nums3 = []\\n        i,j=0,0\\n        while i<len(nums1) and j<len(nums2):\\n            id1 = nums1[i][0]\\n            id2 = nums2[j][0]\\n            if id1 == id2:\\n                nums1[i][-1] += nums2[j][-1]\\n                nums3.append(nums1[i])\\n                i += 1\\n                j += 1\\n            \\n            elif id1 < id2:\\n                nums3.append(nums1[i])\\n                i += 1\\n            else:\\n                nums3.append(nums2[j])\\n                j += 1\\n        \\n    \\n        nums3.extend(nums1[i:])\\n        nums3.extend(nums2[j:])\\n        \\n        return nums3\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3499312,
                "title": "c-easy-solution-two-pointers-no-sorting-maps",
                "content": "## Complexity\\n- Time complexity: $$O(n+m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n        int i=0, j=0;\\n        vector<vector<int>> ans;\\n        while (i<nums1.size() && j<nums2.size()){\\n            if (nums1[i][0]==nums2[j][0]){\\n                ans.push_back({nums1[i][0],(nums1[i][1]+nums2[j][1])});\\n                i++; j++;\\n            }\\n            else if (nums1[i][0]<nums2[j][0]){\\n                ans.push_back(nums1[i]);\\n                i++;\\n            }\\n            else{\\n                ans.push_back(nums2[j]);\\n                j++;\\n            }\\n        }\\n        while (i<nums1.size()){\\n            ans.push_back(nums1[i++]);\\n        }\\n        while (j<nums2.size())ans.push_back(nums2[j++]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n        int i=0, j=0;\\n        vector<vector<int>> ans;\\n        while (i<nums1.size() && j<nums2.size()){\\n            if (nums1[i][0]==nums2[j][0]){\\n                ans.push_back({nums1[i][0],(nums1[i][1]+nums2[j][1])});\\n                i++; j++;\\n            }\\n            else if (nums1[i][0]<nums2[j][0]){\\n                ans.push_back(nums1[i]);\\n                i++;\\n            }\\n            else{\\n                ans.push_back(nums2[j]);\\n                j++;\\n            }\\n        }\\n        while (i<nums1.size()){\\n            ans.push_back(nums1[i++]);\\n        }\\n        while (j<nums2.size())ans.push_back(nums2[j++]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423857,
                "title": "c-runtime-4-ms-97-31-faster-hash-table-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n        vector<vector<int>>ans;\\n        map<int,int>mp;\\n        for(int i=0;i<nums1.size();i++){\\n            mp[nums1[i][0]]=nums1[i][1];\\n        }\\n        for(int i=0;i<nums2.size();i++){\\n            mp[nums2[i][0]]+=nums2[i][1];\\n        }\\n        for(auto i:mp){\\n            ans.push_back({i.first,i.second});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n        vector<vector<int>>ans;\\n        map<int,int>mp;\\n        for(int i=0;i<nums1.size();i++){\\n            mp[nums1[i][0]]=nums1[i][1];\\n        }\\n        for(int i=0;i<nums2.size();i++){\\n            mp[nums2[i][0]]+=nums2[i][1];\\n        }\\n        for(auto i:mp){\\n            ans.push_back({i.first,i.second});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381615,
                "title": "java-simple-and-clear-solution",
                "content": "# Complexity\\n- Time complexity: O(n1+n2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n1+n2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n      List<int[]> list = new ArrayList();\\n      int[][] result;\\n      int ind1= 0, ind2 = 0;\\n      int n1 = nums1.length;\\n      int n2 = nums2.length;\\n\\n      while(ind1 < n1 && ind2 < n2){\\n         if(nums1[ind1][0] == nums2[ind2][0]){\\n             nums1[ind1][1]+=nums2[ind2][1];\\n             list.add(nums1[ind1]);\\n             ind1++;\\n             ind2++;\\n         }else if(nums1[ind1][0] < nums2[ind2][0]){\\n             list.add(nums1[ind1]);\\n             ind1++;\\n         }else{\\n             list.add(nums2[ind2]);\\n             ind2++;\\n         }\\n      }\\n\\n      while(ind1 < n1){\\n          list.add(nums1[ind1]);\\n          ind1++;\\n      }  \\n\\n      while(ind2 < n2){\\n          list.add(nums2[ind2]);\\n          ind2++;\\n      }\\n\\n      result = new int[list.size()][2];\\n      \\n      for(int i = 0; i < list.size(); i++)\\n          result[i] = list.get(i);\\n\\n      return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n      List<int[]> list = new ArrayList();\\n      int[][] result;\\n      int ind1= 0, ind2 = 0;\\n      int n1 = nums1.length;\\n      int n2 = nums2.length;\\n\\n      while(ind1 < n1 && ind2 < n2){\\n         if(nums1[ind1][0] == nums2[ind2][0]){\\n             nums1[ind1][1]+=nums2[ind2][1];\\n             list.add(nums1[ind1]);\\n             ind1++;\\n             ind2++;\\n         }else if(nums1[ind1][0] < nums2[ind2][0]){\\n             list.add(nums1[ind1]);\\n             ind1++;\\n         }else{\\n             list.add(nums2[ind2]);\\n             ind2++;\\n         }\\n      }\\n\\n      while(ind1 < n1){\\n          list.add(nums1[ind1]);\\n          ind1++;\\n      }  \\n\\n      while(ind2 < n2){\\n          list.add(nums2[ind2]);\\n          ind2++;\\n      }\\n\\n      result = new int[list.size()][2];\\n      \\n      for(int i = 0; i < list.size(); i++)\\n          result[i] = list.get(i);\\n\\n      return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368612,
                "title": "python-solution",
                "content": "\\n```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n\\n        D = defaultdict(lambda:0) \\n        for n in nums1: \\n            D[n[0]] += n[1]\\n\\n        for n in nums2:\\n            D[n[0]] += n[1]\\n\\n        res = [] \\n\\n        for k in sorted(D.keys()):\\n            tmp = [k,D[k]]\\n            res.append(tmp)\\n\\n        return res\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n\\n        D = defaultdict(lambda:0) \\n        for n in nums1: \\n            D[n[0]] += n[1]\\n\\n        for n in nums2:\\n            D[n[0]] += n[1]\\n\\n        res = [] \\n\\n        for k in sorted(D.keys()):\\n            tmp = [k,D[k]]\\n            res.append(tmp)\\n\\n        return res\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362177,
                "title": "c-straightforward-clean-code-using-hashtable",
                "content": "**Please Upvote, if you like the solution.**\\n\\n\\n\\n```\\n     vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) { \\n        vector<vector<int>> ans;\\n        int hash[1001]={0};\\n\\t\\t//Adding values of Nums1 array\\n        for(int i=0;i<nums1.size();i++){\\n            hash[nums1[i][0]]+=nums1[i][1];\\n        }      \\n\\t\\t //Adding the values of Nums2 array\\n        for(int i=0;i<nums2.size();i++){\\n           hash[nums2[i][0]]+=nums2[i][1];\\n        }\\n\\t\\t\\n        for(int i=0;i<1001;i++){\\n            if(hash[i]==0)continue;    //if the value in hashtable is NULL or 0, continue\\n            else{    //if there is a value \\n                vector<int>temp={i,hash[i]};    \\n                ans.push_back(temp);   //Add it into answer matrix\\n            }\\n        }\\n        return ans;\\n    }\\n\\t",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "**Please Upvote, if you like the solution.**\\n\\n\\n\\n```\\n     vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) { \\n        vector<vector<int>> ans;\\n        int hash[1001]={0};\\n\\t\\t//Adding values of Nums1 array\\n        for(int i=0;i<nums1.size();i++){\\n            hash[nums1[i][0]]+=nums1[i][1];\\n        }      \\n\\t\\t //Adding the values of Nums2 array\\n        for(int i=0;i<nums2.size();i++){\\n           hash[nums2[i][0]]+=nums2[i][1];\\n        }\\n\\t\\t\\n        for(int i=0;i<1001;i++){\\n            if(hash[i]==0)continue;    //if the value in hashtable is NULL or 0, continue\\n            else{    //if there is a value \\n                vector<int>temp={i,hash[i]};    \\n                ans.push_back(temp);   //Add it into answer matrix\\n            }\\n        }\\n        return ans;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 3297081,
                "title": "easy-to-understand-must-see",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) \\n    {\\n        map<int,int>mp;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            int id = nums1[i][0];\\n            int val = nums1[i][1];\\n            mp[id]+=val;\\n        }\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            int id = nums2[i][0];\\n            int val = nums2[i][1];\\n            mp[id]+=val;\\n        }\\n        vector<vector<int>>ans;\\n        for(auto it = mp.begin();it!=mp.end();it++)\\n        {\\n            int id = it->first;\\n            int val = it->second;\\n            ans.push_back({id,val});\\n        }    \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) \\n    {\\n        map<int,int>mp;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            int id = nums1[i][0];\\n            int val = nums1[i][1];\\n            mp[id]+=val;\\n        }\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            int id = nums2[i][0];\\n            int val = nums2[i][1];\\n            mp[id]+=val;\\n        }\\n        vector<vector<int>>ans;\\n        for(auto it = mp.begin();it!=mp.end();it++)\\n        {\\n            int id = it->first;\\n            int val = it->second;\\n            ans.push_back({id,val});\\n        }    \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3296973,
                "title": "merge-two-2d-arrays-by-summing-values-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n        int i, j, flag=0;\\n        for(i=0 ; i<nums2.size() ; i++)\\n        {\\n            flag=0;\\n            for(j=0 ; j<nums1.size() ; j++)\\n            {\\n                if(nums1[j][0]==nums2[i][0])\\n                {\\n                    nums1[j][1] += nums2[i][1];\\n                    flag=1;\\n                    break;\\n                }\\n            }\\n            if(flag==0)\\n            {\\n                nums1.push_back(nums2[i]);\\n            }\\n        }\\n        sort(nums1.begin(), nums1.end());\\n        return nums1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n        int i, j, flag=0;\\n        for(i=0 ; i<nums2.size() ; i++)\\n        {\\n            flag=0;\\n            for(j=0 ; j<nums1.size() ; j++)\\n            {\\n                if(nums1[j][0]==nums2[i][0])\\n                {\\n                    nums1[j][1] += nums2[i][1];\\n                    flag=1;\\n                    break;\\n                }\\n            }\\n            if(flag==0)\\n            {\\n                nums1.push_back(nums2[i]);\\n            }\\n        }\\n        sort(nums1.begin(), nums1.end());\\n        return nums1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258454,
                "title": "java-solution-without-hashmap-or-arraylist-2ms-simple-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nfirst off all we have to add the values of common id\\'s in both the arrays .\\nand then  merge them to form an array on it\\'s own while maintianing the order . \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nwhile merging the array after adding the values of same id\\'s we also need to have an idea of the size of the resultant array . \\nthis is why because the return type is in 2d array format so we need to make the resultant array in 2d array format , thus we must know the size . \\nlets suppose the max id on both the array is n then the resultant array can not be more then n . hence the consider this as size. \\n\\naccording to id we mark the index of array and then we put the values \\nand also adding the previous values if any avialble .\\n\\nIt is not necessary that all the id\\'s will be continues thus we count the blank one and make the final size of array .\\n\\nat last add all the array whose id\\'s is not starting with zero\\'s and \\nthen return the final array \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\ntime complexity O(N)\\n\\n\\n\\n\\n# if you liked the solution please vote up , you can also ping me \\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        int max = Math.max(nums1[nums1.length - 1][0], nums2[nums2.length - 1][0]);\\n        int[][] ans = new int[max][2];\\n\\n        for ( int[] ints : nums1 ) {\\n            ans[ints[0] - 1][0] = ints[0];\\n            ans[ints[0] - 1][1] = ans[ints[0] - 1][1] + ints[1];\\n        }\\n        for ( int[] ints : nums2 ) {\\n            ans[ints[0] - 1][0] = ints[0];\\n            ans[ints[0] - 1][1] = ans[ints[0] - 1][1] + ints[1];\\n        }\\n        int count = 0;\\n\\n        for ( int[] an : ans ) if ( an[0] != 0 ) count++;\\n\\n        int[][] fans = new int[count][2];\\n        count = 0;\\n\\n        for ( int[] an : ans )\\n            if ( an[0] != 0 )\\n                fans[count++] = an;\\n        \\n        return fans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        int max = Math.max(nums1[nums1.length - 1][0], nums2[nums2.length - 1][0]);\\n        int[][] ans = new int[max][2];\\n\\n        for ( int[] ints : nums1 ) {\\n            ans[ints[0] - 1][0] = ints[0];\\n            ans[ints[0] - 1][1] = ans[ints[0] - 1][1] + ints[1];\\n        }\\n        for ( int[] ints : nums2 ) {\\n            ans[ints[0] - 1][0] = ints[0];\\n            ans[ints[0] - 1][1] = ans[ints[0] - 1][1] + ints[1];\\n        }\\n        int count = 0;\\n\\n        for ( int[] an : ans ) if ( an[0] != 0 ) count++;\\n\\n        int[][] fans = new int[count][2];\\n        count = 0;\\n\\n        for ( int[] an : ans )\\n            if ( an[0] != 0 )\\n                fans[count++] = an;\\n        \\n        return fans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257709,
                "title": "c-2-pointer-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n        int idx1 = 0, idx2 = 0;\\n        vector<vector<int>> res;\\n        while (idx1 < nums1.size() && idx2 < nums2.size()) {\\n            if (nums1[idx1][0] == nums2[idx2][0]) {\\n                vector<int> sum = {nums1[idx1][0], nums1[idx1][1] + nums2[idx2][1]}; \\n                res.push_back(sum);\\n                idx1 += 1;\\n                idx2 += 1;\\n            } else if (nums1[idx1][0] < nums2[idx2][0]) {\\n                res.push_back(nums1[idx1]);\\n                idx1 += 1;\\n            } else {\\n                res.push_back(nums2[idx2]);\\n                idx2 += 1;\\n            }\\n        }\\n        while (idx1 < nums1.size()) {\\n            res.push_back(nums1[idx1]);\\n            idx1 += 1;\\n        }\\n        while (idx2 < nums2.size()) {\\n            res.push_back(nums2[idx2]);\\n            idx2 += 1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n        int idx1 = 0, idx2 = 0;\\n        vector<vector<int>> res;\\n        while (idx1 < nums1.size() && idx2 < nums2.size()) {\\n            if (nums1[idx1][0] == nums2[idx2][0]) {\\n                vector<int> sum = {nums1[idx1][0], nums1[idx1][1] + nums2[idx2][1]}; \\n                res.push_back(sum);\\n                idx1 += 1;\\n                idx2 += 1;\\n            } else if (nums1[idx1][0] < nums2[idx2][0]) {\\n                res.push_back(nums1[idx1]);\\n                idx1 += 1;\\n            } else {\\n                res.push_back(nums2[idx2]);\\n                idx2 += 1;\\n            }\\n        }\\n        while (idx1 < nums1.size()) {\\n            res.push_back(nums1[idx1]);\\n            idx1 += 1;\\n        }\\n        while (idx2 < nums2.size()) {\\n            res.push_back(nums2[idx2]);\\n            idx2 += 1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3249223,
                "title": "java-using-treemap-simple-easy",
                "content": "# Java\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        \\n        Map<Integer, Integer> map = new TreeMap<>();\\n        int l1 = nums1.length;\\n        int l2 = nums2.length;\\n\\n        for (int i = 0; i < l1; i++) {\\n            if (!map.containsKey(nums1[i][0])) {\\n                map.put(nums1[i][0], nums1[i][1]);\\n            }\\n            else {\\n                map.put(nums1[i][0], (map.get(nums1[i][0]) + nums1[i][1]));\\n            }\\n            \\n        }\\n\\n        for (int i = 0; i < l2; i++) {\\n            if (!map.containsKey(nums2[i][0])) {\\n                map.put(nums2[i][0], nums2[i][1]);\\n            }\\n            else {\\n                map.put(nums2[i][0], (map.get(nums2[i][0]) + nums2[i][1]));\\n            }\\n            \\n        }\\n\\n        int count = 0;\\n        int[][] ans = new int[map.size()][2];\\n\\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\\n            ans[count][0] = entry.getKey();\\n            ans[count][1] = entry.getValue();\\n            count++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        \\n        Map<Integer, Integer> map = new TreeMap<>();\\n        int l1 = nums1.length;\\n        int l2 = nums2.length;\\n\\n        for (int i = 0; i < l1; i++) {\\n            if (!map.containsKey(nums1[i][0])) {\\n                map.put(nums1[i][0], nums1[i][1]);\\n            }\\n            else {\\n                map.put(nums1[i][0], (map.get(nums1[i][0]) + nums1[i][1]));\\n            }\\n            \\n        }\\n\\n        for (int i = 0; i < l2; i++) {\\n            if (!map.containsKey(nums2[i][0])) {\\n                map.put(nums2[i][0], nums2[i][1]);\\n            }\\n            else {\\n                map.put(nums2[i][0], (map.get(nums2[i][0]) + nums2[i][1]));\\n            }\\n            \\n        }\\n\\n        int count = 0;\\n        int[][] ans = new int[map.size()][2];\\n\\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\\n            ans[count][0] = entry.getKey();\\n            ans[count][1] = entry.getValue();\\n            count++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3238538,
                "title": "java-map",
                "content": "# Complexity\\n- Time complexity: O(NlogN)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        Map<Integer, Integer> map = new TreeMap<>();\\n        for (int[] arr : nums1) map.put(arr[0], arr[1]);\\n        for (int[] arr : nums2) map.put(arr[0], map.getOrDefault(arr[0], 0) + arr[1]);\\n        int[][] res = new int[map.size()][2];\\n        int count = 0;\\n        for (int key : map.keySet()) {\\n            res[count][0] = key;\\n            res[count++][1] = map.get(key);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        Map<Integer, Integer> map = new TreeMap<>();\\n        for (int[] arr : nums1) map.put(arr[0], arr[1]);\\n        for (int[] arr : nums2) map.put(arr[0], map.getOrDefault(arr[0], 0) + arr[1]);\\n        int[][] res = new int[map.size()][2];\\n        int count = 0;\\n        for (int key : map.keySet()) {\\n            res[count][0] = key;\\n            res[count++][1] = map.get(key);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3222858,
                "title": "c-o-m-n-time-o-m-n-space-best-explanation",
                "content": "**Approach:**\\nThe given problem can be solved by merging two sorted arrays into a single sorted array while summing the values of elements with the same id. To merge the arrays, we can use a two-pointer approach, where we use two pointers to traverse the two arrays and compare their elements to decide which element should be added to the merged array.\\n\\n**Intuition:**\\nWe start by initializing two pointers, i and j, at the beginning of the two input arrays, n1 and n2, respectively. We compare the elements at i and j, and add the element with the smaller id to the merged array. If both elements have the same id, we sum their values and add the result to the merged array. We then increment the pointer of the array from which we added an element. We repeat this process until we reach the end of both arrays. If we reach the end of one of the arrays, we simply add the remaining elements of the other array to the merged array.\\n\\n**Time complexity:**\\nThe time complexity of this approach is O(m+n), where m and n are the lengths of the input arrays n1 and n2, respectively. This is because we traverse both arrays once to merge them, and the time taken for each comparison and element addition operation is constant.\\n\\n**Space complexity:**\\nThe space complexity of this approach is also O(m+n), where m and n are the lengths of the input arrays n1 and n2, respectively. This is because we create a new array to store the merged array, which can have at most m+n elements.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& n1, vector<vector<int>>& n2) {\\n        vector<vector<int>>v;\\n        int i =0 ; int j = 0;\\n\\n        while (i < n1.size() || j < n2.size()) {\\n            if (i < n1.size() && j < n2.size() && n1[i][0] == n2[j][0]) {\\n                v.push_back({n1[i][0], (n1[i][1] + n2[j][1])});\\n                i++;\\n                j++;\\n            } else if (j == n2.size() || i < n1.size() && n1[i][0] < n2[j][0]) {\\n                v.push_back(n1[i]);\\n                i++;\\n            } else {\\n                v.push_back(n2[j]);\\n                j++;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& n1, vector<vector<int>>& n2) {\\n        vector<vector<int>>v;\\n        int i =0 ; int j = 0;\\n\\n        while (i < n1.size() || j < n2.size()) {\\n            if (i < n1.size() && j < n2.size() && n1[i][0] == n2[j][0]) {\\n                v.push_back({n1[i][0], (n1[i][1] + n2[j][1])});\\n                i++;\\n                j++;\\n            } else if (j == n2.size() || i < n1.size() && n1[i][0] < n2[j][0]) {\\n                v.push_back(n1[i]);\\n                i++;\\n            } else {\\n                v.push_back(n2[j]);\\n                j++;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3218283,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n        vector<vector<int>> ans;\\n     int i=0;\\n     int j=0;\\n     int n=nums1.size();\\n     int m=nums2.size();\\n     while(i<n && j<m){\\n         int id1=nums1[i][0];\\n         int id2=nums2[j][0];\\n         if(id1==id2){\\n             int sum=nums1[i][1]+nums2[j][1];\\n             ans.push_back({id1,sum});\\n             i++;\\n             j++;\\n         }else if(id1>id2){\\n             ans.push_back({id2,nums2[j][1]});\\n             j++;\\n         }else{\\n             ans.push_back({id1,nums1[i][1]});\\n             i++;\\n         }\\n\\n     }\\n     while(i<n){\\n         int id1=nums1[i][0];\\n         ans.push_back({id1,nums1[i][1]});\\n         i++;\\n     }\\n      while(j<m){\\n         int id2=nums2[j][0];\\n         ans.push_back({id2,nums2[j][1]});\\n         j++;\\n     }\\n     return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n        vector<vector<int>> ans;\\n     int i=0;\\n     int j=0;\\n     int n=nums1.size();\\n     int m=nums2.size();\\n     while(i<n && j<m){\\n         int id1=nums1[i][0];\\n         int id2=nums2[j][0];\\n         if(id1==id2){\\n             int sum=nums1[i][1]+nums2[j][1];\\n             ans.push_back({id1,sum});\\n             i++;\\n             j++;\\n         }else if(id1>id2){\\n             ans.push_back({id2,nums2[j][1]});\\n             j++;\\n         }else{\\n             ans.push_back({id1,nums1[i][1]});\\n             i++;\\n         }\\n\\n     }\\n     while(i<n){\\n         int id1=nums1[i][0];\\n         ans.push_back({id1,nums1[i][1]});\\n         i++;\\n     }\\n      while(j<m){\\n         int id2=nums2[j][0];\\n         ans.push_back({id2,nums2[j][1]});\\n         j++;\\n     }\\n     return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3218261,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n        vector<vector<int>>v;\\n        map<int, int>m, m1;\\n        for(int i=0; i<nums1.size(); i++){\\n            m[nums1[i][0]]=nums1[i][1];\\n            m1[nums1[i][0]]=i;\\n        }\\n        for(int i=0; i<nums2.size(); i++){\\n            if(m.find(nums2[i][0])!=m.end()){\\n                int pos=m1[nums2[i][0]];\\n                nums1[pos][1]=nums1[pos][1]+nums2[i][1];\\n                m[nums1[pos][0]]=nums1[pos][1];\\n            }\\n            else{\\n                vector<int>temp;\\n                temp.push_back(nums2[i][0]);\\n                temp.push_back(nums2[i][1]);\\n                nums1.push_back(temp);\\n                m[nums2[i][0]]=nums2[i][1];\\n                m1[nums2[i][0]]=nums1.size()-1;\\n            }\\n        }\\n        sort(nums1.begin(), nums1.end());\\n        return nums1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n        vector<vector<int>>v;\\n        map<int, int>m, m1;\\n        for(int i=0; i<nums1.size(); i++){\\n            m[nums1[i][0]]=nums1[i][1];\\n            m1[nums1[i][0]]=i;\\n        }\\n        for(int i=0; i<nums2.size(); i++){\\n            if(m.find(nums2[i][0])!=m.end()){\\n                int pos=m1[nums2[i][0]];\\n                nums1[pos][1]=nums1[pos][1]+nums2[i][1];\\n                m[nums1[pos][0]]=nums1[pos][1];\\n            }\\n            else{\\n                vector<int>temp;\\n                temp.push_back(nums2[i][0]);\\n                temp.push_back(nums2[i][1]);\\n                nums1.push_back(temp);\\n                m[nums2[i][0]]=nums2[i][1];\\n                m1[nums2[i][0]]=nums1.size()-1;\\n            }\\n        }\\n        sort(nums1.begin(), nums1.end());\\n        return nums1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3215788,
                "title": "python3-four-methods",
                "content": "# Code Save All Sums\\n```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        all_values = [0] * 1001\\n        for a,b in nums1:\\n            all_values[a] += b\\n        for a,b in nums2:\\n            all_values[a] += b\\n        return [[a,b] for a,b in enumerate(all_values) if b != 0]\\n```\\n\\n# Code Build New Array\\n```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        ret = []\\n        while nums1 and nums2:\\n            if nums1[0][0] == nums2[0][0]:\\n                arr1 = nums1.pop(0)\\n                arr2 = nums2.pop(0)\\n                arr1[-1] += arr2[-1]\\n                ret.append(arr1)\\n            elif nums1[0][0] > nums2[0][0]:\\n                ret.append(nums2.pop(0))\\n            else:\\n                ret.append(nums1.pop(0))\\n        ret.extend(nums1)\\n        ret.extend(nums2)\\n        return ret\\n```\\n\\n# Code Modify Longest Array In Place\\n```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        if len(nums2) > len(nums1):\\n            nums1, nums2 = nums2, nums1\\n        i = 0\\n        j = 0\\n        while i < len(nums1) and j < len(nums2):\\n            if nums1[i][0] == nums2[j][0]:\\n                nums1[i][1] += nums2[j][1]\\n                i, j = i + 1, j + 1\\n            elif nums1[i][0] < nums2[j][0]:\\n                i += 1\\n            else:\\n                nums1.insert(i, nums2[j])\\n                i, j = i + 1, j + 1\\n        if j != len(nums2):\\n            nums1.extend(nums2[j:])\\n        return nums1\\n```\\n\\n\\n# Code Use Default Dictionary\\n```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        d1, d2 = defaultdict(int, {a:b for a,b in nums1}), defaultdict(int, {a:b for a,b in nums2})\\n        return [[k, d1[k] + d2[k]] for k in sorted(set(d1.keys()).union(set(d2.keys())))]\\n        \\n```\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        all_values = [0] * 1001\\n        for a,b in nums1:\\n            all_values[a] += b\\n        for a,b in nums2:\\n            all_values[a] += b\\n        return [[a,b] for a,b in enumerate(all_values) if b != 0]\\n```\n```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        ret = []\\n        while nums1 and nums2:\\n            if nums1[0][0] == nums2[0][0]:\\n                arr1 = nums1.pop(0)\\n                arr2 = nums2.pop(0)\\n                arr1[-1] += arr2[-1]\\n                ret.append(arr1)\\n            elif nums1[0][0] > nums2[0][0]:\\n                ret.append(nums2.pop(0))\\n            else:\\n                ret.append(nums1.pop(0))\\n        ret.extend(nums1)\\n        ret.extend(nums2)\\n        return ret\\n```\n```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        if len(nums2) > len(nums1):\\n            nums1, nums2 = nums2, nums1\\n        i = 0\\n        j = 0\\n        while i < len(nums1) and j < len(nums2):\\n            if nums1[i][0] == nums2[j][0]:\\n                nums1[i][1] += nums2[j][1]\\n                i, j = i + 1, j + 1\\n            elif nums1[i][0] < nums2[j][0]:\\n                i += 1\\n            else:\\n                nums1.insert(i, nums2[j])\\n                i, j = i + 1, j + 1\\n        if j != len(nums2):\\n            nums1.extend(nums2[j:])\\n        return nums1\\n```\n```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        d1, d2 = defaultdict(int, {a:b for a,b in nums1}), defaultdict(int, {a:b for a,b in nums2})\\n        return [[k, d1[k] + d2[k]] for k in sorted(set(d1.keys()).union(set(d2.keys())))]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3212313,
                "title": "counting-sort-suitable-for-fixed-range-of-ids-1-ms-beat-97",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince the possible IDs are limited in a fixed range of 1 to 1000. It\\'s intuitive to thinking about counting sort, which uses the index of a **count** array to sort elements.\\n\\nThe basic idea is that the value of **id_i** will be stored in **count[id_i]**. Then we simply collect all the elements that are non-zero.\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        int largestID = Math.max(nums1[nums1.length - 1][0], nums2[nums2.length - 1][0]);\\n        int[] count = new int[largestID + 1];\\n        for (int i = 0; i < nums1.length; i++) {\\n            count[nums1[i][0]] += nums1[i][1];\\n        }\\n\\n        int counter = nums1.length; // Num of unique ids.\\n        for (int i = 0; i < nums2.length; i++) {\\n            if (count[nums2[i][0]] == 0)\\n                counter++;\\n            count[nums2[i][0]] += nums2[i][1];\\n        }\\n        \\n        int[][] res = new int[counter][2];\\n        for (int i = 1, j = 0; i <= largestID; i++) {\\n            if (count[i] != 0) {\\n                res[j][0] = i;\\n                res[j][1] = count[i];\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        int largestID = Math.max(nums1[nums1.length - 1][0], nums2[nums2.length - 1][0]);\\n        int[] count = new int[largestID + 1];\\n        for (int i = 0; i < nums1.length; i++) {\\n            count[nums1[i][0]] += nums1[i][1];\\n        }\\n\\n        int counter = nums1.length; // Num of unique ids.\\n        for (int i = 0; i < nums2.length; i++) {\\n            if (count[nums2[i][0]] == 0)\\n                counter++;\\n            count[nums2[i][0]] += nums2[i][1];\\n        }\\n        \\n        int[][] res = new int[counter][2];\\n        for (int i = 1, j = 0; i <= largestID; i++) {\\n            if (count[i] != 0) {\\n                res[j][0] = i;\\n                res[j][1] = count[i];\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3211547,
                "title": "very-easy-and-fast-solution-beats-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        List<int[]> al = new ArrayList<>();\\n        int i=0;\\n        int j=0;\\n        while(i<nums1.length && j<nums2.length){\\n            if(nums1[i][0] == nums2[j][0]){\\n                al.add(new int[] {nums1[i][0] , nums1[i][1] + nums2[j][1]});\\n                i++;j++;\\n            }else if(nums1[i][0] < nums2[j][0]){\\n                al.add(nums1[i]);\\n                i++;\\n            }else{\\n                al.add(nums2[j]);\\n                j++;\\n            }\\n        }\\n        while(i<nums1.length){\\n            al.add(nums1[i]);\\n            i++;\\n        }\\n        while(j<nums2.length){\\n            al.add(nums2[j]);\\n            j++;\\n        }\\n\\n        int[][]res = new int[al.size()][2];\\n        i=0;\\n        for(int[] a : al)\\n            res[i++] = a;\\n\\n        return res;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        List<int[]> al = new ArrayList<>();\\n        int i=0;\\n        int j=0;\\n        while(i<nums1.length && j<nums2.length){\\n            if(nums1[i][0] == nums2[j][0]){\\n                al.add(new int[] {nums1[i][0] , nums1[i][1] + nums2[j][1]});\\n                i++;j++;\\n            }else if(nums1[i][0] < nums2[j][0]){\\n                al.add(nums1[i]);\\n                i++;\\n            }else{\\n                al.add(nums2[j]);\\n                j++;\\n            }\\n        }\\n        while(i<nums1.length){\\n            al.add(nums1[i]);\\n            i++;\\n        }\\n        while(j<nums2.length){\\n            al.add(nums2[j]);\\n            j++;\\n        }\\n\\n        int[][]res = new int[al.size()][2];\\n        i=0;\\n        for(int[] a : al)\\n            res[i++] = a;\\n\\n        return res;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3209379,
                "title": "python-o-n-beats-100-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNaive approach\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncheck both array simultaneously, if ids are same add it into result\\nand if ids are different check for smaller id and add it into result\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(M*N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(M*N)\\n# Code\\n```\\nclass Solution(object):\\n    def mergeArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[List[int]]\\n        :type nums2: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = []\\n        i = 0\\n        j = 0\\n        l1 = len(nums1)\\n        l2 = len(nums2)\\n        while i < l1 and j < l2:\\n            if nums1[i][0] == nums2[j][0]:\\n                res.append(nums1[i])\\n                res[-1][1] = nums1[i][1] + nums2[j][1]\\n                i += 1\\n                j += 1\\n            elif nums1[i][0] < nums2[j][0]:\\n                res.append(nums1[i])\\n                i += 1\\n            else:\\n                res.append(nums2[j])\\n                j += 1\\n\\n        while i < l1:\\n            res.append(nums1[i])\\n            i += 1\\n\\n        while j < l2:\\n            res.append(nums2[j])\\n            j += 1\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def mergeArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[List[int]]\\n        :type nums2: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = []\\n        i = 0\\n        j = 0\\n        l1 = len(nums1)\\n        l2 = len(nums2)\\n        while i < l1 and j < l2:\\n            if nums1[i][0] == nums2[j][0]:\\n                res.append(nums1[i])\\n                res[-1][1] = nums1[i][1] + nums2[j][1]\\n                i += 1\\n                j += 1\\n            elif nums1[i][0] < nums2[j][0]:\\n                res.append(nums1[i])\\n                i += 1\\n            else:\\n                res.append(nums2[j])\\n                j += 1\\n\\n        while i < l1:\\n            res.append(nums1[i])\\n            i += 1\\n\\n        while j < l2:\\n            res.append(nums2[j])\\n            j += 1\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207554,
                "title": "rust-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn merge_arrays(nums1: Vec<Vec<i32>>, nums2: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n        let mut bt = std::collections::BTreeMap::new();\\n        bt.extend(nums1.iter().map(|x| (x[0], x[1])));\\n        nums2\\n            .iter()\\n            .for_each(|x| *bt.entry(x[0]).or_insert(0) += x[1]);\\n        bt.into_iter().map(|(id, val)| vec![id, val]).collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Iterator"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn merge_arrays(nums1: Vec<Vec<i32>>, nums2: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n        let mut bt = std::collections::BTreeMap::new();\\n        bt.extend(nums1.iter().map(|x| (x[0], x[1])));\\n        nums2\\n            .iter()\\n            .for_each(|x| *bt.entry(x[0]).or_insert(0) += x[1]);\\n        bt.into_iter().map(|(id, val)| vec![id, val]).collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3207226,
                "title": "c-simple-solution-with-explanation-hash-table",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n        // create hash map to store sums of values based by id\\n        unordered_map<int, int> mp;\\n\\n        // iterate thru keys and values in nums1 and initialize hash map\\n        for(auto& key_value: nums1)\\n            mp[key_value[0]] = key_value[1];\\n\\n        // iterate thru keys and values in nums2 add values to keys in hash map\\n        for(auto& key_value: nums2)\\n            mp[key_value[0]] += key_value[1];\\n\\n        // create ans\\n        vector<vector<int>> ans;\\n\\n        // iterate thru pairs in hash map and add them to ans\\n        for(auto& key_val: mp)\\n            ans.push_back({key_val.first, key_val.second});\\n        \\n        // sort the ans and return it\\n        sort(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n        // create hash map to store sums of values based by id\\n        unordered_map<int, int> mp;\\n\\n        // iterate thru keys and values in nums1 and initialize hash map\\n        for(auto& key_value: nums1)\\n            mp[key_value[0]] = key_value[1];\\n\\n        // iterate thru keys and values in nums2 add values to keys in hash map\\n        for(auto& key_value: nums2)\\n            mp[key_value[0]] += key_value[1];\\n\\n        // create ans\\n        vector<vector<int>> ans;\\n\\n        // iterate thru pairs in hash map and add them to ans\\n        for(auto& key_val: mp)\\n            ans.push_back({key_val.first, key_val.second});\\n        \\n        // sort the ans and return it\\n        sort(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206819,
                "title": "easy-to-understand-two-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n         vector<vector<int>> ans;\\n        int i=0,j=0;\\n        int n=nums1.size(),m=nums2.size();\\n        while(i<n&&j<m){\\n            if(nums1[i][0]>nums2[j][0]){ans.push_back({nums2[j][0],nums2[j][1]});\\n                                       j++;}\\n            else if(nums1[i][0]<nums2[j][0]){ ans.push_back({nums1[i][0],nums1[i][1]});\\n                                            i++;}\\n            else{\\n               // cout<<\"kk\";\\n            ans.push_back({nums1[i][0],nums1[i][1]+nums2[j][1]});\\n                i++,j++;\\n            }\\n        }\\n        while(i<n) ans.push_back(nums1[i++]);\\n        while(j<m) ans.push_back(nums2[j++]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n         vector<vector<int>> ans;\\n        int i=0,j=0;\\n        int n=nums1.size(),m=nums2.size();\\n        while(i<n&&j<m){\\n            if(nums1[i][0]>nums2[j][0]){ans.push_back({nums2[j][0],nums2[j][1]});\\n                                       j++;}\\n            else if(nums1[i][0]<nums2[j][0]){ ans.push_back({nums1[i][0],nums1[i][1]});\\n                                            i++;}\\n            else{\\n               // cout<<\"kk\";\\n            ans.push_back({nums1[i][0],nums1[i][1]+nums2[j][1]});\\n                i++,j++;\\n            }\\n        }\\n        while(i<n) ans.push_back(nums1[i++]);\\n        while(j<m) ans.push_back(nums2[j++]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3206582,
                "title": "c-two-pointers-efficient-approach-clear-concise-code-quality",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n        vector<vector<int>> ans;\\n        int fir = 0, sec = 0;\\n        int n1 = nums1.size(), n2 = nums2.size();\\n        while (fir < n1 && sec < n2) {\\n            if (nums1[fir][0] == nums2[sec][0]) {\\n                vector<int> temp;\\n                temp.emplace_back(nums1[fir][0]);\\n                temp.emplace_back(nums1[fir][1] + nums2[sec][1]);\\n                ans.emplace_back(temp);\\n                fir++;\\n                sec++;\\n            }\\n            else {\\n                if (nums1[fir][0] < nums2[sec][0]) {\\n                    ans.emplace_back(nums1[fir]);\\n                    fir++;\\n                }\\n                else {\\n                    ans.emplace_back(nums2[sec]);\\n                    sec++;\\n                }\\n\\n            }\\n        }\\n        while (fir < n1) {\\n            ans.emplace_back(nums1[fir]);\\n            fir++;\\n        }\\n        while (sec < n2) {\\n            ans.emplace_back(nums2[sec]);\\n            sec++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n        vector<vector<int>> ans;\\n        int fir = 0, sec = 0;\\n        int n1 = nums1.size(), n2 = nums2.size();\\n        while (fir < n1 && sec < n2) {\\n            if (nums1[fir][0] == nums2[sec][0]) {\\n                vector<int> temp;\\n                temp.emplace_back(nums1[fir][0]);\\n                temp.emplace_back(nums1[fir][1] + nums2[sec][1]);\\n                ans.emplace_back(temp);\\n                fir++;\\n                sec++;\\n            }\\n            else {\\n                if (nums1[fir][0] < nums2[sec][0]) {\\n                    ans.emplace_back(nums1[fir]);\\n                    fir++;\\n                }\\n                else {\\n                    ans.emplace_back(nums2[sec]);\\n                    sec++;\\n                }\\n\\n            }\\n        }\\n        while (fir < n1) {\\n            ans.emplace_back(nums1[fir]);\\n            fir++;\\n        }\\n        while (sec < n2) {\\n            ans.emplace_back(nums2[sec]);\\n            sec++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206548,
                "title": "rust-two-pointers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nimpl Solution {\\n    pub fn merge_arrays(nums1: Vec<Vec<i32>>, nums2: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n        let (m, n) = (nums1.len(), nums2.len());\\n        let (mut i, mut j) = (0, 0);\\n        let mut ret = vec![];\\n        while i < m || j < n {\\n            if i < m && j < n && nums1[i][0] == nums2[j][0] {\\n                ret.push(vec![nums1[i][0], nums1[i][1] + nums2[j][1]]);\\n                i += 1;\\n                j += 1;\\n                continue\\n            } \\n            \\n            if j == n || (i < m && nums1[i][0] < nums2[j][0]) {\\n                ret.push(nums1[i].clone());\\n                i += 1;\\n                continue;\\n            }\\n                \\n            ret.push(nums2[j].clone());\\n            j += 1;\\n        }\\n        \\n        ret\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn merge_arrays(nums1: Vec<Vec<i32>>, nums2: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n        let (m, n) = (nums1.len(), nums2.len());\\n        let (mut i, mut j) = (0, 0);\\n        let mut ret = vec![];\\n        while i < m || j < n {\\n            if i < m && j < n && nums1[i][0] == nums2[j][0] {\\n                ret.push(vec![nums1[i][0], nums1[i][1] + nums2[j][1]]);\\n                i += 1;\\n                j += 1;\\n                continue\\n            } \\n            \\n            if j == n || (i < m && nums1[i][0] < nums2[j][0]) {\\n                ret.push(nums1[i].clone());\\n                i += 1;\\n                continue;\\n            }\\n                \\n            ret.push(nums2[j].clone());\\n            j += 1;\\n        }\\n        \\n        ret\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3206284,
                "title": "merge-two-2d-arrays-by-summing-values-easy-java-sol",
                "content": "Space complexity: O(n+m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int[] num: nums1){\\n            map.put(num[0], num[1]);\\n        }\\n        for(int[] num: nums2){\\n            if(map.containsKey(num[0])){\\n                map.put(num[0], num[1]+map.get(num[0]));\\n            }else{\\n                map.put(num[0], num[1]);\\n            }\\n        }\\n        int[][] res = new int[map.size()][2];\\n        int index=0;\\n        for(int key: map.keySet()){\\n            res[index++] = new int[]{key, map.get(key)};\\n        }\\n\\n        Arrays.sort(res, (a, b) -> a[0] - b[0]);\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int[] num: nums1){\\n            map.put(num[0], num[1]);\\n        }\\n        for(int[] num: nums2){\\n            if(map.containsKey(num[0])){\\n                map.put(num[0], num[1]+map.get(num[0]));\\n            }else{\\n                map.put(num[0], num[1]);\\n            }\\n        }\\n        int[][] res = new int[map.size()][2];\\n        int index=0;\\n        for(int key: map.keySet()){\\n            res[index++] = new int[]{key, map.get(key)};\\n        }\\n\\n        Arrays.sort(res, (a, b) -> a[0] - b[0]);\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205603,
                "title": "0-n-0ms-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& n1, vector<vector<int>>& n2) {\\n        int i=0;\\n        int j=0;\\n        int n=n1.size();\\n        int m=n2.size();\\n        vector<vector<int>>help;\\n        while(i<n && j<m){\\n            vector<int>out;\\n           \\n                if(n1[i][0]<n2[j][0]){\\n                    out.push_back(n1[i][0]);\\n                    out.push_back(n1[i][1]);\\n                     help.push_back(out);\\n                    i++;\\n                }\\n            else    if(n1[i][0]>n2[j][0]){\\n                    out.push_back(n2[j][0]);\\n                    out.push_back(n2[j][1]);\\n                  help.push_back(out);\\n                  j++;\\n                }\\n            else    {\\n                    out.push_back(n1[i][0]);\\n                    out.push_back(n1[i][1]+n2[j][1]);\\n                 help.push_back(out);\\n                  i++;\\n                  j++;\\n                }\\n          //  if(out.size()>0){\\n               \\n        //    }\\n         //   out.clear();\\n           \\n            \\n        }\\n        while(i<n){\\n              vector<int>out;\\n             out.push_back(n1[i][0]);\\n                    out.push_back(n1[i][1]);\\n             help.push_back(out);\\n            i++;\\n        }\\n         while(j<m){\\n              vector<int>out;\\n             out.push_back(n2[j][0]);\\n                    out.push_back(n2[j][1]);\\n             help.push_back(out);\\n             j++;\\n            \\n        }\\n        return help;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& n1, vector<vector<int>>& n2) {\\n        int i=0;\\n        int j=0;\\n        int n=n1.size();\\n        int m=n2.size();\\n        vector<vector<int>>help;\\n        while(i<n && j<m){\\n            vector<int>out;\\n           \\n                if(n1[i][0]<n2[j][0]){\\n                    out.push_back(n1[i][0]);\\n                    out.push_back(n1[i][1]);\\n                     help.push_back(out);\\n                    i++;\\n                }\\n            else    if(n1[i][0]>n2[j][0]){\\n                    out.push_back(n2[j][0]);\\n                    out.push_back(n2[j][1]);\\n                  help.push_back(out);\\n                  j++;\\n                }\\n            else    {\\n                    out.push_back(n1[i][0]);\\n                    out.push_back(n1[i][1]+n2[j][1]);\\n                 help.push_back(out);\\n                  i++;\\n                  j++;\\n                }\\n          //  if(out.size()>0){\\n               \\n        //    }\\n         //   out.clear();\\n           \\n            \\n        }\\n        while(i<n){\\n              vector<int>out;\\n             out.push_back(n1[i][0]);\\n                    out.push_back(n1[i][1]);\\n             help.push_back(out);\\n            i++;\\n        }\\n         while(j<m){\\n              vector<int>out;\\n             out.push_back(n2[j][0]);\\n                    out.push_back(n2[j][1]);\\n             help.push_back(out);\\n             j++;\\n            \\n        }\\n        return help;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205467,
                "title": "java-simple-solution-using-list-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n  Take a list of size according to constraints upto 1001 treat the \\n  indices of list as id\\'s of nums1 and nums2 then traverse twoArrays  and set the values at respectives ids\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nLets take a list of size 1001 and fill it with -1, and then traverse the first array and place the values of nums1 at id\\'s (indices) of our list next traverse the second array nums2 and check if the value of list is -1 or not if -1 then set the value if not then add the present value with existing value and put it.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWe are traversing the entrie list which of size 1001 then it would be \\n[n == 1001 O(n)]\\nwe can optimize by putting a break statement when our [count == ind]\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nWe are using list to store which is of size 1001 and at last our ans matrix if we consider length of the list as n and length of the matrix a m it would be O(n+m)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        int count = 0;\\n        List<Integer> list = new ArrayList<>(1001); \\n        for(int i=0;i<1001;i++) list.add(-1);\\n       \\n        for(int[] arr : nums1) {\\n             list.set(arr[0],arr[1]);\\n            count++;\\n        }\\n        for(int[] arr : nums2) {\\n            if(list.get(arr[0])!=-1) {\\n                int a = list.get(arr[0]); \\n                list.set(arr[0],a+arr[1]);\\n            }\\n            else {\\n                list.set(arr[0],arr[1]);\\n                count++;\\n            }\\n        }\\n      \\n        int[][] ans = new int[count][2];\\n        int ind = 0;\\n        for(int i = 0;i<list.size();i++) {\\n          if(list.get(i) != -1) {\\n            ans[ind][0] = i;\\n             ans[ind][1] = list.get(i);\\n              ind++;\\n          }\\n       }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        int count = 0;\\n        List<Integer> list = new ArrayList<>(1001); \\n        for(int i=0;i<1001;i++) list.add(-1);\\n       \\n        for(int[] arr : nums1) {\\n             list.set(arr[0],arr[1]);\\n            count++;\\n        }\\n        for(int[] arr : nums2) {\\n            if(list.get(arr[0])!=-1) {\\n                int a = list.get(arr[0]); \\n                list.set(arr[0],a+arr[1]);\\n            }\\n            else {\\n                list.set(arr[0],arr[1]);\\n                count++;\\n            }\\n        }\\n      \\n        int[][] ans = new int[count][2];\\n        int ind = 0;\\n        for(int i = 0;i<list.size();i++) {\\n          if(list.get(i) != -1) {\\n            ans[ind][0] = i;\\n             ans[ind][1] = list.get(i);\\n              ind++;\\n          }\\n       }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203988,
                "title": "readable-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        a = [x[0] for x in nums2]\\n        b = [y[1] for y in nums2]\\n        c = [z[0] for z in nums1]\\n        nums3 = []\\n        for i in nums1:\\n            if i[0] in a:\\n                nums3.append([i[0], i[1]+b[a.index(i[0])]])\\n            else:\\n                nums3.append(i)\\n        for k in nums2:\\n            if k[0] not in c:\\n                nums3.append(k)\\n        return sorted(nums3)       \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        a = [x[0] for x in nums2]\\n        b = [y[1] for y in nums2]\\n        c = [z[0] for z in nums1]\\n        nums3 = []\\n        for i in nums1:\\n            if i[0] in a:\\n                nums3.append([i[0], i[1]+b[a.index(i[0])]])\\n            else:\\n                nums3.append(i)\\n        for k in nums2:\\n            if k[0] not in c:\\n                nums3.append(k)\\n        return sorted(nums3)       \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203971,
                "title": "simple-java-solution-using-treemap",
                "content": "# class Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        TreeMap<Integer,Integer> map=new TreeMap<>();\\n         for(int i=0;i<nums1.length;i++)\\n        {\\n            if(map.containsKey(nums1[i][0]))\\n            {\\n            int sum=map.get(nums1[i][0]);\\n            map.put(nums1[i][0],sum+nums1[i][1]);\\n            }else{\\n            map.put(nums1[i][0],nums1[i][1]);\\n            }\\n        }\\n        for(int i=0;i<nums2.length;i++)\\n        {\\n            if(map.containsKey(nums2[i][0]))\\n            {\\n            int sum=map.get(nums2[ i][0]);\\n            map.put(nums2[i][0],sum+nums2[i][1]);\\n            }else{\\n            map.put(nums2[i][0],nums2[i][1]);\\n            }\\n        }\\n        int x=map.size();\\n        int a[][]=new int[x][2];\\n        int k=0;\\n        for(int key:map.keySet())\\n        {\\n            a[k][0]=key;\\n            a[k][1]=map.get(key);\\n            k++;\\n        }\\n        return a;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "class Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        TreeMap<Integer,Integer> map=new TreeMap<>();\\n         for(int i=0;i<nums1.length;i++)\\n        {\\n            if(map.containsKey(nums1[i][0]))\\n            {\\n            int sum=map.get(nums1[i][0]);\\n            map.put(nums1[i][0],sum+nums1[i][1]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3203950,
                "title": "week1",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        Map<Integer, Integer> idToValue = new HashMap<>();\\n        \\n        for (int[] pair : nums1) {\\n            idToValue.put(pair[0], pair[1]);\\n        }\\n        \\n        for (int[] pair : nums2) {\\n            int id = pair[0];\\n            int value = pair[1];\\n            idToValue.put(id, idToValue.getOrDefault(id, 0) + value);\\n        }\\n        \\n        List<Integer> ids = new ArrayList<>(idToValue.keySet());\\n        Collections.sort(ids);\\n    \\n        int[][] result = new int[ids.size()][2];\\n        for (int i = 0; i < ids.size(); i++) {\\n            int id = ids.get(i);\\n            int value = idToValue.get(id);\\n            result[i][0] = id;\\n            result[i][1] = value;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        Map<Integer, Integer> idToValue = new HashMap<>();\\n        \\n        for (int[] pair : nums1) {\\n            idToValue.put(pair[0], pair[1]);\\n        }\\n        \\n        for (int[] pair : nums2) {\\n            int id = pair[0];\\n            int value = pair[1];\\n            idToValue.put(id, idToValue.getOrDefault(id, 0) + value);\\n        }\\n        \\n        List<Integer> ids = new ArrayList<>(idToValue.keySet());\\n        Collections.sort(ids);\\n    \\n        int[][] result = new int[ids.size()][2];\\n        for (int i = 0; i < ids.size(); i++) {\\n            int id = ids.get(i);\\n            int value = idToValue.get(id);\\n            result[i][0] = id;\\n            result[i][1] = value;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203846,
                "title": "simple-java-solution-tc-o-max-n-m-sc-o-max-n-m",
                "content": "```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        int i = 0;\\n\\t\\tint j = 0;\\n\\t\\tList<List<Integer>> res = new ArrayList<>();\\n\\t\\twhile (i < nums1.length && j < nums2.length) {\\n\\t\\t\\tif (nums1[i][0] == nums2[j][0]) {\\n\\t\\t\\t\\tList<Integer> list = new ArrayList<>();\\n\\t\\t\\t\\tlist.add(nums1[i][0]);\\n\\t\\t\\t\\tlist.add(nums1[i][1] + nums2[j][1]);\\n\\t\\t\\t\\tres.add(list);\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t} else if (nums1[i][0] < nums2[j][0]) {\\n\\t\\t\\t\\tList<Integer> list = new ArrayList<>();\\n\\t\\t\\t\\tlist.add(nums1[i][0]);\\n\\t\\t\\t\\tlist.add(nums1[i][1]);\\n\\t\\t\\t\\tres.add(list);\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tList<Integer> list = new ArrayList<>();\\n\\t\\t\\t\\tlist.add(nums2[j][0]);\\n\\t\\t\\t\\tlist.add(nums2[j][1]);\\n\\t\\t\\t\\tres.add(list);\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twhile (i < nums1.length) {\\n\\t\\t\\tList<Integer> list = new ArrayList<>();\\n\\t\\t\\tlist.add(nums1[i][0]);\\n\\t\\t\\tlist.add(nums1[i][1]);\\n\\t\\t\\tres.add(list);\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\twhile (j < nums2.length) {\\n\\t\\t\\tList<Integer> list = new ArrayList<>();\\n\\t\\t\\tlist.add(nums2[j][0]);\\n\\t\\t\\tlist.add(nums2[j][1]);\\n\\t\\t\\tres.add(list);\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\t\\tint[][] ans = new int[res.size()][2];\\n\\t\\tfor (int k = 0; k < res.size(); k++) {\\n\\t\\t\\tans[k] = res.get(k).stream().mapToInt(num -> num).toArray();\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        int i = 0;\\n\\t\\tint j = 0;\\n\\t\\tList<List<Integer>> res = new ArrayList<>();\\n\\t\\twhile (i < nums1.length && j < nums2.length) {\\n\\t\\t\\tif (nums1[i][0] == nums2[j][0]) {\\n\\t\\t\\t\\tList<Integer> list = new ArrayList<>();\\n\\t\\t\\t\\tlist.add(nums1[i][0]);\\n\\t\\t\\t\\tlist.add(nums1[i][1] + nums2[j][1]);\\n\\t\\t\\t\\tres.add(list);\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t} else if (nums1[i][0] < nums2[j][0]) {\\n\\t\\t\\t\\tList<Integer> list = new ArrayList<>();\\n\\t\\t\\t\\tlist.add(nums1[i][0]);\\n\\t\\t\\t\\tlist.add(nums1[i][1]);\\n\\t\\t\\t\\tres.add(list);\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tList<Integer> list = new ArrayList<>();\\n\\t\\t\\t\\tlist.add(nums2[j][0]);\\n\\t\\t\\t\\tlist.add(nums2[j][1]);\\n\\t\\t\\t\\tres.add(list);\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twhile (i < nums1.length) {\\n\\t\\t\\tList<Integer> list = new ArrayList<>();\\n\\t\\t\\tlist.add(nums1[i][0]);\\n\\t\\t\\tlist.add(nums1[i][1]);\\n\\t\\t\\tres.add(list);\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\twhile (j < nums2.length) {\\n\\t\\t\\tList<Integer> list = new ArrayList<>();\\n\\t\\t\\tlist.add(nums2[j][0]);\\n\\t\\t\\tlist.add(nums2[j][1]);\\n\\t\\t\\tres.add(list);\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\t\\tint[][] ans = new int[res.size()][2];\\n\\t\\tfor (int k = 0; k < res.size(); k++) {\\n\\t\\t\\tans[k] = res.get(k).stream().mapToInt(num -> num).toArray();\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203836,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n       \\n        TreeMap<Integer,Integer> tm=new TreeMap<Integer,Integer>();\\n        for(int i=0;i<nums1.length;i++){\\n                tm.put(nums1[i][0],nums1[i][1]);\\n        }\\n        for(int i=0;i<nums2.length;i++){\\n            if(tm.containsKey(nums2[i][0]))\\n                tm.put(nums2[i][0],tm.get(nums2[i][0])+nums2[i][1]);\\n                else\\n                    tm.put(nums2[i][0],nums2[i][1]);\\n        }\\n         int[][] ans=new int[tm.size()][nums1.length+nums2.length];\\n        int j=0;\\n        for(Map.Entry<Integer,Integer> e : tm.entrySet()){\\n            int []ref=new int[2];\\n            ref[0]=e.getKey();\\n            ref[1]=e.getValue();\\n            ans[j]=ref;\\n            j++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n       \\n        TreeMap<Integer,Integer> tm=new TreeMap<Integer,Integer>();\\n        for(int i=0;i<nums1.length;i++){\\n                tm.put(nums1[i][0],nums1[i][1]);\\n        }\\n        for(int i=0;i<nums2.length;i++){\\n            if(tm.containsKey(nums2[i][0]))\\n                tm.put(nums2[i][0],tm.get(nums2[i][0])+nums2[i][1]);\\n                else\\n                    tm.put(nums2[i][0],nums2[i][1]);\\n        }\\n         int[][] ans=new int[tm.size()][nums1.length+nums2.length];\\n        int j=0;\\n        for(Map.Entry<Integer,Integer> e : tm.entrySet()){\\n            int []ref=new int[2];\\n            ref[0]=e.getKey();\\n            ref[1]=e.getValue();\\n            ans[j]=ref;\\n            j++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203771,
                "title": "easy-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        \\n        Set<Integer> set=new HashSet();\\n        for(int i=0;i<nums1.length;i++)\\n        {\\n            set.add(nums1[i][0]);\\n        }\\n        for(int i=0;i<nums2.length;i++)\\n        {\\n            set.add(nums2[i][0]);\\n        }\\n        int [][]ans=new int[set.size()][2];\\n        int k=0;\\n        int i=0;\\n        int j=0;\\n        while(i<nums1.length || j<nums2.length)\\n        {\\n            if(i<nums1.length && j<nums2.length)\\n            {\\n            int a=nums1[i][0];\\n            int b=nums2[j][0];\\n            if(a<b)\\n            {\\n                ans[k][0]=a;\\n                ans[k][1]=nums1[i][1];\\n                i++;\\n            }\\n            else if(a>b)\\n            {\\n                ans[k][0]=b;\\n                ans[k][1]=nums2[j][1];\\n                j++;\\n            }\\n            else\\n            {\\n                ans[k][0]=nums1[i][0];\\n                ans[k][1]=nums1[i][1]+nums2[j][1];\\n                i++;j++;\\n            }\\n                \\n            }\\n            else if(i<nums1.length && j==nums2.length)\\n            {\\n                ans[k][0]=nums1[i][0];\\n                ans[k][1]=nums1[i][1];\\n                i++;\\n            }\\n            else if( i==nums1.length && j<nums2.length)\\n            {\\n                ans[k][0]=nums2[j][0];\\n                ans[k][1]=nums2[j][1];\\n                j++;\\n            }\\n            k++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        \\n        Set<Integer> set=new HashSet();\\n        for(int i=0;i<nums1.length;i++)\\n        {\\n            set.add(nums1[i][0]);\\n        }\\n        for(int i=0;i<nums2.length;i++)\\n        {\\n            set.add(nums2[i][0]);\\n        }\\n        int [][]ans=new int[set.size()][2];\\n        int k=0;\\n        int i=0;\\n        int j=0;\\n        while(i<nums1.length || j<nums2.length)\\n        {\\n            if(i<nums1.length && j<nums2.length)\\n            {\\n            int a=nums1[i][0];\\n            int b=nums2[j][0];\\n            if(a<b)\\n            {\\n                ans[k][0]=a;\\n                ans[k][1]=nums1[i][1];\\n                i++;\\n            }\\n            else if(a>b)\\n            {\\n                ans[k][0]=b;\\n                ans[k][1]=nums2[j][1];\\n                j++;\\n            }\\n            else\\n            {\\n                ans[k][0]=nums1[i][0];\\n                ans[k][1]=nums1[i][1]+nums2[j][1];\\n                i++;j++;\\n            }\\n                \\n            }\\n            else if(i<nums1.length && j==nums2.length)\\n            {\\n                ans[k][0]=nums1[i][0];\\n                ans[k][1]=nums1[i][1];\\n                i++;\\n            }\\n            else if( i==nums1.length && j<nums2.length)\\n            {\\n                ans[k][0]=nums2[j][0];\\n                ans[k][1]=nums2[j][1];\\n                j++;\\n            }\\n            k++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203764,
                "title": "python-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        d1,d2 = {},{}\\n\\t\\t# add all entries of nums1 to map d1\\n        for num in nums1:\\n            d1[num[0]] = num[1]\\n\\t\\t\\t\\n\\t\\t# add all entries of nums2 to map d2\\n        for num in nums2:\\n            d2[num[0]] = num[1]\\n\\t\\t\\t\\n\\t\\t# to store final ans\\n        ans = []\\n\\t\\t\\n\\t\\t# traverse map1\\n        for num in d1.keys():\\n            val = d1[num]\\n\\t\\t\\t\\n\\t\\t\\t# if the entry is in map2 add it in the value of map1 and remove it from map2\\n            if num in d2:\\n                val += d2[num]\\n                del d2[num]\\n\\t\\t\\t\\t\\n\\t\\t\\t# add the id,val pair  to ans\\n            ans.append([num,val])\\n\\t\\t\\t\\n\\t\\t# traverse map2 to get items that are not in map1\\n        for key,val in d2.items():\\n            ans.append([key,val])\\n\\t\\t\\t\\n\\t\\t# sort the final ans by ids\\n        ans.sort(key=lambda x:x[0])\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        d1,d2 = {},{}\\n\\t\\t# add all entries of nums1 to map d1\\n        for num in nums1:\\n            d1[num[0]] = num[1]\\n\\t\\t\\t\\n\\t\\t# add all entries of nums2 to map d2\\n        for num in nums2:\\n            d2[num[0]] = num[1]\\n\\t\\t\\t\\n\\t\\t# to store final ans\\n        ans = []\\n\\t\\t\\n\\t\\t# traverse map1\\n        for num in d1.keys():\\n            val = d1[num]\\n\\t\\t\\t\\n\\t\\t\\t# if the entry is in map2 add it in the value of map1 and remove it from map2\\n            if num in d2:\\n                val += d2[num]\\n                del d2[num]\\n\\t\\t\\t\\t\\n\\t\\t\\t# add the id,val pair  to ans\\n            ans.append([num,val])\\n\\t\\t\\t\\n\\t\\t# traverse map2 to get items that are not in map1\\n        for key,val in d2.items():\\n            ans.append([key,val])\\n\\t\\t\\t\\n\\t\\t# sort the final ans by ids\\n        ans.sort(key=lambda x:x[0])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203734,
                "title": "python-this-is-the-same-as-2363",
                "content": "# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        table = defaultdict(lambda: 0)\\n        items = sorted(nums1 + nums2, key=lambda itm:itm[0])\\n        ret = []\\n        for itm in items:\\n            table[itm[0]] += itm[1]\\n        table = dict(table)\\n        return table.items()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        table = defaultdict(lambda: 0)\\n        items = sorted(nums1 + nums2, key=lambda itm:itm[0])\\n        ret = []\\n        for itm in items:\\n            table[itm[0]] += itm[1]\\n        table = dict(table)\\n        return table.items()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203725,
                "title": "6362-merge-two-2d-arrays-by-summing-values-java-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n         int m=nums1.length,n=nums2.length;\\n        int i=0,j=0,k=0;\\n        while(i<m && j<n)\\n        {\\n            if(nums1[i][0]==nums2[j][0])\\n            {\\n                k++;\\n                i++;\\n                j++;\\n            }\\n            else if(nums1[i][0]>nums2[j][0])\\n            {\\n                k++;\\n                j++;\\n            }\\n            else\\n            {\\n                k++;\\n                i++;\\n            }\\n        }\\n        while(i<m)\\n        {\\n            k++;\\n            i++;\\n        }\\n        while(j<n)\\n        {\\n            k++;\\n            j++;\\n        }\\n        int nums[][] = new int[k][2];\\n        int f=0;\\n        i=0;\\n        j=0;\\n        while(i<m && j<n)\\n        {\\n            if(nums1[i][0]==nums2[j][0])\\n            {\\n                nums[f][0]=nums1[i][0];\\n                nums[f][1]=nums1[i][1]+nums2[j][1];\\n                f++;\\n                i++;\\n                j++;\\n            }\\n            else if(nums1[i][0]>nums2[j][0])\\n            {\\n                nums[f][0]=nums2[j][0];\\n                nums[f][1]=nums2[j][1];\\n                f++;\\n                j++;\\n            }\\n            else\\n            {\\n                nums[f][0]=nums1[i][0];\\n                nums[f][1]=nums1[i][1];\\n                f++;\\n                i++;\\n            }\\n        }\\n        while(i<m)\\n        {\\n            nums[f][0]=nums1[i][0];\\n                nums[f][1]=nums1[i][1];\\n                f++;\\n                i++;\\n        }\\n        while(j<n)\\n        {\\n           nums[f][0]=nums2[j][0];\\n                nums[f][1]=nums2[j][1];\\n                f++;\\n                j++;\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n         int m=nums1.length,n=nums2.length;\\n        int i=0,j=0,k=0;\\n        while(i<m && j<n)\\n        {\\n            if(nums1[i][0]==nums2[j][0])\\n            {\\n                k++;\\n                i++;\\n                j++;\\n            }\\n            else if(nums1[i][0]>nums2[j][0])\\n            {\\n                k++;\\n                j++;\\n            }\\n            else\\n            {\\n                k++;\\n                i++;\\n            }\\n        }\\n        while(i<m)\\n        {\\n            k++;\\n            i++;\\n        }\\n        while(j<n)\\n        {\\n            k++;\\n            j++;\\n        }\\n        int nums[][] = new int[k][2];\\n        int f=0;\\n        i=0;\\n        j=0;\\n        while(i<m && j<n)\\n        {\\n            if(nums1[i][0]==nums2[j][0])\\n            {\\n                nums[f][0]=nums1[i][0];\\n                nums[f][1]=nums1[i][1]+nums2[j][1];\\n                f++;\\n                i++;\\n                j++;\\n            }\\n            else if(nums1[i][0]>nums2[j][0])\\n            {\\n                nums[f][0]=nums2[j][0];\\n                nums[f][1]=nums2[j][1];\\n                f++;\\n                j++;\\n            }\\n            else\\n            {\\n                nums[f][0]=nums1[i][0];\\n                nums[f][1]=nums1[i][1];\\n                f++;\\n                i++;\\n            }\\n        }\\n        while(i<m)\\n        {\\n            nums[f][0]=nums1[i][0];\\n                nums[f][1]=nums1[i][1];\\n                f++;\\n                i++;\\n        }\\n        while(j<n)\\n        {\\n           nums[f][0]=nums2[j][0];\\n                nums[f][1]=nums2[j][1];\\n                f++;\\n                j++;\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203715,
                "title": "map-sorting",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n        map<int,int> mp;\\n        for(auto ele:nums1)mp[ele[0]]+=ele[1];\\n        for(auto ele:nums2)mp[ele[0]]+=ele[1];\\n        vector<vector<int>> arr;\\n        for(auto ele:mp)arr.push_back({ele.first,ele.second});\\n        sort(arr.begin(),arr.end());\\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n        map<int,int> mp;\\n        for(auto ele:nums1)mp[ele[0]]+=ele[1];\\n        for(auto ele:nums2)mp[ele[0]]+=ele[1];\\n        vector<vector<int>> arr;\\n        for(auto ele:mp)arr.push_back({ele.first,ele.second});\\n        sort(arr.begin(),arr.end());\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4099175,
                "title": "easy-java-solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        \\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        for(int[]n:nums1){\\n            map.put(n[0],n[1]);\\n        }\\n        for(int[] n:nums2){\\n            if(map.containsKey(n[0])){\\n                map.put(n[0],map.get(n[0])+n[1]);\\n            }\\n            else{\\n                map.put(n[0],n[1]);\\n            }\\n        }\\n        int[][] arr=new int[map.size()][2];\\n        System.out.println(map);\\n        int i=0;\\n\\n        for(Map.Entry<Integer,Integer> m:map.entrySet()){\\n            arr[i][0]=m.getKey();\\n            arr[i][1]=m.getValue();\\n            i++;\\n        }\\n        Arrays.sort(arr,(a,b)->{\\n            return a[0]-b[0];\\n        });\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        \\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        for(int[]n:nums1){\\n            map.put(n[0],n[1]);\\n        }\\n        for(int[] n:nums2){\\n            if(map.containsKey(n[0])){\\n                map.put(n[0],map.get(n[0])+n[1]);\\n            }\\n            else{\\n                map.put(n[0],n[1]);\\n            }\\n        }\\n        int[][] arr=new int[map.size()][2];\\n        System.out.println(map);\\n        int i=0;\\n\\n        for(Map.Entry<Integer,Integer> m:map.entrySet()){\\n            arr[i][0]=m.getKey();\\n            arr[i][1]=m.getValue();\\n            i++;\\n        }\\n        Arrays.sort(arr,(a,b)->{\\n            return a[0]-b[0];\\n        });\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4097419,
                "title": "java-solution-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n\\n        HashMap<Integer,Integer> map1=new HashMap<>();\\n        HashMap<Integer,Integer> map2=new HashMap<>();\\n        for(int i=0;i<nums1.length;i++)\\n        {\\n            map1.put(nums1[i][0],nums1[i][1]);\\n        }\\n        for(int j=0;j<nums2.length;j++)\\n        {\\n            map2.put(nums2[j][0],nums2[j][1]);\\n        }\\n\\n        List<List<Integer>> result=new ArrayList<>();\\n        for(Map.Entry<Integer,Integer> mapElement : map1.entrySet())\\n        {\\n            List<Integer> list=new ArrayList<>();\\n            int key=mapElement.getKey();\\n            if(map2.containsKey(key))\\n            {\\n                list.add(key);\\n                list.add(mapElement.getValue()+map2.get(key));\\n                result.add(list);\\n            }\\n            else{\\n                list.add(key);\\n                list.add(mapElement.getValue());\\n                result.add(list);\\n            }\\n        }\\n\\n\\n        for(Map.Entry<Integer,Integer> mapElement : map2.entrySet())\\n        {\\n            List<Integer> list=new ArrayList<>();\\n            int key=mapElement.getKey();\\n            if(map1.containsKey(key))\\n            {\\n                list.add(key);\\n                list.add(mapElement.getValue()+map1.get(key));\\n                if(!result.contains(list))\\n                {\\n                result.add(list);\\n                }\\n            }\\n            else{\\n                list.add(key);\\n                list.add(mapElement.getValue());\\n                if(!result.contains(list))\\n                {\\n                    result.add(list);\\n                }\\n            }\\n        }\\n\\n\\n        Collections.sort(result,(a,b)->{\\n            return a.get(0)-b.get(0);\\n        });\\n\\n        int arr[][]=new int[result.size()][result.get(0).size()];\\n        for(int i=0;i<result.size();i++)\\n        {\\n            for(int j=0;j<result.get(0).size();j++)\\n            {\\n                arr[i][j]=result.get(i).get(j);\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n\\n        HashMap<Integer,Integer> map1=new HashMap<>();\\n        HashMap<Integer,Integer> map2=new HashMap<>();\\n        for(int i=0;i<nums1.length;i++)\\n        {\\n            map1.put(nums1[i][0],nums1[i][1]);\\n        }\\n        for(int j=0;j<nums2.length;j++)\\n        {\\n            map2.put(nums2[j][0],nums2[j][1]);\\n        }\\n\\n        List<List<Integer>> result=new ArrayList<>();\\n        for(Map.Entry<Integer,Integer> mapElement : map1.entrySet())\\n        {\\n            List<Integer> list=new ArrayList<>();\\n            int key=mapElement.getKey();\\n            if(map2.containsKey(key))\\n            {\\n                list.add(key);\\n                list.add(mapElement.getValue()+map2.get(key));\\n                result.add(list);\\n            }\\n            else{\\n                list.add(key);\\n                list.add(mapElement.getValue());\\n                result.add(list);\\n            }\\n        }\\n\\n\\n        for(Map.Entry<Integer,Integer> mapElement : map2.entrySet())\\n        {\\n            List<Integer> list=new ArrayList<>();\\n            int key=mapElement.getKey();\\n            if(map1.containsKey(key))\\n            {\\n                list.add(key);\\n                list.add(mapElement.getValue()+map1.get(key));\\n                if(!result.contains(list))\\n                {\\n                result.add(list);\\n                }\\n            }\\n            else{\\n                list.add(key);\\n                list.add(mapElement.getValue());\\n                if(!result.contains(list))\\n                {\\n                    result.add(list);\\n                }\\n            }\\n        }\\n\\n\\n        Collections.sort(result,(a,b)->{\\n            return a.get(0)-b.get(0);\\n        });\\n\\n        int arr[][]=new int[result.size()][result.get(0).size()];\\n        for(int i=0;i<result.size();i++)\\n        {\\n            for(int j=0;j<result.get(0).size();j++)\\n            {\\n                arr[i][j]=result.get(i).get(j);\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4093516,
                "title": "easiest-sol-using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        int count =0;\\n        for(int i =0 ;i<nums1.length;i++){\\n           map.put(nums1[i][0],nums1[i][1]);\\n        }\\n        for(int i =0 ;i<nums2.length;i++){\\n            if(map.containsKey(nums2[i][0])){\\n                count++;\\n            }\\n        }\\n        \\n        int n = nums1.length + nums2.length -count;\\n        int[][] arr = new int[n][2];\\n        int i = 0,j =0,k=0;\\n        while(i<nums1.length && j<nums2.length){\\n            if(nums1[i][0] == nums2[j][0]){\\n                 arr[k][0] = nums1[i][0];\\n                 arr[k][1] = nums1[i][1] + nums2[j][1];\\n                 i++;\\n                 j++;\\n            }\\n            else if(nums1[i][0] < nums2[j][0]){\\n                 arr[k][0] = nums1[i][0];\\n                 arr[k][1] = nums1[i][1];\\n                 i++;\\n            }\\n            else{\\n                arr[k][0] = nums2[j][0];\\n                arr[k][1] = nums2[j][1];\\n                j++;\\n\\n            }\\n            k++;\\n\\n        }\\n        while(i<nums1.length){\\n            arr[k][0] = nums1[i][0];\\n            arr[k][1] = nums1[i][1];\\n            i++;\\n            k++;\\n        }\\n        while(j<nums2.length){\\n            arr[k][0] = nums2[j][0];\\n            arr[k][1] = nums2[j][1];\\n            j++;\\n            k++;\\n        }\\n        return arr;\\n\\n        \\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        int count =0;\\n        for(int i =0 ;i<nums1.length;i++){\\n           map.put(nums1[i][0],nums1[i][1]);\\n        }\\n        for(int i =0 ;i<nums2.length;i++){\\n            if(map.containsKey(nums2[i][0])){\\n                count++;\\n            }\\n        }\\n        \\n        int n = nums1.length + nums2.length -count;\\n        int[][] arr = new int[n][2];\\n        int i = 0,j =0,k=0;\\n        while(i<nums1.length && j<nums2.length){\\n            if(nums1[i][0] == nums2[j][0]){\\n                 arr[k][0] = nums1[i][0];\\n                 arr[k][1] = nums1[i][1] + nums2[j][1];\\n                 i++;\\n                 j++;\\n            }\\n            else if(nums1[i][0] < nums2[j][0]){\\n                 arr[k][0] = nums1[i][0];\\n                 arr[k][1] = nums1[i][1];\\n                 i++;\\n            }\\n            else{\\n                arr[k][0] = nums2[j][0];\\n                arr[k][1] = nums2[j][1];\\n                j++;\\n\\n            }\\n            k++;\\n\\n        }\\n        while(i<nums1.length){\\n            arr[k][0] = nums1[i][0];\\n            arr[k][1] = nums1[i][1];\\n            i++;\\n            k++;\\n        }\\n        while(j<nums2.length){\\n            arr[k][0] = nums2[j][0];\\n            arr[k][1] = nums2[j][1];\\n            j++;\\n            k++;\\n        }\\n        return arr;\\n\\n        \\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4087354,
                "title": "python-easy-solution-using-dictionary",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        d = {}\\n        nums = nums1 + nums2\\n        for i in nums:\\n            a = i[0]\\n            b = i[1]\\n            if a in d:\\n                d[a] += b\\n            else:\\n                d[a] = b\\n                \\n        l = []\\n        for k, v in d.items():\\n            l.append([k,v])\\n\\n        return sorted(l)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        d = {}\\n        nums = nums1 + nums2\\n        for i in nums:\\n            a = i[0]\\n            b = i[1]\\n            if a in d:\\n                d[a] += b\\n            else:\\n                d[a] = b\\n                \\n        l = []\\n        for k, v in d.items():\\n            l.append([k,v])\\n\\n        return sorted(l)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4087305,
                "title": "elixir-recursion-solution",
                "content": "```\\ndefmodule Solution do\\n  @spec merge_arrays(nums1 :: [[integer]], nums2 :: [[integer]]) :: [[integer]]\\n  def merge_arrays([], nums2) do\\n    nums2\\n  end\\n\\n  def merge_arrays(nums1, []) do\\n    nums1\\n  end\\n\\n  def merge_arrays([[id1, v1] | rs1] = nums1, [[id2, v2] | rs2] = nums2) do\\n    cond do\\n      id1 == id2 -> [[id1, v1 + v2] | merge_arrays(rs1, rs2)]\\n      id1 < id2 -> [[id1, v1] | merge_arrays(rs1, nums2)]\\n      true -> [[id2, v2] | merge_arrays(nums1, rs2)]\\n    end\\n  end\\nend\\n\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```\\ndefmodule Solution do\\n  @spec merge_arrays(nums1 :: [[integer]], nums2 :: [[integer]]) :: [[integer]]\\n  def merge_arrays([], nums2) do\\n    nums2\\n  end\\n\\n  def merge_arrays(nums1, []) do\\n    nums1\\n  end\\n\\n  def merge_arrays([[id1, v1] | rs1] = nums1, [[id2, v2] | rs2] = nums2) do\\n    cond do\\n      id1 == id2 -> [[id1, v1 + v2] | merge_arrays(rs1, rs2)]\\n      id1 < id2 -> [[id1, v1] | merge_arrays(rs1, nums2)]\\n      true -> [[id2, v2] | merge_arrays(nums1, rs2)]\\n    end\\n  end\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4079863,
                "title": "easy-solution-in-java-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] a, int[][] b) {\\n        int n1=a.length;\\n         int n2=b.length;\\n        Map<Integer,Integer> m=new TreeMap<>();\\n        for(int i=0;i<n1;i++){\\n            int g=a[i][0];\\n            int h=a[i][1];\\n            if(!m.containsKey(g))\\n              m.put(g,h);\\n            else\\n              m.put(g,m.get(g)+h);  \\n        }\\n         for(int i=0;i<n2;i++){\\n            int g=b[i][0];\\n            int h=b[i][1];\\n            if(!m.containsKey(g))\\n              m.put(g,h);\\n            else\\n              m.put(g,m.get(g)+h);  \\n        }\\n          int k[][]=new int[m.size()][2];\\n          int x=0;\\n          for(int i:m.keySet()){\\n              int g=m.get(i);\\n              k[x][0]=i;\\n              k[x][1]=g;\\n              x++;\\n          }\\n        System.out.print(m);\\n        return k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] a, int[][] b) {\\n        int n1=a.length;\\n         int n2=b.length;\\n        Map<Integer,Integer> m=new TreeMap<>();\\n        for(int i=0;i<n1;i++){\\n            int g=a[i][0];\\n            int h=a[i][1];\\n            if(!m.containsKey(g))\\n              m.put(g,h);\\n            else\\n              m.put(g,m.get(g)+h);  \\n        }\\n         for(int i=0;i<n2;i++){\\n            int g=b[i][0];\\n            int h=b[i][1];\\n            if(!m.containsKey(g))\\n              m.put(g,h);\\n            else\\n              m.put(g,m.get(g)+h);  \\n        }\\n          int k[][]=new int[m.size()][2];\\n          int x=0;\\n          for(int i:m.keySet()){\\n              int g=m.get(i);\\n              k[x][0]=i;\\n              k[x][1]=g;\\n              x++;\\n          }\\n        System.out.print(m);\\n        return k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079599,
                "title": "java-solution-easy-to-solve",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] n1, int[][] n2) {\\n       \\n        Map<Integer,Integer> m=new HashMap<>();\\n        for(int i=0;i<n1.length;i++){\\n            int x=n1[i][0];\\n            int y=n1[i][1];\\n                if(!(m.containsKey(x))){\\n                    m.put(x,y);\\n                }\\n                else{\\n                    m.put(x,m.get(x)+y);\\n                }\\n            \\n        }\\n         for(int i=0;i<n2.length;i++){\\n            int x=n2[i][0];\\n            int y=n2[i][1];\\n                if(!(m.containsKey(x))){\\n                    m.put(x,y);\\n                }\\n                else{\\n                    m.put(x,m.get(x)+y);\\n                }\\n            \\n        }\\n        int r=0;\\n         int n[][]=new int[m.size()][2];\\n         ArrayList<Integer> a=new ArrayList<>();\\n          for(int i:m.keySet()){\\n              a.add(i);\\n          }\\n          Collections.sort(a);\\n        for(int i:a){\\n            int u=m.get(i);\\n            n[r][0]=i;\\n            n[r][1]=u;\\n            r++;\\n            \\n        }\\n        System.out.print(m.size());\\n        return n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] n1, int[][] n2) {\\n       \\n        Map<Integer,Integer> m=new HashMap<>();\\n        for(int i=0;i<n1.length;i++){\\n            int x=n1[i][0];\\n            int y=n1[i][1];\\n                if(!(m.containsKey(x))){\\n                    m.put(x,y);\\n                }\\n                else{\\n                    m.put(x,m.get(x)+y);\\n                }\\n            \\n        }\\n         for(int i=0;i<n2.length;i++){\\n            int x=n2[i][0];\\n            int y=n2[i][1];\\n                if(!(m.containsKey(x))){\\n                    m.put(x,y);\\n                }\\n                else{\\n                    m.put(x,m.get(x)+y);\\n                }\\n            \\n        }\\n        int r=0;\\n         int n[][]=new int[m.size()][2];\\n         ArrayList<Integer> a=new ArrayList<>();\\n          for(int i:m.keySet()){\\n              a.add(i);\\n          }\\n          Collections.sort(a);\\n        for(int i:a){\\n            int u=m.get(i);\\n            n[r][0]=i;\\n            n[r][1]=u;\\n            r++;\\n            \\n        }\\n        System.out.print(m.size());\\n        return n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4073984,
                "title": "two-pointers-approach-explained",
                "content": "# Approach\\nMove two pointers along both arrays\\' elements until one of them reaches the end. At this point appending the remaining elements from another array will give the resulting array (task constraint guarantees elements to be pre-sorted by id).\\n\\n# Code\\n```\\nclass Solution\\n{\\n\\tfunc mergeArrays(_ nums1: [[Int]], _ nums2: [[Int]]) -> [[Int]] {\\n\\t\\tguard !nums1.isEmpty else { return nums2 }\\n\\t\\tguard !nums2.isEmpty else { return nums1 }\\n\\n\\t\\tvar pointer1 = 0, pointer2 = 0\\n\\t\\tvar res = [[Int]]()\\n\\n\\t\\twhile true {\\n\\t\\t\\t// Check if one of the pointers has reached the end\\n\\n\\t\\t\\tguard pointer1 < nums1.count\\n\\t\\t\\telse { res.append(contentsOf: nums2[pointer2...]); break }\\n\\n\\t\\t\\tguard pointer2 < nums2.count\\n\\t\\t\\telse { res.append(contentsOf: nums1[pointer1...]); break }\\n\\n\\t\\t\\t// Check if the next \\'nums1\\' element has lower id\\n\\n\\t\\t\\tif nums1[pointer1][0] < nums2[pointer2][0]\\n\\t\\t\\t{\\n\\t\\t\\t\\tres.append([nums1[pointer1][0], nums1[pointer1][1]])\\n\\n\\t\\t\\t\\tpointer1 += 1\\n\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Check if the next \\'nums2\\' element has lower id\\n\\n\\t\\t\\tif nums1[pointer1][0] > nums2[pointer2][0]\\n\\t\\t\\t{\\n\\t\\t\\t\\tres.append([nums2[pointer2][0], nums2[pointer2][1]])\\n\\n\\t\\t\\t\\tpointer2 += 1\\n\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Both arrays\\' next elements share the same id\\n\\n\\t\\t\\tres.append([nums1[pointer1][0], nums1[pointer1][1] + nums2[pointer2][1]])\\n\\n\\t\\t\\tpointer1 += 1\\n\\t\\t\\tpointer2 += 1\\n\\t\\t}\\n\\n\\t\\treturn res\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution\\n{\\n\\tfunc mergeArrays(_ nums1: [[Int]], _ nums2: [[Int]]) -> [[Int]] {\\n\\t\\tguard !nums1.isEmpty else { return nums2 }\\n\\t\\tguard !nums2.isEmpty else { return nums1 }\\n\\n\\t\\tvar pointer1 = 0, pointer2 = 0\\n\\t\\tvar res = [[Int]]()\\n\\n\\t\\twhile true {\\n\\t\\t\\t// Check if one of the pointers has reached the end\\n\\n\\t\\t\\tguard pointer1 < nums1.count\\n\\t\\t\\telse { res.append(contentsOf: nums2[pointer2...]); break }\\n\\n\\t\\t\\tguard pointer2 < nums2.count\\n\\t\\t\\telse { res.append(contentsOf: nums1[pointer1...]); break }\\n\\n\\t\\t\\t// Check if the next \\'nums1\\' element has lower id\\n\\n\\t\\t\\tif nums1[pointer1][0] < nums2[pointer2][0]\\n\\t\\t\\t{\\n\\t\\t\\t\\tres.append([nums1[pointer1][0], nums1[pointer1][1]])\\n\\n\\t\\t\\t\\tpointer1 += 1\\n\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Check if the next \\'nums2\\' element has lower id\\n\\n\\t\\t\\tif nums1[pointer1][0] > nums2[pointer2][0]\\n\\t\\t\\t{\\n\\t\\t\\t\\tres.append([nums2[pointer2][0], nums2[pointer2][1]])\\n\\n\\t\\t\\t\\tpointer2 += 1\\n\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Both arrays\\' next elements share the same id\\n\\n\\t\\t\\tres.append([nums1[pointer1][0], nums1[pointer1][1] + nums2[pointer2][1]])\\n\\n\\t\\t\\tpointer1 += 1\\n\\t\\t\\tpointer2 += 1\\n\\t\\t}\\n\\n\\t\\treturn res\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4067633,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n   func mergeArrays(_ nums1: [[Int]], _ nums2: [[Int]]) -> [[Int]] {\\n    var dict = [Int:Int]()\\n    var ans = [[Int]]()\\n    \\n    for i in nums1 {\\n        let inx = i[0]\\n        let val = i[1]\\n        dict[inx] = val\\n        \\n    }\\n    \\n    for j in nums2 {\\n        let inx = j[0]\\n        let val = j[1]\\n        if dict[inx] != nil {\\n            dict[inx]! += val\\n        } else {\\n            dict[inx] = val\\n        }\\n    }\\n    \\n    var sortedDict = dict.sorted{ $0.0 < $1.0 }\\n    \\n    for i in sortedDict {\\n        ans.append([i.key,i.value])\\n    }\\n    \\n    return ans\\n}\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n   func mergeArrays(_ nums1: [[Int]], _ nums2: [[Int]]) -> [[Int]] {\\n    var dict = [Int:Int]()\\n    var ans = [[Int]]()\\n    \\n    for i in nums1 {\\n        let inx = i[0]\\n        let val = i[1]\\n        dict[inx] = val\\n        \\n    }\\n    \\n    for j in nums2 {\\n        let inx = j[0]\\n        let val = j[1]\\n        if dict[inx] != nil {\\n            dict[inx]! += val\\n        } else {\\n            dict[inx] = val\\n        }\\n    }\\n    \\n    var sortedDict = dict.sorted{ $0.0 < $1.0 }\\n    \\n    for i in sortedDict {\\n        ans.append([i.key,i.value])\\n    }\\n    \\n    return ans\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047726,
                "title": "99-runtime-99-memory-two-pointer-solution-without-sorting",
                "content": "![image.png](https://assets.leetcode.com/users/images/eaf3abcb-8da2-443c-bf0b-587d9e1b2c88_1694780391.5875485.png)\\n\\n\\n# Complexity\\n- Time complexity: O(n+m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n+m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        result, l, r, n1l, n2l = [], 0, 0, len(nums1), len(nums2)\\n\\n        while l < n1l or r < n2l:\\n            if l == n1l: result.append(nums2[r]); r += 1\\n            elif r == n2l: result.append(nums1[l]); l += 1\\n            else:\\n                if nums1[l][0] > nums2[r][0]:\\n                    result.append(nums2[r]); r += 1\\n\\n                elif nums1[l][0] < nums2[r][0]:\\n                    result.append(nums1[l]); l += 1\\n\\n                else:\\n                    result.append([nums1[l][0], nums1[l][1]+nums2[r][1]])\\n                    l += 1\\n                    r += 1\\n\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        result, l, r, n1l, n2l = [], 0, 0, len(nums1), len(nums2)\\n\\n        while l < n1l or r < n2l:\\n            if l == n1l: result.append(nums2[r]); r += 1\\n            elif r == n2l: result.append(nums1[l]); l += 1\\n            else:\\n                if nums1[l][0] > nums2[r][0]:\\n                    result.append(nums2[r]); r += 1\\n\\n                elif nums1[l][0] < nums2[r][0]:\\n                    result.append(nums1[l]); l += 1\\n\\n                else:\\n                    result.append([nums1[l][0], nums1[l][1]+nums2[r][1]])\\n                    l += 1\\n                    r += 1\\n\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037151,
                "title": "normal-solution",
                "content": "# Intuition\\nNormal Solution\\n```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        nums3 = nums2.copy()\\n        for i in range(len(nums1)):\\n            for j in range(len(nums2)):\\n                if nums1[i][0] == nums2[j][0]:\\n                    nums1[i][1] = nums1[i][1] + nums2[j][1]\\n                    nums3.remove(nums2[j])\\n        return sorted(nums1 + nums3) \\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        nums3 = nums2.copy()\\n        for i in range(len(nums1)):\\n            for j in range(len(nums2)):\\n                if nums1[i][0] == nums2[j][0]:\\n                    nums1[i][1] = nums1[i][1] + nums2[j][1]\\n                    nums3.remove(nums2[j])\\n        return sorted(nums1 + nums3) \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4036854,
                "title": "two-pointers-without-dictionary",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n   public int[][] MergeArrays(int[][] nums1, int[][] nums2)\\n    {\\n        List<int[]> result = new List<int[]>();\\n        int fIndex = 0;\\n        int sIndex = 0;\\n        while (fIndex < nums1.Length && sIndex < nums2.Length)\\n        {\\n            int start = nums1[fIndex][0];\\n            int end = nums2[sIndex][0];\\n\\n            if (start == end)\\n            {\\n                result.Add(new int[]{start, nums1[fIndex][1] + nums2[sIndex][1]});\\n                fIndex++;\\n                sIndex++;\\n            }\\n            else\\n            {\\n                if (start < end)\\n                {\\n                    result.Add(new int[]{start, nums1[fIndex][1]});\\n                    fIndex++;\\n\\n                }\\n                else\\n                {\\n                    result.Add(new int[]{end, nums2[sIndex][1]});\\n                    sIndex++;\\n\\n                }\\n            }\\n        }\\n\\n        while (fIndex < nums1.Length)\\n        {\\n            result.Add(new int[]{nums1[fIndex][0], nums1[fIndex][1]});\\n            fIndex++;\\n        }\\n\\n        while (sIndex < nums2.Length)\\n        {\\n            result.Add(new int[]{nums2[sIndex][0], nums2[sIndex][1]});\\n            sIndex++;\\n        }\\n        return result.ToArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n   public int[][] MergeArrays(int[][] nums1, int[][] nums2)\\n    {\\n        List<int[]> result = new List<int[]>();\\n        int fIndex = 0;\\n        int sIndex = 0;\\n        while (fIndex < nums1.Length && sIndex < nums2.Length)\\n        {\\n            int start = nums1[fIndex][0];\\n            int end = nums2[sIndex][0];\\n\\n            if (start == end)\\n            {\\n                result.Add(new int[]{start, nums1[fIndex][1] + nums2[sIndex][1]});\\n                fIndex++;\\n                sIndex++;\\n            }\\n            else\\n            {\\n                if (start < end)\\n                {\\n                    result.Add(new int[]{start, nums1[fIndex][1]});\\n                    fIndex++;\\n\\n                }\\n                else\\n                {\\n                    result.Add(new int[]{end, nums2[sIndex][1]});\\n                    sIndex++;\\n\\n                }\\n            }\\n        }\\n\\n        while (fIndex < nums1.Length)\\n        {\\n            result.Add(new int[]{nums1[fIndex][0], nums1[fIndex][1]});\\n            fIndex++;\\n        }\\n\\n        while (sIndex < nums2.Length)\\n        {\\n            result.Add(new int[]{nums2[sIndex][0], nums2[sIndex][1]});\\n            sIndex++;\\n        }\\n        return result.ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4036665,
                "title": "java-optimize-solution-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:**(nums1.length+nums2.length)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:**(nums1.length+nums2.length)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        ArrayList<ArrayList<Integer>> set = new ArrayList<>();\\n        int i=0, j=0;\\n\\n        while(i<nums1.length || j<nums2.length){\\n            ArrayList<Integer> s = new ArrayList<>();\\n            if(i<nums1.length && j<nums2.length && nums1[i][0]==nums2[j][0]){\\n                s.add(nums1[i][0]);\\n                s.add(nums1[i][1]+nums2[j][1]);\\n                i++; j++;\\n                set.add(s);\\n            } else if(i<nums1.length && (j>=nums2.length || nums1[i][0]<nums2[j][0])){\\n                s.add(nums1[i][0]);\\n                s.add(nums1[i][1]);\\n                set.add(s);\\n                i++;\\n            } else if(j<nums2.length){\\n                s.add(nums2[j][0]);\\n                s.add(nums2[j][1]);\\n                set.add(s);\\n                j++; \\n            }\\n        }\\n\\n        int [][] arr = new int[set.size()][set.get(0).size()];\\n        for(int x=0; x<set.size(); x++){\\n            for(int y=0; y<set.get(0).size(); y++){\\n                arr[x][y] = set.get(x).get(y);\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        ArrayList<ArrayList<Integer>> set = new ArrayList<>();\\n        int i=0, j=0;\\n\\n        while(i<nums1.length || j<nums2.length){\\n            ArrayList<Integer> s = new ArrayList<>();\\n            if(i<nums1.length && j<nums2.length && nums1[i][0]==nums2[j][0]){\\n                s.add(nums1[i][0]);\\n                s.add(nums1[i][1]+nums2[j][1]);\\n                i++; j++;\\n                set.add(s);\\n            } else if(i<nums1.length && (j>=nums2.length || nums1[i][0]<nums2[j][0])){\\n                s.add(nums1[i][0]);\\n                s.add(nums1[i][1]);\\n                set.add(s);\\n                i++;\\n            } else if(j<nums2.length){\\n                s.add(nums2[j][0]);\\n                s.add(nums2[j][1]);\\n                set.add(s);\\n                j++; \\n            }\\n        }\\n\\n        int [][] arr = new int[set.size()][set.get(0).size()];\\n        for(int x=0; x<set.size(); x++){\\n            for(int y=0; y<set.get(0).size(); y++){\\n                arr[x][y] = set.get(x).get(y);\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035011,
                "title": "o-n-typescript-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction mergeArrays(nums1: number[][], nums2: number[][]): number[][] {\\n    let result = []\\n    let leftIndex = 0\\n    let rightIndex = 0\\n    while (leftIndex < nums1.length && rightIndex < nums2.length) {\\n        if (nums1[leftIndex][0] === nums2[rightIndex][0]) {\\n            result.push([nums1[leftIndex][0], nums1[leftIndex][1] + nums2[rightIndex][1]])\\n            rightIndex++\\n            leftIndex++\\n        } else if (nums1[leftIndex][0] < nums2[rightIndex][0]) {\\n            result.push(nums1[leftIndex])\\n            leftIndex++\\n        } else {\\n            result.push(nums2[rightIndex])\\n            rightIndex++\\n        }\\n    }\\n    while (leftIndex < nums1.length) {\\n        result.push(nums1[leftIndex])\\n        leftIndex++\\n    }\\n    while (rightIndex < nums2.length) {\\n        result.push(nums2[rightIndex])\\n        rightIndex++\\n    }\\n    return result\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction mergeArrays(nums1: number[][], nums2: number[][]): number[][] {\\n    let result = []\\n    let leftIndex = 0\\n    let rightIndex = 0\\n    while (leftIndex < nums1.length && rightIndex < nums2.length) {\\n        if (nums1[leftIndex][0] === nums2[rightIndex][0]) {\\n            result.push([nums1[leftIndex][0], nums1[leftIndex][1] + nums2[rightIndex][1]])\\n            rightIndex++\\n            leftIndex++\\n        } else if (nums1[leftIndex][0] < nums2[rightIndex][0]) {\\n            result.push(nums1[leftIndex])\\n            leftIndex++\\n        } else {\\n            result.push(nums2[rightIndex])\\n            rightIndex++\\n        }\\n    }\\n    while (leftIndex < nums1.length) {\\n        result.push(nums1[leftIndex])\\n        leftIndex++\\n    }\\n    while (rightIndex < nums2.length) {\\n        result.push(nums2[rightIndex])\\n        rightIndex++\\n    }\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4033242,
                "title": "beat-60-percent-in-time-and-97-in-memory-and-easy-to-understand-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        i=0\\n        j=0\\n        ans=[]\\n        while(i<len(nums1) and j<len(nums2)):\\n            if nums1[i][0]==nums2[j][0]:\\n                nums1[i][1]+=nums2[j][1]\\n                ans.append(nums1[i])\\n                i+=1\\n                j+=1\\n            elif nums1[i][0]<nums2[j][0]:\\n                ans.append(nums1[i])\\n                i+=1\\n            else:\\n                ans.append(nums2[j])\\n                j+=1\\n        print(i,j)\\n        if (i!=len(nums1)):\\n            ans.extend(nums1[i:])\\n        elif (j!=len(nums2)):\\n            ans.extend(nums2[j:])\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        i=0\\n        j=0\\n        ans=[]\\n        while(i<len(nums1) and j<len(nums2)):\\n            if nums1[i][0]==nums2[j][0]:\\n                nums1[i][1]+=nums2[j][1]\\n                ans.append(nums1[i])\\n                i+=1\\n                j+=1\\n            elif nums1[i][0]<nums2[j][0]:\\n                ans.append(nums1[i])\\n                i+=1\\n            else:\\n                ans.append(nums2[j])\\n                j+=1\\n        print(i,j)\\n        if (i!=len(nums1)):\\n            ans.extend(nums1[i:])\\n        elif (j!=len(nums2)):\\n            ans.extend(nums2[j:])\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4032386,
                "title": "hindi-c-t-c-o-m-n-o-n-s-c-o-1",
                "content": "# Intuition\\nSaare elements ko ek ek karke check karo auro conditions ke acc. ans main add kardo  . \\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N) == O(n+m)\\n\\n- Space complexity:\\nO(1) -> ans space count nai hoga / kisi ek (nums1/nums2) main b ans store kar sakte hain .. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n        vector<vector<int>>ans ;\\n        int i  = 0 ; \\n        int j =  0 ; \\n        int n = nums1.size() ; \\n        int m = nums2.size() ;\\n        if(n==0)\\n        return nums2 ; \\n        if(m==0)\\n        return nums1 ; \\n        while(i<n&&j<m){\\n            if(ans.empty()){\\n                if(nums1[0][0]<nums2[0][0]){\\n                ans.push_back({nums1[0][0] , nums1[0][1]}) ; \\n                i++; \\n                }\\n                else{\\n                ans.push_back({nums2[0][0] , nums2[0][1]}) ;\\n                j++ ;\\n                }               \\n            }\\n            else{\\n                int a = nums1[i][0] ; \\n                int b = nums2[j][0] ; \\n                if(a==b){\\n                    int sum = nums1[i][1]+nums2[j][1] ; \\n                    if(ans[ans.size()-1][0]==a){\\n                        ans[ans.size()-1][1]+=sum ; \\n                    }\\n                    else{\\n                        ans.push_back({a , sum }) ; \\n                    }\\n                    i++ ; j++ ;\\n                }\\n                else if(a>b){                    \\n                     if(ans[ans.size()-1][0]==b){\\n                        ans[ans.size()-1][1]+=nums2[j][1] ; \\n                    }\\n                    else{\\n                        ans.push_back({b , nums2[j][1] }) ; \\n                    }\\n                    j++; \\n                }\\n                else{\\n                      if(ans[ans.size()-1][0]==a){\\n                        ans[ans.size()-1][1]+=nums1[i][1] ; \\n                    }\\n                    else{\\n                        ans.push_back({a , nums1[i][1] }) ; \\n                    }\\n                    i++ ; \\n                }\\n            }\\n        }\\n        while(i<n){\\n            ans.push_back({nums1[i][0] , nums1[i][1]});\\n            i++; \\n        }\\n        while(j<m){\\n           ans.push_back({nums2[j][0] , nums2[j][1]});\\n            j++; \\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n        vector<vector<int>>ans ;\\n        int i  = 0 ; \\n        int j =  0 ; \\n        int n = nums1.size() ; \\n        int m = nums2.size() ;\\n        if(n==0)\\n        return nums2 ; \\n        if(m==0)\\n        return nums1 ; \\n        while(i<n&&j<m){\\n            if(ans.empty()){\\n                if(nums1[0][0]<nums2[0][0]){\\n                ans.push_back({nums1[0][0] , nums1[0][1]}) ; \\n                i++; \\n                }\\n                else{\\n                ans.push_back({nums2[0][0] , nums2[0][1]}) ;\\n                j++ ;\\n                }               \\n            }\\n            else{\\n                int a = nums1[i][0] ; \\n                int b = nums2[j][0] ; \\n                if(a==b){\\n                    int sum = nums1[i][1]+nums2[j][1] ; \\n                    if(ans[ans.size()-1][0]==a){\\n                        ans[ans.size()-1][1]+=sum ; \\n                    }\\n                    else{\\n                        ans.push_back({a , sum }) ; \\n                    }\\n                    i++ ; j++ ;\\n                }\\n                else if(a>b){                    \\n                     if(ans[ans.size()-1][0]==b){\\n                        ans[ans.size()-1][1]+=nums2[j][1] ; \\n                    }\\n                    else{\\n                        ans.push_back({b , nums2[j][1] }) ; \\n                    }\\n                    j++; \\n                }\\n                else{\\n                      if(ans[ans.size()-1][0]==a){\\n                        ans[ans.size()-1][1]+=nums1[i][1] ; \\n                    }\\n                    else{\\n                        ans.push_back({a , nums1[i][1] }) ; \\n                    }\\n                    i++ ; \\n                }\\n            }\\n        }\\n        while(i<n){\\n            ans.push_back({nums1[i][0] , nums1[i][1]});\\n            i++; \\n        }\\n        while(j<m){\\n           ans.push_back({nums2[j][0] , nums2[j][1]});\\n            j++; \\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4024536,
                "title": "very-easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n         vector<vector<int >> res;\\n        int i=0,j=0,n = nums1.size(),m = nums2.size();\\n        \\n        while(i < n && j < m){\\n            int id1 = nums1[i][0],id2 = nums2[j][0];\\n            \\n            if(id1 == id2){\\n                int sum = nums1[i][1] + nums2[j][1];\\n                res.push_back({id1,sum});\\n                i++;\\n                j++;\\n            }\\n            else if(id1 > id2){\\n                res.push_back({id2,nums2[j][1]});\\n                j++;\\n            }\\n             else if(id1 < id2){\\n                res.push_back({id1,nums1[i][1]});\\n                i++;\\n            }                     \\n        }\\n        \\n        while(i < n){\\n            int id1 = nums1[i][0];\\n            res.push_back({id1,nums1[i][1]});\\n            i++;\\n        }\\n        \\n        while(j < m){\\n            int id2 = nums2[j][0];\\n            res.push_back({id2,nums2[j][1]});\\n            j++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n         vector<vector<int >> res;\\n        int i=0,j=0,n = nums1.size(),m = nums2.size();\\n        \\n        while(i < n && j < m){\\n            int id1 = nums1[i][0],id2 = nums2[j][0];\\n            \\n            if(id1 == id2){\\n                int sum = nums1[i][1] + nums2[j][1];\\n                res.push_back({id1,sum});\\n                i++;\\n                j++;\\n            }\\n            else if(id1 > id2){\\n                res.push_back({id2,nums2[j][1]});\\n                j++;\\n            }\\n             else if(id1 < id2){\\n                res.push_back({id1,nums1[i][1]});\\n                i++;\\n            }                     \\n        }\\n        \\n        while(i < n){\\n            int id1 = nums1[i][0];\\n            res.push_back({id1,nums1[i][1]});\\n            i++;\\n        }\\n        \\n        while(j < m){\\n            int id2 = nums2[j][0];\\n            res.push_back({id2,nums2[j][1]});\\n            j++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018629,
                "title": "easy-c-solution-using-map",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n        map<int,int>mp;\\n        for(int i=0;i<nums1.size();i++){\\n            mp[nums1[i][0]]=nums1[i][1];\\n        }\\n        for(int i=0;i<nums2.size();i++){\\n            if(mp.find(nums2[i][0])!=mp.end()){\\n                mp[nums2[i][0]]=mp[nums2[i][0]]+nums2[i][1];\\n            }\\n            else{\\n            mp[nums2[i][0]]=nums2[i][1];\\n            }\\n        }\\n        vector<vector<int>>ans;\\n        for(auto it:mp){\\n            vector<int>temp;\\n            temp.push_back(it.first);\\n            temp.push_back(it.second);\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n        map<int,int>mp;\\n        for(int i=0;i<nums1.size();i++){\\n            mp[nums1[i][0]]=nums1[i][1];\\n        }\\n        for(int i=0;i<nums2.size();i++){\\n            if(mp.find(nums2[i][0])!=mp.end()){\\n                mp[nums2[i][0]]=mp[nums2[i][0]]+nums2[i][1];\\n            }\\n            else{\\n            mp[nums2[i][0]]=nums2[i][1];\\n            }\\n        }\\n        vector<vector<int>>ans;\\n        for(auto it:mp){\\n            vector<int>temp;\\n            temp.push_back(it.first);\\n            temp.push_back(it.second);\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011852,
                "title": "simple-java-solution",
                "content": "# Intuition\\nUsed Two pointers technique\\n\\n# Approach\\nIt\\'s related to the merge sort\\'s merge prinicple, comparing the two auxillary arrays \\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n $$O(n*m)$$ where n and m are the length of the nums1 and nums2 array respectively.\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        List<List<Integer>> list = new ArrayList<>();\\n\\n        int i = 0;\\n        int j = 0;\\n\\n        while(i < nums1.length && j < nums2.length){\\n            if(nums1[i][0] == nums2[j][0]){\\n                list.add(Arrays.asList(nums1[i][0],nums1[i][1]+nums2[j][1]));\\n                i++;\\n                j++;\\n            }else if(nums1[i][0] < nums2[j][0]){\\n                list.add(Arrays.asList(nums1[i][0],nums1[i][1]));\\n                i++;\\n            }else{\\n                list.add(Arrays.asList(nums2[j][0],nums2[j][1]));\\n                j++;\\n            }\\n        }\\n        while(i < nums1.length){\\n            list.add(Arrays.asList(nums1[i][0],nums1[i][1]));\\n            i++;\\n        }\\n        while(j < nums2.length){\\n            list.add(Arrays.asList(nums2[j][0],nums2[j][1]));\\n            j++;\\n        }\\n        return list.stream().map((inner)->{\\n            return inner.stream().mapToInt(Integer::intValue).toArray();\\n        }).toArray(int[][]::new);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        List<List<Integer>> list = new ArrayList<>();\\n\\n        int i = 0;\\n        int j = 0;\\n\\n        while(i < nums1.length && j < nums2.length){\\n            if(nums1[i][0] == nums2[j][0]){\\n                list.add(Arrays.asList(nums1[i][0],nums1[i][1]+nums2[j][1]));\\n                i++;\\n                j++;\\n            }else if(nums1[i][0] < nums2[j][0]){\\n                list.add(Arrays.asList(nums1[i][0],nums1[i][1]));\\n                i++;\\n            }else{\\n                list.add(Arrays.asList(nums2[j][0],nums2[j][1]));\\n                j++;\\n            }\\n        }\\n        while(i < nums1.length){\\n            list.add(Arrays.asList(nums1[i][0],nums1[i][1]));\\n            i++;\\n        }\\n        while(j < nums2.length){\\n            list.add(Arrays.asList(nums2[j][0],nums2[j][1]));\\n            j++;\\n        }\\n        return list.stream().map((inner)->{\\n            return inner.stream().mapToInt(Integer::intValue).toArray();\\n        }).toArray(int[][]::new);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010456,
                "title": "1ms-beats-92-easy-solution",
                "content": "# If you found useful, Upvote it!\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        int arr[]=new int[1001];\\n        int count=0;\\n        for(int [] i:nums1){\\n            arr[i[0]]=i[1];\\n            count++;\\n        }\\n        for(int [] i:nums2){\\n            if(arr[i[0]]==0) count++;\\n            arr[i[0]]+=i[1];\\n        }\\n        int res[][]=new int[count][2];\\n        int row=0;\\n        int col=0;\\n        for(int i=0;i<1001;i++){    \\n            if(arr[i]>0){\\n                res[row][col++]=i;\\n                res[row++][col--]=arr[i];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        int arr[]=new int[1001];\\n        int count=0;\\n        for(int [] i:nums1){\\n            arr[i[0]]=i[1];\\n            count++;\\n        }\\n        for(int [] i:nums2){\\n            if(arr[i[0]]==0) count++;\\n            arr[i[0]]+=i[1];\\n        }\\n        int res[][]=new int[count][2];\\n        int row=0;\\n        int col=0;\\n        for(int i=0;i<1001;i++){    \\n            if(arr[i]>0){\\n                res[row][col++]=i;\\n                res[row++][col--]=arr[i];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3989469,
                "title": "c-very-simple-solution-7-ms-beats-87-20-memory-10-7-mb-beats-71-97",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n        vector<vector<int>> vect;\\n        int len1 = nums1.size(), len2 = nums2.size();\\n        int i = 0, j = 0;\\n        while(i < len1 && j < len2){\\n            if(nums1[i][0] == nums2[j][0]){\\n                vect.push_back({nums1[i][0], nums1[i][1]+nums2[j][1]});\\n                i++; j++;\\n            }\\n            else if(nums1[i][0] < nums2[j][0]){\\n                vect.push_back({nums1[i][0], nums1[i][1]});\\n                i++;\\n            }\\n            else if (nums1[i][0] > nums2[j][0]){\\n                vect.push_back({nums2[j][0], nums2[j][1]});\\n                j++;\\n            }\\n        }\\n        while(i < len1){\\n          vect.push_back({nums1[i][0], nums1[i][1]});\\n          i++;\\n        }\\n        while(j < len2){\\n          vect.push_back({nums2[j][0], nums2[j][1]});\\n          j++;\\n        }\\n        return vect;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n        vector<vector<int>> vect;\\n        int len1 = nums1.size(), len2 = nums2.size();\\n        int i = 0, j = 0;\\n        while(i < len1 && j < len2){\\n            if(nums1[i][0] == nums2[j][0]){\\n                vect.push_back({nums1[i][0], nums1[i][1]+nums2[j][1]});\\n                i++; j++;\\n            }\\n            else if(nums1[i][0] < nums2[j][0]){\\n                vect.push_back({nums1[i][0], nums1[i][1]});\\n                i++;\\n            }\\n            else if (nums1[i][0] > nums2[j][0]){\\n                vect.push_back({nums2[j][0], nums2[j][1]});\\n                j++;\\n            }\\n        }\\n        while(i < len1){\\n          vect.push_back({nums1[i][0], nums1[i][1]});\\n          i++;\\n        }\\n        while(j < len2){\\n          vect.push_back({nums2[j][0], nums2[j][1]});\\n          j++;\\n        }\\n        return vect;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3982549,
                "title": "my-fastest-solution-with-arraylist-and-buckets",
                "content": "# Code\\n```\\nclass Solution {\\n  public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n    int[] bucket = new int[1001];\\n    List<int[]> response = new ArrayList<>();\\n\\n    for (int i = 0; i < nums1.length; i++) {\\n      bucket[nums1[i][0]] += nums1[i][1];\\n    }\\n\\n    for (int i = 0; i < nums2.length; i++) {\\n      bucket[nums2[i][0]] += nums2[i][1];\\n    }\\n\\n    for (int i = 0; i < bucket.length; i++) {\\n      if (bucket[i] >= 1) {\\n        response.add(new int[]{i, bucket[i]});\\n      }\\n    }\\n\\n    return response.toArray(new int[0][]);\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n    int[] bucket = new int[1001];\\n    List<int[]> response = new ArrayList<>();\\n\\n    for (int i = 0; i < nums1.length; i++) {\\n      bucket[nums1[i][0]] += nums1[i][1];\\n    }\\n\\n    for (int i = 0; i < nums2.length; i++) {\\n      bucket[nums2[i][0]] += nums2[i][1];\\n    }\\n\\n    for (int i = 0; i < bucket.length; i++) {\\n      if (bucket[i] >= 1) {\\n        response.add(new int[]{i, bucket[i]});\\n      }\\n    }\\n\\n    return response.toArray(new int[0][]);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3978164,
                "title": "map-solution-ts-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction mergeArrays(nums1: number[][], nums2: number[][]): number[][] {\\n  let map = new Map<number, number>();\\n  nums1.concat(nums2).forEach((nums: number[]) => {\\n    if (map.has(nums[0])) {\\n      map.set(nums[0], map.get(nums[0]) + nums[1]);\\n    } else {\\n      map.set(nums[0], nums[1]);\\n    }\\n  });\\n\\n  return [...map.entries()].sort((a: number[], b: number[]) => a[0] - b[0]);\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction mergeArrays(nums1: number[][], nums2: number[][]): number[][] {\\n  let map = new Map<number, number>();\\n  nums1.concat(nums2).forEach((nums: number[]) => {\\n    if (map.has(nums[0])) {\\n      map.set(nums[0], map.get(nums[0]) + nums[1]);\\n    } else {\\n      map.set(nums[0], nums[1]);\\n    }\\n  });\\n\\n  return [...map.entries()].sort((a: number[], b: number[]) => a[0] - b[0]);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3971559,
                "title": "python-easy-hashmap-dictionary-implementation",
                "content": "# Intuition\\nCreate a hashmap and perform lookup.\\nIf key present, then add the value \\nIf not, then create a new key-value pair\\n\\nReturn a sorted nested list from the hashmap by using the [[--enter nested list argument--]]\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(Nlogn) due to sorted function\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def mergeArrays(self, nums1, nums2):\\n\\n        hashmap = {}\\n        for i in nums1 + nums2:\\n            if i[0] in hashmap:\\n                hashmap[i[0]]+= i[1]\\n            else:\\n                hashmap[i[0]]=i[1]  \\n                \\n        return sorted([[i , hashmap[i]] for i in hashmap])\\n        \\n        \\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def mergeArrays(self, nums1, nums2):\\n\\n        hashmap = {}\\n        for i in nums1 + nums2:\\n            if i[0] in hashmap:\\n                hashmap[i[0]]+= i[1]\\n            else:\\n                hashmap[i[0]]=i[1]  \\n                \\n        return sorted([[i , hashmap[i]] for i in hashmap])\\n        \\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3966922,
                "title": "simpler-for-beginners",
                "content": "## Time complexity: O(n log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n## Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n## Code\\n```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        d =  {}\\n        for [i,j] in nums1:\\n            d[i] = j\\n        for [i,j] in nums2:\\n            if i in d.keys():\\n                d[i] += j\\n            else:\\n                d[i] = j\\n        res = []\\n        for i in d:\\n            res.append([i , d[i]])\\n        \\n        s = sorted(res, key=lambda x: x[0])\\n        return s\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        d =  {}\\n        for [i,j] in nums1:\\n            d[i] = j\\n        for [i,j] in nums2:\\n            if i in d.keys():\\n                d[i] += j\\n            else:\\n                d[i] = j\\n        res = []\\n        for i in d:\\n            res.append([i , d[i]])\\n        \\n        s = sorted(res, key=lambda x: x[0])\\n        return s\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952758,
                "title": "easy-solution-in-c",
                "content": "# Intuition\\n\\n\\n# Approach\\n\\n\\n# Complexity\\nO(n)\\n\\n- Space complexity:\\n- \\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n        vector<vector<int>>v;\\n        map<int,int>m;\\n        for(auto n:nums1){\\n            m[n[0]]+=n[1];\\n        }\\n        for(auto n:nums2){\\n            m[n[0]]+=n[1];\\n        }\\n\\n        for(auto const &p:m){\\n            v.push_back({p.first,p.second});\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n        vector<vector<int>>v;\\n        map<int,int>m;\\n        for(auto n:nums1){\\n            m[n[0]]+=n[1];\\n        }\\n        for(auto n:nums2){\\n            m[n[0]]+=n[1];\\n        }\\n\\n        for(auto const &p:m){\\n            v.push_back({p.first,p.second});\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3949549,
                "title": "python-easy-using-dictionary-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def mergeArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[List[int]]\\n        :type nums2: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n\\n        lookup = {}\\n        res = []\\n        \\n        for num in nums1:\\n            i = num[0]\\n            val = num[1]\\n            lookup[i] = val\\n        for num in nums2:\\n            i = num[0]\\n            val = num[1]\\n            if i in lookup:\\n                lookup[i] += val\\n            else:\\n                lookup[i] = val\\n        \\n        for k, v in lookup.items():\\n            res.append([k, v])\\n        \\n        res.sort(key = lambda x: x[0])\\n        return res\\n        \\n        \\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def mergeArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[List[int]]\\n        :type nums2: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n\\n        lookup = {}\\n        res = []\\n        \\n        for num in nums1:\\n            i = num[0]\\n            val = num[1]\\n            lookup[i] = val\\n        for num in nums2:\\n            i = num[0]\\n            val = num[1]\\n            if i in lookup:\\n                lookup[i] += val\\n            else:\\n                lookup[i] = val\\n        \\n        for k, v in lookup.items():\\n            res.append([k, v])\\n        \\n        res.sort(key = lambda x: x[0])\\n        return res\\n        \\n        \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938219,
                "title": "using-pyhon",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def mergeArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[List[int]]\\n        :type nums2: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n\\n        nums1.extend(nums2)\\n        nums1.sort()     \\n\\n        res,i=[],0\\n      \\n\\n        while i < (len(nums1)-1):\\n                 t=0\\n              \\n                 if nums1[i][0]==nums1[i+1][0]:\\n                        t=[nums1[i][0],nums1[i][1]+nums1[i+1][1]]\\n                        res.append(t)\\n                        i+=2\\n                 else:\\n                        res.append(nums1[i])\\n                        i+=1\\n             \\n                        \\n        if res[-1][0]==nums1[-1][0]:\\n                return res\\n        else:\\n                res.append(nums1[-1])\\n                return res\\n```",
                "solutionTags": [
                    "Python",
                    "Array"
                ],
                "code": "```\\nclass Solution(object):\\n    def mergeArrays(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[List[int]]\\n        :type nums2: List[List[int]]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n\\n        nums1.extend(nums2)\\n        nums1.sort()     \\n\\n        res,i=[],0\\n      \\n\\n        while i < (len(nums1)-1):\\n                 t=0\\n              \\n                 if nums1[i][0]==nums1[i+1][0]:\\n                        t=[nums1[i][0],nums1[i][1]+nums1[i+1][1]]\\n                        res.append(t)\\n                        i+=2\\n                 else:\\n                        res.append(nums1[i])\\n                        i+=1\\n             \\n                        \\n        if res[-1][0]==nums1[-1][0]:\\n                return res\\n        else:\\n                res.append(nums1[-1])\\n                return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3937991,
                "title": "java-1-ms-solution-without-extra-space",
                "content": "### using Array\\n```java\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        int n1 = nums1.length;\\n        int n2 = nums2.length;\\n        int[][] res = new int[n1+n2][2];\\n\\n        int i = 0, j = 0;\\n        int idx = 0;\\n        while(i<n1 && j<n2) {\\n            if(nums1[i][0] == nums2[j][0]) {\\n                res[idx][0] = nums1[i][0];\\n                res[idx][1] = nums1[i][1] + nums2[j][1];\\n                i++;\\n                j++;\\n            } else if(nums1[i][0] < nums2[j][0]) {\\n                res[idx][0] = nums1[i][0];\\n                res[idx][1] = nums1[i][1];\\n                i++;\\n            } else {\\n                res[idx][0] = nums2[j][0];\\n                res[idx][1] = nums2[j][1];\\n                j++;\\n            }\\n            idx++;\\n        }\\n        while(i<n1) {\\n            res[idx][0] = nums1[i][0];\\n            res[idx][1] = nums1[i][1];\\n            i++;\\n            idx++;\\n        }\\n        while(j<n2) {\\n            res[idx][0] = nums2[j][0];\\n            res[idx][1] = nums2[j][1];\\n            j++;\\n            idx++;\\n        }\\n\\n        return Arrays.copyOf(res, idx);\\n    }\\n}\\n```\\n\\n### same approach - but with linkedlist\\n\\n```java\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        int n1 = nums1.length, n2=nums2.length;\\n        int i=0,j=0;\\n        List<int[]>ans = new ArrayList();\\n        while(i<n1 && j<n2) {\\n            if(nums1[i][0]==nums2[j][0]) {\\n                ans.add(new int[] {nums1[i][0],nums1[i][1]+nums2[j][1]});\\n                i++;\\n                j++;\\n            } else if(nums1[i][0] < nums2[j][0]){\\n                ans.add(nums1[i]);\\n                i++;\\n            } else {\\n                ans.add(nums2[j]);\\n                j++;\\n            }\\n        }\\n\\n        while(i<n1) {\\n            ans.add(nums1[i++]);\\n        }\\n        while(j<n2) {\\n            ans.add(nums2[j++]);\\n        }\\n\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        int n1 = nums1.length;\\n        int n2 = nums2.length;\\n        int[][] res = new int[n1+n2][2];\\n\\n        int i = 0, j = 0;\\n        int idx = 0;\\n        while(i<n1 && j<n2) {\\n            if(nums1[i][0] == nums2[j][0]) {\\n                res[idx][0] = nums1[i][0];\\n                res[idx][1] = nums1[i][1] + nums2[j][1];\\n                i++;\\n                j++;\\n            } else if(nums1[i][0] < nums2[j][0]) {\\n                res[idx][0] = nums1[i][0];\\n                res[idx][1] = nums1[i][1];\\n                i++;\\n            } else {\\n                res[idx][0] = nums2[j][0];\\n                res[idx][1] = nums2[j][1];\\n                j++;\\n            }\\n            idx++;\\n        }\\n        while(i<n1) {\\n            res[idx][0] = nums1[i][0];\\n            res[idx][1] = nums1[i][1];\\n            i++;\\n            idx++;\\n        }\\n        while(j<n2) {\\n            res[idx][0] = nums2[j][0];\\n            res[idx][1] = nums2[j][1];\\n            j++;\\n            idx++;\\n        }\\n\\n        return Arrays.copyOf(res, idx);\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        int n1 = nums1.length, n2=nums2.length;\\n        int i=0,j=0;\\n        List<int[]>ans = new ArrayList();\\n        while(i<n1 && j<n2) {\\n            if(nums1[i][0]==nums2[j][0]) {\\n                ans.add(new int[] {nums1[i][0],nums1[i][1]+nums2[j][1]});\\n                i++;\\n                j++;\\n            } else if(nums1[i][0] < nums2[j][0]){\\n                ans.add(nums1[i]);\\n                i++;\\n            } else {\\n                ans.add(nums2[j]);\\n                j++;\\n            }\\n        }\\n\\n        while(i<n1) {\\n            ans.add(nums1[i++]);\\n        }\\n        while(j<n2) {\\n            ans.add(nums2[j++]);\\n        }\\n\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3935684,
                "title": "python-easy-beginner-friendly-solution-beating-75-97",
                "content": "# Intuition\\nAnd so, we need a final list, where each id is unique, and the value can be either one of two or the sum of two - I think using a dictionary for this is not the worst option, right?\\n# Approach\\nIt\\'s simple - we add ALL elements of the first list to the dictionary through a loop, vecause by the condition in one list cannot be two lists with the same ID. In this case, the check should be done only in the second loop - if such an id is already in the dictionary, then add a value to it in the second list, if not, then add a new key with a value in this list. After that, we simply take key-value pairs through the \"items\" method of the dictionary and use list comprehension to turn all tuples into lists.\\n\\nUpvote it if you like this approach, thanks <3\\n# Complexity\\n- Time complexity:\\nO(len(nums1) + len(nums2)) ------->  #(double for loop)\\n# Code\\n```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        res = {}\\n        for pair in nums1:\\n            res[pair[0]] = pair[1]\\n        for pair in nums2:\\n            if pair[0] in res:\\n                res[pair[0]] += pair[1]\\n            else:\\n                res[pair[0]] = pair[1]\\n        return [list(el) for el in sorted(res.items(), key=lambda x: x[0])]\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        res = {}\\n        for pair in nums1:\\n            res[pair[0]] = pair[1]\\n        for pair in nums2:\\n            if pair[0] in res:\\n                res[pair[0]] += pair[1]\\n            else:\\n                res[pair[0]] = pair[1]\\n        return [list(el) for el in sorted(res.items(), key=lambda x: x[0])]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3931656,
                "title": "easy-c-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n        map<int,int>m;\\n        for(int i=0;i<nums1.size();i++){\\n            m[nums1[i][0]]=nums1[i][1];\\n        }\\n        for(int i=0;i<nums2.size();i++){\\n            m[nums2[i][0]]+=nums2[i][1];\\n        }\\n        vector<vector<int>> v;\\n        \\n        for(auto i:m){\\n          vector<int>temp(2);\\n          temp[0]=i.first;\\n          temp[1]=i.second;\\n          v.push_back(temp); \\n            \\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n        map<int,int>m;\\n        for(int i=0;i<nums1.size();i++){\\n            m[nums1[i][0]]=nums1[i][1];\\n        }\\n        for(int i=0;i<nums2.size();i++){\\n            m[nums2[i][0]]+=nums2[i][1];\\n        }\\n        vector<vector<int>> v;\\n        \\n        for(auto i:m){\\n          vector<int>temp(2);\\n          temp[0]=i.first;\\n          temp[1]=i.second;\\n          v.push_back(temp); \\n            \\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928326,
                "title": "easy-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n        vector<vector<int>> merged;\\n    int i = 0, j = 0;\\n    \\n    while (i < nums1.size() && j < nums2.size()) {\\n        if (nums1[i][0] < nums2[j][0]) {\\n            merged.push_back(nums1[i]);\\n            i++;\\n        } else if (nums1[i][0] > nums2[j][0]) {\\n            merged.push_back(nums2[j]);\\n            j++;\\n        } else {\\n            merged.push_back({nums1[i][0], nums1[i][1] + nums2[j][1]});\\n            i++;\\n            j++;\\n        }\\n    }\\n    \\n    while (i < nums1.size()) {\\n        merged.push_back(nums1[i]);\\n        i++;\\n    }\\n    \\n    while (j < nums2.size()) {\\n        merged.push_back(nums2[j]);\\n        j++;\\n    }\\n    \\n    return merged;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n        vector<vector<int>> merged;\\n    int i = 0, j = 0;\\n    \\n    while (i < nums1.size() && j < nums2.size()) {\\n        if (nums1[i][0] < nums2[j][0]) {\\n            merged.push_back(nums1[i]);\\n            i++;\\n        } else if (nums1[i][0] > nums2[j][0]) {\\n            merged.push_back(nums2[j]);\\n            j++;\\n        } else {\\n            merged.push_back({nums1[i][0], nums1[i][1] + nums2[j][1]});\\n            i++;\\n            j++;\\n        }\\n    }\\n    \\n    while (i < nums1.size()) {\\n        merged.push_back(nums1[i]);\\n        i++;\\n    }\\n    \\n    while (j < nums2.size()) {\\n        merged.push_back(nums2[j]);\\n        j++;\\n    }\\n    \\n    return merged;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3905149,
                "title": "solution-by-merge-sort",
                "content": "# Intuition\\nWe can solve problem with merge sort algorithm.\\n\\n# Approach\\nAs we know both arrays is already sorted. And because of that we can just make a one loop and merge each pair like a merge sort. At the end we just checking if any of arrays have a not the same lenght. For better unserstanding wath the code below!\\n\\n# Complexity\\n- Time complexity: O(n + m) where n - is len(nums1), and m - is len(nums2)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        res, right, left = [], 0, 0\\n        while left < len(nums1) and right < len(nums2):\\n            if nums1[left][0] == nums2[right][0]:\\n                res.append([nums1[left][0], nums1[left][1] + nums2[right][1]])\\n                left, right = left + 1, right + 1\\n            else:\\n                if nums1[left][0] < nums2[right][0]:\\n                    res.append([nums1[left][0], nums1[left][1]])\\n                    left += 1\\n                else:\\n                    res.append([nums2[right][0], nums2[right][1]])\\n                    right += 1\\n        while left < len(nums1):\\n            res.append(nums1[left])\\n            left += 1\\n        while right < len(nums2):\\n            res.append(nums2[right])\\n            right += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        res, right, left = [], 0, 0\\n        while left < len(nums1) and right < len(nums2):\\n            if nums1[left][0] == nums2[right][0]:\\n                res.append([nums1[left][0], nums1[left][1] + nums2[right][1]])\\n                left, right = left + 1, right + 1\\n            else:\\n                if nums1[left][0] < nums2[right][0]:\\n                    res.append([nums1[left][0], nums1[left][1]])\\n                    left += 1\\n                else:\\n                    res.append([nums2[right][0], nums2[right][1]])\\n                    right += 1\\n        while left < len(nums1):\\n            res.append(nums1[left])\\n            left += 1\\n        while right < len(nums2):\\n            res.append(nums2[right])\\n            right += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3900905,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n        map<int, int> map;\\n        for (const auto& v: nums1) {\\n            map[v[0]] += v[1];\\n        }\\n        for (const auto& v: nums2) {\\n            map[v[0]] += v[1];\\n        }\\n\\n        vector<vector<int>> res;\\n        for (const auto& r: map) {\\n            res.push_back({r.first, r.second});\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n        map<int, int> map;\\n        for (const auto& v: nums1) {\\n            map[v[0]] += v[1];\\n        }\\n        for (const auto& v: nums2) {\\n            map[v[0]] += v[1];\\n        }\\n\\n        vector<vector<int>> res;\\n        for (const auto& r: map) {\\n            res.push_back({r.first, r.second});\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3900396,
                "title": "easy-python-code-beats-76-user",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        dic={}\\n        \\n        for i in nums1:\\n            id=i[0]\\n            val=i[1]\\n            if id in dic:\\n                dic[id]+=val\\n            else:\\n                dic[id]=val\\n        for i in nums2:\\n            id=i[0]\\n            val=i[1]\\n            if id in dic:\\n                dic[id]+=val\\n            else:\\n                dic[id]=val\\n        ans=[]\\n\\n        for i in sorted(dic.keys()):\\n            ans.append([i,dic[i]])\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        dic={}\\n        \\n        for i in nums1:\\n            id=i[0]\\n            val=i[1]\\n            if id in dic:\\n                dic[id]+=val\\n            else:\\n                dic[id]=val\\n        for i in nums2:\\n            id=i[0]\\n            val=i[1]\\n            if id in dic:\\n                dic[id]+=val\\n            else:\\n                dic[id]=val\\n        ans=[]\\n\\n        for i in sorted(dic.keys()):\\n            ans.append([i,dic[i]])\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3895154,
                "title": "two-pointers-100",
                "content": "\\n![image.png](https://assets.leetcode.com/users/images/5f4a1a94-8fb5-489d-b427-5de5fc7d6f01_1691762217.7640755.png)\\n\\n# Code\\n```\\nfunc mergeArrays(nums1 [][]int, nums2 [][]int) [][]int {\\n    ans := make([][]int, len(nums1)+len(nums2))\\n    \\n    w := 0\\n    r1 := 0\\n    r2 := 0\\n    for; w < len(ans); w++ {\\n        if !(r1 < len(nums1) && r2 < len(nums2)) { break; }\\n        switch {\\n        case nums1[r1][0] == nums2[r2][0]: \\n            ans[w] = []int{nums1[r1][0], nums1[r1][1] + nums2[r2][1]}\\n            r1++;\\n            r2++;\\n        case nums1[r1][0] < nums2[r2][0]: ans[w] = nums1[r1]; r1++;\\n        case nums1[r1][0] > nums2[r2][0]: ans[w] = nums2[r2]; r2++;\\n        }\\n    }\\n    \\n    for ; r1 < len(nums1); r1++ { ans[w] = nums1[r1]; w++ }\\n    for ; r2 < len(nums2); r2++ { ans[w] = nums2[r2]; w++ }\\n    \\n    return ans[:w]\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc mergeArrays(nums1 [][]int, nums2 [][]int) [][]int {\\n    ans := make([][]int, len(nums1)+len(nums2))\\n    \\n    w := 0\\n    r1 := 0\\n    r2 := 0\\n    for; w < len(ans); w++ {\\n        if !(r1 < len(nums1) && r2 < len(nums2)) { break; }\\n        switch {\\n        case nums1[r1][0] == nums2[r2][0]: \\n            ans[w] = []int{nums1[r1][0], nums1[r1][1] + nums2[r2][1]}\\n            r1++;\\n            r2++;\\n        case nums1[r1][0] < nums2[r2][0]: ans[w] = nums1[r1]; r1++;\\n        case nums1[r1][0] > nums2[r2][0]: ans[w] = nums2[r2]; r2++;\\n        }\\n    }\\n    \\n    for ; r1 < len(nums1); r1++ { ans[w] = nums1[r1]; w++ }\\n    for ; r2 < len(nums2); r2++ { ans[w] = nums2[r2]; w++ }\\n    \\n    return ans[:w]\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3894227,
                "title": "java-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n    HashMap<Integer,Integer>hm=new HashMap<>();\\n    for(int a[]:nums1){\\n        if(!hm.containsKey(a[0])){\\n            hm.put(a[0],a[1]);\\n        }else{\\n            hm.put(a[0],hm.get(a[0])+a[1]);\\n        }\\n    }\\n    for(int a[]:nums2){\\n        if(!hm.containsKey(a[0])){\\n            hm.put(a[0],a[1]);\\n        }else{\\n            hm.put(a[0],hm.get(a[0])+a[1]);\\n        }\\n    }\\n    List<Integer>l2=new ArrayList<>();\\n    for(int key:hm.keySet()){\\n        l2.add(key);\\n    }\\n    Collections.sort(l2);\\n    int arr[][]=new int[hm.size()][2];\\n    int k=0;\\n    for(int i:l2){\\n        arr[k][0]=i;\\n        arr[k][1]=hm.get(i);\\n        k++;\\n    }\\n    return arr;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n    HashMap<Integer,Integer>hm=new HashMap<>();\\n    for(int a[]:nums1){\\n        if(!hm.containsKey(a[0])){\\n            hm.put(a[0],a[1]);\\n        }else{\\n            hm.put(a[0],hm.get(a[0])+a[1]);\\n        }\\n    }\\n    for(int a[]:nums2){\\n        if(!hm.containsKey(a[0])){\\n            hm.put(a[0],a[1]);\\n        }else{\\n            hm.put(a[0],hm.get(a[0])+a[1]);\\n        }\\n    }\\n    List<Integer>l2=new ArrayList<>();\\n    for(int key:hm.keySet()){\\n        l2.add(key);\\n    }\\n    Collections.sort(l2);\\n    int arr[][]=new int[hm.size()][2];\\n    int k=0;\\n    for(int i:l2){\\n        arr[k][0]=i;\\n        arr[k][1]=hm.get(i);\\n        k++;\\n    }\\n    return arr;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885392,
                "title": "merge-2d-arrays",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        nums1.extend(nums2)\\n        nums1=sorted(nums1,key=lambda x:x[0])\\n        i=0\\n        while True:\\n            if i<len(nums1)-1 :\\n                if nums1[i][0]==nums1[i+1][0]:\\n                    nums1[i][1]+=nums1[i+1][1]\\n                    nums1.remove(nums1[i+1])\\n            else:\\n                return nums1\\n            i+=1\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        nums1.extend(nums2)\\n        nums1=sorted(nums1,key=lambda x:x[0])\\n        i=0\\n        while True:\\n            if i<len(nums1)-1 :\\n                if nums1[i][0]==nums1[i+1][0]:\\n                    nums1[i][1]+=nums1[i+1][1]\\n                    nums1.remove(nums1[i+1])\\n            else:\\n                return nums1\\n            i+=1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3882323,
                "title": "solution-using-a-dictionary",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[][] MergeArrays(int[][] nums1, int[][] nums2) {\\n        \\n        SortedDictionary<int, int> findId = new SortedDictionary<int, int>();\\n\\n        foreach (var element in nums1)\\n        {\\n            for(int i = 0; i < element.Length; i+=2)\\n            {\\n                findId[element[i]] = findId.GetValueOrDefault(element[i], 0) + element[i + 1];\\n            }\\n        }\\n\\n        foreach (var element in nums2)\\n        {\\n            for(int i = 0; i < element.Length; i+=2)\\n            {\\n                findId[element[i]] = findId.GetValueOrDefault(element[i], 0) + element[i + 1];\\n            }\\n        }\\n\\n        int[][] result = new int[findId.Count][];\\n        int index = 0;\\n\\n        foreach (var kvp in findId)\\n        {\\n            result[index++] = new int[]{kvp.Key, kvp.Value};\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[][] MergeArrays(int[][] nums1, int[][] nums2) {\\n        \\n        SortedDictionary<int, int> findId = new SortedDictionary<int, int>();\\n\\n        foreach (var element in nums1)\\n        {\\n            for(int i = 0; i < element.Length; i+=2)\\n            {\\n                findId[element[i]] = findId.GetValueOrDefault(element[i], 0) + element[i + 1];\\n            }\\n        }\\n\\n        foreach (var element in nums2)\\n        {\\n            for(int i = 0; i < element.Length; i+=2)\\n            {\\n                findId[element[i]] = findId.GetValueOrDefault(element[i], 0) + element[i + 1];\\n            }\\n        }\\n\\n        int[][] result = new int[findId.Count][];\\n        int index = 0;\\n\\n        foreach (var kvp in findId)\\n        {\\n            result[index++] = new int[]{kvp.Key, kvp.Value};\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876923,
                "title": "masum-code-c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) \\n    {\\n        unordered_map<int,int>mp;\\n        for(auto &i:nums1)\\n        {\\n            mp[i[0]]=i[1];\\n        }\\n\\n        for(auto &i:nums2)\\n        {\\n            mp[i[0]]+=i[1];\\n        }\\n        vector<vector<int>>ans;\\n        for(auto &i:mp)\\n        {\\n            ans.push_back({i.first,i.second});\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) \\n    {\\n        unordered_map<int,int>mp;\\n        for(auto &i:nums1)\\n        {\\n            mp[i[0]]=i[1];\\n        }\\n\\n        for(auto &i:nums2)\\n        {\\n            mp[i[0]]+=i[1];\\n        }\\n        vector<vector<int>>ans;\\n        for(auto &i:mp)\\n        {\\n            ans.push_back({i.first,i.second});\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876242,
                "title": "easiest-solution-using-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n        vector<vector<int>> ans;\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        int i = 0, j = 0;\\n        \\n        while (i < n && j < m) {\\n            int id1 = nums1[i][0];\\n            int id2 = nums2[j][0];\\n            \\n            if (id1 == id2) {\\n                int sum = nums1[i][1] + nums2[j][1];\\n                ans.push_back({id1, sum});\\n                i++;\\n                j++;\\n            } else if (id1 < id2) {\\n                ans.push_back({id1, nums1[i][1]});\\n                i++;\\n            } else {\\n                ans.push_back({id2, nums2[j][1]});\\n                j++;\\n            }\\n        }\\n        \\n        // If there are remaining elements in either nums1 or nums2, add them to ans\\n        while (i < n) {\\n            ans.push_back({nums1[i][0], nums1[i][1]});\\n            i++;\\n        }\\n        \\n        while (j < m) {\\n            ans.push_back({nums2[j][0], nums2[j][1]});\\n            j++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n        vector<vector<int>> ans;\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        int i = 0, j = 0;\\n        \\n        while (i < n && j < m) {\\n            int id1 = nums1[i][0];\\n            int id2 = nums2[j][0];\\n            \\n            if (id1 == id2) {\\n                int sum = nums1[i][1] + nums2[j][1];\\n                ans.push_back({id1, sum});\\n                i++;\\n                j++;\\n            } else if (id1 < id2) {\\n                ans.push_back({id1, nums1[i][1]});\\n                i++;\\n            } else {\\n                ans.push_back({id2, nums2[j][1]});\\n                j++;\\n            }\\n        }\\n        \\n        // If there are remaining elements in either nums1 or nums2, add them to ans\\n        while (i < n) {\\n            ans.push_back({nums1[i][0], nums1[i][1]});\\n            i++;\\n        }\\n        \\n        while (j < m) {\\n            ans.push_back({nums2[j][0], nums2[j][1]});\\n            j++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3871280,
                "title": "easy-understadable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        d={}\\n        l=[]\\n        for i in nums1:\\n            d[i[0]]=i[1]\\n        for i in nums2:\\n            if i[0] in d.keys():\\n                d[i[0]]+=i[1]\\n            else:\\n                d[i[0]]=i[1]\\n        for i in d.keys():\\n\\n            l.append([i,d[i]])\\n        l.sort()\\n        return l\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        d={}\\n        l=[]\\n        for i in nums1:\\n            d[i[0]]=i[1]\\n        for i in nums2:\\n            if i[0] in d.keys():\\n                d[i[0]]+=i[1]\\n            else:\\n                d[i[0]]=i[1]\\n        for i in d.keys():\\n\\n            l.append([i,d[i]])\\n        l.sort()\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3868319,
                "title": "solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        a=[]\\n        for i in nums1 :\\n            for j in nums2 :\\n                if i[0]==j[0] :\\n                    a.append([i[0],i[1]+j[1]])\\n        b=[]\\n        for i in nums1 :\\n            x=0\\n            for j in nums2 :\\n                if i[0]!=j[0] :\\n                    x+=1\\n            if x==len(nums2) :\\n                b.append(i)\\n        c=[]\\n        for i in nums2 :\\n            x=0\\n            for j in nums1 :\\n                if i[0]!=j[0] :\\n                    x+=1\\n            if x==len(nums1) :\\n                c.append(i)\\n        d=a+b+c\\n        for i in range(0,len(d)-1) :\\n            for j in range(i+1,len(d)) :\\n                if d[i]>d[j] :\\n                    d[i],d[j]=d[j],d[i] \\n        return d\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        a=[]\\n        for i in nums1 :\\n            for j in nums2 :\\n                if i[0]==j[0] :\\n                    a.append([i[0],i[1]+j[1]])\\n        b=[]\\n        for i in nums1 :\\n            x=0\\n            for j in nums2 :\\n                if i[0]!=j[0] :\\n                    x+=1\\n            if x==len(nums2) :\\n                b.append(i)\\n        c=[]\\n        for i in nums2 :\\n            x=0\\n            for j in nums1 :\\n                if i[0]!=j[0] :\\n                    x+=1\\n            if x==len(nums1) :\\n                c.append(i)\\n        d=a+b+c\\n        for i in range(0,len(d)-1) :\\n            for j in range(i+1,len(d)) :\\n                if d[i]>d[j] :\\n                    d[i],d[j]=d[j],d[i] \\n        return d\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3858947,
                "title": "swift-one-liner-o-n-time-o-n-space",
                "content": "# Explanation \\nSince the range of <tt>id<sub>i</sub></tt> is limited to a relatively small range, there is no need to use a dictionary, we can reduce the arrays into an zero initialized array using the `id` as an index and add the values to the appropriate elements.\\n\\nWe can then filter the enumeration of that array to remove the zero elements and map the index and value into the required format.\\n\\nThe nice thing about this approach is that there is no need to sort.\\n\\n# Complexity\\nLetting $n = nums_{1}.length + nums_{2}.length$. The space complexity is $O(n)$ due to the intermediate arrays that Swift will create. The time complexity is also $O(n)$ since we need to inspect every element is each of the input arrays.\\n\\n# Code\\n```\\nclass Solution {\\n    func mergeArrays(_ nums1: [[Int]], _ nums2: [[Int]]) -> [[Int]] {\\n        (nums1 + nums2)\\n            .reduce(into: [Int](repeating: 0, count: 1001)) { $0[$1[0]] += $1[1] }\\n            .enumerated()\\n            .filter { $0.element > 0 }\\n            .map { [$0.offset, $0.element]}\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func mergeArrays(_ nums1: [[Int]], _ nums2: [[Int]]) -> [[Int]] {\\n        (nums1 + nums2)\\n            .reduce(into: [Int](repeating: 0, count: 1001)) { $0[$1[0]] += $1[1] }\\n            .enumerated()\\n            .filter { $0.element > 0 }\\n            .map { [$0.offset, $0.element]}\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3857475,
                "title": "hash-table-vs-merge-and-keep-sorted-inside-while-loop",
                "content": "## Hash table\\n![image.png](https://assets.leetcode.com/users/images/5e8f1e54-4bc0-40a6-b0fc-212b6e1bf19c_1691056075.9808383.png)\\n\\n```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        id_map = {i[0]: i[1] for i in nums1}\\n        \\n        for i in nums2:\\n            id_map[i[0]] = id_map.get(i[0], 0) + i[1]\\n        \\n        return [[key, id_map[key]] for key in sorted(id_map.keys())]\\n```\\n\\n## Merge and keep sorted\\n![image.png](https://assets.leetcode.com/users/images/8d38accd-fc1e-4edb-94f2-a507e1dedc6a_1691056121.0273807.png)\\n\\n```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        result = []\\n        \\n        while nums1 and nums2:\\n            if nums1[-1][0] == nums2[-1][0]:\\n                result.append([nums1[-1][0], nums1[-1][1] + nums2[-1][1]])\\n                nums1.pop()\\n                nums2.pop()\\n            elif nums1[-1][0] > nums2[-1][0]:\\n                result.append(nums1.pop())\\n            else:\\n                result.append(nums2.pop())\\n        \\n        while nums1:\\n            result.append(nums1.pop())\\n        \\n        while nums2:\\n            result.append(nums2.pop())\\n        \\n        return result[::-1]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        id_map = {i[0]: i[1] for i in nums1}\\n        \\n        for i in nums2:\\n            id_map[i[0]] = id_map.get(i[0], 0) + i[1]\\n        \\n        return [[key, id_map[key]] for key in sorted(id_map.keys())]\\n```\n```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        result = []\\n        \\n        while nums1 and nums2:\\n            if nums1[-1][0] == nums2[-1][0]:\\n                result.append([nums1[-1][0], nums1[-1][1] + nums2[-1][1]])\\n                nums1.pop()\\n                nums2.pop()\\n            elif nums1[-1][0] > nums2[-1][0]:\\n                result.append(nums1.pop())\\n            else:\\n                result.append(nums2.pop())\\n        \\n        while nums1:\\n            result.append(nums1.pop())\\n        \\n        while nums2:\\n            result.append(nums2.pop())\\n        \\n        return result[::-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3846402,
                "title": "javascript-100",
                "content": "Your runtime beats 100 % of javascript submissions\\nYour memory usage beats 94.37 % of javascript submissions (44.9 MB)\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} nums1\\n * @param {number[][]} nums2\\n * @return {number[][]}\\n */\\nvar mergeArrays = function (nums1, nums2) {\\n    const arr = new Array();\\n    for (let i = 0; i < nums1.length; i++) {\\n        arr[nums1[i][0]] = arr[nums1[i][0]] === undefined ? nums1[i][1] : arr[nums1[i][0]] + nums1[i][1];\\n    }\\n    for (let i = 0; i < nums2.length; i++) {\\n        arr[nums2[i][0]] = arr[nums2[i][0]] === undefined ? nums2[i][1] : arr[nums2[i][0]] + nums2[i][1];\\n    }\\n    const result = new Array();\\n    for (let i = 0; i < arr.length; i++) {\\n        if (arr[i] !== undefined) {\\n            result.push(new Array(i, arr[i]));\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} nums1\\n * @param {number[][]} nums2\\n * @return {number[][]}\\n */\\nvar mergeArrays = function (nums1, nums2) {\\n    const arr = new Array();\\n    for (let i = 0; i < nums1.length; i++) {\\n        arr[nums1[i][0]] = arr[nums1[i][0]] === undefined ? nums1[i][1] : arr[nums1[i][0]] + nums1[i][1];\\n    }\\n    for (let i = 0; i < nums2.length; i++) {\\n        arr[nums2[i][0]] = arr[nums2[i][0]] === undefined ? nums2[i][1] : arr[nums2[i][0]] + nums2[i][1];\\n    }\\n    const result = new Array();\\n    for (let i = 0; i < arr.length; i++) {\\n        if (arr[i] !== undefined) {\\n            result.push(new Array(i, arr[i]));\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3845928,
                "title": "java-3ms-beats-51-34",
                "content": "# Complexity\\n- Time complexity: O(n log n) (due to TreeMap\\'s Red-Black tree)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nimport java.util.SortedMap;\\n\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n\\n        SortedMap<Integer, Integer> map = new TreeMap<>();  // what we\\'ll return, after conversion to int[][]\\n\\n        for (int[] arr : nums1) {\\n            map.put(arr[0], arr[1]);\\n        }\\n\\n        for (int[] arr : nums2) {\\n            map.merge(arr[0], arr[1], Integer::sum);\\n        }\\n\\n        // convert `map` to int[][] and return it\\n        int[][] res = new int[map.size()][2];\\n        int index = 0;\\n        for (Map.Entry<Integer, Integer> me : map.entrySet()) {\\n            res[index][0] = me.getKey();\\n            res[index++][1] = me.getValue();\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.SortedMap;\\n\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n\\n        SortedMap<Integer, Integer> map = new TreeMap<>();  // what we\\'ll return, after conversion to int[][]\\n\\n        for (int[] arr : nums1) {\\n            map.put(arr[0], arr[1]);\\n        }\\n\\n        for (int[] arr : nums2) {\\n            map.merge(arr[0], arr[1], Integer::sum);\\n        }\\n\\n        // convert `map` to int[][] and return it\\n        int[][] res = new int[map.size()][2];\\n        int index = 0;\\n        for (Map.Entry<Integer, Integer> me : map.entrySet()) {\\n            res[index][0] = me.getKey();\\n            res[index++][1] = me.getValue();\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3843115,
                "title": "typescript-65-80ms-runtime-46mb-memory-conditionals-and-while-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince each index is unique and incrementing, simply loop while there are any values in either array, and shift() elements from the two arrays and push() them to an array to be returned.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nP(arameters): takes in two 2D arrays of numbers, with unique index values\\nR(eturns): returns a single 2D array of unique index numbers \\nE(xamples): See given examples\\nP(pseudocode): \\n1. Retun a single 2D array. \\n2. Declare the array. \\n3. Loop through both arrays while at least one of them is not empty. \\n4. On each loop, check if either is empty. If so return the non-empty array\\'s first index element\\n5. If both are not empty, then check if the two next indeces are equal to each other and return the sum.\\n6. If one index is smaller than the other, push the smallest index element.\\n7. For each step, push the value to the result array and Array.shift() any elements that were pushed.\\n8. Once the arrays are empty, return the newly declared array\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n65ms - 80ms\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n~46mb\\n\\n# Code\\n```\\nfunction mergeArrays(nums1: number[][], nums2: number[][]): number[][] {\\n\\n    let result: number[][] = []\\n\\n    while(nums1.length > 0 || nums2.length > 0){\\n\\n        if(nums1.length === 0 || (nums2.length > 0 && nums2[0][0] < nums1[0][0])){\\n            result.push(nums2[0])\\n            nums2.shift()\\n        }else if(nums2.length === 0 || (nums1.length > 0 && nums1[0][0] < nums2[0][0])){\\n            result.push(nums1[0])\\n            nums1.shift()\\n        }else{\\n            result.push([nums1[0][0], nums1[0][1] + nums2[0][1]])\\n            nums1.shift()\\n            nums2.shift()\\n        }\\n    }\\n    return result\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction mergeArrays(nums1: number[][], nums2: number[][]): number[][] {\\n\\n    let result: number[][] = []\\n\\n    while(nums1.length > 0 || nums2.length > 0){\\n\\n        if(nums1.length === 0 || (nums2.length > 0 && nums2[0][0] < nums1[0][0])){\\n            result.push(nums2[0])\\n            nums2.shift()\\n        }else if(nums2.length === 0 || (nums1.length > 0 && nums1[0][0] < nums2[0][0])){\\n            result.push(nums1[0])\\n            nums1.shift()\\n        }else{\\n            result.push([nums1[0][0], nums1[0][1] + nums2[0][1]])\\n            nums1.shift()\\n            nums2.shift()\\n        }\\n    }\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3843113,
                "title": "beats-99-of-python-users-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCombine them to make work-load easier and then use a dictionary to total the numbers. Same as maximum truck problem on leetcode\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n\\n        nums = nums1 + nums2\\n        sc = {}\\n        for num in nums:\\n            if num[0] in sc:\\n                sc[num[0]] += num[1]\\n            else:\\n                sc[num[0]] = num[1]\\n        ret = [[key, value] for key, value in sc.items()]\\n        ret.sort()\\n        return ret\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n\\n        nums = nums1 + nums2\\n        sc = {}\\n        for num in nums:\\n            if num[0] in sc:\\n                sc[num[0]] += num[1]\\n            else:\\n                sc[num[0]] = num[1]\\n        ret = [[key, value] for key, value in sc.items()]\\n        ret.sort()\\n        return ret\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3839632,
                "title": "easy-python-dictionary-solution-beats-99-6",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        res = []\\n        if len(nums2) <= len(nums1):\\n            nums1, nums2 = nums2, nums1\\n\\n        dic1 = dict(nums1)\\n        dic2 = dict(nums2)\\n\\n        for i in dic2:\\n            if i in dic1:\\n                dic1[i] += dic2[i]\\n            if i not in dic1:\\n                dic1[i] = dic2[i]\\n\\n        for k,v in dic1.items():\\n            res.append([k,v])\\n        return sorted(res)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        res = []\\n        if len(nums2) <= len(nums1):\\n            nums1, nums2 = nums2, nums1\\n\\n        dic1 = dict(nums1)\\n        dic2 = dict(nums2)\\n\\n        for i in dic2:\\n            if i in dic1:\\n                dic1[i] += dic2[i]\\n            if i not in dic1:\\n                dic1[i] = dic2[i]\\n\\n        for k,v in dic1.items():\\n            res.append([k,v])\\n        return sorted(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3838659,
                "title": "c-solution-12-ms-runtime-two-pointers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n        vector<vector<int>> ans;\\n        int i = 0;\\n        int j = 0;\\n        while(i<nums1.size() || j<nums2.size()){\\n            if(i==nums1.size()){\\n                ans.push_back(nums2[j]);\\n                j++;\\n                continue;\\n            }\\n            else if(j==nums2.size()){\\n                ans.push_back(nums1[i]);\\n                i++;\\n                continue;\\n            }\\n\\n\\n            if(nums1[i][0] == nums2[j][0]){\\n                vector<int> arr;\\n                arr.push_back(nums1[i][0]);\\n                arr.push_back(nums1[i][1] + nums2[j][1]);\\n                ans.push_back(arr);\\n                i++;\\n                j++;\\n            }\\n            else if(nums1[i][0] > nums2[j][0]){\\n                ans.push_back(nums2[j]);\\n                j++;\\n            }\\n            else{\\n                ans.push_back(nums1[i]);\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n        vector<vector<int>> ans;\\n        int i = 0;\\n        int j = 0;\\n        while(i<nums1.size() || j<nums2.size()){\\n            if(i==nums1.size()){\\n                ans.push_back(nums2[j]);\\n                j++;\\n                continue;\\n            }\\n            else if(j==nums2.size()){\\n                ans.push_back(nums1[i]);\\n                i++;\\n                continue;\\n            }\\n\\n\\n            if(nums1[i][0] == nums2[j][0]){\\n                vector<int> arr;\\n                arr.push_back(nums1[i][0]);\\n                arr.push_back(nums1[i][1] + nums2[j][1]);\\n                ans.push_back(arr);\\n                i++;\\n                j++;\\n            }\\n            else if(nums1[i][0] > nums2[j][0]){\\n                ans.push_back(nums2[j]);\\n                j++;\\n            }\\n            else{\\n                ans.push_back(nums1[i]);\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3838590,
                "title": "java-two-pointer-sorting-merge-sort-style-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(M + N), M = nums1.length & N = nums2.length\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(M + N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        \\n        List<int[]> list = new ArrayList<>();\\n\\n        int m = nums1.length;\\n        int n = nums2.length;\\n\\n        int i = 0;\\n        int j = 0;\\n\\n        while(i < m && j < n){\\n\\n            if(nums1[i][0] == nums2[j][0]) {\\n                list.add(new int[]{nums1[i][0], nums1[i][1] + nums2[j][1]});\\n                i++;\\n                j++;\\n            } else if(nums1[i][0] < nums2[j][0]){\\n                list.add(nums1[i++]);\\n            } else if(nums1[i][0] > nums2[j][0]){\\n                list.add(nums2[j++]);\\n            }\\n        }\\n\\n        while(i < m) list.add(nums1[i++]);\\n        \\n        while(j < n) list.add(nums2[j++]);\\n        \\n        return list.toArray(new int[list.size()][]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sort",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        \\n        List<int[]> list = new ArrayList<>();\\n\\n        int m = nums1.length;\\n        int n = nums2.length;\\n\\n        int i = 0;\\n        int j = 0;\\n\\n        while(i < m && j < n){\\n\\n            if(nums1[i][0] == nums2[j][0]) {\\n                list.add(new int[]{nums1[i][0], nums1[i][1] + nums2[j][1]});\\n                i++;\\n                j++;\\n            } else if(nums1[i][0] < nums2[j][0]){\\n                list.add(nums1[i++]);\\n            } else if(nums1[i][0] > nums2[j][0]){\\n                list.add(nums2[j++]);\\n            }\\n        }\\n\\n        while(i < m) list.add(nums1[i++]);\\n        \\n        while(j < n) list.add(nums2[j++]);\\n        \\n        return list.toArray(new int[list.size()][]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3836029,
                "title": "python-2-pointers-solution-beats-98",
                "content": "# Complexity\\n- Time complexity:\\nO(n+m)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        i = 0\\n        j = 0\\n        res = []\\n        while i < len(nums1) or j < len(nums2):\\n            left = nums1[i] if i < len(nums1) else (inf, inf)\\n            right = nums2[j] if j < len(nums2) else (inf, inf)\\n            if left[0] <= right[0]:\\n                if res and res[-1][0] == left[0]:\\n                    res[-1][1] += left[1]\\n                else:\\n                    res.append(left)\\n                i += 1\\n            else:\\n                if res and res[-1][0] == right[0]:\\n                    res[-1][1] += right[1]\\n                else:\\n                    res.append(right)\\n                j += 1\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        i = 0\\n        j = 0\\n        res = []\\n        while i < len(nums1) or j < len(nums2):\\n            left = nums1[i] if i < len(nums1) else (inf, inf)\\n            right = nums2[j] if j < len(nums2) else (inf, inf)\\n            if left[0] <= right[0]:\\n                if res and res[-1][0] == left[0]:\\n                    res[-1][1] += left[1]\\n                else:\\n                    res.append(left)\\n                i += 1\\n            else:\\n                if res and res[-1][0] == right[0]:\\n                    res[-1][1] += right[1]\\n                else:\\n                    res.append(right)\\n                j += 1\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3830724,
                "title": "simple-and-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        int n = nums1.length;\\n        int m = nums2.length;\\n        int i=0,j=0;\\n        int[][] ans;\\n        List<int[]> a= new ArrayList();\\n        int k=0;\\n        while(i<n && j<m){\\n            int id1 = nums1[i][0];\\n            int id2 = nums2[j][0];\\n            int[] ans1 = new int[2];\\n            if(id1<id2){\\n                a.add(nums1[i]);\\n                i++;\\n            }\\n            else if(id1>id2){\\n                a.add(nums2[j]);\\n                j++;\\n            }\\n            else{\\n                nums1[i][1]+=nums2[j][1];\\n                a.add(nums1[i]);\\n                j++;\\n                i++;\\n            }\\n        }\\n        while(i<n){\\n            a.add(nums1[i]);\\n            i++;\\n        }\\n        while(j<m){\\n            a.add(nums2[j]);\\n            j++;\\n\\n        }\\n        ans= new int[a.size()][2];\\n        for(int in=0;in<a.size();in++){\\n            ans[in]=a.get(in);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        int n = nums1.length;\\n        int m = nums2.length;\\n        int i=0,j=0;\\n        int[][] ans;\\n        List<int[]> a= new ArrayList();\\n        int k=0;\\n        while(i<n && j<m){\\n            int id1 = nums1[i][0];\\n            int id2 = nums2[j][0];\\n            int[] ans1 = new int[2];\\n            if(id1<id2){\\n                a.add(nums1[i]);\\n                i++;\\n            }\\n            else if(id1>id2){\\n                a.add(nums2[j]);\\n                j++;\\n            }\\n            else{\\n                nums1[i][1]+=nums2[j][1];\\n                a.add(nums1[i]);\\n                j++;\\n                i++;\\n            }\\n        }\\n        while(i<n){\\n            a.add(nums1[i]);\\n            i++;\\n        }\\n        while(j<m){\\n            a.add(nums2[j]);\\n            j++;\\n\\n        }\\n        ans= new int[a.size()][2];\\n        for(int in=0;in<a.size();in++){\\n            ans[in]=a.get(in);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3823502,
                "title": "java-solution-using-merge-sort-technique",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        HashMap<Integer,Integer> hashMap = new HashMap<>();\\n        ArrayList<int[]> util = new ArrayList<>();\\n\\n        int idx1 = 0;\\n        int idx2 = 0;\\n\\n        while (idx1 < nums1.length && idx2 < nums2.length){\\n            int idxArr1 = nums1[idx1][0];\\n            int idxArr2 = nums2[idx2][0];\\n\\n            if (idxArr1 < idxArr2){\\n                util.add(new int[]{idxArr1, nums1[idx1][1]});\\n                idx1++;\\n            } else if (idxArr1 > idxArr2) {\\n                util.add(new int[]{idxArr2, nums2[idx2][1]});\\n                idx2++;\\n            }\\n            else {\\n                util.add(new int[]{idxArr2, nums1[idx1][1]+nums2[idx2][1]});\\n                idx1++;\\n                idx2++;\\n            }\\n        }\\n\\n        while (idx1 < nums1.length){\\n            util.add(new int[]{nums1[idx1][0], nums1[idx1][1]});\\n            idx1++;\\n        }\\n\\n        while (idx2 < nums2.length){\\n            util.add(new int[]{nums2[idx2][0], nums2[idx2][1]});\\n            idx2++;\\n        }\\n\\n        int[][] ans = new int[util.size()][2];\\n\\n        for (int i = 0; i < ans.length; i++) {\\n            ans[i] = util.get(i);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        HashMap<Integer,Integer> hashMap = new HashMap<>();\\n        ArrayList<int[]> util = new ArrayList<>();\\n\\n        int idx1 = 0;\\n        int idx2 = 0;\\n\\n        while (idx1 < nums1.length && idx2 < nums2.length){\\n            int idxArr1 = nums1[idx1][0];\\n            int idxArr2 = nums2[idx2][0];\\n\\n            if (idxArr1 < idxArr2){\\n                util.add(new int[]{idxArr1, nums1[idx1][1]});\\n                idx1++;\\n            } else if (idxArr1 > idxArr2) {\\n                util.add(new int[]{idxArr2, nums2[idx2][1]});\\n                idx2++;\\n            }\\n            else {\\n                util.add(new int[]{idxArr2, nums1[idx1][1]+nums2[idx2][1]});\\n                idx1++;\\n                idx2++;\\n            }\\n        }\\n\\n        while (idx1 < nums1.length){\\n            util.add(new int[]{nums1[idx1][0], nums1[idx1][1]});\\n            idx1++;\\n        }\\n\\n        while (idx2 < nums2.length){\\n            util.add(new int[]{nums2[idx2][0], nums2[idx2][1]});\\n            idx2++;\\n        }\\n\\n        int[][] ans = new int[util.size()][2];\\n\\n        for (int i = 0; i < ans.length; i++) {\\n            ans[i] = util.get(i);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3816046,
                "title": "merge-two-2d-arrays-by-summing-values",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n    HashMap<Integer,Integer> no1 = new HashMap<Integer,Integer>();\\n    ArrayList<Integer> arr = new ArrayList<Integer>();\\n    for(int i=0;i<nums1.length;i++)\\n    {\\n        arr.add(nums1[i][0]);\\n    }\\n    for(int i=0;i<nums2.length;i++)\\n    {\\n        if(arr.contains(nums2[i][0])==false)\\n        arr.add(nums2[i][0]);\\n    }\\n    Collections.sort(arr);\\n      for(int i=0;i<nums1.length;i++)\\n      {\\n          no1.put(nums1[i][0],nums1[i][1]);\\n      }\\n      for(int i=0;i<nums2.length;i++)\\n      {\\n          if(no1.containsKey(nums2[i][0]))\\n          {\\n              no1.put(nums2[i][0],(no1.get(nums2[i][0])+nums2[i][1]));\\n          }\\n          else\\n          no1.put(nums2[i][0],nums2[i][1]);\\n      }\\n      int[][] arr1 = new int[no1.size()][2];\\n      int i=0;\\n    for(int j=0;j<arr.size();j++)\\n    {\\n        arr1[i][0] = arr.get(i);\\n        arr1[i][1] = no1.get(arr.get(i));\\n        i++;\\n    }\\n      return arr1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n    HashMap<Integer,Integer> no1 = new HashMap<Integer,Integer>();\\n    ArrayList<Integer> arr = new ArrayList<Integer>();\\n    for(int i=0;i<nums1.length;i++)\\n    {\\n        arr.add(nums1[i][0]);\\n    }\\n    for(int i=0;i<nums2.length;i++)\\n    {\\n        if(arr.contains(nums2[i][0])==false)\\n        arr.add(nums2[i][0]);\\n    }\\n    Collections.sort(arr);\\n      for(int i=0;i<nums1.length;i++)\\n      {\\n          no1.put(nums1[i][0],nums1[i][1]);\\n      }\\n      for(int i=0;i<nums2.length;i++)\\n      {\\n          if(no1.containsKey(nums2[i][0]))\\n          {\\n              no1.put(nums2[i][0],(no1.get(nums2[i][0])+nums2[i][1]));\\n          }\\n          else\\n          no1.put(nums2[i][0],nums2[i][1]);\\n      }\\n      int[][] arr1 = new int[no1.size()][2];\\n      int i=0;\\n    for(int j=0;j<arr.size();j++)\\n    {\\n        arr1[i][0] = arr.get(i);\\n        arr1[i][1] = no1.get(arr.get(i));\\n        i++;\\n    }\\n      return arr1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3813883,
                "title": "golang-look-ma-i-m-fast",
                "content": "# Code\\nNot like it\\'s a nice & clean code but at least it\\'s fast.\\n\\n![leetcode_2570.png](https://assets.leetcode.com/users/images/347c0c2e-422e-49b1-ab11-65b6c393283e_1690278438.9347239.png)\\n\\n\\n```\\nfunc mergeArrays(nums1 [][]int, nums2 [][]int) [][]int {\\n  ptr1 := 0\\n  ptr2 := 0\\n\\n  ans := make([][]int, 0)\\n\\n  for ptr1 < len(nums1) || ptr2 < len(nums2) {\\n\\n    if ptr1 > len(nums1)-1 {\\n      for ptr2 < len(nums2) {\\n        ans = append(ans, nums2[ptr2])\\n        ptr2++\\n      }\\n      break\\n    }\\n\\n    if ptr2 > len(nums2)-1 {\\n      for ptr1 < len(nums1) {\\n        ans = append(ans, nums1[ptr1])\\n        ptr1++\\n      }\\n      break\\n    }\\n    \\n    if nums1[ptr1][0] < nums2[ptr2][0] {\\n      ans = append(ans, nums1[ptr1])\\n      ptr1++\\n    } else if nums1[ptr1][0] == nums2[ptr2][0] {\\n      k := nums1[ptr1][0]\\n      v := nums1[ptr1][1] + nums2[ptr2][1]\\n      ans = append(ans, []int{k,v})\\n      ptr1++\\n      ptr2++\\n    } else {\\n      ans = append(ans, nums2[ptr2])\\n      ptr2++\\n    }\\n  } \\n  return ans\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nfunc mergeArrays(nums1 [][]int, nums2 [][]int) [][]int {\\n  ptr1 := 0\\n  ptr2 := 0\\n\\n  ans := make([][]int, 0)\\n\\n  for ptr1 < len(nums1) || ptr2 < len(nums2) {\\n\\n    if ptr1 > len(nums1)-1 {\\n      for ptr2 < len(nums2) {\\n        ans = append(ans, nums2[ptr2])\\n        ptr2++\\n      }\\n      break\\n    }\\n\\n    if ptr2 > len(nums2)-1 {\\n      for ptr1 < len(nums1) {\\n        ans = append(ans, nums1[ptr1])\\n        ptr1++\\n      }\\n      break\\n    }\\n    \\n    if nums1[ptr1][0] < nums2[ptr2][0] {\\n      ans = append(ans, nums1[ptr1])\\n      ptr1++\\n    } else if nums1[ptr1][0] == nums2[ptr2][0] {\\n      k := nums1[ptr1][0]\\n      v := nums1[ptr1][1] + nums2[ptr2][1]\\n      ans = append(ans, []int{k,v})\\n      ptr1++\\n      ptr2++\\n    } else {\\n      ans = append(ans, nums2[ptr2])\\n      ptr2++\\n    }\\n  } \\n  return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3806764,
                "title": "c-solution-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n        map<int,int>m;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            m[nums1[i][0]]+=nums1[i][1];\\n        }\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            m[nums2[i][0]]+=nums2[i][1];\\n        }\\n        vector<vector<int>>ans;\\n        for(auto it:m)\\n        {\\n            ans.push_back({it.first,it.second});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n        map<int,int>m;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            m[nums1[i][0]]+=nums1[i][1];\\n        }\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            m[nums2[i][0]]+=nums2[i][1];\\n        }\\n        vector<vector<int>>ans;\\n        for(auto it:m)\\n        {\\n            ans.push_back({it.first,it.second});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3794905,
                "title": "python-noobie-dictionary-approach",
                "content": "# Intuition\\nSimply update a dictionary based on ids.\\n\\n# Approach\\nCreate initial dictionary using id, then update corresponding values. Create a sorted array based on index 0 of subarrays.\\n\\n# Code\\n```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        dictHelper = {idx:val for [idx, val] in nums1}\\n\\n        for arr in nums2:\\n            if arr[0] not in dictHelper.keys():\\n                dictHelper[arr[0]] = arr[1]\\n            else:\\n                dictHelper[arr[0]] += arr[1]\\n\\n        ans = [[idx, val] for idx, val in dictHelper.items()]\\n\\n        return sorted(ans, key=lambda x: x[0])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        dictHelper = {idx:val for [idx, val] in nums1}\\n\\n        for arr in nums2:\\n            if arr[0] not in dictHelper.keys():\\n                dictHelper[arr[0]] = arr[1]\\n            else:\\n                dictHelper[arr[0]] += arr[1]\\n\\n        ans = [[idx, val] for idx, val in dictHelper.items()]\\n\\n        return sorted(ans, key=lambda x: x[0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3791803,
                "title": "two-pointers-merging-2-sorted-arrays",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(m+n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(m+n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n    int i=0,j=0;\\n    vector<vector<int>> ans;\\n        while(i<nums1.size() && j<nums2.size()){\\n            if(nums1[i][0] == nums2[j][0]){\\n                ans.push_back({nums1[i][0] , nums1[i][1] + nums2[j][1]});\\n                i++;j++;\\n            }else if(nums1[i][0] < nums2[j][0]){\\n                ans.push_back(nums1[i]);\\n                i++;\\n            }else{\\n                ans.push_back(nums2[j]);\\n                j++;\\n            }\\n        }\\n        while(i<nums1.size()){\\n            ans.push_back(nums1[i]);\\n            i++; \\n        }\\n        while(j<nums2.size()){\\n            ans.push_back(nums2[j]);\\n            j++;            \\n        }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n    int i=0,j=0;\\n    vector<vector<int>> ans;\\n        while(i<nums1.size() && j<nums2.size()){\\n            if(nums1[i][0] == nums2[j][0]){\\n                ans.push_back({nums1[i][0] , nums1[i][1] + nums2[j][1]});\\n                i++;j++;\\n            }else if(nums1[i][0] < nums2[j][0]){\\n                ans.push_back(nums1[i]);\\n                i++;\\n            }else{\\n                ans.push_back(nums2[j]);\\n                j++;\\n            }\\n        }\\n        while(i<nums1.size()){\\n            ans.push_back(nums1[i]);\\n            i++; \\n        }\\n        while(j<nums2.size()){\\n            ans.push_back(nums2[j]);\\n            j++;            \\n        }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3780926,
                "title": "initial-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} nums1\\n * @param {number[][]} nums2\\n * @return {number[][]}\\n */\\nvar mergeArrays = function(nums1, nums2) {\\n    // we have 2d array with integer arrays nums1 and nums2\\n    // each array contains unique ids and is sorted in ascenfing order by id\\n    // merge the two array that is sorted in ascending order by id\\n\\n    let hash = {};\\n    let combinedNums = nums1.concat(nums2);\\n\\n    for(let elem of combinedNums ){\\n        let key = elem[0];\\n        let value = elem[1];\\n\\n        if(key in hash){\\n            hash[key] = hash[key] + value;\\n        }else{\\n            hash[key] = value;\\n        }\\n        \\n    }\\n\\n    return Object.entries(hash);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} nums1\\n * @param {number[][]} nums2\\n * @return {number[][]}\\n */\\nvar mergeArrays = function(nums1, nums2) {\\n    // we have 2d array with integer arrays nums1 and nums2\\n    // each array contains unique ids and is sorted in ascenfing order by id\\n    // merge the two array that is sorted in ascending order by id\\n\\n    let hash = {};\\n    let combinedNums = nums1.concat(nums2);\\n\\n    for(let elem of combinedNums ){\\n        let key = elem[0];\\n        let value = elem[1];\\n\\n        if(key in hash){\\n            hash[key] = hash[key] + value;\\n        }else{\\n            hash[key] = value;\\n        }\\n        \\n    }\\n\\n    return Object.entries(hash);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3780113,
                "title": "simple-easy-solution-using-two-iterators-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        ArrayList<int[]>ans = new ArrayList<>();\\n        int i=0, j=0;\\n        while(i<nums1.length && j<nums2.length){\\n            if(nums1[i][0] == nums2[j][0]){\\n                ans.add(new int[]{nums1[i][0],nums1[i][1]+nums2[j][1]});\\n                i++;\\n                j++;\\n            }\\n            else if(nums1[i][0]<nums2[j][0]){\\n                ans.add(nums1[i]);\\n                i++;\\n            }\\n            else{\\n                ans.add(nums2[j]);\\n                j++;\\n            }\\n            \\n        }\\n        while(i<nums1.length){\\n            ans.add(nums1[i]);\\n            i++;\\n        }\\n        while(j<nums2.length){\\n            ans.add(nums2[j]);\\n            j++;\\n        }\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        ArrayList<int[]>ans = new ArrayList<>();\\n        int i=0, j=0;\\n        while(i<nums1.length && j<nums2.length){\\n            if(nums1[i][0] == nums2[j][0]){\\n                ans.add(new int[]{nums1[i][0],nums1[i][1]+nums2[j][1]});\\n                i++;\\n                j++;\\n            }\\n            else if(nums1[i][0]<nums2[j][0]){\\n                ans.add(nums1[i]);\\n                i++;\\n            }\\n            else{\\n                ans.add(nums2[j]);\\n                j++;\\n            }\\n            \\n        }\\n        while(i<nums1.length){\\n            ans.add(nums1[i]);\\n            i++;\\n        }\\n        while(j<nums2.length){\\n            ans.add(nums2[j]);\\n            j++;\\n        }\\n        return ans.toArray(new int[ans.size()][]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3771140,
                "title": "easy-solution-using-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nBig O (nlogn)\\n\\n- Space complexity:\\nBig O(n)\\n\\n# Code\\n```\\n\\nfunction mergeArrays(nums1,nums2){\\n  let merged = [];\\n  let i = 0; \\n  let j = 0;\\n \\n  while(i < nums1.length && j < nums2.length){\\n    if(nums1[i][0] < nums2[j][0]){\\n      merged.push([nums1[i][0],nums1[i][1]]);\\n      i++;\\n    } else if (nums1[i][0] > nums2[j][0]){\\n      merged.push([nums2[j][0],nums2[j][1]]);\\n      j++;\\n    } else{\\n       merged.push([nums1[i][0],nums1[i][1] + nums2[j][1]]);\\n      i++;\\n      j++;\\n    }\\n   \\n  }\\n\\n  while(i < nums1.length){\\n    merged.push([nums1[i][0],nums1[i][1]]);\\n    i++;\\n  }\\n  while(j< nums2.length){\\n    merged.push([nums2[j][0],nums2[j][1]]);\\n    j++;\\n  }\\n  return merged;\\n}\\nconsole.log(mergeArrays([[1,2],[2,3],[4,5]],[[1,4],[3,2],[4,1]]))\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Merge Sort"
                ],
                "code": "```\\n\\nfunction mergeArrays(nums1,nums2){\\n  let merged = [];\\n  let i = 0; \\n  let j = 0;\\n \\n  while(i < nums1.length && j < nums2.length){\\n    if(nums1[i][0] < nums2[j][0]){\\n      merged.push([nums1[i][0],nums1[i][1]]);\\n      i++;\\n    } else if (nums1[i][0] > nums2[j][0]){\\n      merged.push([nums2[j][0],nums2[j][1]]);\\n      j++;\\n    } else{\\n       merged.push([nums1[i][0],nums1[i][1] + nums2[j][1]]);\\n      i++;\\n      j++;\\n    }\\n   \\n  }\\n\\n  while(i < nums1.length){\\n    merged.push([nums1[i][0],nums1[i][1]]);\\n    i++;\\n  }\\n  while(j< nums2.length){\\n    merged.push([nums2[j][0],nums2[j][1]]);\\n    j++;\\n  }\\n  return merged;\\n}\\nconsole.log(mergeArrays([[1,2],[2,3],[4,5]],[[1,4],[3,2],[4,1]]))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3765934,
                "title": "easy-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} nums1\\n * @param {number[][]} nums2\\n * @return {number[][]}\\n */\\nvar mergeArrays = function(nums1, nums2) {\\n    let map = {}\\n    let nums = [...nums1, ...nums2]\\n    for(let [num,count] of nums) {\\n        if(map[num]) {\\n           map[num]+=count\\n        } else {\\n            map[num] = count\\n        }\\n    }\\n    return Object.entries(map)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} nums1\\n * @param {number[][]} nums2\\n * @return {number[][]}\\n */\\nvar mergeArrays = function(nums1, nums2) {\\n    let map = {}\\n    let nums = [...nums1, ...nums2]\\n    for(let [num,count] of nums) {\\n        if(map[num]) {\\n           map[num]+=count\\n        } else {\\n            map[num] = count\\n        }\\n    }\\n    return Object.entries(map)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3750437,
                "title": "easy-to-get-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n         List<int[]> list = new ArrayList<>();\\n        int i=0;\\n        int j=0;\\n        while(i<nums1.length && j<nums2.length){\\n            if(nums1[i][0] == nums2[j][0]){\\n                list.add(new int[] {nums1[i][0] , nums1[i][1] + nums2[j][1]});\\n                i++;j++;\\n            }else if(nums1[i][0] < nums2[j][0]){\\n                list.add(nums1[i]);\\n                i++;\\n            }else{\\n                list.add(nums2[j]);\\n                j++;\\n            }\\n        }\\n        while(i<nums1.length){\\n            list.add(nums1[i]);\\n            i++;\\n        }\\n        while(j<nums2.length){\\n            list.add(nums2[j]);\\n            j++;\\n        }\\n\\n       return list.toArray(new int[list.size()][2]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n         List<int[]> list = new ArrayList<>();\\n        int i=0;\\n        int j=0;\\n        while(i<nums1.length && j<nums2.length){\\n            if(nums1[i][0] == nums2[j][0]){\\n                list.add(new int[] {nums1[i][0] , nums1[i][1] + nums2[j][1]});\\n                i++;j++;\\n            }else if(nums1[i][0] < nums2[j][0]){\\n                list.add(nums1[i]);\\n                i++;\\n            }else{\\n                list.add(nums2[j]);\\n                j++;\\n            }\\n        }\\n        while(i<nums1.length){\\n            list.add(nums1[i]);\\n            i++;\\n        }\\n        while(j<nums2.length){\\n            list.add(nums2[j]);\\n            j++;\\n        }\\n\\n       return list.toArray(new int[list.size()][2]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3747085,
                "title": "java-easy-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis solution felt really similar to one I just did - unique-number-of-occurrences\\n\\nChecked the related topics, found hashmap, good to go!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs I am a beginner who didnt reach medium level yet, I will try to explain my approach the ELI5 way. (Explain like im 5) \\nSo that beginners like me will get to know the problem from the same level of perspective.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n    \\n        // Create hashmap that stores keys and values.\\n        // We use hashmap so that whenever we see a key that is \\n        // same in the next array, we can add and update the values.\\n\\n// This is basically the logic, after iterations we just need to\\n// create a new 2d array and add the key value pairs then return it\\n\\n        for(int i = 0; i < nums1.length; i++){\\n// Adding the key and values of nums1.\\n\\n// Here for each i, we add the key that\\'s in 0th index of i, and\\n// the value that\\'s in the 1st index of i.\\n                map.put(nums1[i][0], nums1[i][1]);\\n          \\n        }\\n\\n\\n         for(int i = 0; i < nums2.length; i++){\\n\\n// Do the same for nums2 but we check if key of this array is already\\n// present in the map. If present, get that key\\'s value from the \\n// nums1 array which is already stored in the map and increment\\n// with the new value of this new nums2 array and update.\\n\\n            if(map.containsKey(nums2[i][0])){\\n                map.put(nums2[i][0], map.getOrDefault(nums2[i][0], 0) + nums2[i][1] );\\n            }else{\\n\\n// Else treat it as a new key, value pair from nums2.\\n\\n                 map.put(nums2[i][0], nums2[i][1]);\\n            }\\n          \\n        }\\n\\n// Now we got what we wanted as output in maps format.\\n// Add the values to a new 2d array ans.\\n// A slowpointer for a global index.\\n// i that increments till map gets empty. (while loop).\\n// Remove elements from the map if added in the ans array.\\n       \\n        int i = 0;\\n        int slowptr = 0;\\n\\n        int[][] ans = new int[map.size()][2];\\n\\n        while(!map.isEmpty()){\\n\\n            if(map.containsKey(i)){\\n                ans[slowptr][0] = i;\\n                ans[slowptr][1] = map.get(i);\\n                map.remove(i);\\n                slowptr++;\\n            }\\n\\n            i++;\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n    \\n        // Create hashmap that stores keys and values.\\n        // We use hashmap so that whenever we see a key that is \\n        // same in the next array, we can add and update the values.\\n\\n// This is basically the logic, after iterations we just need to\\n// create a new 2d array and add the key value pairs then return it\\n\\n        for(int i = 0; i < nums1.length; i++){\\n// Adding the key and values of nums1.\\n\\n// Here for each i, we add the key that\\'s in 0th index of i, and\\n// the value that\\'s in the 1st index of i.\\n                map.put(nums1[i][0], nums1[i][1]);\\n          \\n        }\\n\\n\\n         for(int i = 0; i < nums2.length; i++){\\n\\n// Do the same for nums2 but we check if key of this array is already\\n// present in the map. If present, get that key\\'s value from the \\n// nums1 array which is already stored in the map and increment\\n// with the new value of this new nums2 array and update.\\n\\n            if(map.containsKey(nums2[i][0])){\\n                map.put(nums2[i][0], map.getOrDefault(nums2[i][0], 0) + nums2[i][1] );\\n            }else{\\n\\n// Else treat it as a new key, value pair from nums2.\\n\\n                 map.put(nums2[i][0], nums2[i][1]);\\n            }\\n          \\n        }\\n\\n// Now we got what we wanted as output in maps format.\\n// Add the values to a new 2d array ans.\\n// A slowpointer for a global index.\\n// i that increments till map gets empty. (while loop).\\n// Remove elements from the map if added in the ans array.\\n       \\n        int i = 0;\\n        int slowptr = 0;\\n\\n        int[][] ans = new int[map.size()][2];\\n\\n        while(!map.isEmpty()){\\n\\n            if(map.containsKey(i)){\\n                ans[slowptr][0] = i;\\n                ans[slowptr][1] = map.get(i);\\n                map.remove(i);\\n                slowptr++;\\n            }\\n\\n            i++;\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3746266,
                "title": "java-solution-using-hashmap",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n       HashMap<Integer, Integer> map = new HashMap<>();\\n       for(int i = 0; i<nums1.length; i++)\\n       {\\n           map.put(nums1[i][0], nums1[i][1]);\\n       } \\n       for(int i = 0; i<nums2.length; i++)\\n       {\\n           if(!(map.containsKey(nums2[i][0])))\\n           {\\n               map.put(nums2[i][0], nums2[i][1]);\\n           }\\n           else\\n           {\\n               map.put(nums2[i][0], map.get(nums2[i][0])+nums2[i][1]);\\n           }\\n       }\\n       int[][] ans = new int[map.size()][2];\\n       int j =0;\\n       for(Integer i : map.keySet())\\n       {\\n           ans[j][0] = i;\\n           ans[j][1] = map.get(i);\\n           j++;\\n       }\\n       Arrays.sort(ans, (a,b) -> Integer.compare(a[0] , b[0]));\\n       return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n       HashMap<Integer, Integer> map = new HashMap<>();\\n       for(int i = 0; i<nums1.length; i++)\\n       {\\n           map.put(nums1[i][0], nums1[i][1]);\\n       } \\n       for(int i = 0; i<nums2.length; i++)\\n       {\\n           if(!(map.containsKey(nums2[i][0])))\\n           {\\n               map.put(nums2[i][0], nums2[i][1]);\\n           }\\n           else\\n           {\\n               map.put(nums2[i][0], map.get(nums2[i][0])+nums2[i][1]);\\n           }\\n       }\\n       int[][] ans = new int[map.size()][2];\\n       int j =0;\\n       for(Integer i : map.keySet())\\n       {\\n           ans[j][0] = i;\\n           ans[j][1] = map.get(i);\\n           j++;\\n       }\\n       Arrays.sort(ans, (a,b) -> Integer.compare(a[0] , b[0]));\\n       return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3743054,
                "title": "simple-javascript-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} nums1\\n * @param {number[][]} nums2\\n * @return {number[][]}\\n */\\nvar mergeArrays = function(nums1, nums2) {\\n   const map = {};\\n    nums1.forEach(([id, num]) => {\\n        map[id] = num;\\n    });\\n    nums2.forEach(([id, num]) => {\\n        map[id] = (map[id] ?? 0) + num;\\n    });\\n    return Object.entries(map);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} nums1\\n * @param {number[][]} nums2\\n * @return {number[][]}\\n */\\nvar mergeArrays = function(nums1, nums2) {\\n   const map = {};\\n    nums1.forEach(([id, num]) => {\\n        map[id] = num;\\n    });\\n    nums2.forEach(([id, num]) => {\\n        map[id] = (map[id] ?? 0) + num;\\n    });\\n    return Object.entries(map);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3742331,
                "title": "easy-two-pointers-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        res=[]\\n        i,j=0,0\\n\\n        while i<len(nums1) or j<len(nums2):\\n\\n            if i==len(nums1):\\n                res.append(nums2[j])\\n                j+=1\\n\\n            elif j==len(nums2):\\n                res.append(nums1[i])\\n                i+=1\\n\\n            else:\\n                if nums1[i][0] == nums2[j][0]:\\n                    res.append([nums1[i][0],nums1[i][1]+nums2[j][1]])\\n                    i+=1\\n                    j+=1\\n                \\n                elif nums1[i][0] < nums2[j][0]:\\n                    res.append(nums1[i])\\n                    i+=1\\n\\n                else:\\n                    res.append(nums2[j])\\n                    j+=1\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        res=[]\\n        i,j=0,0\\n\\n        while i<len(nums1) or j<len(nums2):\\n\\n            if i==len(nums1):\\n                res.append(nums2[j])\\n                j+=1\\n\\n            elif j==len(nums2):\\n                res.append(nums1[i])\\n                i+=1\\n\\n            else:\\n                if nums1[i][0] == nums2[j][0]:\\n                    res.append([nums1[i][0],nums1[i][1]+nums2[j][1]])\\n                    i+=1\\n                    j+=1\\n                \\n                elif nums1[i][0] < nums2[j][0]:\\n                    res.append(nums1[i])\\n                    i+=1\\n\\n                else:\\n                    res.append(nums2[j])\\n                    j+=1\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738108,
                "title": "simple-c-solution-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n + m)\\n\\n- Space complexity:\\nO(1), Result array is not counted towards space complexity.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n        \\n        vector<vector<int>> res{};\\n\\n        int n = nums1.size(), m = nums2.size(), i{}, j{};\\n\\n        while(i < n || j < m){\\n            if(i != n && (j == m || nums1[i][0] < nums2[j][0])) res.push_back({nums1[i][0], nums1[i++][1]});\\n            else if(j != m && (i == n || nums1[i][0] > nums2[j][0])) res.push_back({nums2[j][0], nums2[j++][1]}); \\n            else res.push_back({nums1[i][0], nums1[i++][1] + nums2[j++][1]});\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n        \\n        vector<vector<int>> res{};\\n\\n        int n = nums1.size(), m = nums2.size(), i{}, j{};\\n\\n        while(i < n || j < m){\\n            if(i != n && (j == m || nums1[i][0] < nums2[j][0])) res.push_back({nums1[i][0], nums1[i++][1]});\\n            else if(j != m && (i == n || nums1[i][0] > nums2[j][0])) res.push_back({nums2[j][0], nums2[j++][1]}); \\n            else res.push_back({nums1[i][0], nums1[i++][1] + nums2[j++][1]});\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731654,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>&n1 , vector<vector<int>>&n2){\\n        vector<vector<int>>v;\\n        map<int,int>mp;\\n        for(auto i:n1){\\n            mp[i[0]]+=i[1];\\n        }\\n        for(auto i:n2){\\n            mp[i[0]]+=i[1];\\n        }\\n        for(auto i:mp){\\n            v.push_back({i.first,i.second});\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>&n1 , vector<vector<int>>&n2){\\n        vector<vector<int>>v;\\n        map<int,int>mp;\\n        for(auto i:n1){\\n            mp[i[0]]+=i[1];\\n        }\\n        for(auto i:n2){\\n            mp[i[0]]+=i[1];\\n        }\\n        for(auto i:mp){\\n            v.push_back({i.first,i.second});\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3727846,
                "title": "python3-two-pointers-method-time-complexity-o-n1-n2-space-complexity-o-n1-n2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMerge two arrays using 2 pointer idea.\\nOne pointer - i1,  on first nums1.\\nOther pointer - i2, on second nums2.\\n\\nIterativle(while i1 < n1 and i2 < n2) move first or second pointer and write values into the answer list - merge_nums.\\nBefore write new value into answer list - merge_nums, we check - if id already exists in merge_nums, so we just += current value, otherwise we write new pair [id, value] into answer list - merge_nums.\\n\\n# Complexity\\n- Time complexity: $$O(n1 + n2)$$, where n1 = length of nums1, n2 = length of nums2\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n1 + n2)$$, where n1 = length of nums1, n2 = length of nums2\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        n1 = len(nums1)\\n        n2 = len(nums2)\\n        \\n        merge_nums = [[0, 0]]\\n        i1 = i2 = 0\\n        while i1 < n1 and i2 < n2:\\n            id1, val1 = nums1[i1]\\n            id2, val2 = nums2[i2]\\n            \\n            if id1 <= id2:\\n                if merge_nums[-1][0] == id1:\\n                    merge_nums[-1][1] += val1\\n                else:\\n                    merge_nums.append([id1, val1])\\n                \\n                i1 += 1\\n            else:\\n                if merge_nums[-1][0] == id2:\\n                    merge_nums[-1][1] += val2\\n                else:\\n                    merge_nums.append([id2, val2])\\n                \\n                i2 += 1\\n                \\n        for i in range(i1, n1):\\n            id1, val1 = nums1[i]\\n            \\n            if merge_nums[-1][0] == id1:\\n                merge_nums[-1][1] += val1\\n            else:\\n                merge_nums.append([id1, val1])\\n        \\n        for i in range(i2, n2):\\n            id2, val2 = nums2[i]\\n            \\n            if merge_nums[-1][0] == id2:\\n                merge_nums[-1][1] += val2\\n            else:\\n                merge_nums.append([id2, val2])\\n        \\n        return merge_nums[1:]\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        n1 = len(nums1)\\n        n2 = len(nums2)\\n        \\n        merge_nums = [[0, 0]]\\n        i1 = i2 = 0\\n        while i1 < n1 and i2 < n2:\\n            id1, val1 = nums1[i1]\\n            id2, val2 = nums2[i2]\\n            \\n            if id1 <= id2:\\n                if merge_nums[-1][0] == id1:\\n                    merge_nums[-1][1] += val1\\n                else:\\n                    merge_nums.append([id1, val1])\\n                \\n                i1 += 1\\n            else:\\n                if merge_nums[-1][0] == id2:\\n                    merge_nums[-1][1] += val2\\n                else:\\n                    merge_nums.append([id2, val2])\\n                \\n                i2 += 1\\n                \\n        for i in range(i1, n1):\\n            id1, val1 = nums1[i]\\n            \\n            if merge_nums[-1][0] == id1:\\n                merge_nums[-1][1] += val1\\n            else:\\n                merge_nums.append([id1, val1])\\n        \\n        for i in range(i2, n2):\\n            id2, val2 = nums2[i]\\n            \\n            if merge_nums[-1][0] == id2:\\n                merge_nums[-1][1] += val2\\n            else:\\n                merge_nums.append([id2, val2])\\n        \\n        return merge_nums[1:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3726362,
                "title": "python3-solution-2-pointers-o-n-m",
                "content": "```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        result = []\\n        i, j = 0, 0\\n        while i < len(nums1) and j < len(nums2):\\n            id1, value1 = nums1[i]\\n            id2, value2 = nums2[j]\\n            item = []\\n            if id1 == id2:\\n                item = [id1, value1 + value2]\\n                i += 1\\n                j += 1\\n            if id1 < id2:\\n                item = [id1, value1]\\n                i += 1\\n            if id1 > id2:\\n                item = [id2, value2]\\n                j += 1\\n            result.append(item)\\n        result.extend(nums1[i:])\\n        result.extend(nums2[j:])\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        result = []\\n        i, j = 0, 0\\n        while i < len(nums1) and j < len(nums2):\\n            id1, value1 = nums1[i]\\n            id2, value2 = nums2[j]\\n            item = []\\n            if id1 == id2:\\n                item = [id1, value1 + value2]\\n                i += 1\\n                j += 1\\n            if id1 < id2:\\n                item = [id1, value1]\\n                i += 1\\n            if id1 > id2:\\n                item = [id2, value2]\\n                j += 1\\n            result.append(item)\\n        result.extend(nums1[i:])\\n        result.extend(nums2[j:])\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3718597,
                "title": "2570-merge-two-2d-arrays-by-summing-values-single-line-answer-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nConvert both list[list[int]] to Counter and add them and sort\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n-> Convert list[list[int]] to dictionary using dict(nums1) and convert dictionary to Counter using Counter() class from collections module\\n->Now convert nums2 to Counter\\n->Add Counter1 and Counter2\\n->Sort resulting Counter by taing first index as key\\n->sorted will return list[tuples[int]] because of .items() funciton\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        return sorted((Counter(dict(nums1))+Counter(dict(nums2))).items(),key = (lambda obj: obj))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        return sorted((Counter(dict(nums1))+Counter(dict(nums2))).items(),key = (lambda obj: obj))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3712715,
                "title": "94-beats-time-complexity-and-100-beats-space-complexity-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n1 + n2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nfunc mergeArrays(nums1 [][]int, nums2 [][]int) [][]int {\\n    n1, n2 := len(nums1), len(nums2)\\n    result := make([][]int, 0, n1+n2)\\n    \\n    i, j := 0, 0\\n    for i < n1 || j < n2 {\\n        if i < n1 && (j >= n2 || nums1[i][0] < nums2[j][0]) {\\n            result = append(result, nums1[i])\\n            i++\\n        } else if j < n2 && (i >= n1 || nums2[j][0] < nums1[i][0]) {\\n            result = append(result, nums2[j])\\n            j++\\n        } else {\\n            sum := nums1[i][1] + nums2[j][1]\\n            result = append(result, []int{nums1[i][0], sum})\\n            i++\\n            j++\\n        }\\n    }\\n    return result\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc mergeArrays(nums1 [][]int, nums2 [][]int) [][]int {\\n    n1, n2 := len(nums1), len(nums2)\\n    result := make([][]int, 0, n1+n2)\\n    \\n    i, j := 0, 0\\n    for i < n1 || j < n2 {\\n        if i < n1 && (j >= n2 || nums1[i][0] < nums2[j][0]) {\\n            result = append(result, nums1[i])\\n            i++\\n        } else if j < n2 && (i >= n1 || nums2[j][0] < nums1[i][0]) {\\n            result = append(result, nums2[j])\\n            j++\\n        } else {\\n            sum := nums1[i][1] + nums2[j][1]\\n            result = append(result, []int{nums1[i][0], sum})\\n            i++\\n            j++\\n        }\\n    }\\n    return result\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3706311,
                "title": "unexpected-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        \\n        ArrayList<int[]> answer = new ArrayList<>();\\n        int[] buffer = new int[2];\\n\\n        for (int i = 0; i < nums1.length; i++) {\\n            for (int j = 0; j < nums2.length; j++) {\\n                if(nums1[i][0]==nums2[j][0]){\\n\\n                    buffer = new int[]{nums1[i][0],nums1[i][1] + nums2[j][1]};\\n        \\n                    answer.add(buffer);\\n                    nums2[j][0] = -1;\\n                    break;\\n\\n                }else if (j == nums2.length-1) {\\n                    answer.add(nums1[i]);\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < nums2.length; i++) {\\n            if (nums2[i][0] != -1){\\n                answer.add(nums2[i]);\\n            }\\n        }\\n\\n        int[][] array = new int[answer.size()][];\\n        for (int i = 0; i < answer.size(); i++) {\\n            array[i] = answer.get(i);\\n        }\\n        \\n        Arrays.sort(array, Comparator.comparingInt(a -> a[0]));\\n        return array;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        \\n        ArrayList<int[]> answer = new ArrayList<>();\\n        int[] buffer = new int[2];\\n\\n        for (int i = 0; i < nums1.length; i++) {\\n            for (int j = 0; j < nums2.length; j++) {\\n                if(nums1[i][0]==nums2[j][0]){\\n\\n                    buffer = new int[]{nums1[i][0],nums1[i][1] + nums2[j][1]};\\n        \\n                    answer.add(buffer);\\n                    nums2[j][0] = -1;\\n                    break;\\n\\n                }else if (j == nums2.length-1) {\\n                    answer.add(nums1[i]);\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < nums2.length; i++) {\\n            if (nums2[i][0] != -1){\\n                answer.add(nums2[i]);\\n            }\\n        }\\n\\n        int[][] array = new int[answer.size()][];\\n        for (int i = 0; i < answer.size(); i++) {\\n            array[i] = answer.get(i);\\n        }\\n        \\n        Arrays.sort(array, Comparator.comparingInt(a -> a[0]));\\n        return array;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706232,
                "title": "python-while-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        summed = []\\n        i = 0\\n        j = 0\\n        while i<len(nums1) and j<len(nums2):\\n            if nums1[i][0] == nums2[j][0]:\\n                summed.append([nums1[i][0], nums1[i][1] + nums2[j][1]])\\n                i+=1\\n                j+=1\\n                continue\\n            if nums1[i][0] < nums2[j][0]:\\n                summed.append([nums1[i][0], nums1[i][1]])\\n                i+=1\\n            else:\\n                summed.append([nums2[j][0], nums2[j][1]])\\n                j+=1\\n        \\n        while i<len(nums1):\\n            summed.append([nums1[i][0], nums1[i][1]])\\n            i+=1\\n        \\n        while j<len(nums2):\\n            summed.append([nums2[j][0], nums2[j][1]])\\n            j+=1\\n        \\n        return summed\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n            \\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        summed = []\\n        i = 0\\n        j = 0\\n        while i<len(nums1) and j<len(nums2):\\n            if nums1[i][0] == nums2[j][0]:\\n                summed.append([nums1[i][0], nums1[i][1] + nums2[j][1]])\\n                i+=1\\n                j+=1\\n                continue\\n            if nums1[i][0] < nums2[j][0]:\\n                summed.append([nums1[i][0], nums1[i][1]])\\n                i+=1\\n            else:\\n                summed.append([nums2[j][0], nums2[j][1]])\\n                j+=1\\n        \\n        while i<len(nums1):\\n            summed.append([nums1[i][0], nums1[i][1]])\\n            i+=1\\n        \\n        while j<len(nums2):\\n            summed.append([nums2[j][0], nums2[j][1]])\\n            j+=1\\n        \\n        return summed\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703632,
                "title": "python-simple-solution",
                "content": "\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        nums1.extend(nums2)\\n        for i in range(len(nums1)-1):\\n            for j in nums1[i+1:len(nums1)]:\\n                if nums1[i][0] == j[0]:\\n                    nums1[i][1]+=j[1]\\n                    nums1.remove(j)\\n\\n        nums1.sort(key = lambda x :x[0])\\n        return nums1",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\\n        nums1.extend(nums2)\\n        for i in range(len(nums1)-1):\\n            for j in nums1[i+1:len(nums1)]:\\n                if nums1[i][0] == j[0]:\\n                    nums1[i][1]+=j[1]\\n                    nums1.remove(j)\\n\\n        nums1.sort(key = lambda x :x[0])\\n        return nums1",
                "codeTag": "Python3"
            },
            {
                "id": 3702555,
                "title": "kotlin-solution-using-hashmap",
                "content": "# Code\\n```\\nclass Solution {\\n    fun mergeArrays(nums1: Array<IntArray>, nums2: Array<IntArray>): Array<IntArray> {\\n        var hash = HashMap<Int, Int>()\\n        nums1.forEach {\\n            if(hash.containsKey(it[0])) {\\n                hash[it[0]] = it[1] + hash.getValue(it[0])\\n            } else {\\n                hash.put(it[0], it[1])\\n            }\\n        }\\n        nums2.forEach {\\n            if(hash.containsKey(it[0])) {\\n                hash[it[0]] = it[1] + hash.getValue(it[0])\\n            } else {\\n                hash.put(it[0], it[1])\\n            }\\n        }\\n        var sortedHash = TreeMap(hash)\\n        var output = ArrayList<IntArray>()\\n        sortedHash.forEach { key, value ->\\n            output.add(intArrayOf(key, value))\\n        }\\n        return output.toTypedArray()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun mergeArrays(nums1: Array<IntArray>, nums2: Array<IntArray>): Array<IntArray> {\\n        var hash = HashMap<Int, Int>()\\n        nums1.forEach {\\n            if(hash.containsKey(it[0])) {\\n                hash[it[0]] = it[1] + hash.getValue(it[0])\\n            } else {\\n                hash.put(it[0], it[1])\\n            }\\n        }\\n        nums2.forEach {\\n            if(hash.containsKey(it[0])) {\\n                hash[it[0]] = it[1] + hash.getValue(it[0])\\n            } else {\\n                hash.put(it[0], it[1])\\n            }\\n        }\\n        var sortedHash = TreeMap(hash)\\n        var output = ArrayList<IntArray>()\\n        sortedHash.forEach { key, value ->\\n            output.add(intArrayOf(key, value))\\n        }\\n        return output.toTypedArray()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3700117,
                "title": "dart-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n  List<List<int>> mergeArrays(List<List<int>> nums1, List<List<int>> nums2) {\\n    int ptr1 = 0;\\n    int ptr2 = 0;\\n    List<List<int>> result = [];\\n\\n    while (ptr1 < nums1.length && ptr2 < nums2.length) {\\n      int id1 = nums1[ptr1][0];\\n      int id2 = nums2[ptr2][0];\\n\\n      if (id1 < id2) {\\n        result.add([id1, nums1[ptr1][1]]);\\n        ptr1++;\\n      } else if (id1 > id2) {\\n        result.add([id2, nums2[ptr2][1]]);\\n        ptr2++;\\n      } else {\\n        int value = nums1[ptr1][1] + nums2[ptr2][1];\\n        result.add([id1, value]);\\n        ptr1++;\\n        ptr2++;\\n      }\\n    }\\n\\n    while (ptr1 < nums1.length) {\\n      result.add([nums1[ptr1][0], nums1[ptr1][1]]);\\n      ptr1++;\\n    }\\n\\n    while (ptr2 < nums2.length) {\\n      result.add([nums2[ptr2][0], nums2[ptr2][1]]);\\n      ptr2++;\\n    }\\n\\n    return result;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  List<List<int>> mergeArrays(List<List<int>> nums1, List<List<int>> nums2) {\\n    int ptr1 = 0;\\n    int ptr2 = 0;\\n    List<List<int>> result = [];\\n\\n    while (ptr1 < nums1.length && ptr2 < nums2.length) {\\n      int id1 = nums1[ptr1][0];\\n      int id2 = nums2[ptr2][0];\\n\\n      if (id1 < id2) {\\n        result.add([id1, nums1[ptr1][1]]);\\n        ptr1++;\\n      } else if (id1 > id2) {\\n        result.add([id2, nums2[ptr2][1]]);\\n        ptr2++;\\n      } else {\\n        int value = nums1[ptr1][1] + nums2[ptr2][1];\\n        result.add([id1, value]);\\n        ptr1++;\\n        ptr2++;\\n      }\\n    }\\n\\n    while (ptr1 < nums1.length) {\\n      result.add([nums1[ptr1][0], nums1[ptr1][1]]);\\n      ptr1++;\\n    }\\n\\n    while (ptr2 < nums2.length) {\\n      result.add([nums2[ptr2][0], nums2[ptr2][1]]);\\n      ptr2++;\\n    }\\n\\n    return result;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1806627,
                "content": [
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Very Easy Question \\nFirst create a HashMap and store the value of first array \\nand then Store the value of second array with condition if map does not contains key if it contains key already then store the sum of previous value plus current value .and also we count the number of key from hashMap with the loop to use one variable .\\nAfter that we create TreeMap because we want sorted key .\\nThen we create a 2D array of number of row =number of key in the hashMap which we count already and we know the number of column is always 2 \\nthen we iterate the loop on TREEMAP and store the value in our array \\nat the end we return the array .\\n\\n\\n"
                    },
                    {
                        "username": "Hakob_Saghatelyan",
                        "content": "You can solve it without using HashMap and TreeMap, better we can use only O(1) extra memory. Ids are already sorted in the arrays, so you can just use two iterators and iterate through the both arrays at the same time. On each iteration we just compare id from one array with id from the other. And depending on the result of comparison <, >, == we just add appropriate pair to the answer array. Time complexity O(n + m), extra memory O(1)"
                    },
                    {
                        "username": "potatopie",
                        "content": "2363\\tMerge Similar Items -  is exactly similar to this....."
                    },
                    {
                        "username": "pa-one55",
                        "content": "too lazy to do this.. \\uD83D\\uDE34"
                    },
                    {
                        "username": "holywatersheep",
                        "content": "bro, i just came from unique number of occurrences"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach O(N1+N2) :-\n\nInitialize two variables to store the lengths of the two arrays to be merged.\n\nCreate an empty list to store the merged arrays.\n\nUse a loop to iterate through both arrays simultaneously, comparing the first elements of each subarray and adding the smaller one to the merged list.\n\nAfter the loop, add any remaining subarrays to the merged list.\n\nReturn the merged list as a 2D array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/merge-two-2d-arrays-by-summing-values/solutions/3203787/using-merge-sort-java/"
                    },
                    {
                        "username": "yeah_boi123",
                        "content": "just iterate both the vectors from beginning by comparing their id values if same then add the values and push in ans vector and increase both i and j  and if id are different put the smaller id one and increment only that index and at end if any iterator does not reaches end complete by running while loop"
                    },
                    {
                        "username": "hannangujar",
                        "content": "The merge_arrays method takes two arrays nums1 and nums2 as arguments and returns the merged array.\\n\\nThe method uses two indices i and j to iterate over nums1 and nums2 respectively. It also initializes two variables n and m to the sizes of the two arrays.\\n\\nThe method creates an empty array result to hold the merged array.\\n\\nThe while loop continues as long as there are elements left in either nums1 or nums2. Inside the loop, the method compares the current ids of nums1[i] and nums2[j] to determine which id should be added to the result array. If the ids are equal, the method adds the values of the two ids together.\\n\\nFinally, the method returns the merged array result.\\n\\nNote that this solution assumes that the input arrays nums1 and nums2 are sorted in ascending order by id. If the input arrays are not sorted, you can add a sorting step before the while loop."
                    },
                    {
                        "username": "khazratovi",
                        "content": "Finally!"
                    },
                    {
                        "username": "c4tdog",
                        "content": "similar to https://leetcode.com/problems/merge-similar-items/description/"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "C++ Easy and simple solution \\nMy solution Link : https://leetcode.com/problems/merge-two-2d-arrays-by-summing-values/solutions/3205386/c-easy-and-simple-solution-using-hashmap/\\nDon\\'t forgot to upvote it. "
                    }
                ]
            },
            {
                "id": 1996448,
                "content": [
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Very Easy Question \\nFirst create a HashMap and store the value of first array \\nand then Store the value of second array with condition if map does not contains key if it contains key already then store the sum of previous value plus current value .and also we count the number of key from hashMap with the loop to use one variable .\\nAfter that we create TreeMap because we want sorted key .\\nThen we create a 2D array of number of row =number of key in the hashMap which we count already and we know the number of column is always 2 \\nthen we iterate the loop on TREEMAP and store the value in our array \\nat the end we return the array .\\n\\n\\n"
                    },
                    {
                        "username": "Hakob_Saghatelyan",
                        "content": "You can solve it without using HashMap and TreeMap, better we can use only O(1) extra memory. Ids are already sorted in the arrays, so you can just use two iterators and iterate through the both arrays at the same time. On each iteration we just compare id from one array with id from the other. And depending on the result of comparison <, >, == we just add appropriate pair to the answer array. Time complexity O(n + m), extra memory O(1)"
                    },
                    {
                        "username": "potatopie",
                        "content": "2363\\tMerge Similar Items -  is exactly similar to this....."
                    },
                    {
                        "username": "pa-one55",
                        "content": "too lazy to do this.. \\uD83D\\uDE34"
                    },
                    {
                        "username": "holywatersheep",
                        "content": "bro, i just came from unique number of occurrences"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach O(N1+N2) :-\n\nInitialize two variables to store the lengths of the two arrays to be merged.\n\nCreate an empty list to store the merged arrays.\n\nUse a loop to iterate through both arrays simultaneously, comparing the first elements of each subarray and adding the smaller one to the merged list.\n\nAfter the loop, add any remaining subarrays to the merged list.\n\nReturn the merged list as a 2D array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/merge-two-2d-arrays-by-summing-values/solutions/3203787/using-merge-sort-java/"
                    },
                    {
                        "username": "yeah_boi123",
                        "content": "just iterate both the vectors from beginning by comparing their id values if same then add the values and push in ans vector and increase both i and j  and if id are different put the smaller id one and increment only that index and at end if any iterator does not reaches end complete by running while loop"
                    },
                    {
                        "username": "hannangujar",
                        "content": "The merge_arrays method takes two arrays nums1 and nums2 as arguments and returns the merged array.\\n\\nThe method uses two indices i and j to iterate over nums1 and nums2 respectively. It also initializes two variables n and m to the sizes of the two arrays.\\n\\nThe method creates an empty array result to hold the merged array.\\n\\nThe while loop continues as long as there are elements left in either nums1 or nums2. Inside the loop, the method compares the current ids of nums1[i] and nums2[j] to determine which id should be added to the result array. If the ids are equal, the method adds the values of the two ids together.\\n\\nFinally, the method returns the merged array result.\\n\\nNote that this solution assumes that the input arrays nums1 and nums2 are sorted in ascending order by id. If the input arrays are not sorted, you can add a sorting step before the while loop."
                    },
                    {
                        "username": "khazratovi",
                        "content": "Finally!"
                    },
                    {
                        "username": "c4tdog",
                        "content": "similar to https://leetcode.com/problems/merge-similar-items/description/"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "C++ Easy and simple solution \\nMy solution Link : https://leetcode.com/problems/merge-two-2d-arrays-by-summing-values/solutions/3205386/c-easy-and-simple-solution-using-hashmap/\\nDon\\'t forgot to upvote it. "
                    }
                ]
            },
            {
                "id": 1980821,
                "content": [
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Very Easy Question \\nFirst create a HashMap and store the value of first array \\nand then Store the value of second array with condition if map does not contains key if it contains key already then store the sum of previous value plus current value .and also we count the number of key from hashMap with the loop to use one variable .\\nAfter that we create TreeMap because we want sorted key .\\nThen we create a 2D array of number of row =number of key in the hashMap which we count already and we know the number of column is always 2 \\nthen we iterate the loop on TREEMAP and store the value in our array \\nat the end we return the array .\\n\\n\\n"
                    },
                    {
                        "username": "Hakob_Saghatelyan",
                        "content": "You can solve it without using HashMap and TreeMap, better we can use only O(1) extra memory. Ids are already sorted in the arrays, so you can just use two iterators and iterate through the both arrays at the same time. On each iteration we just compare id from one array with id from the other. And depending on the result of comparison <, >, == we just add appropriate pair to the answer array. Time complexity O(n + m), extra memory O(1)"
                    },
                    {
                        "username": "potatopie",
                        "content": "2363\\tMerge Similar Items -  is exactly similar to this....."
                    },
                    {
                        "username": "pa-one55",
                        "content": "too lazy to do this.. \\uD83D\\uDE34"
                    },
                    {
                        "username": "holywatersheep",
                        "content": "bro, i just came from unique number of occurrences"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach O(N1+N2) :-\n\nInitialize two variables to store the lengths of the two arrays to be merged.\n\nCreate an empty list to store the merged arrays.\n\nUse a loop to iterate through both arrays simultaneously, comparing the first elements of each subarray and adding the smaller one to the merged list.\n\nAfter the loop, add any remaining subarrays to the merged list.\n\nReturn the merged list as a 2D array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/merge-two-2d-arrays-by-summing-values/solutions/3203787/using-merge-sort-java/"
                    },
                    {
                        "username": "yeah_boi123",
                        "content": "just iterate both the vectors from beginning by comparing their id values if same then add the values and push in ans vector and increase both i and j  and if id are different put the smaller id one and increment only that index and at end if any iterator does not reaches end complete by running while loop"
                    },
                    {
                        "username": "hannangujar",
                        "content": "The merge_arrays method takes two arrays nums1 and nums2 as arguments and returns the merged array.\\n\\nThe method uses two indices i and j to iterate over nums1 and nums2 respectively. It also initializes two variables n and m to the sizes of the two arrays.\\n\\nThe method creates an empty array result to hold the merged array.\\n\\nThe while loop continues as long as there are elements left in either nums1 or nums2. Inside the loop, the method compares the current ids of nums1[i] and nums2[j] to determine which id should be added to the result array. If the ids are equal, the method adds the values of the two ids together.\\n\\nFinally, the method returns the merged array result.\\n\\nNote that this solution assumes that the input arrays nums1 and nums2 are sorted in ascending order by id. If the input arrays are not sorted, you can add a sorting step before the while loop."
                    },
                    {
                        "username": "khazratovi",
                        "content": "Finally!"
                    },
                    {
                        "username": "c4tdog",
                        "content": "similar to https://leetcode.com/problems/merge-similar-items/description/"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "C++ Easy and simple solution \\nMy solution Link : https://leetcode.com/problems/merge-two-2d-arrays-by-summing-values/solutions/3205386/c-easy-and-simple-solution-using-hashmap/\\nDon\\'t forgot to upvote it. "
                    }
                ]
            },
            {
                "id": 1964699,
                "content": [
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Very Easy Question \\nFirst create a HashMap and store the value of first array \\nand then Store the value of second array with condition if map does not contains key if it contains key already then store the sum of previous value plus current value .and also we count the number of key from hashMap with the loop to use one variable .\\nAfter that we create TreeMap because we want sorted key .\\nThen we create a 2D array of number of row =number of key in the hashMap which we count already and we know the number of column is always 2 \\nthen we iterate the loop on TREEMAP and store the value in our array \\nat the end we return the array .\\n\\n\\n"
                    },
                    {
                        "username": "Hakob_Saghatelyan",
                        "content": "You can solve it without using HashMap and TreeMap, better we can use only O(1) extra memory. Ids are already sorted in the arrays, so you can just use two iterators and iterate through the both arrays at the same time. On each iteration we just compare id from one array with id from the other. And depending on the result of comparison <, >, == we just add appropriate pair to the answer array. Time complexity O(n + m), extra memory O(1)"
                    },
                    {
                        "username": "potatopie",
                        "content": "2363\\tMerge Similar Items -  is exactly similar to this....."
                    },
                    {
                        "username": "pa-one55",
                        "content": "too lazy to do this.. \\uD83D\\uDE34"
                    },
                    {
                        "username": "holywatersheep",
                        "content": "bro, i just came from unique number of occurrences"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach O(N1+N2) :-\n\nInitialize two variables to store the lengths of the two arrays to be merged.\n\nCreate an empty list to store the merged arrays.\n\nUse a loop to iterate through both arrays simultaneously, comparing the first elements of each subarray and adding the smaller one to the merged list.\n\nAfter the loop, add any remaining subarrays to the merged list.\n\nReturn the merged list as a 2D array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/merge-two-2d-arrays-by-summing-values/solutions/3203787/using-merge-sort-java/"
                    },
                    {
                        "username": "yeah_boi123",
                        "content": "just iterate both the vectors from beginning by comparing their id values if same then add the values and push in ans vector and increase both i and j  and if id are different put the smaller id one and increment only that index and at end if any iterator does not reaches end complete by running while loop"
                    },
                    {
                        "username": "hannangujar",
                        "content": "The merge_arrays method takes two arrays nums1 and nums2 as arguments and returns the merged array.\\n\\nThe method uses two indices i and j to iterate over nums1 and nums2 respectively. It also initializes two variables n and m to the sizes of the two arrays.\\n\\nThe method creates an empty array result to hold the merged array.\\n\\nThe while loop continues as long as there are elements left in either nums1 or nums2. Inside the loop, the method compares the current ids of nums1[i] and nums2[j] to determine which id should be added to the result array. If the ids are equal, the method adds the values of the two ids together.\\n\\nFinally, the method returns the merged array result.\\n\\nNote that this solution assumes that the input arrays nums1 and nums2 are sorted in ascending order by id. If the input arrays are not sorted, you can add a sorting step before the while loop."
                    },
                    {
                        "username": "khazratovi",
                        "content": "Finally!"
                    },
                    {
                        "username": "c4tdog",
                        "content": "similar to https://leetcode.com/problems/merge-similar-items/description/"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "C++ Easy and simple solution \\nMy solution Link : https://leetcode.com/problems/merge-two-2d-arrays-by-summing-values/solutions/3205386/c-easy-and-simple-solution-using-hashmap/\\nDon\\'t forgot to upvote it. "
                    }
                ]
            },
            {
                "id": 1828825,
                "content": [
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Very Easy Question \\nFirst create a HashMap and store the value of first array \\nand then Store the value of second array with condition if map does not contains key if it contains key already then store the sum of previous value plus current value .and also we count the number of key from hashMap with the loop to use one variable .\\nAfter that we create TreeMap because we want sorted key .\\nThen we create a 2D array of number of row =number of key in the hashMap which we count already and we know the number of column is always 2 \\nthen we iterate the loop on TREEMAP and store the value in our array \\nat the end we return the array .\\n\\n\\n"
                    },
                    {
                        "username": "Hakob_Saghatelyan",
                        "content": "You can solve it without using HashMap and TreeMap, better we can use only O(1) extra memory. Ids are already sorted in the arrays, so you can just use two iterators and iterate through the both arrays at the same time. On each iteration we just compare id from one array with id from the other. And depending on the result of comparison <, >, == we just add appropriate pair to the answer array. Time complexity O(n + m), extra memory O(1)"
                    },
                    {
                        "username": "potatopie",
                        "content": "2363\\tMerge Similar Items -  is exactly similar to this....."
                    },
                    {
                        "username": "pa-one55",
                        "content": "too lazy to do this.. \\uD83D\\uDE34"
                    },
                    {
                        "username": "holywatersheep",
                        "content": "bro, i just came from unique number of occurrences"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach O(N1+N2) :-\n\nInitialize two variables to store the lengths of the two arrays to be merged.\n\nCreate an empty list to store the merged arrays.\n\nUse a loop to iterate through both arrays simultaneously, comparing the first elements of each subarray and adding the smaller one to the merged list.\n\nAfter the loop, add any remaining subarrays to the merged list.\n\nReturn the merged list as a 2D array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/merge-two-2d-arrays-by-summing-values/solutions/3203787/using-merge-sort-java/"
                    },
                    {
                        "username": "yeah_boi123",
                        "content": "just iterate both the vectors from beginning by comparing their id values if same then add the values and push in ans vector and increase both i and j  and if id are different put the smaller id one and increment only that index and at end if any iterator does not reaches end complete by running while loop"
                    },
                    {
                        "username": "hannangujar",
                        "content": "The merge_arrays method takes two arrays nums1 and nums2 as arguments and returns the merged array.\\n\\nThe method uses two indices i and j to iterate over nums1 and nums2 respectively. It also initializes two variables n and m to the sizes of the two arrays.\\n\\nThe method creates an empty array result to hold the merged array.\\n\\nThe while loop continues as long as there are elements left in either nums1 or nums2. Inside the loop, the method compares the current ids of nums1[i] and nums2[j] to determine which id should be added to the result array. If the ids are equal, the method adds the values of the two ids together.\\n\\nFinally, the method returns the merged array result.\\n\\nNote that this solution assumes that the input arrays nums1 and nums2 are sorted in ascending order by id. If the input arrays are not sorted, you can add a sorting step before the while loop."
                    },
                    {
                        "username": "khazratovi",
                        "content": "Finally!"
                    },
                    {
                        "username": "c4tdog",
                        "content": "similar to https://leetcode.com/problems/merge-similar-items/description/"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "C++ Easy and simple solution \\nMy solution Link : https://leetcode.com/problems/merge-two-2d-arrays-by-summing-values/solutions/3205386/c-easy-and-simple-solution-using-hashmap/\\nDon\\'t forgot to upvote it. "
                    }
                ]
            },
            {
                "id": 1816333,
                "content": [
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Very Easy Question \\nFirst create a HashMap and store the value of first array \\nand then Store the value of second array with condition if map does not contains key if it contains key already then store the sum of previous value plus current value .and also we count the number of key from hashMap with the loop to use one variable .\\nAfter that we create TreeMap because we want sorted key .\\nThen we create a 2D array of number of row =number of key in the hashMap which we count already and we know the number of column is always 2 \\nthen we iterate the loop on TREEMAP and store the value in our array \\nat the end we return the array .\\n\\n\\n"
                    },
                    {
                        "username": "Hakob_Saghatelyan",
                        "content": "You can solve it without using HashMap and TreeMap, better we can use only O(1) extra memory. Ids are already sorted in the arrays, so you can just use two iterators and iterate through the both arrays at the same time. On each iteration we just compare id from one array with id from the other. And depending on the result of comparison <, >, == we just add appropriate pair to the answer array. Time complexity O(n + m), extra memory O(1)"
                    },
                    {
                        "username": "potatopie",
                        "content": "2363\\tMerge Similar Items -  is exactly similar to this....."
                    },
                    {
                        "username": "pa-one55",
                        "content": "too lazy to do this.. \\uD83D\\uDE34"
                    },
                    {
                        "username": "holywatersheep",
                        "content": "bro, i just came from unique number of occurrences"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach O(N1+N2) :-\n\nInitialize two variables to store the lengths of the two arrays to be merged.\n\nCreate an empty list to store the merged arrays.\n\nUse a loop to iterate through both arrays simultaneously, comparing the first elements of each subarray and adding the smaller one to the merged list.\n\nAfter the loop, add any remaining subarrays to the merged list.\n\nReturn the merged list as a 2D array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/merge-two-2d-arrays-by-summing-values/solutions/3203787/using-merge-sort-java/"
                    },
                    {
                        "username": "yeah_boi123",
                        "content": "just iterate both the vectors from beginning by comparing their id values if same then add the values and push in ans vector and increase both i and j  and if id are different put the smaller id one and increment only that index and at end if any iterator does not reaches end complete by running while loop"
                    },
                    {
                        "username": "hannangujar",
                        "content": "The merge_arrays method takes two arrays nums1 and nums2 as arguments and returns the merged array.\\n\\nThe method uses two indices i and j to iterate over nums1 and nums2 respectively. It also initializes two variables n and m to the sizes of the two arrays.\\n\\nThe method creates an empty array result to hold the merged array.\\n\\nThe while loop continues as long as there are elements left in either nums1 or nums2. Inside the loop, the method compares the current ids of nums1[i] and nums2[j] to determine which id should be added to the result array. If the ids are equal, the method adds the values of the two ids together.\\n\\nFinally, the method returns the merged array result.\\n\\nNote that this solution assumes that the input arrays nums1 and nums2 are sorted in ascending order by id. If the input arrays are not sorted, you can add a sorting step before the while loop."
                    },
                    {
                        "username": "khazratovi",
                        "content": "Finally!"
                    },
                    {
                        "username": "c4tdog",
                        "content": "similar to https://leetcode.com/problems/merge-similar-items/description/"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "C++ Easy and simple solution \\nMy solution Link : https://leetcode.com/problems/merge-two-2d-arrays-by-summing-values/solutions/3205386/c-easy-and-simple-solution-using-hashmap/\\nDon\\'t forgot to upvote it. "
                    }
                ]
            },
            {
                "id": 1810333,
                "content": [
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Very Easy Question \\nFirst create a HashMap and store the value of first array \\nand then Store the value of second array with condition if map does not contains key if it contains key already then store the sum of previous value plus current value .and also we count the number of key from hashMap with the loop to use one variable .\\nAfter that we create TreeMap because we want sorted key .\\nThen we create a 2D array of number of row =number of key in the hashMap which we count already and we know the number of column is always 2 \\nthen we iterate the loop on TREEMAP and store the value in our array \\nat the end we return the array .\\n\\n\\n"
                    },
                    {
                        "username": "Hakob_Saghatelyan",
                        "content": "You can solve it without using HashMap and TreeMap, better we can use only O(1) extra memory. Ids are already sorted in the arrays, so you can just use two iterators and iterate through the both arrays at the same time. On each iteration we just compare id from one array with id from the other. And depending on the result of comparison <, >, == we just add appropriate pair to the answer array. Time complexity O(n + m), extra memory O(1)"
                    },
                    {
                        "username": "potatopie",
                        "content": "2363\\tMerge Similar Items -  is exactly similar to this....."
                    },
                    {
                        "username": "pa-one55",
                        "content": "too lazy to do this.. \\uD83D\\uDE34"
                    },
                    {
                        "username": "holywatersheep",
                        "content": "bro, i just came from unique number of occurrences"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach O(N1+N2) :-\n\nInitialize two variables to store the lengths of the two arrays to be merged.\n\nCreate an empty list to store the merged arrays.\n\nUse a loop to iterate through both arrays simultaneously, comparing the first elements of each subarray and adding the smaller one to the merged list.\n\nAfter the loop, add any remaining subarrays to the merged list.\n\nReturn the merged list as a 2D array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/merge-two-2d-arrays-by-summing-values/solutions/3203787/using-merge-sort-java/"
                    },
                    {
                        "username": "yeah_boi123",
                        "content": "just iterate both the vectors from beginning by comparing their id values if same then add the values and push in ans vector and increase both i and j  and if id are different put the smaller id one and increment only that index and at end if any iterator does not reaches end complete by running while loop"
                    },
                    {
                        "username": "hannangujar",
                        "content": "The merge_arrays method takes two arrays nums1 and nums2 as arguments and returns the merged array.\\n\\nThe method uses two indices i and j to iterate over nums1 and nums2 respectively. It also initializes two variables n and m to the sizes of the two arrays.\\n\\nThe method creates an empty array result to hold the merged array.\\n\\nThe while loop continues as long as there are elements left in either nums1 or nums2. Inside the loop, the method compares the current ids of nums1[i] and nums2[j] to determine which id should be added to the result array. If the ids are equal, the method adds the values of the two ids together.\\n\\nFinally, the method returns the merged array result.\\n\\nNote that this solution assumes that the input arrays nums1 and nums2 are sorted in ascending order by id. If the input arrays are not sorted, you can add a sorting step before the while loop."
                    },
                    {
                        "username": "khazratovi",
                        "content": "Finally!"
                    },
                    {
                        "username": "c4tdog",
                        "content": "similar to https://leetcode.com/problems/merge-similar-items/description/"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "C++ Easy and simple solution \\nMy solution Link : https://leetcode.com/problems/merge-two-2d-arrays-by-summing-values/solutions/3205386/c-easy-and-simple-solution-using-hashmap/\\nDon\\'t forgot to upvote it. "
                    }
                ]
            },
            {
                "id": 1809619,
                "content": [
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Very Easy Question \\nFirst create a HashMap and store the value of first array \\nand then Store the value of second array with condition if map does not contains key if it contains key already then store the sum of previous value plus current value .and also we count the number of key from hashMap with the loop to use one variable .\\nAfter that we create TreeMap because we want sorted key .\\nThen we create a 2D array of number of row =number of key in the hashMap which we count already and we know the number of column is always 2 \\nthen we iterate the loop on TREEMAP and store the value in our array \\nat the end we return the array .\\n\\n\\n"
                    },
                    {
                        "username": "Hakob_Saghatelyan",
                        "content": "You can solve it without using HashMap and TreeMap, better we can use only O(1) extra memory. Ids are already sorted in the arrays, so you can just use two iterators and iterate through the both arrays at the same time. On each iteration we just compare id from one array with id from the other. And depending on the result of comparison <, >, == we just add appropriate pair to the answer array. Time complexity O(n + m), extra memory O(1)"
                    },
                    {
                        "username": "potatopie",
                        "content": "2363\\tMerge Similar Items -  is exactly similar to this....."
                    },
                    {
                        "username": "pa-one55",
                        "content": "too lazy to do this.. \\uD83D\\uDE34"
                    },
                    {
                        "username": "holywatersheep",
                        "content": "bro, i just came from unique number of occurrences"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach O(N1+N2) :-\n\nInitialize two variables to store the lengths of the two arrays to be merged.\n\nCreate an empty list to store the merged arrays.\n\nUse a loop to iterate through both arrays simultaneously, comparing the first elements of each subarray and adding the smaller one to the merged list.\n\nAfter the loop, add any remaining subarrays to the merged list.\n\nReturn the merged list as a 2D array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/merge-two-2d-arrays-by-summing-values/solutions/3203787/using-merge-sort-java/"
                    },
                    {
                        "username": "yeah_boi123",
                        "content": "just iterate both the vectors from beginning by comparing their id values if same then add the values and push in ans vector and increase both i and j  and if id are different put the smaller id one and increment only that index and at end if any iterator does not reaches end complete by running while loop"
                    },
                    {
                        "username": "hannangujar",
                        "content": "The merge_arrays method takes two arrays nums1 and nums2 as arguments and returns the merged array.\\n\\nThe method uses two indices i and j to iterate over nums1 and nums2 respectively. It also initializes two variables n and m to the sizes of the two arrays.\\n\\nThe method creates an empty array result to hold the merged array.\\n\\nThe while loop continues as long as there are elements left in either nums1 or nums2. Inside the loop, the method compares the current ids of nums1[i] and nums2[j] to determine which id should be added to the result array. If the ids are equal, the method adds the values of the two ids together.\\n\\nFinally, the method returns the merged array result.\\n\\nNote that this solution assumes that the input arrays nums1 and nums2 are sorted in ascending order by id. If the input arrays are not sorted, you can add a sorting step before the while loop."
                    },
                    {
                        "username": "khazratovi",
                        "content": "Finally!"
                    },
                    {
                        "username": "c4tdog",
                        "content": "similar to https://leetcode.com/problems/merge-similar-items/description/"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "C++ Easy and simple solution \\nMy solution Link : https://leetcode.com/problems/merge-two-2d-arrays-by-summing-values/solutions/3205386/c-easy-and-simple-solution-using-hashmap/\\nDon\\'t forgot to upvote it. "
                    }
                ]
            },
            {
                "id": 1808966,
                "content": [
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Very Easy Question \\nFirst create a HashMap and store the value of first array \\nand then Store the value of second array with condition if map does not contains key if it contains key already then store the sum of previous value plus current value .and also we count the number of key from hashMap with the loop to use one variable .\\nAfter that we create TreeMap because we want sorted key .\\nThen we create a 2D array of number of row =number of key in the hashMap which we count already and we know the number of column is always 2 \\nthen we iterate the loop on TREEMAP and store the value in our array \\nat the end we return the array .\\n\\n\\n"
                    },
                    {
                        "username": "Hakob_Saghatelyan",
                        "content": "You can solve it without using HashMap and TreeMap, better we can use only O(1) extra memory. Ids are already sorted in the arrays, so you can just use two iterators and iterate through the both arrays at the same time. On each iteration we just compare id from one array with id from the other. And depending on the result of comparison <, >, == we just add appropriate pair to the answer array. Time complexity O(n + m), extra memory O(1)"
                    },
                    {
                        "username": "potatopie",
                        "content": "2363\\tMerge Similar Items -  is exactly similar to this....."
                    },
                    {
                        "username": "pa-one55",
                        "content": "too lazy to do this.. \\uD83D\\uDE34"
                    },
                    {
                        "username": "holywatersheep",
                        "content": "bro, i just came from unique number of occurrences"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach O(N1+N2) :-\n\nInitialize two variables to store the lengths of the two arrays to be merged.\n\nCreate an empty list to store the merged arrays.\n\nUse a loop to iterate through both arrays simultaneously, comparing the first elements of each subarray and adding the smaller one to the merged list.\n\nAfter the loop, add any remaining subarrays to the merged list.\n\nReturn the merged list as a 2D array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/merge-two-2d-arrays-by-summing-values/solutions/3203787/using-merge-sort-java/"
                    },
                    {
                        "username": "yeah_boi123",
                        "content": "just iterate both the vectors from beginning by comparing their id values if same then add the values and push in ans vector and increase both i and j  and if id are different put the smaller id one and increment only that index and at end if any iterator does not reaches end complete by running while loop"
                    },
                    {
                        "username": "hannangujar",
                        "content": "The merge_arrays method takes two arrays nums1 and nums2 as arguments and returns the merged array.\\n\\nThe method uses two indices i and j to iterate over nums1 and nums2 respectively. It also initializes two variables n and m to the sizes of the two arrays.\\n\\nThe method creates an empty array result to hold the merged array.\\n\\nThe while loop continues as long as there are elements left in either nums1 or nums2. Inside the loop, the method compares the current ids of nums1[i] and nums2[j] to determine which id should be added to the result array. If the ids are equal, the method adds the values of the two ids together.\\n\\nFinally, the method returns the merged array result.\\n\\nNote that this solution assumes that the input arrays nums1 and nums2 are sorted in ascending order by id. If the input arrays are not sorted, you can add a sorting step before the while loop."
                    },
                    {
                        "username": "khazratovi",
                        "content": "Finally!"
                    },
                    {
                        "username": "c4tdog",
                        "content": "similar to https://leetcode.com/problems/merge-similar-items/description/"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "C++ Easy and simple solution \\nMy solution Link : https://leetcode.com/problems/merge-two-2d-arrays-by-summing-values/solutions/3205386/c-easy-and-simple-solution-using-hashmap/\\nDon\\'t forgot to upvote it. "
                    }
                ]
            },
            {
                "id": 1806926,
                "content": [
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Very Easy Question \\nFirst create a HashMap and store the value of first array \\nand then Store the value of second array with condition if map does not contains key if it contains key already then store the sum of previous value plus current value .and also we count the number of key from hashMap with the loop to use one variable .\\nAfter that we create TreeMap because we want sorted key .\\nThen we create a 2D array of number of row =number of key in the hashMap which we count already and we know the number of column is always 2 \\nthen we iterate the loop on TREEMAP and store the value in our array \\nat the end we return the array .\\n\\n\\n"
                    },
                    {
                        "username": "Hakob_Saghatelyan",
                        "content": "You can solve it without using HashMap and TreeMap, better we can use only O(1) extra memory. Ids are already sorted in the arrays, so you can just use two iterators and iterate through the both arrays at the same time. On each iteration we just compare id from one array with id from the other. And depending on the result of comparison <, >, == we just add appropriate pair to the answer array. Time complexity O(n + m), extra memory O(1)"
                    },
                    {
                        "username": "potatopie",
                        "content": "2363\\tMerge Similar Items -  is exactly similar to this....."
                    },
                    {
                        "username": "pa-one55",
                        "content": "too lazy to do this.. \\uD83D\\uDE34"
                    },
                    {
                        "username": "holywatersheep",
                        "content": "bro, i just came from unique number of occurrences"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach O(N1+N2) :-\n\nInitialize two variables to store the lengths of the two arrays to be merged.\n\nCreate an empty list to store the merged arrays.\n\nUse a loop to iterate through both arrays simultaneously, comparing the first elements of each subarray and adding the smaller one to the merged list.\n\nAfter the loop, add any remaining subarrays to the merged list.\n\nReturn the merged list as a 2D array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/merge-two-2d-arrays-by-summing-values/solutions/3203787/using-merge-sort-java/"
                    },
                    {
                        "username": "yeah_boi123",
                        "content": "just iterate both the vectors from beginning by comparing their id values if same then add the values and push in ans vector and increase both i and j  and if id are different put the smaller id one and increment only that index and at end if any iterator does not reaches end complete by running while loop"
                    },
                    {
                        "username": "hannangujar",
                        "content": "The merge_arrays method takes two arrays nums1 and nums2 as arguments and returns the merged array.\\n\\nThe method uses two indices i and j to iterate over nums1 and nums2 respectively. It also initializes two variables n and m to the sizes of the two arrays.\\n\\nThe method creates an empty array result to hold the merged array.\\n\\nThe while loop continues as long as there are elements left in either nums1 or nums2. Inside the loop, the method compares the current ids of nums1[i] and nums2[j] to determine which id should be added to the result array. If the ids are equal, the method adds the values of the two ids together.\\n\\nFinally, the method returns the merged array result.\\n\\nNote that this solution assumes that the input arrays nums1 and nums2 are sorted in ascending order by id. If the input arrays are not sorted, you can add a sorting step before the while loop."
                    },
                    {
                        "username": "khazratovi",
                        "content": "Finally!"
                    },
                    {
                        "username": "c4tdog",
                        "content": "similar to https://leetcode.com/problems/merge-similar-items/description/"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "C++ Easy and simple solution \\nMy solution Link : https://leetcode.com/problems/merge-two-2d-arrays-by-summing-values/solutions/3205386/c-easy-and-simple-solution-using-hashmap/\\nDon\\'t forgot to upvote it. "
                    }
                ]
            },
            {
                "id": 1806627,
                "content": [
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Very Easy Question \\nFirst create a HashMap and store the value of first array \\nand then Store the value of second array with condition if map does not contains key if it contains key already then store the sum of previous value plus current value .and also we count the number of key from hashMap with the loop to use one variable .\\nAfter that we create TreeMap because we want sorted key .\\nThen we create a 2D array of number of row =number of key in the hashMap which we count already and we know the number of column is always 2 \\nthen we iterate the loop on TREEMAP and store the value in our array \\nat the end we return the array .\\n\\n\\n"
                    },
                    {
                        "username": "Hakob_Saghatelyan",
                        "content": "You can solve it without using HashMap and TreeMap, better we can use only O(1) extra memory. Ids are already sorted in the arrays, so you can just use two iterators and iterate through the both arrays at the same time. On each iteration we just compare id from one array with id from the other. And depending on the result of comparison <, >, == we just add appropriate pair to the answer array. Time complexity O(n + m), extra memory O(1)"
                    },
                    {
                        "username": "potatopie",
                        "content": "2363\\tMerge Similar Items -  is exactly similar to this....."
                    },
                    {
                        "username": "pa-one55",
                        "content": "too lazy to do this.. \\uD83D\\uDE34"
                    },
                    {
                        "username": "holywatersheep",
                        "content": "bro, i just came from unique number of occurrences"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach O(N1+N2) :-\n\nInitialize two variables to store the lengths of the two arrays to be merged.\n\nCreate an empty list to store the merged arrays.\n\nUse a loop to iterate through both arrays simultaneously, comparing the first elements of each subarray and adding the smaller one to the merged list.\n\nAfter the loop, add any remaining subarrays to the merged list.\n\nReturn the merged list as a 2D array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/merge-two-2d-arrays-by-summing-values/solutions/3203787/using-merge-sort-java/"
                    },
                    {
                        "username": "yeah_boi123",
                        "content": "just iterate both the vectors from beginning by comparing their id values if same then add the values and push in ans vector and increase both i and j  and if id are different put the smaller id one and increment only that index and at end if any iterator does not reaches end complete by running while loop"
                    },
                    {
                        "username": "hannangujar",
                        "content": "The merge_arrays method takes two arrays nums1 and nums2 as arguments and returns the merged array.\\n\\nThe method uses two indices i and j to iterate over nums1 and nums2 respectively. It also initializes two variables n and m to the sizes of the two arrays.\\n\\nThe method creates an empty array result to hold the merged array.\\n\\nThe while loop continues as long as there are elements left in either nums1 or nums2. Inside the loop, the method compares the current ids of nums1[i] and nums2[j] to determine which id should be added to the result array. If the ids are equal, the method adds the values of the two ids together.\\n\\nFinally, the method returns the merged array result.\\n\\nNote that this solution assumes that the input arrays nums1 and nums2 are sorted in ascending order by id. If the input arrays are not sorted, you can add a sorting step before the while loop."
                    },
                    {
                        "username": "khazratovi",
                        "content": "Finally!"
                    },
                    {
                        "username": "c4tdog",
                        "content": "similar to https://leetcode.com/problems/merge-similar-items/description/"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "C++ Easy and simple solution \\nMy solution Link : https://leetcode.com/problems/merge-two-2d-arrays-by-summing-values/solutions/3205386/c-easy-and-simple-solution-using-hashmap/\\nDon\\'t forgot to upvote it. "
                    }
                ]
            },
            {
                "id": 1996448,
                "content": [
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Very Easy Question \\nFirst create a HashMap and store the value of first array \\nand then Store the value of second array with condition if map does not contains key if it contains key already then store the sum of previous value plus current value .and also we count the number of key from hashMap with the loop to use one variable .\\nAfter that we create TreeMap because we want sorted key .\\nThen we create a 2D array of number of row =number of key in the hashMap which we count already and we know the number of column is always 2 \\nthen we iterate the loop on TREEMAP and store the value in our array \\nat the end we return the array .\\n\\n\\n"
                    },
                    {
                        "username": "Hakob_Saghatelyan",
                        "content": "You can solve it without using HashMap and TreeMap, better we can use only O(1) extra memory. Ids are already sorted in the arrays, so you can just use two iterators and iterate through the both arrays at the same time. On each iteration we just compare id from one array with id from the other. And depending on the result of comparison <, >, == we just add appropriate pair to the answer array. Time complexity O(n + m), extra memory O(1)"
                    },
                    {
                        "username": "potatopie",
                        "content": "2363\\tMerge Similar Items -  is exactly similar to this....."
                    },
                    {
                        "username": "pa-one55",
                        "content": "too lazy to do this.. \\uD83D\\uDE34"
                    },
                    {
                        "username": "holywatersheep",
                        "content": "bro, i just came from unique number of occurrences"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach O(N1+N2) :-\n\nInitialize two variables to store the lengths of the two arrays to be merged.\n\nCreate an empty list to store the merged arrays.\n\nUse a loop to iterate through both arrays simultaneously, comparing the first elements of each subarray and adding the smaller one to the merged list.\n\nAfter the loop, add any remaining subarrays to the merged list.\n\nReturn the merged list as a 2D array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/merge-two-2d-arrays-by-summing-values/solutions/3203787/using-merge-sort-java/"
                    },
                    {
                        "username": "yeah_boi123",
                        "content": "just iterate both the vectors from beginning by comparing their id values if same then add the values and push in ans vector and increase both i and j  and if id are different put the smaller id one and increment only that index and at end if any iterator does not reaches end complete by running while loop"
                    },
                    {
                        "username": "hannangujar",
                        "content": "The merge_arrays method takes two arrays nums1 and nums2 as arguments and returns the merged array.\\n\\nThe method uses two indices i and j to iterate over nums1 and nums2 respectively. It also initializes two variables n and m to the sizes of the two arrays.\\n\\nThe method creates an empty array result to hold the merged array.\\n\\nThe while loop continues as long as there are elements left in either nums1 or nums2. Inside the loop, the method compares the current ids of nums1[i] and nums2[j] to determine which id should be added to the result array. If the ids are equal, the method adds the values of the two ids together.\\n\\nFinally, the method returns the merged array result.\\n\\nNote that this solution assumes that the input arrays nums1 and nums2 are sorted in ascending order by id. If the input arrays are not sorted, you can add a sorting step before the while loop."
                    },
                    {
                        "username": "khazratovi",
                        "content": "Finally!"
                    },
                    {
                        "username": "c4tdog",
                        "content": "similar to https://leetcode.com/problems/merge-similar-items/description/"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "C++ Easy and simple solution \\nMy solution Link : https://leetcode.com/problems/merge-two-2d-arrays-by-summing-values/solutions/3205386/c-easy-and-simple-solution-using-hashmap/\\nDon\\'t forgot to upvote it. "
                    }
                ]
            },
            {
                "id": 1980821,
                "content": [
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Very Easy Question \\nFirst create a HashMap and store the value of first array \\nand then Store the value of second array with condition if map does not contains key if it contains key already then store the sum of previous value plus current value .and also we count the number of key from hashMap with the loop to use one variable .\\nAfter that we create TreeMap because we want sorted key .\\nThen we create a 2D array of number of row =number of key in the hashMap which we count already and we know the number of column is always 2 \\nthen we iterate the loop on TREEMAP and store the value in our array \\nat the end we return the array .\\n\\n\\n"
                    },
                    {
                        "username": "Hakob_Saghatelyan",
                        "content": "You can solve it without using HashMap and TreeMap, better we can use only O(1) extra memory. Ids are already sorted in the arrays, so you can just use two iterators and iterate through the both arrays at the same time. On each iteration we just compare id from one array with id from the other. And depending on the result of comparison <, >, == we just add appropriate pair to the answer array. Time complexity O(n + m), extra memory O(1)"
                    },
                    {
                        "username": "potatopie",
                        "content": "2363\\tMerge Similar Items -  is exactly similar to this....."
                    },
                    {
                        "username": "pa-one55",
                        "content": "too lazy to do this.. \\uD83D\\uDE34"
                    },
                    {
                        "username": "holywatersheep",
                        "content": "bro, i just came from unique number of occurrences"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach O(N1+N2) :-\n\nInitialize two variables to store the lengths of the two arrays to be merged.\n\nCreate an empty list to store the merged arrays.\n\nUse a loop to iterate through both arrays simultaneously, comparing the first elements of each subarray and adding the smaller one to the merged list.\n\nAfter the loop, add any remaining subarrays to the merged list.\n\nReturn the merged list as a 2D array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/merge-two-2d-arrays-by-summing-values/solutions/3203787/using-merge-sort-java/"
                    },
                    {
                        "username": "yeah_boi123",
                        "content": "just iterate both the vectors from beginning by comparing their id values if same then add the values and push in ans vector and increase both i and j  and if id are different put the smaller id one and increment only that index and at end if any iterator does not reaches end complete by running while loop"
                    },
                    {
                        "username": "hannangujar",
                        "content": "The merge_arrays method takes two arrays nums1 and nums2 as arguments and returns the merged array.\\n\\nThe method uses two indices i and j to iterate over nums1 and nums2 respectively. It also initializes two variables n and m to the sizes of the two arrays.\\n\\nThe method creates an empty array result to hold the merged array.\\n\\nThe while loop continues as long as there are elements left in either nums1 or nums2. Inside the loop, the method compares the current ids of nums1[i] and nums2[j] to determine which id should be added to the result array. If the ids are equal, the method adds the values of the two ids together.\\n\\nFinally, the method returns the merged array result.\\n\\nNote that this solution assumes that the input arrays nums1 and nums2 are sorted in ascending order by id. If the input arrays are not sorted, you can add a sorting step before the while loop."
                    },
                    {
                        "username": "khazratovi",
                        "content": "Finally!"
                    },
                    {
                        "username": "c4tdog",
                        "content": "similar to https://leetcode.com/problems/merge-similar-items/description/"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "C++ Easy and simple solution \\nMy solution Link : https://leetcode.com/problems/merge-two-2d-arrays-by-summing-values/solutions/3205386/c-easy-and-simple-solution-using-hashmap/\\nDon\\'t forgot to upvote it. "
                    }
                ]
            },
            {
                "id": 1964699,
                "content": [
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Very Easy Question \\nFirst create a HashMap and store the value of first array \\nand then Store the value of second array with condition if map does not contains key if it contains key already then store the sum of previous value plus current value .and also we count the number of key from hashMap with the loop to use one variable .\\nAfter that we create TreeMap because we want sorted key .\\nThen we create a 2D array of number of row =number of key in the hashMap which we count already and we know the number of column is always 2 \\nthen we iterate the loop on TREEMAP and store the value in our array \\nat the end we return the array .\\n\\n\\n"
                    },
                    {
                        "username": "Hakob_Saghatelyan",
                        "content": "You can solve it without using HashMap and TreeMap, better we can use only O(1) extra memory. Ids are already sorted in the arrays, so you can just use two iterators and iterate through the both arrays at the same time. On each iteration we just compare id from one array with id from the other. And depending on the result of comparison <, >, == we just add appropriate pair to the answer array. Time complexity O(n + m), extra memory O(1)"
                    },
                    {
                        "username": "potatopie",
                        "content": "2363\\tMerge Similar Items -  is exactly similar to this....."
                    },
                    {
                        "username": "pa-one55",
                        "content": "too lazy to do this.. \\uD83D\\uDE34"
                    },
                    {
                        "username": "holywatersheep",
                        "content": "bro, i just came from unique number of occurrences"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach O(N1+N2) :-\n\nInitialize two variables to store the lengths of the two arrays to be merged.\n\nCreate an empty list to store the merged arrays.\n\nUse a loop to iterate through both arrays simultaneously, comparing the first elements of each subarray and adding the smaller one to the merged list.\n\nAfter the loop, add any remaining subarrays to the merged list.\n\nReturn the merged list as a 2D array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/merge-two-2d-arrays-by-summing-values/solutions/3203787/using-merge-sort-java/"
                    },
                    {
                        "username": "yeah_boi123",
                        "content": "just iterate both the vectors from beginning by comparing their id values if same then add the values and push in ans vector and increase both i and j  and if id are different put the smaller id one and increment only that index and at end if any iterator does not reaches end complete by running while loop"
                    },
                    {
                        "username": "hannangujar",
                        "content": "The merge_arrays method takes two arrays nums1 and nums2 as arguments and returns the merged array.\\n\\nThe method uses two indices i and j to iterate over nums1 and nums2 respectively. It also initializes two variables n and m to the sizes of the two arrays.\\n\\nThe method creates an empty array result to hold the merged array.\\n\\nThe while loop continues as long as there are elements left in either nums1 or nums2. Inside the loop, the method compares the current ids of nums1[i] and nums2[j] to determine which id should be added to the result array. If the ids are equal, the method adds the values of the two ids together.\\n\\nFinally, the method returns the merged array result.\\n\\nNote that this solution assumes that the input arrays nums1 and nums2 are sorted in ascending order by id. If the input arrays are not sorted, you can add a sorting step before the while loop."
                    },
                    {
                        "username": "khazratovi",
                        "content": "Finally!"
                    },
                    {
                        "username": "c4tdog",
                        "content": "similar to https://leetcode.com/problems/merge-similar-items/description/"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "C++ Easy and simple solution \\nMy solution Link : https://leetcode.com/problems/merge-two-2d-arrays-by-summing-values/solutions/3205386/c-easy-and-simple-solution-using-hashmap/\\nDon\\'t forgot to upvote it. "
                    }
                ]
            },
            {
                "id": 1828825,
                "content": [
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Very Easy Question \\nFirst create a HashMap and store the value of first array \\nand then Store the value of second array with condition if map does not contains key if it contains key already then store the sum of previous value plus current value .and also we count the number of key from hashMap with the loop to use one variable .\\nAfter that we create TreeMap because we want sorted key .\\nThen we create a 2D array of number of row =number of key in the hashMap which we count already and we know the number of column is always 2 \\nthen we iterate the loop on TREEMAP and store the value in our array \\nat the end we return the array .\\n\\n\\n"
                    },
                    {
                        "username": "Hakob_Saghatelyan",
                        "content": "You can solve it without using HashMap and TreeMap, better we can use only O(1) extra memory. Ids are already sorted in the arrays, so you can just use two iterators and iterate through the both arrays at the same time. On each iteration we just compare id from one array with id from the other. And depending on the result of comparison <, >, == we just add appropriate pair to the answer array. Time complexity O(n + m), extra memory O(1)"
                    },
                    {
                        "username": "potatopie",
                        "content": "2363\\tMerge Similar Items -  is exactly similar to this....."
                    },
                    {
                        "username": "pa-one55",
                        "content": "too lazy to do this.. \\uD83D\\uDE34"
                    },
                    {
                        "username": "holywatersheep",
                        "content": "bro, i just came from unique number of occurrences"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach O(N1+N2) :-\n\nInitialize two variables to store the lengths of the two arrays to be merged.\n\nCreate an empty list to store the merged arrays.\n\nUse a loop to iterate through both arrays simultaneously, comparing the first elements of each subarray and adding the smaller one to the merged list.\n\nAfter the loop, add any remaining subarrays to the merged list.\n\nReturn the merged list as a 2D array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/merge-two-2d-arrays-by-summing-values/solutions/3203787/using-merge-sort-java/"
                    },
                    {
                        "username": "yeah_boi123",
                        "content": "just iterate both the vectors from beginning by comparing their id values if same then add the values and push in ans vector and increase both i and j  and if id are different put the smaller id one and increment only that index and at end if any iterator does not reaches end complete by running while loop"
                    },
                    {
                        "username": "hannangujar",
                        "content": "The merge_arrays method takes two arrays nums1 and nums2 as arguments and returns the merged array.\\n\\nThe method uses two indices i and j to iterate over nums1 and nums2 respectively. It also initializes two variables n and m to the sizes of the two arrays.\\n\\nThe method creates an empty array result to hold the merged array.\\n\\nThe while loop continues as long as there are elements left in either nums1 or nums2. Inside the loop, the method compares the current ids of nums1[i] and nums2[j] to determine which id should be added to the result array. If the ids are equal, the method adds the values of the two ids together.\\n\\nFinally, the method returns the merged array result.\\n\\nNote that this solution assumes that the input arrays nums1 and nums2 are sorted in ascending order by id. If the input arrays are not sorted, you can add a sorting step before the while loop."
                    },
                    {
                        "username": "khazratovi",
                        "content": "Finally!"
                    },
                    {
                        "username": "c4tdog",
                        "content": "similar to https://leetcode.com/problems/merge-similar-items/description/"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "C++ Easy and simple solution \\nMy solution Link : https://leetcode.com/problems/merge-two-2d-arrays-by-summing-values/solutions/3205386/c-easy-and-simple-solution-using-hashmap/\\nDon\\'t forgot to upvote it. "
                    }
                ]
            },
            {
                "id": 1816333,
                "content": [
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Very Easy Question \\nFirst create a HashMap and store the value of first array \\nand then Store the value of second array with condition if map does not contains key if it contains key already then store the sum of previous value plus current value .and also we count the number of key from hashMap with the loop to use one variable .\\nAfter that we create TreeMap because we want sorted key .\\nThen we create a 2D array of number of row =number of key in the hashMap which we count already and we know the number of column is always 2 \\nthen we iterate the loop on TREEMAP and store the value in our array \\nat the end we return the array .\\n\\n\\n"
                    },
                    {
                        "username": "Hakob_Saghatelyan",
                        "content": "You can solve it without using HashMap and TreeMap, better we can use only O(1) extra memory. Ids are already sorted in the arrays, so you can just use two iterators and iterate through the both arrays at the same time. On each iteration we just compare id from one array with id from the other. And depending on the result of comparison <, >, == we just add appropriate pair to the answer array. Time complexity O(n + m), extra memory O(1)"
                    },
                    {
                        "username": "potatopie",
                        "content": "2363\\tMerge Similar Items -  is exactly similar to this....."
                    },
                    {
                        "username": "pa-one55",
                        "content": "too lazy to do this.. \\uD83D\\uDE34"
                    },
                    {
                        "username": "holywatersheep",
                        "content": "bro, i just came from unique number of occurrences"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach O(N1+N2) :-\n\nInitialize two variables to store the lengths of the two arrays to be merged.\n\nCreate an empty list to store the merged arrays.\n\nUse a loop to iterate through both arrays simultaneously, comparing the first elements of each subarray and adding the smaller one to the merged list.\n\nAfter the loop, add any remaining subarrays to the merged list.\n\nReturn the merged list as a 2D array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/merge-two-2d-arrays-by-summing-values/solutions/3203787/using-merge-sort-java/"
                    },
                    {
                        "username": "yeah_boi123",
                        "content": "just iterate both the vectors from beginning by comparing their id values if same then add the values and push in ans vector and increase both i and j  and if id are different put the smaller id one and increment only that index and at end if any iterator does not reaches end complete by running while loop"
                    },
                    {
                        "username": "hannangujar",
                        "content": "The merge_arrays method takes two arrays nums1 and nums2 as arguments and returns the merged array.\\n\\nThe method uses two indices i and j to iterate over nums1 and nums2 respectively. It also initializes two variables n and m to the sizes of the two arrays.\\n\\nThe method creates an empty array result to hold the merged array.\\n\\nThe while loop continues as long as there are elements left in either nums1 or nums2. Inside the loop, the method compares the current ids of nums1[i] and nums2[j] to determine which id should be added to the result array. If the ids are equal, the method adds the values of the two ids together.\\n\\nFinally, the method returns the merged array result.\\n\\nNote that this solution assumes that the input arrays nums1 and nums2 are sorted in ascending order by id. If the input arrays are not sorted, you can add a sorting step before the while loop."
                    },
                    {
                        "username": "khazratovi",
                        "content": "Finally!"
                    },
                    {
                        "username": "c4tdog",
                        "content": "similar to https://leetcode.com/problems/merge-similar-items/description/"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "C++ Easy and simple solution \\nMy solution Link : https://leetcode.com/problems/merge-two-2d-arrays-by-summing-values/solutions/3205386/c-easy-and-simple-solution-using-hashmap/\\nDon\\'t forgot to upvote it. "
                    }
                ]
            },
            {
                "id": 1810333,
                "content": [
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Very Easy Question \\nFirst create a HashMap and store the value of first array \\nand then Store the value of second array with condition if map does not contains key if it contains key already then store the sum of previous value plus current value .and also we count the number of key from hashMap with the loop to use one variable .\\nAfter that we create TreeMap because we want sorted key .\\nThen we create a 2D array of number of row =number of key in the hashMap which we count already and we know the number of column is always 2 \\nthen we iterate the loop on TREEMAP and store the value in our array \\nat the end we return the array .\\n\\n\\n"
                    },
                    {
                        "username": "Hakob_Saghatelyan",
                        "content": "You can solve it without using HashMap and TreeMap, better we can use only O(1) extra memory. Ids are already sorted in the arrays, so you can just use two iterators and iterate through the both arrays at the same time. On each iteration we just compare id from one array with id from the other. And depending on the result of comparison <, >, == we just add appropriate pair to the answer array. Time complexity O(n + m), extra memory O(1)"
                    },
                    {
                        "username": "potatopie",
                        "content": "2363\\tMerge Similar Items -  is exactly similar to this....."
                    },
                    {
                        "username": "pa-one55",
                        "content": "too lazy to do this.. \\uD83D\\uDE34"
                    },
                    {
                        "username": "holywatersheep",
                        "content": "bro, i just came from unique number of occurrences"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach O(N1+N2) :-\n\nInitialize two variables to store the lengths of the two arrays to be merged.\n\nCreate an empty list to store the merged arrays.\n\nUse a loop to iterate through both arrays simultaneously, comparing the first elements of each subarray and adding the smaller one to the merged list.\n\nAfter the loop, add any remaining subarrays to the merged list.\n\nReturn the merged list as a 2D array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/merge-two-2d-arrays-by-summing-values/solutions/3203787/using-merge-sort-java/"
                    },
                    {
                        "username": "yeah_boi123",
                        "content": "just iterate both the vectors from beginning by comparing their id values if same then add the values and push in ans vector and increase both i and j  and if id are different put the smaller id one and increment only that index and at end if any iterator does not reaches end complete by running while loop"
                    },
                    {
                        "username": "hannangujar",
                        "content": "The merge_arrays method takes two arrays nums1 and nums2 as arguments and returns the merged array.\\n\\nThe method uses two indices i and j to iterate over nums1 and nums2 respectively. It also initializes two variables n and m to the sizes of the two arrays.\\n\\nThe method creates an empty array result to hold the merged array.\\n\\nThe while loop continues as long as there are elements left in either nums1 or nums2. Inside the loop, the method compares the current ids of nums1[i] and nums2[j] to determine which id should be added to the result array. If the ids are equal, the method adds the values of the two ids together.\\n\\nFinally, the method returns the merged array result.\\n\\nNote that this solution assumes that the input arrays nums1 and nums2 are sorted in ascending order by id. If the input arrays are not sorted, you can add a sorting step before the while loop."
                    },
                    {
                        "username": "khazratovi",
                        "content": "Finally!"
                    },
                    {
                        "username": "c4tdog",
                        "content": "similar to https://leetcode.com/problems/merge-similar-items/description/"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "C++ Easy and simple solution \\nMy solution Link : https://leetcode.com/problems/merge-two-2d-arrays-by-summing-values/solutions/3205386/c-easy-and-simple-solution-using-hashmap/\\nDon\\'t forgot to upvote it. "
                    }
                ]
            },
            {
                "id": 1809619,
                "content": [
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Very Easy Question \\nFirst create a HashMap and store the value of first array \\nand then Store the value of second array with condition if map does not contains key if it contains key already then store the sum of previous value plus current value .and also we count the number of key from hashMap with the loop to use one variable .\\nAfter that we create TreeMap because we want sorted key .\\nThen we create a 2D array of number of row =number of key in the hashMap which we count already and we know the number of column is always 2 \\nthen we iterate the loop on TREEMAP and store the value in our array \\nat the end we return the array .\\n\\n\\n"
                    },
                    {
                        "username": "Hakob_Saghatelyan",
                        "content": "You can solve it without using HashMap and TreeMap, better we can use only O(1) extra memory. Ids are already sorted in the arrays, so you can just use two iterators and iterate through the both arrays at the same time. On each iteration we just compare id from one array with id from the other. And depending on the result of comparison <, >, == we just add appropriate pair to the answer array. Time complexity O(n + m), extra memory O(1)"
                    },
                    {
                        "username": "potatopie",
                        "content": "2363\\tMerge Similar Items -  is exactly similar to this....."
                    },
                    {
                        "username": "pa-one55",
                        "content": "too lazy to do this.. \\uD83D\\uDE34"
                    },
                    {
                        "username": "holywatersheep",
                        "content": "bro, i just came from unique number of occurrences"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach O(N1+N2) :-\n\nInitialize two variables to store the lengths of the two arrays to be merged.\n\nCreate an empty list to store the merged arrays.\n\nUse a loop to iterate through both arrays simultaneously, comparing the first elements of each subarray and adding the smaller one to the merged list.\n\nAfter the loop, add any remaining subarrays to the merged list.\n\nReturn the merged list as a 2D array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/merge-two-2d-arrays-by-summing-values/solutions/3203787/using-merge-sort-java/"
                    },
                    {
                        "username": "yeah_boi123",
                        "content": "just iterate both the vectors from beginning by comparing their id values if same then add the values and push in ans vector and increase both i and j  and if id are different put the smaller id one and increment only that index and at end if any iterator does not reaches end complete by running while loop"
                    },
                    {
                        "username": "hannangujar",
                        "content": "The merge_arrays method takes two arrays nums1 and nums2 as arguments and returns the merged array.\\n\\nThe method uses two indices i and j to iterate over nums1 and nums2 respectively. It also initializes two variables n and m to the sizes of the two arrays.\\n\\nThe method creates an empty array result to hold the merged array.\\n\\nThe while loop continues as long as there are elements left in either nums1 or nums2. Inside the loop, the method compares the current ids of nums1[i] and nums2[j] to determine which id should be added to the result array. If the ids are equal, the method adds the values of the two ids together.\\n\\nFinally, the method returns the merged array result.\\n\\nNote that this solution assumes that the input arrays nums1 and nums2 are sorted in ascending order by id. If the input arrays are not sorted, you can add a sorting step before the while loop."
                    },
                    {
                        "username": "khazratovi",
                        "content": "Finally!"
                    },
                    {
                        "username": "c4tdog",
                        "content": "similar to https://leetcode.com/problems/merge-similar-items/description/"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "C++ Easy and simple solution \\nMy solution Link : https://leetcode.com/problems/merge-two-2d-arrays-by-summing-values/solutions/3205386/c-easy-and-simple-solution-using-hashmap/\\nDon\\'t forgot to upvote it. "
                    }
                ]
            },
            {
                "id": 1808966,
                "content": [
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Very Easy Question \\nFirst create a HashMap and store the value of first array \\nand then Store the value of second array with condition if map does not contains key if it contains key already then store the sum of previous value plus current value .and also we count the number of key from hashMap with the loop to use one variable .\\nAfter that we create TreeMap because we want sorted key .\\nThen we create a 2D array of number of row =number of key in the hashMap which we count already and we know the number of column is always 2 \\nthen we iterate the loop on TREEMAP and store the value in our array \\nat the end we return the array .\\n\\n\\n"
                    },
                    {
                        "username": "Hakob_Saghatelyan",
                        "content": "You can solve it without using HashMap and TreeMap, better we can use only O(1) extra memory. Ids are already sorted in the arrays, so you can just use two iterators and iterate through the both arrays at the same time. On each iteration we just compare id from one array with id from the other. And depending on the result of comparison <, >, == we just add appropriate pair to the answer array. Time complexity O(n + m), extra memory O(1)"
                    },
                    {
                        "username": "potatopie",
                        "content": "2363\\tMerge Similar Items -  is exactly similar to this....."
                    },
                    {
                        "username": "pa-one55",
                        "content": "too lazy to do this.. \\uD83D\\uDE34"
                    },
                    {
                        "username": "holywatersheep",
                        "content": "bro, i just came from unique number of occurrences"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach O(N1+N2) :-\n\nInitialize two variables to store the lengths of the two arrays to be merged.\n\nCreate an empty list to store the merged arrays.\n\nUse a loop to iterate through both arrays simultaneously, comparing the first elements of each subarray and adding the smaller one to the merged list.\n\nAfter the loop, add any remaining subarrays to the merged list.\n\nReturn the merged list as a 2D array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/merge-two-2d-arrays-by-summing-values/solutions/3203787/using-merge-sort-java/"
                    },
                    {
                        "username": "yeah_boi123",
                        "content": "just iterate both the vectors from beginning by comparing their id values if same then add the values and push in ans vector and increase both i and j  and if id are different put the smaller id one and increment only that index and at end if any iterator does not reaches end complete by running while loop"
                    },
                    {
                        "username": "hannangujar",
                        "content": "The merge_arrays method takes two arrays nums1 and nums2 as arguments and returns the merged array.\\n\\nThe method uses two indices i and j to iterate over nums1 and nums2 respectively. It also initializes two variables n and m to the sizes of the two arrays.\\n\\nThe method creates an empty array result to hold the merged array.\\n\\nThe while loop continues as long as there are elements left in either nums1 or nums2. Inside the loop, the method compares the current ids of nums1[i] and nums2[j] to determine which id should be added to the result array. If the ids are equal, the method adds the values of the two ids together.\\n\\nFinally, the method returns the merged array result.\\n\\nNote that this solution assumes that the input arrays nums1 and nums2 are sorted in ascending order by id. If the input arrays are not sorted, you can add a sorting step before the while loop."
                    },
                    {
                        "username": "khazratovi",
                        "content": "Finally!"
                    },
                    {
                        "username": "c4tdog",
                        "content": "similar to https://leetcode.com/problems/merge-similar-items/description/"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "C++ Easy and simple solution \\nMy solution Link : https://leetcode.com/problems/merge-two-2d-arrays-by-summing-values/solutions/3205386/c-easy-and-simple-solution-using-hashmap/\\nDon\\'t forgot to upvote it. "
                    }
                ]
            },
            {
                "id": 1806926,
                "content": [
                    {
                        "username": "Vishal_chandravanshi",
                        "content": "Very Easy Question \\nFirst create a HashMap and store the value of first array \\nand then Store the value of second array with condition if map does not contains key if it contains key already then store the sum of previous value plus current value .and also we count the number of key from hashMap with the loop to use one variable .\\nAfter that we create TreeMap because we want sorted key .\\nThen we create a 2D array of number of row =number of key in the hashMap which we count already and we know the number of column is always 2 \\nthen we iterate the loop on TREEMAP and store the value in our array \\nat the end we return the array .\\n\\n\\n"
                    },
                    {
                        "username": "Hakob_Saghatelyan",
                        "content": "You can solve it without using HashMap and TreeMap, better we can use only O(1) extra memory. Ids are already sorted in the arrays, so you can just use two iterators and iterate through the both arrays at the same time. On each iteration we just compare id from one array with id from the other. And depending on the result of comparison <, >, == we just add appropriate pair to the answer array. Time complexity O(n + m), extra memory O(1)"
                    },
                    {
                        "username": "potatopie",
                        "content": "2363\\tMerge Similar Items -  is exactly similar to this....."
                    },
                    {
                        "username": "pa-one55",
                        "content": "too lazy to do this.. \\uD83D\\uDE34"
                    },
                    {
                        "username": "holywatersheep",
                        "content": "bro, i just came from unique number of occurrences"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach O(N1+N2) :-\n\nInitialize two variables to store the lengths of the two arrays to be merged.\n\nCreate an empty list to store the merged arrays.\n\nUse a loop to iterate through both arrays simultaneously, comparing the first elements of each subarray and adding the smaller one to the merged list.\n\nAfter the loop, add any remaining subarrays to the merged list.\n\nReturn the merged list as a 2D array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/merge-two-2d-arrays-by-summing-values/solutions/3203787/using-merge-sort-java/"
                    },
                    {
                        "username": "yeah_boi123",
                        "content": "just iterate both the vectors from beginning by comparing their id values if same then add the values and push in ans vector and increase both i and j  and if id are different put the smaller id one and increment only that index and at end if any iterator does not reaches end complete by running while loop"
                    },
                    {
                        "username": "hannangujar",
                        "content": "The merge_arrays method takes two arrays nums1 and nums2 as arguments and returns the merged array.\\n\\nThe method uses two indices i and j to iterate over nums1 and nums2 respectively. It also initializes two variables n and m to the sizes of the two arrays.\\n\\nThe method creates an empty array result to hold the merged array.\\n\\nThe while loop continues as long as there are elements left in either nums1 or nums2. Inside the loop, the method compares the current ids of nums1[i] and nums2[j] to determine which id should be added to the result array. If the ids are equal, the method adds the values of the two ids together.\\n\\nFinally, the method returns the merged array result.\\n\\nNote that this solution assumes that the input arrays nums1 and nums2 are sorted in ascending order by id. If the input arrays are not sorted, you can add a sorting step before the while loop."
                    },
                    {
                        "username": "khazratovi",
                        "content": "Finally!"
                    },
                    {
                        "username": "c4tdog",
                        "content": "similar to https://leetcode.com/problems/merge-similar-items/description/"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "C++ Easy and simple solution \\nMy solution Link : https://leetcode.com/problems/merge-two-2d-arrays-by-summing-values/solutions/3205386/c-easy-and-simple-solution-using-hashmap/\\nDon\\'t forgot to upvote it. "
                    }
                ]
            }
        ]
    }
]