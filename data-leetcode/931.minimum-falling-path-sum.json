[
    {
        "title": "Minimum Falling Path Sum",
        "question_content": "Given an n x n array of integers matrix, return the minimum sum of any falling path through matrix.\nA falling path starts at any element in the first row and chooses the element in the next row that is either directly below or diagonally left/right. Specifically, the next element from position (row, col) will be (row + 1, col - 1), (row + 1, col), or (row + 1, col + 1).\n&nbsp;\nExample 1:\n\nInput: matrix = [[2,1,3],[6,5,4],[7,8,9]]\nOutput: 13\nExplanation: There are two falling paths with a minimum sum as shown.\n\nExample 2:\n\nInput: matrix = [[-19,57],[-40,-5]]\nOutput: -59\nExplanation: The falling path with a minimum sum is shown.\n\n&nbsp;\nConstraints:\n\n\tn == matrix.length == matrix[i].length\n\t1 <= n <= 100\n\t-100 <= matrix[i][j] <= 100",
        "solutions": [
            {
                "id": 186666,
                "title": "c-java-4-lines-dp",
                "content": "The minimum path to get to element ```A[i][j]``` is the minimum of ```A[i - 1][j - 1]```, ```A[i - 1][j]``` and ```A[i - 1][j + 1]```. \\nStarting from row 1, we add the minumum path to each element. The smallest number in the last row is the miminum path sum.\\nExample:\\n[1, 2, 3]\\n[4, 5, 6] => [5, 6, 8]\\n[7, 8, 9] => [7, 8, 9] => [12, 13, 15]\\n\\n**C++**\\n```cpp\\nint minFallingPathSum(vector<vector<int>>& A) {\\n  for (auto i = 1; i < A.size(); ++i)\\n    for (auto j = 0; j < A.size(); ++j)\\n      A[i][j] += min({ A[i-1][j], A[i-1][max(0,j-1)], A[i-1][min((int)A.size()-1,j+1)] });\\n  return *min_element(begin(A[A.size() - 1]), end(A[A.size() - 1]));\\n}\\n```\\n\\n**Java**\\n```java\\npublic int minFallingPathSum(int[][] A) {\\n  for (int i = 1; i < A.length; ++i)\\n    for (int j = 0; j < A.length; ++j)\\n      A[i][j] += Math.min(A[i - 1][j], Math.min(A[i - 1][Math.max(0, j - 1)], A[i - 1][Math.min(A.length - 1, j + 1)]));\\n  return Arrays.stream(A[A.length - 1]).min().getAsInt();\\n}        \\n```",
                "solutionTags": [],
                "code": "```A[i][j]```\n```A[i - 1][j - 1]```\n```A[i - 1][j]```\n```A[i - 1][j + 1]```\n```cpp\\nint minFallingPathSum(vector<vector<int>>& A) {\\n  for (auto i = 1; i < A.size(); ++i)\\n    for (auto j = 0; j < A.size(); ++j)\\n      A[i][j] += min({ A[i-1][j], A[i-1][max(0,j-1)], A[i-1][min((int)A.size()-1,j+1)] });\\n  return *min_element(begin(A[A.size() - 1]), end(A[A.size() - 1]));\\n}\\n```\n```java\\npublic int minFallingPathSum(int[][] A) {\\n  for (int i = 1; i < A.length; ++i)\\n    for (int j = 0; j < A.length; ++j)\\n      A[i][j] += Math.min(A[i - 1][j], Math.min(A[i - 1][Math.max(0, j - 1)], A[i - 1][Math.min(A.length - 1, j + 1)]));\\n  return Arrays.stream(A[A.length - 1]).min().getAsInt();\\n}        \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 186689,
                "title": "java-dp-solution-with-graph-illustrated-explanations",
                "content": "The solution is definitely not optimal, nor is the code as \"elegant\", but the idea is straght forward, hope it helps :)\n\nGiven matrix like the left part in the graph below, we first initialize a 2D DP matrix, and then iterate the original matrix row by row. For each element in DP matrix, we sum up the **corresponding element from original matrix** with the **minimum neighbors from previous row in DP matrix**. \nIn order to save the future hassles dealing with index boundries while iterating the matrix, I added the **two extra columns** and assigned them as `Integer.MAX_VALUE`.\n\nThe idea is illustrated as following:\n![image](https://assets.leetcode.com/users/yfgu0618/image_1540698728.png)\n\nFollowing is the code:\n```java\npublic static int minFallingPathSum(int[][] A) {\n  int rows = A.length;\n  int cols = A[0].length;\n  // DP matrix has 2 extra columns\n  int[][] dp = new int[rows][cols + 2];\n  // Fill the first row of DP matrix\n  for (int i = 1; i <= cols; i++) {\n    dp[0][i] = A[0][i - 1];\n  }\n  // Fill Integer.MAX_VALUE into first and last column of DP matrix\n  for (int i = 0; i < rows; i++) {\n    dp[i][0] = Integer.MAX_VALUE;\n    dp[i][cols + 1] = Integer.MAX_VALUE;\n  }\n  // Building the DP matrix\n  for (int i = 1; i < rows; i++) {\n    for (int j = 1; j <= cols; j++) {\n      // Find the minimum neighbor from previous row in DP matrix\n      int minNeighbor = Math.min(dp[i - 1][j - 1], dp[i - 1][j]);\n      minNeighbor = Math.min(minNeighbor, dp[i - 1][j + 1]);\n      dp[i][j] = A[i][j - 1] + minNeighbor;\n    }\n  }\n  // The minimum path sum is minimum of the last row in DP matrix\n  int min = Integer.MAX_VALUE;\n  for (int i = 1; i <= cols; i++) {\n    min = Math.min(min, dp[rows - 1][i]);\n  }\n  return min;\n}\n```\n",
                "solutionTags": [],
                "code": "```java\npublic static int minFallingPathSum(int[][] A) {\n  int rows = A.length;\n  int cols = A[0].length;\n  // DP matrix has 2 extra columns\n  int[][] dp = new int[rows][cols + 2];\n  // Fill the first row of DP matrix\n  for (int i = 1; i <= cols; i++) {\n    dp[0][i] = A[0][i - 1];\n  }\n  // Fill Integer.MAX_VALUE into first and last column of DP matrix\n  for (int i = 0; i < rows; i++) {\n    dp[i][0] = Integer.MAX_VALUE;\n    dp[i][cols + 1] = Integer.MAX_VALUE;\n  }\n  // Building the DP matrix\n  for (int i = 1; i < rows; i++) {\n    for (int j = 1; j <= cols; j++) {\n      // Find the minimum neighbor from previous row in DP matrix\n      int minNeighbor = Math.min(dp[i - 1][j - 1], dp[i - 1][j]);\n      minNeighbor = Math.min(minNeighbor, dp[i - 1][j + 1]);\n      dp[i][j] = A[i][j - 1] + minNeighbor;\n    }\n  }\n  // The minimum path sum is minimum of the last row in DP matrix\n  int min = Integer.MAX_VALUE;\n  for (int i = 1; i <= cols; i++) {\n    min = Math.min(min, dp[rows - 1][i]);\n  }\n  return min;\n}\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 381898,
                "title": "python-not-shortest-but-easiest-to-understand-with-explanation",
                "content": "\\nTried to give a decent explanation of how to look at problem. Let me know if there is anything that is hard to understand.\\n    \\n    #this problem will use DP \\n    #by taking the minimum value from itself plus one of the 3 values right above it\\n\\n    #EX: \\n    # 1  2  3   \\n    # 4  5  6  \\n    # 7  8  9 \\n\\n    # new value for number at A[1][1] will be  min(5 + 1, 5 + 2, 5 + 3)\\n    # therefore it will be 5 + 1 = 6, and 6 will then replace the value at A[1][1]\\n\\n    #new value for number at A[1][0] will be  min(4 + 1, 4 + 2) = 5\\n    #it will only have two values to compare since there is no upper left value\\n\\n    #new value for number at A[1][2] will be  min(6 + 2, 6 + 3) = 8\\n    #it will only have two values to compare since there is no upper right value\\n    \\n    def minFallingPathSum(self, A: List[List[int]]) -> int:\\n        for i in range(1,len(A)):\\n            for j in range(len(A[0])):\\n\\t\\t\\t\\n                #edge cases are first column and last column which only have two paths from above\\n                if j == 0:\\n                    A[i][j]  = min((A[i][j] + A[i - 1][j]), (A[i][j] + A[i - 1][j + 1]) )\\n\\t\\t\\t\\t\\t\\n                elif (j == len(A[0]) - 1):\\n                    A[i][j]  = min((A[i][j] + A[i - 1][j]), (A[i][j] + A[i - 1][j - 1]) )\\n\\t\\t\\t\\t\\t\\n                #every other column will have three paths coming from above\\n                else:\\n                    A[i][j] = min(A[i][j] + A[i - 1][j],A[i][j] + A[i - 1][j + 1], A[i][j] + A[i - 1][j - 1])\\n            \\n\\t\\t# Now that minimum falling sums for each value at the bottom row have been computer\\n\\t\\t# We can just take the min of the bottow row to get the smallest overall path sum \\n        return min(A[len(A) - 1])\\n",
                "solutionTags": [],
                "code": "\\nTried to give a decent explanation of how to look at problem. Let me know if there is anything that is hard to understand.\\n    \\n    #this problem will use DP \\n    #by taking the minimum value from itself plus one of the 3 values right above it\\n\\n    #EX: \\n    # 1  2  3   \\n    # 4  5  6  \\n    # 7  8  9 \\n\\n    # new value for number at A[1][1] will be  min(5 + 1, 5 + 2, 5 + 3)\\n    # therefore it will be 5 + 1 = 6, and 6 will then replace the value at A[1][1]\\n\\n    #new value for number at A[1][0] will be  min(4 + 1, 4 + 2) = 5\\n    #it will only have two values to compare since there is no upper left value\\n\\n    #new value for number at A[1][2] will be  min(6 + 2, 6 + 3) = 8\\n    #it will only have two values to compare since there is no upper right value\\n    \\n    def minFallingPathSum(self, A: List[List[int]]) -> int:\\n        for i in range(1,len(A)):\\n            for j in range(len(A[0])):\\n\\t\\t\\t\\n                #edge cases are first column and last column which only have two paths from above\\n                if j == 0:\\n                    A[i][j]  = min((A[i][j] + A[i - 1][j]), (A[i][j] + A[i - 1][j + 1]) )\\n\\t\\t\\t\\t\\t\\n                elif (j == len(A[0]) - 1):\\n                    A[i][j]  = min((A[i][j] + A[i - 1][j]), (A[i][j] + A[i - 1][j - 1]) )\\n\\t\\t\\t\\t\\t\\n                #every other column will have three paths coming from above\\n                else:\\n                    A[i][j] = min(A[i][j] + A[i - 1][j],A[i][j] + A[i - 1][j + 1], A[i][j] + A[i - 1][j - 1])\\n            \\n\\t\\t# Now that minimum falling sums for each value at the bottom row have been computer\\n\\t\\t# We can just take the min of the bottow row to get the smallest overall path sum \\n        return min(A[len(A) - 1])\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1191340,
                "title": "c-4-solutions-from-bruteforce-to-dp-with-explainations",
                "content": "Let\\'s start from the brute force, a good way is to think is a recursive fashion which helps to understand the base cases and how to implement the iterative one.\\n\\nIf we start from the row 1 in the matrix we need to pick for every position of the matrix the min value between:\\n- Matrix[r-1][c-1] + matrix[r][c] which means we have reach pos [r][c] from left\\n- Matrix[r-1][c+1] + matrix[r][c] which means we have reach pos [r][c] from right\\n- Matrix[r-1][c] + matrix[r][c] which means we have reach pos [r][c] from the middle\\n\\nBetween these we need to pick the minimum, paying attention to the matrix indexes (Don\\'t get out of boundaries) which reppresent a base case for the recursive calls.\\nThe other base case is when we reach the end so r = 0 in the case of the brute force.\\n\\nAfter having calculate the minimum value that lead to all the positions matrix[rows-1][c] we can just iterate through those values and take the max.\\n\\nHere is the brute force using recursion.\\n```\\n//Brute force TLE\\nclass Solution {\\npublic:\\n        int minFallingPathSumHelper(vector<vector<int>>& matrix, int r, int c){\\n        if(r == 0 and c < matrix[0].size() and c >= 0) return matrix[r][c]; \\n        if(c >= matrix[0].size() or c < 0) return INT_MAX;\\n        \\n        return matrix[r][c] + min(min(minFallingPathSumHelper(matrix, r-1, c+1), minFallingPathSumHelper(matrix, r-1, c)), minFallingPathSumHelper(matrix, r-1, c-1));\\n        \\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int rows = matrix.size(), cols = matrix[0].size();\\n        int ans = INT_MAX;\\n        for(int c=0; c < cols; c++){\\n            ans = min(ans, minFallingPathSumHelper(matrix, rows-1, c));\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nSomething you can note is that we are reapeting a bunch of calls, we can optimize using a memo that keeps the values for the position which are already calculated. We just need to initialize the memo with a value, INT_MAX since we can have also negative numbers. And if we haven\\'t calculated the value yet we do recursion as in the bruteforce otherwise we hit the cache.\\n\\n```\\n//Top-down Recursive with memo\\nclass Solution {\\npublic:\\n    int minFallingPathSumHelper(vector<vector<int>>& matrix, int r, int c, vector<vector<int>>& dp){\\n        if(r == 0 and c < matrix[0].size() and c >= 0) return matrix[r][c]; \\n        if(c >= matrix[0].size() or c < 0) return INT_MAX;\\n        \\n        if(dp[r][c] != INT_MAX) return dp[r][c];\\n        return dp[r][c] = matrix[r][c] + min(min(minFallingPathSumHelper(matrix, r-1, c+1, dp), minFallingPathSumHelper(matrix, r-1, c, dp)), minFallingPathSumHelper(matrix, r-1, c-1, dp));\\n        \\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int rows = matrix.size(), cols = matrix[0].size();\\n        vector<vector<int>> dp(rows+1, vector<int>(cols+1, INT_MAX));\\n        int ans = INT_MAX;\\n        for(int c=0; c < cols; c++){\\n            ans = min(ans, minFallingPathSumHelper(matrix, rows-1, c, dp));\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nAs I was saying before you can rethink the logic in the opposite way in a bottom-up fashion:\\n```\\n //Bottom-up Recursive with memo\\nclass Solution {\\npublic:\\n    int minFallingPathSumHelper(vector<vector<int>>& matrix, int r, int c, vector<vector<int>>& dp){\\n        if(r == matrix.size()-1 and c < matrix[0].size() and c >= 0) return matrix[r][c]; \\n        if(c >= matrix[0].size() or c < 0) return INT_MAX;\\n        \\n        if(dp[r][c] != INT_MAX) return dp[r][c];\\n        return dp[r][c] = matrix[r][c] + min(min(minFallingPathSumHelper(matrix, r+1, c-1, dp), minFallingPathSumHelper(matrix, r+1, c, dp)), minFallingPathSumHelper(matrix, r+1, c+1, dp));\\n        \\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int rows = matrix.size(), cols = matrix[0].size();\\n        vector<vector<int>> dp(rows+1, vector<int>(cols+1, INT_MAX));\\n        int ans = INT_MAX;\\n        for(int c=0; c < cols; c++){\\n            ans = min(ans, minFallingPathSumHelper(matrix, 0, c, dp));\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nThe last two solutions make use of a memo called dp which store preview calculation + occupies space with the recursive calls. So we can say that it takes O(mn) time and O(mn) extra space.\\n\\n\\nAnother approach could be (in the case you\\'re allowed to modify the input to store directly the calculation of the minimum path until that position directly in the matrix. This would need O(mn) time and O(1) extra space.\\nThe following solution can be adapted using a copy of the matrix to not modify the input using O(mn) space.\\n\\n```\\n//Iterative bottom-up solution\\nclass Solution {\\npublic:\\n    int customMin(int a, int b, int c){\\n        return min(a,min(b,c));\\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int rows = matrix.size(), cols = matrix[0].size();\\n        int ans = INT_MAX;\\n        \\n        for(int r=1; r < rows; r++){\\n            for(int c=0; c < cols; c++){\\n                int leftD, middle, rightD;               \\n                if(c == 0){\\n                    rightD = matrix[r-1][c+1];\\n                    middle = matrix[r-1][c];\\n                    matrix[r][c] += min(rightD, middle);\\n                }else if(c == cols-1){\\n                    leftD = matrix[r-1][c-1];\\n                    middle = matrix[r-1][c];\\n                    matrix[r][c] += min(leftD, middle);\\n                }else{\\n                    leftD = matrix[r-1][c+1];\\n                    middle = matrix[r-1][c];\\n                    rightD = matrix[r-1][c-1];\\n                    matrix[r][c] += customMin(leftD, rightD, middle);\\n                } \\n            }\\n        }\\n        for(int c=0; c < cols; c++){\\n            ans = min(ans, matrix[rows-1][c]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nIn general iterative is harder to think but it\\'s almost always better.\\n\\nUpvote if you found this useful and check out my twitch channel.\\n\\n\\n    \\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Iterator"
                ],
                "code": "```\\n//Brute force TLE\\nclass Solution {\\npublic:\\n        int minFallingPathSumHelper(vector<vector<int>>& matrix, int r, int c){\\n        if(r == 0 and c < matrix[0].size() and c >= 0) return matrix[r][c]; \\n        if(c >= matrix[0].size() or c < 0) return INT_MAX;\\n        \\n        return matrix[r][c] + min(min(minFallingPathSumHelper(matrix, r-1, c+1), minFallingPathSumHelper(matrix, r-1, c)), minFallingPathSumHelper(matrix, r-1, c-1));\\n        \\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int rows = matrix.size(), cols = matrix[0].size();\\n        int ans = INT_MAX;\\n        for(int c=0; c < cols; c++){\\n            ans = min(ans, minFallingPathSumHelper(matrix, rows-1, c));\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n//Top-down Recursive with memo\\nclass Solution {\\npublic:\\n    int minFallingPathSumHelper(vector<vector<int>>& matrix, int r, int c, vector<vector<int>>& dp){\\n        if(r == 0 and c < matrix[0].size() and c >= 0) return matrix[r][c]; \\n        if(c >= matrix[0].size() or c < 0) return INT_MAX;\\n        \\n        if(dp[r][c] != INT_MAX) return dp[r][c];\\n        return dp[r][c] = matrix[r][c] + min(min(minFallingPathSumHelper(matrix, r-1, c+1, dp), minFallingPathSumHelper(matrix, r-1, c, dp)), minFallingPathSumHelper(matrix, r-1, c-1, dp));\\n        \\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int rows = matrix.size(), cols = matrix[0].size();\\n        vector<vector<int>> dp(rows+1, vector<int>(cols+1, INT_MAX));\\n        int ans = INT_MAX;\\n        for(int c=0; c < cols; c++){\\n            ans = min(ans, minFallingPathSumHelper(matrix, rows-1, c, dp));\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n //Bottom-up Recursive with memo\\nclass Solution {\\npublic:\\n    int minFallingPathSumHelper(vector<vector<int>>& matrix, int r, int c, vector<vector<int>>& dp){\\n        if(r == matrix.size()-1 and c < matrix[0].size() and c >= 0) return matrix[r][c]; \\n        if(c >= matrix[0].size() or c < 0) return INT_MAX;\\n        \\n        if(dp[r][c] != INT_MAX) return dp[r][c];\\n        return dp[r][c] = matrix[r][c] + min(min(minFallingPathSumHelper(matrix, r+1, c-1, dp), minFallingPathSumHelper(matrix, r+1, c, dp)), minFallingPathSumHelper(matrix, r+1, c+1, dp));\\n        \\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int rows = matrix.size(), cols = matrix[0].size();\\n        vector<vector<int>> dp(rows+1, vector<int>(cols+1, INT_MAX));\\n        int ans = INT_MAX;\\n        for(int c=0; c < cols; c++){\\n            ans = min(ans, minFallingPathSumHelper(matrix, 0, c, dp));\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n//Iterative bottom-up solution\\nclass Solution {\\npublic:\\n    int customMin(int a, int b, int c){\\n        return min(a,min(b,c));\\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int rows = matrix.size(), cols = matrix[0].size();\\n        int ans = INT_MAX;\\n        \\n        for(int r=1; r < rows; r++){\\n            for(int c=0; c < cols; c++){\\n                int leftD, middle, rightD;               \\n                if(c == 0){\\n                    rightD = matrix[r-1][c+1];\\n                    middle = matrix[r-1][c];\\n                    matrix[r][c] += min(rightD, middle);\\n                }else if(c == cols-1){\\n                    leftD = matrix[r-1][c-1];\\n                    middle = matrix[r-1][c];\\n                    matrix[r][c] += min(leftD, middle);\\n                }else{\\n                    leftD = matrix[r-1][c+1];\\n                    middle = matrix[r-1][c];\\n                    rightD = matrix[r-1][c-1];\\n                    matrix[r][c] += customMin(leftD, rightD, middle);\\n                } \\n            }\\n        }\\n        for(int c=0; c < cols; c++){\\n            ans = min(ans, matrix[rows-1][c]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 776004,
                "title": "easy-java-solution-using-dp",
                "content": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] A) {\\n        int dp[][] = new int[A.length][A.length];\\n        int min = Integer.MAX_VALUE;\\n        for(int i = 0; i < A.length; i++)\\n        {\\n            dp[0][i] = A[0][i];\\n        }\\n        for(int i = 1; i < A.length; i++)\\n        {\\n            for(int j = 0; j < A.length; j++)\\n            {\\n                if(j == 0)\\n                {\\n                    dp[i][j] = A[i][j] + Math.min(dp[i-1][j], dp[i-1][j+1]);\\n                }\\n                else if(j == A.length - 1)\\n                {\\n                    dp[i][j] = A[i][j] + Math.min(dp[i-1][j-1], dp[i-1][j]);\\n                }\\n                else\\n                {\\n                    dp[i][j] = A[i][j] + Math.min(Math.min(dp[i-1][j-1], dp[i-1][j]), dp[i-1][j+1]);\\n                }\\n            }\\n        }\\n        for(int i = 0; i < A.length; i++)\\n        {\\n            if(dp[A.length-1][i] < min)  min = dp[A.length-1][i];\\n        }\\n        return min;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public int minFallingPathSum(int[][] A) {\\n        int dp[][] = new int[A.length][A.length];\\n        int min = Integer.MAX_VALUE;\\n        for(int i = 0; i < A.length; i++)\\n        {\\n            dp[0][i] = A[0][i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1369046,
                "title": "python-explanation-visuals-5-approaches-dp-dfs-w-memo-dfs-iterative",
                "content": "**Idea:**\\n- The problem is very simialr to **64. Minimum Path Sum** with minor tweaks:\\n\\t- multipe (starting nodes/ roots) instead of a single root\\n\\t- multiple (targets/ leaves) instead of just one\\n\\t- The allowed movement are : \\n\\t\\t- down and to the right\\n\\t\\t- down and to the left\\n\\t\\t- down\\n\\n- This problem fits the min/max pattern which can be solved via these methods:\\n\\n**1. Dfs**\\n\\t\\t- recursive with global memo\\n\\t\\t- recursive with local memo\\n\\t\\t- iterative \\n\\n**2. Dynamic programming**\\n\\n\\n\\n\\n----------------------------------------------------\\n[1] - Bottom up - DP | 120 ms, faster than 63.67% of Python3\\n----------------------------------------------------\\n----------------------------------------------------\\n![image](https://assets.leetcode.com/users/images/54836d22-edf2-42f6-bf34-0c264bf911d0_1627501376.4721816.jpeg)\\n\\n```\\ndef minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n\\tgrid = matrix\\n\\tfor i in range(1, len(grid)):\\n\\t\\tfor j in range(len(grid[i])):\\n\\n\\t\\t\\t# [1] up-left\\n\\t\\t\\tif i-1 >= 0 and j-1 >= 0:\\n\\t\\t\\t\\tp1 = grid[i-1][j-1]\\n\\t\\t\\telse:\\n\\t\\t\\t\\tp1 = float(\\'inf\\')\\n\\n\\t\\t\\t# [2] up-same\\n\\t\\t\\tif i-1 >= 0:\\n\\t\\t\\t\\tp2 = grid[i-1][j]\\n\\t\\t\\telse:\\n\\t\\t\\t\\tp2 = float(\\'inf\\')\\n\\n\\t\\t\\t# [3] up-right\\n\\t\\t\\tif i-1 >= 0 and j+1 <= len(grid[0])-1:\\n\\t\\t\\t\\tp3 = grid[i-1][j+1]\\n\\t\\t\\telse:\\n\\t\\t\\t\\tp3 = float(\\'inf\\')\\n\\n\\t\\t\\tgrid[i][j] += min(p1,p2,p3)\\n\\n\\treturn min(grid[len(grid)-1])\\n```\\n----------------------------------------------------\\n[2] Brute force DFS iterative - with no visited set | SLOW | TLE 38 / 48 test cases passed.\\n----------------------------------------------------\\n----------------------------------------------------\\n\\n- For the DFS solution, we have to invoke it multiple times (once for each root/DAG separately)\\n\\n```\\ndef minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n\\t# helper\\n\\tdef dfs(x,y):\\n\\t\\tstack = [((x,y), grid[x][y])]\\n\\t\\tdirs = [(1,0), (1,1), (1,-1)]\\n\\t\\tm, n = len(grid)-1, len(grid[0])-1\\n\\t\\tlocalMinSum = float(\\'inf\\')\\n\\t\\twhile stack:\\n\\t\\t\\t(x,y), pathSum = stack.pop()\\n\\t\\t\\t# print((x,y), pathSum)\\n\\t\\t\\tif x == m:\\n\\t\\t\\t\\tlocalMinSum = min(localMinSum, pathSum)\\n\\t\\t\\tfor dir in dirs:\\n\\t\\t\\t\\tnewX, newY = x+dir[0], y+dir[1]\\n\\t\\t\\t\\tif newX >= 0 and newX <= m and newY >= 0 and newY <= n:\\n\\t\\t\\t\\t\\tstack.append(((newX, newY), pathSum+grid[newX][newY]))\\n\\t\\treturn localMinSum\\n\\n\\n\\t# main\\n\\tgrid = matrix\\n\\troots = grid[0]\\n\\tminPath = float(\\'inf\\')\\n\\tfor i in range(len(roots)):\\n\\t\\tminPath = min(dfs(0,i), minPath)\\n\\treturn minPath\\n```\\n----------------------------------------------------\\n[3] - Recursive DFS with memo\\n\\t- with local memo for each DAG separate | 4908 ms faster than 5.22% of Python3\\n----------------------------------------------------\\n----------------------------------------------------\\n\\n- For the DFS solution, we have to invoke it multiple times (once for each root/DAG separately)\\n![image](https://assets.leetcode.com/users/images/f1ee79d7-ddfe-4085-8f1e-2ec318261a20_1627502368.368746.jpeg)\\n\\n- Initially, I though I should also use a separate memo dict to memoize each root/DAG separately as you can see below. See **approach [4]** for more details.\\n\\n```        \\ndef minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n\\t# helper\\n\\tdef recurse(i,j, memo):\\n\\n\\t\\tif i < 0 or j < 0 or i > m-1 or j > n-1:\\n\\t\\t\\treturn float(\\'inf\\')\\n\\t\\tif i == m-1: # last row reached - does not make sense to memoize here\\n\\t\\t\\treturn grid[i][j]\\n\\t\\tif (i,j) in memo:\\n\\t\\t\\treturn memo[(i,j)]\\n\\t\\tresult = grid[i][j] + min(recurse(i+1, j, memo), recurse(i+1, j+1, memo), recurse(i+1, j-1, memo)) # - NOTE [1]\\n\\t\\tmemo[(i,j)] = result\\n\\t\\treturn result\\n\\n\\t# main\\n\\tgrid = matrix\\n\\tm, n = len(grid), len(grid[0])\\n\\tminFallPath = float(\\'inf\\')\\n\\tfor i in range(len(grid[0])):\\n\\t\\tminFallPath = min(minFallPath, recurse(0, i, {}))\\n\\treturn minFallPath\\n\\n\\t# - NOTE [1]\\n\\t# ----------\\n\\t# Treat every node in the zeroth row as a separate root/DAG with its own memoization\\n\\t# Memoization is possible when we have a single starting point that branches out\\n\\n\\t# Behavior of memo for each DAG separately for the ex: matrix = [[2,1,3],[6,5,4],[7,8,9]]\\n\\t# ------ new DAG -----\\n\\t# memo =  {(1, 0): 13}\\n\\t# memo =  {(1, 0): 13, (1, 1): 12}\\n\\t# memo =  {(1, 0): 13, (1, 1): 12, (0, 0): 14}\\n\\t#  ------ new DAG -----\\n\\t# memo =  {(1, 1): 12}\\n\\t# memo =  {(1, 1): 12, (1, 2): 12}\\n\\t# memo =  {(1, 1): 12, (1, 2): 12, (1, 0): 13}\\n\\t# memo =  {(1, 1): 12, (1, 2): 12, (1, 0): 13, (0, 1): 13}\\n\\t#  ------ new DAG -----\\n\\t# memo =  {(1, 2): 12}\\n\\t# memo =  {(1, 2): 12, (1, 1): 12}\\n\\t# memo =  {(1, 2): 12, (1, 1): 12, (0, 2): 15}\\n```\\n        \\n----------------------------------------------------\\n\\n[4] - Recursive DFS with memo\\n\\t- with global memo for the entire grid | 160 ms faster than 27.15% Python3\\n----------------------------------------------------\\n----------------------------------------------------\\n- Here, I am using a global memo for the entire grid\\n- This obviosuly reduces the runtime significalty\\n- **Why shoud we use global memoization?**\\n\\t- ![image](https://assets.leetcode.com/users/images/29702449-9697-4236-9890-784b62088ad3_1627502479.2262669.jpeg)\\n\\n\\t- It makes sense to use a global memo, because once memoized, a node (or a key) in the memo dict does not change its value. That is because the memoized value is determined based on the children of that node/key, and that is never going to change.\\n\\n\\t- So when the same node is viisted again via a different root (starting point), its value has already been memoized and we don\\'t have to go down the rabbit hole once again (don\\'t have to recurse to the bottom of the grid again)\\n \\n\\n```\\ndef minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n\\t# helper\\n\\tdef recurse(i,j):\\n\\n\\t\\tif i < 0 or j < 0 or i > m-1 or j > n-1:\\n\\t\\t\\treturn float(\\'inf\\')\\n\\t\\tif i == m-1: # last row reached - does not make sense to memoize here\\n\\t\\t\\treturn grid[i][j]\\n\\t\\tif (i,j) in memo:\\n\\t\\t\\treturn memo[(i,j)]\\n\\t\\tresult = grid[i][j] + min(recurse(i+1, j), recurse(i+1, j+1), recurse(i+1, j-1)) # - NOTE [1]\\n\\t\\tmemo[(i,j)] = result\\n\\t\\tprint(\\'memo = \\', memo)\\n\\t\\treturn result\\n\\n\\t# main\\n\\tgrid = matrix\\n\\tm, n = len(grid), len(grid[0])\\n\\tminFallPath = float(\\'inf\\')\\n\\tmemo = {}\\n\\tfor i in range(len(grid[0])):\\n\\t\\tprint(\\' ------ new DAG -----\\')\\n\\t\\tminFallPath = min(minFallPath, recurse(0, i))\\n\\treturn minFallPath\\n ```   \\n----------------------------------------------------\\n[5] - Recursive DFS with memo\\n\\t- without memo | TLE 38 / 48 test cases passed.\\n----------------------------------------------------\\n----------------------------------------------------\\n```        \\ndef minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n\\t# helper\\n\\tdef recurse(i,j):\\n\\t\\tif i < 0 or j < 0 or i > m-1 or j > n-1:\\n\\t\\t\\treturn float(\\'inf\\')\\n\\t\\tif i == m-1: # last row reached\\n\\t\\t\\treturn grid[i][j]\\n\\t\\tresult = grid[i][j] + min(recurse(i+1, j), recurse(i+1, j+1), recurse(i+1, j-1))\\n\\t\\t# memo[(i,j)] = result\\n\\t\\treturn result\\n\\n\\t# main\\n\\tgrid = matrix\\n\\tm, n = len(grid), len(grid[0])\\n\\tminFallPath = float(\\'inf\\')\\n\\tfor i in range(len(grid[0])):\\n\\t\\tminFallPath = min(minFallPath, recurse(0, i))\\n\\treturn minFallPath\\n```        \\n        \\n        \\n        \\n    \\n        \\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization",
                    "Iterator"
                ],
                "code": "```\\ndef minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n\\tgrid = matrix\\n\\tfor i in range(1, len(grid)):\\n\\t\\tfor j in range(len(grid[i])):\\n\\n\\t\\t\\t# [1] up-left\\n\\t\\t\\tif i-1 >= 0 and j-1 >= 0:\\n\\t\\t\\t\\tp1 = grid[i-1][j-1]\\n\\t\\t\\telse:\\n\\t\\t\\t\\tp1 = float(\\'inf\\')\\n\\n\\t\\t\\t# [2] up-same\\n\\t\\t\\tif i-1 >= 0:\\n\\t\\t\\t\\tp2 = grid[i-1][j]\\n\\t\\t\\telse:\\n\\t\\t\\t\\tp2 = float(\\'inf\\')\\n\\n\\t\\t\\t# [3] up-right\\n\\t\\t\\tif i-1 >= 0 and j+1 <= len(grid[0])-1:\\n\\t\\t\\t\\tp3 = grid[i-1][j+1]\\n\\t\\t\\telse:\\n\\t\\t\\t\\tp3 = float(\\'inf\\')\\n\\n\\t\\t\\tgrid[i][j] += min(p1,p2,p3)\\n\\n\\treturn min(grid[len(grid)-1])\\n```\n```\\ndef minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n\\t# helper\\n\\tdef dfs(x,y):\\n\\t\\tstack = [((x,y), grid[x][y])]\\n\\t\\tdirs = [(1,0), (1,1), (1,-1)]\\n\\t\\tm, n = len(grid)-1, len(grid[0])-1\\n\\t\\tlocalMinSum = float(\\'inf\\')\\n\\t\\twhile stack:\\n\\t\\t\\t(x,y), pathSum = stack.pop()\\n\\t\\t\\t# print((x,y), pathSum)\\n\\t\\t\\tif x == m:\\n\\t\\t\\t\\tlocalMinSum = min(localMinSum, pathSum)\\n\\t\\t\\tfor dir in dirs:\\n\\t\\t\\t\\tnewX, newY = x+dir[0], y+dir[1]\\n\\t\\t\\t\\tif newX >= 0 and newX <= m and newY >= 0 and newY <= n:\\n\\t\\t\\t\\t\\tstack.append(((newX, newY), pathSum+grid[newX][newY]))\\n\\t\\treturn localMinSum\\n\\n\\n\\t# main\\n\\tgrid = matrix\\n\\troots = grid[0]\\n\\tminPath = float(\\'inf\\')\\n\\tfor i in range(len(roots)):\\n\\t\\tminPath = min(dfs(0,i), minPath)\\n\\treturn minPath\\n```\n```        \\ndef minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n\\t# helper\\n\\tdef recurse(i,j, memo):\\n\\n\\t\\tif i < 0 or j < 0 or i > m-1 or j > n-1:\\n\\t\\t\\treturn float(\\'inf\\')\\n\\t\\tif i == m-1: # last row reached - does not make sense to memoize here\\n\\t\\t\\treturn grid[i][j]\\n\\t\\tif (i,j) in memo:\\n\\t\\t\\treturn memo[(i,j)]\\n\\t\\tresult = grid[i][j] + min(recurse(i+1, j, memo), recurse(i+1, j+1, memo), recurse(i+1, j-1, memo)) # - NOTE [1]\\n\\t\\tmemo[(i,j)] = result\\n\\t\\treturn result\\n\\n\\t# main\\n\\tgrid = matrix\\n\\tm, n = len(grid), len(grid[0])\\n\\tminFallPath = float(\\'inf\\')\\n\\tfor i in range(len(grid[0])):\\n\\t\\tminFallPath = min(minFallPath, recurse(0, i, {}))\\n\\treturn minFallPath\\n\\n\\t# - NOTE [1]\\n\\t# ----------\\n\\t# Treat every node in the zeroth row as a separate root/DAG with its own memoization\\n\\t# Memoization is possible when we have a single starting point that branches out\\n\\n\\t# Behavior of memo for each DAG separately for the ex: matrix = [[2,1,3],[6,5,4],[7,8,9]]\\n\\t# ------ new DAG -----\\n\\t# memo =  {(1, 0): 13}\\n\\t# memo =  {(1, 0): 13, (1, 1): 12}\\n\\t# memo =  {(1, 0): 13, (1, 1): 12, (0, 0): 14}\\n\\t#  ------ new DAG -----\\n\\t# memo =  {(1, 1): 12}\\n\\t# memo =  {(1, 1): 12, (1, 2): 12}\\n\\t# memo =  {(1, 1): 12, (1, 2): 12, (1, 0): 13}\\n\\t# memo =  {(1, 1): 12, (1, 2): 12, (1, 0): 13, (0, 1): 13}\\n\\t#  ------ new DAG -----\\n\\t# memo =  {(1, 2): 12}\\n\\t# memo =  {(1, 2): 12, (1, 1): 12}\\n\\t# memo =  {(1, 2): 12, (1, 1): 12, (0, 2): 15}\\n```\n```\\ndef minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n\\t# helper\\n\\tdef recurse(i,j):\\n\\n\\t\\tif i < 0 or j < 0 or i > m-1 or j > n-1:\\n\\t\\t\\treturn float(\\'inf\\')\\n\\t\\tif i == m-1: # last row reached - does not make sense to memoize here\\n\\t\\t\\treturn grid[i][j]\\n\\t\\tif (i,j) in memo:\\n\\t\\t\\treturn memo[(i,j)]\\n\\t\\tresult = grid[i][j] + min(recurse(i+1, j), recurse(i+1, j+1), recurse(i+1, j-1)) # - NOTE [1]\\n\\t\\tmemo[(i,j)] = result\\n\\t\\tprint(\\'memo = \\', memo)\\n\\t\\treturn result\\n\\n\\t# main\\n\\tgrid = matrix\\n\\tm, n = len(grid), len(grid[0])\\n\\tminFallPath = float(\\'inf\\')\\n\\tmemo = {}\\n\\tfor i in range(len(grid[0])):\\n\\t\\tprint(\\' ------ new DAG -----\\')\\n\\t\\tminFallPath = min(minFallPath, recurse(0, i))\\n\\treturn minFallPath\\n ```\n```        \\ndef minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n\\t# helper\\n\\tdef recurse(i,j):\\n\\t\\tif i < 0 or j < 0 or i > m-1 or j > n-1:\\n\\t\\t\\treturn float(\\'inf\\')\\n\\t\\tif i == m-1: # last row reached\\n\\t\\t\\treturn grid[i][j]\\n\\t\\tresult = grid[i][j] + min(recurse(i+1, j), recurse(i+1, j+1), recurse(i+1, j-1))\\n\\t\\t# memo[(i,j)] = result\\n\\t\\treturn result\\n\\n\\t# main\\n\\tgrid = matrix\\n\\tm, n = len(grid), len(grid[0])\\n\\tminFallPath = float(\\'inf\\')\\n\\tfor i in range(len(grid[0])):\\n\\t\\tminFallPath = min(minFallPath, recurse(0, i))\\n\\treturn minFallPath\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1466824,
                "title": "recursion-memoization-iterative-dp",
                "content": "![image](https://assets.leetcode.com/users/images/6bda003d-d02b-421f-a84f-70a9a4ae9c20_1631794522.257455.jpeg)\\n\\n**Recursion TLE** \\n\\n```\\nint solve(int i,int j,int m,int n,vector<vector<int>>& matrix)\\n    {\\n        if(i<0 || j<0 || i>m || j>n) return INT_MAX;\\n        if(i == m) return matrix[i][j];\\n        \\n       return matrix[i][j] + min(solve(i+1,j-1,m,n,matrix),\\n           min(solve(i+1,j,m,n,matrix), solve(i+1,j+1,m,n,matrix)));\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int ans = INT_MAX;\\n        \\n        for(int j=0;j<n;j++)\\n        {\\n           ans = min(ans,solve(0,j,m-1,n-1,matrix));    \\n        }\\n        return ans;\\n    }\\n\\t\\n```\\n\\n**Memoization**\\n\\n```\\nint solve(int i,int j,int m,int n,vector<vector<int>>& matrix,\\n             vector<vector<int>> &dp)\\n    {\\n        if(i<0 || j<0 || i>m || j>n) return INT_MAX;\\n        if(i == m) return matrix[i][j];\\n        \\n        if(dp[i][j] != -1) return dp[i][j];\\n       \\n        return dp[i][j] = matrix[i][j] + min(solve(i+1,j-1,m,n,matrix,dp),\\n           min(solve(i+1,j,m,n,matrix,dp), solve(i+1,j+1,m,n,matrix,dp)));\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int ans = INT_MAX;\\n        \\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        for(int j=0;j<n;j++)\\n        {\\n           ans = min(ans,solve(0,j,m-1,n-1,matrix,dp));    \\n        }\\n        return ans;\\n    }\\n```\\n\\n**Iterative DP**\\n\\n```\\nint minFallingPathSum(vector<vector<int>>& matrix) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        \\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        for(int j=0;j<n;j++)\\n        {\\n            dp[0][j] = matrix[0][j];\\n        }\\n        \\n        for(int i=1;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                // for oth col we dont have col-1\\n                if(j == 0)\\n                    dp[i][j] = matrix[i][j] + min(dp[i-1][j],dp[i-1][j+1]);\\n                \\n                else if(j == n-1)\\n                    dp[i][j] = matrix[i][j] + min(dp[i-1][j-1],dp[i-1][j]);\\n                \\n                else\\n                {\\n                    dp[i][j] = matrix[i][j] + min(dp[i-1][j-1],\\n                                                min(dp[i-1][j],dp[i-1][j+1]));\\n                }\\n            }\\n        }\\n        \\n        int ans = 1e9;\\n        // find min among last row\\n        for(int j=0;j<n;j++)\\n        {\\n            ans = min(ans,dp[m-1][j]);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint solve(int i,int j,int m,int n,vector<vector<int>>& matrix)\\n    {\\n        if(i<0 || j<0 || i>m || j>n) return INT_MAX;\\n        if(i == m) return matrix[i][j];\\n        \\n       return matrix[i][j] + min(solve(i+1,j-1,m,n,matrix),\\n           min(solve(i+1,j,m,n,matrix), solve(i+1,j+1,m,n,matrix)));\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int ans = INT_MAX;\\n        \\n        for(int j=0;j<n;j++)\\n        {\\n           ans = min(ans,solve(0,j,m-1,n-1,matrix));    \\n        }\\n        return ans;\\n    }\\n\\t\\n```\n```\\nint solve(int i,int j,int m,int n,vector<vector<int>>& matrix,\\n             vector<vector<int>> &dp)\\n    {\\n        if(i<0 || j<0 || i>m || j>n) return INT_MAX;\\n        if(i == m) return matrix[i][j];\\n        \\n        if(dp[i][j] != -1) return dp[i][j];\\n       \\n        return dp[i][j] = matrix[i][j] + min(solve(i+1,j-1,m,n,matrix,dp),\\n           min(solve(i+1,j,m,n,matrix,dp), solve(i+1,j+1,m,n,matrix,dp)));\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int ans = INT_MAX;\\n        \\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        for(int j=0;j<n;j++)\\n        {\\n           ans = min(ans,solve(0,j,m-1,n-1,matrix,dp));    \\n        }\\n        return ans;\\n    }\\n```\n```\\nint minFallingPathSum(vector<vector<int>>& matrix) {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        \\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        for(int j=0;j<n;j++)\\n        {\\n            dp[0][j] = matrix[0][j];\\n        }\\n        \\n        for(int i=1;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                // for oth col we dont have col-1\\n                if(j == 0)\\n                    dp[i][j] = matrix[i][j] + min(dp[i-1][j],dp[i-1][j+1]);\\n                \\n                else if(j == n-1)\\n                    dp[i][j] = matrix[i][j] + min(dp[i-1][j-1],dp[i-1][j]);\\n                \\n                else\\n                {\\n                    dp[i][j] = matrix[i][j] + min(dp[i-1][j-1],\\n                                                min(dp[i-1][j],dp[i-1][j+1]));\\n                }\\n            }\\n        }\\n        \\n        int ans = 1e9;\\n        // find min among last row\\n        for(int j=0;j<n;j++)\\n        {\\n            ans = min(ans,dp[m-1][j]);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 186646,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8 The ART of Dynamic Programming](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master)\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n\\nThere are 3 path sum choices to consider for each cell `i`,`j` denoted as `a`,`b`,`c` to denote above/left, above, above/right correspondingly.\\n\\n---\\n\\n**Kotlin Solutions:**\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\n    fun minFallingPathSum(A: Array<IntArray>, INF: Int = (1e9 + 7).toInt()): Int {\\n        var (M, N) = listOf(A.size, A[0].size)\\n        fun go(i: Int, j: Int): Int {\\n            if (j < 0 || j == N)\\n                return INF\\n            if (i == 0)\\n                return A[i][j]\\n            var a = go(i - 1, j - 1)\\n            var b = go(i - 1, j)\\n            var c = go(i - 1, j + 1)\\n            return A[i][j] + listOf(a, b, c).min()!!\\n        }\\n        var best = INF\\n        for (j in 0 until N)\\n            best = Math.min(best, go(M - 1, j))\\n        return best\\n    }\\n}\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\n    fun minFallingPathSum(A: Array<IntArray>, INF: Int = (1e9 + 7).toInt()): Int {\\n        var m = mutableMapOf<String, Int>()\\n        var (M, N) = listOf(A.size, A[0].size)\\n        fun go(i: Int, j: Int): Int {\\n            if (j < 0 || j == N)\\n                return INF\\n            if (i == 0)\\n                return A[i][j]\\n            var k = \"$i,$j\"\\n            if (!m.contains(k)) {\\n                var a = go(i - 1, j - 1)\\n                var b = go(i - 1, j)\\n                var c = go(i - 1, j + 1)\\n                m[k] = A[i][j] + listOf(a, b, c).min()!!\\n            }\\n            return m[k]!!\\n        }\\n        var best = INF\\n        for (j in 0 until N)\\n            best = Math.min(best, go(M - 1, j))\\n        return best\\n    }\\n}\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\n    fun minFallingPathSum(A: Array<IntArray>, INF: Int = (1e9 + 7).toInt()): Int {\\n        var (M, N) = listOf(A.size, A[0].size)\\n        for (i in 1 until M) {\\n            for (j in 0 until N) {\\n                var a = if (0 <= j - 1) A[i - 1][j - 1] else INF\\n                var b = A[i - 1][j]\\n                var c = if (j + 1 < N) A[i - 1][j + 1] else INF\\n                A[i][j] += listOf(a, b, c).min()!!\\n            }\\n        }\\n        return A[M - 1].min()!!\\n    }\\n}\\n```\\n\\n---\\n\\n**Javascript Solutions:**\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nlet minFallingPathSum = A => {\\n    let [M, N] = [A.length, A[0].length];\\n    let go = (i, j) => {\\n        if (j < 0 || j == N)\\n            return Infinity;\\n        if (!i)\\n            return A[i][j];\\n        let a = go(i - 1, j - 1),\\n            b = go(i - 1, j),\\n            c = go(i - 1, j + 1);\\n        return A[i][j] + Math.min(a, b, c);\\n    };\\n    let best = Infinity;\\n    for (let j = 0; j < N; ++j)\\n        best = Math.min(best, go(M - 1, j));\\n    return best;\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nlet minFallingPathSum = (A, m = new Map()) => {\\n    let [M, N] = [A.length, A[0].length];\\n    let go = (i, j) => {\\n        if (j < 0 || j == N)\\n            return Infinity;\\n        if (!i)\\n            return A[i][j];\\n        let k = `${i},${j}`;\\n        if (!m.has(k)) {\\n            let a = go(i - 1, j - 1),\\n                b = go(i - 1, j),\\n                c = go(i - 1, j + 1);\\n            m.set(k, A[i][j] + Math.min(a, b, c));\\n        }\\n        return m.get(k);\\n    };\\n    let best = Infinity;\\n    for (let j = 0; j < N; ++j)\\n        best = Math.min(best, go(M - 1, j));\\n    return best;\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nlet minFallingPathSum = (A, m = new Map()) => {\\n    let [M, N] = [A.length, A[0].length];\\n    for (let i = 1; i < M; ++i) {\\n        for (let j = 0; j < N; ++j) {\\n            let a = 0 <= j - 1 ? A[i - 1][j - 1] : Infinity,\\n                b = A[i - 1][j],\\n                c = j + 1 < N ? A[i - 1][j + 1] : Infinity;\\n            A[i][j] += Math.min(a, b, c);\\n        }\\n    }\\n    return Math.min(...A[M - 1]);\\n};\\n```\\n\\n---\\n\\n**Python3 Solutions:**\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution:\\n    def minFallingPathSum(self, A: List[List[int]]) -> int:\\n        M, N = len(A), len(A[0])\\n        def go(i, j):\\n            if j < 0 or j == N:\\n                return float(\\'inf\\')\\n            if not i:\\n                return A[i][j]\\n            a = go(i - 1, j - 1)\\n            b = go(i - 1, j)\\n            c = go(i - 1, j + 1)\\n            return A[i][j] + min(a, b, c)\\n        best = float(\\'inf\\')\\n        for j in range(N):\\n            best = min(best, go(M - 1, j))\\n        return best\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution:\\n    def minFallingPathSum(self, A: List[List[int]]) -> int:\\n        M, N = len(A), len(A[0])\\n        @cache\\n        def go(i, j):\\n            if j < 0 or j == N:\\n                return float(\\'inf\\')\\n            if not i:\\n                return A[i][j]\\n            a = go(i - 1, j - 1)\\n            b = go(i - 1, j)\\n            c = go(i - 1, j + 1)\\n            return A[i][j] + min(a, b, c)\\n        best = float(\\'inf\\')\\n        for j in range(N):\\n            best = min(best, go(M - 1, j))\\n        return best\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution:\\n    def minFallingPathSum(self, A: List[List[int]]) -> int:\\n        M, N = len(A), len(A[0])\\n        for i in range(1, M):\\n            for j in range(N):\\n                a = A[i - 1][j - 1] if 0 <= j - 1 else float(\\'inf\\')\\n                b = A[i - 1][j]\\n                c = A[i - 1][j + 1] if j + 1 < N else float(\\'inf\\')\\n                A[i][j] += min(a, b, c)\\n        return min(A[M - 1])\\n```\\n\\n---\\n\\n**C++ Solutions:**\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using fun = function<int(int, int)>;\\n    int minFallingPathSum(VVI& A, int INF = 1e9 + 7) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        fun go = [&](auto i, auto j) {\\n            if (j < 0 || j == N)\\n                return INF;\\n            if (!i)\\n                return A[i][j];\\n            auto a = go(i - 1, j -1),\\n                 b = go(i - 1, j),\\n                 c = go(i - 1, j + 1);\\n            return A[i][j] + min({ a, b, c });\\n        };\\n        auto best = INF;\\n        for (auto j{ 0 }; j < N; ++j)\\n            best = min(best, go(M - 1, j));\\n        return best;\\n    }\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via a DP memo\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using fun = function<int(int, int)>;\\n    using Map = unordered_map<string, int>;\\n    int minFallingPathSum(VVI& A, Map m = {}, int INF = 1e9 + 7) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        auto key = [](auto i, auto j) {\\n            stringstream ss; ss << i << \",\" << j;\\n            return ss.str();\\n        };\\n        fun go = [&](auto i, auto j) {\\n            if (j < 0 || j == N)\\n                return INF;\\n            if (!i)\\n                return A[i][j];\\n            auto k = key(i, j);\\n            if (m.find(k) == m.end()) {\\n                auto a = go(i - 1, j -1),\\n                     b = go(i - 1, j),\\n                     c = go(i - 1, j + 1);\\n                m[k] = A[i][j] + min({ a, b, c });\\n            }\\n            return m[k];\\n        };\\n        auto best = INF;\\n        for (auto j{ 0 }; j < N; ++j)\\n            best = min(best, go(M - 1, j));\\n        return best;\\n    }\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using fun = function<int(int, int)>;\\n    using Map = unordered_map<string, int>;\\n    int minFallingPathSum(VVI& A, Map m = {}, int INF = 1e9 + 7) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        for (auto i{ 1 }; i < M; ++i) {\\n            for (auto j{ 0 }; j < N; ++j) {\\n                auto a = 0 <= j - 1 ? A[i - 1][j - 1] : INF,\\n                     b = A[i - 1][j],\\n                     c = j + 1 < N ? A[i - 1][j + 1] : INF;\\n                A[i][j] += min({ a, b, c });\\n            }\\n        }\\n        return *min_element(A[M - 1].begin(), A[M - 1].end());\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun minFallingPathSum(A: Array<IntArray>, INF: Int = (1e9 + 7).toInt()): Int {\\n        var (M, N) = listOf(A.size, A[0].size)\\n        fun go(i: Int, j: Int): Int {\\n            if (j < 0 || j == N)\\n                return INF\\n            if (i == 0)\\n                return A[i][j]\\n            var a = go(i - 1, j - 1)\\n            var b = go(i - 1, j)\\n            var c = go(i - 1, j + 1)\\n            return A[i][j] + listOf(a, b, c).min()!!\\n        }\\n        var best = INF\\n        for (j in 0 until N)\\n            best = Math.min(best, go(M - 1, j))\\n        return best\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun minFallingPathSum(A: Array<IntArray>, INF: Int = (1e9 + 7).toInt()): Int {\\n        var m = mutableMapOf<String, Int>()\\n        var (M, N) = listOf(A.size, A[0].size)\\n        fun go(i: Int, j: Int): Int {\\n            if (j < 0 || j == N)\\n                return INF\\n            if (i == 0)\\n                return A[i][j]\\n            var k = \"$i,$j\"\\n            if (!m.contains(k)) {\\n                var a = go(i - 1, j - 1)\\n                var b = go(i - 1, j)\\n                var c = go(i - 1, j + 1)\\n                m[k] = A[i][j] + listOf(a, b, c).min()!!\\n            }\\n            return m[k]!!\\n        }\\n        var best = INF\\n        for (j in 0 until N)\\n            best = Math.min(best, go(M - 1, j))\\n        return best\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun minFallingPathSum(A: Array<IntArray>, INF: Int = (1e9 + 7).toInt()): Int {\\n        var (M, N) = listOf(A.size, A[0].size)\\n        for (i in 1 until M) {\\n            for (j in 0 until N) {\\n                var a = if (0 <= j - 1) A[i - 1][j - 1] else INF\\n                var b = A[i - 1][j]\\n                var c = if (j + 1 < N) A[i - 1][j + 1] else INF\\n                A[i][j] += listOf(a, b, c).min()!!\\n            }\\n        }\\n        return A[M - 1].min()!!\\n    }\\n}\\n```\n```\\nlet minFallingPathSum = A => {\\n    let [M, N] = [A.length, A[0].length];\\n    let go = (i, j) => {\\n        if (j < 0 || j == N)\\n            return Infinity;\\n        if (!i)\\n            return A[i][j];\\n        let a = go(i - 1, j - 1),\\n            b = go(i - 1, j),\\n            c = go(i - 1, j + 1);\\n        return A[i][j] + Math.min(a, b, c);\\n    };\\n    let best = Infinity;\\n    for (let j = 0; j < N; ++j)\\n        best = Math.min(best, go(M - 1, j));\\n    return best;\\n};\\n```\n```\\nlet minFallingPathSum = (A, m = new Map()) => {\\n    let [M, N] = [A.length, A[0].length];\\n    let go = (i, j) => {\\n        if (j < 0 || j == N)\\n            return Infinity;\\n        if (!i)\\n            return A[i][j];\\n        let k = `${i},${j}`;\\n        if (!m.has(k)) {\\n            let a = go(i - 1, j - 1),\\n                b = go(i - 1, j),\\n                c = go(i - 1, j + 1);\\n            m.set(k, A[i][j] + Math.min(a, b, c));\\n        }\\n        return m.get(k);\\n    };\\n    let best = Infinity;\\n    for (let j = 0; j < N; ++j)\\n        best = Math.min(best, go(M - 1, j));\\n    return best;\\n};\\n```\n```\\nlet minFallingPathSum = (A, m = new Map()) => {\\n    let [M, N] = [A.length, A[0].length];\\n    for (let i = 1; i < M; ++i) {\\n        for (let j = 0; j < N; ++j) {\\n            let a = 0 <= j - 1 ? A[i - 1][j - 1] : Infinity,\\n                b = A[i - 1][j],\\n                c = j + 1 < N ? A[i - 1][j + 1] : Infinity;\\n            A[i][j] += Math.min(a, b, c);\\n        }\\n    }\\n    return Math.min(...A[M - 1]);\\n};\\n```\n```\\nclass Solution:\\n    def minFallingPathSum(self, A: List[List[int]]) -> int:\\n        M, N = len(A), len(A[0])\\n        def go(i, j):\\n            if j < 0 or j == N:\\n                return float(\\'inf\\')\\n            if not i:\\n                return A[i][j]\\n            a = go(i - 1, j - 1)\\n            b = go(i - 1, j)\\n            c = go(i - 1, j + 1)\\n            return A[i][j] + min(a, b, c)\\n        best = float(\\'inf\\')\\n        for j in range(N):\\n            best = min(best, go(M - 1, j))\\n        return best\\n```\n```\\nclass Solution:\\n    def minFallingPathSum(self, A: List[List[int]]) -> int:\\n        M, N = len(A), len(A[0])\\n        @cache\\n        def go(i, j):\\n            if j < 0 or j == N:\\n                return float(\\'inf\\')\\n            if not i:\\n                return A[i][j]\\n            a = go(i - 1, j - 1)\\n            b = go(i - 1, j)\\n            c = go(i - 1, j + 1)\\n            return A[i][j] + min(a, b, c)\\n        best = float(\\'inf\\')\\n        for j in range(N):\\n            best = min(best, go(M - 1, j))\\n        return best\\n```\n```\\nclass Solution:\\n    def minFallingPathSum(self, A: List[List[int]]) -> int:\\n        M, N = len(A), len(A[0])\\n        for i in range(1, M):\\n            for j in range(N):\\n                a = A[i - 1][j - 1] if 0 <= j - 1 else float(\\'inf\\')\\n                b = A[i - 1][j]\\n                c = A[i - 1][j + 1] if j + 1 < N else float(\\'inf\\')\\n                A[i][j] += min(a, b, c)\\n        return min(A[M - 1])\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using fun = function<int(int, int)>;\\n    int minFallingPathSum(VVI& A, int INF = 1e9 + 7) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        fun go = [&](auto i, auto j) {\\n            if (j < 0 || j == N)\\n                return INF;\\n            if (!i)\\n                return A[i][j];\\n            auto a = go(i - 1, j -1),\\n                 b = go(i - 1, j),\\n                 c = go(i - 1, j + 1);\\n            return A[i][j] + min({ a, b, c });\\n        };\\n        auto best = INF;\\n        for (auto j{ 0 }; j < N; ++j)\\n            best = min(best, go(M - 1, j));\\n        return best;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using fun = function<int(int, int)>;\\n    using Map = unordered_map<string, int>;\\n    int minFallingPathSum(VVI& A, Map m = {}, int INF = 1e9 + 7) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        auto key = [](auto i, auto j) {\\n            stringstream ss; ss << i << \",\" << j;\\n            return ss.str();\\n        };\\n        fun go = [&](auto i, auto j) {\\n            if (j < 0 || j == N)\\n                return INF;\\n            if (!i)\\n                return A[i][j];\\n            auto k = key(i, j);\\n            if (m.find(k) == m.end()) {\\n                auto a = go(i - 1, j -1),\\n                     b = go(i - 1, j),\\n                     c = go(i - 1, j + 1);\\n                m[k] = A[i][j] + min({ a, b, c });\\n            }\\n            return m[k];\\n        };\\n        auto best = INF;\\n        for (auto j{ 0 }; j < N; ++j)\\n            best = min(best, go(M - 1, j));\\n        return best;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using fun = function<int(int, int)>;\\n    using Map = unordered_map<string, int>;\\n    int minFallingPathSum(VVI& A, Map m = {}, int INF = 1e9 + 7) {\\n        int M = A.size(),\\n            N = A[0].size();\\n        for (auto i{ 1 }; i < M; ++i) {\\n            for (auto j{ 0 }; j < N; ++j) {\\n                auto a = 0 <= j - 1 ? A[i - 1][j - 1] : INF,\\n                     b = A[i - 1][j],\\n                     c = j + 1 < N ? A[i - 1][j + 1] : INF;\\n                A[i][j] += min({ a, b, c });\\n            }\\n        }\\n        return *min_element(A[M - 1].begin(), A[M - 1].end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 645283,
                "title": "c-simple-easy-solution-using-dp-beginners-friendly",
                "content": "Pls upvote if you find this helpful  :)\\n\\nBasic idea is to divide this problem into subproblems i.e get minimum value corresponding to each grid cell.For the first row the value remains unchanged,while from second row onwards we need to add minimum of the three elements from the previous row.Deal with corner cases separately .Once all this is done we scan the last row and get the minimum.\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& A) {\\n        int row=A.size();\\n        int column=A[0].size();\\n        for(int i=1;i<row;i++){\\n            for(int j=0;j<column;j++){\\n                if(j==0)                                                    //Leftmost or first column\\n                A[i][j]+=min(A[i-1][j],A[i-1][j+1]);\\n                else if(j==column-1)A[i][j]+=min(A[i-1][j],A[i-1][j-1]);     //Rightmost or last column\\n                else A[i][j]+=std::min({A[i-1][j],A[i-1][j+1],A[i-1][j-1]}); //Remaining cases\\n            }\\n        }\\n        int sum=INT_MAX;\\n        for(int i=0;i<column;i++){\\n            sum=min(sum,A[row-1][i]);                                      //Last row scan\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& A) {\\n        int row=A.size();\\n        int column=A[0].size();\\n        for(int i=1;i<row;i++){\\n            for(int j=0;j<column;j++){\\n                if(j==0)                                                    //Leftmost or first column\\n                A[i][j]+=min(A[i-1][j],A[i-1][j+1]);\\n                else if(j==column-1)A[i][j]+=min(A[i-1][j],A[i-1][j-1]);     //Rightmost or last column\\n                else A[i][j]+=std::min({A[i-1][j],A[i-1][j+1],A[i-1][j-1]}); //Remaining cases\\n            }\\n        }\\n        int sum=INT_MAX;\\n        for(int i=0;i<column;i++){\\n            sum=min(sum,A[row-1][i]);                                      //Last row scan\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 206902,
                "title": "python-dp-solution-in-4-lines",
                "content": "\\n    def minFallingPathSum(self, A):\\n        \"\"\"\\n        :type A: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        dp = A[0]\\n        for row in A[1:]:\\n            dp = [value + min([dp[c], dp[max(c - 1, 0)], dp[min(len(A) - 1, c + 1)]]) for c, value in enumerate(row)]\\n        return min(dp)\\n\\t\\t\\n\\t\\t\\nin-place solution:\\n\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        for i in range(1, len(matrix)):\\n            for j in range(len(matrix[0])):\\n                matrix[i][j] += min(matrix[i - 1][max(0, j - 1):j + 2])\\n        return min(matrix[-1])",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "\\n    def minFallingPathSum(self, A):\\n        \"\"\"\\n        :type A: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        dp = A[0]\\n        for row in A[1:]:\\n            dp = [value + min([dp[c], dp[max(c - 1, 0)], dp[min(len(A) - 1, c + 1)]]) for c, value in enumerate(row)]\\n        return min(dp)\\n\\t\\t\\n\\t\\t\\nin-place solution:\\n\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        for i in range(1, len(matrix)):\\n            for j in range(len(matrix[0])):\\n                matrix[i][j] += min(matrix[i - 1][max(0, j - 1):j + 2])\\n        return min(matrix[-1])",
                "codeTag": "Python3"
            },
            {
                "id": 400592,
                "title": "python-beats-100-concise-code",
                "content": "\\tclass Solution(object):\\n\\t\\tdef minFallingPathSum(self, arr):\\n\\t\\t\\tfor i in range(1,len(arr)):\\n\\t\\t\\t\\tfor j in range(len(arr[0])):\\n\\t\\t\\t\\t\\tif j==0:\\n\\t\\t\\t\\t\\t\\tarr[i][j] += min([arr[i-1][j+1], arr[i-1][j]])\\n\\t\\t\\t\\t\\telif j==len(arr[0])-1:\\n\\t\\t\\t\\t\\t\\tarr[i][j] += min([arr[i-1][j-1], arr[i-1][j]])\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tarr[i][j] += min([arr[i-1][j-1], arr[i-1][j], arr[i-1][j+1]])\\n\\t\\t\\treturn min(arr[-1])",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass Solution(object):\\n\\t\\tdef minFallingPathSum(self, arr):\\n\\t\\t\\tfor i in range(1,len(arr)):\\n\\t\\t\\t\\tfor j in range(len(arr[0])):\\n\\t\\t\\t\\t\\tif j==0:\\n\\t\\t\\t\\t\\t\\tarr[i][j] += min([arr[i-1][j+1], arr[i-1][j]])\\n\\t\\t\\t\\t\\telif j==len(arr[0])-1:\\n\\t\\t\\t\\t\\t\\tarr[i][j] += min([arr[i-1][j-1], arr[i-1][j]])\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tarr[i][j] += min([arr[i-1][j-1], arr[i-1][j], arr[i-1][j+1]])\\n\\t\\t\\treturn min(arr[-1])",
                "codeTag": "Java"
            },
            {
                "id": 241307,
                "title": "cpp-dp-easy-to-understand",
                "content": "```\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& A) {\\n    vector<vector<int>> dp(A.size(),vector<int>(A.size(),INT_MAX));\\n    for(int i=0;i<A.size();i++){\\n        dp[0][i] = A[0][i];\\n    }\\n    for(int i=1;i<A.size();i++){\\n        for(int j=0;j<A.size();j++){\\n            if(j>0 and j<A.size()-1){\\n                dp[i][j] = min(dp[i-1][j-1]+A[i][j],dp[i-1][j]+A[i][j]);\\n                dp[i][j] = min(dp[i-1][j+1]+A[i][j],dp[i][j]);\\n            }\\n            else if(j==0){\\n                dp[i][j] = min(dp[i-1][j+1]+A[i][j],dp[i-1][j]+A[i][j]);\\n            }\\n            else if(j == A.size()-1){\\n                dp[i][j] = min(dp[i-1][j-1]+A[i][j],dp[i-1][j]+A[i][j]);\\n            }\\n        }\\n    }\\n    \\n    int ans = INT_MAX;\\n    for(auto& x:dp[dp.size()-1]){\\n            ans = min(ans,x);\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& A) {\\n    vector<vector<int>> dp(A.size(),vector<int>(A.size(),INT_MAX));\\n    for(int i=0;i<A.size();i++){\\n        dp[0][i] = A[0][i];\\n    }\\n    for(int i=1;i<A.size();i++){\\n        for(int j=0;j<A.size();j++){\\n            if(j>0 and j<A.size()-1){\\n                dp[i][j] = min(dp[i-1][j-1]+A[i][j],dp[i-1][j]+A[i][j]);\\n                dp[i][j] = min(dp[i-1][j+1]+A[i][j],dp[i][j]);\\n            }\\n            else if(j==0){\\n                dp[i][j] = min(dp[i-1][j+1]+A[i][j],dp[i-1][j]+A[i][j]);\\n            }\\n            else if(j == A.size()-1){\\n                dp[i][j] = min(dp[i-1][j-1]+A[i][j],dp[i-1][j]+A[i][j]);\\n            }\\n        }\\n    }\\n    \\n    int ans = INT_MAX;\\n    for(auto& x:dp[dp.size()-1]){\\n            ans = min(ans,x);\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 201812,
                "title": "recursive-with-memoization-3ms-beats-100",
                "content": "This solution sacrifices memory for speed. Things to keep in mind, minimal error checking, we know that A.length is bigger than 0 so we don\\'t have to check those cases. \\n\\nAlso there is one case that that might be a problem but I leave that as homework for you.\\n```\\nclass Solution {\\n    int[][] memo;\\n    public int minFallingPathSum(int[][] A) {\\n        int minPath = Integer.MAX_VALUE;\\n        memo = new int[A.length][A.length];\\n        for (int i = 0; i < A.length; i++){\\n            minPath = Math.min(minPath, findMinPath(A, 0, i));\\n        }\\n        return minPath;    \\n    }\\n    \\n    private int findMinPath(int[][] A, int row, int column){\\n        if (row == A.length - 1){\\n            return A[row][column];\\n        } \\n        if (memo[row][column] != 0) {return memo[row][column];}\\n        int minPath = Integer.MAX_VALUE; \\n        int value = A[row][column];\\n        if (column-1 >= 0)\\n            minPath = Math.min(minPath, findMinPath(A, row + 1, column - 1) + value);\\n        if (column+1 < A.length)\\n            minPath = Math.min(minPath, findMinPath(A, row + 1, column + 1) + value);\\n        minPath = Math.min(minPath, findMinPath(A, row + 1, column) + value);\\n        memo[row][column] = minPath;\\n        \\n        return minPath;\\n            \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[][] memo;\\n    public int minFallingPathSum(int[][] A) {\\n        int minPath = Integer.MAX_VALUE;\\n        memo = new int[A.length][A.length];\\n        for (int i = 0; i < A.length; i++){\\n            minPath = Math.min(minPath, findMinPath(A, 0, i));\\n        }\\n        return minPath;    \\n    }\\n    \\n    private int findMinPath(int[][] A, int row, int column){\\n        if (row == A.length - 1){\\n            return A[row][column];\\n        } \\n        if (memo[row][column] != 0) {return memo[row][column];}\\n        int minPath = Integer.MAX_VALUE; \\n        int value = A[row][column];\\n        if (column-1 >= 0)\\n            minPath = Math.min(minPath, findMinPath(A, row + 1, column - 1) + value);\\n        if (column+1 < A.length)\\n            minPath = Math.min(minPath, findMinPath(A, row + 1, column + 1) + value);\\n        minPath = Math.min(minPath, findMinPath(A, row + 1, column) + value);\\n        memo[row][column] = minPath;\\n        \\n        return minPath;\\n            \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1738722,
                "title": "easy-dp-recurion-memoization-tabulation-space-optimization",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    \\n    //BASIC RECURSION \\n    \\n    \\n    \\n    int f(int i,int j,int n,int m,vector<vector<int>>& a)\\n    {\\n        if(j<0 || j>m-1)\\n            return 1e9;\\n        \\n        if(i==0)\\n            return a[i][j];\\n        \\n        int up = a[i][j] + f(i-1,j,n,m,a);\\n        \\n        int ld = a[i][j] + f(i-1,j-1,n,m,a);\\n        \\n        int rd = a[i][j] + f(i-1,j+1,n,m,a);\\n        \\n        \\n        return min(up,min(ld,rd));\\n        \\n    }\\n    \\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        \\n        int ans=INT_MAX;\\n        \\n        int n=matrix.size();\\n        \\n        int m=matrix[0].size();\\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            ans=min(ans,f(n-1,j,n,m,matrix));\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    \\n    \\n     \\n    //MEMOIZATION\\n    \\n    \\n    \\n    \\n    int f(int i,int j,int n,int m,vector<vector<int>>& a,vector<vector<int>>&dp)\\n    {\\n        if(j<0 || j>m-1)\\n            return 1e9;\\n        \\n        if(i==0)\\n            return a[i][j];\\n        \\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        int up = a[i][j] + f(i-1,j,n,m,a,dp);\\n        \\n        int ld = a[i][j] + f(i-1,j-1,n,m,a,dp);\\n        \\n        int rd = a[i][j] + f(i-1,j+1,n,m,a,dp);\\n        \\n        \\n        return dp[i][j]=min(up,min(ld,rd));\\n        \\n    }\\n    \\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        \\n        int ans=INT_MAX;\\n        \\n        int n=matrix.size();\\n        \\n        int m=matrix[0].size();\\n        \\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            ans=min(ans,f(n-1,j,n,m,matrix,dp));\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    \\n    \\n    \\n    \\n    //TABULATION\\n    \\n    \\n    \\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        \\n        \\n        \\n        int n=matrix.size();\\n        \\n        int m=matrix[0].size();\\n        \\n        vector<vector<int>>dp(n,vector<int>(m,0));\\n        \\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            dp[0][j]=matrix[0][j];\\n            \\n        }\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int ld=1e9,rd=1e9;\\n                \\n                \\n                int up=matrix[i][j] + dp[i-1][j];\\n                \\n                if(j-1>=0)\\n                    ld=matrix[i][j] + dp[i-1][j-1];\\n                if(j+1<m)\\n                    rd=matrix[i][j] + dp[i-1][j+1];\\n                \\n                dp[i][j] = min(up,min(ld,rd));\\n                \\n                \\n                \\n            }\\n        }\\n        \\n        int mini=dp[n-1][0];\\n        \\n        for(int j=1;j<m;j++)\\n        {\\n            \\n            mini=min(mini,dp[n-1][j]);\\n            \\n        }\\n        return mini;\\n        \\n    }\\n    \\n    \\n    \\n    \\n    // space optimization \\n    \\n    \\n    \\n    \\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        \\n        \\n        \\n        int n=matrix.size();\\n        \\n        int m=matrix[0].size();\\n        \\n        vector<int>cur(m,0);\\n        vector<int>prev(m,0);\\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            prev[j]=matrix[0][j]; \\n        }\\n        \\n        \\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int ld=1e9,rd=1e9;\\n                \\n                \\n                int up=matrix[i][j] + prev[j];\\n                \\n                if(j-1>=0)\\n                    ld=matrix[i][j] + prev[j-1];\\n                if(j+1<m)\\n                    rd=matrix[i][j] + prev[j+1];\\n                \\n                cur[j] = min(up,min(ld,rd));\\n                \\n                \\n                \\n            }\\n            prev=cur;\\n        }\\n        \\n        int mini=prev[0];\\n        \\n        for(int j=1;j<m;j++)\\n        {\\n            \\n            mini=min(mini,prev[j]);\\n            \\n        }\\n        return mini;\\n        \\n    }\\n    \\n    \\n    \\n    \\n    \\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    \\n    //BASIC RECURSION \\n    \\n    \\n    \\n    int f(int i,int j,int n,int m,vector<vector<int>>& a)\\n    {\\n        if(j<0 || j>m-1)\\n            return 1e9;\\n        \\n        if(i==0)\\n            return a[i][j];\\n        \\n        int up = a[i][j] + f(i-1,j,n,m,a);\\n        \\n        int ld = a[i][j] + f(i-1,j-1,n,m,a);\\n        \\n        int rd = a[i][j] + f(i-1,j+1,n,m,a);\\n        \\n        \\n        return min(up,min(ld,rd));\\n        \\n    }\\n    \\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        \\n        int ans=INT_MAX;\\n        \\n        int n=matrix.size();\\n        \\n        int m=matrix[0].size();\\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            ans=min(ans,f(n-1,j,n,m,matrix));\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    \\n    \\n     \\n    //MEMOIZATION\\n    \\n    \\n    \\n    \\n    int f(int i,int j,int n,int m,vector<vector<int>>& a,vector<vector<int>>&dp)\\n    {\\n        if(j<0 || j>m-1)\\n            return 1e9;\\n        \\n        if(i==0)\\n            return a[i][j];\\n        \\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        int up = a[i][j] + f(i-1,j,n,m,a,dp);\\n        \\n        int ld = a[i][j] + f(i-1,j-1,n,m,a,dp);\\n        \\n        int rd = a[i][j] + f(i-1,j+1,n,m,a,dp);\\n        \\n        \\n        return dp[i][j]=min(up,min(ld,rd));\\n        \\n    }\\n    \\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        \\n        int ans=INT_MAX;\\n        \\n        int n=matrix.size();\\n        \\n        int m=matrix[0].size();\\n        \\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            ans=min(ans,f(n-1,j,n,m,matrix,dp));\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    \\n    \\n    \\n    \\n    //TABULATION\\n    \\n    \\n    \\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        \\n        \\n        \\n        int n=matrix.size();\\n        \\n        int m=matrix[0].size();\\n        \\n        vector<vector<int>>dp(n,vector<int>(m,0));\\n        \\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            dp[0][j]=matrix[0][j];\\n            \\n        }\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int ld=1e9,rd=1e9;\\n                \\n                \\n                int up=matrix[i][j] + dp[i-1][j];\\n                \\n                if(j-1>=0)\\n                    ld=matrix[i][j] + dp[i-1][j-1];\\n                if(j+1<m)\\n                    rd=matrix[i][j] + dp[i-1][j+1];\\n                \\n                dp[i][j] = min(up,min(ld,rd));\\n                \\n                \\n                \\n            }\\n        }\\n        \\n        int mini=dp[n-1][0];\\n        \\n        for(int j=1;j<m;j++)\\n        {\\n            \\n            mini=min(mini,dp[n-1][j]);\\n            \\n        }\\n        return mini;\\n        \\n    }\\n    \\n    \\n    \\n    \\n    // space optimization \\n    \\n    \\n    \\n    \\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        \\n        \\n        \\n        int n=matrix.size();\\n        \\n        int m=matrix[0].size();\\n        \\n        vector<int>cur(m,0);\\n        vector<int>prev(m,0);\\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            prev[j]=matrix[0][j]; \\n        }\\n        \\n        \\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int ld=1e9,rd=1e9;\\n                \\n                \\n                int up=matrix[i][j] + prev[j];\\n                \\n                if(j-1>=0)\\n                    ld=matrix[i][j] + prev[j-1];\\n                if(j+1<m)\\n                    rd=matrix[i][j] + prev[j+1];\\n                \\n                cur[j] = min(up,min(ld,rd));\\n                \\n                \\n                \\n            }\\n            prev=cur;\\n        }\\n        \\n        int mini=prev[0];\\n        \\n        for(int j=1;j<m;j++)\\n        {\\n            \\n            mini=min(mini,prev[j]);\\n            \\n        }\\n        return mini;\\n        \\n    }\\n    \\n    \\n    \\n    \\n    \\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1087173,
                "title": "python-dp-easy-to-understand",
                "content": "Guys im emotional because this is the first medium dp tabulation problem ive solved on my own in <10 minutes. Thanks to anyone who reads this.\\n```\\nimport math\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        for row in range(1, len(matrix)):\\n            for col in range(len(matrix)):\\n\\t\\t\\t\\t# Update current element with the min of its upper 3 elements. \\n\\t\\t\\t\\t# If any of those do not exist then just use math.inf as placeholder\\n                matrix[row][col] = matrix[row][col] + \\\\\\n\\t\\t\\t\\tmin(matrix[row-1][col], \\n\\t\\t\\t\\tmatrix[row-1][col-1] if col - 1 >= 0 else math.inf, \\n\\t\\t\\t\\tmatrix[row-1][col+1] if col + 1 < len(matrix) else math.inf)\\n\\t\\t# The minimum item on the last row is the result because it is the \"smallest path sum\"\\n        return min(matrix[-1])\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        for row in range(1, len(matrix)):\\n            for col in range(len(matrix)):\\n\\t\\t\\t\\t# Update current element with the min of its upper 3 elements. \\n\\t\\t\\t\\t# If any of those do not exist then just use math.inf as placeholder\\n                matrix[row][col] = matrix[row][col] + \\\\\\n\\t\\t\\t\\tmin(matrix[row-1][col], \\n\\t\\t\\t\\tmatrix[row-1][col-1] if col - 1 >= 0 else math.inf, \\n\\t\\t\\t\\tmatrix[row-1][col+1] if col + 1 < len(matrix) else math.inf)\\n\\t\\t# The minimum item on the last row is the result because it is the \"smallest path sum\"\\n        return min(matrix[-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2906833,
                "title": "python-c-dp-dfs",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs a *Dynamic Programming* approach to explore all possible paths. Time complexity is quadratic: **O(N\\\\*N)**. Space complexity is quadratic: **O(N\\\\*N)**.\\n****\\n\\n**Comment.** Path with the minimal sum is defined recursively, i.e., the path starting from some element in the current row is continued by the element in the next row (that is either directly below or diagonally left/right) which itself is a start of a minimal-sum path.\\n\\n**Python.** Recursive DFS. \\n```\\nclass Solution:\\n    def minFallingPathSum(self, mat: List[List[int]]) -> int:\\n        \\n        n = len(mat)\\n        \\n        @cache\\n        def dfs(i,j):\\n            if i == n          : return 0                                   # the bottom is reached\\n            if j < 0 or j == n : return float(\\'inf\\')                        # a boundary is reached\\n            return mat[i][j] + min(dfs(i+1,j-1), dfs(i+1,j), dfs(i+1,j+1))  # recursive condition\\n        \\n        return min(dfs(0,j) for j in range(n))                              # try all starting elements\\n```\\n\\n**C++.** Iterative DP.\\n```\\nclass Solution\\n{\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& m)\\n    {\\n        int n = m.size();\\n        \\n        for (int i = n-2; i >= 0; --i)\\n            for (int j = n-1; j >= 0; --j)\\n                m[i][j] += min({ m[i+1][max(j-1,0)], \\n                                 m[i+1][j], \\n                                 m[i+1][min(j+1,n-1)] });\\n        \\n        return *min_element(m[0].begin(), m[0].end());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minFallingPathSum(self, mat: List[List[int]]) -> int:\\n        \\n        n = len(mat)\\n        \\n        @cache\\n        def dfs(i,j):\\n            if i == n          : return 0                                   # the bottom is reached\\n            if j < 0 or j == n : return float(\\'inf\\')                        # a boundary is reached\\n            return mat[i][j] + min(dfs(i+1,j-1), dfs(i+1,j), dfs(i+1,j+1))  # recursive condition\\n        \\n        return min(dfs(0,j) for j in range(n))                              # try all starting elements\\n```\n```\\nclass Solution\\n{\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& m)\\n    {\\n        int n = m.size();\\n        \\n        for (int i = n-2; i >= 0; --i)\\n            for (int j = n-1; j >= 0; --j)\\n                m[i][j] += min({ m[i+1][max(j-1,0)], \\n                                 m[i+1][j], \\n                                 m[i+1][min(j+1,n-1)] });\\n        \\n        return *min_element(m[0].begin(), m[0].end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 470229,
                "title": "easy-soution-by-3-ways-recursion-dp-bottom-up-and-dp-top-down",
                "content": "##### By simple recursion: \\n```\\n\\tconst int inf=1e8;\\n    int start(int x,int y,vector<vector<int>> &a)\\n    {\\n        if(x==a.size()) return 0;\\n        if(y==-1 || y==a[0].size()) return inf;\\n\\n\\n         int ans=INT_MAX;\\n        ans = min(ans,a[x][y] + start(x+1,y-1,a));\\n        ans = min(ans,a[x][y] + start(x+1,y,a));\\n        ans = min(ans,a[x][y] + start(x+1,y+1,a));\\n\\n         return ans;\\n    }\\n\\n     int minFallingPathSum(vector<vector<int>>& a) {\\n        int row = a.size();\\n        int col = a[0].size();\\n\\n         int ans = INT_MAX;\\n        for(int i=0;i<col;i++)\\n        {\\n            ans  = min(ans,start(0,i,a));\\n        }\\n        return ans;\\n    }\\n```\\n#### By Dynamic Programming : \\n\\n**1. Top-down** : \\n```\\n\\tconst int inf=1e8;\\n    vector<vector<int>> dp,visit;\\n    int start(int x,int y,vector<vector<int>> &a)\\n    {\\n        if(x==a.size()) return 0;\\n        if(y==-1 || y==a[0].size()) return inf;\\n            \\n        if(visit[x][y]) return dp[x][y];\\n        \\n        int ans=INT_MAX;\\n        ans = min(ans,a[x][y] + start(x+1,y-1,a));\\n        ans = min(ans,a[x][y] + start(x+1,y,a));\\n        ans = min(ans,a[x][y] + start(x+1,y+1,a));\\n        visit[x][y] = 1;\\n        return dp[x][y] = ans;\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& a) {\\n        int row = a.size();\\n        int col = a[0].size();\\n        \\n        dp.resize(row, vector<int>(col));\\n        visit.resize(row, vector<int>(col,0));\\n\\n        int ans = INT_MAX;\\n        for(int i=0;i<col;i++)\\n        {\\n            ans  = min(ans,start(0,i,a));\\n        }\\n        return ans;\\n    }\\n```\\n**2. Bottom-up**\\n```\\n\\tint n = a.size();\\n\\tvector<vector<int>> dp(n+1,vector<int>(n+2));\\n\\n\\tfor(int i=0;i<n+1;i++)\\n\\t{\\n\\t\\tdp[i][0] = dp[i][n+1] = INT_MAX;\\n\\t\\tdp[n][i] = 0;\\n\\t}\\n\\n\\tfor(int i=n-1;i>=0;i--)\\n\\t\\tfor(int j=n-1;j>=0;j--)\\n\\t\\t\\tdp[i][j+1] = a[i][j] + min(dp[i+1][j],min(dp[i+1][j+1], dp[i+1][j+2]) );\\n\\n\\tint ans=INT_MAX;\\n\\tfor(int i=1;i<=n;i++)\\n\\t\\tans = min(ans,dp[0][i]);\\n\\treturn ans;\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\n\\tconst int inf=1e8;\\n    int start(int x,int y,vector<vector<int>> &a)\\n    {\\n        if(x==a.size()) return 0;\\n        if(y==-1 || y==a[0].size()) return inf;\\n\\n\\n         int ans=INT_MAX;\\n        ans = min(ans,a[x][y] + start(x+1,y-1,a));\\n        ans = min(ans,a[x][y] + start(x+1,y,a));\\n        ans = min(ans,a[x][y] + start(x+1,y+1,a));\\n\\n         return ans;\\n    }\\n\\n     int minFallingPathSum(vector<vector<int>>& a) {\\n        int row = a.size();\\n        int col = a[0].size();\\n\\n         int ans = INT_MAX;\\n        for(int i=0;i<col;i++)\\n        {\\n            ans  = min(ans,start(0,i,a));\\n        }\\n        return ans;\\n    }\\n```\n```\\n\\tconst int inf=1e8;\\n    vector<vector<int>> dp,visit;\\n    int start(int x,int y,vector<vector<int>> &a)\\n    {\\n        if(x==a.size()) return 0;\\n        if(y==-1 || y==a[0].size()) return inf;\\n            \\n        if(visit[x][y]) return dp[x][y];\\n        \\n        int ans=INT_MAX;\\n        ans = min(ans,a[x][y] + start(x+1,y-1,a));\\n        ans = min(ans,a[x][y] + start(x+1,y,a));\\n        ans = min(ans,a[x][y] + start(x+1,y+1,a));\\n        visit[x][y] = 1;\\n        return dp[x][y] = ans;\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& a) {\\n        int row = a.size();\\n        int col = a[0].size();\\n        \\n        dp.resize(row, vector<int>(col));\\n        visit.resize(row, vector<int>(col,0));\\n\\n        int ans = INT_MAX;\\n        for(int i=0;i<col;i++)\\n        {\\n            ans  = min(ans,start(0,i,a));\\n        }\\n        return ans;\\n    }\\n```\n```\\n\\tint n = a.size();\\n\\tvector<vector<int>> dp(n+1,vector<int>(n+2));\\n\\n\\tfor(int i=0;i<n+1;i++)\\n\\t{\\n\\t\\tdp[i][0] = dp[i][n+1] = INT_MAX;\\n\\t\\tdp[n][i] = 0;\\n\\t}\\n\\n\\tfor(int i=n-1;i>=0;i--)\\n\\t\\tfor(int j=n-1;j>=0;j--)\\n\\t\\t\\tdp[i][j+1] = a[i][j] + min(dp[i+1][j],min(dp[i+1][j+1], dp[i+1][j+2]) );\\n\\n\\tint ans=INT_MAX;\\n\\tfor(int i=1;i<=n;i++)\\n\\t\\tans = min(ans,dp[0][i]);\\n\\treturn ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2905878,
                "title": "python-3-6-lines-w-explanation-t-m-99-91",
                "content": "Here\\'s the plan:\\n- We start on the bottom row, sliding a three-element window from left to right. \\n- For each window,  we select the minimum value and add it to the element directly above the middle element of the window. \\n- We continue this process on each row moving upward.\\n- When we complete the top row, we select the minimum value as the answer.\\n```\\nclass Solution:\\n    def minFallingPathSum(self, matrix: list[list[int]]) -> int:\\n\\n        m = len(matrix)\\n\\n        matrix = [[inf]+x+[inf] for x in matrix]            # <\\u2013\\u2013 apply some rails to the matrix, whichpreclude  \\n                                                            #     the need for checking if we are off the board\\n        for i in range(m-2,-1,-1):\\n            for j in (range(1,m+1)):\\n                matrix[i][j]+= min(matrix[i+1][j-1:j+2])    # <\\u2013\\u2013 sliding window\\n                \\n        return min(matrix[0])\\n\\n```\\n[https://leetcode.com/problems/minimum-falling-path-sum/submissions/858891502/](http://)\\n\\nI could be wrong, but I think that time is *O*(*N*^2) and space is *O*(*N*).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minFallingPathSum(self, matrix: list[list[int]]) -> int:\\n\\n        m = len(matrix)\\n\\n        matrix = [[inf]+x+[inf] for x in matrix]            # <\\u2013\\u2013 apply some rails to the matrix, whichpreclude  \\n                                                            #     the need for checking if we are off the board\\n        for i in range(m-2,-1,-1):\\n            for j in (range(1,m+1)):\\n                matrix[i][j]+= min(matrix[i+1][j-1:j+2])    # <\\u2013\\u2013 sliding window\\n                \\n        return min(matrix[0])\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 848477,
                "title": "c-simple-and-clean-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& A) {\\n        int n = A.size();\\n\\t\\t// Creating a dp matrix. This is the STL way to do it.\\n        vector<vector<int>> dp(n, vector<int>(n, 0));\\n        \\n\\t\\t// Populate the DP matrix for the first row.\\n        for(int i=0;i<dp.size();i++){\\n            dp[0][i] = A[0][i];\\n        }\\n        \\n\\t\\t// Loop for the rest of the DP matrix.\\n        for(int i=1; i<n;i++){\\n            for(int j=0;j<n;j++){\\n\\t\\t\\t\\t// INT_MAX is chosen because then that variable won\\'t be taken into consideration at the time of **main step.**\\n                int prevCol = (j>=1) ? dp[i-1][j-1] + A[i][j]: INT_MAX;\\n                int nextCol = (j<n-1) ? dp[i-1][j+1] + A[i][j]: INT_MAX;\\n                int sameCol = dp[i-1][j] + A[i][j];\\n                dp[i][j] = min(prevCol, min(nextCol, sameCol));    // MAIN STEP\\n            }\\n        }\\n        \\n\\t\\t// Calucating the minimum value for the last row becuase that is what we want.\\n        int ans = INT_MAX;\\n        for(int j=0;i<n;j++){\\n            ans = min(ans, dp[n-1][j]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nFeel free to ask any doubts in the **comment** section.\\nIf you like this solution, do **UPVOTE**.\\nHappy Coding :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& A) {\\n        int n = A.size();\\n\\t\\t// Creating a dp matrix. This is the STL way to do it.\\n        vector<vector<int>> dp(n, vector<int>(n, 0));\\n        \\n\\t\\t// Populate the DP matrix for the first row.\\n        for(int i=0;i<dp.size();i++){\\n            dp[0][i] = A[0][i];\\n        }\\n        \\n\\t\\t// Loop for the rest of the DP matrix.\\n        for(int i=1; i<n;i++){\\n            for(int j=0;j<n;j++){\\n\\t\\t\\t\\t// INT_MAX is chosen because then that variable won\\'t be taken into consideration at the time of **main step.**\\n                int prevCol = (j>=1) ? dp[i-1][j-1] + A[i][j]: INT_MAX;\\n                int nextCol = (j<n-1) ? dp[i-1][j+1] + A[i][j]: INT_MAX;\\n                int sameCol = dp[i-1][j] + A[i][j];\\n                dp[i][j] = min(prevCol, min(nextCol, sameCol));    // MAIN STEP\\n            }\\n        }\\n        \\n\\t\\t// Calucating the minimum value for the last row becuase that is what we want.\\n        int ans = INT_MAX;\\n        for(int j=0;i<n;j++){\\n            ans = min(ans, dp[n-1][j]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 186843,
                "title": "python-easy-4-liner",
                "content": "* Idea is simple.\\n* Starting from row 1, for each number in the current row (A[i][j]), cumulate minimum previous sum from (A[i - 1][j - 1], A[i - 1][j], A[i - 1][j + 1]).\\n* Return minimum cumulated sum in the last row\\n```\\nclass Solution:\\n    def minFallingPathSum(self, A):\\n        for i in range(1, len(A)):\\n            for j in range(len(A)):\\n                A[i][j] += min(A[i - 1][j and j - 1:j + 2])\\n        return min(A[-1])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minFallingPathSum(self, A):\\n        for i in range(1, len(A)):\\n            for j in range(len(A)):\\n                A[i][j] += min(A[i - 1][j and j - 1:j + 2])\\n        return min(A[-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 186650,
                "title": "java-top-down-dynamic-programming",
                "content": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] A) {\\n        int m = A.length;\\n        int n = A[0].length;\\n        \\n\\n        if (m == 1 || n == 1) return A[0][0];\\n        \\n        Integer[][] dp = new Integer[m][n];\\n        int ans = Integer.MAX_VALUE;\\n        for (int i = 0; i < A.length; i++){\\n            ans = Math.min(ans, minFallingPathSum(A, 0, i, dp));\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int minFallingPathSum(int[][] A, int row, int col, Integer[][]dp){\\n        int m = A.length;\\n        int n = A[0].length;\\n        \\n        if (dp[row][col] != null) return dp[row][col];\\n        \\n        if (row == n-1) //If we are on the last row then we are done for this path\\n            return dp[row][col] = A[row][col];\\n        \\n        int left = Integer.MAX_VALUE, right = Integer.MAX_VALUE;\\n        if (col > 0)\\n         left = minFallingPathSum(A, row +1, col-1, dp);\\n        \\n        int straight = minFallingPathSum(A, row+1, col, dp);\\n        \\n        if (col < n-1)\\n         right = minFallingPathSum(A, row+1, col+1, dp);\\n            \\n        dp[row][col] = Math.min(left, Math.min(straight, right)) + A[row][col];\\n        \\n        return dp[row][col];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] A) {\\n        int m = A.length;\\n        int n = A[0].length;\\n        \\n\\n        if (m == 1 || n == 1) return A[0][0];\\n        \\n        Integer[][] dp = new Integer[m][n];\\n        int ans = Integer.MAX_VALUE;\\n        for (int i = 0; i < A.length; i++){\\n            ans = Math.min(ans, minFallingPathSum(A, 0, i, dp));\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int minFallingPathSum(int[][] A, int row, int col, Integer[][]dp){\\n        int m = A.length;\\n        int n = A[0].length;\\n        \\n        if (dp[row][col] != null) return dp[row][col];\\n        \\n        if (row == n-1) //If we are on the last row then we are done for this path\\n            return dp[row][col] = A[row][col];\\n        \\n        int left = Integer.MAX_VALUE, right = Integer.MAX_VALUE;\\n        if (col > 0)\\n         left = minFallingPathSum(A, row +1, col-1, dp);\\n        \\n        int straight = minFallingPathSum(A, row+1, col, dp);\\n        \\n        if (col < n-1)\\n         right = minFallingPathSum(A, row+1, col+1, dp);\\n            \\n        dp[row][col] = Math.min(left, Math.min(straight, right)) + A[row][col];\\n        \\n        return dp[row][col];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2723332,
                "title": "java-dp-solution-2-approaches-and-complexity-analysis-with-full-explanation",
                "content": "I will show `2 approaches` using Dynamic Programming to solve this question.\\n\\nIn this question, ***3 important things need to be highlighted***: \\n1. **starts at any element in the first row** - this means that, we need to compute answer by taking into consideration each element of `first row`  \\n2. allowed positions are **(row + 1, col - 1), (row + 1, col), or (row + 1, col + 1)**\\n3. question just demands you to reach the **last row** and `not last row\\'s last element `(as in few other path sum problems)\\n\\nSo basically, \\n- we need to find answer by considering each element of first row as starting element of path\\n- for that starting element, we\\'ll find answers considering 3 allowed moves as stated in point 2\\n- find the minimun of those (as we need to return the minimum path sum)\\n\\n## Approach 1 - DP (recursive)\\nWe shall consider variable `i` is for `rows` and `j` for columns and `n` as size of grid(matrix)\\nWe will follow the general approach that is followed for other path sum problems weherin we store value returned recursively by making recursive calls for each path.\\n\\n**Base case senarios**\\n1. if `j >= n`: i.e; we have crossed the bounds of that row and hence we shall return some **large** **positive** number, say (10^7). We are returning large and positive number because it should not be counted when we taken into account when finding the minimum sum as that number doesnot exist in the array.\\n\\t> We are not returning Integer.MAX_VALUE because in future variable recieves that value, it is added to grid[i][j] and when we add a number to MAX_VALUE it results in negative number to avoid overflow.\\n2. if `i == n - 1`: as i stated in 3rd point in the \"points to be highlighted\" - when we reach last row (where index of last row is n - 1) we need to simply stop the operations and return value - `grid[i][j]`\\n\\n**Code**\\n``` java\\npublic int minFallingPathSum(int[][] grid) {\\n        Integer[][] dp = new Integer[grid.length + 1][grid[0].length];\\n        int ans = Integer.MAX_VALUE;\\n        for (int i = 0; i < grid.length; i++)\\n            ans = Math.min(ans, (helperRecursiveDP(grid, dp, 0, i, grid.length)));\\n\\t\\t\\t// finding answers for each column of first row seperatly and storing the minimum value in variable ans \\n        return ans;\\n    }\\n\\t\\n// helper function which computes the result for each column in row 1\\nprivate int helperRecursiveDP(int[][] grid, Integer[][] dp, int i, int j, int n) {\\n        if (j >= n || j < 0) // base-case 1\\n            return (int) Math.pow(10, 7);\\n\\n        if (i == n - 1)\\n            return grid[i][j]; // base-case 2\\n\\n        if (dp[i][j] != null)\\n            return dp[i][j]; // avoiding repetitive steps by returning previously calculated ans\\n\\t\\t\\n\\t\\t// Traversing path according to the question\\n        int x = grid[i][j] + helperRecursiveDP(grid, dp, i + 1, j, n);\\n        int y = grid[i][j] + helperRecursiveDP(grid, dp, i + 1, j + 1, n);\\n        int z = grid[i][j] + helperRecursiveDP(grid, dp, i + 1, j - 1, n);\\n\\n        int ans = Math.min(x, Math.min(y, z)); // finding min of values returned by three traversed paths\\n        dp[i][j] = ans;\\n\\n        return ans;\\n    }\\n```\\n- Time complexity - O(N^2) because at max there will be `N*N` calls for every new problem\\n- Space complexity - O(N ^ 2) + O(N) because we are using O(N) recursive stack space\\n---\\n\\n(\\uD83C\\uDF1FPlease upvote\\u2B06 if it helps. Thank you\\uD83E\\uDD17)\\n\\n---\\n\\n## Approach 2 - Iterative DP (tabulation)\\n\\n**Note**\\n > - One thing to note here is that, dp array will have 2 extra colums on each side (like ***cusion***) so that `ArrayIndexOutOfBounds exception` will be avoided without requiring extra if-else statements. \\n > - We are doing so because we are looping through arrays with column values as (col - 1) (col) (col + 1) for (row + 1) and if we don\\'t add 1 extra columns at each end then at col == 0 and col == n - 1, we will get exceptions.\\n >  - i -> rows, j-> columns, n -> no. of rows\\n\\nTo convert recursive dp to iterative dp, we will do followings steps:\\n1. Pre-store values as per base cases. Therefore\\n\\t- in dp array, we will fill column == 0 and column == n + 1 (cusion columns of dp array)  `10 ^7` (some large +ve number) \\n\\t- we will fill elements of last row of dp array (apart from cusion elements) with values same as those of grid\\'s last row\\n2. Loop through whole dp matrix and storing respective values as explained in code\\n3. return minimum value in dp array\\'s top row \\n\\n**Code**\\n```\\npublic int minFallingPathSum(int[][] grid) {\\n        return table(grid, new int[grid.length][grid[0].length + 2], grid.length);\\n\\t}\\n\\t\\n// helper function to compute result\\nprivate static int table(int[][] grid, int[][] dp, int n) {\\n        if (grid.length == 1)\\n            return grid[0][0]; // base-case\\n\\t\\t\\t\\n\\t\\t// filling cusion columns with (10^7)\\n        for (int i = 0; i < n; i++) {\\n            dp[i][0] = (int) Math.pow(10, 7);\\n        }\\n        for (int i = 0; i < n; i++) {\\n            dp[i][n + 1] = (int) Math.pow(10, 7);\\n        }\\n\\t\\t\\n        int ans = 0;\\n\\t\\t\\n        for (int i = n - 1; i >= 0; i--) {\\n            int min = Integer.MAX_VALUE;\\n            for (int j = 1; j <= n; j++) {\\n                if (i == n - 1) {\\n                    dp[i][j] = grid[i][j - 1]; // filling elements of last row of dp array (apart from cusion elements) with values same as those of grid\\'s last row\\n                } else {\\n\\t\\t\\t\\t\\n                    int x = grid[i][j - 1] + dp[i + 1][j]; // similar to traversing (row + 1)(col) path\\n                    int y = grid[i][j - 1] + dp[i + 1][j - 1]; // similar to traversing (row + 1)(col - 1) path\\n                    int z = grid[i][j - 1] + dp[i + 1][j + 1]; // similar to traversing (row + 1)(col + 1) path\\n\\n                    dp[i][j] = Math.min(z, Math.min(y, x)); // storing min value of 3 \"paths\"\\n                    min = Math.min(min, dp[i][j]); // finding minimum value of that row. Can be ignored here but then has to be done at the end \"to find minimun value of top row\"\\n                }\\n            }\\n            ans = min;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nNote:\\nTo optimize this appraoch a bit, instead of calculating `min` ans in each row, you can calculate it for only the top row of dp array. Anyways, it won\\'t affect the actual time complexity, just the solution will run a bit faster.\\n\\n- Time complexity - O(N^2) because at max there will be `N*N` calls for every new problem\\n- Space complexity - O(N ^ 2) as no recurive stack space involved\\n\\nThankyou for reading.\\n\\n---\\n\\n(\\uD83C\\uDF1FPlease upvote\\u2B06 if it helps. Thank you\\uD83E\\uDD17)\\nIf you have any doubts/suggestions, feel free to comment them down below.\\n\\n---\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "``` java\\npublic int minFallingPathSum(int[][] grid) {\\n        Integer[][] dp = new Integer[grid.length + 1][grid[0].length];\\n        int ans = Integer.MAX_VALUE;\\n        for (int i = 0; i < grid.length; i++)\\n            ans = Math.min(ans, (helperRecursiveDP(grid, dp, 0, i, grid.length)));\\n\\t\\t\\t// finding answers for each column of first row seperatly and storing the minimum value in variable ans \\n        return ans;\\n    }\\n\\t\\n// helper function which computes the result for each column in row 1\\nprivate int helperRecursiveDP(int[][] grid, Integer[][] dp, int i, int j, int n) {\\n        if (j >= n || j < 0) // base-case 1\\n            return (int) Math.pow(10, 7);\\n\\n        if (i == n - 1)\\n            return grid[i][j]; // base-case 2\\n\\n        if (dp[i][j] != null)\\n            return dp[i][j]; // avoiding repetitive steps by returning previously calculated ans\\n\\t\\t\\n\\t\\t// Traversing path according to the question\\n        int x = grid[i][j] + helperRecursiveDP(grid, dp, i + 1, j, n);\\n        int y = grid[i][j] + helperRecursiveDP(grid, dp, i + 1, j + 1, n);\\n        int z = grid[i][j] + helperRecursiveDP(grid, dp, i + 1, j - 1, n);\\n\\n        int ans = Math.min(x, Math.min(y, z)); // finding min of values returned by three traversed paths\\n        dp[i][j] = ans;\\n\\n        return ans;\\n    }\\n```\n```\\npublic int minFallingPathSum(int[][] grid) {\\n        return table(grid, new int[grid.length][grid[0].length + 2], grid.length);\\n\\t}\\n\\t\\n// helper function to compute result\\nprivate static int table(int[][] grid, int[][] dp, int n) {\\n        if (grid.length == 1)\\n            return grid[0][0]; // base-case\\n\\t\\t\\t\\n\\t\\t// filling cusion columns with (10^7)\\n        for (int i = 0; i < n; i++) {\\n            dp[i][0] = (int) Math.pow(10, 7);\\n        }\\n        for (int i = 0; i < n; i++) {\\n            dp[i][n + 1] = (int) Math.pow(10, 7);\\n        }\\n\\t\\t\\n        int ans = 0;\\n\\t\\t\\n        for (int i = n - 1; i >= 0; i--) {\\n            int min = Integer.MAX_VALUE;\\n            for (int j = 1; j <= n; j++) {\\n                if (i == n - 1) {\\n                    dp[i][j] = grid[i][j - 1]; // filling elements of last row of dp array (apart from cusion elements) with values same as those of grid\\'s last row\\n                } else {\\n\\t\\t\\t\\t\\n                    int x = grid[i][j - 1] + dp[i + 1][j]; // similar to traversing (row + 1)(col) path\\n                    int y = grid[i][j - 1] + dp[i + 1][j - 1]; // similar to traversing (row + 1)(col - 1) path\\n                    int z = grid[i][j - 1] + dp[i + 1][j + 1]; // similar to traversing (row + 1)(col + 1) path\\n\\n                    dp[i][j] = Math.min(z, Math.min(y, x)); // storing min value of 3 \"paths\"\\n                    min = Math.min(min, dp[i][j]); // finding minimum value of that row. Can be ignored here but then has to be done at the end \"to find minimun value of top row\"\\n                }\\n            }\\n            ans = min;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2906026,
                "title": "c-easy-understanding-fastest",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix.size();\\n        for(int i = 1; i < rows; i++){\\n            for(int j = 0; j < cols; j++){\\n                int rowUp = matrix[i-1][j];\\n                int leftUp = j>0?matrix[i-1][j-1]:INT_MAX;\\n                int rightUp = j<cols-1?matrix[i-1][j+1]:INT_MAX;\\n                matrix[i][j] += min(rowUp, min(leftUp, rightUp));\\n            }\\n        }\\n        int answer = INT_MAX;\\n        for(int j=0;j < cols; j++){\\n            answer = min(answer, matrix[rows-1][j]);\\n        }\\n        return answer;\\n    }\\n};\\n```\\n**Please upvote if you found the solution is useful**\\n\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix.size();\\n        for(int i = 1; i < rows; i++){\\n            for(int j = 0; j < cols; j++){\\n                int rowUp = matrix[i-1][j];\\n                int leftUp = j>0?matrix[i-1][j-1]:INT_MAX;\\n                int rightUp = j<cols-1?matrix[i-1][j+1]:INT_MAX;\\n                matrix[i][j] += min(rowUp, min(leftUp, rightUp));\\n            }\\n        }\\n        int answer = INT_MAX;\\n        for(int j=0;j < cols; j++){\\n            answer = min(answer, matrix[rows-1][j]);\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2905987,
                "title": "memoized-bottomup-sc-o-n-n-sc-o-n-sc-o-1",
                "content": "**Memoized**\\n```\\nclass Solution {\\npublic:\\n    int dp[105][105];\\n    int rec(int i,int j, vector<vector<int>>&a){\\n        if(i==a.size()) return 0;\\n        if(dp[i][j]!=INT_MAX){\\n            return dp[i][j];\\n        }\\n        int op1 = INT_MAX , op2= INT_MAX , op3 = INT_MAX;\\n        if(j-1>=0){\\n            op1 = min(op1 , a[i][j] + rec(i+1,j-1,a));\\n        }\\n        \\n        if(j+1<a[0].size()){\\n            op2 = min(op2, a[i][j] + rec(i+1,j+1,a));\\n        }\\n        op3 = min(op3, a[i][j] + rec(i+1,j,a));\\n        return dp[i][j] = min({op1, op2, op3});\\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        for(int i=0;i<matrix.size()+1;i++){\\n            for(int j=0;j<=matrix[0].size();j++){\\n                dp[i][j] = INT_MAX;\\n            }\\n        }\\n        int ans = INT_MAX;\\n        for(int i=1;i<=18;i++){\\n            cout<<dp[i][0]<<endl;\\n        }\\n        for(int j=0;j<matrix[0].size();j++){\\n            ans = min(ans , rec(0,j,matrix));\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Bottom up O(N * N) space**\\n\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& a) {\\n        int n = a.size();\\n        int m = n;\\n        vector<vector<int>> dp(n, vector<int>(m));\\n        for(int j=0;j<m;j++){\\n            dp[0][j] = a[0][j];\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(j==0 and j+1<m){\\n                    dp[i][j] = a[i][j] + min({dp[i-1][j+1], dp[i-1][j]});\\n                }\\n                \\n                if(j==m-1 and j-1>=0){\\n                    dp[i][j] = a[i][j] + min({dp[i-1][j-1], dp[i-1][j] });\\n                }\\n                \\n                if(j-1>=0 and j+1<m){\\n                    dp[i][j] = a[i][j] + min({dp[i-1][j-1], dp[i-1][j] , dp[i-1][j+1]});\\n                }\\n            }\\n        }\\n        return *min_element(begin(dp[n-1]), end(dp[n-1]));\\n    }\\n};\\n```\\n\\n**Bottom up O(N) space**\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& a) {\\n        int n = a.size();\\n        int m = n;\\n        vector<int> curr(m, -1);\\n        vector<int> prev(m);\\n        for(int j=0;j<m;j++){\\n            prev[j] = a[0][j];\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(j==0 and j+1<m){\\n                    curr[j] = a[i][j] + min(prev[j] , prev[j+1]);\\n                }\\n                else if(j==m-1 and j-1>=0){\\n                    curr[j] = a[i][j] + min(prev[j] , prev[j-1]);\\n                }\\n                else{\\n                    curr[j] = a[i][j] + min({prev[j] , prev[j-1], prev[j+1]});\\n                }\\n            }\\n            prev = curr;\\n        }\\n        return *min_element(begin(prev), end(prev));\\n    }\\n};\\n```\\n\\n**Bottom Up O(1) space**\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& a) {\\n        int mx = INT_MAX;\\n        int n = a.size();\\n        int m = n;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(j==0 and j+1<m and i){\\n                    a[i][j] = a[i][j] + min({a[i-1][j+1], a[i-1][j]});\\n                }\\n                if(j==m-1 and j-1>=0 and i){\\n                    a[i][j] = a[i][j] + min({a[i-1][j-1], a[i-1][j] });\\n                }\\n                \\n                if(j-1>=0 and j+1<m and i){\\n                    a[i][j] = a[i][j] + min({a[i-1][j-1], a[i-1][j] , a[i-1][j+1]});\\n                }\\n                if(i==n-1){\\n                    mx = min(mx, a[i][j]);\\n                }\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n```\\n**All above solutions have TC O(N * N)**\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[105][105];\\n    int rec(int i,int j, vector<vector<int>>&a){\\n        if(i==a.size()) return 0;\\n        if(dp[i][j]!=INT_MAX){\\n            return dp[i][j];\\n        }\\n        int op1 = INT_MAX , op2= INT_MAX , op3 = INT_MAX;\\n        if(j-1>=0){\\n            op1 = min(op1 , a[i][j] + rec(i+1,j-1,a));\\n        }\\n        \\n        if(j+1<a[0].size()){\\n            op2 = min(op2, a[i][j] + rec(i+1,j+1,a));\\n        }\\n        op3 = min(op3, a[i][j] + rec(i+1,j,a));\\n        return dp[i][j] = min({op1, op2, op3});\\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        for(int i=0;i<matrix.size()+1;i++){\\n            for(int j=0;j<=matrix[0].size();j++){\\n                dp[i][j] = INT_MAX;\\n            }\\n        }\\n        int ans = INT_MAX;\\n        for(int i=1;i<=18;i++){\\n            cout<<dp[i][0]<<endl;\\n        }\\n        for(int j=0;j<matrix[0].size();j++){\\n            ans = min(ans , rec(0,j,matrix));\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& a) {\\n        int n = a.size();\\n        int m = n;\\n        vector<vector<int>> dp(n, vector<int>(m));\\n        for(int j=0;j<m;j++){\\n            dp[0][j] = a[0][j];\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(j==0 and j+1<m){\\n                    dp[i][j] = a[i][j] + min({dp[i-1][j+1], dp[i-1][j]});\\n                }\\n                \\n                if(j==m-1 and j-1>=0){\\n                    dp[i][j] = a[i][j] + min({dp[i-1][j-1], dp[i-1][j] });\\n                }\\n                \\n                if(j-1>=0 and j+1<m){\\n                    dp[i][j] = a[i][j] + min({dp[i-1][j-1], dp[i-1][j] , dp[i-1][j+1]});\\n                }\\n            }\\n        }\\n        return *min_element(begin(dp[n-1]), end(dp[n-1]));\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& a) {\\n        int n = a.size();\\n        int m = n;\\n        vector<int> curr(m, -1);\\n        vector<int> prev(m);\\n        for(int j=0;j<m;j++){\\n            prev[j] = a[0][j];\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(j==0 and j+1<m){\\n                    curr[j] = a[i][j] + min(prev[j] , prev[j+1]);\\n                }\\n                else if(j==m-1 and j-1>=0){\\n                    curr[j] = a[i][j] + min(prev[j] , prev[j-1]);\\n                }\\n                else{\\n                    curr[j] = a[i][j] + min({prev[j] , prev[j-1], prev[j+1]});\\n                }\\n            }\\n            prev = curr;\\n        }\\n        return *min_element(begin(prev), end(prev));\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& a) {\\n        int mx = INT_MAX;\\n        int n = a.size();\\n        int m = n;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(j==0 and j+1<m and i){\\n                    a[i][j] = a[i][j] + min({a[i-1][j+1], a[i-1][j]});\\n                }\\n                if(j==m-1 and j-1>=0 and i){\\n                    a[i][j] = a[i][j] + min({a[i-1][j-1], a[i-1][j] });\\n                }\\n                \\n                if(j-1>=0 and j+1<m and i){\\n                    a[i][j] = a[i][j] + min({a[i-1][j-1], a[i-1][j] , a[i-1][j+1]});\\n                }\\n                if(i==n-1){\\n                    mx = min(mx, a[i][j]);\\n                }\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 221123,
                "title": "very-easy-to-understand-python-6-line-dp-with-no-extra-space-beats-90",
                "content": "```\\nclass Solution:\\n    def minFallingPathSum(self, A):\\n        \"\"\"\\n        :type A: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        for i in range(1, len(A)):\\n            for j in range(len(A[0])):\\n                topleft = A[i-1][j-1] if j-1>=0 else float(\\'inf\\')\\n                topright = A[i-1][j+1] if j+1<len(A[0]) else float(\\'inf\\')\\n                A[i][j] += min(topleft, topright, A[i-1][j])\\n           \\n        return min(A[-1])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minFallingPathSum(self, A):\\n        \"\"\"\\n        :type A: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        for i in range(1, len(A)):\\n            for j in range(len(A[0])):\\n                topleft = A[i-1][j-1] if j-1>=0 else float(\\'inf\\')\\n                topright = A[i-1][j+1] if j+1<len(A[0]) else float(\\'inf\\')\\n                A[i][j] += min(topleft, topright, A[i-1][j])\\n           \\n        return min(A[-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2905841,
                "title": "94-fastest-javascript-very-easy-to-understand-solution",
                "content": "Visit my youtube! Thank you!\\nhttps://www.youtube.com/channel/UCkhEaNAOO8tig5NHqqxXIeg\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} matrix\\n * @return {number}\\n */\\nvar minFallingPathSum = function(matrix) {\\n    let arr = Array.from(Array(matrix.length),()=>new Array(matrix[0].length).fill(0))\\n    for(let i =0; i<matrix[0].length;i++){\\n        arr[0][i] = matrix[0][i]\\n    }\\n    for(let i =1;i<matrix.length;i++){\\n        for(let j =0;j<matrix[0].length;j++){\\n            if(j==0) arr[i][j] = Math.min(arr[i-1][j],arr[i-1][j+1])\\n            else if(j ==matrix[0].length-1) arr[i][j] = Math.min(arr[i-1][j-1],arr[i-1][j])\\n            else arr[i][j] = Math.min(arr[i-1][j-1],arr[i-1][j],arr[i-1][j+1])\\n            arr[i][j] += matrix[i][j]\\n        }\\n    }\\n    return Math.min(...arr[arr.length-1])\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} matrix\\n * @return {number}\\n */\\nvar minFallingPathSum = function(matrix) {\\n    let arr = Array.from(Array(matrix.length),()=>new Array(matrix[0].length).fill(0))\\n    for(let i =0; i<matrix[0].length;i++){\\n        arr[0][i] = matrix[0][i]\\n    }\\n    for(let i =1;i<matrix.length;i++){\\n        for(let j =0;j<matrix[0].length;j++){\\n            if(j==0) arr[i][j] = Math.min(arr[i-1][j],arr[i-1][j+1])\\n            else if(j ==matrix[0].length-1) arr[i][j] = Math.min(arr[i-1][j-1],arr[i-1][j])\\n            else arr[i][j] = Math.min(arr[i-1][j-1],arr[i-1][j],arr[i-1][j+1])\\n            arr[i][j] += matrix[i][j]\\n        }\\n    }\\n    return Math.min(...arr[arr.length-1])\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2554137,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Bottom Up DP***\\n\\n* ***Time Complexity :- O(N * M)***\\n\\n* ***Space Complexity :- O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        \\n        int n = matrix.size();\\n        \\n        int m = matrix[0].size();\\n        \\n        // matrix[i][j] will store the minimum sum from 1st row to {i, j}\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                // find min. of {up, diagonally left, diagonally right}\\n                \\n                // initialize with up\\n                \\n                int mini = matrix[i - 1][j];\\n                \\n                // diagonally left\\n                \\n                if(j - 1 >= 0)\\n                {\\n                    mini = min(mini, matrix[i - 1][j - 1]);\\n                }\\n                \\n                // diagonally right\\n                \\n                if(j + 1 < m)\\n                {\\n                    mini = min(mini, matrix[i - 1][j + 1]);\\n                }\\n                \\n                // update matrix[i][j]\\n                \\n                matrix[i][j] += mini;\\n            }\\n        }\\n        \\n        return *min_element(matrix[n - 1].begin(), matrix[n - 1].end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        \\n        int n = matrix.size();\\n        \\n        int m = matrix[0].size();\\n        \\n        // matrix[i][j] will store the minimum sum from 1st row to {i, j}\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                // find min. of {up, diagonally left, diagonally right}\\n                \\n                // initialize with up\\n                \\n                int mini = matrix[i - 1][j];\\n                \\n                // diagonally left\\n                \\n                if(j - 1 >= 0)\\n                {\\n                    mini = min(mini, matrix[i - 1][j - 1]);\\n                }\\n                \\n                // diagonally right\\n                \\n                if(j + 1 < m)\\n                {\\n                    mini = min(mini, matrix[i - 1][j + 1]);\\n                }\\n                \\n                // update matrix[i][j]\\n                \\n                matrix[i][j] += mini;\\n            }\\n        }\\n        \\n        return *min_element(matrix[n - 1].begin(), matrix[n - 1].end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 792368,
                "title": "simple-solution-with-explaination-with-comments",
                "content": "Idea : at each step we will choose **minimum** from **(column-1,column,column+1)** of **previous** row.\\n\\n```\\nclass Solution:\\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\\n        m,n = len(arr),len(arr[0])\\n        if m==0 or n==0:return 0\\n        dp = [[None]*n for r in range(m)]\\n        \\n        for i in range(m):\\n            for j in range(n):\\n\\t\\t\\t\\t#base case\\n                if i==0:dp[i][j] = arr[i][j]\\n\\t\\t\\t\\t#when there is only one column\\n                elif j==0 and j==n-1:dp[i][j] = arr[i][j]+dp[i-1][j]\\n\\t\\t\\t\\t#when it is first column, (column-1) will out of bound\\n                elif j==0:dp[i][j] = min(dp[i-1][j],dp[i-1][j+1])+arr[i][j]\\n\\t\\t\\t\\t#when it is last column, (column+1) will out of bound\\n                elif j==n-1:dp[i][j] = min(dp[i-1][j],dp[i-1][j-1])+arr[i][j]\\n\\t\\t\\t\\t#choose min from all of three\\n                else:dp[i][j] = min(dp[i-1][j-1],dp[i-1][j],dp[i-1][j+1])+arr[i][j]\\n\\t\\t#atlast return minimum from last row\\n        return min(dp[-1])\\n        \\n\\t\\t#if you understood this then please appreciate it",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "Idea : at each step we will choose **minimum** from **(column-1,column,column+1)** of **previous** row.\\n\\n```\\nclass Solution:\\n    def minFallingPathSum(self, arr: List[List[int]]) -> int:\\n        m,n = len(arr),len(arr[0])\\n        if m==0 or n==0:return 0\\n        dp = [[None]*n for r in range(m)]\\n        \\n        for i in range(m):\\n            for j in range(n):\\n\\t\\t\\t\\t#base case\\n                if i==0:dp[i][j] = arr[i][j]\\n\\t\\t\\t\\t#when there is only one column\\n                elif j==0 and j==n-1:dp[i][j] = arr[i][j]+dp[i-1][j]\\n\\t\\t\\t\\t#when it is first column, (column-1) will out of bound\\n                elif j==0:dp[i][j] = min(dp[i-1][j],dp[i-1][j+1])+arr[i][j]\\n\\t\\t\\t\\t#when it is last column, (column+1) will out of bound\\n                elif j==n-1:dp[i][j] = min(dp[i-1][j],dp[i-1][j-1])+arr[i][j]\\n\\t\\t\\t\\t#choose min from all of three\\n                else:dp[i][j] = min(dp[i-1][j-1],dp[i-1][j],dp[i-1][j+1])+arr[i][j]\\n\\t\\t#atlast return minimum from last row\\n        return min(dp[-1])\\n        \\n\\t\\t#if you understood this then please appreciate it",
                "codeTag": "Java"
            },
            {
                "id": 504544,
                "title": "java-top-down-with-memo-faster-than-100-with-comments",
                "content": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] A) {\\n        Integer[][] dp = new Integer[A.length][A.length];\\n        int min = Integer.MAX_VALUE;\\n        //loop through the first row\\n        for(int i= 0; i < A[0].length; i++) {\\n            //for each element in the first row find the minimum path possible from that element\\n            int curr = minPath(A, 0, i, dp);\\n            min = Math.min(curr, min);\\n        }\\n        return min;\\n    }\\n    private int minPath(int[][] A, int i, int j, Integer[][] dp) {\\n        //if row or col crosses boundaries return Max value since there\\'s no path possible\\n        if(i < 0 || j < 0 || i >= A.length || j >= A[i].length) {\\n            return Integer.MAX_VALUE;\\n        }\\n        //when you reach the end of the path, return the element at the end\\n        if(i == A.length-1) {\\n            return A[i][j];\\n        }\\n        //if you\\'ve already seen the path return the stored result\\n        if(dp[i][j] != null) {\\n            return dp[i][j];\\n        }\\n        //find the best possible path going left\\n        int left = minPath(A, i+1, j-1, dp);\\n        if(left != Integer.MAX_VALUE){\\n            left += A[i][j];\\n        }\\n        //find the best possible path going down\\n        int mid = minPath(A, i+1, j, dp);\\n        if(mid != Integer.MAX_VALUE){\\n            mid += A[i][j];\\n        }\\n        //find the best possible path going right\\n        int right = minPath(A, i+1, j+1, dp);\\n        if(right != Integer.MAX_VALUE){\\n            right += A[i][j];\\n        }\\n        int lm_best = Math.min(left, mid);\\n        //store and the best result found\\n        dp[i][j]= Math.min(lm_best, right);\\n        return dp[i][j];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] A) {\\n        Integer[][] dp = new Integer[A.length][A.length];\\n        int min = Integer.MAX_VALUE;\\n        //loop through the first row\\n        for(int i= 0; i < A[0].length; i++) {\\n            //for each element in the first row find the minimum path possible from that element\\n            int curr = minPath(A, 0, i, dp);\\n            min = Math.min(curr, min);\\n        }\\n        return min;\\n    }\\n    private int minPath(int[][] A, int i, int j, Integer[][] dp) {\\n        //if row or col crosses boundaries return Max value since there\\'s no path possible\\n        if(i < 0 || j < 0 || i >= A.length || j >= A[i].length) {\\n            return Integer.MAX_VALUE;\\n        }\\n        //when you reach the end of the path, return the element at the end\\n        if(i == A.length-1) {\\n            return A[i][j];\\n        }\\n        //if you\\'ve already seen the path return the stored result\\n        if(dp[i][j] != null) {\\n            return dp[i][j];\\n        }\\n        //find the best possible path going left\\n        int left = minPath(A, i+1, j-1, dp);\\n        if(left != Integer.MAX_VALUE){\\n            left += A[i][j];\\n        }\\n        //find the best possible path going down\\n        int mid = minPath(A, i+1, j, dp);\\n        if(mid != Integer.MAX_VALUE){\\n            mid += A[i][j];\\n        }\\n        //find the best possible path going right\\n        int right = minPath(A, i+1, j+1, dp);\\n        if(right != Integer.MAX_VALUE){\\n            right += A[i][j];\\n        }\\n        int lm_best = Math.min(left, mid);\\n        //store and the best result found\\n        dp[i][j]= Math.min(lm_best, right);\\n        return dp[i][j];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 186664,
                "title": "python-dynamic-programming-solution",
                "content": "```python\nclass Solution:\n    def minFallingPathSum(self, A):\n        \"\"\"\n        :type A: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not A: return 0\n        if len(A) == 1: return A[0][0]\n        length = len(A)\n        for i in range(1, length):\n            for j in range(0, length):\n                if j == 0:\n                    A[i][j] += min(A[i - 1][j], A[i - 1][j + 1])\n                elif j == length - 1:\n                    A[i][j] += min(A[i - 1][j - 1], A[i - 1][j])\n                else:\n                    A[i][j] += min(A[i - 1][j - 1], A[i - 1][j], A[i - 1][j + 1])\n\n        return min(A[-1])\n\n```",
                "solutionTags": [],
                "code": "```python\nclass Solution:\n    def minFallingPathSum(self, A):\n        \"\"\"\n        :type A: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not A: return 0\n        if len(A) == 1: return A[0][0]\n        length = len(A)\n        for i in range(1, length):\n            for j in range(0, length):\n                if j == 0:\n                    A[i][j] += min(A[i - 1][j], A[i - 1][j + 1])\n                elif j == length - 1:\n                    A[i][j] += min(A[i - 1][j - 1], A[i - 1][j])\n                else:\n                    A[i][j] += min(A[i - 1][j - 1], A[i - 1][j], A[i - 1][j + 1])\n\n        return min(A[-1])\n\n```",
                "codeTag": "Java"
            },
            {
                "id": 3693057,
                "title": "c-solution-dp-memorization-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSumUtil(int row, int col, vector<vector<int>>& matrix, int n, vector<vector<int>>& dp) {\\n\\n    if(row == n-1) return matrix[row][col];\\n\\n    if(dp[row][col] != INT_MIN) return dp[row][col];\\n\\n    return (dp[row][col] = matrix[row][col] + min({\\n       minFallingPathSumUtil(row+1, max(0, col-1), matrix, n, dp),\\n       minFallingPathSumUtil(row+1, col, matrix, n, dp),\\n       minFallingPathSumUtil(row+1, min(n-1, col+1), matrix, n, dp)\\n    }));\\n\\n}\\nint minFallingPathSum(vector<vector<int>>& matrix) {\\n\\n    int n = matrix.size();\\n\\n    vector<vector<int>> dp(n, vector<int>(n, INT_MIN));\\n        int mini = INT_MAX;\\n        for(int i = 0; i < n; i++) { \\n\\n            mini = min(mini, minFallingPathSumUtil(0, i, matrix, n, dp));\\n        }\\n\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFallingPathSumUtil(int row, int col, vector<vector<int>>& matrix, int n, vector<vector<int>>& dp) {\\n\\n    if(row == n-1) return matrix[row][col];\\n\\n    if(dp[row][col] != INT_MIN) return dp[row][col];\\n\\n    return (dp[row][col] = matrix[row][col] + min({\\n       minFallingPathSumUtil(row+1, max(0, col-1), matrix, n, dp),\\n       minFallingPathSumUtil(row+1, col, matrix, n, dp),\\n       minFallingPathSumUtil(row+1, min(n-1, col+1), matrix, n, dp)\\n    }));\\n\\n}\\nint minFallingPathSum(vector<vector<int>>& matrix) {\\n\\n    int n = matrix.size();\\n\\n    vector<vector<int>> dp(n, vector<int>(n, INT_MIN));\\n        int mini = INT_MAX;\\n        for(int i = 0; i < n; i++) { \\n\\n            mini = min(mini, minFallingPathSumUtil(0, i, matrix, n, dp));\\n        }\\n\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3640333,
                "title": "very-simple-java-dp-tabulation-solution-everything-explained",
                "content": "\\n# Approach\\n1. Make a dp array and store the first row of matrix as it is in the array as that will the the minimum falling sum if we land on that element.\\n2. Now just iterate through the array by choosing the minimum falling sum from the above rows as per the given conditions. Check for boundary elements. The if/else checks are for them. Now we have filled up the DP array.\\n3. Now the dp array in the last row consists of n values out to which we have to select the minimum one.\\n\\n# Complexity\\n- Time complexity:\\nO(N X N)\\n\\n- Space complexity:\\nO(N X N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        int n = matrix.length;\\n        int [][] dp = new int [n][n]; \\n        dp[0][0] = matrix[0][0];  \\n        for(int i=1;i<n;i++){\\n            dp[0][i] = matrix[0][i]; # 1\\n        }\\n        for(int i =0;i<n;i++){\\n            for(int j=0;j<n;j++){ #2\\n                if(i==0) continue;\\n                else if(j==0){\\n                    dp[i][j] = matrix[i][j] + Math.min(dp[i-1][j+1],dp[i-1][j]);\\n                }\\n                else if(j==n-1){\\n                    dp[i][j] = matrix[i][j] + Math.min(dp[i-1][j-1],dp[i-1][j]);\\n                }\\n                else{\\n                    dp[i][j] = matrix[i][j] + Math.min(dp[i-1][j+1],Math.min(dp[i-1][j-1],dp[i-1][j]));\\n                }\\n            }\\n        }\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0;i<n;i++){\\n            min = Math.min(dp[n-1][i],min); #3\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        int n = matrix.length;\\n        int [][] dp = new int [n][n]; \\n        dp[0][0] = matrix[0][0];  \\n        for(int i=1;i<n;i++){\\n            dp[0][i] = matrix[0][i]; # 1\\n        }\\n        for(int i =0;i<n;i++){\\n            for(int j=0;j<n;j++){ #2\\n                if(i==0) continue;\\n                else if(j==0){\\n                    dp[i][j] = matrix[i][j] + Math.min(dp[i-1][j+1],dp[i-1][j]);\\n                }\\n                else if(j==n-1){\\n                    dp[i][j] = matrix[i][j] + Math.min(dp[i-1][j-1],dp[i-1][j]);\\n                }\\n                else{\\n                    dp[i][j] = matrix[i][j] + Math.min(dp[i-1][j+1],Math.min(dp[i-1][j-1],dp[i-1][j]));\\n                }\\n            }\\n        }\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0;i<n;i++){\\n            min = Math.min(dp[n-1][i],min); #3\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2906365,
                "title": "c-3-approaches-memoization-tabulation-space-optimization",
                "content": "# Intuition\\nSince we have to find all possible ways to get minimum path sum, we use recursion and dp.\\n\\n# Approach\\nWe start from every column of last row (we can also start from first row) and move in all three mentioned directions upward (i-1, j-1), (i-1, j), and (i-1, j+1). If we go out of the matrix boundary we return max value. When we reach any column of the first row, we return that cell value and at last we calculate minimum path sum among all path sums and return it.\\n\\n# Memoization : (Top-Down Approach)\\n    \\n```\\nint f(int i, int j, vector<vector<int>> &mat, vector<vector<int>> &dp)\\n{\\n    if(j<0 || j>=mat[0].size()) return 1e8;\\n    if(i==0) return mat[0][j];\\n    if(dp[i][j] != -1) return dp[i][j];\\n\\n    int u=mat[i][j] + f(i-1, j, mat, dp);\\n    int ld=mat[i][j] + f(i-1, j-1, mat, dp);\\n    int rd=mat[i][j] + f(i-1, j+1, mat, dp);\\n\\n    return dp[i][j] = min(u, min(ld, rd));\\n}\\n\\nint minFallingPathSum(vector<vector<int>> &mat)\\n{\\n    int m=mat.size(), n=mat[0].size();\\n    vector<vector<int>> dp(m, vector<int> (n, -1));\\n    int mini=1e8;\\n    for(int j=0; j<n; j++)\\n        mini = min(mini, f(m-1, j, mat, dp));\\n    return mini;\\n}\\n```\\n### Complexity\\n**Time Complexity: O(mxn)** (recursion) + **O(m)** (loop)\\n**Space Complexity: O(mxn)** (dp) + **O(mxn)** (recursion auxiliary space)\\n    \\n# Tabulation : (Bottom-Up Approach)\\n\\n```\\nint minFallingPathSum(vector<vector<int>> &mat)\\n{\\n    int m=mat.size(), n=mat[0].size();\\n    vector<vector<int>> dp(m, vector<int> (n, 0));\\n\\n    for(int j=0; j<n; j++) dp[0][j] = mat[0][j];\\n\\n    for(int i=1; i<m; i++)\\n    {\\n        for(int j=0; j<n; j++)\\n        {\\n            int u = mat[i][j] + dp[i-1][j];\\n            int ld = mat[i][j], rd = mat[i][j];\\n\\n            if(j-1>=0) ld += dp[i-1][j-1];\\n            else ld += 1e8;\\n\\n            if(j+1<n) rd += dp[i-1][j+1];\\n            else rd += 1e8;\\n\\n            dp[i][j] = min(u, min(ld, rd));\\n        }\\n    }\\n\\n    int mini=1e8;\\n    for(int j=0; j<n; j++)\\n        mini = min(mini, dp[m-1][j]);\\n    return mini;\\n}\\n\\n```\\n### Complexity\\n**Time Complexity: O(mxn)** (nested for loop) + **O(m)** (base case loop)\\n**Space Complexity: O(mxn)** (dp)\\n# Space Optimization   \\n```\\nint minFallingPathSum(vector<vector<int>>& mat) \\n{\\n    int r=mat.size(), c=mat[0].size();\\n    vector<int> pre(c, 0), cur(c, 0);\\n    \\n    for(int j=0; j<c; j++) pre[j] = mat[0][j];\\n    \\n    for(int i=1; i<r; i++)\\n    {\\n        for(int j=0; j<c; j++)\\n        {\\n            int u = mat[i][j] + pre[j];\\n            \\n            int ld=mat[i][j], rd=mat[i][j];\\n            \\n            if(j-1>=0) ld += pre[j-1];\\n            else ld += 1e8;\\n            \\n            if(j+1<c) rd += pre[j+1];\\n            else rd += 1e8;\\n                \\n            cur[j] = min(u, min(ld, rd));\\n        }\\n        pre = cur;\\n    }\\n    \\n    int mini = 1e8;\\n    for(int j=0; j<c; j++)\\n        mini = min(mini, pre[j]);\\n    \\n    return mini;    \\n}\\n```\\n### Complexity\\n**Time Complexity: O(mxn)** (nested for loop) + **O(m)** (base case loop)\\n**Space Complexity: O(m)** (pre/cur vector)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Memoization",
                    "Matrix"
                ],
                "code": "```\\nint f(int i, int j, vector<vector<int>> &mat, vector<vector<int>> &dp)\\n{\\n    if(j<0 || j>=mat[0].size()) return 1e8;\\n    if(i==0) return mat[0][j];\\n    if(dp[i][j] != -1) return dp[i][j];\\n\\n    int u=mat[i][j] + f(i-1, j, mat, dp);\\n    int ld=mat[i][j] + f(i-1, j-1, mat, dp);\\n    int rd=mat[i][j] + f(i-1, j+1, mat, dp);\\n\\n    return dp[i][j] = min(u, min(ld, rd));\\n}\\n\\nint minFallingPathSum(vector<vector<int>> &mat)\\n{\\n    int m=mat.size(), n=mat[0].size();\\n    vector<vector<int>> dp(m, vector<int> (n, -1));\\n    int mini=1e8;\\n    for(int j=0; j<n; j++)\\n        mini = min(mini, f(m-1, j, mat, dp));\\n    return mini;\\n}\\n```\n```\\nint minFallingPathSum(vector<vector<int>> &mat)\\n{\\n    int m=mat.size(), n=mat[0].size();\\n    vector<vector<int>> dp(m, vector<int> (n, 0));\\n\\n    for(int j=0; j<n; j++) dp[0][j] = mat[0][j];\\n\\n    for(int i=1; i<m; i++)\\n    {\\n        for(int j=0; j<n; j++)\\n        {\\n            int u = mat[i][j] + dp[i-1][j];\\n            int ld = mat[i][j], rd = mat[i][j];\\n\\n            if(j-1>=0) ld += dp[i-1][j-1];\\n            else ld += 1e8;\\n\\n            if(j+1<n) rd += dp[i-1][j+1];\\n            else rd += 1e8;\\n\\n            dp[i][j] = min(u, min(ld, rd));\\n        }\\n    }\\n\\n    int mini=1e8;\\n    for(int j=0; j<n; j++)\\n        mini = min(mini, dp[m-1][j]);\\n    return mini;\\n}\\n\\n```\n```\\nint minFallingPathSum(vector<vector<int>>& mat) \\n{\\n    int r=mat.size(), c=mat[0].size();\\n    vector<int> pre(c, 0), cur(c, 0);\\n    \\n    for(int j=0; j<c; j++) pre[j] = mat[0][j];\\n    \\n    for(int i=1; i<r; i++)\\n    {\\n        for(int j=0; j<c; j++)\\n        {\\n            int u = mat[i][j] + pre[j];\\n            \\n            int ld=mat[i][j], rd=mat[i][j];\\n            \\n            if(j-1>=0) ld += pre[j-1];\\n            else ld += 1e8;\\n            \\n            if(j+1<c) rd += pre[j+1];\\n            else rd += 1e8;\\n                \\n            cur[j] = min(u, min(ld, rd));\\n        }\\n        pre = cur;\\n    }\\n    \\n    int mini = 1e8;\\n    for(int j=0; j<c; j++)\\n        mini = min(mini, pre[j]);\\n    \\n    return mini;    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2906111,
                "title": "c-memoization-space-optimization-explained",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int rec( int i, int j, vector<vector<int>> &mat, vector<vector<int>> &dp ){\\n\\n        // Base Case \\n        if( j<0 || j>=mat.size() ) return 1e5;\\n        if( i == 0 ) return mat[0][j];\\n\\n        // memoization\\n        if( dp[i][j] != -1 ) return dp[i][j] ;\\n\\n        // Explore all the paths \\n        int up = mat[i][j] + rec( i-1, j, mat, dp );\\n        int leftDiag = mat[i][j] + rec( i-1, j-1, mat, dp );\\n        int rightDiag = mat[i][j] + rec( i-1, j+1, mat, dp );\\n\\n        // take the minimum \\n        return dp[i][j] = min( up, min(leftDiag, rightDiag) );\\n    } \\n    \\n    // Top Down Memoization \\n    // T.C -> O(n^3) Exponential, S.C -> O(n) Recursive Stack Space  \\n    int memoization( vector<vector<int>>& mat ) {\\n        \\n        int n = mat.size() ;\\n        vector<vector<int>> dp(n, vector<int>(n,0) );\\n\\n        int mini = 1e5 ;\\n        for( int j=0 ; j<n ; j++ ){\\n\\n            mini = min( mini, rec( n-1, j, mat, dp ) );\\n        }\\n        return mini ;\\n    }\\n    \\n    // Bottom Up Tabulation \\n    // T.C -> O(n*m), S.C -> O(n*m) DP vector \\n    int tabulation( vector<vector<int>>& mat ) {\\n        \\n        int n = mat.size() ;\\n        int mini = 1e5 ;\\n        vector<vector<int>> dp(n, vector<int>(n,0) );\\n        \\n        // Initialize the first row \\n        for( int j=0 ; j<n ; j++ ){\\n            dp[0][j] = mat[0][j] ;\\n        }\\n\\n        for( int i=1 ; i<n ; i++ ){\\n            for( int j=0 ; j<n ; j++ ){\\n\\n                int up = mat[i][j] + dp[i-1][j] ;\\n\\n                int ld = mat[i][j] ;\\n                if( j-1>=0 ) ld += dp[i-1][j-1] ;\\n                else ld = 1e5 ;\\n\\n                int rd = mat[i][j] ;\\n                if( j+1<n ) rd += dp[i-1][j+1] ;\\n                else rd = 1e5 ;\\n\\n                dp[i][j] = min( up, min(ld,rd) );\\n            }\\n        }\\n\\n        // calculate the max \\n        for( int j=0 ; j<n ; j++ ){\\n            mini = min( mini, dp[n-1][j] );\\n        }\\n\\n        return mini ;\\n    }\\n    \\n    // Space Optimization \\n    // T.C -> O(n*m), S.C -> O(2n) Just 2 linear vectors \\n    int minFallingPathSum( vector<vector<int>>& mat ) {\\n\\n        if( mat.size() == 1 && (mat[0][0]<0 || mat[0][0]>=0) ) return mat[0][0] ;\\n        \\n        int n = mat.size() ;\\n        int mini = 1e5 ;\\n        vector<int> curr(n,0), prev(n,0);\\n        \\n        // Initialize the first row \\n        for( int j=0 ; j<n ; j++ ){\\n            prev[j] = mat[0][j] ;\\n        }\\n\\n        for( int i=1 ; i<n ; i++ ){\\n            for( int j=0 ; j<n ; j++ ){\\n\\n                int up = mat[i][j] + prev[j] ;\\n\\n                int ld = mat[i][j] ;\\n                if( j-1>=0 ) ld += prev[j-1] ;\\n                else ld = 1e5 ;\\n\\n                int rd = mat[i][j] ;\\n                if( j+1<n ) rd += prev[j+1] ;\\n                else rd = 1e5 ;\\n\\n                curr[j] = min( up, min(ld,rd) );\\n            }\\n\\n            prev = curr ;\\n        }\\n\\n        // calculate the max \\n        for( int j=0 ; j<n ; j++ ){\\n            mini = min( mini, curr[j] );\\n        }\\n\\n        return mini ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rec( int i, int j, vector<vector<int>> &mat, vector<vector<int>> &dp ){\\n\\n        // Base Case \\n        if( j<0 || j>=mat.size() ) return 1e5;\\n        if( i == 0 ) return mat[0][j];\\n\\n        // memoization\\n        if( dp[i][j] != -1 ) return dp[i][j] ;\\n\\n        // Explore all the paths \\n        int up = mat[i][j] + rec( i-1, j, mat, dp );\\n        int leftDiag = mat[i][j] + rec( i-1, j-1, mat, dp );\\n        int rightDiag = mat[i][j] + rec( i-1, j+1, mat, dp );\\n\\n        // take the minimum \\n        return dp[i][j] = min( up, min(leftDiag, rightDiag) );\\n    } \\n    \\n    // Top Down Memoization \\n    // T.C -> O(n^3) Exponential, S.C -> O(n) Recursive Stack Space  \\n    int memoization( vector<vector<int>>& mat ) {\\n        \\n        int n = mat.size() ;\\n        vector<vector<int>> dp(n, vector<int>(n,0) );\\n\\n        int mini = 1e5 ;\\n        for( int j=0 ; j<n ; j++ ){\\n\\n            mini = min( mini, rec( n-1, j, mat, dp ) );\\n        }\\n        return mini ;\\n    }\\n    \\n    // Bottom Up Tabulation \\n    // T.C -> O(n*m), S.C -> O(n*m) DP vector \\n    int tabulation( vector<vector<int>>& mat ) {\\n        \\n        int n = mat.size() ;\\n        int mini = 1e5 ;\\n        vector<vector<int>> dp(n, vector<int>(n,0) );\\n        \\n        // Initialize the first row \\n        for( int j=0 ; j<n ; j++ ){\\n            dp[0][j] = mat[0][j] ;\\n        }\\n\\n        for( int i=1 ; i<n ; i++ ){\\n            for( int j=0 ; j<n ; j++ ){\\n\\n                int up = mat[i][j] + dp[i-1][j] ;\\n\\n                int ld = mat[i][j] ;\\n                if( j-1>=0 ) ld += dp[i-1][j-1] ;\\n                else ld = 1e5 ;\\n\\n                int rd = mat[i][j] ;\\n                if( j+1<n ) rd += dp[i-1][j+1] ;\\n                else rd = 1e5 ;\\n\\n                dp[i][j] = min( up, min(ld,rd) );\\n            }\\n        }\\n\\n        // calculate the max \\n        for( int j=0 ; j<n ; j++ ){\\n            mini = min( mini, dp[n-1][j] );\\n        }\\n\\n        return mini ;\\n    }\\n    \\n    // Space Optimization \\n    // T.C -> O(n*m), S.C -> O(2n) Just 2 linear vectors \\n    int minFallingPathSum( vector<vector<int>>& mat ) {\\n\\n        if( mat.size() == 1 && (mat[0][0]<0 || mat[0][0]>=0) ) return mat[0][0] ;\\n        \\n        int n = mat.size() ;\\n        int mini = 1e5 ;\\n        vector<int> curr(n,0), prev(n,0);\\n        \\n        // Initialize the first row \\n        for( int j=0 ; j<n ; j++ ){\\n            prev[j] = mat[0][j] ;\\n        }\\n\\n        for( int i=1 ; i<n ; i++ ){\\n            for( int j=0 ; j<n ; j++ ){\\n\\n                int up = mat[i][j] + prev[j] ;\\n\\n                int ld = mat[i][j] ;\\n                if( j-1>=0 ) ld += prev[j-1] ;\\n                else ld = 1e5 ;\\n\\n                int rd = mat[i][j] ;\\n                if( j+1<n ) rd += prev[j+1] ;\\n                else rd = 1e5 ;\\n\\n                curr[j] = min( up, min(ld,rd) );\\n            }\\n\\n            prev = curr ;\\n        }\\n\\n        // calculate the max \\n        for( int j=0 ; j<n ; j++ ){\\n            mini = min( mini, curr[j] );\\n        }\\n\\n        return mini ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1724482,
                "title": "optimise-optimise-optimise",
                "content": "# Recursion\\nT.C - O(3^N) \\nS.C - O(N)\\n```\\nvar minFallingPathSum = function(matrix) {\\n    let n = matrix.length;\\n    let m = matrix[0].length;\\n    let min = Infinity;\\n    \\n    // base case - when i will be 0, dp[0][j] will be matrix[0][j]\\n    for(let j = 0; j < m; j++) matrix[0][j] = matrix[0][j]\\n    \\n    for(let j = 0 ; j < m; j++) {\\n        min = Math.min(min, compute(n - 1, j, matrix));  \\n    }\\n    return min;\\n};\\n\\nfunction compute(i, j, matrix) {\\n    if(j < 0 || j >= matrix.length) return 10000; // big enough number\\n    \\n    if(i === 0) return matrix[0][j];\\n    \\n    let up = matrix[i][j] + compute(i - 1, j, matrix);\\n    let upLeft = matrix[i][j] + compute(i - 1, j - 1, matrix);\\n    let upRight = matrix[i][j] + compute(i - 1, j + 1, matrix);\\n    \\n    return Math.min(up, upLeft, upRight);\\n}\\n```\\n\\n# Recursion + Dynamic Programming\\nT.C - O(N * M) * M \\nS.C - O(N * M) * M\\n```\\nvar minFallingPathSum = function(matrix) {\\n    let n = matrix.length;\\n    let m = matrix[0].length;\\n    let min = Infinity;\\n    let dp = new Array(n).fill(-1).map(() => new Array(m).fill(-1));\\n    \\n    // base case - when i will be 0, dp[0][j] will be matrix[0][j]\\n    for(let j = 0; j < m; j++) matrix[0][j] = matrix[0][j]\\n    \\n    for(let j = 0 ; j < m; j++) {\\n        min = Math.min(min, compute(n - 1, j, matrix, dp));  \\n    }\\n    \\n    return min;\\n};\\n\\nfunction compute(i, j, matrix, dp) {\\n    if(j < 0 || j >= matrix.length) return 10000; // big enough number\\n    \\n    if(i === 0) return matrix[0][j];\\n    \\n    if(dp[i][j] !== -1) return dp[i][j];\\n    \\n    let up = matrix[i][j] + compute(i - 1, j, matrix, dp);\\n    let upLeft = matrix[i][j] + compute(i - 1, j - 1, matrix, dp);\\n    let upRight = matrix[i][j] + compute(i - 1, j + 1, matrix, dp);\\n    \\n    return dp[i][j] = Math.min(up, upLeft, upRight);\\n}\\n```\\n\\n# Dynamic Programming + Tabulation\\nT.C - O(N * M)\\nS.C - O(N * M)\\n```\\nvar minFallingPathSum = function(matrix) {\\n    let n = matrix.length;\\n    let m = matrix[0].length;\\n    let dp = new Array(n).fill(0).map(() => new Array(m).fill(0));\\n    \\n    // tabulation // bottom-up approach\\n    \\n    // base case - when i will be 0, dp[0][j] will be matrix[0][j]\\n    for(let j = 0; j < m; j++) dp[0][j] = matrix[0][j]\\n    \\n    for(let i = 1; i < n; i++) {\\n        for(let j = 0 ; j < m; j++) {\\n            let up = matrix[i][j] + dp[i - 1][j];\\n            \\n            let upLeft = matrix[i][j];\\n            if((j - 1) >= 0) upLeft += dp[i - 1][j - 1]; // if not out of bound\\n            else upLeft += 10000; // big enough number\\n            \\n            let upRight = matrix[i][j];\\n            if((j + 1) < m) upRight += dp[i - 1][j + 1]; // if not out of bound\\n            else upRight += 10000; // big enough number\\n            \\n            dp[i][j] = Math.min(up, upLeft, upRight);\\n        }\\n    }\\n    return Math.min(...dp[n - 1]);\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/7d4a3179-f9af-4a70-b2ef-3ab241a391e3_1643376563.8287063.png)\\nThis runtime is of above solution\\n\\n\\n# Dynamic Programming + Tabulation (Space optimised)\\n How it is space optimised ?\\n     In this our upleft, upRight and up value only depends on the previous row\\n     Notice we reach next row after previous row right ?\\n     So why not just use previous row to compute next value instead of creating a 2D dpArray\\n```\\nvar minFallingPathSum = function(matrix) {\\n    let n = matrix.length;\\n    let m = matrix[0].length;\\n    let prev = new Array(m).fill(0);\\n    let curr = new Array(m).fill(0);\\n    \\n    // tabulation // bottom-up approach\\n    \\n    // base case - when i will be 0, dp[0][j] will be matrix[0][j]\\n    for(let j = 0; j < m; j++) prev[j] = matrix[0][j]; \\n    \\n    for(let i = 1; i < n; i++) {\\n        for(let j = 0 ; j < m; j++) {\\n            let up = matrix[i][j] + prev[j];\\n            \\n            let upLeft = matrix[i][j];\\n            if((j - 1) >= 0) upLeft += prev[j - 1]; if not out of bound\\n            else upLeft += 10000; // big enough number\\n            \\n            let upRight = matrix[i][j];\\n            if((j + 1) < m) upRight += prev[j + 1]; // if not out of bound\\n            else upRight += 10000; // big enough number\\n            \\n            curr[j] = Math.min(up, upLeft, upRight);\\n        }\\n        prev = curr;\\n    }\\n    return Math.min(...prev);\\n};\\n```\\n\\n# Tabulation\\nT.C - O(N * M)\\nS.C - O(1)\\n```\\nconst minFallingPathSum = function(matrix) {\\n    let m = matrix.length;\\n    let n = matrix[0].length;\\n    \\n    for (let i = 1; i < m; i++) {\\n        for (let j = 0; j < n; j++) {\\n            matrix[i][j] = matrix[i][j] + Math.min(matrix[i - 1][j], matrix[i - 1][j - 1] || 10000, matrix[i - 1][j + 1] || 10000);\\n        }\\n    }\\n    return Math.min(...matrix[m - 1]);\\n};\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nvar minFallingPathSum = function(matrix) {\\n    let n = matrix.length;\\n    let m = matrix[0].length;\\n    let min = Infinity;\\n    \\n    // base case - when i will be 0, dp[0][j] will be matrix[0][j]\\n    for(let j = 0; j < m; j++) matrix[0][j] = matrix[0][j]\\n    \\n    for(let j = 0 ; j < m; j++) {\\n        min = Math.min(min, compute(n - 1, j, matrix));  \\n    }\\n    return min;\\n};\\n\\nfunction compute(i, j, matrix) {\\n    if(j < 0 || j >= matrix.length) return 10000; // big enough number\\n    \\n    if(i === 0) return matrix[0][j];\\n    \\n    let up = matrix[i][j] + compute(i - 1, j, matrix);\\n    let upLeft = matrix[i][j] + compute(i - 1, j - 1, matrix);\\n    let upRight = matrix[i][j] + compute(i - 1, j + 1, matrix);\\n    \\n    return Math.min(up, upLeft, upRight);\\n}\\n```\n```\\nvar minFallingPathSum = function(matrix) {\\n    let n = matrix.length;\\n    let m = matrix[0].length;\\n    let min = Infinity;\\n    let dp = new Array(n).fill(-1).map(() => new Array(m).fill(-1));\\n    \\n    // base case - when i will be 0, dp[0][j] will be matrix[0][j]\\n    for(let j = 0; j < m; j++) matrix[0][j] = matrix[0][j]\\n    \\n    for(let j = 0 ; j < m; j++) {\\n        min = Math.min(min, compute(n - 1, j, matrix, dp));  \\n    }\\n    \\n    return min;\\n};\\n\\nfunction compute(i, j, matrix, dp) {\\n    if(j < 0 || j >= matrix.length) return 10000; // big enough number\\n    \\n    if(i === 0) return matrix[0][j];\\n    \\n    if(dp[i][j] !== -1) return dp[i][j];\\n    \\n    let up = matrix[i][j] + compute(i - 1, j, matrix, dp);\\n    let upLeft = matrix[i][j] + compute(i - 1, j - 1, matrix, dp);\\n    let upRight = matrix[i][j] + compute(i - 1, j + 1, matrix, dp);\\n    \\n    return dp[i][j] = Math.min(up, upLeft, upRight);\\n}\\n```\n```\\nvar minFallingPathSum = function(matrix) {\\n    let n = matrix.length;\\n    let m = matrix[0].length;\\n    let dp = new Array(n).fill(0).map(() => new Array(m).fill(0));\\n    \\n    // tabulation // bottom-up approach\\n    \\n    // base case - when i will be 0, dp[0][j] will be matrix[0][j]\\n    for(let j = 0; j < m; j++) dp[0][j] = matrix[0][j]\\n    \\n    for(let i = 1; i < n; i++) {\\n        for(let j = 0 ; j < m; j++) {\\n            let up = matrix[i][j] + dp[i - 1][j];\\n            \\n            let upLeft = matrix[i][j];\\n            if((j - 1) >= 0) upLeft += dp[i - 1][j - 1]; // if not out of bound\\n            else upLeft += 10000; // big enough number\\n            \\n            let upRight = matrix[i][j];\\n            if((j + 1) < m) upRight += dp[i - 1][j + 1]; // if not out of bound\\n            else upRight += 10000; // big enough number\\n            \\n            dp[i][j] = Math.min(up, upLeft, upRight);\\n        }\\n    }\\n    return Math.min(...dp[n - 1]);\\n};\\n```\n```\\nvar minFallingPathSum = function(matrix) {\\n    let n = matrix.length;\\n    let m = matrix[0].length;\\n    let prev = new Array(m).fill(0);\\n    let curr = new Array(m).fill(0);\\n    \\n    // tabulation // bottom-up approach\\n    \\n    // base case - when i will be 0, dp[0][j] will be matrix[0][j]\\n    for(let j = 0; j < m; j++) prev[j] = matrix[0][j]; \\n    \\n    for(let i = 1; i < n; i++) {\\n        for(let j = 0 ; j < m; j++) {\\n            let up = matrix[i][j] + prev[j];\\n            \\n            let upLeft = matrix[i][j];\\n            if((j - 1) >= 0) upLeft += prev[j - 1]; if not out of bound\\n            else upLeft += 10000; // big enough number\\n            \\n            let upRight = matrix[i][j];\\n            if((j + 1) < m) upRight += prev[j + 1]; // if not out of bound\\n            else upRight += 10000; // big enough number\\n            \\n            curr[j] = Math.min(up, upLeft, upRight);\\n        }\\n        prev = curr;\\n    }\\n    return Math.min(...prev);\\n};\\n```\n```\\nconst minFallingPathSum = function(matrix) {\\n    let m = matrix.length;\\n    let n = matrix[0].length;\\n    \\n    for (let i = 1; i < m; i++) {\\n        for (let j = 0; j < n; j++) {\\n            matrix[i][j] = matrix[i][j] + Math.min(matrix[i - 1][j], matrix[i - 1][j - 1] || 10000, matrix[i - 1][j + 1] || 10000);\\n        }\\n    }\\n    return Math.min(...matrix[m - 1]);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3376335,
                "title": "c-easy-solution-dfs-and-dp",
                "content": "# Intuition\\nFrom one cell we can move to three cells. We can use DFS to traverse the successors of a cell. But here we do have some repetations. We need to avoid repetation using DP.\\n\\n# Approach\\nWe need to apply DFS and store the value in a dp table. Calculate for every column in row 1 and return the minimum.\\n\\nThe terminating cases are:\\n\\nrow>=n returns 0 as it is end.\\ncol>=n || col<0 returns INT_MAX as we cannot go outside the matrix.\\n\\nDFS:\\n\\nFor each cell calculate minimum sum path ({row+1,col-1},{row+1,col},{row+1,col+1}) and add the current cell value.\\n\\n# Complexity\\n- Time complexity:\\nO(N^2)\\n\\n- Space complexity:\\nO(N^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint dfs(vector<vector<int>>&matrix,int row,int col,vector<vector<int>>&dp,int n){\\n    if(row>=n){\\n        return 0;\\n    }\\n    if(col>=n || col<0){\\n        return INT_MAX;\\n    }\\n    if(dp[row][col] != -1){\\n        return dp[row][col];\\n    }\\n    return dp[row][col] = matrix[row][col]+min({dfs(matrix,row+1,col-1,dp,n),dfs(matrix,row+1,col,dp,n),dfs(matrix,row+1,col+1,dp,n)});\\n}\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int ans = INT_MAX;\\n        vector<vector<int>>dp(n,vector<int>(n,-1));\\n        for(int i = 0;i<n;i++){\\n            ans = min(ans,dfs(matrix,0,i,dp,n));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint dfs(vector<vector<int>>&matrix,int row,int col,vector<vector<int>>&dp,int n){\\n    if(row>=n){\\n        return 0;\\n    }\\n    if(col>=n || col<0){\\n        return INT_MAX;\\n    }\\n    if(dp[row][col] != -1){\\n        return dp[row][col];\\n    }\\n    return dp[row][col] = matrix[row][col]+min({dfs(matrix,row+1,col-1,dp,n),dfs(matrix,row+1,col,dp,n),dfs(matrix,row+1,col+1,dp,n)});\\n}\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int ans = INT_MAX;\\n        vector<vector<int>>dp(n,vector<int>(n,-1));\\n        for(int i = 0;i<n;i++){\\n            ans = min(ans,dfs(matrix,0,i,dp,n));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2908134,
                "title": "c-just-do-as-question-says",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust did what was asked in the question and return the minimum of all the possibilites, that is, *minimum of all the path sum obtained after considering every element in first row*\\n# Complexity\\n- Time complexity: $$O(r*c*c)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(r*c)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int helper (vector<vector<int>>&matrix, int i, int j, vector<vector<int>>&dp){\\n        if (j < 0 || j >= matrix[0].size ())\\n            return INT_MAX;\\n        \\n        if (i == matrix.size()-1)\\n            \\n            return matrix[i][j];\\n        \\n        if (dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        int ans1 = helper (matrix,i+1,j,dp);\\n        int ans2 = helper (matrix,i+1,j+1,dp);\\n        int ans3 = helper (matrix,i+1,j-1,dp);\\n        \\n        return dp[i][j] = matrix[i][j] + min (ans1,min(ans2,ans3));\\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int res = INT_MAX;\\n        vector<vector<int>> dp (matrix.size(), vector<int>(matrix[0].size(),-1));\\n        \\n        for (int i = 0; i < matrix[0].size(); i++){\\n            res= min (res,helper (matrix,0,i,dp));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper (vector<vector<int>>&matrix, int i, int j, vector<vector<int>>&dp){\\n        if (j < 0 || j >= matrix[0].size ())\\n            return INT_MAX;\\n        \\n        if (i == matrix.size()-1)\\n            \\n            return matrix[i][j];\\n        \\n        if (dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        int ans1 = helper (matrix,i+1,j,dp);\\n        int ans2 = helper (matrix,i+1,j+1,dp);\\n        int ans3 = helper (matrix,i+1,j-1,dp);\\n        \\n        return dp[i][j] = matrix[i][j] + min (ans1,min(ans2,ans3));\\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int res = INT_MAX;\\n        vector<vector<int>> dp (matrix.size(), vector<int>(matrix[0].size(),-1));\\n        \\n        for (int i = 0; i < matrix[0].size(); i++){\\n            res= min (res,helper (matrix,0,i,dp));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2907009,
                "title": "dp-with-memoization",
                "content": "I am not proud of this code, but it works. DP with Memoization:\\n```csharp\\npublic class Solution\\n{\\n    public int MinFallingPathSum(int[][] m)\\n    {\\n        Dictionary<(int, int), int> memo = new();\\n        return m[0].Select((x, i) => dp(0, i)).Min();\\n\\n        int dp(int i, int j, int sum = 0) =>\\n            memo.ContainsKey((i, j)) ? memo[(i, j)]\\n            : i == m.Length ? sum\\n            : j < 0 || j == m[0].Length ? 1_000_000\\n            : memo[(i, j)] = m[i][j]\\n                + Math.Min(\\n                    dp(i + 1, j, sum),\\n                    Math.Min(\\n                        dp(i + 1, j - 1, sum),\\n                        dp(i + 1, j + 1, sum)\\n                    )\\n                );\\n    } \\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Memoization"
                ],
                "code": "```csharp\\npublic class Solution\\n{\\n    public int MinFallingPathSum(int[][] m)\\n    {\\n        Dictionary<(int, int), int> memo = new();\\n        return m[0].Select((x, i) => dp(0, i)).Min();\\n\\n        int dp(int i, int j, int sum = 0) =>\\n            memo.ContainsKey((i, j)) ? memo[(i, j)]\\n            : i == m.Length ? sum\\n            : j < 0 || j == m[0].Length ? 1_000_000\\n            : memo[(i, j)] = m[i][j]\\n                + Math.Min(\\n                    dp(i + 1, j, sum),\\n                    Math.Min(\\n                        dp(i + 1, j - 1, sum),\\n                        dp(i + 1, j + 1, sum)\\n                    )\\n                );\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2905875,
                "title": "python-dp-solution-6-lines",
                "content": "### Code\\n```\\nclass Solution:\\n    def minFallingPathSum(self, A: List[List[int]]) -> int:\\n        for i in range(1,len(A)):\\n            for j in range(1,len(A[0])-1):\\n                A[i][j] = A[i][j] + min(A[i-1][j-1], A[i-1][j], A[i-1][j+1])\\n            \\n            A[i][0] = A[i][0] + min(A[i-1][0], A[i-1][1])\\n            A[i][-1] = A[i][-1] + min(A[i-1][-2], A[i-1][-1])\\n            \\n        return min(A[-1])\\n\\n```\\n\\n### Explanation\\nIterate from 2nd row to the end of the matrix.\\nFor each element add the minimum adjacent element in the row above it.\\nSeperate the edge cases when we are at the start of the row (since we can\\'t have an element above diagonally left) and end of the row (since we can\\'t have an element diagonally above and to the right)\\n\\n![931.gif](https://assets.leetcode.com/users/images/631bc451-b3e6-4a45-bb9e-fc662ff11466_1670899992.149613.gif){:style=\\'width:200px\\'}\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minFallingPathSum(self, A: List[List[int]]) -> int:\\n        for i in range(1,len(A)):\\n            for j in range(1,len(A[0])-1):\\n                A[i][j] = A[i][j] + min(A[i-1][j-1], A[i-1][j], A[i-1][j+1])\\n            \\n            A[i][0] = A[i][0] + min(A[i-1][0], A[i-1][1])\\n            A[i][-1] = A[i][-1] + min(A[i-1][-2], A[i-1][-1])\\n            \\n        return min(A[-1])\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2403722,
                "title": "c-recursion-memoization-tabulation-space-optimization",
                "content": "The problem states that the starting point can be any cell from the first row and the ending point can be any cell in the last row. So, first let\\'s try out all the possible paths using recursion.\\n##### ***Recursive solution:***\\n***Step 1: Define the function and write Base cases.***\\n* We can define the function with two parameters i and j, where i and j represent the row and column of the matrix. `f(i, j)` -> Minimum path sum from any cell in the first row to the `cell[i][j]`.\\n* We will be doing a top-down recursion as there are multiple start points and multiple end points. So, lets start our recursion from the last row towards the first row. For the last row,` (i == N - 1)` there are multiple start points so we try out all the starting points i.e., `f(N-1,0), f(N-1,1) \\u2026\\u2026. f(N-1, M-1)`. and go upwards to the first `(i == 0)`.\\n**Base Case :**\\n* When `(i == 0)`, it means we are at the first row, we `return mat[0][j]`.\\n* At every cell we have three options (we are writing recursion from the last row to the first row): to the top cell (\\u2191), to the top-right cell(\\u2197), or to the top-left cell(\\u2196). When we go up we `return mat[i][j`] when `(i == 0)`. When we top-left cell(\\u2196)  and if we go out of the bound i.e., `j < 0` we `return 1e9` or when we go top-right cell(\\u2197) and if we go out of the bound i.e., `j > m-1` we return `1e9`.\\n\\n***Step 2: Try out all possible choices at a given index.***\\n* `top = cell[i][j] + f(cell[i-1][j])` when we move to the top cell (\\u2191).\\n* `top_left = cell[i][j] + f(cell[i-1][j-1]`) when we move to the top-left cell(\\u2196).\\n* `top_right = cell[i][j] + f(cell[i-1][j+1])` when we move to the top-right cell(\\u2197).\\n\\n***Step 3:  Take the minimum of all choices***\\n* we will return the minimum of all the choices (top, top_left, Top_right) \\n\\n***\\u274C CODE for Recursive function : | T.C \\u2013 O(3^N) | S.C \\u2013 O(N) Stack Space***\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>> &mat, int i, int j, int n) {\\n        if (j < 0 || j >= n) return 1e9; // Base Case 1: out of bound\\n        if (i == 0) return mat[i][j]; // Base Case 2: end point - 0th row\\n        int top = mat[i][j] + solve(mat, i - 1, j, n);\\n        int top_left = mat[i][j] + solve(mat, i - 1, j - 1, n);\\n        int top_right = mat[i][j] + solve(mat, i - 1, j + 1, n);\\n        return min(top, min(top_left, top_right));\\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int min_path_sum = 1e9;\\n        for (int j = 0; j < n; j++) {\\n            min_path_sum = min(min_path_sum, solve(matrix, n - 1, j, n));\\n        }\\n        return min_path_sum;\\n    }\\n};\\n```\\n**It will give TLE. So, we will Optimize it further. As we can see there are multiple overlapping sub-problems so we will store the answer of current state in an array and use it to prevent same computation everytime.**\\n\\n##### ***Memoization***\\n* Create a dp array of size [N][N] an initialize it with -1.\\n\\u2022\\t`if(dp[i][j]!=-1) return dp[i][j]` else use the recursive relation as usual but before returning from the function, we will set dp[i][j] to the solution we get.\\n\\n***\\u2705 CODE: | T.C \\u2013 O(N^2) | S.C \\u2013 O(N^2) + O(N)-Stack Space***\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>> &mat, int i, int j, int m, vector<vector<int>> &dp) {\\n        if (j < 0 || j >= m) return 1e9; // out of bound\\n        if (i == 0) return mat[i][j]; // end point - 0th row\\n        if (dp[i][j] != -1) return dp[i][j]; // Memoization\\n        int top = mat[i][j] + solve(mat, i - 1, j, m, dp);\\n        int top_left = mat[i][j] + solve(mat, i - 1, j - 1, m, dp);\\n        int top_right = mat[i][j] + solve(mat, i - 1, j + 1, m, dp);\\n        return dp[i][j] = min(top, min(top_left, top_right));\\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>> dp(n, vector<int>(m, -1));\\n        int min_path_sum = 1e9;\\n        for (int j = 0; j < m; j++) {\\n            min_path_sum = min(min_path_sum, solve(matrix, n - 1, j, m, dp));\\n        }\\n        return min_path_sum;\\n    }\\n};\\n```\\n\\n##### ***Converting Memoization to Tabulation:***\\n* Declare a dp[] array of size [N][M]. And write the base condition values, i.e., the first row of the dp[][] to the first row of the input matrix.\\n* We want to move from the first row to the last row. if we see the memoized code, values required for `dp[i][j]` are: `dp[i-1][j], dp[i-1][j-1]` and `dp[i-1][j+1]`. So, we only need the values from the \\u2018i-1\\u2019 row. As we have already filled the first row (i=0), if we start from row \\u20181\\u2019 and move downwards we will find the values correctly.\\n* We can use two nested loops to have this traversal and at last we need to return the maximum among the last row of dp array as our answer.\\n\\n***\\u2705 CODE  | T.C \\u2013 O(N^2) | S.C \\u2013 O(N^2)***\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& mat) {\\n        int n = mat.size(); // rows\\n        vector<vector<int>> dp(n, vector<int>(n, 0));\\n        int min_path_sum = 1e9;\\n        for (int j = 0; j < n; j++) // Base Case : (i == 0) precompute 1st row\\n            dp[0][j] = mat[0][j];\\n\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int down = mat[i][j] +  dp[i - 1][j];\\n                int right_diagonal = 1e9, left_diagonal = 1e9;\\n                // Check for Base condition : out of bounds\\n                if (j - 1 >= 0) left_diagonal = mat[i][j] + dp[i - 1][j - 1];\\n                if (j + 1 < n) right_diagonal = mat[i][j] +  dp[i - 1][j + 1];\\n                dp[i][j] = min(down, min(left_diagonal, right_diagonal));\\n            }\\n        }\\n        // Our answer will be the minimum of all path sum in last row\\n        for (int j = 0; j < n; j++) min_path_sum = min(min_path_sum, dp[n - 1][j]);\\n        return min_path_sum;\\n    }\\n};\\n```\\n\\n##### ***Space Optimization -->  (Best Solution)***\\n* if we closely look the relation, `dp[i][j] = matrix[i][j] + max(dp[i-1][j],dp[i-1][j-1], dp[i-1][j+1]`)). Which means we only need the previous row, to calculate `dp[i][j]`. so, we can space optimize it.\\n* Initially we can take a dummy array (say `prev`). We initialize this to the matrix first row (as done in tabulation).\\n* Now the current row only needs the `prev` row\\u2019s value in order to calculate `dp[i][j]`. we can store current row path sum in same input Matrix to optimize space.\\n* At last, we return the maximum value among all the values of the `prev` to get our answer.\\n\\n***\\u2705 CODE | T.C - O(N^2) | S.C - O(N)***\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& mat) {\\n        int n = mat.size(); // rows & cols\\n        vector<int>prev;\\n        int min_path_sum = 1e9;\\n        for (int j = 0; j < n; j++) //  (i == 0) precompute 1st row\\n            prev.push_back(mat[0][j]);\\n\\n        for (int i = 1; i < n; i++) { // Now, start from 2nd row\\n            for (int j = 0; j < n; j++) {\\n                int down = mat[i][j] +  prev[j]; // go down\\n                int right_diagonal = 1e9, left_diagonal = 1e9;\\n                if (j - 1 >= 0) left_diagonal = mat[i][j] + prev[j - 1];\\n                if (j + 1 < n) right_diagonal = mat[i][j] +  prev[j + 1];\\n                // Here we can store curr row path sum in matrix itself\\n                mat[i][j] = min(down, min(left_diagonal, right_diagonal));\\n            }\\n            prev = mat[i];\\n        }\\n        // Our answer will be the minimum of all path sum in last row\\n        for (int j = 0; j < n; j++) min_path_sum = min(min_path_sum, prev[j]);\\n        return min_path_sum;\\n    }\\n};\\n```\\n**Runtime: 17 ms, faster than 80.44% of C++ online submissions for Minimum Falling Path Sum.\\nMemory Usage: 9.9 MB, less than 83.83% of C++ online submissions for Minimum Falling Path Sum.**\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>> &mat, int i, int j, int n) {\\n        if (j < 0 || j >= n) return 1e9; // Base Case 1: out of bound\\n        if (i == 0) return mat[i][j]; // Base Case 2: end point - 0th row\\n        int top = mat[i][j] + solve(mat, i - 1, j, n);\\n        int top_left = mat[i][j] + solve(mat, i - 1, j - 1, n);\\n        int top_right = mat[i][j] + solve(mat, i - 1, j + 1, n);\\n        return min(top, min(top_left, top_right));\\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int min_path_sum = 1e9;\\n        for (int j = 0; j < n; j++) {\\n            min_path_sum = min(min_path_sum, solve(matrix, n - 1, j, n));\\n        }\\n        return min_path_sum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>> &mat, int i, int j, int m, vector<vector<int>> &dp) {\\n        if (j < 0 || j >= m) return 1e9; // out of bound\\n        if (i == 0) return mat[i][j]; // end point - 0th row\\n        if (dp[i][j] != -1) return dp[i][j]; // Memoization\\n        int top = mat[i][j] + solve(mat, i - 1, j, m, dp);\\n        int top_left = mat[i][j] + solve(mat, i - 1, j - 1, m, dp);\\n        int top_right = mat[i][j] + solve(mat, i - 1, j + 1, m, dp);\\n        return dp[i][j] = min(top, min(top_left, top_right));\\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>> dp(n, vector<int>(m, -1));\\n        int min_path_sum = 1e9;\\n        for (int j = 0; j < m; j++) {\\n            min_path_sum = min(min_path_sum, solve(matrix, n - 1, j, m, dp));\\n        }\\n        return min_path_sum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& mat) {\\n        int n = mat.size(); // rows\\n        vector<vector<int>> dp(n, vector<int>(n, 0));\\n        int min_path_sum = 1e9;\\n        for (int j = 0; j < n; j++) // Base Case : (i == 0) precompute 1st row\\n            dp[0][j] = mat[0][j];\\n\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int down = mat[i][j] +  dp[i - 1][j];\\n                int right_diagonal = 1e9, left_diagonal = 1e9;\\n                // Check for Base condition : out of bounds\\n                if (j - 1 >= 0) left_diagonal = mat[i][j] + dp[i - 1][j - 1];\\n                if (j + 1 < n) right_diagonal = mat[i][j] +  dp[i - 1][j + 1];\\n                dp[i][j] = min(down, min(left_diagonal, right_diagonal));\\n            }\\n        }\\n        // Our answer will be the minimum of all path sum in last row\\n        for (int j = 0; j < n; j++) min_path_sum = min(min_path_sum, dp[n - 1][j]);\\n        return min_path_sum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& mat) {\\n        int n = mat.size(); // rows & cols\\n        vector<int>prev;\\n        int min_path_sum = 1e9;\\n        for (int j = 0; j < n; j++) //  (i == 0) precompute 1st row\\n            prev.push_back(mat[0][j]);\\n\\n        for (int i = 1; i < n; i++) { // Now, start from 2nd row\\n            for (int j = 0; j < n; j++) {\\n                int down = mat[i][j] +  prev[j]; // go down\\n                int right_diagonal = 1e9, left_diagonal = 1e9;\\n                if (j - 1 >= 0) left_diagonal = mat[i][j] + prev[j - 1];\\n                if (j + 1 < n) right_diagonal = mat[i][j] +  prev[j + 1];\\n                // Here we can store curr row path sum in matrix itself\\n                mat[i][j] = min(down, min(left_diagonal, right_diagonal));\\n            }\\n            prev = mat[i];\\n        }\\n        // Our answer will be the minimum of all path sum in last row\\n        for (int j = 0; j < n; j++) min_path_sum = min(min_path_sum, prev[j]);\\n        return min_path_sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2005104,
                "title": "java-4-solutions-simple-easy-clean-code",
                "content": "```\\nBELOW ARE THE  POSSIBLE SOLUTIONS\\n```\\n_Comment if anything is wrong!_\\n\\n-------------------------------------\\n__1. NAIVE SOLUTION__\\n```\\n`NAIVE SOLUTION WITH WORST TIME COMPLEXITY[EXPONENTIAL]`\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        \\n        int m = matrix.length, n = matrix[0].length;\\n        int result = Integer.MAX_VALUE;\\n        \\n        for(int i = 0; i < n; i++)\\n            result = Math.min(result, solve(m - 1, i, matrix, dp));\\n        \\n        return result;\\n    }\\n    \\n    private int solve(int m, int n, int[][] matrix, int[][] dp){\\n        \\n        if(n < 0 || n >= matrix[m].length) return Integer.MAX_VALUE;\\n        \\n        if(m == 0) return matrix[0][n];\\n    \\n        int up = solve(m - 1, n, matrix, dp);\\n        int left = solve(m - 1, n - 1, matrix, dp);\\n        int right = solve(m - 1, n + 1, matrix, dp);\\n        \\n        return Math.min(Math.min(left, right), up) + matrix[m][n];\\n        \\n    }   \\n}\\n```\\n__2. MEMOIZED SOLUTION__\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        \\n        int m = matrix.length, n = matrix[0].length;\\n        int result = Integer.MAX_VALUE;\\n        \\n        int[][] dp = new int[m][n];\\n        for(int[] row : dp) Arrays.fill(row, Integer.MAX_VALUE);\\n        \\n        for(int i = 0; i < n; i++)\\n            result = Math.min(result, solve(m - 1, i, matrix, dp));\\n        \\n        return result;\\n    }\\n    \\n    private int solve(int m, int n, int[][] matrix, int[][] dp){\\n        \\n        if(n < 0 || n >= matrix[m].length) return Integer.MAX_VALUE;\\n        \\n        if(m == 0) return dp[m][n] = matrix[0][n];\\n        \\n        if(dp[m][n] != Integer.MAX_VALUE) return dp[m][n];\\n        \\n        int up = solve(m - 1, n, matrix, dp);\\n        int left = solve(m - 1, n - 1, matrix, dp);\\n        int right = solve(m - 1, n + 1, matrix, dp);\\n        \\n        return dp[m][n] = Math.min(Math.min(left, right), up) + matrix[m][n];\\n        \\n    }\\n}\\n```\\n__3.TABULATION__\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        int m = matrix.length, n = matrix[0].length;\\n        int result = Integer.MAX_VALUE;\\n        \\n        int[][] dp = new int[m][n];\\n        \\n        //BASE CASE\\n        for(int i = 0; i < n; i++) dp[0][i] = matrix[0][i];\\n        \\n        for(int i = 1; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                int up = matrix[i][j] + dp[i - 1][j], left = matrix[i][j], right = matrix[i][j];\\n                \\n                if(j> 0) left += dp[i - 1][j - 1];\\n                else left = (int)Math.pow(10,9);\\n                \\n                if(j < n - 1) right += dp[i - 1][j + 1];\\n                else right = (int)Math.pow(10,9);\\n                \\n                dp[i][j] = Math.min(up, Math.min(left, right));\\n                \\n                // result = Math.min(result, dp[i][j]);\\n            }\\n        }\\n        \\n        for(int i = 0; i < n; i++)\\n            result = Math.min(result, dp[m - 1][i]);\\n        \\n        return result;\\n    }\\n}\\n```\\n__4. SPACE OPTIMIZED TABULATION__\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        int m = matrix.length, n = matrix[0].length;\\n        int result = Integer.MAX_VALUE;\\n        \\n        int[] dp = new int[n];\\n        \\n        //BASE CASE\\n        for(int i = 0; i < n; i++) dp[i] = matrix[0][i];\\n        \\n        \\n        for(int i = 1; i < m; i++){\\n            int[] temp = new int[n];\\n            for(int j = 0; j < n; j++){\\n                int up = matrix[i][j] + dp[j], left = matrix[i][j], right = matrix[i][j];\\n                \\n                if(j > 0) left += dp[j - 1];\\n                else left = (int)Math.pow(10,9);\\n                \\n                if(j < n - 1) right += dp[j + 1];\\n                else right = (int)Math.pow(10,9);\\n                \\n                temp[j] = Math.min(up, Math.min(left, right));\\n                \\n            }\\n            dp = temp;\\n        }\\n        \\n        for(int i = 0; i < n; i++)\\n            result = Math.min(result, dp[i]);\\n        \\n        return result;\\n    }\\n}\\n```\\n\\n__UPVOTE WOULBE APPRECIATED \\uD83D\\uDE4F\\uD83C\\uDFFB \\uD83D\\uDD25__\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nBELOW ARE THE  POSSIBLE SOLUTIONS\\n```\n```\\n`NAIVE SOLUTION WITH WORST TIME COMPLEXITY[EXPONENTIAL]`\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        \\n        int m = matrix.length, n = matrix[0].length;\\n        int result = Integer.MAX_VALUE;\\n        \\n        for(int i = 0; i < n; i++)\\n            result = Math.min(result, solve(m - 1, i, matrix, dp));\\n        \\n        return result;\\n    }\\n    \\n    private int solve(int m, int n, int[][] matrix, int[][] dp){\\n        \\n        if(n < 0 || n >= matrix[m].length) return Integer.MAX_VALUE;\\n        \\n        if(m == 0) return matrix[0][n];\\n    \\n        int up = solve(m - 1, n, matrix, dp);\\n        int left = solve(m - 1, n - 1, matrix, dp);\\n        int right = solve(m - 1, n + 1, matrix, dp);\\n        \\n        return Math.min(Math.min(left, right), up) + matrix[m][n];\\n        \\n    }   \\n}\\n```\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        \\n        int m = matrix.length, n = matrix[0].length;\\n        int result = Integer.MAX_VALUE;\\n        \\n        int[][] dp = new int[m][n];\\n        for(int[] row : dp) Arrays.fill(row, Integer.MAX_VALUE);\\n        \\n        for(int i = 0; i < n; i++)\\n            result = Math.min(result, solve(m - 1, i, matrix, dp));\\n        \\n        return result;\\n    }\\n    \\n    private int solve(int m, int n, int[][] matrix, int[][] dp){\\n        \\n        if(n < 0 || n >= matrix[m].length) return Integer.MAX_VALUE;\\n        \\n        if(m == 0) return dp[m][n] = matrix[0][n];\\n        \\n        if(dp[m][n] != Integer.MAX_VALUE) return dp[m][n];\\n        \\n        int up = solve(m - 1, n, matrix, dp);\\n        int left = solve(m - 1, n - 1, matrix, dp);\\n        int right = solve(m - 1, n + 1, matrix, dp);\\n        \\n        return dp[m][n] = Math.min(Math.min(left, right), up) + matrix[m][n];\\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        int m = matrix.length, n = matrix[0].length;\\n        int result = Integer.MAX_VALUE;\\n        \\n        int[][] dp = new int[m][n];\\n        \\n        //BASE CASE\\n        for(int i = 0; i < n; i++) dp[0][i] = matrix[0][i];\\n        \\n        for(int i = 1; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                int up = matrix[i][j] + dp[i - 1][j], left = matrix[i][j], right = matrix[i][j];\\n                \\n                if(j> 0) left += dp[i - 1][j - 1];\\n                else left = (int)Math.pow(10,9);\\n                \\n                if(j < n - 1) right += dp[i - 1][j + 1];\\n                else right = (int)Math.pow(10,9);\\n                \\n                dp[i][j] = Math.min(up, Math.min(left, right));\\n                \\n                // result = Math.min(result, dp[i][j]);\\n            }\\n        }\\n        \\n        for(int i = 0; i < n; i++)\\n            result = Math.min(result, dp[m - 1][i]);\\n        \\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        int m = matrix.length, n = matrix[0].length;\\n        int result = Integer.MAX_VALUE;\\n        \\n        int[] dp = new int[n];\\n        \\n        //BASE CASE\\n        for(int i = 0; i < n; i++) dp[i] = matrix[0][i];\\n        \\n        \\n        for(int i = 1; i < m; i++){\\n            int[] temp = new int[n];\\n            for(int j = 0; j < n; j++){\\n                int up = matrix[i][j] + dp[j], left = matrix[i][j], right = matrix[i][j];\\n                \\n                if(j > 0) left += dp[j - 1];\\n                else left = (int)Math.pow(10,9);\\n                \\n                if(j < n - 1) right += dp[j + 1];\\n                else right = (int)Math.pow(10,9);\\n                \\n                temp[j] = Math.min(up, Math.min(left, right));\\n                \\n            }\\n            dp = temp;\\n        }\\n        \\n        for(int i = 0; i < n; i++)\\n            result = Math.min(result, dp[i]);\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1931580,
                "title": "recursion-memoization-tabulation-optimization",
                "content": "**Recursion:**\\nTC: O(3^M) where M is no. of rows\\nSC: O(M) where M is no. of rows\\n\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] a) {\\n        int min = Integer.MAX_VALUE;\\n        int m = a.length;\\n        int n = a[0].length;\\n        \\n        for(int j = 0; j<n; j++){\\n            int temp = help(m-1,j,a);\\n            min = Math.min(min,temp);\\n        }\\n        return min;\\n    }\\n    public int help(int i, int j, int[][] a){\\n        \\n        if(i<0 || j<0 || j>a[0].length-1) return (int)Math.pow(10,9);\\n        if(i==0) return a[i][j];\\n        \\n        int left = a[i][j] + help(i-1,j-1,a);\\n        int up = a[i][j] + help(i-1,j,a);\\n        int right = a[i][j] + help(i-1,j+1,a);\\n        \\n        return Math.min(left,Math.min(up,right));\\n    }\\n}\\n```\\n\\n\\n\\n**Memoization:**\\nTC: O(M x N) \\nSC: O(M) + O(M xN) \\n\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] a) {\\n        int min = Integer.MAX_VALUE;\\n        int m = a.length;\\n        int n = a[0].length;\\n        int[][] dp=new int[m][n];\\n        for(int[] row: dp) Arrays.fill(row,-1);\\n        for(int j = 0; j<n; j++){\\n            int temp = help(m-1,j,a,dp);\\n            min = Math.min(min,temp);\\n        }\\n        return min;\\n    }\\n    public int help(int i, int j, int[][] a,int[][] dp){\\n        \\n        if(i<0 || j<0 || j>a[0].length-1) return (int)Math.pow(10,9);\\n        if(i==0) return a[i][j];\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int left = a[i][j] + help(i-1,j-1,a,dp);\\n        int up = a[i][j] + help(i-1,j,a,dp);\\n        int right = a[i][j] + help(i-1,j+1,a,dp);\\n        \\n        return dp[i][j] = Math.min(left,Math.min(up,right));\\n    }\\n}\\n```\\n\\n\\n**Tabulation:**\\nTC: O(M x N) \\nSC: O(M x N) \\n\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] a) {\\n        int min = Integer.MAX_VALUE;\\n        int m = a.length;\\n        int n = a[0].length;\\n        \\n        int[][] dp=new int[m][n];\\n        for(int[] row: dp) Arrays.fill(row,-1);\\n        for(int j = 0; j<n; j++) dp[0][j] = a[0][j];\\n        \\n        for(int i = 1; i<m; i++){\\n            for(int j =0; j<n; j++){\\n                \\n                int left = a[i][j];\\n                if(j>0) left += dp[i-1][j-1];\\n                else left += (int)Math.pow(10,9);\\n                \\n                int up = a[i][j] + dp[i-1][j];\\n                \\n                int right = a[i][j];\\n                if(j<a[0].length-1) right += dp[i-1][j+1];\\n                else right = (int)Math.pow(10,9);\\n                \\n                dp[i][j] = Math.min(left,Math.min(up,right));\\n            }\\n        }\\n        \\n        for(int j = 0; j<n; j++){\\n            min = Math.min(min,dp[n-1][j]);\\n        }\\n        return min;\\n    }\\n}\\n```\\n\\n\\n**Space Optimization:**\\nTC: O(M X N)\\nSC: O(M) Where M is no. of rows\\n\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] a) {\\n        int min = Integer.MAX_VALUE;\\n        int m = a.length;\\n        int n = a[0].length;\\n        \\n        int[] dp=new int[n];\\n        Arrays.fill(dp,-1);\\n        for(int j = 0; j<n; j++) dp[j] = a[0][j];\\n        \\n        for(int i = 1; i<m; i++){\\n            int[] curr=new int[n];\\n            for(int j =0; j<n; j++){\\n                \\n                int left = a[i][j];\\n                if(j>0) left += dp[j-1];\\n                else left += (int)Math.pow(10,9);\\n                \\n                int up = a[i][j] + dp[j];\\n                \\n                int right = a[i][j];\\n                if(j<a[0].length-1) right += dp[j+1];\\n                else right = (int)Math.pow(10,9);\\n                \\n                curr[j] = Math.min(left,Math.min(up,right));\\n            }\\n            dp=curr;\\n        }\\n        \\n        for(int j = 0; j<n; j++){\\n            min = Math.min(min,dp[j]);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] a) {\\n        int min = Integer.MAX_VALUE;\\n        int m = a.length;\\n        int n = a[0].length;\\n        \\n        for(int j = 0; j<n; j++){\\n            int temp = help(m-1,j,a);\\n            min = Math.min(min,temp);\\n        }\\n        return min;\\n    }\\n    public int help(int i, int j, int[][] a){\\n        \\n        if(i<0 || j<0 || j>a[0].length-1) return (int)Math.pow(10,9);\\n        if(i==0) return a[i][j];\\n        \\n        int left = a[i][j] + help(i-1,j-1,a);\\n        int up = a[i][j] + help(i-1,j,a);\\n        int right = a[i][j] + help(i-1,j+1,a);\\n        \\n        return Math.min(left,Math.min(up,right));\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] a) {\\n        int min = Integer.MAX_VALUE;\\n        int m = a.length;\\n        int n = a[0].length;\\n        int[][] dp=new int[m][n];\\n        for(int[] row: dp) Arrays.fill(row,-1);\\n        for(int j = 0; j<n; j++){\\n            int temp = help(m-1,j,a,dp);\\n            min = Math.min(min,temp);\\n        }\\n        return min;\\n    }\\n    public int help(int i, int j, int[][] a,int[][] dp){\\n        \\n        if(i<0 || j<0 || j>a[0].length-1) return (int)Math.pow(10,9);\\n        if(i==0) return a[i][j];\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int left = a[i][j] + help(i-1,j-1,a,dp);\\n        int up = a[i][j] + help(i-1,j,a,dp);\\n        int right = a[i][j] + help(i-1,j+1,a,dp);\\n        \\n        return dp[i][j] = Math.min(left,Math.min(up,right));\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] a) {\\n        int min = Integer.MAX_VALUE;\\n        int m = a.length;\\n        int n = a[0].length;\\n        \\n        int[][] dp=new int[m][n];\\n        for(int[] row: dp) Arrays.fill(row,-1);\\n        for(int j = 0; j<n; j++) dp[0][j] = a[0][j];\\n        \\n        for(int i = 1; i<m; i++){\\n            for(int j =0; j<n; j++){\\n                \\n                int left = a[i][j];\\n                if(j>0) left += dp[i-1][j-1];\\n                else left += (int)Math.pow(10,9);\\n                \\n                int up = a[i][j] + dp[i-1][j];\\n                \\n                int right = a[i][j];\\n                if(j<a[0].length-1) right += dp[i-1][j+1];\\n                else right = (int)Math.pow(10,9);\\n                \\n                dp[i][j] = Math.min(left,Math.min(up,right));\\n            }\\n        }\\n        \\n        for(int j = 0; j<n; j++){\\n            min = Math.min(min,dp[n-1][j]);\\n        }\\n        return min;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] a) {\\n        int min = Integer.MAX_VALUE;\\n        int m = a.length;\\n        int n = a[0].length;\\n        \\n        int[] dp=new int[n];\\n        Arrays.fill(dp,-1);\\n        for(int j = 0; j<n; j++) dp[j] = a[0][j];\\n        \\n        for(int i = 1; i<m; i++){\\n            int[] curr=new int[n];\\n            for(int j =0; j<n; j++){\\n                \\n                int left = a[i][j];\\n                if(j>0) left += dp[j-1];\\n                else left += (int)Math.pow(10,9);\\n                \\n                int up = a[i][j] + dp[j];\\n                \\n                int right = a[i][j];\\n                if(j<a[0].length-1) right += dp[j+1];\\n                else right = (int)Math.pow(10,9);\\n                \\n                curr[j] = Math.min(left,Math.min(up,right));\\n            }\\n            dp=curr;\\n        }\\n        \\n        for(int j = 0; j<n; j++){\\n            min = Math.min(min,dp[j]);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935121,
                "title": "java-recursion-with-memorization",
                "content": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] A) {\\n        int[][] memo = new int[A.length][A[0].length];\\n        \\n        // In the first row, we can start at any element\\n        // Find the min path\\n        int ans = Integer.MAX_VALUE;\\n        for(int j = 0; j < A[0].length; j++) {\\n            ans = Math.min(ans, dp(A, 0, j, memo));    \\n        }\\n        \\n        return ans;\\n    }\\n    \\n    // Defination: Falling from the first row, find the shortest path to reach the last row\\n    private int dp(int[][] A, int i, int j, int[][] memo) {\\n        // Base case\\n        // 1. No more row to falling\\n        if(i >= A.length) return 0;\\n        // 2. Invalid column index\\n        if(j < 0 || j >= A[0].length) return Integer.MAX_VALUE;\\n        // 3. If we are already solved it, return the result\\n        if(memo[i][j] != 0) return memo[i][j];\\n        \\n        // Make choice\\n\\t\\t// We have three choices to falling whitch is from the left(j - 1), center(j) or right(j + 1)\\n        return memo[i][j] = A[i][j] + min(dp(A, i + 1, j - 1, memo),\\n                                       dp(A, i + 1, j + 1, memo),\\n                                       dp(A, i + 1, j, memo));\\n    }\\n    \\n    private int min(int a, int b, int c) {\\n        return Math.min(Math.min(a, b), c);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] A) {\\n        int[][] memo = new int[A.length][A[0].length];\\n        \\n        // In the first row, we can start at any element\\n        // Find the min path\\n        int ans = Integer.MAX_VALUE;\\n        for(int j = 0; j < A[0].length; j++) {\\n            ans = Math.min(ans, dp(A, 0, j, memo));    \\n        }\\n        \\n        return ans;\\n    }\\n    \\n    // Defination: Falling from the first row, find the shortest path to reach the last row\\n    private int dp(int[][] A, int i, int j, int[][] memo) {\\n        // Base case\\n        // 1. No more row to falling\\n        if(i >= A.length) return 0;\\n        // 2. Invalid column index\\n        if(j < 0 || j >= A[0].length) return Integer.MAX_VALUE;\\n        // 3. If we are already solved it, return the result\\n        if(memo[i][j] != 0) return memo[i][j];\\n        \\n        // Make choice\\n\\t\\t// We have three choices to falling whitch is from the left(j - 1), center(j) or right(j + 1)\\n        return memo[i][j] = A[i][j] + min(dp(A, i + 1, j - 1, memo),\\n                                       dp(A, i + 1, j + 1, memo),\\n                                       dp(A, i + 1, j, memo));\\n    }\\n    \\n    private int min(int a, int b, int c) {\\n        return Math.min(Math.min(a, b), c);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 695035,
                "title": "workings-how-i-solved-the-problem",
                "content": "**Orientation:**\\n- ***read the problem***:\\n\\t- square of integers (array of array)\\n\\t- find min sum path with constraints on choice\\n- ***hypothesis***: a 2d array A with size n*n where ??? < |A| < ???\\n- ***conclusion***:  the minimum sum subarray (given the constraints)\\n- ***categorize***:\\n\\t- combinatorial\\n- ***search space***:\\n\\t- exponential? I think this is factorial because it is n choose k.  Either way, brute force is not polynomial which leads me to believe a DP or Greedy solution may apply if we can prove optimal substructure\\n- ***brainstorm***:\\n\\t- start with visualizing and stepping through an example to find brute force algorithm:\\n\\t\\t- make the problem easier while you step through\\n\\t\\t\\t- what if there were no negative numbers?\\n\\t\\t\\t- what if you just chose a single column and returned the sum?\\n\\t\\t\\t- what if you didn\\'t care about the min sum?\\n\\t\\t- look at extreme examples\\n\\t\\t\\t- what is the smallest valid input?\\n\\t\\t\\t- what if all numbers are equal?\\n\\t\\t\\t- what if all min numbers form a diagonal\\n\\t\\t- look at the problem backwards\\n\\t\\t\\t- go from a complete set to the starting point\\n\\t- evaluate DP and Greedy criteria\\n\\t- if not possible, come back to orientation...\\n\\n**Visualize and Step Through Example:**\\n- input: A[[1,2,3],[4,5,6],[7,8,9]]\\n- output: [1,4,7]\\n\\n| i \\tj|  0 \\t| 1  \\t| 2  \\t|  \\n|---\\t|---\\t|---\\t|---\\t|\\n|   **0**\\t|   1\\t|  2 \\t|  3 \\t|   \\t\\n|   **1**\\t|   4\\t|  5 \\t|  6 \\t|   \\t\\n|   **2**\\t|   7\\t|  8 \\t| 9  \\t|   \\t\\n\\n**Make it easy - find the smallest sum column:**\\nSpecialize the problem and constrain it to make it easier and generalize from there.\\n```\\nAlgorithm(A):\\n\\tminSum = Integer.MAX_VALUE\\n\\tfor int i = 0 to i < A.length\\n\\t\\tcurSum = 0\\n\\t\\tfor int j = 0 to j < A.length\\n\\t\\t\\tcurCum += A[i][j]\\n\\t\\tminSum = Math.min(minSum, curSum)\\n\\treturn minSum\\n```\\n\\n**Make it easy - recast the problem slightly:**\\nInstead of finding the min sum of an entire column, reframe the problem as: ***find the min sum of a column ending at position (i,j) in the grid A***.\\n\\n**Look for optimal substructure:**\\nMin sum ending at (0,0) is 1 + 4 + 7\\nMin sum ending at (1,0) is 4 + 7\\nMin sum ending at (2,0) is 7\\n\\n**Add implied empty sets to make the recurrence more obvious:**\\nMin sum ending at (0,0) is 1 + 4 + 7 + {}\\nMin sum ending at (1,0) is 4 + 7 + {}\\nMin sum ending at (2,0) is 7 + {}\\nMin sum ending at (3,0) is {}\\n\\n*Notice that when i > A.length, we return an empty set.*\\n\\n**Define min sum ending at position (i,j) recursively:**\\nMin sum ending at (i,j) is: \\n- i > A.length, return empty\\n- else return A[i][j] + minSumEndingAt(A, i+1, j)\\n\\n```\\nminSumEndingAt(A, i, j)\\n\\tif (i > A.length) return 0;\\n\\treturn A[i][j] + minSumEndingAt(A, i+1, j);\\n```\\n\\n**Generalize - add the choice requirement into the problem:**\\nFind the min sum ending at i,j given the choice of an element in a column to the diagonal side of or below i,j.\\n\\nWe know that when the choice is constrained to just the cell directly below i,j then the min sum ending at i,j is the value at i,j plus the min sum of i+1,j. Therefore with the new requirement we can say that the min sum ending at i,j is the min of the min sum ending at all of the available choice cells:\\n\\nmin sum at i,j = **A[i][j] + Math.min(minSEA(A,i+1,j-1), minSEA(A,i+1,j), minSEA(A,i+1,j+1))** \\nalso notice that when j < 0 or j > A.length we return a nil set\\n\\n**Visualize as a tree:**\\nSometimes helps me later on if I visualize the recursion tree, abreviate min sum ending at as *minSEA*:\\n\\n```\\n\\n\\t\\t\\t\\t _____________minSEA(0,0)____________\\n\\t\\t\\t\\t/                  |                 \\\\\\n\\t\\t\\t   /                   |                  \\\\\\n\\tminSEA(1,-1)                  minSEA(1,0)         minSEA(1,1)\\n```\\n*tree continues like this for all cells. Leaves are outside the bounds of the grid and return a nil set.*\\n\\n**Define recursive brute force algorithm:**\\n```\\nminSumEndingAt(A, i, j)\\n\\tif (i > A.length || j < 0 || j > A.length) return nil\\n\\treturn A[i][j] + Math.min(minSumEndingAt(A,i+1,j-1), minSumEndingAt(A,i+1,j), minSumEndingAt(A,i+1,j))\\n```\\n\\n**Analyze:**\\n- **time**: we know the search space is non-polynomial, I think it\\'s factorial **O(n!)** because it looks like n choose k\\n- we do a few extra recursions to make the recursive function easier to write but I\\'m not too worried about this\\n\\n**Check DP / Greedy criteria to see if we can optimize:**\\n- does the problem have optimal substructure? yes, the optimal solution for the min sum ending at (i,j) contains the optimal solution to the min sum ending at one of the three cells below (i,j)\\n- have we defined the problem recursively? yes, above\\n- is there symmetry in the search space that we can exploit? yes, solutions to problems depend on the same solutions to sub problems which we can double check by looking at a table of optimal solutions:\\n\\n|  **min ending at cell:** \\t|   **min subset:**\\t|   **resursive solution:**\\t|   \\t   \\t\\n|---\\t|---\\t|---\\t\\n|  (2,0) \\t|   [7]\\t|   \\t|   \\t   \\t\\n|  (1,0) \\t|   [**4,7**]\\t|   4 + min (minSEA(2,0),minSEA(2,1)\\t|   \\t   \\t\\n|  (0,0)\\t|   [1,**4,7**]\\t|  1 + min (minSEA(1,0),minSEA(0,1) \\t|   \\t \\t\\n|  (2,1) \\t|   [8]\\t|   \\t|   \\t \\t\\n|  (1,1) \\t|   [5,7]\\t|   5 + min (minSEA(2,0), minSEA(2,1), minSEA(2,2))\\t|   \\t \\t\\n|  (0,1) \\t|   [2,**4,7**]\\t|   2 + min (minSEA(1,0), minSEA(1,1), minSEA(1,2))\\t|   \\t \\t\\n|  (2,2)\\t|   [9]\\t|   \\t|   \\t \\t\\n|  (1,2) \\t|   [6,8]\\t|   6 + min (minSEA(2,1), minSEA(2,2))\\t|   \\t \\t\\n|  (0,2) \\t|   [3,5,7]\\t|   3 + min (minSEA(1,1), minSEA(1,2))\\t|   \\t \\t\\n\\n**Looks like DP applies, add memoization to optimize the recursive algorithm:**\\nBasically the same as our algorithm but use a hash to store the computed min sum ending at i,j:\\n\\n```\\nhash[][]\\nminSumEndingAt(A,i,j)\\n\\tif (i > A.length || j < 0 || j > A.length) return nil\\n\\tif (hash[i][j] != nil) return hash[i][j]\\n\\n\\thash[i][j] = A[i][j] + Math.min(minSumEndingAt(A,i+1,j-1), minSumEndingAt(A,i+1,j), minSumEndingAt(A,i+1,j))\\n\\treturn hash[i][j]\\n```\\n\\n**Analyze:**\\n- **time**: we now only compute the value of a sub problem once and so the number of computations is now linear with regards to the number of cells. **O(n)**\\n- **space**: we need space for the hash proportional to the number of cells in the input and we need space for the recursion tree proportional to the height of the tree which is A.length or just **O(n)**\\n\\n**Transpose into Java:**\\nbreak out some smaller problems that I need to solve as I transpose:\\n- how to define the base case where i or j is out of bounds? easiest way I can think of is to use Integer.MAX_VALUE as we\\'re calculating min sums, will need to assume that the sum will be less than that so that I can test if a sub problem yields MAX_VALUE, and count it as 0 in my sum calculation.\\n- how to initialize the hash? easiest way I can think of is to assume the min sum will always be greater than 0\\n\\nmake assumptions to make the code easier to write:\\n- 0 < minSumEndingAt(i,j) < Integer.MAX_VALUE\\n\\n```\\nclass Solution {\\n    int[][] hash;\\n    \\n    public int minFallingPathSum(int[][] A) {\\n        int min = Integer.MAX_VALUE;\\n        hash = new int[A.length][A.length];\\n        for (int j = 0; j < A.length; j++) {\\n            min = Math.min(min, minSumEndingHere(A, 0, j));\\n        }\\n        return min;\\n    }\\n    \\n    private int minSumEndingHere(int[][] A, int i, int j) {\\n        if      (j < 0 || j > A.length - 1 || i > A.length - 1) return Integer.MAX_VALUE;\\n        else if (hash[i][j] != 0)                               return hash[i][j];\\n        \\n        int left    = minSumEndingHere(A, i+1, j-1);\\n        int mid     = minSumEndingHere(A, i+1, j);\\n        int right   = minSumEndingHere(A, i+1, j+1);\\n        \\n        int res = min(left, mid, right);\\n        \\n        hash[i][j] = A[i][j] + (res == Integer.MAX_VALUE ? 0 : res);\\n        return hash[i][j];\\n    }\\n    \\n    private int min(int a, int b, int c) {\\n        return Math.min(Math.min(a, b), c);\\n    }\\n}\\n```\\n\\n**I really struggled with time / space complexity analysis - anyone out there who can tell me what the actual time / space is and why?**",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nAlgorithm(A):\\n\\tminSum = Integer.MAX_VALUE\\n\\tfor int i = 0 to i < A.length\\n\\t\\tcurSum = 0\\n\\t\\tfor int j = 0 to j < A.length\\n\\t\\t\\tcurCum += A[i][j]\\n\\t\\tminSum = Math.min(minSum, curSum)\\n\\treturn minSum\\n```\n```\\nminSumEndingAt(A, i, j)\\n\\tif (i > A.length) return 0;\\n\\treturn A[i][j] + minSumEndingAt(A, i+1, j);\\n```\n```\\n\\n\\t\\t\\t\\t _____________minSEA(0,0)____________\\n\\t\\t\\t\\t/                  |                 \\\\\\n\\t\\t\\t   /                   |                  \\\\\\n\\tminSEA(1,-1)                  minSEA(1,0)         minSEA(1,1)\\n```\n```\\nminSumEndingAt(A, i, j)\\n\\tif (i > A.length || j < 0 || j > A.length) return nil\\n\\treturn A[i][j] + Math.min(minSumEndingAt(A,i+1,j-1), minSumEndingAt(A,i+1,j), minSumEndingAt(A,i+1,j))\\n```\n```\\nhash[][]\\nminSumEndingAt(A,i,j)\\n\\tif (i > A.length || j < 0 || j > A.length) return nil\\n\\tif (hash[i][j] != nil) return hash[i][j]\\n\\n\\thash[i][j] = A[i][j] + Math.min(minSumEndingAt(A,i+1,j-1), minSumEndingAt(A,i+1,j), minSumEndingAt(A,i+1,j))\\n\\treturn hash[i][j]\\n```\n```\\nclass Solution {\\n    int[][] hash;\\n    \\n    public int minFallingPathSum(int[][] A) {\\n        int min = Integer.MAX_VALUE;\\n        hash = new int[A.length][A.length];\\n        for (int j = 0; j < A.length; j++) {\\n            min = Math.min(min, minSumEndingHere(A, 0, j));\\n        }\\n        return min;\\n    }\\n    \\n    private int minSumEndingHere(int[][] A, int i, int j) {\\n        if      (j < 0 || j > A.length - 1 || i > A.length - 1) return Integer.MAX_VALUE;\\n        else if (hash[i][j] != 0)                               return hash[i][j];\\n        \\n        int left    = minSumEndingHere(A, i+1, j-1);\\n        int mid     = minSumEndingHere(A, i+1, j);\\n        int right   = minSumEndingHere(A, i+1, j+1);\\n        \\n        int res = min(left, mid, right);\\n        \\n        hash[i][j] = A[i][j] + (res == Integer.MAX_VALUE ? 0 : res);\\n        return hash[i][j];\\n    }\\n    \\n    private int min(int a, int b, int c) {\\n        return Math.min(Math.min(a, b), c);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 388723,
                "title": "python3-super-easy-understanding-with-dp",
                "content": "\\tclass Solution:\\n\\t\\tdef minFallingPathSum(self, A: List[List[int]]) -> int:\\n\\t\\t\\tr=len(A)\\n\\t\\t\\tc=len(A[0])\\n\\t\\t\\tfor i in range(1,r):\\n\\t\\t\\t\\tfor j in range(c):\\n\\t\\t\\t\\t\\tif j==0:\\n\\t\\t\\t\\t\\t\\tA[i][j]+=min(A[i-1][j+1],A[i-1][j])\\n\\t\\t\\t\\t\\telif j==c-1:\\n\\t\\t\\t\\t\\t\\tA[i][j]+=min(A[i-1][j-1],A[i-1][j])\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tA[i][j]+=min(A[i-1][j-1],A[i-1][j],A[i-1][j+1])\\n\\t\\t\\treturn min(A[-1])",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef minFallingPathSum(self, A: List[List[int]]) -> int:\\n\\t\\t\\tr=len(A)\\n\\t\\t\\tc=len(A[0])\\n\\t\\t\\tfor i in range(1,r):\\n\\t\\t\\t\\tfor j in range(c):\\n\\t\\t\\t\\t\\tif j==0:\\n\\t\\t\\t\\t\\t\\tA[i][j]+=min(A[i-1][j+1],A[i-1][j])\\n\\t\\t\\t\\t\\telif j==c-1:\\n\\t\\t\\t\\t\\t\\tA[i][j]+=min(A[i-1][j-1],A[i-1][j])\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tA[i][j]+=min(A[i-1][j-1],A[i-1][j],A[i-1][j+1])\\n\\t\\t\\treturn min(A[-1])",
                "codeTag": "Java"
            },
            {
                "id": 196646,
                "title": "c-4ms-dp-solution-with-explanation",
                "content": "# Brute Force / Recursive Solution\\nThe problem can be solved with recursion by generating all possible paths and picking the one with the smallest path sum; this can be done in *O(3^array_length)* time and *O(array_length)* space on the call stack (for a very large square array, each possible starting point in the first row has roughly 3 possible next values, and each of those has three possible next values, leading to roughly 3^array_length possible paths to consider).\\n\\n# Dynamic Programming\\nWe can solve this faster with dynamic programming in *O(array_length^2)* time and *O(array_length^2)* space. Suppose we have the array:\\n```\\n1   2   3\\n4   5   6\\n7   8   9\\n```\\n\\nWhat is the minimum falling path sum (mFPS) starting at array[0][1]? It is the minimum of the mFPS\\'s starting at array[1][0], array[1][1], and array[1][2], plus the value of array[0][1]. Similarly, the mFPS starting at array[1][1] is the minimum of the mFPS\\'s starting at array[2][0], array[2][1], and array[2][2], plus the value of array[1][1]. We can generalize this into an equation:\\n\\n**mFPSThrough(r, c) = min(mFPSThrough(r+1, c-1),    mFPSThrough(r+1, c),    mFPSThrough(r+1, c+1)) + array[r][c]**\\n\\nThere are a few edge cases to keep track of.\\n* The mFPS of elements in the last row is the values of the elements themselves since they\\'re at the end of any path (i.e. mFPSThrough(i+1, ...) = 0 for i >= r).\\n* The mFPS of elements in the first and last columns should only consider two possible paths, not three; the falling path sum can\\'t go outside the bounds of the array.\\n\\nWith this in mind, we can create a DP solution using a two-dimensional array with the elements in the bottom row initialized to their values in the array. We then iterate upwards, row by row, and for each element in that row we set it to the minimum of the two or three elements directly below it, plus its value in the array. At the end, we iterate through the top row and find the smallest value, which represents the minimum falling path sum.\\n\\n```\\nint minFallingPathSum(int** A, int ARowSize, int *AColSizes) {\\n    \\n\\t// Allocate the DP matrix\\n    int* mFPSThrough = (int*) malloc(ARowSize*ARowSize*sizeof(int));\\n    \\n\\t// Initialize the bottom row base case for our DP matrix\\n    int r, c;\\n    for(c = 0; c < ARowSize; ++c) {\\n        mFPSThrough[((ARowSize-1)*ARowSize) + c] = A[ARowSize-1][c]; \\n    }\\n    \\n\\t// Iterate upwards starting from the 2nd to last row\\n    for (r = ARowSize - 2; r >= 0; r--) {\\n        for (c = 0; c < ARowSize; ++c) {\\n            int index = (r*ARowSize) + c;\\n            \\n            // All paths can take the same column for the next row, so we start with this as the mFPS value through this column\\n            int cellMin = mFPSThrough[((r + 1)*ARowSize) + c];\\n            \\n            // If not leftmost col, check path through [r+1][c-1]\\n            if (c > 0) {\\n                int leftNext = mFPSThrough[((r + 1)*ARowSize) + (c - 1)];\\n                cellMin = (cellMin < leftNext) ? cellMin : leftNext;\\n            }\\n            \\n            // If not rightmost col, check path through [r+1][c+1]\\n            if (c < (ARowSize - 1)) {\\n                int rightNext = mFPSThrough[((r + 1)*ARowSize) + (c + 1)];\\n                cellMin = (cellMin < rightNext) ? cellMin : rightNext;\\n            }\\n\\n            // Need to include current cell\\'s value for sum of path through cell\\n            mFPSThrough[index] = cellMin + A[r][c];\\n        }\\n    }\\n    \\n\\t// Now find the smallest mFPS\\n\\tint minFPSum = INT_MAX;\\n    for (c = 0; c < ARowSize; ++c) {\\n        minFPSum = (mFPSThrough[c] < minFPSum) ? mFPSThrough[c] : minFPSum;\\n    }\\n    \\n    return minFPSum;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n1   2   3\\n4   5   6\\n7   8   9\\n```\n```\\nint minFallingPathSum(int** A, int ARowSize, int *AColSizes) {\\n    \\n\\t// Allocate the DP matrix\\n    int* mFPSThrough = (int*) malloc(ARowSize*ARowSize*sizeof(int));\\n    \\n\\t// Initialize the bottom row base case for our DP matrix\\n    int r, c;\\n    for(c = 0; c < ARowSize; ++c) {\\n        mFPSThrough[((ARowSize-1)*ARowSize) + c] = A[ARowSize-1][c]; \\n    }\\n    \\n\\t// Iterate upwards starting from the 2nd to last row\\n    for (r = ARowSize - 2; r >= 0; r--) {\\n        for (c = 0; c < ARowSize; ++c) {\\n            int index = (r*ARowSize) + c;\\n            \\n            // All paths can take the same column for the next row, so we start with this as the mFPS value through this column\\n            int cellMin = mFPSThrough[((r + 1)*ARowSize) + c];\\n            \\n            // If not leftmost col, check path through [r+1][c-1]\\n            if (c > 0) {\\n                int leftNext = mFPSThrough[((r + 1)*ARowSize) + (c - 1)];\\n                cellMin = (cellMin < leftNext) ? cellMin : leftNext;\\n            }\\n            \\n            // If not rightmost col, check path through [r+1][c+1]\\n            if (c < (ARowSize - 1)) {\\n                int rightNext = mFPSThrough[((r + 1)*ARowSize) + (c + 1)];\\n                cellMin = (cellMin < rightNext) ? cellMin : rightNext;\\n            }\\n\\n            // Need to include current cell\\'s value for sum of path through cell\\n            mFPSThrough[index] = cellMin + A[r][c];\\n        }\\n    }\\n    \\n\\t// Now find the smallest mFPS\\n\\tint minFPSum = INT_MAX;\\n    for (c = 0; c < ARowSize; ++c) {\\n        minFPSum = (mFPSThrough[c] < minFPSum) ? mFPSThrough[c] : minFPSum;\\n    }\\n    \\n    return minFPSum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 186656,
                "title": "c-using-dynamic-programming",
                "content": "    int minFallingPathSum(vector<vector<int>>& A) {\n        int rows = A.size(), cols = rows ? A[0].size() : 0, i, j, k;\n        int res = INT_MAX;\n        \n        if(0 == rows || 0 == cols)\n            return 0;\n \n        for(i = 1; i < rows; i++) {\n            for(j = 0; j < cols; j++) {\n                int mn = A[i - 1][j];\n                if(j > 0)\n                    mn = min(mn, A[i - 1][j - 1]);\n                if(j < cols - 1)\n                    mn = min(mn, A[i - 1][j + 1]);\n                A[i][j] += mn;\n            }\n        }\n        for(j = 0; j < cols; j++)\n            res = min(res, A[rows - 1][j]);\n        \n        return res;\n    }",
                "solutionTags": [],
                "code": "    int minFallingPathSum(vector<vector<int>>& A) {\n        int rows = A.size(), cols = rows ? A[0].size() : 0, i, j, k;\n        int res = INT_MAX;\n        if(0 == rows || 0 == cols)\n            return 0;\n        for(i = 1; i < rows; i++) {\n            for(j = 0; j < cols; j++) {\n                int mn = A[i - 1][j];\n                if(j > 0)\n                    mn = min(mn, A[i - 1][j - 1]);\n                if(j < cols - 1)\n                    mn = min(mn, A[i - 1][j + 1]);\n                A[i][j] += mn;\n            }\n        }\n        for(j = 0; j < cols; j++)\n            res = min(res, A[rows - 1][j]);\n        return res;\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4048436,
                "title": "easy-to-understand-c",
                "content": "# Problem: Minimum Falling Path Sum\\n\\n## Intuition\\nThe goal of this problem is to find the minimum falling path sum in a given matrix. Each cell in the matrix is the sum of the current cell and the minimum of its upper adjacent cells.\\n\\n## Approach\\nWe can solve this problem using dynamic programming. We start from the second row of the matrix and, for each cell in the current row, calculate the minimum falling path sum by considering the values of the upper adjacent cells. We update each cell with the sum of its current value and the minimum of the upper adjacent cells.\\n\\nHere\\'s the step-by-step approach:\\n1. Initialize a variable `n` to represent the number of rows in the matrix.\\n2. Iterate through the rows starting from the second row (index 1) to the last row (index n-1).\\n   - For each cell in the current row, calculate the minimum falling path sum by considering the values of the upper adjacent cells.\\n   - Handle the special cases for cells at the leftmost and rightmost edges of the matrix.\\n3. After completing the iteration, the minimum falling path sum can be found in the last row of the matrix.\\n4. Return the minimum value in the last row as the result.\\n\\n## Complexity\\n- Time Complexity: O($N^2$) where N is the number of rows in the matrix, as we iterate through each cell once.\\n- Space Complexity: O(1) as we are modifying the input matrix in-place.\\n\\n## Code\\n```cpp\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n      int n = matrix.size();\\n      for(int i=1; i<n; i++) {\\n        for(int j=0; j<n; j++) {\\n          if(j==0)\\n            matrix[i][j] += min(matrix[i-1][j], matrix[i-1][j+1]);\\n          else if(j==n-1)\\n            matrix[i][j] += min(matrix[i-1][j], matrix[i-1][j-1]);\\n          else \\n            matrix[i][j] += min(matrix[i-1][j], min(matrix[i-1][j-1], matrix[i-1][j+1]));\\n        }\\n      }\\n      int ans = *min_element(matrix[n-1].begin(), matrix[n-1].end()); \\n      return ans;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "class Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n      int n = matrix.size();\\n      for(int i=1; i<n; i++) {\\n        for(int j=0; j<n; j++) {\\n          if(j==0)\\n            matrix[i][j] += min(matrix[i-1][j], matrix[i-1][j+1]);\\n          else if(j==n-1)\\n            matrix[i][j] += min(matrix[i-1][j], matrix[i-1][j-1]);\\n          else \\n            matrix[i][j] += min(matrix[i-1][j], min(matrix[i-1][j-1], matrix[i-1][j+1]));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3339256,
                "title": "best-o-n-n-solution",
                "content": "# Approach 1\\nRecursion (TLE)\\n\\n# Complexity\\n- Time complexity:\\n$$O(3^n)$$ \\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int solve(int i, int j, vector<vector<int>>& matrix, int n) {\\n        if (j < 0 || j >= n)\\n            return 1e9;\\n        if (i == 0)\\n            return matrix[i][j];\\n        int up = matrix[i][j] + solve(i-1, j, matrix, n);  \\n        int leftDiagonal = matrix[i][j] + solve(i-1, j-1, matrix, n);  \\n        int rightDiagonal = matrix[i][j] + solve(i-1, j+1, matrix, n); \\n        return min (up, min (leftDiagonal, rightDiagonal));   \\n    }\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int minSum = INT_MAX;\\n        for (int j = 0; j < n; j++) \\n            minSum = min (minSum, solve(n-1, j, matrix, n));\\n        return minSum;\\n    }\\n};\\n```\\n\\n# Approach 2\\nDP (Top Down Approach)\\n\\n# Complexity\\n- Time complexity:\\n$$O(n * n)$$\\n\\n- Space complexity:\\n$$O(n * n)$$\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int solve(int i, int j, vector<vector<int>>& matrix, vector<vector<int>>& dp, int n) {\\n        if (j < 0 || j >= n)\\n            return 1e9;\\n        if (i == 0)\\n            return matrix[i][j];\\n        if (dp[i][j] != -1)\\n            return dp[i][j];    \\n        int up = matrix[i][j] + solve(i-1, j, matrix, dp, n);  \\n        int leftDiagonal = matrix[i][j] + solve(i-1, j-1, matrix, dp, n);  \\n        int rightDiagonal = matrix[i][j] + solve(i-1, j+1, matrix, dp, n); \\n        return dp[i][j] = min (up, min (leftDiagonal, rightDiagonal));   \\n    }\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n        int minSum = INT_MAX;\\n        for (int j = 0; j < n; j++) \\n            minSum = min (minSum, solve(n-1, j, matrix, dp, n));\\n        return minSum;\\n    }\\n};\\n```\\n\\n# Approach 3\\nDP (Bottom Up Approach)\\n\\n# Complexity\\n- Time complexity:\\n$$O(n * n)$$\\n\\n- Space complexity:\\n$$O(n * n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector<vector<int>> dp(n, vector<int>(n, 0));\\n        for (int j = 0; j < n; j++) \\n            dp[0][j] = matrix[0][j];\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int up = matrix[i][j] + dp[i-1][j];  \\n                int leftDiagonal = matrix[i][j]; \\n                if (j-1 >= 0)\\n                    leftDiagonal += dp[i-1][j-1]; \\n                else\\n                    leftDiagonal += 1e9;    \\n                int rightDiagonal = matrix[i][j]; \\n                if (j+1 < n)\\n                    rightDiagonal += dp[i-1][j+1]; \\n                else\\n                    rightDiagonal += 1e9;\\n                dp[i][j] = min (up, min (leftDiagonal, rightDiagonal));   \\n            }\\n        }    \\n        int minSum = INT_MAX;\\n        for (int j = 0; j < n; j++)\\n            minSum = min (minSum, dp[n-1][j]);\\n        return minSum;\\n    }\\n};\\n```\\n\\n# Approach 4\\nDP (Bottom Up Approach) + Space Optimization\\n\\n# Complexity\\n- Time complexity:\\n$$O(n * n)$$ \\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector <int> prev(n, 0), cur(n, 0);\\n        for (int j = 0; j < n; j++) \\n           prev[j] = matrix[0][j];\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int up = matrix[i][j] + prev[j];  \\n                int leftDiagonal = matrix[i][j]; \\n                if (j-1 >= 0)\\n                    leftDiagonal += prev[j-1]; \\n                else\\n                    leftDiagonal += 1e9;    \\n                int rightDiagonal = matrix[i][j]; \\n                if (j+1 < n)\\n                    rightDiagonal += prev[j+1]; \\n                else\\n                    rightDiagonal += 1e9;\\n                cur[j] = min (up, min (leftDiagonal, rightDiagonal));   \\n            }\\n            prev = cur;\\n        }    \\n        int minSum = INT_MAX;\\n        for (int j = 0; j < n; j++)\\n            minSum = min (minSum, prev[j]);\\n        return minSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int solve(int i, int j, vector<vector<int>>& matrix, int n) {\\n        if (j < 0 || j >= n)\\n            return 1e9;\\n        if (i == 0)\\n            return matrix[i][j];\\n        int up = matrix[i][j] + solve(i-1, j, matrix, n);  \\n        int leftDiagonal = matrix[i][j] + solve(i-1, j-1, matrix, n);  \\n        int rightDiagonal = matrix[i][j] + solve(i-1, j+1, matrix, n); \\n        return min (up, min (leftDiagonal, rightDiagonal));   \\n    }\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int minSum = INT_MAX;\\n        for (int j = 0; j < n; j++) \\n            minSum = min (minSum, solve(n-1, j, matrix, n));\\n        return minSum;\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    int solve(int i, int j, vector<vector<int>>& matrix, vector<vector<int>>& dp, int n) {\\n        if (j < 0 || j >= n)\\n            return 1e9;\\n        if (i == 0)\\n            return matrix[i][j];\\n        if (dp[i][j] != -1)\\n            return dp[i][j];    \\n        int up = matrix[i][j] + solve(i-1, j, matrix, dp, n);  \\n        int leftDiagonal = matrix[i][j] + solve(i-1, j-1, matrix, dp, n);  \\n        int rightDiagonal = matrix[i][j] + solve(i-1, j+1, matrix, dp, n); \\n        return dp[i][j] = min (up, min (leftDiagonal, rightDiagonal));   \\n    }\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n        int minSum = INT_MAX;\\n        for (int j = 0; j < n; j++) \\n            minSum = min (minSum, solve(n-1, j, matrix, dp, n));\\n        return minSum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector<vector<int>> dp(n, vector<int>(n, 0));\\n        for (int j = 0; j < n; j++) \\n            dp[0][j] = matrix[0][j];\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int up = matrix[i][j] + dp[i-1][j];  \\n                int leftDiagonal = matrix[i][j]; \\n                if (j-1 >= 0)\\n                    leftDiagonal += dp[i-1][j-1]; \\n                else\\n                    leftDiagonal += 1e9;    \\n                int rightDiagonal = matrix[i][j]; \\n                if (j+1 < n)\\n                    rightDiagonal += dp[i-1][j+1]; \\n                else\\n                    rightDiagonal += 1e9;\\n                dp[i][j] = min (up, min (leftDiagonal, rightDiagonal));   \\n            }\\n        }    \\n        int minSum = INT_MAX;\\n        for (int j = 0; j < n; j++)\\n            minSum = min (minSum, dp[n-1][j]);\\n        return minSum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector <int> prev(n, 0), cur(n, 0);\\n        for (int j = 0; j < n; j++) \\n           prev[j] = matrix[0][j];\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int up = matrix[i][j] + prev[j];  \\n                int leftDiagonal = matrix[i][j]; \\n                if (j-1 >= 0)\\n                    leftDiagonal += prev[j-1]; \\n                else\\n                    leftDiagonal += 1e9;    \\n                int rightDiagonal = matrix[i][j]; \\n                if (j+1 < n)\\n                    rightDiagonal += prev[j+1]; \\n                else\\n                    rightDiagonal += 1e9;\\n                cur[j] = min (up, min (leftDiagonal, rightDiagonal));   \\n            }\\n            prev = cur;\\n        }    \\n        int minSum = INT_MAX;\\n        for (int j = 0; j < n; j++)\\n            minSum = min (minSum, prev[j]);\\n        return minSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3058953,
                "title": "beats-100-most-efficient-solution-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& v) {\\n        int N = v.size();\\n         vector<int> curr(N,0) , prev(N,0);\\n        int maxi = INT_MIN;\\n        for(int j=0;j<N;j++){\\n            prev[j] = v[0][j];      \\n        }\\n        for(int i=1;i<N;i++){\\n            for(int j=0;j<N;j++){\\n                int top    = v[i][j] + prev[j];\\n                int topleft = v[i][j]; \\n                if(j>0){\\n                    topleft += prev[j-1];\\n                }\\n                else{\\n                    topleft += 1e9;\\n                }\\n                int topright = v[i][j];\\n                if(j<N-1){\\n                    topright += prev[j+1]; \\n                }\\n                else{\\n                    topright += 1e9; \\n                }\\n                curr[j] = min(top , min(topleft,topright));\\n            }\\n            prev = curr;\\n        }\\n        \\n        \\n         maxi = INT_MAX;\\n        for(int j=0;j<N;j++){\\n            maxi = min(maxi,prev[j]);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& v) {\\n        int N = v.size();\\n         vector<int> curr(N,0) , prev(N,0);\\n        int maxi = INT_MIN;\\n        for(int j=0;j<N;j++){\\n            prev[j] = v[0][j];      \\n        }\\n        for(int i=1;i<N;i++){\\n            for(int j=0;j<N;j++){\\n                int top    = v[i][j] + prev[j];\\n                int topleft = v[i][j]; \\n                if(j>0){\\n                    topleft += prev[j-1];\\n                }\\n                else{\\n                    topleft += 1e9;\\n                }\\n                int topright = v[i][j];\\n                if(j<N-1){\\n                    topright += prev[j+1]; \\n                }\\n                else{\\n                    topright += 1e9; \\n                }\\n                curr[j] = min(top , min(topleft,topright));\\n            }\\n            prev = curr;\\n        }\\n        \\n        \\n         maxi = INT_MAX;\\n        for(int j=0;j<N;j++){\\n            maxi = min(maxi,prev[j]);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2907855,
                "title": "simple-and-easy-java-video-explanation",
                "content": "--It is not the Fastest Solution but easy to understand and implement\\n--For understanding approach refer to my page and one youtube video link is also there\\n\\n# Code\\n```\\n// Kindly upvote my solution if it helps you because it gives me motivation to explain more\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        int n = matrix.length;\\n        int[][] mat = new int[n][n];\\n\\n        // Copying 1st row of given matrix to new matriz\\n        for(int i=0; i<n; i++){\\n            mat[0][i] = matrix[0][i];\\n        }\\n\\n        // Now in second row comparing the each element\\'s sum to the element on top of it top left and top right\\n        for(int row=1; row<n; row++){\\n            for(int col=0; col<n; col++){\\n                int min = Integer.MAX_VALUE;    // i took 1000 because in constraints they have mentioned max value is 100\\n\\n                // Now taking sum of this element and it\\'s upper element and comparing with previous\\n                min = Math.min(min , matrix[row][col] + mat[row-1][col]);\\n\\n                // checking if left element of upper element in new matrix exist then doing sum of it\\n                if(col-1 >= 0)    min = Math.min(min , matrix[row][col] + mat[row-1][col-1]);\\n\\n                // Now checking if top right element in new matrix exist and comparing the same\\n                if(col+1 <= n-1)    min = Math.min(min, matrix[row][col] + mat[row-1][col+1]);\\n\\n                // Now we have got the minimum value so we will add that value to the spot\\n                mat[row][col] = min;\\n            }\\n        }\\n        // Now we just need to select the minimum value from the last row of our new matrix\\n        int answer = Integer.MAX_VALUE;\\n        for(int i=0; i<n; i++){\\n            answer = Math.min(answer , mat[n-1][i]);\\n        }\\n        return answer;\\n    }\\n}\\n```\\n[https://www.youtube.com/watch?v=oJ5leqo6vjg]()",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Kindly upvote my solution if it helps you because it gives me motivation to explain more\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        int n = matrix.length;\\n        int[][] mat = new int[n][n];\\n\\n        // Copying 1st row of given matrix to new matriz\\n        for(int i=0; i<n; i++){\\n            mat[0][i] = matrix[0][i];\\n        }\\n\\n        // Now in second row comparing the each element\\'s sum to the element on top of it top left and top right\\n        for(int row=1; row<n; row++){\\n            for(int col=0; col<n; col++){\\n                int min = Integer.MAX_VALUE;    // i took 1000 because in constraints they have mentioned max value is 100\\n\\n                // Now taking sum of this element and it\\'s upper element and comparing with previous\\n                min = Math.min(min , matrix[row][col] + mat[row-1][col]);\\n\\n                // checking if left element of upper element in new matrix exist then doing sum of it\\n                if(col-1 >= 0)    min = Math.min(min , matrix[row][col] + mat[row-1][col-1]);\\n\\n                // Now checking if top right element in new matrix exist and comparing the same\\n                if(col+1 <= n-1)    min = Math.min(min, matrix[row][col] + mat[row-1][col+1]);\\n\\n                // Now we have got the minimum value so we will add that value to the spot\\n                mat[row][col] = min;\\n            }\\n        }\\n        // Now we just need to select the minimum value from the last row of our new matrix\\n        int answer = Integer.MAX_VALUE;\\n        for(int i=0; i<n; i++){\\n            answer = Math.min(answer , mat[n-1][i]);\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2906678,
                "title": "simple-3-cases-solution-easy-to-understand-recursive-memoization-commented",
                "content": "# upvote if helpful.\\n# some knowledge:  \\nIn recursion we have two types of calls one is making the clever recursive calls and putting base case random and other is making random calls and putting base case cleverly, here i have shown how to make clever calls, where by making the below calls one can never go out of the index bound.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp; //our programs brain; currently empty \\n    int util(vector<vector<int>>& arr, int i, int j){\\n        if(i>=arr.size()){\\n            return 0;\\n        }//base case when we go out of the matrix\\n        if(dp[i][j]!= 100000)return dp[i][j]; //if we already found our answer and stored in our brain then return that answer no need to make further recursive calls.\\n        int ans=INT_MAX;\\n        if(j==0){// if j==0 =>that we can go to j, j+1th element of next row\\n            int a= arr[i][j]+util(arr, i+1, j);\\n            int b= INT_MAX;\\n            //although there can be case where we have only 1 col\\n            //edge case\\n            if(j+1<arr[0].size()) b=arr[i][j]+ util(arr, i+1, j+1);\\n            ans= min({a, b, ans});\\n        }\\n        else if(j==arr[0].size()-1){//if j==arr[0].size()=> we are at last column and\\n        //we can make only call to j, j-1th element in next row\\n            int a= arr[i][j]+util(arr, i+1, j);\\n            int b= INT_MAX;\\n            //edge case when we have only one col in matrix\\n            if(j-1>=0)b= arr[i][j]+util(arr, i+1, j-1);\\n            ans=min({a, b, ans});\\n        }else{//this case is when we not the first col, last col we are in the cols between them \\n        //so we have 3 cases as mentioned in the problem\\n            //three cases are as follows:\\n            //1) add me and go to next ele below me.\\n            //2) add me and go to diagonally left ele below me.\\n            //3) add me and go to diagonally right ele below me.\\n            int a= arr[i][j]+util(arr, i+1, j);\\n            int b= arr[i][j]+util(arr, i+1, j-1);\\n            int c= arr[i][j]+util(arr, i+1, j+1);\\n            ans= min({a, b, c, ans});\\n        }\\n        return dp[i][j]= ans;// store calculated result into the brain\\n        //so that i can easilly return calculated result without doing calculations repeatatively.\\n\\n    }\\n\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int ans=INT_MAX;\\n        dp.resize(matrix.size()+1, vector<int>(matrix[0].size()+1, 100000));//defining our brain size.\\n        //for the first row only we have any choice to choose our\\n        //starting point.\\n        //but ater that we have at max 3 choices only \\n        for(int j=0; j<matrix[0].size(); j++){\\n            int curr= util(matrix, 0, j);\\n            ans= min(ans, curr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp; //our programs brain; currently empty \\n    int util(vector<vector<int>>& arr, int i, int j){\\n        if(i>=arr.size()){\\n            return 0;\\n        }//base case when we go out of the matrix\\n        if(dp[i][j]!= 100000)return dp[i][j]; //if we already found our answer and stored in our brain then return that answer no need to make further recursive calls.\\n        int ans=INT_MAX;\\n        if(j==0){// if j==0 =>that we can go to j, j+1th element of next row\\n            int a= arr[i][j]+util(arr, i+1, j);\\n            int b= INT_MAX;\\n            //although there can be case where we have only 1 col\\n            //edge case\\n            if(j+1<arr[0].size()) b=arr[i][j]+ util(arr, i+1, j+1);\\n            ans= min({a, b, ans});\\n        }\\n        else if(j==arr[0].size()-1){//if j==arr[0].size()=> we are at last column and\\n        //we can make only call to j, j-1th element in next row\\n            int a= arr[i][j]+util(arr, i+1, j);\\n            int b= INT_MAX;\\n            //edge case when we have only one col in matrix\\n            if(j-1>=0)b= arr[i][j]+util(arr, i+1, j-1);\\n            ans=min({a, b, ans});\\n        }else{//this case is when we not the first col, last col we are in the cols between them \\n        //so we have 3 cases as mentioned in the problem\\n            //three cases are as follows:\\n            //1) add me and go to next ele below me.\\n            //2) add me and go to diagonally left ele below me.\\n            //3) add me and go to diagonally right ele below me.\\n            int a= arr[i][j]+util(arr, i+1, j);\\n            int b= arr[i][j]+util(arr, i+1, j-1);\\n            int c= arr[i][j]+util(arr, i+1, j+1);\\n            ans= min({a, b, c, ans});\\n        }\\n        return dp[i][j]= ans;// store calculated result into the brain\\n        //so that i can easilly return calculated result without doing calculations repeatatively.\\n\\n    }\\n\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int ans=INT_MAX;\\n        dp.resize(matrix.size()+1, vector<int>(matrix[0].size()+1, 100000));//defining our brain size.\\n        //for the first row only we have any choice to choose our\\n        //starting point.\\n        //but ater that we have at max 3 choices only \\n        for(int j=0; j<matrix[0].size(); j++){\\n            int curr= util(matrix, 0, j);\\n            ans= min(ans, curr);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1727944,
                "title": "c-dynamic-programming-easy-solution",
                "content": "```\\nclass Solution {\\n    int dp[102][102];\\npublic:\\n    int solve(vector<vector<int>>& matrix, int i, int j, int n, int m){\\n        if (j>=m || j<0) return INT_MAX;\\n        if (i==n-1) return matrix[i][j];\\n        if (dp[i][j]!=-1) return dp[i][j];\\n\\t\\t// now we will traverse below, diagonally_left and diagonally_right.\\n        return dp[i][j]=matrix[i][j]+min(solve(matrix,i+1,j,n,m),min(solve(matrix,i+1,j-1,n,m),solve(matrix,i+1,j+1,n,m)));\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        int min_val=INT_MAX;\\n        memset(dp,-1,sizeof(dp));\\n\\t\\t// this loop is for all elements of first row\\n        for (int i=0;i<m;i++){\\n            min_val=min(min_val,solve(matrix,0,i,n,m));\\n        }\\n        return min_val;\\n    }\\n};\\n```\\n\\nPS: do \"UPVOTE\" if you liked this solution :)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int dp[102][102];\\npublic:\\n    int solve(vector<vector<int>>& matrix, int i, int j, int n, int m){\\n        if (j>=m || j<0) return INT_MAX;\\n        if (i==n-1) return matrix[i][j];\\n        if (dp[i][j]!=-1) return dp[i][j];\\n\\t\\t// now we will traverse below, diagonally_left and diagonally_right.\\n        return dp[i][j]=matrix[i][j]+min(solve(matrix,i+1,j,n,m),min(solve(matrix,i+1,j-1,n,m),solve(matrix,i+1,j+1,n,m)));\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        int min_val=INT_MAX;\\n        memset(dp,-1,sizeof(dp));\\n\\t\\t// this loop is for all elements of first row\\n        for (int i=0;i<m;i++){\\n            min_val=min(min_val,solve(matrix,0,i,n,m));\\n        }\\n        return min_val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 948936,
                "title": "python-3-detailed-explanation-that-is-possible-to-follow",
                "content": "**Idea**:\\nCreate a ```dp``` matrix that is originally has 0 everywhere\\nThe first row will be equal to the row in the original list; we cannot do anything with it\\nThen we start filling out ```dp``` from the second row using two loops:\\n- if we are in the leftmost column, then we take the value from the original list that sits in the same position and will add to it the minimum of elements one row above: one element is just above our element, another is one step to the right\\n- if we are in the rightmost column, then we take the value from the original list that sits in the same position and will add to it the minimum of elements one row above: one element is just above our element, another is one step to the left\\n- in all other cases we take the value from the original list that sits in the same position and will add the minimum of three elements one row above: one element is just above our element, another element is one step to the left, another is one step to the right\\nThe answer is the minimum value in the last row of ```dp```\\n\\n```\\ndef minFallingPathSum(arr):\\n    dp = [[0] * len(arr[0]) for i in range(len(arr))]  # dp with zeroes\\n    for col in range(len(arr[0])):  # filling out the first row with original numbers\\n        dp[0][col] = arr[0][col]\\n    for row in range(1, len(arr)):  # two loops to fill out the rest of dp\\n        for col in range(len(arr[0])):\\n            if col == 0:  # filling out the first column starting from the second row\\n                dp[row][col] = arr[row][col] + min(dp[row - 1][col], dp[row - 1][col + 1])\\n            elif col == len(arr[0]) - 1:   # filling out the rightmost column from the second row\\n                dp[row][col] = arr[row][col] + min(dp[row - 1][col], dp[row - 1][col - 1])\\n            else:  # everything in between\\n                dp[row][col] = arr[row][col] + min(dp[row - 1][col - 1], dp[row - 1][col], dp[row - 1][col + 1])\\n    return min(dp[-1])  # return the smallest number in the last row\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```dp```\n```dp```\n```dp```\n```\\ndef minFallingPathSum(arr):\\n    dp = [[0] * len(arr[0]) for i in range(len(arr))]  # dp with zeroes\\n    for col in range(len(arr[0])):  # filling out the first row with original numbers\\n        dp[0][col] = arr[0][col]\\n    for row in range(1, len(arr)):  # two loops to fill out the rest of dp\\n        for col in range(len(arr[0])):\\n            if col == 0:  # filling out the first column starting from the second row\\n                dp[row][col] = arr[row][col] + min(dp[row - 1][col], dp[row - 1][col + 1])\\n            elif col == len(arr[0]) - 1:   # filling out the rightmost column from the second row\\n                dp[row][col] = arr[row][col] + min(dp[row - 1][col], dp[row - 1][col - 1])\\n            else:  # everything in between\\n                dp[row][col] = arr[row][col] + min(dp[row - 1][col - 1], dp[row - 1][col], dp[row - 1][col + 1])\\n    return min(dp[-1])  # return the smallest number in the last row\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 572100,
                "title": "python-o-n-2-sol-with-in-place-dp-75-w-visualization",
                "content": "Python O(n^2) sol with in-place update by dynamic programming. \\n\\n---\\n\\nAbstract model and diagram:\\n\\nGeneral case:\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1586523920.png)\\n\\n--\\n\\nSpecial case:\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1586523934.png)\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1586523730.png)\\n\\n---\\n\\n```\\nclass Solution:\\n    def minFallingPathSum(self, A: List[List[int]]) -> int:\\n        \\n        size = len(A)\\n        \\n        if size == 1:\\n            # Quick response for single row\\n            return A[0][0]\\n        \\n\\n        # Update A[y][x] from second row to last row\\n        for y in range( 1, size):\\n\\t\\t\\n\\t\\t\\t# sacn each column from 0 to size-1\\n            for x in range( size ):\\n                \\n\\t\\t\\t\\t# find falling path of minimal cost with optimal substructure\\n                min_prev = A[y-1][x] \\n                \\n                if x > 0:\\n                    min_prev = min( min_prev, A[y-1][x-1] )\\n                \\n                if x < size-1:\\n                    min_prev = min( min_prev, A[y-1][x+1] )\\n                \\n                # update the cost of falling path, destination is [y][x], with optimal substructure\\n                A[y][x] = A[y][x] + min_prev\\n                \\n        \\n        # the cost of minimum falling path is the minimum value of last row\\n        return min( A[size-1] )\\n        \\n        \\n```\\n\\n---\\n\\nShare another implementation by top-down DP:\\n\\n```\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        \\n        h, w = len(matrix), len(matrix[0])\\n        INF = sys.maxsize\\n        \\n        @cache\\n        def dp(row, col):\\n            \\n            ## Base case: top row\\n            if row == 0 and 0 <= col < w:\\n                return matrix[0][col]\\n            \\n            ## Base case: out-of boundary\\n            if col < 0 or col >= w:\\n                return INF\\n            \\n            ## General case: current cost + minimal cost of neighbor on previous row\\n            return matrix[row][col] + min( dp(row-1,col+offset) for offset in (-1, 0, 1) )\\n        \\n        # ------------------------------------------------\\n        return min( dp(h-1, col) for col in range(w) )\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minFallingPathSum(self, A: List[List[int]]) -> int:\\n        \\n        size = len(A)\\n        \\n        if size == 1:\\n            # Quick response for single row\\n            return A[0][0]\\n        \\n\\n        # Update A[y][x] from second row to last row\\n        for y in range( 1, size):\\n\\t\\t\\n\\t\\t\\t# sacn each column from 0 to size-1\\n            for x in range( size ):\\n                \\n\\t\\t\\t\\t# find falling path of minimal cost with optimal substructure\\n                min_prev = A[y-1][x] \\n                \\n                if x > 0:\\n                    min_prev = min( min_prev, A[y-1][x-1] )\\n                \\n                if x < size-1:\\n                    min_prev = min( min_prev, A[y-1][x+1] )\\n                \\n                # update the cost of falling path, destination is [y][x], with optimal substructure\\n                A[y][x] = A[y][x] + min_prev\\n                \\n        \\n        # the cost of minimum falling path is the minimum value of last row\\n        return min( A[size-1] )\\n        \\n        \\n```\n```\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        \\n        h, w = len(matrix), len(matrix[0])\\n        INF = sys.maxsize\\n        \\n        @cache\\n        def dp(row, col):\\n            \\n            ## Base case: top row\\n            if row == 0 and 0 <= col < w:\\n                return matrix[0][col]\\n            \\n            ## Base case: out-of boundary\\n            if col < 0 or col >= w:\\n                return INF\\n            \\n            ## General case: current cost + minimal cost of neighbor on previous row\\n            return matrix[row][col] + min( dp(row-1,col+offset) for offset in (-1, 0, 1) )\\n        \\n        # ------------------------------------------------\\n        return min( dp(h-1, col) for col in range(w) )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 212061,
                "title": "python-topdown-and-bottomup-with-detailed-explanation-and-algorithms",
                "content": "# https://leetcode.com/problems/minimum-falling-path-sum/description/\\n# Medium\\nimport sys\\n\\n# Input:\\nA = [[1,2,3],[4,5,6],[7,8,9]]\\nA = [[17,82],[1,-44]]\\n\\n# Algorithm: Iterative DP O(n) time and O(len(A)) space\\n 1. We create a Pad of infinity on left and right of the row, i,e including two cols to left and right\\n 2. We start from 1st index and for each A[i][j] we calc min from previous rows reachable cols i,e (j - 1), j, (j + 1)\\n 3. The technique lies in adding the min value to each cell from its reachable columns\\n 4. We update the values till the last row, then we return the min value of the last row\\n```\\nfrom collections import Counter\\nfrom copy import deepcopy\\n\\ndef minFallingPathSumIterativeDP(array):\\n    for i in range(len(array)):\\n        array[i] = [sys.maxsize] + array[i] + [sys.maxsize] # Pad infinity to left and right of array\\n\\n    for i in range(1, len(array)): # For rows 1->n, add reachable min value from prev row\\n        for j in range(1, len(array[0]) - 1): # Gracefully handle js indices\\n            array[i][j] += min(array[i - 1][j - 1],\\n                               array[i - 1][j],\\n                               array[i - 1][j + 1])\\n    return min(array[-1])\\n\\narray = deepcopy(A) # Creates a copy without reference\\nprint(minFallingPathSumIterativeDP(array))\\n```\\n# Algorithm: Recursive DP O(n * m) time\\n 0. Since the value depends on i and j, dp is 2D, we use it to store intermediate to avoid recomputations\\n 1. If reached the end of the array (in either the row or col) then, return 0\\n 2. Add the current value with minValue in next row\\n 3. Return the value as the result\\n```\\nfrom collections import Counter\\n\\ndef minFallingPathSumDP(A):\\n    def findFallingPathSum(A, i, j):\\n        if i == len(A): return 0 # If reached end of matrix, return 0\\n\\n        if (i, j) in dp: return dp[(i, j)] # If we have the value computed before return the value\\n        elif (0 <= j < len(A[0])): # If j is in range of columns and we haven\\'t computed before\\n            dp[(i, j)] = A[i][j] + min(findFallingPathSum(A, i + 1, j - 1), # Left element of j in next row\\n                                       findFallingPathSum(A, i + 1, j), # Same element as j in next row\\n                                       findFallingPathSum(A, i + 1, j + 1)) # Right element of j in next row\\n            return dp[(i, j)] # Return the computed value\\n        else: return sys.maxsize  j is out of range, so return infinity\\n\\n    dp = Counter()  DP is a lookup table\\n    return min([findFallingPathSum(A, 0, j) for j in range(len(A[0]))])\\n\\nprint(minFallingPathSumDP(A))\\n```\\n# Algorithm: Basic Recursive Solution O(3^n) time and O(n) stack space\\n 1. If reached the end of the array (in either the row or col) then, return 0\\n 2. Add the current value with minValue in next row\\n 3. Return the value as the result\\n```\\ndef minFallingPathSum(A):\\n    def findFallingPathSum(A, i, j):\\n        if i == len(A): return 0 # If reached end of matrix, return 0\\n\\n        if (0 <= j < len(A[0])): # If j is in range of columns\\n            return A[i][j] + min(findFallingPathSum(A, i + 1, j - 1), # Left element of j in next row\\n                                 findFallingPathSum(A, i + 1, j), # Same element as j in next row\\n                                 findFallingPathSum(A, i + 1, j + 1)) # Right element of j in next row\\n        else: return sys.maxsize\\n\\n    return min(findFallingPathSum(A, 0, j) for j in range(len(A[0])))\\n\\nprint(minFallingPathSum(A))\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\nfrom copy import deepcopy\\n\\ndef minFallingPathSumIterativeDP(array):\\n    for i in range(len(array)):\\n        array[i] = [sys.maxsize] + array[i] + [sys.maxsize] # Pad infinity to left and right of array\\n\\n    for i in range(1, len(array)): # For rows 1->n, add reachable min value from prev row\\n        for j in range(1, len(array[0]) - 1): # Gracefully handle js indices\\n            array[i][j] += min(array[i - 1][j - 1],\\n                               array[i - 1][j],\\n                               array[i - 1][j + 1])\\n    return min(array[-1])\\n\\narray = deepcopy(A) # Creates a copy without reference\\nprint(minFallingPathSumIterativeDP(array))\\n```\n```\\nfrom collections import Counter\\n\\ndef minFallingPathSumDP(A):\\n    def findFallingPathSum(A, i, j):\\n        if i == len(A): return 0 # If reached end of matrix, return 0\\n\\n        if (i, j) in dp: return dp[(i, j)] # If we have the value computed before return the value\\n        elif (0 <= j < len(A[0])): # If j is in range of columns and we haven\\'t computed before\\n            dp[(i, j)] = A[i][j] + min(findFallingPathSum(A, i + 1, j - 1), # Left element of j in next row\\n                                       findFallingPathSum(A, i + 1, j), # Same element as j in next row\\n                                       findFallingPathSum(A, i + 1, j + 1)) # Right element of j in next row\\n            return dp[(i, j)] # Return the computed value\\n        else: return sys.maxsize  j is out of range, so return infinity\\n\\n    dp = Counter()  DP is a lookup table\\n    return min([findFallingPathSum(A, 0, j) for j in range(len(A[0]))])\\n\\nprint(minFallingPathSumDP(A))\\n```\n```\\ndef minFallingPathSum(A):\\n    def findFallingPathSum(A, i, j):\\n        if i == len(A): return 0 # If reached end of matrix, return 0\\n\\n        if (0 <= j < len(A[0])): # If j is in range of columns\\n            return A[i][j] + min(findFallingPathSum(A, i + 1, j - 1), # Left element of j in next row\\n                                 findFallingPathSum(A, i + 1, j), # Same element as j in next row\\n                                 findFallingPathSum(A, i + 1, j + 1)) # Right element of j in next row\\n        else: return sys.maxsize\\n\\n    return min(findFallingPathSum(A, 0, j) for j in range(len(A[0])))\\n\\nprint(minFallingPathSum(A))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 186677,
                "title": "java-simple-dp",
                "content": "```\\nclass Solution {\\n    public int mini(int[][] A, int i, int j){\\n        int a = (j > 0 ) ? A[i-1][j-1] : Integer.MAX_VALUE; \\n        int b = A[i-1][j]; \\n        int c = (j < A.length-1) ? A[i-1][j+1] : Integer.MAX_VALUE; \\n        return Math.min(a, Math.min(b,c)); \\n    }\\n    public int minFallingPathSum(int[][] A) {\\n        int n = A.length; \\n        int[][] dp = new int[n][n]; \\n        for(int i = 0; i < n; ++i ) dp[0][i] = A[0][i]; \\n        for(int i = 1; i < n; ++i){\\n            for(int j = 0; j < n; ++j){\\n                dp[i][j] = A[i][j] + mini(dp, i, j);\\n            }\\n        }\\n        int min = Integer.MAX_VALUE; \\n        for(int i = 0; i < n ; ++i) min = Math.min(min, dp[n-1][i]);\\n        return min; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int mini(int[][] A, int i, int j){\\n        int a = (j > 0 ) ? A[i-1][j-1] : Integer.MAX_VALUE; \\n        int b = A[i-1][j]; \\n        int c = (j < A.length-1) ? A[i-1][j+1] : Integer.MAX_VALUE; \\n        return Math.min(a, Math.min(b,c)); \\n    }\\n    public int minFallingPathSum(int[][] A) {\\n        int n = A.length; \\n        int[][] dp = new int[n][n]; \\n        for(int i = 0; i < n; ++i ) dp[0][i] = A[0][i]; \\n        for(int i = 1; i < n; ++i){\\n            for(int j = 0; j < n; ++j){\\n                dp[i][j] = A[i][j] + mini(dp, i, j);\\n            }\\n        }\\n        int min = Integer.MAX_VALUE; \\n        for(int i = 0; i < n ; ++i) min = Math.min(min, dp[n-1][i]);\\n        return min; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3751797,
                "title": "three-approaches-memoization-tabulation-space-optimization-complexity-analysis",
                "content": "This problem is a typical Dynamic Programming Problem. Although most of the DP problems can be solved using Memoization, but this problem has updated an edge case, which gives TLE when using memoization, therefore we need to further optimize it. \\n\\nHere\\'s the code for your reference:\\n```\\nclass Solution {\\npublic:\\n    \\n//         int helper(int i, int j, vector<vector<int>>& matrix, vector<vector<int>>& dp){\\n//             if(i<0 || j<0 || i>=matrix.size() || j>=matrix[0].size()) return 1e9;\\n//             if(i==0) return matrix[i][j];\\n//             if(dp[i][j]!=-1) return dp[i][j];\\n//             return dp[i][j] = matrix[i][j] + min( helper(i-1, j, matrix, dp),\\n//                 min(helper(i-1, j-1, matrix, dp), helper(i-1, j+1, matrix, dp)));\\n\\n//         }\\n    \\n    /*\\n    // Memoization - TLE\\n    // T.C.: O(n x m)\\n    // S.C.: O(n x m) + O(n x m) - stack + dp\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>>dp(n, vector<int>(m, -1));\\n        int res = 1e9;\\n        for(int col = 0; col<m; col++){\\n            res = min( helper(n-1, col, matrix, dp), res);\\n        }\\n        return res;\\n    }\\n    */\\n    \\n    /*\\n    // Tabulation\\n    // T.C.: O(n x m)\\n    // S.C.: O(n x m) - dp\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>>dp(n, vector<int>(m, -1));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(i==0){\\n                    dp[i][j] = matrix[i][j];\\n                    continue;\\n                }\\n                int top = INT_MAX, leftd = INT_MAX, rightd = INT_MAX;\\n                if(i-1 >= 0) top = dp[i-1][j];\\n                if(i-1 >= 0 && j-1>=0) leftd = dp[i-1][j-1];\\n                if(i-1 >= 0 && j+1<m) rightd = dp[i-1][j+1];\\n                dp[i][j] = matrix[i][j] + min(top, min(leftd, rightd));\\n                \\n            }\\n        }\\n        int res = INT_MAX;\\n        for(int col = 0; col<m; col++){\\n            res = min( dp[n-1][col], res);\\n        }\\n        return res;\\n    }\\n    */\\n    \\n    \\n    // Space Optimization\\n    // T.C.: O(n x m)\\n    // S.C.: O(m + m) == O(m) - prev + curr\\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<int> prev(m, 0);\\n        \\n        for(int i=0;i<n;i++){\\n            vector<int> curr(m, 0);\\n            for(int j=0;j<m;j++){\\n                if(i==0){\\n                    curr[j] = matrix[i][j];\\n                    continue;\\n                }\\n                int top = INT_MAX, leftd = INT_MAX, rightd = INT_MAX;\\n                if(i-1 >= 0) top = prev[j];\\n                if(i-1 >= 0 && j-1>=0) leftd = prev[j-1];\\n                if(i-1 >= 0 && j+1<m) rightd = prev[j+1];\\n                curr[j] = matrix[i][j] + min(top, min(leftd, rightd));\\n                \\n            }\\n            prev = curr;\\n        }\\n        int res = INT_MAX;\\n        for(auto x: prev){\\n            res = min(x, res);\\n        }\\n        \\n        return res;\\n        \\n    }    \\n    \\n};\\n```\\n\\n**P.S: Do give it an upvote if this helped :)\\nIn case of any queries or suggestions, feel free to comment below!**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n//         int helper(int i, int j, vector<vector<int>>& matrix, vector<vector<int>>& dp){\\n//             if(i<0 || j<0 || i>=matrix.size() || j>=matrix[0].size()) return 1e9;\\n//             if(i==0) return matrix[i][j];\\n//             if(dp[i][j]!=-1) return dp[i][j];\\n//             return dp[i][j] = matrix[i][j] + min( helper(i-1, j, matrix, dp),\\n//                 min(helper(i-1, j-1, matrix, dp), helper(i-1, j+1, matrix, dp)));\\n\\n//         }\\n    \\n    /*\\n    // Memoization - TLE\\n    // T.C.: O(n x m)\\n    // S.C.: O(n x m) + O(n x m) - stack + dp\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>>dp(n, vector<int>(m, -1));\\n        int res = 1e9;\\n        for(int col = 0; col<m; col++){\\n            res = min( helper(n-1, col, matrix, dp), res);\\n        }\\n        return res;\\n    }\\n    */\\n    \\n    /*\\n    // Tabulation\\n    // T.C.: O(n x m)\\n    // S.C.: O(n x m) - dp\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>>dp(n, vector<int>(m, -1));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(i==0){\\n                    dp[i][j] = matrix[i][j];\\n                    continue;\\n                }\\n                int top = INT_MAX, leftd = INT_MAX, rightd = INT_MAX;\\n                if(i-1 >= 0) top = dp[i-1][j];\\n                if(i-1 >= 0 && j-1>=0) leftd = dp[i-1][j-1];\\n                if(i-1 >= 0 && j+1<m) rightd = dp[i-1][j+1];\\n                dp[i][j] = matrix[i][j] + min(top, min(leftd, rightd));\\n                \\n            }\\n        }\\n        int res = INT_MAX;\\n        for(int col = 0; col<m; col++){\\n            res = min( dp[n-1][col], res);\\n        }\\n        return res;\\n    }\\n    */\\n    \\n    \\n    // Space Optimization\\n    // T.C.: O(n x m)\\n    // S.C.: O(m + m) == O(m) - prev + curr\\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<int> prev(m, 0);\\n        \\n        for(int i=0;i<n;i++){\\n            vector<int> curr(m, 0);\\n            for(int j=0;j<m;j++){\\n                if(i==0){\\n                    curr[j] = matrix[i][j];\\n                    continue;\\n                }\\n                int top = INT_MAX, leftd = INT_MAX, rightd = INT_MAX;\\n                if(i-1 >= 0) top = prev[j];\\n                if(i-1 >= 0 && j-1>=0) leftd = prev[j-1];\\n                if(i-1 >= 0 && j+1<m) rightd = prev[j+1];\\n                curr[j] = matrix[i][j] + min(top, min(leftd, rightd));\\n                \\n            }\\n            prev = curr;\\n        }\\n        int res = INT_MAX;\\n        for(auto x: prev){\\n            res = min(x, res);\\n        }\\n        \\n        return res;\\n        \\n    }    \\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567378,
                "title": "memoization-striver-s-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int memo(int i,int j,vector<vector<int>> &matrix,vector<vector<int>> &dp){\\n        if(j<0 || j>(matrix.size()-1))return 1e9;\\n        if(i==0) return matrix[i][j];\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int up=memo(i-1,j,matrix,dp);\\n        int ld=memo(i-1,j-1,matrix,dp);\\n        int rd=memo(i-1,j+1,matrix,dp);\\n        return dp[i][j]=matrix[i][j]+min(up,min(ld,rd));\\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int mini=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            vector<vector<int>> dp(n,vector<int>(n,-1));\\n            int sum=memo(n-1,i,matrix,dp);\\n            mini=min(mini,sum);\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int memo(int i,int j,vector<vector<int>> &matrix,vector<vector<int>> &dp){\\n        if(j<0 || j>(matrix.size()-1))return 1e9;\\n        if(i==0) return matrix[i][j];\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int up=memo(i-1,j,matrix,dp);\\n        int ld=memo(i-1,j-1,matrix,dp);\\n        int rd=memo(i-1,j+1,matrix,dp);\\n        return dp[i][j]=matrix[i][j]+min(up,min(ld,rd));\\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int mini=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            vector<vector<int>> dp(n,vector<int>(n,-1));\\n            int sum=memo(n-1,i,matrix,dp);\\n            mini=min(mini,sum);\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2908550,
                "title": "java-easy-dp-solution",
                "content": "# Intuition\\nWhy DP? because we can arrive at cell `A[r][c]` in multiple ways. Whenever we arrive at cell `A[r][c]` we need to calculate the minimum path from that cell onwards.\\n\\nTherefore, we have a recurring subproblem.\\n\\nWe need to know the solutions from the bottom-up so we iterate from the matrix bottom to top. The column order doesn\\'t matter.\\n\\n# Code\\n```\\n    class Solution {\\n        public int minFallingPathSum(int[][] matrix) {\\n            int n = matrix.length;\\n            int[][] dp = new int[n + 1][n + 2];\\n\\n            // The DP walls should be out-of-scope hence Integer.MAX_VALUE; They are used for code ease\\n            for (int r = 0; r < dp.length; r++) {\\n                dp[r][0] = Integer.MAX_VALUE;\\n                dp[r][dp[0].length - 1] = Integer.MAX_VALUE;\\n            }\\n\\n            for (int r = n - 1; r >= 0; r--) {\\n                for (int c = 0; c < n; c++) {\\n                    int[] moves = new int[]{dp[r + 1][c], dp[r + 1][c + 1], dp[r + 1][c + 2]};\\n                    dp[r][c + 1] = matrix[r][c] + Arrays.stream(moves).min().getAsInt();\\n                }\\n            }\\n            \\n            return Arrays.stream(dp[0]).min().getAsInt();\\n\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    class Solution {\\n        public int minFallingPathSum(int[][] matrix) {\\n            int n = matrix.length;\\n            int[][] dp = new int[n + 1][n + 2];\\n\\n            // The DP walls should be out-of-scope hence Integer.MAX_VALUE; They are used for code ease\\n            for (int r = 0; r < dp.length; r++) {\\n                dp[r][0] = Integer.MAX_VALUE;\\n                dp[r][dp[0].length - 1] = Integer.MAX_VALUE;\\n            }\\n\\n            for (int r = n - 1; r >= 0; r--) {\\n                for (int c = 0; c < n; c++) {\\n                    int[] moves = new int[]{dp[r + 1][c], dp[r + 1][c + 1], dp[r + 1][c + 2]};\\n                    dp[r][c + 1] = matrix[r][c] + Arrays.stream(moves).min().getAsInt();\\n                }\\n            }\\n            \\n            return Arrays.stream(dp[0]).min().getAsInt();\\n\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2908285,
                "title": "fastest-python-solution-beats-100",
                "content": "# Approach\\ngo from bottom to top and summarizing. then return min value of first row.\\n\\n# Complexity\\n- Time complexity:   $$O(n^2)$$\\n\\n- Space complexity:   $$O(n)$$\\n\\n# Code\\n```\\nclass Solution(object):\\n    def minFallingPathSum(self, m):\\n        m = [[100000]+x+[100000] for x in m]\\n        l = len(m)\\n        for i in range(l-1, 0, -1):\\n            for j in range(1, l+1):\\n                m[i-1][j] = m[i-1][j] + min(m[i][j], m[i][j-1], m[i][j+1])\\n        return min(m[0])\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minFallingPathSum(self, m):\\n        m = [[100000]+x+[100000] for x in m]\\n        l = len(m)\\n        for i in range(l-1, 0, -1):\\n            for j in range(1, l+1):\\n                m[i-1][j] = m[i-1][j] + min(m[i][j], m[i][j-1], m[i][j+1])\\n        return min(m[0])\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2908090,
                "title": "python-2-solutions-video-solution",
                "content": "I have explained both the approaches in this [video](https://youtu.be/mzeDdbAABpE).\\n\\nIf this is helpful, please upvote, like the video and subscribe to the channel for more such content.\\n\\nCheers\\n\\n# Memoization\\n\\n**Time**: `O(n^2)`\\n**Space**: `O(n^2)`\\n\\n```\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        \\n        n = len(matrix)\\n        dp = {}\\n        \\n        def dfs(i, j):\\n            if j<0 or j>=n:\\n                return inf\\n            \\n            if i==n-1:\\n                return matrix[i][j]\\n            \\n            if (i,j) in dp:\\n                return dp[(i, j)]\\n            \\n            cur = matrix[i][j]\\n            \\n            dp[(i, j)] = cur + min( dfs(i+1, j), dfs(i+1, j-1), dfs(i+1, j+1))\\n            return dp[(i, j)]\\n        \\n        ans = math.inf\\n        for j in range(n):\\n            ans = min(ans, dfs(0,j))\\n            \\n        return ans\\n```\\n\\n# Dynamic Programming\\n\\n**Time**: `O(n^2)`\\n**Space**: `O(1)`\\n\\n```\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        \\n        n = len(matrix)\\n        \\n        for i in reversed(range(n-1)):\\n            for j in range(n):\\n                left = inf if j==0 else matrix[i+1][j-1]\\n                right = inf if j==n-1 else matrix[i+1][j+1]\\n                down = matrix[i+1][j]\\n                \\n                matrix[i][j] += min(left, down, right)\\n                \\n        return min(matrix[0])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        \\n        n = len(matrix)\\n        dp = {}\\n        \\n        def dfs(i, j):\\n            if j<0 or j>=n:\\n                return inf\\n            \\n            if i==n-1:\\n                return matrix[i][j]\\n            \\n            if (i,j) in dp:\\n                return dp[(i, j)]\\n            \\n            cur = matrix[i][j]\\n            \\n            dp[(i, j)] = cur + min( dfs(i+1, j), dfs(i+1, j-1), dfs(i+1, j+1))\\n            return dp[(i, j)]\\n        \\n        ans = math.inf\\n        for j in range(n):\\n            ans = min(ans, dfs(0,j))\\n            \\n        return ans\\n```\n```\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        \\n        n = len(matrix)\\n        \\n        for i in reversed(range(n-1)):\\n            for j in range(n):\\n                left = inf if j==0 else matrix[i+1][j-1]\\n                right = inf if j==n-1 else matrix[i+1][j+1]\\n                down = matrix[i+1][j]\\n                \\n                matrix[i][j] += min(left, down, right)\\n                \\n        return min(matrix[0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2906977,
                "title": "easy-java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        int n = matrix.length;\\n\\n        if(n==1) return matrix[0][0];\\n        int[][] arr = new int[n+1][n+2];\\n\\n        for (int i = 0; i < n; i++) {\\n            arr[i][0] = Integer.MAX_VALUE;\\n            arr[i][n + 1] = Integer.MAX_VALUE;\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            for(int j =1;j<=n;j++){\\n                int curr = matrix[i][j-1];\\n                int min = Integer.MIN_VALUE;\\n                min = Math.min(arr[i+1][j], Math.min(arr[i+1][j+1], arr[i+1][j-1]));\\n                arr[i][j]= curr+min;\\n            }\\n        }\\n        int minSum = Integer.MAX_VALUE;\\n        for(int i=1;i<=n;i++){\\n            minSum = Math.min(minSum,arr[0][i]);\\n        }\\n        return minSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        int n = matrix.length;\\n\\n        if(n==1) return matrix[0][0];\\n        int[][] arr = new int[n+1][n+2];\\n\\n        for (int i = 0; i < n; i++) {\\n            arr[i][0] = Integer.MAX_VALUE;\\n            arr[i][n + 1] = Integer.MAX_VALUE;\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            for(int j =1;j<=n;j++){\\n                int curr = matrix[i][j-1];\\n                int min = Integer.MIN_VALUE;\\n                min = Math.min(arr[i+1][j], Math.min(arr[i+1][j+1], arr[i+1][j-1]));\\n                arr[i][j]= curr+min;\\n            }\\n        }\\n        int minSum = Integer.MAX_VALUE;\\n        for(int i=1;i<=n;i++){\\n            minSum = Math.min(minSum,arr[0][i]);\\n        }\\n        return minSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2906757,
                "title": "c-dp-3-approaches-easy-and-fast",
                "content": "```\\nIf you learn/found something new please upvote \\uD83D\\uDC4D\\n```\\n---\\n# Approach1 - Memoization Method\\n\\n### Complexity\\n- Time complexity: $$O(n*m)$$\\n\\n- Space complexity: $$O(n*m)$$\\n\\n```\\nclass Solution {\\n    vector<vector<int>> dp;\\n\\n    int dfs(int row, int col, vector<vector<int>>& matrix){\\n        if(row == matrix.size()-1)\\n            return matrix[row][col];\\n        \\n        if(dp[row][col] != -1)\\n            return dp[row][col];\\n\\n        int ans = dfs(row+1, col, matrix);\\n        if(col > 0)\\n            ans = min(ans, dfs(row+1, col-1, matrix));\\n        if(col < matrix[0].size()-1)\\n            ans = min(ans, dfs(row+1, col+1, matrix));\\n\\n        dp[row][col] = ans + matrix[row][col];\\n        return dp[row][col];\\n    }\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int minSum = INT_MAX;\\n\\n        int n = matrix.size(), m = matrix[0].size();\\n        dp = vector<vector<int>>(n, vector<int>(m, -1));\\n\\n        for(int i = 0; i<m; i++){\\n            minSum = min(minSum, dfs(0, i, matrix));\\n        }\\n\\n        return minSum;\\n    }\\n};\\n```\\n\\n---\\n\\n# Approach2 - Tabulation Method\\n\\n### Approach\\nStarted from bottom most row and found the minimum sum for each element. Then progressively done the same thing for each upper row. And searched for minimum sum that will be our answer.\\n\\n### Complexity\\n- Time complexity: $$O(n*m)$$\\n\\n- Space complexity: $$O(n*m)$$ ----- [Specific: $$O(3*n*m)$$]\\n\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int minSum = INT_MAX;\\n\\n        int n = matrix.size(), m = matrix[0].size();\\n        vector<vector<int>> dp(n, vector<int>(m, INT_MAX));\\n\\n        for(int j = 0; j<m; j++)\\n            dp[n-1][j] = matrix[n-1][j];\\n\\n        for(int i = n-2; i>=0; i--){\\n            for(int j = 0; j<m; j++){\\n\\n                for(int y = -1; y<=1; y++){\\n                    if(j+y >= 0 && j+y < m)\\n                        dp[i][j] = min(dp[i][j], dp[i+1][j+y]);\\n                }\\n\\n                dp[i][j] += matrix[i][j];\\n            }\\n        }\\n\\n        for(int j = 0; j<m; j++)\\n            minSum = min(minSum, dp[0][j]);\\n\\n        return minSum;\\n    }\\n};\\n```\\n---\\n\\n# Approach3 - Space Optimised Tabulation Method\\n\\n### Approach\\nStarted from bottom most row and found the minimum sum for each element. Then progressively done the same thing for each upper row. And searched for minimum sum that will be our answer.\\n[Same as Approach 2 - Only replaced 2-D dp matrix with 1D dp array]\\n\\n### Complexity\\n- Time complexity: $$O(n*m)$$\\n\\n- Space complexity: $$O(n)$$ ----- [Specific: $$O(2*n)$$]\\n\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        \\n        vector<int> prev(n, 0), curr(n, 0);\\n\\n        int sum = INT_MAX;\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<n; j++){\\n                curr[j] = matrix[i][j];\\n                if(i != 0){\\n                    int prevSum = prev[j];\\n                    if(j > 0)\\n                        prevSum = min(prevSum, prev[j-1]);\\n                    if(j < n-1)\\n                        prevSum = min(prevSum, prev[j+1]);\\n\\n                    curr[j] += prevSum;\\n                }\\n                \\n                if(i == n-1)\\n                    sum = min(sum, curr[j]);\\n            }\\n            prev = curr;\\n        }\\n\\n        return sum;\\n    }\\n};\\n```\\n---\\n\\n```\\nIf you learn/found something new please upvote \\uD83D\\uDC4D\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization",
                    "Matrix"
                ],
                "code": "```\\nIf you learn/found something new please upvote \\uD83D\\uDC4D\\n```\n```\\nclass Solution {\\n    vector<vector<int>> dp;\\n\\n    int dfs(int row, int col, vector<vector<int>>& matrix){\\n        if(row == matrix.size()-1)\\n            return matrix[row][col];\\n        \\n        if(dp[row][col] != -1)\\n            return dp[row][col];\\n\\n        int ans = dfs(row+1, col, matrix);\\n        if(col > 0)\\n            ans = min(ans, dfs(row+1, col-1, matrix));\\n        if(col < matrix[0].size()-1)\\n            ans = min(ans, dfs(row+1, col+1, matrix));\\n\\n        dp[row][col] = ans + matrix[row][col];\\n        return dp[row][col];\\n    }\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int minSum = INT_MAX;\\n\\n        int n = matrix.size(), m = matrix[0].size();\\n        dp = vector<vector<int>>(n, vector<int>(m, -1));\\n\\n        for(int i = 0; i<m; i++){\\n            minSum = min(minSum, dfs(0, i, matrix));\\n        }\\n\\n        return minSum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int minSum = INT_MAX;\\n\\n        int n = matrix.size(), m = matrix[0].size();\\n        vector<vector<int>> dp(n, vector<int>(m, INT_MAX));\\n\\n        for(int j = 0; j<m; j++)\\n            dp[n-1][j] = matrix[n-1][j];\\n\\n        for(int i = n-2; i>=0; i--){\\n            for(int j = 0; j<m; j++){\\n\\n                for(int y = -1; y<=1; y++){\\n                    if(j+y >= 0 && j+y < m)\\n                        dp[i][j] = min(dp[i][j], dp[i+1][j+y]);\\n                }\\n\\n                dp[i][j] += matrix[i][j];\\n            }\\n        }\\n\\n        for(int j = 0; j<m; j++)\\n            minSum = min(minSum, dp[0][j]);\\n\\n        return minSum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        \\n        vector<int> prev(n, 0), curr(n, 0);\\n\\n        int sum = INT_MAX;\\n        for(int i = 0; i<n; i++){\\n            for(int j = 0; j<n; j++){\\n                curr[j] = matrix[i][j];\\n                if(i != 0){\\n                    int prevSum = prev[j];\\n                    if(j > 0)\\n                        prevSum = min(prevSum, prev[j-1]);\\n                    if(j < n-1)\\n                        prevSum = min(prevSum, prev[j+1]);\\n\\n                    curr[j] += prevSum;\\n                }\\n                \\n                if(i == n-1)\\n                    sum = min(sum, curr[j]);\\n            }\\n            prev = curr;\\n        }\\n\\n        return sum;\\n    }\\n};\\n```\n```\\nIf you learn/found something new please upvote \\uD83D\\uDC4D\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2906597,
                "title": "java-easiest-dp",
                "content": "\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        int n = matrix.length;\\n        int minSum = Integer.MAX_VALUE;\\n\\n        if(n == 1) {\\n            return matrix[0][0];\\n        }\\n\\n        for(int i = 1; i<n; i++) {\\n            for(int j = 0; j<n; j++) {\\n                int minTop = matrix[i-1][j];\\n                if(j>0) {\\n                    minTop = Math.min(minTop, matrix[i-1][j-1]);\\n                } if(j<n-1) {\\n                    minTop = Math.min(minTop, matrix[i-1][j+1]);\\n                }\\n                \\n                matrix[i][j] += minTop;\\n                if(i == n-1) {\\n                    minSum = Math.min(minSum, matrix[i][j]);\\n                }\\n            }\\n        }\\n\\n        return minSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        int n = matrix.length;\\n        int minSum = Integer.MAX_VALUE;\\n\\n        if(n == 1) {\\n            return matrix[0][0];\\n        }\\n\\n        for(int i = 1; i<n; i++) {\\n            for(int j = 0; j<n; j++) {\\n                int minTop = matrix[i-1][j];\\n                if(j>0) {\\n                    minTop = Math.min(minTop, matrix[i-1][j-1]);\\n                } if(j<n-1) {\\n                    minTop = Math.min(minTop, matrix[i-1][j+1]);\\n                }\\n                \\n                matrix[i][j] += minTop;\\n                if(i == n-1) {\\n                    minSum = Math.min(minSum, matrix[i][j]);\\n                }\\n            }\\n        }\\n\\n        return minSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2906418,
                "title": "minfallingpathsum-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        // int ans=0;\\n        int n= matrix.size();\\n        int m= matrix[0].size();\\n         vector<vector<int>> dp(n,vector<int>(m,0));\\n         for(int i=0;i<m;i++){\\n           dp[0][i]=matrix[0][i];\\n         }\\n        for(int i=0;i<m;i++){\\n           cout<<dp[0][i]<<\" \";\\n         }\\n         for(int i=1;i<n;i++){\\n             for(int j=0;j<m;j++){\\n                 if(j==0){\\n                     dp[i][j]=matrix[i][j] + min(dp[i-1][j],dp[i-1][j+1]);\\n                 }\\n                 else if(j==m-1){\\n                     dp[i][j]=matrix[i][j] + min(dp[i-1][j],dp[i-1][j-1]);\\n                 }\\n                 else{\\n                     dp[i][j]=matrix[i][j] + min(dp[i-1][j-1],min(dp[i-1][j],dp[i-1][j+1]));\\n                 }\\n             }\\n              for(int k=0;k<m;k++){\\n           cout<<dp[i][k]<<\" \";\\n         }\\n         }\\n\\n         vector<int> v;\\n         for(int i=0;i<m;i++){\\n           v.push_back(dp[n-1][i]);\\n         }\\n         sort(v.begin(),v.end());\\n        return v[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        // int ans=0;\\n        int n= matrix.size();\\n        int m= matrix[0].size();\\n         vector<vector<int>> dp(n,vector<int>(m,0));\\n         for(int i=0;i<m;i++){\\n           dp[0][i]=matrix[0][i];\\n         }\\n        for(int i=0;i<m;i++){\\n           cout<<dp[0][i]<<\" \";\\n         }\\n         for(int i=1;i<n;i++){\\n             for(int j=0;j<m;j++){\\n                 if(j==0){\\n                     dp[i][j]=matrix[i][j] + min(dp[i-1][j],dp[i-1][j+1]);\\n                 }\\n                 else if(j==m-1){\\n                     dp[i][j]=matrix[i][j] + min(dp[i-1][j],dp[i-1][j-1]);\\n                 }\\n                 else{\\n                     dp[i][j]=matrix[i][j] + min(dp[i-1][j-1],min(dp[i-1][j],dp[i-1][j+1]));\\n                 }\\n             }\\n              for(int k=0;k<m;k++){\\n           cout<<dp[i][k]<<\" \";\\n         }\\n         }\\n\\n         vector<int> v;\\n         for(int i=0;i<m;i++){\\n           v.push_back(dp[n-1][i]);\\n         }\\n         sort(v.begin(),v.end());\\n        return v[0];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2906392,
                "title": "4-dp-solutions-recursion-memoization-2d-dp-1d-dp",
                "content": "# Recursion(TLE)\\n```\\nclass Solution {\\npublic:\\n    int f(int x, int y, vector<vector<int>>& mat) {\\n        if(!x) return mat[x][y];\\n        int minSum = 1e6;\\n        int currSum = mat[x][y];\\n        minSum = min(minSum, f(x - 1, y, mat));\\n        if(y - 1 >= 0) minSum = min(minSum, f(x - 1, y - 1, mat));\\n        if(y + 1 < mat.size()) minSum = min(minSum, f(x - 1, y + 1, mat));\\n        return currSum + minSum;\\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int minFallPathSum = 1e6;\\n        int n = matrix.size();\\n        for(int j = n - 1; j >= 0; j--) {\\n            minFallPathSum = min(minFallPathSum, f(n - 1, j, matrix));\\n        }\\n        return minFallPathSum;\\n    }\\n};\\n```\\n# Memoization\\n```\\nclass Solution {\\npublic:\\n    int f(int x, int y, vector<vector<int>>& mat, vector<vector<int>>& dp) {\\n        if(!x) return mat[x][y];\\n        if(dp[x][y] != 1e6) return dp[x][y];\\n        int minSum = 1e6;\\n        int currSum = mat[x][y];\\n        minSum = min(minSum, f(x - 1, y, mat, dp));\\n        if(y - 1 >= 0) minSum = min(minSum, f(x - 1, y - 1, mat, dp));\\n        if(y + 1 < mat.size()) minSum = min(minSum, f(x - 1, y + 1, mat, dp));\\n        return dp[x][y] = currSum + minSum;\\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int minFallPathSum = 1e6;\\n        int n = matrix.size();\\n        vector<vector<int>> dp(n, vector<int>(n, 1e6));\\n        for(int j = n - 1; j >= 0; j--) {\\n            minFallPathSum = min(minFallPathSum, f(n - 1, j, matrix, dp));\\n        }\\n        return minFallPathSum;\\n    }\\n};\\n```\\n# 2D DP\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector<vector<int>> dp(n, vector<int>(n, 1e6));\\n        for(int j = 0; j < n; j++) {\\n            dp[n - 1][j] = matrix[n - 1][j];\\n        }\\n        for(int i = n - 2; i >= 0; i--) {\\n            for(int j = 0; j < n; j++) {\\n                int minSum = dp[i + 1][j];\\n                if(j - 1 >= 0) minSum = min(minSum, dp[i + 1][j - 1]);\\n                if(j + 1 < n) minSum = min(minSum, dp[i + 1][j + 1]);\\n                dp[i][j] = matrix[i][j] + minSum;\\n            }\\n        }\\n        return *min_element(dp[0].begin(), dp[0].end());\\n    }\\n};\\n```\\n# 1D DP\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector<int> prev(n, 0), curr(n, 0);\\n        for(int j = 0; j < n; j++) {\\n            prev[j] = matrix[n - 1][j];\\n        }\\n        for(int i = n - 2; i >= 0; i--) {\\n            for(int j = 0; j < n; j++) {\\n                int minSum = prev[j];\\n                if(j - 1 >= 0) minSum = min(minSum, prev[j - 1]);\\n                if(j + 1 < n) minSum = min(minSum, prev[j + 1]);\\n                curr[j] = matrix[i][j] + minSum;\\n            }\\n            prev = curr;\\n        }\\n        return *min_element(prev.begin(), prev.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int x, int y, vector<vector<int>>& mat) {\\n        if(!x) return mat[x][y];\\n        int minSum = 1e6;\\n        int currSum = mat[x][y];\\n        minSum = min(minSum, f(x - 1, y, mat));\\n        if(y - 1 >= 0) minSum = min(minSum, f(x - 1, y - 1, mat));\\n        if(y + 1 < mat.size()) minSum = min(minSum, f(x - 1, y + 1, mat));\\n        return currSum + minSum;\\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int minFallPathSum = 1e6;\\n        int n = matrix.size();\\n        for(int j = n - 1; j >= 0; j--) {\\n            minFallPathSum = min(minFallPathSum, f(n - 1, j, matrix));\\n        }\\n        return minFallPathSum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int f(int x, int y, vector<vector<int>>& mat, vector<vector<int>>& dp) {\\n        if(!x) return mat[x][y];\\n        if(dp[x][y] != 1e6) return dp[x][y];\\n        int minSum = 1e6;\\n        int currSum = mat[x][y];\\n        minSum = min(minSum, f(x - 1, y, mat, dp));\\n        if(y - 1 >= 0) minSum = min(minSum, f(x - 1, y - 1, mat, dp));\\n        if(y + 1 < mat.size()) minSum = min(minSum, f(x - 1, y + 1, mat, dp));\\n        return dp[x][y] = currSum + minSum;\\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int minFallPathSum = 1e6;\\n        int n = matrix.size();\\n        vector<vector<int>> dp(n, vector<int>(n, 1e6));\\n        for(int j = n - 1; j >= 0; j--) {\\n            minFallPathSum = min(minFallPathSum, f(n - 1, j, matrix, dp));\\n        }\\n        return minFallPathSum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector<vector<int>> dp(n, vector<int>(n, 1e6));\\n        for(int j = 0; j < n; j++) {\\n            dp[n - 1][j] = matrix[n - 1][j];\\n        }\\n        for(int i = n - 2; i >= 0; i--) {\\n            for(int j = 0; j < n; j++) {\\n                int minSum = dp[i + 1][j];\\n                if(j - 1 >= 0) minSum = min(minSum, dp[i + 1][j - 1]);\\n                if(j + 1 < n) minSum = min(minSum, dp[i + 1][j + 1]);\\n                dp[i][j] = matrix[i][j] + minSum;\\n            }\\n        }\\n        return *min_element(dp[0].begin(), dp[0].end());\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector<int> prev(n, 0), curr(n, 0);\\n        for(int j = 0; j < n; j++) {\\n            prev[j] = matrix[n - 1][j];\\n        }\\n        for(int i = n - 2; i >= 0; i--) {\\n            for(int j = 0; j < n; j++) {\\n                int minSum = prev[j];\\n                if(j - 1 >= 0) minSum = min(minSum, prev[j - 1]);\\n                if(j + 1 < n) minSum = min(minSum, prev[j + 1]);\\n                curr[j] = matrix[i][j] + minSum;\\n            }\\n            prev = curr;\\n        }\\n        return *min_element(prev.begin(), prev.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2906214,
                "title": "c-begineerfriendly-easy-understanding-dp-video-solution",
                "content": "# Intuition and Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**C++ Clear Explaination ,Please support if you find it usefull. Can give me feedback in comment for improvement.,will be very thankfull.**\\nhttps://www.youtube.com/watch?v=GdbbIeLKwZM/\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n int minFallingPathSum(vector<vector<int>>& matrix) {\\n int n = matrix.size();\\n        int m = matrix[0].size();\\n// If only one row. return minimum ..\\n        if(n == 1) return *min_element(matrix[0].begin(),matrix[0].end());\\n\\n// Otherwise traverse the entire matrix and update it.\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                    if(j == 0){\\n                        matrix[i][j] = matrix[i][j]+min(matrix[i-1][j],matrix[i-1][j+1]);\\n\\n                    }else if(j == m-1){\\n                        matrix[i][j] = matrix[i][j]+min(matrix[i-1][j],matrix[i-1][j-1]);\\n                    }else{\\n                        matrix[i][j] = matrix[i][j]+min(matrix[i-1][j],min(matrix[i-1][j+1],matrix[i-1][j-1]));\\n                    }\\n                }\\n            }\\n\\n// Return the minimum out of last elements.\\n        return *min_element(matrix[n-1].begin(),matrix[n-1].end());\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Backtracking",
                    "Greedy",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n int minFallingPathSum(vector<vector<int>>& matrix) {\\n int n = matrix.size();\\n        int m = matrix[0].size();\\n// If only one row. return minimum ..\\n        if(n == 1) return *min_element(matrix[0].begin(),matrix[0].end());\\n\\n// Otherwise traverse the entire matrix and update it.\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                    if(j == 0){\\n                        matrix[i][j] = matrix[i][j]+min(matrix[i-1][j],matrix[i-1][j+1]);\\n\\n                    }else if(j == m-1){\\n                        matrix[i][j] = matrix[i][j]+min(matrix[i-1][j],matrix[i-1][j-1]);\\n                    }else{\\n                        matrix[i][j] = matrix[i][j]+min(matrix[i-1][j],min(matrix[i-1][j+1],matrix[i-1][j-1]));\\n                    }\\n                }\\n            }\\n\\n// Return the minimum out of last elements.\\n        return *min_element(matrix[n-1].begin(),matrix[n-1].end());\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830529,
                "title": "rust-iterators-100",
                "content": "# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn min_falling_path_sum(matrix: Vec<Vec<i32>>) -> i32 {\\n        let len = matrix[0].len();\\n        *matrix\\n            .into_iter()\\n            .rev()\\n            .reduce(|acc, mut row| {\\n                for (i, x) in row.iter_mut().enumerate() {\\n                    *x += acc[i].min(acc[(len - 1).min(i + 1)].min(acc[i.min(i - 1)]));\\n                }\\n                row\\n            })\\n            .unwrap()\\n            .iter()\\n            .min()\\n            .unwrap()\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_falling_path_sum(matrix: Vec<Vec<i32>>) -> i32 {\\n        let len = matrix[0].len();\\n        *matrix\\n            .into_iter()\\n            .rev()\\n            .reduce(|acc, mut row| {\\n                for (i, x) in row.iter_mut().enumerate() {\\n                    *x += acc[i].min(acc[(len - 1).min(i + 1)].min(acc[i.min(i - 1)]));\\n                }\\n                row\\n            })\\n            .unwrap()\\n            .iter()\\n            .min()\\n            .unwrap()\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2764325,
                "title": "c-easy-bottom-up-o-n-2",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach -> Bottom up\\n<!-- Describe your approach to solving the problem. -->\\n\\n- Time complexity: O(m*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int m = matrix.size();\\n        for(int i=1; i<m; i++){\\n            for(int j=0; j<m; j++){\\n                if(j==0)\\n                    matrix[i][j] += min(matrix[i-1][j], matrix[i-1][j+1]);\\n                else if(j==m-1)\\n                    matrix[i][j] += min(matrix[i-1][j-1], matrix[i-1][j]);\\n                else if(0<j<m-1)\\n                    matrix[i][j] += min(matrix[i-1][j-1], min(matrix[i-1][j], matrix[i-1][j+1]));\\n            }\\n        }\\n        return *min_element(matrix[m-1].begin(), matrix[m-1].end());\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int m = matrix.size();\\n        for(int i=1; i<m; i++){\\n            for(int j=0; j<m; j++){\\n                if(j==0)\\n                    matrix[i][j] += min(matrix[i-1][j], matrix[i-1][j+1]);\\n                else if(j==m-1)\\n                    matrix[i][j] += min(matrix[i-1][j-1], matrix[i-1][j]);\\n                else if(0<j<m-1)\\n                    matrix[i][j] += min(matrix[i-1][j-1], min(matrix[i-1][j], matrix[i-1][j+1]));\\n            }\\n        }\\n        return *min_element(matrix[m-1].begin(), matrix[m-1].end());\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2686717,
                "title": "python-dp-solution-memoization-tabulation-spaceoptimization",
                "content": "```\\n# Memoization Solution -->>>>>\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        def dfs(arr,i,j,dp):\\n\\n\\n            if j<0 or j>=len(arr[0]):\\n                return 1e9\\n            if i==0:\\n                return arr[0][j]\\n            if dp[i][j] != -1:\\n                return dp[i][j]\\n            up=dfs(arr,i-1,j,dp)+arr[i][j]\\n\\n            left=dfs(arr,i-1,j-1,dp)+arr[i][j]\\n\\n            right=dfs(arr,i-1,j+1,dp)+arr[i][j]\\n\\n            dp[i][j]=min(up,left,right)\\n            return dp[i][j]\\n\\n\\n        dp=[[-1]*len(matrix[0]) for i in range(len(matrix))]\\n        mini=999999\\n        for i in range(len(matrix[0])):\\n            mini=min(mini,dfs(matrix,len(matrix)-1,i,dp))\\n        return mini\\n        \\n```\\n```\\n# Tabulation Solution -->>>>>>>\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        dp=[[-1]*len(matrix[0]) for i in range(len(matrix))]\\n        n=len(matrix)\\n        m=len(matrix[0])\\n        for i in range(m):\\n            dp[0][i]=matrix[0][i]\\n        for i in range(1,n):\\n            for j in range(m):\\n                up=dp[i-1][j]+matrix[i][j]\\n                if j-1>=0:\\n                    left=dp[i-1][j-1]+matrix[i][j]\\n                else:\\n                    left=1e9+matrix[i][j]\\n\\n                if j+1<m:\\n                    right=dp[i-1][j+1]+matrix[i][j]\\n                else:\\n                    right=1e9+matrix[i][j]\\n                dp[i][j]=min(up,left,right)\\n        return min(dp[n-1])\\n```\\n```\\n# SpaceOptimization -->>>>>>>>\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        n=len(matrix)\\n        m=len(matrix[0])\\n        prev=[0]*m\\n        for i in range(m):\\n            prev[i]=matrix[0][i]\\n        for i in range(1,n):\\n            curr=[0]*m\\n            for j in range(m):\\n                up=prev[j]+matrix[i][j]\\n                if j-1>=0:\\n                    left=prev[j-1]+matrix[i][j]\\n                else:\\n                    left=1e9+matrix[i][j]\\n\\n                if j+1<m:\\n                    right=prev[j+1]+matrix[i][j]\\n                else:\\n                    right=1e9+matrix[i][j]\\n                curr[j]=min(up,left,right)\\n            prev=curr\\n        return min(prev)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n# Memoization Solution -->>>>>\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        def dfs(arr,i,j,dp):\\n\\n\\n            if j<0 or j>=len(arr[0]):\\n                return 1e9\\n            if i==0:\\n                return arr[0][j]\\n            if dp[i][j] != -1:\\n                return dp[i][j]\\n            up=dfs(arr,i-1,j,dp)+arr[i][j]\\n\\n            left=dfs(arr,i-1,j-1,dp)+arr[i][j]\\n\\n            right=dfs(arr,i-1,j+1,dp)+arr[i][j]\\n\\n            dp[i][j]=min(up,left,right)\\n            return dp[i][j]\\n\\n\\n        dp=[[-1]*len(matrix[0]) for i in range(len(matrix))]\\n        mini=999999\\n        for i in range(len(matrix[0])):\\n            mini=min(mini,dfs(matrix,len(matrix)-1,i,dp))\\n        return mini\\n        \\n```\n```\\n# Tabulation Solution -->>>>>>>\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        dp=[[-1]*len(matrix[0]) for i in range(len(matrix))]\\n        n=len(matrix)\\n        m=len(matrix[0])\\n        for i in range(m):\\n            dp[0][i]=matrix[0][i]\\n        for i in range(1,n):\\n            for j in range(m):\\n                up=dp[i-1][j]+matrix[i][j]\\n                if j-1>=0:\\n                    left=dp[i-1][j-1]+matrix[i][j]\\n                else:\\n                    left=1e9+matrix[i][j]\\n\\n                if j+1<m:\\n                    right=dp[i-1][j+1]+matrix[i][j]\\n                else:\\n                    right=1e9+matrix[i][j]\\n                dp[i][j]=min(up,left,right)\\n        return min(dp[n-1])\\n```\n```\\n# SpaceOptimization -->>>>>>>>\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        n=len(matrix)\\n        m=len(matrix[0])\\n        prev=[0]*m\\n        for i in range(m):\\n            prev[i]=matrix[0][i]\\n        for i in range(1,n):\\n            curr=[0]*m\\n            for j in range(m):\\n                up=prev[j]+matrix[i][j]\\n                if j-1>=0:\\n                    left=prev[j-1]+matrix[i][j]\\n                else:\\n                    left=1e9+matrix[i][j]\\n\\n                if j+1<m:\\n                    right=prev[j+1]+matrix[i][j]\\n                else:\\n                    right=1e9+matrix[i][j]\\n                curr[j]=min(up,left,right)\\n            prev=curr\\n        return min(prev)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2584949,
                "title": "java-recursion-memo-tabulation-dp-solution",
                "content": "Please UPVOTE the Solution\\n```\\nclass Solution {\\n    \\n    // Dp with Tabulation\\n    public int minFallingPathSum(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int dp[][] = new int[m][n];\\n        for(int j = 0; j < n; j++) {\\n            dp[0][j] = matrix[0][j];\\n        }\\n        for(int i = 1; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(j == 0) {\\n                    dp[i][j] = matrix[i][j] + Math.min(dp[i-1][j], dp[i-1][j+1]);\\n                }\\n                else if(j == n-1) {\\n                    dp[i][j] = matrix[i][j] + Math.min(dp[i-1][j], dp[i-1][j-1]);\\n                }\\n                else {\\n                    dp[i][j] = matrix[i][j] + Math.min(dp[i-1][j], Math.min(dp[i-1][j-1], dp[i-1][j+1]));\\n                }\\n            }\\n        }\\n        int res = Integer.MAX_VALUE;\\n        for(int j = 0; j < n; j++) {\\n            res = Math.min(dp[m-1][j], res);\\n        }\\n        return res;\\n    }\\n    \\n\\t\\t// Recursion with Memoization DP\\n\\t\\t// int dp[][];\\n\\t\\t// public int minFallingPathSum(int[][] matrix) {\\n\\t\\t// int res = Integer.MAX_VALUE;\\n\\t\\t// int m = matrix.length;\\n\\t\\t// int n = matrix[0].length;\\n\\t\\t// dp = new int[m][n];\\n\\t\\t// for(int row[]: dp) \\n\\t\\t// Arrays.fill(row, -200);\\n\\t\\t// for(int j = 0; j < n; j++) {\\n\\t\\t// int temp = helper(matrix.length-1, j, matrix);\\n\\t\\t// res = Math.min(res, temp);\\n\\t\\t// }\\n\\t\\t// return res;\\n\\t\\t// }\\n\\t\\t// private int helper(int i, int j, int[][] mat) {\\n\\t\\t// if(j < 0 || j >= mat.length) {\\n\\t\\t// return (int)1e9;\\n\\t\\t// }\\n\\t\\t// if(i == 0) {\\n\\t\\t// return mat[0][j];\\n\\t\\t// }\\n\\t\\t// if(dp[i][j] != -200) {\\n\\t\\t// return dp[i][j];\\n\\t\\t// }\\n\\t\\t// int up = mat[i][j] + helper(i-1, j, mat);\\n\\t\\t// int rdgu = mat[i][j] + helper(i-1, j+1, mat);\\n\\t\\t// int ldgu = mat[i][j] + helper(i-1, j-1, mat);\\n\\t\\t// return dp[i][j] = Math.min(up, Math.min(ldgu, rdgu));\\n\\t\\t// }\\n}\\n```\\nPlease UPVOTE the solution",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    \\n    // Dp with Tabulation\\n    public int minFallingPathSum(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int dp[][] = new int[m][n];\\n        for(int j = 0; j < n; j++) {\\n            dp[0][j] = matrix[0][j];\\n        }\\n        for(int i = 1; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(j == 0) {\\n                    dp[i][j] = matrix[i][j] + Math.min(dp[i-1][j], dp[i-1][j+1]);\\n                }\\n                else if(j == n-1) {\\n                    dp[i][j] = matrix[i][j] + Math.min(dp[i-1][j], dp[i-1][j-1]);\\n                }\\n                else {\\n                    dp[i][j] = matrix[i][j] + Math.min(dp[i-1][j], Math.min(dp[i-1][j-1], dp[i-1][j+1]));\\n                }\\n            }\\n        }\\n        int res = Integer.MAX_VALUE;\\n        for(int j = 0; j < n; j++) {\\n            res = Math.min(dp[m-1][j], res);\\n        }\\n        return res;\\n    }\\n    \\n\\t\\t// Recursion with Memoization DP\\n\\t\\t// int dp[][];\\n\\t\\t// public int minFallingPathSum(int[][] matrix) {\\n\\t\\t// int res = Integer.MAX_VALUE;\\n\\t\\t// int m = matrix.length;\\n\\t\\t// int n = matrix[0].length;\\n\\t\\t// dp = new int[m][n];\\n\\t\\t// for(int row[]: dp) \\n\\t\\t// Arrays.fill(row, -200);\\n\\t\\t// for(int j = 0; j < n; j++) {\\n\\t\\t// int temp = helper(matrix.length-1, j, matrix);\\n\\t\\t// res = Math.min(res, temp);\\n\\t\\t// }\\n\\t\\t// return res;\\n\\t\\t// }\\n\\t\\t// private int helper(int i, int j, int[][] mat) {\\n\\t\\t// if(j < 0 || j >= mat.length) {\\n\\t\\t// return (int)1e9;\\n\\t\\t// }\\n\\t\\t// if(i == 0) {\\n\\t\\t// return mat[0][j];\\n\\t\\t// }\\n\\t\\t// if(dp[i][j] != -200) {\\n\\t\\t// return dp[i][j];\\n\\t\\t// }\\n\\t\\t// int up = mat[i][j] + helper(i-1, j, mat);\\n\\t\\t// int rdgu = mat[i][j] + helper(i-1, j+1, mat);\\n\\t\\t// int ldgu = mat[i][j] + helper(i-1, j-1, mat);\\n\\t\\t// return dp[i][j] = Math.min(up, Math.min(ldgu, rdgu));\\n\\t\\t// }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2526559,
                "title": "cpp-98-99-faster-solution-space-optimized",
                "content": "\\n```\\n  int n=matrix.size();\\n        int m=matrix[0].size();\\n        int mini=1e8;\\n        vector<int>prev(m,0),cur(m,0);\\n       \\n       for(int j=0;j<m;j++)prev[j]=matrix[0][j];\\n       for(int i=1;i<n;i++){\\n           for(int j=0;j<m;j++){\\n               int  ld = matrix[i][j] ;\\n               if(j-1>=0) ld+= prev[j-1];\\n               else ld+=1e8;\\n               int  u = matrix[i][j] + prev[j];     \\n               int  rd = matrix[i][j] ;\\n               if(j+1<m) rd+= prev[j+1];\\n               else rd+=1e8;\\n               cur[j]=min(u ,min(ld,rd));\\n           }\\n           prev=cur;\\n       }\\n    \\n        for(int j=0;j<m;j++){\\n            mini= min(mini,prev[j]);\\n        }\\n        return mini;\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\n  int n=matrix.size();\\n        int m=matrix[0].size();\\n        int mini=1e8;\\n        vector<int>prev(m,0),cur(m,0);\\n       \\n       for(int j=0;j<m;j++)prev[j]=matrix[0][j];\\n       for(int i=1;i<n;i++){\\n           for(int j=0;j<m;j++){\\n               int  ld = matrix[i][j] ;\\n               if(j-1>=0) ld+= prev[j-1];\\n               else ld+=1e8;\\n               int  u = matrix[i][j] + prev[j];     \\n               int  rd = matrix[i][j] ;\\n               if(j+1<m) rd+= prev[j+1];\\n               else rd+=1e8;\\n               cur[j]=min(u ,min(ld,rd));\\n           }\\n           prev=cur;\\n       }\\n    \\n        for(int j=0;j<m;j++){\\n            mini= min(mini,prev[j]);\\n        }\\n        return mini;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2399423,
                "title": "memoization-tabulation-space-optimization-striver-s-dp",
                "content": "**upvote please it took a lot of effort**\\n\\n##### Memoization\\n```\\nint solve(int i, int j, vector<vector < int>> &matrix, vector< vector< int>> &dp)\\n        {\\n            if (j < 0 || j >= matrix[0].size())\\n            {\\n                return 1e9;\\n            }\\n            if (i == 0)\\n            {\\n                return matrix[i][j];\\n            }\\n            if (dp[i][j] != -1)\\n            {\\n                return dp[i][j];\\n            }\\n            int up = matrix[i][j] + solve(i - 1, j, matrix, dp);\\n            int leftdg = matrix[i][j] + solve(i - 1, j - 1, matrix, dp);\\n            int rightdg = matrix[i][j] + solve(i - 1, j + 1, matrix, dp);\\n            return dp[i][j] = min(up, min(leftdg, rightdg));\\n        }\\n    int minFallingPathSum(vector<vector < int>> &matrix)\\n    {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector < int>> dp(n, vector<int> (m, -1));\\n        int mini = 1e9;\\n        for (int i = 0; i < m; i++)\\n        {\\n            mini = min(mini, solve(n - 1, i, matrix, dp));\\n        }\\n        return mini;\\n    }\\n```\\n##### Tabulation\\n```\\nint minFallingPathSum(vector<vector < int>> &matrix)\\n        {\\n\\n            int n = matrix.size();\\n            int m = matrix[0].size();\\n            vector<int> prev(m, 0), cur(m, 0);\\n            for (int i = 0; i < m; i++)\\n            {\\n                prev[i] = matrix[0][i];\\n            }\\n            for (int i = 1; i < n; i++)\\n            {\\n                for (int j = 0; j < m; j++)\\n                {\\n                    int up = matrix[i][j] + prev[j];\\n                    int ldg = 1e9, rdg = 1e9;\\n                    if (j > 0)\\n                    {\\n                        ldg = matrix[i][j] + prev[j - 1];\\n                    }\\n                    if (j < m - 1)\\n                    {\\n                        rdg = matrix[i][j] + prev[j + 1];\\n                    }\\n                    cur[j] = min(up, min(ldg, rdg));\\n                }\\n                prev = cur;\\n            }\\n            int mini = 1e9;\\n            for (int i = 0; i < m; i++)\\n            {\\n                mini = min(mini, prev[i]);\\n            }\\n            return mini;\\n        }\\n```\\n##### Space optimized\\n```\\nint minFallingPathSum(vector<vector < int>> &matrix)\\n        {\\n\\n            int n = matrix.size();\\n            int m = matrix[0].size();\\n            vector<int> prev(m, 0), cur(m, 0);\\n            for (int i = 0; i < m; i++)\\n            {\\n                prev[i] = matrix[0][i];\\n            }\\n            for (int i = 1; i < n; i++)\\n            {\\n                for (int j = 0; j < m; j++)\\n                {\\n                    int up = matrix[i][j] + prev[j];\\n                    int ldg = 1e9, rdg = 1e9;\\n                    if (j > 0)\\n                    {\\n                        ldg = matrix[i][j] + prev[j - 1];\\n                    }\\n                    if (j < m - 1)\\n                    {\\n                        rdg = matrix[i][j] + prev[j + 1];\\n                    }\\n                    cur[j] = min(up, min(ldg, rdg));\\n                }\\n                prev = cur;\\n            }\\n            int mini = 1e9;\\n            for (int i = 0; i < m; i++)\\n            {\\n                mini = min(mini, prev[i]);\\n            }\\n            return mini;\\n        }\\n```\\n\\n### if you like it then please don\\'t forget to upvote",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nint solve(int i, int j, vector<vector < int>> &matrix, vector< vector< int>> &dp)\\n        {\\n            if (j < 0 || j >= matrix[0].size())\\n            {\\n                return 1e9;\\n            }\\n            if (i == 0)\\n            {\\n                return matrix[i][j];\\n            }\\n            if (dp[i][j] != -1)\\n            {\\n                return dp[i][j];\\n            }\\n            int up = matrix[i][j] + solve(i - 1, j, matrix, dp);\\n            int leftdg = matrix[i][j] + solve(i - 1, j - 1, matrix, dp);\\n            int rightdg = matrix[i][j] + solve(i - 1, j + 1, matrix, dp);\\n            return dp[i][j] = min(up, min(leftdg, rightdg));\\n        }\\n    int minFallingPathSum(vector<vector < int>> &matrix)\\n    {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector < int>> dp(n, vector<int> (m, -1));\\n        int mini = 1e9;\\n        for (int i = 0; i < m; i++)\\n        {\\n            mini = min(mini, solve(n - 1, i, matrix, dp));\\n        }\\n        return mini;\\n    }\\n```\n```\\nint minFallingPathSum(vector<vector < int>> &matrix)\\n        {\\n\\n            int n = matrix.size();\\n            int m = matrix[0].size();\\n            vector<int> prev(m, 0), cur(m, 0);\\n            for (int i = 0; i < m; i++)\\n            {\\n                prev[i] = matrix[0][i];\\n            }\\n            for (int i = 1; i < n; i++)\\n            {\\n                for (int j = 0; j < m; j++)\\n                {\\n                    int up = matrix[i][j] + prev[j];\\n                    int ldg = 1e9, rdg = 1e9;\\n                    if (j > 0)\\n                    {\\n                        ldg = matrix[i][j] + prev[j - 1];\\n                    }\\n                    if (j < m - 1)\\n                    {\\n                        rdg = matrix[i][j] + prev[j + 1];\\n                    }\\n                    cur[j] = min(up, min(ldg, rdg));\\n                }\\n                prev = cur;\\n            }\\n            int mini = 1e9;\\n            for (int i = 0; i < m; i++)\\n            {\\n                mini = min(mini, prev[i]);\\n            }\\n            return mini;\\n        }\\n```\n```\\nint minFallingPathSum(vector<vector < int>> &matrix)\\n        {\\n\\n            int n = matrix.size();\\n            int m = matrix[0].size();\\n            vector<int> prev(m, 0), cur(m, 0);\\n            for (int i = 0; i < m; i++)\\n            {\\n                prev[i] = matrix[0][i];\\n            }\\n            for (int i = 1; i < n; i++)\\n            {\\n                for (int j = 0; j < m; j++)\\n                {\\n                    int up = matrix[i][j] + prev[j];\\n                    int ldg = 1e9, rdg = 1e9;\\n                    if (j > 0)\\n                    {\\n                        ldg = matrix[i][j] + prev[j - 1];\\n                    }\\n                    if (j < m - 1)\\n                    {\\n                        rdg = matrix[i][j] + prev[j + 1];\\n                    }\\n                    cur[j] = min(up, min(ldg, rdg));\\n                }\\n                prev = cur;\\n            }\\n            int mini = 1e9;\\n            for (int i = 0; i < m; i++)\\n            {\\n                mini = min(mini, prev[i]);\\n            }\\n            return mini;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1967536,
                "title": "java-consise-easy-tabulation",
                "content": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix){\\n        int n = matrix.length,res = Integer.MAX_VALUE;\\n        int[][] dp = new int[n][n];\\n        for(int i=n-1;i>=0;i--)\\n            for(int j=0;j<n;j++){\\n                if(i == n-1) dp[i][j] = matrix[i][j];\\n                else if(j==0) dp[i][j] = matrix[i][j] + Math.min(dp[i+1][j],dp[i+1][j+1]);\\n                else if(j==matrix[0].length-1) dp[i][j] = matrix[i][j] + Math.min(dp[i+1][j],dp[i+1][j-1]);\\n                else dp[i][j] = matrix[i][j] + Math.min(dp[i+1][j],Math.min(dp[i+1][j+1],dp[i+1][j-1]));\\n                if(i==0) res = Math.min(res,dp[i][j]);\\n            }\\n        return res;\\n     }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix){\\n        int n = matrix.length,res = Integer.MAX_VALUE;\\n        int[][] dp = new int[n][n];\\n        for(int i=n-1;i>=0;i--)\\n            for(int j=0;j<n;j++){\\n                if(i == n-1) dp[i][j] = matrix[i][j];\\n                else if(j==0) dp[i][j] = matrix[i][j] + Math.min(dp[i+1][j],dp[i+1][j+1]);\\n                else if(j==matrix[0].length-1) dp[i][j] = matrix[i][j] + Math.min(dp[i+1][j],dp[i+1][j-1]);\\n                else dp[i][j] = matrix[i][j] + Math.min(dp[i+1][j],Math.min(dp[i+1][j+1],dp[i+1][j-1]));\\n                if(i==0) res = Math.min(res,dp[i][j]);\\n            }\\n        return res;\\n     }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1871019,
                "title": "go-dp-o-n-m-time-in-place-o-1-space-clear-solution",
                "content": "O(n*m) Time, O(1) Space (In-place, using input matrix)\\n```\\nfunc minFallingPathSum(matrix [][]int) int {\\n    m, n := len(matrix), len(matrix[0])\\n    for r := 1; r < m; r++ {\\n        for c := 0; c < n; c++ {\\n            switch c {\\n                case 0:     matrix[r][c] += Min(matrix[r-1][c], matrix[r-1][c+1])\\n                case n-1:   matrix[r][c] += Min(matrix[r-1][c-1], matrix[r-1][c])\\n                default:    matrix[r][c] += Min(matrix[r-1][c-1], Min(matrix[r-1][c], matrix[r-1][c+1]))\\n            }\\n        }\\n    }\\n    min := math.MaxInt\\n    for c := 0; c < n; c++ { min = Min(min, matrix[m-1][c]) }\\n    return min\\n}\\n\\nfunc Min(a, b int) int {\\n    if a < b { return a }\\n    return b\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```\\nfunc minFallingPathSum(matrix [][]int) int {\\n    m, n := len(matrix), len(matrix[0])\\n    for r := 1; r < m; r++ {\\n        for c := 0; c < n; c++ {\\n            switch c {\\n                case 0:     matrix[r][c] += Min(matrix[r-1][c], matrix[r-1][c+1])\\n                case n-1:   matrix[r][c] += Min(matrix[r-1][c-1], matrix[r-1][c])\\n                default:    matrix[r][c] += Min(matrix[r-1][c-1], Min(matrix[r-1][c], matrix[r-1][c+1]))\\n            }\\n        }\\n    }\\n    min := math.MaxInt\\n    for c := 0; c < n; c++ { min = Min(min, matrix[m-1][c]) }\\n    return min\\n}\\n\\nfunc Min(a, b int) int {\\n    if a < b { return a }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1807460,
                "title": "easy-dp-solution-in-java",
                "content": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] mat) {\\n        int m=mat.length;\\n        int dp[][]=new int[m][m];\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(i==0)                   //no need to calc sum in first row\\n                    dp[i][j]=mat[i][j];\\n\\t\\t\\t\\telse if(j==0)              //when in first column find the minimum number on top or top-right diagonal\\n                    dp[i][j]=mat[i][j]+Math.min(dp[i-1][j],dp[i-1][j+1]);\\n                else if(j==m-1)            //when in last column find the minimum number on top or top-left diagonal\\n                    dp[i][j]=mat[i][j]+Math.min(dp[i-1][j],dp[i-1][j-1]);\\n                else                       //find the minimum number on top or top-left diagonal or top-right diagonal\\n                    dp[i][j]=mat[i][j]+Math.min(Math.min(dp[i-1][j],dp[i-1][j-1]),dp[i-1][j+1]);\\n            }\\n        }\\n        int min=Integer.MAX_VALUE;\\n\\t\\tfor(int j=0;j<m;j++)               //find the minimum in last row\\n            min=Math.min(dp[m-1][j],min);\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] mat) {\\n        int m=mat.length;\\n        int dp[][]=new int[m][m];\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(i==0)                   //no need to calc sum in first row\\n                    dp[i][j]=mat[i][j];\\n\\t\\t\\t\\telse if(j==0)              //when in first column find the minimum number on top or top-right diagonal\\n                    dp[i][j]=mat[i][j]+Math.min(dp[i-1][j],dp[i-1][j+1]);\\n                else if(j==m-1)            //when in last column find the minimum number on top or top-left diagonal\\n                    dp[i][j]=mat[i][j]+Math.min(dp[i-1][j],dp[i-1][j-1]);\\n                else                       //find the minimum number on top or top-left diagonal or top-right diagonal\\n                    dp[i][j]=mat[i][j]+Math.min(Math.min(dp[i-1][j],dp[i-1][j-1]),dp[i-1][j+1]);\\n            }\\n        }\\n        int min=Integer.MAX_VALUE;\\n\\t\\tfor(int j=0;j<m;j++)               //find the minimum in last row\\n            min=Math.min(dp[m-1][j],min);\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1674573,
                "title": "solution-swift-minimum-falling-path-sum-test-cases",
                "content": "```swift\\nclass Solution {\\n    func minFallingPathSum(_ matrix: [[Int]]) -> Int {\\n        let len = matrix.count, n = matrix[0].count\\n        if len <= 1 { return len == 0 ? 0 : matrix[0].min()! }\\n        var mat: [[Int]] = matrix\\n        for i in 1..<len {\\n            for j in 0..<n {\\n                var tmp = mat[i-1][j]\\n                if j + 1 < n { tmp = min(tmp, mat[i-1][j+1]) }\\n                if j - 1 >= 0 { tmp = min(tmp, mat[i-1][j-1]) }\\n                mat[i][j] += tmp\\n            }\\n        }\\n        return mat.last!.min()!\\n    }\\n}\\n```\\n\\n---\\n\\n<p>\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 2 tests, with 0 failures (0 unexpected) in 0.009 (0.011) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    /// There are two falling paths with a minimum sum as shown.\\n    func test0() {\\n        let value = solution.minFallingPathSum([[2,1,3],[6,5,4],[7,8,9]])\\n        XCTAssertEqual(value, 13)\\n    }\\n    \\n    /// The falling path with a minimum sum is shown.\\n    func test1() {\\n        let value = solution.minFallingPathSum([[-19,57],[-40,-5]])\\n        XCTAssertEqual(value, -59)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func minFallingPathSum(_ matrix: [[Int]]) -> Int {\\n        let len = matrix.count, n = matrix[0].count\\n        if len <= 1 { return len == 0 ? 0 : matrix[0].min()! }\\n        var mat: [[Int]] = matrix\\n        for i in 1..<len {\\n            for j in 0..<n {\\n                var tmp = mat[i-1][j]\\n                if j + 1 < n { tmp = min(tmp, mat[i-1][j+1]) }\\n                if j - 1 >= 0 { tmp = min(tmp, mat[i-1][j-1]) }\\n                mat[i][j] += tmp\\n            }\\n        }\\n        return mat.last!.min()!\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    /// There are two falling paths with a minimum sum as shown.\\n    func test0() {\\n        let value = solution.minFallingPathSum([[2,1,3],[6,5,4],[7,8,9]])\\n        XCTAssertEqual(value, 13)\\n    }\\n    \\n    /// The falling path with a minimum sum is shown.\\n    func test1() {\\n        let value = solution.minFallingPathSum([[-19,57],[-40,-5]])\\n        XCTAssertEqual(value, -59)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1592660,
                "title": "easy-to-understand-in-c-amazing-bottom-to-up",
                "content": "class Solution {\\npublic:\\n\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        for(int i=n-2;i>=0;i--){\\n            for(int j=0;j<n;j++){\\n                int low=matrix[i+1][j];\\n                if(j-1>=0){\\n                    low=min(low,matrix[i+1][j-1]);\\n                }\\n                if(j+1<n){\\n                    low=min(low,matrix[i+1][j+1]);\\n                }\\n                matrix[i][j]+=low;\\n            }\\n        }\\n        int ans=matrix[0][0];\\n        for(int i=0;i<n;i++){\\n            ans=min(ans,matrix[0][i]);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        for(int i=n-2;i>=0;i--){\\n            for(int j=0;j<n;j++){\\n                int low=matrix[i+1][j];\\n                if(j-1>=0){\\n                    low=min(low,matrix[i+1][j-1]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1354472,
                "title": "java-recursion-memoization-bottom-up-1ms-beats-99-62-t-c-o-n-2-s-c-o-n-2",
                "content": "\\n\\t// Recursion\\n\\t// O(n*3^n) O(n)\\n\\tpublic int minFallingPathSumRec(int[][] matrix) {\\n\\n\\t\\tint n = matrix.length, min = Integer.MAX_VALUE;\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\tmin = Math.min(min, minFallingPathSumRecHelper(matrix, 0, i, n));\\n\\t\\treturn min;\\n\\t}\\n\\n\\t// Recursion\\n\\t// O(n*3^n) O(n)\\n\\tpublic int minFallingPathSumRecHelper(int[][] matrix, int row, int col, int n) {\\n\\n\\t\\tif (row == n)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\tif (col - 1 >= 0)\\n\\t\\t\\tmin = Math.min(min, minFallingPathSumRecHelper(matrix, row + 1, col - 1, n) + matrix[row][col]);\\n\\n\\t\\tmin = Math.min(min, minFallingPathSumRecHelper(matrix, row + 1, col, n) + matrix[row][col]);\\n\\n\\t\\tif (col + 1 < n)\\n\\t\\t\\tmin = Math.min(min, minFallingPathSumRecHelper(matrix, row + 1, col + 1, n) + matrix[row][col]);\\n\\n\\t\\treturn min;\\n\\t}\\n\\n\\t// Memoization\\n\\t// O(n^2) O(n^2)\\n\\tpublic int minFallingPathSumMemo(int[][] matrix) {\\n\\n\\t\\tint n = matrix.length, min = Integer.MAX_VALUE;\\n\\t\\tInteger[][] memo = new Integer[n][n];\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\tmin = Math.min(min, minFallingPathSumMemoHelper(matrix, 0, i, n, memo));\\n\\t\\treturn min;\\n\\t}\\n\\n\\t// Memoization\\n\\t// O(n^2) O(n^2)\\n\\tpublic int minFallingPathSumMemoHelper(int[][] matrix, int row, int col, int n, Integer[][] memo) {\\n\\n\\t\\tif (row == n)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tif (memo[row][col] != null)\\n\\t\\t\\treturn memo[row][col];\\n\\n\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\tif (col - 1 >= 0)\\n\\t\\t\\tmin = Math.min(min, minFallingPathSumMemoHelper(matrix, row + 1, col - 1, n, memo) + matrix[row][col]);\\n\\n\\t\\tmin = Math.min(min, minFallingPathSumMemoHelper(matrix, row + 1, col, n, memo) + matrix[row][col]);\\n\\n\\t\\tif (col + 1 < n)\\n\\t\\t\\tmin = Math.min(min, minFallingPathSumMemoHelper(matrix, row + 1, col + 1, n, memo) + matrix[row][col]);\\n\\n\\t\\tmemo[row][col] = min;\\n\\t\\treturn min;\\n\\t}\\n\\n\\t// Bottom Up\\n\\t// O(n^2) O(n^2)\\n\\tpublic int minFallingPathSumBU(int[][] matrix) {\\n\\n\\t\\tint n = matrix.length, ans = Integer.MAX_VALUE;\\n\\t\\tint[][] dp = new int[n + 1][n];\\n\\n\\t\\tfor (int i = n - 1; i >= 0; i--) {\\n\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\t\\t\\tif (j - 1 >= 0)\\n\\t\\t\\t\\t\\tmin = Math.min(min, dp[i + 1][j - 1]);\\n\\t\\t\\t\\tmin = Math.min(min, dp[i + 1][j]);\\n\\t\\t\\t\\tif (j + 1 < n)\\n\\t\\t\\t\\t\\tmin = Math.min(min, dp[i + 1][j + 1]);\\n\\t\\t\\t\\tdp[i][j] = min + matrix[i][j];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\tans = Math.min(ans, dp[0][i]);\\n\\n\\t\\treturn ans;\\n\\t}",
                "solutionTags": [],
                "code": "\\n\\t// Recursion\\n\\t// O(n*3^n) O(n)\\n\\tpublic int minFallingPathSumRec(int[][] matrix) {\\n\\n\\t\\tint n = matrix.length, min = Integer.MAX_VALUE;\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\tmin = Math.min(min, minFallingPathSumRecHelper(matrix, 0, i, n));\\n\\t\\treturn min;\\n\\t}\\n\\n\\t// Recursion\\n\\t// O(n*3^n) O(n)\\n\\tpublic int minFallingPathSumRecHelper(int[][] matrix, int row, int col, int n) {\\n\\n\\t\\tif (row == n)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\tif (col - 1 >= 0)\\n\\t\\t\\tmin = Math.min(min, minFallingPathSumRecHelper(matrix, row + 1, col - 1, n) + matrix[row][col]);\\n\\n\\t\\tmin = Math.min(min, minFallingPathSumRecHelper(matrix, row + 1, col, n) + matrix[row][col]);\\n\\n\\t\\tif (col + 1 < n)\\n\\t\\t\\tmin = Math.min(min, minFallingPathSumRecHelper(matrix, row + 1, col + 1, n) + matrix[row][col]);\\n\\n\\t\\treturn min;\\n\\t}\\n\\n\\t// Memoization\\n\\t// O(n^2) O(n^2)\\n\\tpublic int minFallingPathSumMemo(int[][] matrix) {\\n\\n\\t\\tint n = matrix.length, min = Integer.MAX_VALUE;\\n\\t\\tInteger[][] memo = new Integer[n][n];\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\tmin = Math.min(min, minFallingPathSumMemoHelper(matrix, 0, i, n, memo));\\n\\t\\treturn min;\\n\\t}\\n\\n\\t// Memoization\\n\\t// O(n^2) O(n^2)\\n\\tpublic int minFallingPathSumMemoHelper(int[][] matrix, int row, int col, int n, Integer[][] memo) {\\n\\n\\t\\tif (row == n)\\n\\t\\t\\treturn 0;\\n\\n\\t\\tif (memo[row][col] != null)\\n\\t\\t\\treturn memo[row][col];\\n\\n\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\tif (col - 1 >= 0)\\n\\t\\t\\tmin = Math.min(min, minFallingPathSumMemoHelper(matrix, row + 1, col - 1, n, memo) + matrix[row][col]);\\n\\n\\t\\tmin = Math.min(min, minFallingPathSumMemoHelper(matrix, row + 1, col, n, memo) + matrix[row][col]);\\n\\n\\t\\tif (col + 1 < n)\\n\\t\\t\\tmin = Math.min(min, minFallingPathSumMemoHelper(matrix, row + 1, col + 1, n, memo) + matrix[row][col]);\\n\\n\\t\\tmemo[row][col] = min;\\n\\t\\treturn min;\\n\\t}\\n\\n\\t// Bottom Up\\n\\t// O(n^2) O(n^2)\\n\\tpublic int minFallingPathSumBU(int[][] matrix) {\\n\\n\\t\\tint n = matrix.length, ans = Integer.MAX_VALUE;\\n\\t\\tint[][] dp = new int[n + 1][n];\\n\\n\\t\\tfor (int i = n - 1; i >= 0; i--) {\\n\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\t\\t\\tif (j - 1 >= 0)\\n\\t\\t\\t\\t\\tmin = Math.min(min, dp[i + 1][j - 1]);\\n\\t\\t\\t\\tmin = Math.min(min, dp[i + 1][j]);\\n\\t\\t\\t\\tif (j + 1 < n)\\n\\t\\t\\t\\t\\tmin = Math.min(min, dp[i + 1][j + 1]);\\n\\t\\t\\t\\tdp[i][j] = min + matrix[i][j];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\tans = Math.min(ans, dp[0][i]);\\n\\n\\t\\treturn ans;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 785637,
                "title": "python3-faster-than-99-33-dp",
                "content": "```\\nclass Solution:\\n    def minFallingPathSum(self, A: List[List[int]]) -> int:\\n        n = len(A)\\n        path = [[0 for x in range(n)] for y in range(n)]\\n        \\n        # initial state\\n        path[0] = A[0]\\n        \\n        for i in range(1, n):\\n            for j in range(n):\\n                if 0 < j < n -1:\\n                    path[i][j] = min(path[i-1][j-1], path[i-1][j], path[i-1][j+1]) + A[i][j]\\n                elif j == 0:\\n                    path[i][j] = min(path[i-1][j], path[i-1][j+1]) + A[i][j]\\n                else:\\n                    path[i][j] = min(path[i-1][j-1], path[i-1][j]) + A[i][j]\\n                    \\n        return min(path[-1])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minFallingPathSum(self, A: List[List[int]]) -> int:\\n        n = len(A)\\n        path = [[0 for x in range(n)] for y in range(n)]\\n        \\n        # initial state\\n        path[0] = A[0]\\n        \\n        for i in range(1, n):\\n            for j in range(n):\\n                if 0 < j < n -1:\\n                    path[i][j] = min(path[i-1][j-1], path[i-1][j], path[i-1][j+1]) + A[i][j]\\n                elif j == 0:\\n                    path[i][j] = min(path[i-1][j], path[i-1][j+1]) + A[i][j]\\n                else:\\n                    path[i][j] = min(path[i-1][j-1], path[i-1][j]) + A[i][j]\\n                    \\n        return min(path[-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 657787,
                "title": "simple-cpp-solution-with-detailed-explanation-o-n-x-m-tc",
                "content": "```\\n    int minFallingPathSum(vector<vector<int>>& A) {\\n        int rowSize = A.size(), colSize = A[0].size(), res = INT_MAX;\\n        //DP vector. Initialize all elements to 0\\n        vector<vector<int>> dp(rowSize, vector<int>(colSize, 0));\\n        \\n        //Copy first row\\n        for(int i = 0; i < colSize; i++)\\n            dp[0][i] = A[0][i];        \\n        \\n        //Traverse from second row and first col\\n        for(int i = 1; i < rowSize; i++)\\n        {\\n            for(int j = 0; j < colSize; j++)\\n            {\\n                int temp;\\n                //If it is first column, then take only first two columns in previous row for dp\\n                if(j == 0)\\n                    temp = min(dp[i-1][j], dp[i-1][j+1]);\\n                //If it is last column then take only last two columns in previous row for dp\\n                else if(j == (colSize - 1) )\\n                    temp = min(dp[i-1][j], dp[i-1][j-1]);\\n                //Else take current, preceeding and suceeding columns in previous row for dp\\n                else\\n                    temp = min(dp[i-1][j], min(dp[i-1][j-1], dp[i-1][j+1]));\\n                \\n                dp[i][j] = A[i][j] + temp;\\n            }\\n        }\\n        //Iterate through last row of Dp and take min sum\\n        for(int i = 0; i < colSize; i++)\\n            res = min(res, dp[rowSize-1][i]);\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int minFallingPathSum(vector<vector<int>>& A) {\\n        int rowSize = A.size(), colSize = A[0].size(), res = INT_MAX;\\n        //DP vector. Initialize all elements to 0\\n        vector<vector<int>> dp(rowSize, vector<int>(colSize, 0));\\n        \\n        //Copy first row\\n        for(int i = 0; i < colSize; i++)\\n            dp[0][i] = A[0][i];        \\n        \\n        //Traverse from second row and first col\\n        for(int i = 1; i < rowSize; i++)\\n        {\\n            for(int j = 0; j < colSize; j++)\\n            {\\n                int temp;\\n                //If it is first column, then take only first two columns in previous row for dp\\n                if(j == 0)\\n                    temp = min(dp[i-1][j], dp[i-1][j+1]);\\n                //If it is last column then take only last two columns in previous row for dp\\n                else if(j == (colSize - 1) )\\n                    temp = min(dp[i-1][j], dp[i-1][j-1]);\\n                //Else take current, preceeding and suceeding columns in previous row for dp\\n                else\\n                    temp = min(dp[i-1][j], min(dp[i-1][j-1], dp[i-1][j+1]));\\n                \\n                dp[i][j] = A[i][j] + temp;\\n            }\\n        }\\n        //Iterate through last row of Dp and take min sum\\n        for(int i = 0; i < colSize; i++)\\n            res = min(res, dp[rowSize-1][i]);\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 455701,
                "title": "how-the-memory-usage-in-leetcode-is-calculated",
                "content": "If I use extra `2-dim dp[][]` array, the memory usage is 13.3MB.\\nBut if I don\\'t use any extra variables, the memory usage increased to 13.8MB.\\nCould someone explain me where is wrong? Thanks~\\n\\n- 2-dim dp[][] array code as follows, whose memory usage is 13.3MB:\\n```\\nclass Solution:\\n    def minFallingPathSum(self, A: List[List[int]]) -> int:\\n        # dp[i][j] the minimum sum in ith row jth column\\n        dp = []\\n        [dp.append([0] * len(A)) for i in range(len(A))]\\n\\n        for i in range(len(A)):\\n            dp[0][i] = A[0][i]\\n\\t\\t\\t\\n        for i in range(1, len(A)):\\n            for j in range(len(A)):\\n                if j == 0:\\n                    dp[i][j] = min(dp[i-1][j], dp[i-1][j+1]) + A[i][j]\\n                elif j == len(A) - 1:\\n                    dp[i][j] = min(dp[i-1][j-1], dp[i-1][j]) + A[i][j]\\n                else:\\n                    dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i-1][j+1]) + A[i][j]\\n\\n        return min(dp[i])\\n```\\n\\n- No extra variables code is bellow, whose memory usage is 13.8MB:\\n```\\nclass Solution:\\n    def minFallingPathSum(self, A: List[List[int]]) -> int:\\n\\n        for i in range(1, len(A)):\\n            for j in range(len(A)):\\n                if j == 0:\\n                    A[i][j] = min(A[i-1][j], A[i-1][j+1]) + A[i][j]\\n                elif j == len(A) - 1:\\n                    A[i][j] = min(A[i-1][j-1], A[i-1][j]) + A[i][j]\\n                else:\\n                    A[i][j] = min(A[i-1][j-1], A[i-1][j], A[i-1][j+1]) + A[i][j]\\n        return min(A[-1])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minFallingPathSum(self, A: List[List[int]]) -> int:\\n        # dp[i][j] the minimum sum in ith row jth column\\n        dp = []\\n        [dp.append([0] * len(A)) for i in range(len(A))]\\n\\n        for i in range(len(A)):\\n            dp[0][i] = A[0][i]\\n\\t\\t\\t\\n        for i in range(1, len(A)):\\n            for j in range(len(A)):\\n                if j == 0:\\n                    dp[i][j] = min(dp[i-1][j], dp[i-1][j+1]) + A[i][j]\\n                elif j == len(A) - 1:\\n                    dp[i][j] = min(dp[i-1][j-1], dp[i-1][j]) + A[i][j]\\n                else:\\n                    dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i-1][j+1]) + A[i][j]\\n\\n        return min(dp[i])\\n```\n```\\nclass Solution:\\n    def minFallingPathSum(self, A: List[List[int]]) -> int:\\n\\n        for i in range(1, len(A)):\\n            for j in range(len(A)):\\n                if j == 0:\\n                    A[i][j] = min(A[i-1][j], A[i-1][j+1]) + A[i][j]\\n                elif j == len(A) - 1:\\n                    A[i][j] = min(A[i-1][j-1], A[i-1][j]) + A[i][j]\\n                else:\\n                    A[i][j] = min(A[i-1][j-1], A[i-1][j], A[i-1][j+1]) + A[i][j]\\n        return min(A[-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 411948,
                "title": "easy-to-understand-dfs-memo-python-with-dp-recipe",
                "content": "1) Determine if it\\'s DP Problem\\n2) Think about states and thing that change from state. -> position (i,j) change and min () from state to state\\n3) Think about the equation -> F(i,j)=A[i][j] +min(F(i+1,j),F(i+1,j+1),F(i+1,j-1))\\n4)  Think about the recursive solution and how to handle edge cases (this one tricky, you need to handle being off the board some how while maintaing the at most 1 over rule) I used min and max to determine the the rule for going left and right -> `left = max(0,j-1)` and `right = min(len(A)-1,j+1)`\\n```\\ndef dfs(self,A,i,j,memo):\\n        if i >= len(A):\\n            return 0\\n        return A[i][j] + min(self.dfs(A,i+1,j,memo),self.dfs(A,i+1,max(0,j-1),memo), self.dfs(A,i+1,min(len(A)-1,j+1),memo))\\n```\\n5)  memozation to help with TLE and your done with a good enough N^2 time N^2 space solution\\n\\nNote: Can def be optimize but this should be good enough to get you through that round of interviewing =D\\n```\\ndef minFallingPathSum(self, A):\\n        \"\"\"\\n        :type A: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        n = len(A[0])\\n        memo = [[None for _ in range(n)] for _ in range(n)] \\n        min_count = float(\\'inf\\')\\n        for j in range(n):\\n            min_count=min(min_count,self.dfs(A,0,j,memo))\\n        return min_count\\n\\n    def dfs(self,A,i,j,memo):\\n        if i >= len(A):\\n            return 0\\n        if memo[i][j]:\\n            return memo[i][j]\\n        memo[i][j]=A[i][j] + min(self.dfs(A,i+1,j,memo),self.dfs(A,i+1,max(0,j-1),memo), self.dfs(A,i+1,min(len(A)-1,j+1),memo))\\n        return memo[i][j]\\n\\t\\t```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\ndef dfs(self,A,i,j,memo):\\n        if i >= len(A):\\n            return 0\\n        return A[i][j] + min(self.dfs(A,i+1,j,memo),self.dfs(A,i+1,max(0,j-1),memo), self.dfs(A,i+1,min(len(A)-1,j+1),memo))\\n```\n```\\ndef minFallingPathSum(self, A):\\n        \"\"\"\\n        :type A: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        n = len(A[0])\\n        memo = [[None for _ in range(n)] for _ in range(n)] \\n        min_count = float(\\'inf\\')\\n        for j in range(n):\\n            min_count=min(min_count,self.dfs(A,0,j,memo))\\n        return min_count\\n\\n    def dfs(self,A,i,j,memo):\\n        if i >= len(A):\\n            return 0\\n        if memo[i][j]:\\n            return memo[i][j]\\n        memo[i][j]=A[i][j] + min(self.dfs(A,i+1,j,memo),self.dfs(A,i+1,max(0,j-1),memo), self.dfs(A,i+1,min(len(A)-1,j+1),memo))\\n        return memo[i][j]\\n\\t\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 186671,
                "title": "java-dp-clean-code",
                "content": "```\\nclass Solution {\\n        int n=A.length;\\n        int[][] dp=new int[n][n];\\n        for (int[] line:dp){\\n            Arrays.fill(line,Integer.MAX_VALUE); \\n        }\\n        for (int i=0;i<n;i++){\\n            for (int j=0;j<n;j++){\\n                if(i==0) dp[i][j]=A[i][j];\\n                else{\\n                    dp[i][j]=dp[i-1][j];\\n                    if(j-1>=0) dp[i][j]=Math.min(dp[i][j],dp[i-1][j-1]);\\n                    if(j+1<n) dp[i][j]=Math.min(dp[i][j],dp[i-1][j+1]);\\n                    dp[i][j]+=A[i][j];  \\n                }\\n            }\\n        }\\n        int min=Integer.MAX_VALUE;\\n        for (int sum:dp[n-1]){\\n            min=Math.min(min,sum);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n        int n=A.length;\\n        int[][] dp=new int[n][n];\\n        for (int[] line:dp){\\n            Arrays.fill(line,Integer.MAX_VALUE); \\n        }\\n        for (int i=0;i<n;i++){\\n            for (int j=0;j<n;j++){\\n                if(i==0) dp[i][j]=A[i][j];\\n                else{\\n                    dp[i][j]=dp[i-1][j];\\n                    if(j-1>=0) dp[i][j]=Math.min(dp[i][j],dp[i-1][j-1]);\\n                    if(j+1<n) dp[i][j]=Math.min(dp[i][j],dp[i-1][j+1]);\\n                    dp[i][j]+=A[i][j];  \\n                }\\n            }\\n        }\\n        int min=Integer.MAX_VALUE;\\n        for (int sum:dp[n-1]){\\n            min=Math.min(min,sum);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 186651,
                "title": "java-two-clean-dp-codes-input-modified-and-not-time-o-n-2-space-o-1-o-n",
                "content": "\\nMethod 1: input **modified**.\\nTime: ```O(n ^ 2)```, space: ```O(1)```\\n\\n1. Starting from 2nd row, for each element, choose to add the minimum of the above 3 (or 2 if at either end of the row);\\n2. Repeat till the last row;\\n3. Find the minimum out of the last row.\\n\\n\\n```\\n    public int minFallingPathSum(int[][] A) {\\n        int n = A.length;\\n        for (int i = 1; i < n; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                int minOfAbove3 = A[i - 1][j];\\n                if (j > 0 && A[i - 1][j - 1] < minOfAbove3) { minOfAbove3 = A[i - 1][j - 1]; }\\n                if (j + 1 < n && A[i - 1][j + 1] < minOfAbove3) { minOfAbove3 = A[i - 1][j + 1]; }\\n                A[i][j] += minOfAbove3;            \\n            }\\n        }\\n        return  Arrays.stream(A[n - 1]).min().getAsInt();\\n    }\\n```\\n\\nMethod 2: Input **NOT modified**.\\nTime: ```O(n ^ 2)```, space: ```O(n)```\\n\\n1. Use a two-row array to store previous and current path value;\\n2. Use ```^= 1``` to switch between the two rows.\\n\\n```\\n    public int minFallingPathSum(int[][] A) {\\n        int n = A.length;\\n        int[][] paths = new int[2][n];\\n        for (int i = 0, k = 0; i < n; ++i, k ^= 1) {\\n            for (int j = 0; j < n; ++j) {\\n                int minOfAbove3 = paths[k][j]; // paths[k] - previous path value.\\n                if (j > 0 && paths[k][j - 1] < minOfAbove3) { minOfAbove3 = paths[k][j - 1]; }\\n                if (j + 1 < n && paths[k][j + 1] < minOfAbove3) { minOfAbove3 = paths[k][j + 1]; }\\n                paths[k ^ 1][j] = minOfAbove3 + A[i][j]; // paths[k ^ 1] - current path value.\\n            }\\n        }\\n        return Arrays.stream(paths[n % 2]).min().getAsInt();\\n    }\\n```",
                "solutionTags": [],
                "code": "```O(n ^ 2)```\n```O(1)```\n```\\n    public int minFallingPathSum(int[][] A) {\\n        int n = A.length;\\n        for (int i = 1; i < n; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                int minOfAbove3 = A[i - 1][j];\\n                if (j > 0 && A[i - 1][j - 1] < minOfAbove3) { minOfAbove3 = A[i - 1][j - 1]; }\\n                if (j + 1 < n && A[i - 1][j + 1] < minOfAbove3) { minOfAbove3 = A[i - 1][j + 1]; }\\n                A[i][j] += minOfAbove3;            \\n            }\\n        }\\n        return  Arrays.stream(A[n - 1]).min().getAsInt();\\n    }\\n```\n```O(n ^ 2)```\n```O(n)```\n```^= 1```\n```\\n    public int minFallingPathSum(int[][] A) {\\n        int n = A.length;\\n        int[][] paths = new int[2][n];\\n        for (int i = 0, k = 0; i < n; ++i, k ^= 1) {\\n            for (int j = 0; j < n; ++j) {\\n                int minOfAbove3 = paths[k][j]; // paths[k] - previous path value.\\n                if (j > 0 && paths[k][j - 1] < minOfAbove3) { minOfAbove3 = paths[k][j - 1]; }\\n                if (j + 1 < n && paths[k][j + 1] < minOfAbove3) { minOfAbove3 = paths[k][j + 1]; }\\n                paths[k ^ 1][j] = minOfAbove3 + A[i][j]; // paths[k ^ 1] - current path value.\\n            }\\n        }\\n        return Arrays.stream(paths[n % 2]).min().getAsInt();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3894169,
                "title": "python-92-56-faster-dp-memoization-tabulation",
                "content": "```\\n#Recursion \\n#Time Complexity: O(3^n)\\n#Space Complexity: O(n)\\nclass Solution1:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        def solve(i,j):\\n            if j>=n or j<0:\\n                return float(\\'inf\\')\\n            if i==0:\\n                return matrix[i][j]\\n            up=matrix[i][j]+solve(i-1,j)\\n            left=matrix[i][j]+solve(i-1,j-1)\\n            right=matrix[i][j]+solve(i-1,j+1)\\n            return min(up,left,right)\\n        n=len(matrix)\\n        m=float(\\'inf\\')\\n        for j in range(n):\\n            m=min(m,solve(n-1,j))\\n        return m\\n    \\n#Memoization (Top-Down)\\n#Time Complexity: O(n^2)\\n#Space Complexity: O(n) + O(n^2)\\nclass Solution2:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        def solve(i,j):\\n            if j>=n or j<0:\\n                return float(\\'inf\\')\\n            if i==0:\\n                return matrix[i][j]\\n            if dp[i][j]!=-1:\\n                return dp[i][j]\\n            up=matrix[i][j]+solve(i-1,j)\\n            left=matrix[i][j]+solve(i-1,j-1)\\n            right=matrix[i][j]+solve(i-1,j+1)\\n            return min(up,left,right)\\n        n=len(matrix)\\n        m=float(\\'inf\\')\\n        dp=[[-1 for j in range(n)] for i in range(n)]\\n        for j in range(n):\\n            m=min(m,solve(n-1,j))\\n        return m\\n\\n\\n#Tabulation (Bottom-Up)\\n#Time Complexity: O(n^2)\\n#Space Complexity: O(n^2)\\nclass Solution3:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        n=len(matrix)\\n        dp=[[0 for j in range(n)] for i in range(n)]\\n        for i in range(n):\\n            for j in range(n):\\n                if i==0:\\n                    dp[i][j]=matrix[i][j]\\n                    continue\\n                up=matrix[i][j]+dp[i-1][j]\\n                left=right=float(\\'inf\\')\\n                if j>0:\\n                    left=matrix[i][j]+dp[i-1][j-1]\\n                if j<n-1:\\n                    right=matrix[i][j]+dp[i-1][j+1]\\n                dp[i][j]=min(up,left,right)\\n        m=float(\\'inf\\')\\n        print(dp)\\n        for j in range(n):\\n            m=min(m,dp[n-1][j])\\n        return m\\n    \\n#Space Optimization\\n#Time Complexity: O(n^2)\\n#Space Complexity: O(n)\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        n=len(matrix)\\n        prev=[0]*n\\n        for i in range(n):\\n            curr=[0]*n\\n            for j in range(n):\\n                if i==0:\\n                    curr[j]=matrix[i][j]\\n                    continue\\n                up=matrix[i][j]+prev[j]\\n                left=right=float(\\'inf\\')\\n                if j>0:\\n                    left=matrix[i][j]+prev[j-1]\\n                if j<n-1:\\n                    right=matrix[i][j]+prev[j+1]\\n                curr[j]=min(up,left,right)\\n            prev=curr[:]\\n        m=float(\\'inf\\')\\n        for j in range(n):\\n            m=min(m,prev[j])\\n        return m\\n```\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Matrix"
                ],
                "code": "```\\n#Recursion \\n#Time Complexity: O(3^n)\\n#Space Complexity: O(n)\\nclass Solution1:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        def solve(i,j):\\n            if j>=n or j<0:\\n                return float(\\'inf\\')\\n            if i==0:\\n                return matrix[i][j]\\n            up=matrix[i][j]+solve(i-1,j)\\n            left=matrix[i][j]+solve(i-1,j-1)\\n            right=matrix[i][j]+solve(i-1,j+1)\\n            return min(up,left,right)\\n        n=len(matrix)\\n        m=float(\\'inf\\')\\n        for j in range(n):\\n            m=min(m,solve(n-1,j))\\n        return m\\n    \\n#Memoization (Top-Down)\\n#Time Complexity: O(n^2)\\n#Space Complexity: O(n) + O(n^2)\\nclass Solution2:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        def solve(i,j):\\n            if j>=n or j<0:\\n                return float(\\'inf\\')\\n            if i==0:\\n                return matrix[i][j]\\n            if dp[i][j]!=-1:\\n                return dp[i][j]\\n            up=matrix[i][j]+solve(i-1,j)\\n            left=matrix[i][j]+solve(i-1,j-1)\\n            right=matrix[i][j]+solve(i-1,j+1)\\n            return min(up,left,right)\\n        n=len(matrix)\\n        m=float(\\'inf\\')\\n        dp=[[-1 for j in range(n)] for i in range(n)]\\n        for j in range(n):\\n            m=min(m,solve(n-1,j))\\n        return m\\n\\n\\n#Tabulation (Bottom-Up)\\n#Time Complexity: O(n^2)\\n#Space Complexity: O(n^2)\\nclass Solution3:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        n=len(matrix)\\n        dp=[[0 for j in range(n)] for i in range(n)]\\n        for i in range(n):\\n            for j in range(n):\\n                if i==0:\\n                    dp[i][j]=matrix[i][j]\\n                    continue\\n                up=matrix[i][j]+dp[i-1][j]\\n                left=right=float(\\'inf\\')\\n                if j>0:\\n                    left=matrix[i][j]+dp[i-1][j-1]\\n                if j<n-1:\\n                    right=matrix[i][j]+dp[i-1][j+1]\\n                dp[i][j]=min(up,left,right)\\n        m=float(\\'inf\\')\\n        print(dp)\\n        for j in range(n):\\n            m=min(m,dp[n-1][j])\\n        return m\\n    \\n#Space Optimization\\n#Time Complexity: O(n^2)\\n#Space Complexity: O(n)\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        n=len(matrix)\\n        prev=[0]*n\\n        for i in range(n):\\n            curr=[0]*n\\n            for j in range(n):\\n                if i==0:\\n                    curr[j]=matrix[i][j]\\n                    continue\\n                up=matrix[i][j]+prev[j]\\n                left=right=float(\\'inf\\')\\n                if j>0:\\n                    left=matrix[i][j]+prev[j-1]\\n                if j<n-1:\\n                    right=matrix[i][j]+prev[j+1]\\n                curr[j]=min(up,left,right)\\n            prev=curr[:]\\n        m=float(\\'inf\\')\\n        for j in range(n):\\n            m=min(m,prev[j])\\n        return m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861955,
                "title": "memoization-updated-striver-s-approach-tle-solved",
                "content": "# Intuition\\nYou might be getting tle in memoisation if you are initialising the dp with with -1 like this-\\n```\\nWrong:\\nvector<vector<int>> dp(n,vector<int> (n,-1));\\nRight:\\nvector<vector<int>> dp(n,vector<int> (n,INT_MIN));\\nAlso update, \\nif(dp[i][j]!=INT_MIN) return dp[i][j];\\n```\\nThis is happening because -1 can also be considered in taking the min sum so its deviating the answer hence we\\'d taken INT_MIN to initialise the dp.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n      int f(int i,int j,int n,vector<vector<int>>& matrix,vector<vector<int>>&dp){\\n\\n        if(j<0 || j>=n)return 1e9;\\n        if(i==0 )return matrix[i][j];\\n\\n        if(dp[i][j]!=INT_MIN) return dp[i][j];\\n        int str= matrix[i][j] + f(i-1,j,n,matrix,dp);\\n        int rd= matrix[i][j] + f(i-1,j+1,n,matrix,dp);\\n        int ld= matrix[i][j] + f(i-1,j-1,n,matrix,dp);\\n        return dp[i][j]= min(str, min(rd,ld));\\n    }\\n\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int ans=INT_MAX;\\n        vector<vector<int>> dp(n,vector<int> (n,INT_MIN));\\n        for(int j=0; j<n; j++){\\n          ans=min(ans,f(n-1,j,n,matrix,dp));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nWrong:\\nvector<vector<int>> dp(n,vector<int> (n,-1));\\nRight:\\nvector<vector<int>> dp(n,vector<int> (n,INT_MIN));\\nAlso update, \\nif(dp[i][j]!=INT_MIN) return dp[i][j];\\n```\n```\\nclass Solution {\\npublic:\\n      int f(int i,int j,int n,vector<vector<int>>& matrix,vector<vector<int>>&dp){\\n\\n        if(j<0 || j>=n)return 1e9;\\n        if(i==0 )return matrix[i][j];\\n\\n        if(dp[i][j]!=INT_MIN) return dp[i][j];\\n        int str= matrix[i][j] + f(i-1,j,n,matrix,dp);\\n        int rd= matrix[i][j] + f(i-1,j+1,n,matrix,dp);\\n        int ld= matrix[i][j] + f(i-1,j-1,n,matrix,dp);\\n        return dp[i][j]= min(str, min(rd,ld));\\n    }\\n\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int ans=INT_MAX;\\n        vector<vector<int>> dp(n,vector<int> (n,INT_MIN));\\n        for(int j=0; j<n; j++){\\n          ans=min(ans,f(n-1,j,n,matrix,dp));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3855287,
                "title": "check-if-you-struck-with-one-test-case-spoiler-alert",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nif you are storing the initial values of dp array as -1.\\nyou will get time limit exceeding because, there is a test designed especially for that.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int helperFunction(vector<vector<int>>& matrix, int i, int j, vector<vector<int>> &dp){\\n\\n        if(i >= matrix.size() || j < 0 || j >= matrix[0].size()){\\n            return 0;\\n        }\\n\\n        if(dp[i][j] != 1000000){\\n            return dp[i][j];\\n        }\\n\\n        int colSize = matrix[0].size();\\n        int first = INT_MAX;\\n        int second = INT_MAX;\\n        // int third = INT_MAX - 1;\\n        if(j + 1 < colSize)\\n            first = matrix[i][j + 1] + helperFunction(matrix, i + 1, j + 1, dp);\\n        if(j - 1 >= 0)\\n            second = matrix[i][j - 1] + helperFunction(matrix, i + 1, j - 1, dp);\\n        int third = matrix[i][j] + helperFunction(matrix, i + 1, j, dp);\\n\\n        int min = INT_MAX;\\n        if(first > second){\\n            min = second;\\n        }else{\\n            min = first;\\n        }\\n\\n        if(min > third){\\n            min = third;\\n        }\\n        // cout << min << \" \";\\n        return dp[i][j] = min;\\n    }\\n\\n\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int min = INT_MAX;\\n        // int col = 0;\\n        // vector<int> solution;\\n        for(int i=0; i < matrix[0].size(); i++){\\n            vector<vector<int>> dp(matrix.size(), vector<int>(matrix[0].size(), 1000000));\\n            int k = helperFunction(matrix, 0, i, dp);\\n            if(min > k){\\n                min = k;\\n            }\\n        }\\n        return min;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helperFunction(vector<vector<int>>& matrix, int i, int j, vector<vector<int>> &dp){\\n\\n        if(i >= matrix.size() || j < 0 || j >= matrix[0].size()){\\n            return 0;\\n        }\\n\\n        if(dp[i][j] != 1000000){\\n            return dp[i][j];\\n        }\\n\\n        int colSize = matrix[0].size();\\n        int first = INT_MAX;\\n        int second = INT_MAX;\\n        // int third = INT_MAX - 1;\\n        if(j + 1 < colSize)\\n            first = matrix[i][j + 1] + helperFunction(matrix, i + 1, j + 1, dp);\\n        if(j - 1 >= 0)\\n            second = matrix[i][j - 1] + helperFunction(matrix, i + 1, j - 1, dp);\\n        int third = matrix[i][j] + helperFunction(matrix, i + 1, j, dp);\\n\\n        int min = INT_MAX;\\n        if(first > second){\\n            min = second;\\n        }else{\\n            min = first;\\n        }\\n\\n        if(min > third){\\n            min = third;\\n        }\\n        // cout << min << \" \";\\n        return dp[i][j] = min;\\n    }\\n\\n\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int min = INT_MAX;\\n        // int col = 0;\\n        // vector<int> solution;\\n        for(int i=0; i < matrix[0].size(); i++){\\n            vector<vector<int>> dp(matrix.size(), vector<int>(matrix[0].size(), 1000000));\\n            int k = helperFunction(matrix, 0, i, dp);\\n            if(min > k){\\n                min = k;\\n            }\\n        }\\n        return min;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3811790,
                "title": "java-top-down-and-bottom-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Added comments in code explaination\\n- Upvote if you Understand the asolution\\n\\n\\n# Code\\n```\\n/*\\nRecurion Appraoch that gives TLE\\nclass Solution {\\n    public int solve(int dp[][],int i,int j,int [][] matrix)\\n    {\\n        if(i<0 || j<0 || i>=matrix.length || j>=matrix[0].length)\\n        {\\n            return (int)Math.pow(10,9);\\n        }\\n        if(i==matrix.length-1)\\n        return matrix[i][j];\\n\\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        int right=matrix[i][j]+solve(dp,i+1,j,matrix);\\n        int down=matrix[i][j]+solve(dp,i+1,j-1,matrix);\\n        int diag=matrix[i][j]+solve(dp,i+1,j+1,matrix);\\n\\n         dp[i][j] = Math.min(right, Math.min(down, diag));\\n        return dp[i][j];\\n\\n    }\\n    public int minFallingPathSum(int[][] matrix) {\\n        int n=matrix.length;\\n        int m=matrix[0].length;\\n\\n        int dp[][]= new int[n][m];\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                dp[i][j]=-1;\\n            }\\n        }\\n       \\n\\n        int minSum = Integer.MAX_VALUE;\\n        for (int j = 0; j < m; j++) {\\n            minSum = Math.min(minSum, solve(dp, 0, j, matrix));\\n        }\\n        return minSum;\\n\\n\\n    }\\n}\\n*/\\nBottom Up Dp Approach\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n\\n        int[][] dp = new int[n][m];\\n        // Initialize the bottom row of dp with the values from the original matrix\\n        for (int j = 0; j < m; j++) {\\n            dp[n - 1][j] = matrix[n - 1][j];\\n        }\\n\\n        for (int i = n - 2; i >= 0; i--) {\\n            for (int j = 0; j < m; j++) {\\n                int right = dp[i + 1][j];\\n                int down = (j - 1 >= 0) ? dp[i + 1][j - 1] : Integer.MAX_VALUE;\\n                int diag = (j + 1 < m) ? dp[i + 1][j + 1] : Integer.MAX_VALUE;\\n                dp[i][j] = matrix[i][j] + Math.min(right, Math.min(down, diag));\\n            }\\n        }\\n\\n        // Find the minimum value in the first row, which represents the minimum falling path sum\\n        int minSum = Integer.MAX_VALUE;\\n        for (int j = 0; j < m; j++) {\\n            minSum = Math.min(minSum, dp[0][j]);\\n        }\\n\\n        return minSum;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\nRecurion Appraoch that gives TLE\\nclass Solution {\\n    public int solve(int dp[][],int i,int j,int [][] matrix)\\n    {\\n        if(i<0 || j<0 || i>=matrix.length || j>=matrix[0].length)\\n        {\\n            return (int)Math.pow(10,9);\\n        }\\n        if(i==matrix.length-1)\\n        return matrix[i][j];\\n\\n        if(dp[i][j]!=-1) return dp[i][j];\\n\\n        int right=matrix[i][j]+solve(dp,i+1,j,matrix);\\n        int down=matrix[i][j]+solve(dp,i+1,j-1,matrix);\\n        int diag=matrix[i][j]+solve(dp,i+1,j+1,matrix);\\n\\n         dp[i][j] = Math.min(right, Math.min(down, diag));\\n        return dp[i][j];\\n\\n    }\\n    public int minFallingPathSum(int[][] matrix) {\\n        int n=matrix.length;\\n        int m=matrix[0].length;\\n\\n        int dp[][]= new int[n][m];\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                dp[i][j]=-1;\\n            }\\n        }\\n       \\n\\n        int minSum = Integer.MAX_VALUE;\\n        for (int j = 0; j < m; j++) {\\n            minSum = Math.min(minSum, solve(dp, 0, j, matrix));\\n        }\\n        return minSum;\\n\\n\\n    }\\n}\\n*/\\nBottom Up Dp Approach\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n\\n        int[][] dp = new int[n][m];\\n        // Initialize the bottom row of dp with the values from the original matrix\\n        for (int j = 0; j < m; j++) {\\n            dp[n - 1][j] = matrix[n - 1][j];\\n        }\\n\\n        for (int i = n - 2; i >= 0; i--) {\\n            for (int j = 0; j < m; j++) {\\n                int right = dp[i + 1][j];\\n                int down = (j - 1 >= 0) ? dp[i + 1][j - 1] : Integer.MAX_VALUE;\\n                int diag = (j + 1 < m) ? dp[i + 1][j + 1] : Integer.MAX_VALUE;\\n                dp[i][j] = matrix[i][j] + Math.min(right, Math.min(down, diag));\\n            }\\n        }\\n\\n        // Find the minimum value in the first row, which represents the minimum falling path sum\\n        int minSum = Integer.MAX_VALUE;\\n        for (int j = 0; j < m; j++) {\\n            minSum = Math.min(minSum, dp[0][j]);\\n        }\\n\\n        return minSum;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3789438,
                "title": "simple-short-easy-solution-beats-90-using-recursion-memoization",
                "content": "# Intuition \\u2733\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n   The intuition behind the dynamic programming approach is to compute the minimum falling path sum for each cell by considering three possible moves from the current cell in the next row: moving down to the left, straight down, or moving down to the right. The minimum falling path sum at any cell is the sum of the value of the current cell and the minimum falling path sum of the three possible moves in the next row.\\nTo avoid redundant calculations, the function solve() uses memoization by storing the computed values in the dp array. If the function is called with the same row and column indices again, it returns the precomputed result directly.\\n\\n# Approach \\u2733\\n<!-- Describe your approach to solving the problem. -->The code uses a recursive dynamic programming approach to find the minimum falling path sum. It defines a recursive function solve() that calculates the minimum falling path sum starting from each element in the top row and recursively exploring all possible paths to reach the bottom row. The function stores previously computed results in the 2D array dp to avoid redundant calculations.\\nThe main function minFallingPathSum() initializes the dp array with INT_MAX, representing an uninitialized state. Then, it iterates over each element in the top row of the matrix and calls the solve() function for each starting position, keeping track of the minimum falling path sum encountered.\\n\\n# Complexity \\uD83D\\uDCAF\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n    O(m*m);\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(m*m)\\n\\n# Code\\n  PLEASE UPVOTE IF YOU LIKE THIS SOLUTION HELPFUL \\uD83D\\uDE0A\\uD83D\\uDE0A\\n  THANKS .............\\n```\\nclass Solution {\\npublic:\\n    int dp[102][102];\\n    int solve(vector<vector<int>>&arr,int m,int i,int j)\\n    {   \\n        if(i>m)\\n          return 0;\\n        if(j>m || j<0)\\n          return INT_MAX;\\n        if(dp[i][j]!=INT_MAX)\\n          return dp[i][j];\\n        return dp[i][j]=arr[i][j]+min(solve(arr,m,i+1,j-1),min(solve(arr,m,i+1,j),solve(arr,m,i+1,j+1)));\\n\\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n       int ans=INT_MAX;\\n       int m=matrix.size()-1; \\n  \\n       for(int i=0;i<=m;i++)\\n        for(int j=0;j<=m;j++)\\n            dp[i][j]=INT_MAX;\\n\\n // start traversing from all elements in first row and find minium sum \\n\\n       for(int i=0;i<=m;i++)\\n       {\\n          ans=min(ans,solve(matrix,m,0,i));\\n       }\\n       return ans;\\n    }\\n};\\n```\\n![upvote.png](https://assets.leetcode.com/users/images/aadc9d52-4cfd-4b4f-8215-4a430d12f515_1689794728.8447285.png)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[102][102];\\n    int solve(vector<vector<int>>&arr,int m,int i,int j)\\n    {   \\n        if(i>m)\\n          return 0;\\n        if(j>m || j<0)\\n          return INT_MAX;\\n        if(dp[i][j]!=INT_MAX)\\n          return dp[i][j];\\n        return dp[i][j]=arr[i][j]+min(solve(arr,m,i+1,j-1),min(solve(arr,m,i+1,j),solve(arr,m,i+1,j+1)));\\n\\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n       int ans=INT_MAX;\\n       int m=matrix.size()-1; \\n  \\n       for(int i=0;i<=m;i++)\\n        for(int j=0;j<=m;j++)\\n            dp[i][j]=INT_MAX;\\n\\n // start traversing from all elements in first row and find minium sum \\n\\n       for(int i=0;i<=m;i++)\\n       {\\n          ans=min(ans,solve(matrix,m,0,i));\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3746636,
                "title": "space-optimized-solution-dynamic-programming-c",
                "content": "# Code\\n```cpp []\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size(), m = matrix[0].size();\\n        vector<int> back(m, 0), curr(m, 0);\\n        for(int i=0; i<m; i++) back[i] = matrix[0][i];\\n\\n        for(int i=1; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                int left_d = INT_MAX, up = INT_MAX, right_d = INT_MAX;\\n                if(j>0) left_d = matrix[i][j] + back[j-1];\\n                up = matrix[i][j] + back[j];\\n                if(j<m-1) right_d = matrix[i][j] + back[j+1];\\n                curr[j] = min(left_d, min(up, right_d));\\n            }\\n            back = curr;\\n        }\\n        int ans = INT_MAX;\\n        for(int i=0; i<m; i++){\\n            ans = min(ans, back[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```cpp []\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size(), m = matrix[0].size();\\n        vector<int> back(m, 0), curr(m, 0);\\n        for(int i=0; i<m; i++) back[i] = matrix[0][i];\\n\\n        for(int i=1; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                int left_d = INT_MAX, up = INT_MAX, right_d = INT_MAX;\\n                if(j>0) left_d = matrix[i][j] + back[j-1];\\n                up = matrix[i][j] + back[j];\\n                if(j<m-1) right_d = matrix[i][j] + back[j+1];\\n                curr[j] = min(left_d, min(up, right_d));\\n            }\\n            back = curr;\\n        }\\n        int ans = INT_MAX;\\n        for(int i=0; i<m; i++){\\n            ans = min(ans, back[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3603853,
                "title": "brute-force-memoization-tabulation-optimization-c",
                "content": "# Approach :\\nAt each point, we have 3 choices to make. Move in all the directions and consider the minimum cost path to reach the last row.\\n\\n# Brute Force (TLE)\\n```\\nint solve(vector<vector<int>> &grid, int i, int j, int m, int n)\\n{\\n    // base case\\n    // moving out of grid\\n    if(j >= n) return 999999;\\n    if(j < 0) return 99999;\\n    // reaching last row would be base case\\n    if(i == m-1) return grid[i][j];\\n\\n    \\n    // rec cases\\n    // it can move down, left diagonal, right diagonal\\n\\n    int down = 99999, leftD = 99999, rightD = 999999;\\n\\n    down = grid[i][j] +  solve(grid, i+1, j, m, n);\\n    if(j>0)  leftD = grid[i][j] + solve(grid, i+1, j-1, m, n);\\n    if(j+1<n) rightD = grid[i][j] + solve(grid, i+1, j+1, m, n);\\n\\n\\n    return min(down, min(leftD, rightD));\\n}\\n\\n\\nint minFallingPathSum(vector<vector<int>>& matrix) {\\n\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int ans = 999999;\\n\\n        // we need to check  min cost from all the element of first row\\n\\n        for(int j = 0; j<n; j++)\\n        {\\n            ans = min(ans, solve(matrix, 0,j,m,n));\\n        }\\n\\n\\n        return ans;\\n        \\n    }\\n```\\n\\n\\nThis method costs approx O(3^M) * N Time and Space : Stack space\\n\\n\\n# Memoization (TLE) : \\n\\n```\\nint solve(vector<vector<int>> &grid, int i, int j, int m, int n,vectoe<vector<int>> &dp)\\n{\\n    // base case\\n    // moving out of grid\\n    if(j >= n) return 999999;\\n    if(j < 0) return 99999;\\n    // reaching last row would be base case\\n    if(i == m-1) return grid[i][j];\\n    if(dp[i][j] != -1) return dp[i][j];\\n\\n\\n    \\n    // rec cases\\n    // it can move down, left diagonal, right diagonal\\n\\n    int down = 99999, leftD = 99999, rightD = 999999;\\n\\n    down = grid[i][j] +  solve(grid, i+1, j, m, n, dp);\\n    if(j>0)  leftD = grid[i][j] + solve(grid, i+1, j-1, m, n, dp);\\n    if(j+1<n) rightD = grid[i][j] + solve(grid, i+1, j+1, m, n, dp);\\n\\n\\n    return dp[i][j] =  min(down, min(leftD, rightD));\\n}\\n\\n\\nint minFallingPathSum(vector<vector<int>>& matrix) {\\n\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int ans = 999999;\\n\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n\\n        for(int j = 0; j<n; j++)\\n        {\\n            ans = min(ans, solve(matrix, 0,j,m,n, dp));\\n        }\\n\\n\\n        return ans;\\n        \\n    }\\n```\\n\\nMemoization costs $$O(m*n)$$ time and space : $$O(m*n)$$ + $$Stack   Space$$\\n\\n\\n\\n# Tabulation (Accepted)\\n\\n```\\nint solve(vector<vector<int>> &grid,int m, int n)\\n{\\n\\n    vector<vector<int>> dp(m, vector<int>(n, -1));\\n    // base\\n    // copy first row of grid to dp\\n    for(int j = 0; j<n; j++)\\n    {\\n        dp[0][j] = grid[0][j];\\n    }\\n\\n\\n    for(int i = 1; i<m; i++)\\n    {\\n        for(int j = 0; j<n; j++)\\n        {\\n            int down = 999999, leftD = 999999, rightD = 999999;\\n            down = grid[i][j] + dp[i-1][j];\\n            if(j>0) leftD = grid[i][j] + dp[i-1][j-1];\\n            if(j+1<n) rightD = grid[i][j] + dp[i-1][j+1];\\n\\n            dp[i][j] = min(down, min(leftD, rightD));\\n        }\\n    }\\n\\n    // ans would be min of the last row\\n\\n    int ans = 9999;\\n    for(int j = 0; j<n; j++)\\n    {\\n        ans = min(ans, dp[m-1][j]);\\n    }\\n\\n    return ans;\\n    \\n}\\n\\nint minFallingPathSum(vector<vector<int>>& matrix) {\\n\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n\\n        return solve(matrix, m, n);\\n        \\n    }\\n```\\n\\n\\nTabulation costs $$O(m * n)$$ time ans $$O(m * n)$$ space\\n\\n**But if we notice, each time we only need previous row as dp[i-1].\\nSo further space can be optimized to $$O(n)$$ if we only use that row** \\n\\n# Optimized (Accepted) :\\n\\n\\n```\\nclass Solution {\\npublic:\\nint solve(vector<vector<int>> &grid,int m, int n)\\n{\\n\\n    vector<int> prev = grid[0];\\n   \\n    for(int i = 1; i<m; i++)\\n    {\\n        vector<int> curr(n, -1);\\n        for(int j = 0; j<n; j++)\\n        {\\n            int down = 999999, leftD = 999999, rightD = 999999;\\n            down = grid[i][j] + prev[j];\\n            if(j>0) leftD = grid[i][j] + prev[j-1];\\n            if(j+1<n) rightD = grid[i][j] + prev[j+1];\\n\\n            curr[j] = min(down, min(leftD, rightD));\\n        }\\n        prev = curr;\\n    }\\n\\n    \\n\\n    int ans = 999999;\\n    for(int j = 0; j<n; j++)\\n    {\\n        ans = min(ans, prev[j]);\\n    }\\n\\n    return ans;\\n    \\n}\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n\\n        return solve(matrix, m, n);\\n        \\n    }\\n};\\n```\\n\\nHence Time it takes is $$O(m*n)$$ and space $$O(n)$$.\\n\\n# Hope it helps!",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nint solve(vector<vector<int>> &grid, int i, int j, int m, int n)\\n{\\n    // base case\\n    // moving out of grid\\n    if(j >= n) return 999999;\\n    if(j < 0) return 99999;\\n    // reaching last row would be base case\\n    if(i == m-1) return grid[i][j];\\n\\n    \\n    // rec cases\\n    // it can move down, left diagonal, right diagonal\\n\\n    int down = 99999, leftD = 99999, rightD = 999999;\\n\\n    down = grid[i][j] +  solve(grid, i+1, j, m, n);\\n    if(j>0)  leftD = grid[i][j] + solve(grid, i+1, j-1, m, n);\\n    if(j+1<n) rightD = grid[i][j] + solve(grid, i+1, j+1, m, n);\\n\\n\\n    return min(down, min(leftD, rightD));\\n}\\n\\n\\nint minFallingPathSum(vector<vector<int>>& matrix) {\\n\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int ans = 999999;\\n\\n        // we need to check  min cost from all the element of first row\\n\\n        for(int j = 0; j<n; j++)\\n        {\\n            ans = min(ans, solve(matrix, 0,j,m,n));\\n        }\\n\\n\\n        return ans;\\n        \\n    }\\n```\n```\\nint solve(vector<vector<int>> &grid, int i, int j, int m, int n,vectoe<vector<int>> &dp)\\n{\\n    // base case\\n    // moving out of grid\\n    if(j >= n) return 999999;\\n    if(j < 0) return 99999;\\n    // reaching last row would be base case\\n    if(i == m-1) return grid[i][j];\\n    if(dp[i][j] != -1) return dp[i][j];\\n\\n\\n    \\n    // rec cases\\n    // it can move down, left diagonal, right diagonal\\n\\n    int down = 99999, leftD = 99999, rightD = 999999;\\n\\n    down = grid[i][j] +  solve(grid, i+1, j, m, n, dp);\\n    if(j>0)  leftD = grid[i][j] + solve(grid, i+1, j-1, m, n, dp);\\n    if(j+1<n) rightD = grid[i][j] + solve(grid, i+1, j+1, m, n, dp);\\n\\n\\n    return dp[i][j] =  min(down, min(leftD, rightD));\\n}\\n\\n\\nint minFallingPathSum(vector<vector<int>>& matrix) {\\n\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int ans = 999999;\\n\\n        vector<vector<int>> dp(m, vector<int>(n, -1));\\n\\n        for(int j = 0; j<n; j++)\\n        {\\n            ans = min(ans, solve(matrix, 0,j,m,n, dp));\\n        }\\n\\n\\n        return ans;\\n        \\n    }\\n```\n```\\nint solve(vector<vector<int>> &grid,int m, int n)\\n{\\n\\n    vector<vector<int>> dp(m, vector<int>(n, -1));\\n    // base\\n    // copy first row of grid to dp\\n    for(int j = 0; j<n; j++)\\n    {\\n        dp[0][j] = grid[0][j];\\n    }\\n\\n\\n    for(int i = 1; i<m; i++)\\n    {\\n        for(int j = 0; j<n; j++)\\n        {\\n            int down = 999999, leftD = 999999, rightD = 999999;\\n            down = grid[i][j] + dp[i-1][j];\\n            if(j>0) leftD = grid[i][j] + dp[i-1][j-1];\\n            if(j+1<n) rightD = grid[i][j] + dp[i-1][j+1];\\n\\n            dp[i][j] = min(down, min(leftD, rightD));\\n        }\\n    }\\n\\n    // ans would be min of the last row\\n\\n    int ans = 9999;\\n    for(int j = 0; j<n; j++)\\n    {\\n        ans = min(ans, dp[m-1][j]);\\n    }\\n\\n    return ans;\\n    \\n}\\n\\nint minFallingPathSum(vector<vector<int>>& matrix) {\\n\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n\\n        return solve(matrix, m, n);\\n        \\n    }\\n```\n```\\nclass Solution {\\npublic:\\nint solve(vector<vector<int>> &grid,int m, int n)\\n{\\n\\n    vector<int> prev = grid[0];\\n   \\n    for(int i = 1; i<m; i++)\\n    {\\n        vector<int> curr(n, -1);\\n        for(int j = 0; j<n; j++)\\n        {\\n            int down = 999999, leftD = 999999, rightD = 999999;\\n            down = grid[i][j] + prev[j];\\n            if(j>0) leftD = grid[i][j] + prev[j-1];\\n            if(j+1<n) rightD = grid[i][j] + prev[j+1];\\n\\n            curr[j] = min(down, min(leftD, rightD));\\n        }\\n        prev = curr;\\n    }\\n\\n    \\n\\n    int ans = 999999;\\n    for(int j = 0; j<n; j++)\\n    {\\n        ans = min(ans, prev[j]);\\n    }\\n\\n    return ans;\\n    \\n}\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n\\n        return solve(matrix, m, n);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460607,
                "title": "clean-code-easy-dp-interview-approach-striver-you-will-understand",
                "content": "# Please UpVote \\n\\n# Code\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        int n = matrix.length; int m = matrix[0].length;\\n        int dp[][] = new int [n][m];\\n        for(int i=0 ; i< n; i++)\\n            for(int j =0 ;j < m ;j++)\\n                dp[i][j]=-1;\\n        \\n        int min= (int)1e9;\\n        for(int j =0  ; j< n ; j++){\\n            min= Math.min( min, f( 0 ,j ,n-1,matrix , dp ));\\n        }\\n        return min;\\n    }\\n    public int f ( int i , int j , int n ,int [][] matrix, int [][] dp){\\n        if( j>n || j<0) return (int)1e9;\\n        if( i==n) return matrix[i][j];\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int d= matrix[i][j] + f( i+1, j, n, matrix, dp);\\n        int dr= matrix[i][j] + f(i+1, j+1, n, matrix, dp);\\n        int dl= matrix[i][j] + f( i+1, j-1, n, matrix, dp);\\n        return dp[i][j]= Math.min(d, Math.min(dr, dl));\\n    }\\n}\\n```\\n![Screenshot 2023-04-21 140036.png](https://assets.leetcode.com/users/images/b84967d8-2b40-4861-984e-ef6714c6ee8f_1682598490.8409297.png)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        int n = matrix.length; int m = matrix[0].length;\\n        int dp[][] = new int [n][m];\\n        for(int i=0 ; i< n; i++)\\n            for(int j =0 ;j < m ;j++)\\n                dp[i][j]=-1;\\n        \\n        int min= (int)1e9;\\n        for(int j =0  ; j< n ; j++){\\n            min= Math.min( min, f( 0 ,j ,n-1,matrix , dp ));\\n        }\\n        return min;\\n    }\\n    public int f ( int i , int j , int n ,int [][] matrix, int [][] dp){\\n        if( j>n || j<0) return (int)1e9;\\n        if( i==n) return matrix[i][j];\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int d= matrix[i][j] + f( i+1, j, n, matrix, dp);\\n        int dr= matrix[i][j] + f(i+1, j+1, n, matrix, dp);\\n        int dl= matrix[i][j] + f( i+1, j-1, n, matrix, dp);\\n        return dp[i][j]= Math.min(d, Math.min(dr, dl));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3438483,
                "title": "top-down-simple-dp-solution-easy-and-intuitive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince we want to find the minimum path sum at the bottom of the matrix, we can use dynamic programming to find the minimum path sum for each row of the matrix and work our way through the matrix to find the final result. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTop down dynamic programming\\n\\nFor each position i in row j, we want to find the minimum path sum to get to that position from row j-1. Since we are allowed to move either diagonally or downwards, we take the minimum of tiles i-1, i and i+1 in row j-1 to calculate the \"previous path sum\" which is to be added to the current value stored in grid[i][j]. \\n\\nWe do this to each and every row starting from the 2nd row (the first row will just contain values from the first row in the matrix), and once we reach the last row we find the minimum of that row to be our answer.\\n\\nThings to consider:\\nSince at index 0 and matrix.length-1 there is no diagonally upper left or right value, we can only consider 2 previous values to calculate the previous path sum to be used.\\n\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$ - traversing through n * n matrix\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ - can be O(1) if done in place\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        int n = matrix.length;\\n        int[][] dp = new int[n][n];\\n\\n        for(int i=0; i<n; i++){\\n            dp[0][i] = matrix[0][i];\\n        }\\n\\n        for(int i=1; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                //no top left\\n                if(j == 0){\\n                    dp[i][j] = Math.min(dp[i-1][j], dp[i-1][j+1]) + matrix[i][j];\\n                }\\n                //no top right\\n                else if(j == n-1){\\n                    dp[i][j] = Math.min(dp[i-1][j], dp[i-1][j-1]) + matrix[i][j];\\n                }\\n                //comparing top left, middle, and right\\n                else{\\n                    dp[i][j] = Math.min(Math.min(dp[i-1][j], dp[i-1][j-1]), dp[i-1][j+1]) + matrix[i][j];\\n                }\\n            }\\n        }\\n        int out = Integer.MAX_VALUE;\\n        //finding the minimum of the last row\\n        for(int i=0; i<n; i++){\\n            out = Math.min(out, dp[n-1][i]);\\n        }\\n\\n        return out;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        int n = matrix.length;\\n        int[][] dp = new int[n][n];\\n\\n        for(int i=0; i<n; i++){\\n            dp[0][i] = matrix[0][i];\\n        }\\n\\n        for(int i=1; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                //no top left\\n                if(j == 0){\\n                    dp[i][j] = Math.min(dp[i-1][j], dp[i-1][j+1]) + matrix[i][j];\\n                }\\n                //no top right\\n                else if(j == n-1){\\n                    dp[i][j] = Math.min(dp[i-1][j], dp[i-1][j-1]) + matrix[i][j];\\n                }\\n                //comparing top left, middle, and right\\n                else{\\n                    dp[i][j] = Math.min(Math.min(dp[i-1][j], dp[i-1][j-1]), dp[i-1][j+1]) + matrix[i][j];\\n                }\\n            }\\n        }\\n        int out = Integer.MAX_VALUE;\\n        //finding the minimum of the last row\\n        for(int i=0; i<n; i++){\\n            out = Math.min(out, dp[n-1][i]);\\n        }\\n\\n        return out;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397491,
                "title": "super-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->We will first form the recursive solution by the three points mentioned in Dynamic Programming Introduction. \\n\\nStep 1: Express the problem in terms of indexes.\\n\\nWe are given an \\u2018N*M\\u2019 matrix. We can define the function with two parameters i and j, where i and j represent the row and column of the matrix.\\n\\nNow our ultimate aim is to reach the last row. We can define f(i,j) such that it gives us the maximum path sum from any cell in the first row to the cell[i][j].\\n\\n\\nIf we see the figure given below:\\n\\n\\nWe have a top row and a bottom row, we will be writing a recursion in the direction of the last row to the first row. For the last row, i=N-1 therefore we need to find four different answers:\\n\\nf(N-1,0), f(N-1,1), f(N-1,2), f(N-1,3)\\n\\nThese recursive calls will give the maximum path sum from a cell in the first row to the respective four cells for which the recursion calls are made. We need to return the maximum value among these as the final answer.\\n\\nBase Case:\\n\\nThere will be the following base cases:\\n\\nWhen i == 0, it means we are at the first row, so the min path from that cell to the first will be the value of that cell itself, hence we return mat[0][j].\\nAt every cell we have three options (we are writing recursion from the last row to the first row): to the top cell (\\u2191), to the top-right cell(\\u2197), or to the top-left cell(\\u2196).\\n\\nAs we are moving to the top cell (\\u2191), at max we will reach the first row, from where we return, so we will never go out of the bounding index.\\n\\nTo move to the top-left cell(\\u2196) or to the top-right cell(\\u2197), it can happen that we may go out of bound as shown in the figure(below). So we need to handle it, we can return -1e9, whenever we go out of bound, in this way this path will not be selected by the calling function as we have to return the maximum path.\\n\\n\\nIf j<0 or j>=M , then we return -1e9 \\nThe pseudocode till this step will be:\\n\\n\\nStep 2: Try out all possible choices at a given index.\\n\\nAt every cell we have three options (we are writing recursion from the last row to the first row): to the top cell (\\u2191), to the top-right cell(\\u2197), or to the top-left cell(\\u2196).\\n\\nTo go to the top, we will decrease i by 1, and to move towards top-left, we will decrease both i and j by 1 whereas to move to top-right, we will decrease i by 1 and increase j by 1.\\n\\nNow when we get our answer for the recursive call (f(i-1,j), f(i-1,j-1) or f(i-1,j+1)), we need to also add the current cell value to it as we have to include it too for the current path sum.\\n\\n\\nStep 3:  Take the maximum of all choices\\n\\nAs we have to find the maximum path sum of all the possible unique paths, we will return the maximum of all the choices(up, leftDiagonal, right diagonal) \\n\\nThe final pseudocode after steps 1, 2, and 3:\\n\\n\\nSteps to memoize a recursive solution:\\n\\nIf we draw the recursion tree, we will see that there are overlapping subproblems. In order to convert a recursive solution the following steps will be taken:\\n\\nCreate a dp array of size [N][M]\\nWhenever we want to find the answer of a particular row and column (say f(i,j)), we first check whether the answer is already calculated using the dp array(i.e dp[i][j]!= -1 ). If yes, simply return the value from the dp array.\\nIf not, then we are finding the answer for the given values for the first time, we will use the recursive relation as usual but before returning from the function, we will set dp[i][j] to the solution we get.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(M*N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nint getminUtil(int i, int j, int m, vector<vector<int>> &matrix, \\nvector<vector<int> > &dp){\\n    \\n    // Base Conditions\\n    if(j<0 || j>=m)\\n        return 1e9;\\n    if(i==0)\\n        return matrix[0][j];\\n    \\n    if(dp[i][j]!=-1) return dp[i][j];\\n    \\n    int up = matrix[i][j] + getminUtil(i-1,j,m,matrix,dp);\\n    int leftDiagonal = matrix[i][j] + getminUtil(i-1,j-1,m,matrix,dp);\\n    int rightDiagonal = matrix[i][j] + getminUtil(i-1,j+1,m,matrix,dp);\\n    \\n    return dp[i][j]= min(up,min(leftDiagonal,rightDiagonal));\\n    \\n}\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n          \\n    int n = matrix.size();\\n    int m = matrix[0].size();\\n    \\n    vector<vector<int>> dp(n,vector<int>(m,-1));\\n    \\n    int mini = INT_MAX;\\n    \\n    for(int j=0; j<m;j++){\\n        int ans = getminUtil(n-1,j,m,matrix,dp);\\n        mini = min(mini,ans);\\n    }\\n    \\n    return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nint getminUtil(int i, int j, int m, vector<vector<int>> &matrix, \\nvector<vector<int> > &dp){\\n    \\n    // Base Conditions\\n    if(j<0 || j>=m)\\n        return 1e9;\\n    if(i==0)\\n        return matrix[0][j];\\n    \\n    if(dp[i][j]!=-1) return dp[i][j];\\n    \\n    int up = matrix[i][j] + getminUtil(i-1,j,m,matrix,dp);\\n    int leftDiagonal = matrix[i][j] + getminUtil(i-1,j-1,m,matrix,dp);\\n    int rightDiagonal = matrix[i][j] + getminUtil(i-1,j+1,m,matrix,dp);\\n    \\n    return dp[i][j]= min(up,min(leftDiagonal,rightDiagonal));\\n    \\n}\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n          \\n    int n = matrix.size();\\n    int m = matrix[0].size();\\n    \\n    vector<vector<int>> dp(n,vector<int>(m,-1));\\n    \\n    int mini = INT_MAX;\\n    \\n    for(int j=0; j<m;j++){\\n        int ans = getminUtil(n-1,j,m,matrix,dp);\\n        mini = min(mini,ans);\\n    }\\n    \\n    return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3330093,
                "title": "minimum-falling-path-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int minsum(vector<vector<int>>& matrix, int n, int row, int col,  vector<vector<int>>& dp){\\n        \\n        if(row >=n || col >=n || row <0 || col <0)\\n            return 10000001;\\n        \\n        if(row == n-1)\\n            return matrix[row][col];\\n        \\n        if(dp[row][col] != -1)\\n            return dp[row][col];\\n        \\n            int below = matrix[row][col] + minsum(matrix,n,row+1,col,dp); \\n            int left  = matrix[row][col] + minsum(matrix,n,row+1,col-1,dp);\\n            int right = matrix[row][col] + minsum(matrix,n,row+1,col+1,dp);\\n        \\n        dp[row][col] = min(below,min(left,right));\\n        return dp[row][col];\\n    }\\n        \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        \\n        int n = matrix.size();\\n        int ans = 10000000;\\n        vector<vector<int>>dp(101,vector<int>(101,-1));\\n        for(int i = 0; i<n; i++){\\n            int temp_ans = minsum(matrix,n,0,i,dp);\\n            ans = min(ans,temp_ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minsum(vector<vector<int>>& matrix, int n, int row, int col,  vector<vector<int>>& dp){\\n        \\n        if(row >=n || col >=n || row <0 || col <0)\\n            return 10000001;\\n        \\n        if(row == n-1)\\n            return matrix[row][col];\\n        \\n        if(dp[row][col] != -1)\\n            return dp[row][col];\\n        \\n            int below = matrix[row][col] + minsum(matrix,n,row+1,col,dp); \\n            int left  = matrix[row][col] + minsum(matrix,n,row+1,col-1,dp);\\n            int right = matrix[row][col] + minsum(matrix,n,row+1,col+1,dp);\\n        \\n        dp[row][col] = min(below,min(left,right));\\n        return dp[row][col];\\n    }\\n        \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        \\n        int n = matrix.size();\\n        int ans = 10000000;\\n        vector<vector<int>>dp(101,vector<int>(101,-1));\\n        for(int i = 0; i<n; i++){\\n            int temp_ans = minsum(matrix,n,0,i,dp);\\n            ans = min(ans,temp_ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3293147,
                "title": "c-two-approaches-memoization-space-optimized",
                "content": "# Memoization :\\n\\n- Time complexity: O(N*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N*N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int i, int j, int n, vector<vector<int>>& mat, vector<vector<int>>& t) {\\n        if(i == n-1 && j >= 0 && j < n) return mat[i][j];\\n        if(j < 0 || j >= n) return INT_MAX;\\n        if(t[i][j] != -1) return t[i][j];\\n        int a = solve(i+1, j-1, n, mat, t);\\n        int b = solve(i+1, j, n, mat, t);\\n        int c = solve(i+1, j+1, n, mat, t);\\n        return t[i][j] = mat[i][j] + min(a, min(b, c));\\n    }\\n    int minFallingPathSum(vector<vector<int>>& mat) {\\n        int n = mat.size(), ans = INT_MAX;\\n        vector<vector<int>> t(n, vector<int> (n, -1));\\n        for(int k=0; k<n; k++) {\\n            int res = solve(0, k, n, mat, t);\\n            ans = min(ans, res);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Tabulation(Space Optimized) :\\n- Time complexity: O(N*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& mat) {\\n        int n = mat.size();\\n        for(int i=1; i<n; i++) {\\n            for(int j=0; j<n; j++) {\\n                int s = mat[i-1][j];\\n                if(j-1 >= 0) s = min(s, mat[i-1][j-1]);\\n                if(j+1 < n) s = min(s, mat[i-1][j+1]);\\n                mat[i][j] += s;\\n            }\\n        }\\n        int ans = INT_MAX;\\n        for(int i=0; i<n; i++) ans = min(ans, mat[n-1][i]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i, int j, int n, vector<vector<int>>& mat, vector<vector<int>>& t) {\\n        if(i == n-1 && j >= 0 && j < n) return mat[i][j];\\n        if(j < 0 || j >= n) return INT_MAX;\\n        if(t[i][j] != -1) return t[i][j];\\n        int a = solve(i+1, j-1, n, mat, t);\\n        int b = solve(i+1, j, n, mat, t);\\n        int c = solve(i+1, j+1, n, mat, t);\\n        return t[i][j] = mat[i][j] + min(a, min(b, c));\\n    }\\n    int minFallingPathSum(vector<vector<int>>& mat) {\\n        int n = mat.size(), ans = INT_MAX;\\n        vector<vector<int>> t(n, vector<int> (n, -1));\\n        for(int k=0; k<n; k++) {\\n            int res = solve(0, k, n, mat, t);\\n            ans = min(ans, res);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& mat) {\\n        int n = mat.size();\\n        for(int i=1; i<n; i++) {\\n            for(int j=0; j<n; j++) {\\n                int s = mat[i-1][j];\\n                if(j-1 >= 0) s = min(s, mat[i-1][j-1]);\\n                if(j+1 < n) s = min(s, mat[i-1][j+1]);\\n                mat[i][j] += s;\\n            }\\n        }\\n        int ans = INT_MAX;\\n        for(int i=0; i<n; i++) ans = min(ans, mat[n-1][i]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3069452,
                "title": "easily-explained-optimized-solution-recursive-d-p-tabulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe are allowed to move in 3 directions and find out Minimum path sum among them.\\n\\nSo, we need to find all possible path sum and then take out minimum one. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Simple Recursive Approach:\\n    Steps to write a recursive function:\\n    ```\\n    (a) Identify Base Case\\n    (b) Do all stuff on particular index \\n    (c) Return whatever asked in question\\n    ```\\n\\n    ```\\n    class Solution {\\n        public static int fun(int row, int col, int[][] ar, int n) {\\n            if (col < 0 || col > n - 1)\\n                return (int)Math.pow(10, 9);\\n\\n            if (row == n - 1)\\n                return ar[n - 1][col];\\n            \\n            int down = ar[row][col] + fun(row + 1, col, ar, n);\\n            int left = ar[row][col] + fun(row + 1, col - 1, ar, n);\\n            int right = ar[row][col] + fun(row + 1, col + 1, ar, n);\\n\\n            return Math.min(down, Math.min(left, right));\\n        }\\n        public int minFallingPathSum(int[][] arr) {\\n            int n = arr.length;\\n            int ans = Integer.MAX_VALUE;\\n            for (int i = 0; i < n; i++) {\\n                ans = Math.min(ans, fun(0, i, arr, n));\\n            }\\n            return ans;\\n        }        \\n    }\\n\\n    ```\\n    - Time Complexity: ``` O(2^(N*N)) ```\\n    - Space Complexity:``` O(N) ```\\n    \\n2. DP Approach:\\n    Properties of a problem to be solved by DP are:\\n    1. We must be able to write recursive approach to code.\\n    2. Should include overlapping subproblems.\\n    \\n    We have overlapping subproblem in recursive solution so we will store it in 2-D array and use its solution in another subproblems which will save our time.\\n    ```\\n    class Solution {\\n        public static int fun(int row, int col, int[][] ar, int n, int[][] memo) {\\n            if (col < 0 || col > n - 1)\\n                return (int)Math.pow(10, 9);\\n\\n            if (row == n - 1)\\n                return ar[n - 1][col];\\n            \\n            if (memo[row][col] != 0)\\n                return memo[row][col];\\n            int down = ar[row][col] + fun(row + 1, col, ar, n, memo);\\n            int left = ar[row][col] + fun(row + 1, col - 1, ar, n, memo);\\n            int right = ar[row][col] + fun(row + 1, col + 1, ar, n, memo);\\n\\n            return memo[row][col] =  Math.min(down, Math.min(left, right));\\n        }\\n        public int minFallingPathSum(int[][] arr) {\\n            int n = arr.length;\\n            int ans = Integer.MAX_VALUE;\\n            int[][] dp = new int[n][n];\\n            \\n            for (int i = 0; i < n; i++) {\\n                \\n                ans = Math.min(ans, fun(0, i, arr, n, dp));\\n            }\\n            return ans;\\n        }        \\n    }\\n    ```\\n    - Time Complexity: O(N*N)\\n    - Space Complexity: O(N) + O(N*N)\\n    \\n\\n3. Tabulation Approach: \\n    Tabulation is Space Optimized approach which will remove the stack space.\\n\\n    ```\\n    class Solution {\\n        public int minFallingPathSum(int[][] A) {\\n            int n = A.length;\\n            int ans = Integer.MAX_VALUE;\\n            int[][] dp = new int[n][n];\\n            \\n            for (int i = 0; i < n; i++) {\\n                dp[0][i] = A[0][i];\\n            }\\n            \\n            int down = Integer.MAX_VALUE, left = Integer.MAX_VALUE, right = Integer.MAX_VALUE;\\n            for(int row = 1; row < n; row++) {\\n                for(int col = 0; col < n; col++) {\\n                    down = dp[row - 1][col];\\n                    if(col == 0) {\\n                        right = dp[row - 1][col + 1];\\n                        dp[row][col] = A[row][col] + Math.min(down, right);\\n                    }\\n                    else if (col == n - 1) {\\n                        left = dp[row - 1][col - 1];\\n                        dp[row][col] = A[row][col] + Math.min(down, left);\\n                    }\\n                    else {\\n                        left = dp[row - 1][col - 1];\\n                        right = dp[row - 1][col + 1];\\n                        dp[row][col] = A[row][col] + Math.min(down, Math.min(left, right));\\n                    }\\n                }\\n            }\\n\\n            for(int col = 0; col < n; col++)\\n                ans = Math.min(ans, dp[n - 1][col]);\\n            \\n            return ans;\\n        }        \\n    }\\n    ```\\n    - Time Complexity: O(N*N)\\n    - Space Complexity: O(N*N)\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\n    (a) Identify Base Case\\n    (b) Do all stuff on particular index \\n    (c) Return whatever asked in question\\n    ```\n```\\n    class Solution {\\n        public static int fun(int row, int col, int[][] ar, int n) {\\n            if (col < 0 || col > n - 1)\\n                return (int)Math.pow(10, 9);\\n\\n            if (row == n - 1)\\n                return ar[n - 1][col];\\n            \\n            int down = ar[row][col] + fun(row + 1, col, ar, n);\\n            int left = ar[row][col] + fun(row + 1, col - 1, ar, n);\\n            int right = ar[row][col] + fun(row + 1, col + 1, ar, n);\\n\\n            return Math.min(down, Math.min(left, right));\\n        }\\n        public int minFallingPathSum(int[][] arr) {\\n            int n = arr.length;\\n            int ans = Integer.MAX_VALUE;\\n            for (int i = 0; i < n; i++) {\\n                ans = Math.min(ans, fun(0, i, arr, n));\\n            }\\n            return ans;\\n        }        \\n    }\\n\\n    ```\n``` O(2^(N*N)) ```\n``` O(N) ```\n```\\n    class Solution {\\n        public static int fun(int row, int col, int[][] ar, int n, int[][] memo) {\\n            if (col < 0 || col > n - 1)\\n                return (int)Math.pow(10, 9);\\n\\n            if (row == n - 1)\\n                return ar[n - 1][col];\\n            \\n            if (memo[row][col] != 0)\\n                return memo[row][col];\\n            int down = ar[row][col] + fun(row + 1, col, ar, n, memo);\\n            int left = ar[row][col] + fun(row + 1, col - 1, ar, n, memo);\\n            int right = ar[row][col] + fun(row + 1, col + 1, ar, n, memo);\\n\\n            return memo[row][col] =  Math.min(down, Math.min(left, right));\\n        }\\n        public int minFallingPathSum(int[][] arr) {\\n            int n = arr.length;\\n            int ans = Integer.MAX_VALUE;\\n            int[][] dp = new int[n][n];\\n            \\n            for (int i = 0; i < n; i++) {\\n                \\n                ans = Math.min(ans, fun(0, i, arr, n, dp));\\n            }\\n            return ans;\\n        }        \\n    }\\n    ```\n```\\n    class Solution {\\n        public int minFallingPathSum(int[][] A) {\\n            int n = A.length;\\n            int ans = Integer.MAX_VALUE;\\n            int[][] dp = new int[n][n];\\n            \\n            for (int i = 0; i < n; i++) {\\n                dp[0][i] = A[0][i];\\n            }\\n            \\n            int down = Integer.MAX_VALUE, left = Integer.MAX_VALUE, right = Integer.MAX_VALUE;\\n            for(int row = 1; row < n; row++) {\\n                for(int col = 0; col < n; col++) {\\n                    down = dp[row - 1][col];\\n                    if(col == 0) {\\n                        right = dp[row - 1][col + 1];\\n                        dp[row][col] = A[row][col] + Math.min(down, right);\\n                    }\\n                    else if (col == n - 1) {\\n                        left = dp[row - 1][col - 1];\\n                        dp[row][col] = A[row][col] + Math.min(down, left);\\n                    }\\n                    else {\\n                        left = dp[row - 1][col - 1];\\n                        right = dp[row - 1][col + 1];\\n                        dp[row][col] = A[row][col] + Math.min(down, Math.min(left, right));\\n                    }\\n                }\\n            }\\n\\n            for(int col = 0; col < n; col++)\\n                ans = Math.min(ans, dp[n - 1][col]);\\n            \\n            return ans;\\n        }        \\n    }\\n    ```",
                "codeTag": "Java"
            },
            {
                "id": 2972189,
                "title": "memoization-tabulation-space-optimization-c",
                "content": "# Memoization\\n```\\nclass Solution {\\n    int dfs(int i, int j, int n, vector<vector<int>> &matrix, vector<vector<int>> &dp) {\\n        if(j < 0 || j == n) return INT_MAX;\\n        if(i == n - 1) return matrix[i][j];\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        int l = dfs(i + 1, j - 1, n, matrix, dp);\\n        int b = dfs(i + 1, j, n, matrix, dp);\\n        int r = dfs(i + 1, j + 1, n, matrix, dp);\\n\\n        return dp[i][j] = matrix[i][j] + min(l, min(b, r));\\n    }\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int ans = INT_MAX, n = matrix.size();\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n        for(int i=0; i<n; i++) {\\n            ans = min(ans, dfs(0, i, n, matrix, dp));\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n# Tabulation\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int ans = INT_MAX, n = matrix.size();\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n        \\n        dp[0] = matrix[0];\\n        for(int i=1; i<n; i++) {\\n            for(int j=0; j<n; j++) {\\n                int l = 1e9, a = 1e9, r = 1e9;\\n                if(j > 0) l = dp[i - 1][j - 1];\\n                a = dp[i - 1][j];\\n                if(j + 1 < n) r = dp[i - 1][j + 1];\\n                dp[i][j] = matrix[i][j] + min(l, min(a, r));\\n            }\\n        }\\n\\n        for(int i=0; i<n; i++) ans = min(ans, dp[n - 1][i]);\\n        return ans;\\n    }\\n};\\n```\\n\\n# Space Optimization\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int ans = INT_MAX, n = matrix.size();\\n        vector<int> dp = matrix[0];\\n        \\n        for(int i=1; i<n; i++) {\\n            vector<int> temp(n);\\n            for(int j=0; j<n; j++) {\\n                int l = 1e9, a = 1e9, r = 1e9;\\n                if(j > 0) l = dp[j - 1];\\n                a = dp[j];\\n                if(j + 1 < n) r = dp[j + 1];\\n                temp[j] = matrix[i][j] + min(l, min(a, r));\\n            }\\n            dp = temp;\\n        }\\n\\n        for(int i=0; i<n; i++) ans = min(ans, dp[i]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int dfs(int i, int j, int n, vector<vector<int>> &matrix, vector<vector<int>> &dp) {\\n        if(j < 0 || j == n) return INT_MAX;\\n        if(i == n - 1) return matrix[i][j];\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        int l = dfs(i + 1, j - 1, n, matrix, dp);\\n        int b = dfs(i + 1, j, n, matrix, dp);\\n        int r = dfs(i + 1, j + 1, n, matrix, dp);\\n\\n        return dp[i][j] = matrix[i][j] + min(l, min(b, r));\\n    }\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int ans = INT_MAX, n = matrix.size();\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n        for(int i=0; i<n; i++) {\\n            ans = min(ans, dfs(0, i, n, matrix, dp));\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int ans = INT_MAX, n = matrix.size();\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n        \\n        dp[0] = matrix[0];\\n        for(int i=1; i<n; i++) {\\n            for(int j=0; j<n; j++) {\\n                int l = 1e9, a = 1e9, r = 1e9;\\n                if(j > 0) l = dp[i - 1][j - 1];\\n                a = dp[i - 1][j];\\n                if(j + 1 < n) r = dp[i - 1][j + 1];\\n                dp[i][j] = matrix[i][j] + min(l, min(a, r));\\n            }\\n        }\\n\\n        for(int i=0; i<n; i++) ans = min(ans, dp[n - 1][i]);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int ans = INT_MAX, n = matrix.size();\\n        vector<int> dp = matrix[0];\\n        \\n        for(int i=1; i<n; i++) {\\n            vector<int> temp(n);\\n            for(int j=0; j<n; j++) {\\n                int l = 1e9, a = 1e9, r = 1e9;\\n                if(j > 0) l = dp[j - 1];\\n                a = dp[j];\\n                if(j + 1 < n) r = dp[j + 1];\\n                temp[j] = matrix[i][j] + min(l, min(a, r));\\n            }\\n            dp = temp;\\n        }\\n\\n        for(int i=0; i<n; i++) ans = min(ans, dp[i]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2930241,
                "title": "simple-python-solution-with-memoization",
                "content": "# Intuition\\nFirst thing that comes to mind is Depth First Search but you can quickly realiza that DFS will lead to Time Limit Exceeded. Becasue we are solving a summation problem at each level again and again that leads to memoization, we can save the computation by only calculating once the minimum sum possible if we select a specific `x, y` in matrix at level `i`.  \\n\\n# Approach\\nSince we need to know minimum on the next level, we start with bottom-up approach. Calculate the `memo` array from bottom and then perform simple `min` operation going up.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n\\n- Space complexity: $$O(n^2)$$\\n\\n---\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        memo = [[0]*n for _ in range(m)]\\n        memo[m-1] = matrix[m-1]\\n        \\n\\n        for i in range(m-2, -1, -1):\\n            for j in range(n):\\n                x, y, z = memo[i+1][j], float(\\'inf\\'), float(\\'inf\\')\\n                if j != 0:\\n                    y = memo[i+1][j-1]\\n\\n                if j != n-1:\\n                   z = memo[i+1][j+1] \\n\\n                memo[i][j] = min(x, y, z) + matrix[i][j]\\n        return min(memo[0])\\n\\n            \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        m, n = len(matrix), len(matrix[0])\\n        memo = [[0]*n for _ in range(m)]\\n        memo[m-1] = matrix[m-1]\\n        \\n\\n        for i in range(m-2, -1, -1):\\n            for j in range(n):\\n                x, y, z = memo[i+1][j], float(\\'inf\\'), float(\\'inf\\')\\n                if j != 0:\\n                    y = memo[i+1][j-1]\\n\\n                if j != n-1:\\n                   z = memo[i+1][j+1] \\n\\n                memo[i][j] = min(x, y, z) + matrix[i][j]\\n        return min(memo[0])\\n\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2910404,
                "title": "c-dp-on-grids-memoized-code-bottom-up-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to explore all possible paths here and then will find the minimum sum. Here source and destination both are variables. I am using bottom up approach. Starting from bottom row and then going to first row, finding all possible sum and storing mininum.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Time complexity for recursive solution will be O(3^n) means exponential, so we need to do either memoization or tabulation to handle overlapping subproblems.\\n2. Create one dp matrix and storing the result.\\n\\n# Complexity\\n- Time complexity: O(NxM)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(NxM) (not including recursion stack space)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int row, int col, vector<vector<int>> &matrix,vector<vector<int>> &dp)\\n    {\\n        if(col<0 || col>matrix[0].size()-1) return 1E9;\\n        if(row==0) return matrix[row][col];\\n        if(dp[row][col] != -1) return dp[row][col];\\n        int up = matrix[row][col] + solve(row-1,col,matrix,dp);\\n        int leftDiagonal = matrix[row][col] + solve(row-1,col-1,matrix,dp);\\n        int rightDiagonal = matrix[row][col] + solve(row-1,col+1,matrix,dp);\\n        return dp[row][col] = min(up,min(leftDiagonal,rightDiagonal));\\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int ans = INT_MAX;\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>> dp(n,vector<int>(m,-1));\\n        for(int i=0;i<m;i++)\\n        {\\n            ans = min(ans,solve(n-1,i,matrix,dp));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int row, int col, vector<vector<int>> &matrix,vector<vector<int>> &dp)\\n    {\\n        if(col<0 || col>matrix[0].size()-1) return 1E9;\\n        if(row==0) return matrix[row][col];\\n        if(dp[row][col] != -1) return dp[row][col];\\n        int up = matrix[row][col] + solve(row-1,col,matrix,dp);\\n        int leftDiagonal = matrix[row][col] + solve(row-1,col-1,matrix,dp);\\n        int rightDiagonal = matrix[row][col] + solve(row-1,col+1,matrix,dp);\\n        return dp[row][col] = min(up,min(leftDiagonal,rightDiagonal));\\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int ans = INT_MAX;\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>> dp(n,vector<int>(m,-1));\\n        for(int i=0;i<m;i++)\\n        {\\n            ans = min(ans,solve(n-1,i,matrix,dp));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2907956,
                "title": "python-code-beats-96-easy-for-begginers",
                "content": "# Code\\n```\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        for i in range(1,len(matrix)):\\n            for j in range(len(matrix[i])):\\n                if j != 0 and j!=len(matrix[i])-1:\\n                    matrix[i][j] = min(matrix[i][j] + matrix[i-1][j], matrix[i][j] + matrix[i-1][j-1], matrix[i][j] + matrix[i-1][j+1])\\n                elif j == 0:\\n                    matrix[i][j] = min(matrix[i][j] + matrix[i-1][j], matrix[i][j] + matrix[i-1][j+1])\\n                else:\\n                    matrix[i][j] = min(matrix[i][j] + matrix[i-1][j], matrix[i][j] + matrix[i-1][j-1])\\n        return min(matrix[-1])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        for i in range(1,len(matrix)):\\n            for j in range(len(matrix[i])):\\n                if j != 0 and j!=len(matrix[i])-1:\\n                    matrix[i][j] = min(matrix[i][j] + matrix[i-1][j], matrix[i][j] + matrix[i-1][j-1], matrix[i][j] + matrix[i-1][j+1])\\n                elif j == 0:\\n                    matrix[i][j] = min(matrix[i][j] + matrix[i-1][j], matrix[i][j] + matrix[i-1][j+1])\\n                else:\\n                    matrix[i][j] = min(matrix[i][j] + matrix[i-1][j], matrix[i][j] + matrix[i-1][j-1])\\n        return min(matrix[-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2907554,
                "title": "c-solution",
                "content": "# Code\\n```\\n#define inf 1000000000\\n#define maxn 105\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size(), dp[maxn][maxn] = {};\\n        for(int i=1; i<maxn; i++) for(int j=0; j<maxn; j++) dp[i][j] = inf;\\n        for(int i=1; i<=n; i++) {\\n            for(int j=1; j<=n; j++) {\\n                dp[i][j] = matrix[i-1][j-1] + min({dp[i-1][j-1], dp[i-1][j], dp[i-1][j+1]});\\n            }\\n        }\\n        int ans = inf;\\n        for(int i=1; i<=n; i++) ans = min(ans, dp[n][i]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define inf 1000000000\\n#define maxn 105\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size(), dp[maxn][maxn] = {};\\n        for(int i=1; i<maxn; i++) for(int j=0; j<maxn; j++) dp[i][j] = inf;\\n        for(int i=1; i<=n; i++) {\\n            for(int j=1; j<=n; j++) {\\n                dp[i][j] = matrix[i-1][j-1] + min({dp[i-1][j-1], dp[i-1][j], dp[i-1][j+1]});\\n            }\\n        }\\n        int ans = inf;\\n        for(int i=1; i<=n; i++) ans = min(ans, dp[n][i]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2907236,
                "title": "python-simple-solutions-o-n-2-time-and-o-1-space",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def minFallingPathSum(self, matrix):\\n        matLen = len(matrix)\\n        for i in range(matLen-2,-1,-1):\\n            for j in range (matLen):\\n                left = matrix[i][j]+matrix[i+1][j-1] if j > 0 else 999999999\\n                mid = matrix[i][j]+matrix[i+1][j] \\n                right = matrix[i][j]+matrix[i+1][j+1] if j < matLen-1 else 999999999\\n                matrix[i][j] = min(left,mid,right)\\n        return min(matrix[0])\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution(object):\\n    def minFallingPathSum(self, matrix):\\n        matLen = len(matrix)\\n        for i in range(matLen-2,-1,-1):\\n            for j in range (matLen):\\n                left = matrix[i][j]+matrix[i+1][j-1] if j > 0 else 999999999\\n                mid = matrix[i][j]+matrix[i+1][j] \\n                right = matrix[i][j]+matrix[i+1][j+1] if j < matLen-1 else 999999999\\n                matrix[i][j] = min(left,mid,right)\\n        return min(matrix[0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2907130,
                "title": "java-easy-to-understand-dp-using-tabulation",
                "content": "https://github.com/Freeze777/SDE-Interviewer-Notes/blob/main/LeetCodeJava/src/main/java/leetcode/medium/dp/MinFallingPathSum.java",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2906518,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        //here we are manipulating the input matrix. We are storing the minimum sum upto that position from the first row.\\n        for(int i=1;i<=matrix.size()-1;++i)\\n            for(int j=0;j<=matrix.size()-1;++j)\\n                matrix[i][j]+=min({matrix[i-1][j],matrix[i-1][max(0,j-1)],matrix[i-1][min((int)matrix.size()-1,j+1)]});\\n                // Now we are returning the minimum sum stored from the last row.\\n        return *min_element((begin(matrix[matrix.size()-1])),end(matrix[matrix.size()-1]));\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        //here we are manipulating the input matrix. We are storing the minimum sum upto that position from the first row.\\n        for(int i=1;i<=matrix.size()-1;++i)\\n            for(int j=0;j<=matrix.size()-1;++j)\\n                matrix[i][j]+=min({matrix[i-1][j],matrix[i-1][max(0,j-1)],matrix[i-1][min((int)matrix.size()-1,j+1)]});\\n                // Now we are returning the minimum sum stored from the last row.\\n        return *min_element((begin(matrix[matrix.size()-1])),end(matrix[matrix.size()-1]));\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2906130,
                "title": "javascript-iteration-recursion-dynamic-programming-memoization",
                "content": "\\uD835\\uDDE3\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDDF2 \\uD835\\uDDF1\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDDFD \\uD835\\uDDF0\\uD835\\uDDFC\\uD835\\uDDFA\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\uD835\\uDE00 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF3\\uD835\\uDDF2\\uD835\\uDDF2\\uD835\\uDDF1\\uD835\\uDDEF\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF8 \\uD835\\uDDF3\\uD835\\uDDFC\\uD835\\uDDFF \\uD835\\uDDF6\\uD835\\uDDFA\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDE03\\uD835\\uDDF2\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\nhttps://youtu.be/OPwU0D0z1r4\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n*n)\\n# Code\\n```\\n/**\\n *Iteration\\n */\\nvar minFallingPathSum = function(matrix) {\\n    let n = matrix.length;\\n\\n    let dp = new Array(n);\\n    for (let i = 0; i < n; i++) {\\n        dp[i] = [...matrix[i]]\\n    }\\n\\n    let minSum = Infinity;\\n    for (let i = n - 2; i >= 0; i--) {\\n        minSum = Infinity;\\n        for (let j = 0; j < n; j++) {\\n            dp[i][j] += dp[i+1][j];\\n            if (j > 0) dp[i][j] = Math.min(dp[i][j], matrix[i][j] + dp[i+1][j-1]);\\n            if (j < n-1) dp[i][j] = Math.min(dp[i][j], matrix[i][j] + dp[i+1][j+1]);\\n            minSum = Math.min(minSum, dp[i][j])\\n        }\\n    }\\n    return matrix.length > 1 ? minSum : matrix[0][0];\\n};\\n```\\n\\n\\n```\\n\\\\\\\\recursion\\nvar minFallingPathSum = function(matrix) {\\n    let minSum = Infinity;\\n    let n = matrix.length;\\n    let dp = new Array(n);\\n    for (let i = 0; i < n; i++) {\\n        dp[i] = [...matrix[i]];\\n    }\\n    let helper = function(i,j) {\\n        if (i == n || j == n || i < 0 || j < 0) return Infinity;\\n        if (i == n-1) return matrix[i][j];\\n        if (dp[i][j] != matrix[i][j]) return dp[i][j];\\n\\n        dp[i][j] += Math.min(helper(i+1, j-1), Math.min(helper(i+1, j), helper(i+1, j+1)))\\n        return dp[i][j];\\n    }\\n    for (let i = 0; i < matrix.length; i++) {\\n        helper(0,i);\\n        minSum = Math.min(minSum, dp[0][i])\\n    }\\n    return minSum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Iterator"
                ],
                "code": "```\\n/**\\n *Iteration\\n */\\nvar minFallingPathSum = function(matrix) {\\n    let n = matrix.length;\\n\\n    let dp = new Array(n);\\n    for (let i = 0; i < n; i++) {\\n        dp[i] = [...matrix[i]]\\n    }\\n\\n    let minSum = Infinity;\\n    for (let i = n - 2; i >= 0; i--) {\\n        minSum = Infinity;\\n        for (let j = 0; j < n; j++) {\\n            dp[i][j] += dp[i+1][j];\\n            if (j > 0) dp[i][j] = Math.min(dp[i][j], matrix[i][j] + dp[i+1][j-1]);\\n            if (j < n-1) dp[i][j] = Math.min(dp[i][j], matrix[i][j] + dp[i+1][j+1]);\\n            minSum = Math.min(minSum, dp[i][j])\\n        }\\n    }\\n    return matrix.length > 1 ? minSum : matrix[0][0];\\n};\\n```\n```\\n\\\\\\\\recursion\\nvar minFallingPathSum = function(matrix) {\\n    let minSum = Infinity;\\n    let n = matrix.length;\\n    let dp = new Array(n);\\n    for (let i = 0; i < n; i++) {\\n        dp[i] = [...matrix[i]];\\n    }\\n    let helper = function(i,j) {\\n        if (i == n || j == n || i < 0 || j < 0) return Infinity;\\n        if (i == n-1) return matrix[i][j];\\n        if (dp[i][j] != matrix[i][j]) return dp[i][j];\\n\\n        dp[i][j] += Math.min(helper(i+1, j-1), Math.min(helper(i+1, j), helper(i+1, j+1)))\\n        return dp[i][j];\\n    }\\n    for (let i = 0; i < matrix.length; i++) {\\n        helper(0,i);\\n        minSum = Math.min(minSum, dp[0][i])\\n    }\\n    return minSum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2906085,
                "title": "java-solution-dp",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n       int dp[][] = new int[matrix.length][matrix.length];\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0;i<matrix.length;i++){\\n            dp[0][i]=matrix[0][i];\\n        }\\n\\n        for(int i=1;i<matrix.length;i++){\\n            for(int j=0;j<matrix.length;j++){\\n                if(j==0){\\n                    dp[i][j]=matrix[i][j]+Math.min(dp[i-1][j],dp[i-1][j+1]);\\n                }\\n                else if(j==matrix.length-1){\\n                    dp[i][j]=matrix[i][j]+Math.min(dp[i-1][j],dp[i-1][j-1]);\\n                }\\n                else{\\n                    dp[i][j]=matrix[i][j]+ Math.min(Math.min(dp[i-1][j-1], dp[i-1][j]), dp[i-1][j+1]);\\n                }\\n\\n            }\\n        }\\n        for(int i=0;i<matrix.length;i++){\\n            if(dp[matrix.length-1][i]<min) min=dp[matrix.length-1][i];\\n        }\\n     return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n       int dp[][] = new int[matrix.length][matrix.length];\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0;i<matrix.length;i++){\\n            dp[0][i]=matrix[0][i];\\n        }\\n\\n        for(int i=1;i<matrix.length;i++){\\n            for(int j=0;j<matrix.length;j++){\\n                if(j==0){\\n                    dp[i][j]=matrix[i][j]+Math.min(dp[i-1][j],dp[i-1][j+1]);\\n                }\\n                else if(j==matrix.length-1){\\n                    dp[i][j]=matrix[i][j]+Math.min(dp[i-1][j],dp[i-1][j-1]);\\n                }\\n                else{\\n                    dp[i][j]=matrix[i][j]+ Math.min(Math.min(dp[i-1][j-1], dp[i-1][j]), dp[i-1][j+1]);\\n                }\\n\\n            }\\n        }\\n        for(int i=0;i<matrix.length;i++){\\n            if(dp[matrix.length-1][i]<min) min=dp[matrix.length-1][i];\\n        }\\n     return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2905834,
                "title": "swift-one-liner",
                "content": "**One-Liner, terse (accepted answer)**\\n```\\nclass Solution {\\n    func minFallingPathSum(_ m: [[Int]]) -> Int {\\n        (1..<m.count).reduce(into: m) { m,i in m.indices.forEach { j in m[i][j]+=m[i-1][max(0,j-1)...min(m.count-1,j+1)].min()!}}.last!.min()!\\n    }\\n}\\n```\\n**NOTE:** Technically a one-liner, since `return` keyword was omitted.\\n\\n---\\n**One-Liner, expanded (accepted answer)**\\n```\\nclass Solution {\\n    func minFallingPathSum(_ m: [[Int]]) -> Int {\\n        (1..<m.count).reduce(into: m) { m,i in\\n            m.indices.forEach { j in\\n                m[i][j] += m[i-1][max(0,j-1)...min(m.count-1,j+1)].min()!\\n            }\\n        }.last!.min()!\\n    }\\n}\\n```\\n---\\n\\n**One-Liner, expanded and annotated (accepted answer)**\\n```\\nclass Solution {\\n    func minFallingPathSum(_ matrix: [[Int]]) -> Int {\\n        // compute dp in-place \\n        // the reduce result initialized to a copy of `matrix` value\\n        (1..<matrix.count).reduce(into: matrix) { m,i in\\n            matrix.indices.forEach { j in\\n                // update `m[i][j]` by adding to it min. of \\n                // (up to) three adjacent cells under it.  \\n                m[i][j] += m[i-1][max(0,j-1)...min(m.count-1,j+1)].min()!\\n            }\\n        }.last!.min()! // the minimum elem. of the last row is the result.\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minFallingPathSum(_ m: [[Int]]) -> Int {\\n        (1..<m.count).reduce(into: m) { m,i in m.indices.forEach { j in m[i][j]+=m[i-1][max(0,j-1)...min(m.count-1,j+1)].min()!}}.last!.min()!\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func minFallingPathSum(_ m: [[Int]]) -> Int {\\n        (1..<m.count).reduce(into: m) { m,i in\\n            m.indices.forEach { j in\\n                m[i][j] += m[i-1][max(0,j-1)...min(m.count-1,j+1)].min()!\\n            }\\n        }.last!.min()!\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func minFallingPathSum(_ matrix: [[Int]]) -> Int {\\n        // compute dp in-place \\n        // the reduce result initialized to a copy of `matrix` value\\n        (1..<matrix.count).reduce(into: matrix) { m,i in\\n            matrix.indices.forEach { j in\\n                // update `m[i][j]` by adding to it min. of \\n                // (up to) three adjacent cells under it.  \\n                m[i][j] += m[i-1][max(0,j-1)...min(m.count-1,j+1)].min()!\\n            }\\n        }.last!.min()! // the minimum elem. of the last row is the result.\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2905656,
                "title": "daily-leetcoding-challenge-december-day-13",
                "content": "This problem is the Daily LeetCoding Challenge for December, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/minimum-falling-path-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force Using Depth First Search\n\n  \n**Approach 2:** Top Down Dynamic Programming\n\n  \n**Approach 3:** Bottom-Up Dynamic Programming (Tabulation)\n\n  \n**Approach 4:** Space Optimized, Bottom-Up Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/minimum-falling-path-sum/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n**Approach 3:** Bottom-Up Dynamic Programming (Tabulation)\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2877607,
                "title": "golang-clean-and-efficient-dp-solution",
                "content": "```\\nfunc minFallingPathSum(matrix [][]int) int {\\n    dp := make([][]int, len(matrix))\\n    for i := range dp {\\n        dp[i] = make([]int, len(matrix[0]))\\n    }\\n    copy(dp[0], matrix[0])\\n\\n    for i := 1; i < len(dp); i++ {\\n        for j := 0; j < len(dp[0]); j++ {\\n            var minPathAbove int\\n\\n            switch j {\\n            case 0:\\n                minPathAbove = min([]int{dp[i-1][j], dp[i-1][j+1]})\\n            case len(dp[0])-1:\\n                minPathAbove = min([]int{dp[i-1][j-1], dp[i-1][j]})\\n            default:\\n                minPathAbove = min([]int{dp[i-1][j-1], dp[i-1][j], dp[i-1][j+1]})\\n            }\\n            \\n            dp[i][j] = minPathAbove + matrix[i][j]\\n        }\\n    }\\n\\n    return min(dp[len(dp)-1])\\n}\\n\\nfunc min(a []int) int {\\n    curMin := a[0]\\n    for _, elem := range a {\\n        if elem < curMin {\\n            curMin = elem\\n        }\\n    }\\n    return curMin\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nfunc minFallingPathSum(matrix [][]int) int {\\n    dp := make([][]int, len(matrix))\\n    for i := range dp {\\n        dp[i] = make([]int, len(matrix[0]))\\n    }\\n    copy(dp[0], matrix[0])\\n\\n    for i := 1; i < len(dp); i++ {\\n        for j := 0; j < len(dp[0]); j++ {\\n            var minPathAbove int\\n\\n            switch j {\\n            case 0:\\n                minPathAbove = min([]int{dp[i-1][j], dp[i-1][j+1]})\\n            case len(dp[0])-1:\\n                minPathAbove = min([]int{dp[i-1][j-1], dp[i-1][j]})\\n            default:\\n                minPathAbove = min([]int{dp[i-1][j-1], dp[i-1][j], dp[i-1][j+1]})\\n            }\\n            \\n            dp[i][j] = minPathAbove + matrix[i][j]\\n        }\\n    }\\n\\n    return min(dp[len(dp)-1])\\n}\\n\\nfunc min(a []int) int {\\n    curMin := a[0]\\n    for _, elem := range a {\\n        if elem < curMin {\\n            curMin = elem\\n        }\\n    }\\n    return curMin\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2847369,
                "title": "python-dp",
                "content": "class Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        m=len(matrix)\\n        n=len(matrix[0])\\n        dp=[[0 for i in range(n)] for j in range(m)]\\n        for i in range(0,m):\\n            for j in range(0,n):\\n                if(i>0):\\n                    if(j-1>=0 and j+1<n):\\n                        dp[i][j]=matrix[i][j]+min(dp[i-1][j-1],dp[i-1][j],dp[i-1][j+1])\\n                    elif(j==0):\\n                        dp[i][j]=matrix[i][j]+min(dp[i-1][j],dp[i-1][j+1])\\n                    else:\\n                        dp[i][j]=matrix[i][j]+min(dp[i-1][j],dp[i-1][j-1])\\n                else:\\n                    dp[i][j]=matrix[i][j]\\n        return min(dp[-1])\\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        m=len(matrix)\\n        n=len(matrix[0])\\n        dp=[[0 for i in range(n)] for j in range(m)]\\n        for i in range(0,m):\\n            for j in range(0,n):\\n                if(i>0):\\n                    if(j-1>=0 and j+1<n):\\n                        dp[i][j]=matrix[i][j]+min(dp[i-1][j-1],dp[i-1][j],dp[i-1][j+1])\\n                    elif(j==0):\\n                        dp[i][j]=matrix[i][j]+min(dp[i-1][j],dp[i-1][j+1])\\n                    else:\\n                        dp[i][j]=matrix[i][j]+min(dp[i-1][j],dp[i-1][j-1])\\n                else:\\n                    dp[i][j]=matrix[i][j]\\n        return min(dp[-1])\\n",
                "codeTag": "Java"
            },
            {
                "id": 2617250,
                "title": "what-s-wrong-in-the-memoization-code-runtime-error",
                "content": "Here\\'s my code: \\n```\\nclass Solution {\\npublic:\\n    int solve(int i, int j, vector<vector<int>>& mat, vector<vector<int>> &dp){\\n        if(i == 0) return mat[0][j];\\n        if(j < 0 || j >= mat[0].size()) return 1e9;\\n        \\n        if(dp[i][j] != -1) return dp[i][j];\\n        int up = mat[i][j] + solve(i-1,j,mat,dp);\\n        int upl = mat[i][j] + solve(i-1,j-1,mat,dp);\\n        int upr = mat[i][j] + solve(i-1,j+1,mat,dp);\\n        \\n        return dp[i][j] = min(up,min(upl,upr));\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        int mini = 1e9;\\n        for(int i=0;i<n;i++){\\n            mini = min(mini,solve(n-1,i,mat,dp));\\n        }\\n        return mini;\\n    }\\n};\\n```\\nError:\\n```\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n```\\n",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i, int j, vector<vector<int>>& mat, vector<vector<int>> &dp){\\n        if(i == 0) return mat[0][j];\\n        if(j < 0 || j >= mat[0].size()) return 1e9;\\n        \\n        if(dp[i][j] != -1) return dp[i][j];\\n        int up = mat[i][j] + solve(i-1,j,mat,dp);\\n        int upl = mat[i][j] + solve(i-1,j-1,mat,dp);\\n        int upr = mat[i][j] + solve(i-1,j+1,mat,dp);\\n        \\n        return dp[i][j] = min(up,min(upl,upr));\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        int mini = 1e9;\\n        for(int i=0;i<n;i++){\\n            mini = min(mini,solve(n-1,i,mat,dp));\\n        }\\n        return mini;\\n    }\\n};\\n```\n```\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2540020,
                "title": "faster-than-99-71-14-6-mb-less-than-89-60",
                "content": "```\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        n=len(matrix)\\n        dp=[[-1]*n for i in range(n)]\\n        for i in range(n):\\n            (dp[n-1])[i]=(matrix[n-1])[i]\\n\\n        for i in range(n-2,-1,-1):\\n            for j in range(n):\\n                leftd=99999\\n                rightd=99999\\n                down=(dp[i+1])[j]\\n                if j==0:\\n                    rightd=(dp[i+1])[j+1]\\n                elif j==n-1:\\n                    leftd=(dp[i+1])[j-1]\\n                else:  \\n                    rightd=(dp[i+1])[j+1]\\n                    leftd=(dp[i+1])[j-1]\\n\\n                (dp[i])[j]=((matrix[i])[j]+min(rightd,leftd,down))\\n\\n        return min(dp[0])\\n\\t\\t\\n\\t\\t\\n\\t\\t\\nMemoization \\n\\n```\\n```\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        def fun(i,j,Arry,n,dp):\\n            if i==n-1:\\n                (dp[i])[j]=(Arry[i])[j]\\n                return (dp[i])[j]\\n\\n            if (dp[i])[j]!=-1:\\n                return (dp[i])[j]\\n\\n            leftd=99999\\n            rightd=99999\\n            down=fun(i+1,j,Arry,n,dp)\\n            if j==0:\\n                rightd=fun(i+1,j+1,Arry,n,dp)\\n            elif j==n-1:\\n                leftd=fun(i+1,j-1,Arry,n,dp)\\n            else:  \\n                rightd=fun(i+1,j+1,Arry,n,dp)\\n                leftd=fun(i+1,j-1,Arry,n,dp)\\n\\n            (dp[i])[j]=((Arry[i])[j]+min(rightd,leftd,down))\\n            return (dp[i])[j]\\n\\n        \\n        \\n        \\n       \\n        n=len(matrix)\\n        dp=[[-1]*n for i in range(n)]\\n        \\n        mini=99999\\n        for x in range(n):\\n            mini=min(mini,fun(0,x,matrix,n,dp))\\n\\n        return(mini)\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        n=len(matrix)\\n        dp=[[-1]*n for i in range(n)]\\n        for i in range(n):\\n            (dp[n-1])[i]=(matrix[n-1])[i]\\n\\n        for i in range(n-2,-1,-1):\\n            for j in range(n):\\n                leftd=99999\\n                rightd=99999\\n                down=(dp[i+1])[j]\\n                if j==0:\\n                    rightd=(dp[i+1])[j+1]\\n                elif j==n-1:\\n                    leftd=(dp[i+1])[j-1]\\n                else:  \\n                    rightd=(dp[i+1])[j+1]\\n                    leftd=(dp[i+1])[j-1]\\n\\n                (dp[i])[j]=((matrix[i])[j]+min(rightd,leftd,down))\\n\\n        return min(dp[0])\\n\\t\\t\\n\\t\\t\\n\\t\\t\\nMemoization \\n\\n```\n```\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        def fun(i,j,Arry,n,dp):\\n            if i==n-1:\\n                (dp[i])[j]=(Arry[i])[j]\\n                return (dp[i])[j]\\n\\n            if (dp[i])[j]!=-1:\\n                return (dp[i])[j]\\n\\n            leftd=99999\\n            rightd=99999\\n            down=fun(i+1,j,Arry,n,dp)\\n            if j==0:\\n                rightd=fun(i+1,j+1,Arry,n,dp)\\n            elif j==n-1:\\n                leftd=fun(i+1,j-1,Arry,n,dp)\\n            else:  \\n                rightd=fun(i+1,j+1,Arry,n,dp)\\n                leftd=fun(i+1,j-1,Arry,n,dp)\\n\\n            (dp[i])[j]=((Arry[i])[j]+min(rightd,leftd,down))\\n            return (dp[i])[j]\\n\\n        \\n        \\n        \\n       \\n        n=len(matrix)\\n        dp=[[-1]*n for i in range(n)]\\n        \\n        mini=99999\\n        for x in range(n):\\n            mini=min(mini,fun(0,x,matrix,n,dp))\\n\\n        return(mini)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2472309,
                "title": "simple-java-solution",
                "content": "Solution - 1  (dp table memorization)\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] m) {\\n        int k=m.length;\\n        int n=Integer.MAX_VALUE;\\n        int dp[][] = new int[k][k];\\n        for(int a[]:dp)\\n        {\\n            Arrays.fill(a,-1);\\n        }\\n        for(int i=0;i<k;i++)\\n        {\\n            n=Math.min(n,task(k,i,k-1,m,dp));\\n        }\\n        return n;\\n    }\\n    public int task(int n, int j, int i, int m[][], int dp[][])\\n    {\\n        if(j<0||j>=n)\\n            return Integer.MAX_VALUE;\\n        if(i==0)\\n            return m[0][j];\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        else\\n            return dp[i][j] = m[i][j]+Math.min(task(n,j-1,i-1,m,dp),Math.min(task(n,j,i-1,m,dp),task(n,j+1,i-1,m,dp)));\\n    }\\n}\\n```\\n\\nSolution - 2 (dp table iterative with space optimized)\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] m) {\\n        int k=m.length;\\n        int n=Integer.MAX_VALUE;\\n        int dp[] = new int[k];\\n        for(int i=0;i<k;i++)\\n        {\\n            dp[i]=m[0][i];\\n        }\\n        for(int i=1;i<k;i++)\\n        {\\n            int a[] = new int[k];\\n            for(int j=0;j<k;j++)\\n            {\\n                if(j==0)\\n                {\\n                    a[j]=m[i][j]+Math.min(dp[j],dp[j+1]);\\n                }\\n                else if(j==k-1)\\n                {\\n                    a[j]=m[i][j]+Math.min(dp[j],dp[j-1]);\\n                }\\n                else\\n                {\\n                    a[j]=m[i][j]+Math.min(dp[j],Math.min(dp[j+1],dp[j-1]));\\n                }\\n            }\\n            dp=a;\\n        }\\n        int f=Integer.MAX_VALUE;\\n        for(int i=0;i<k;i++)\\n        {\\n            f=Math.min(f,dp[i]);\\n        }\\n        return f;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] m) {\\n        int k=m.length;\\n        int n=Integer.MAX_VALUE;\\n        int dp[][] = new int[k][k];\\n        for(int a[]:dp)\\n        {\\n            Arrays.fill(a,-1);\\n        }\\n        for(int i=0;i<k;i++)\\n        {\\n            n=Math.min(n,task(k,i,k-1,m,dp));\\n        }\\n        return n;\\n    }\\n    public int task(int n, int j, int i, int m[][], int dp[][])\\n    {\\n        if(j<0||j>=n)\\n            return Integer.MAX_VALUE;\\n        if(i==0)\\n            return m[0][j];\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        else\\n            return dp[i][j] = m[i][j]+Math.min(task(n,j-1,i-1,m,dp),Math.min(task(n,j,i-1,m,dp),task(n,j+1,i-1,m,dp)));\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] m) {\\n        int k=m.length;\\n        int n=Integer.MAX_VALUE;\\n        int dp[] = new int[k];\\n        for(int i=0;i<k;i++)\\n        {\\n            dp[i]=m[0][i];\\n        }\\n        for(int i=1;i<k;i++)\\n        {\\n            int a[] = new int[k];\\n            for(int j=0;j<k;j++)\\n            {\\n                if(j==0)\\n                {\\n                    a[j]=m[i][j]+Math.min(dp[j],dp[j+1]);\\n                }\\n                else if(j==k-1)\\n                {\\n                    a[j]=m[i][j]+Math.min(dp[j],dp[j-1]);\\n                }\\n                else\\n                {\\n                    a[j]=m[i][j]+Math.min(dp[j],Math.min(dp[j+1],dp[j-1]));\\n                }\\n            }\\n            dp=a;\\n        }\\n        int f=Integer.MAX_VALUE;\\n        for(int i=0;i<k;i++)\\n        {\\n            f=Math.min(f,dp[i]);\\n        }\\n        return f;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2418850,
                "title": "c-rec-mem-tab-so-so-inplace-99-faster",
                "content": "\\tint solveRec(vector<vector<int>>& matrix, int i, int j, int n, int m)\\n    {\\n        if(j<0||j>=m) return INT_MAX;\\n        if(i==n-1) return matrix[i][j];\\n        int lDiag=solveRec(matrix,i+1,j-1,n,m);\\n        int bottom=solveRec(matrix,i+1,j,n,m);\\n        int rDiag=solveRec(matrix,i+1,j+1,n,m);\\n        return matrix[i][j]+min(lDiag,min(bottom,rDiag));\\n    }\\n    \\n    int solveMem(vector<vector<int>>& matrix, int i, int j, int n, int m, vector<vector<int>> &dp)\\n    {\\n        if(j<0||j>=m) return INT_MAX;\\n        if(i==n-1) return matrix[i][j];\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int lDiag=solveMem(matrix,i+1,j-1,n,m,dp);\\n        int bottom=solveMem(matrix,i+1,j,n,m,dp);\\n        int rDiag=solveMem(matrix,i+1,j+1,n,m,dp);\\n        return dp[i][j]=matrix[i][j]+min(lDiag,min(bottom,rDiag));\\n    }\\n    \\n    int solveTab(vector<vector<int>>& matrix, int n, int m)\\n    {\\n        vector<vector<int>> dp(n,vector<int>(m));\\n        //Fill up the last row as it is\\n        for(int j=0;j<m;j++)  dp[n-1][j]=matrix[n-1][j];\\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int lDiag=INT_MAX; //only fill it when it is inside our range \\n                int rDiag=INT_MAX;\\n                if(j-1>=0)  lDiag=dp[i+1][j-1];\\n                int bottom=dp[i+1][j]; //this will always be inside the matrix\\n                if(j+1<m)   rDiag=dp[i+1][j+1];\\n                \\n                dp[i][j]=matrix[i][j]+min(lDiag,min(bottom,rDiag));\\n            }\\n        }\\n        int ans=INT_MAX;\\n        \\n        //Grab the least among the first row and return it\\n        for(int j=0;j<m;j++) ans=min(ans,dp[0][j]);\\n        return ans;\\n        \\n    }\\n    \\n    int solveSO(vector<vector<int>>& matrix, int n, int m)\\n    {\\n        vector<int>next(m);\\n        for(int j=0;j<m;j++)  next[j]=matrix[n-1][j];\\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            vector<int>cur(m);\\n            for(int j=0;j<m;j++)\\n            {\\n                int lDiag=INT_MAX;\\n                int rDiag=INT_MAX;\\n                if(j-1>=0)  lDiag=next[j-1];\\n                int bottom=next[j]; \\n                if(j+1<m)   rDiag=next[j+1];\\n                \\n                cur[j]=matrix[i][j]+min(lDiag,min(bottom,rDiag));\\n            }\\n            next=cur;\\n        }\\n        int ans=INT_MAX;\\n        \\n        for(int j=0;j<m;j++) ans=min(ans,next[j]);\\n        return ans;\\n        \\n    }\\n    \\n    int solveSOMore(vector<vector<int>>& matrix, int n, int m)\\n    {        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int lDiag=INT_MAX;\\n                int rDiag=INT_MAX;\\n                if(j-1>=0)  lDiag=matrix[i+1][j-1];\\n                int bottom=matrix[i+1][j]; \\n                if(j+1<m)   rDiag=matrix[i+1][j+1];\\n                \\n                matrix[i][j]=matrix[i][j]+min(lDiag,min(bottom,rDiag));\\n            }\\n        }\\n        \\n        int ans=INT_MAX;\\n        for(int j=0;j<m;j++) ans=min(ans,matrix[0][j]);\\n        return ans;\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n=matrix.size(); int m=matrix[0].size();\\n        // vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        int ans=INT_MAX;\\n        // for(int j=0;j<m;j++)\\n        // {\\n        //     ans=min(ans,solveRec(matrix,0,j,n,m,dp));\\n        //     ans=min(ans,solveMem(matrix,0,j,n,m,dp));\\n        // }\\n        // ans=solveTab(matrix,n,m);\\n        // ans=solveSO(matrix,n,m);\\n        ans=solveSOMore(matrix,n,m);\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "\\tint solveRec(vector<vector<int>>& matrix, int i, int j, int n, int m)\\n    {\\n        if(j<0||j>=m) return INT_MAX;\\n        if(i==n-1) return matrix[i][j];\\n        int lDiag=solveRec(matrix,i+1,j-1,n,m);\\n        int bottom=solveRec(matrix,i+1,j,n,m);\\n        int rDiag=solveRec(matrix,i+1,j+1,n,m);\\n        return matrix[i][j]+min(lDiag,min(bottom,rDiag));\\n    }\\n    \\n    int solveMem(vector<vector<int>>& matrix, int i, int j, int n, int m, vector<vector<int>> &dp)\\n    {\\n        if(j<0||j>=m) return INT_MAX;\\n        if(i==n-1) return matrix[i][j];\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int lDiag=solveMem(matrix,i+1,j-1,n,m,dp);\\n        int bottom=solveMem(matrix,i+1,j,n,m,dp);\\n        int rDiag=solveMem(matrix,i+1,j+1,n,m,dp);\\n        return dp[i][j]=matrix[i][j]+min(lDiag,min(bottom,rDiag));\\n    }\\n    \\n    int solveTab(vector<vector<int>>& matrix, int n, int m)\\n    {\\n        vector<vector<int>> dp(n,vector<int>(m));\\n        //Fill up the last row as it is\\n        for(int j=0;j<m;j++)  dp[n-1][j]=matrix[n-1][j];\\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int lDiag=INT_MAX; //only fill it when it is inside our range \\n                int rDiag=INT_MAX;\\n                if(j-1>=0)  lDiag=dp[i+1][j-1];\\n                int bottom=dp[i+1][j]; //this will always be inside the matrix\\n                if(j+1<m)   rDiag=dp[i+1][j+1];\\n                \\n                dp[i][j]=matrix[i][j]+min(lDiag,min(bottom,rDiag));\\n            }\\n        }\\n        int ans=INT_MAX;\\n        \\n        //Grab the least among the first row and return it\\n        for(int j=0;j<m;j++) ans=min(ans,dp[0][j]);\\n        return ans;\\n        \\n    }\\n    \\n    int solveSO(vector<vector<int>>& matrix, int n, int m)\\n    {\\n        vector<int>next(m);\\n        for(int j=0;j<m;j++)  next[j]=matrix[n-1][j];\\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            vector<int>cur(m);\\n            for(int j=0;j<m;j++)\\n            {\\n                int lDiag=INT_MAX;\\n                int rDiag=INT_MAX;\\n                if(j-1>=0)  lDiag=next[j-1];\\n                int bottom=next[j]; \\n                if(j+1<m)   rDiag=next[j+1];\\n                \\n                cur[j]=matrix[i][j]+min(lDiag,min(bottom,rDiag));\\n            }\\n            next=cur;\\n        }\\n        int ans=INT_MAX;\\n        \\n        for(int j=0;j<m;j++) ans=min(ans,next[j]);\\n        return ans;\\n        \\n    }\\n    \\n    int solveSOMore(vector<vector<int>>& matrix, int n, int m)\\n    {        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int lDiag=INT_MAX;\\n                int rDiag=INT_MAX;\\n                if(j-1>=0)  lDiag=matrix[i+1][j-1];\\n                int bottom=matrix[i+1][j]; \\n                if(j+1<m)   rDiag=matrix[i+1][j+1];\\n                \\n                matrix[i][j]=matrix[i][j]+min(lDiag,min(bottom,rDiag));\\n            }\\n        }\\n        \\n        int ans=INT_MAX;\\n        for(int j=0;j<m;j++) ans=min(ans,matrix[0][j]);\\n        return ans;\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n=matrix.size(); int m=matrix[0].size();\\n        // vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        int ans=INT_MAX;\\n        // for(int j=0;j<m;j++)\\n        // {\\n        //     ans=min(ans,solveRec(matrix,0,j,n,m,dp));\\n        //     ans=min(ans,solveMem(matrix,0,j,n,m,dp));\\n        // }\\n        // ans=solveTab(matrix,n,m);\\n        // ans=solveSO(matrix,n,m);\\n        ans=solveSOMore(matrix,n,m);\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2406783,
                "title": "dynamic-programming-3-approaches",
                "content": "Approach 1 - Recursion only ( TLE Appraoch)\\n```\\n\\tint rec(vector<vector<int>>& mat, int c, int r, int n) {\\n        if(r == n-1) return mat[r][c];\\n        \\n        int left = INT_MAX, right;\\n        if(c>0) left = rec(mat, c-1, r+1, n);\\n        int down = rec(mat, c  , r+1, n);\\n        if(c<n-1) right = rec(mat, c+1, r+1, n);\\n        \\n        int mn = min(down, min(left, right));\\n        return (mat[r][c] + mn);\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& mat) {\\n        int n = mat.size();\\n        \\n        int ans = INT_MAX;\\n        for(int i=0;i<n;i++) {\\n            ans = min(ans, rec(mat, i, 0, n));\\n        }\\n        \\n        return ans;\\n    }\\n```\\n\\nApproach 2 - Recursion + Memoization\\n```\\n\\tint rec(vector<vector<int>>& mat, vector<vector<int>>& dp, int c, int r, int n) {\\n        if(r == n-1) return mat[r][c];\\n        if(dp[r][c] != -1) return dp[r][c];\\n        \\n        int left = INT_MAX, right;\\n        if(c>0) left = rec(mat, dp, c-1, r+1, n);\\n        int down = rec(mat, dp, c  , r+1, n);\\n        if(c<n-1) right = rec(mat, dp, c+1, r+1, n);\\n        \\n        int mn = min(down, min(left, right));\\n        return dp[r][c] = (mat[r][c] + mn);\\n    }\\n    int minFallingPathSum(vector<vector<int>>& mat) {\\n        int n = mat.size();\\n        \\n        vector<vector<int>> dp(n, vector<int> (n, -1));\\n        int ans = INT_MAX;\\n        \\n        for(int i=0;i<n;i++) {\\n            ans = min(ans, rec(mat, dp, i, 0, n));\\n        }\\n        \\n        return ans;\\n    }\\n```\\n\\nApproach 3 - Tabulation\\n```\\n\\tint minFallingPathSum(vector<vector<int>>& mat) {\\n        int n = mat.size();\\n        \\n        vector<vector<int>> dp(n, vector<int> (n, -1));\\n        int ans = INT_MAX;\\n        \\n        for(int i=0;i<n;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(i==0) dp[i][j] = mat[i][j];\\n                else {\\n                    int u = dp[i-1][j];\\n                    int l = INT_MAX, r = INT_MAX;\\n                    if(j>0) l = dp[i-1][j-1];\\n                    if(j<n-1) r=dp[i-1][j+1];\\n                    \\n                    dp[i][j] = min(u, min(l, r)) + mat[i][j];\\n                }\\n                \\n                if(i==n-1) ans = min(ans, dp[i][j]);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n\\tint rec(vector<vector<int>>& mat, int c, int r, int n) {\\n        if(r == n-1) return mat[r][c];\\n        \\n        int left = INT_MAX, right;\\n        if(c>0) left = rec(mat, c-1, r+1, n);\\n        int down = rec(mat, c  , r+1, n);\\n        if(c<n-1) right = rec(mat, c+1, r+1, n);\\n        \\n        int mn = min(down, min(left, right));\\n        return (mat[r][c] + mn);\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& mat) {\\n        int n = mat.size();\\n        \\n        int ans = INT_MAX;\\n        for(int i=0;i<n;i++) {\\n            ans = min(ans, rec(mat, i, 0, n));\\n        }\\n        \\n        return ans;\\n    }\\n```\n```\\n\\tint rec(vector<vector<int>>& mat, vector<vector<int>>& dp, int c, int r, int n) {\\n        if(r == n-1) return mat[r][c];\\n        if(dp[r][c] != -1) return dp[r][c];\\n        \\n        int left = INT_MAX, right;\\n        if(c>0) left = rec(mat, dp, c-1, r+1, n);\\n        int down = rec(mat, dp, c  , r+1, n);\\n        if(c<n-1) right = rec(mat, dp, c+1, r+1, n);\\n        \\n        int mn = min(down, min(left, right));\\n        return dp[r][c] = (mat[r][c] + mn);\\n    }\\n    int minFallingPathSum(vector<vector<int>>& mat) {\\n        int n = mat.size();\\n        \\n        vector<vector<int>> dp(n, vector<int> (n, -1));\\n        int ans = INT_MAX;\\n        \\n        for(int i=0;i<n;i++) {\\n            ans = min(ans, rec(mat, dp, i, 0, n));\\n        }\\n        \\n        return ans;\\n    }\\n```\n```\\n\\tint minFallingPathSum(vector<vector<int>>& mat) {\\n        int n = mat.size();\\n        \\n        vector<vector<int>> dp(n, vector<int> (n, -1));\\n        int ans = INT_MAX;\\n        \\n        for(int i=0;i<n;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(i==0) dp[i][j] = mat[i][j];\\n                else {\\n                    int u = dp[i-1][j];\\n                    int l = INT_MAX, r = INT_MAX;\\n                    if(j>0) l = dp[i-1][j-1];\\n                    if(j<n-1) r=dp[i-1][j+1];\\n                    \\n                    dp[i][j] = min(u, min(l, r)) + mat[i][j];\\n                }\\n                \\n                if(i==n-1) ans = min(ans, dp[i][j]);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2406284,
                "title": "c-recursion-memoization-tabulation-spaceoptimization",
                "content": "# Method - 1 [Recursion - Bruteforce]\\n![image](https://assets.leetcode.com/users/images/ccff0257-08ed-4483-a58f-0be8fff59853_1660126376.7057586.png)\\n\\n**T->O(3^(n)) && S->O(n) [Recursion Stack Space]**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint f(int i,int j,vector<vector<int>>& mat){\\n\\t\\t\\tif(j<0 || j>=mat.size()) return 1e6;\\n\\t\\t\\tif(i==mat.size()-1) return mat[i][j];\\n\\t\\t\\tint left = mat[i][j] + f(i+1,j-1,mat); \\n\\t\\t\\tint down = mat[i][j] + f(i+1,j,mat);\\n\\t\\t\\tint right = mat[i][j] + f(i+1,j+1,mat);\\n\\t\\t\\treturn min(down,min(left,right)); \\n\\t\\t}\\n\\n\\t\\tint minFallingPathSum(vector<vector<int>>& mat) {\\n\\t\\t\\tint n=mat.size();\\n\\t\\t\\tint ans=INT_MAX;\\n\\t\\t\\tfor(int j=0;j<n;j++) ans=min(ans,f(0,j,mat));\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\n\\n# Method - 2 [Memoization]\\n![image](https://assets.leetcode.com/users/images/3cbc847f-13ca-4122-a0ce-dadae9bb70ee_1660126484.8591104.png)\\n\\n**T->O(n * n) && S->O(n) [Recursion Stack Space] + O(n * n) [Space for dp Matrix]**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint f(int i,int j,vector<vector<int>>& mat,vector<vector<int>>& dp){\\n\\t\\t\\tif(j<0 || j>=mat.size()) return 1e6;\\n\\t\\t\\tif(i==mat.size()-1) return mat[i][j];\\n\\t\\t\\tif(dp[i][j]!=-1) return dp[i][j];\\n\\t\\t\\tint left = mat[i][j] + f(i+1,j-1,mat,dp); \\n\\t\\t\\tint down = mat[i][j] + f(i+1,j,mat,dp);\\n\\t\\t\\tint right = mat[i][j] + f(i+1,j+1,mat,dp);\\n\\t\\t\\treturn dp[i][j] = min(down,min(left,right)); \\n\\t\\t}\\n\\n\\t\\tint minFallingPathSum(vector<vector<int>>& mat) {\\n\\t\\t\\tint n=mat.size();\\n\\t\\t\\tint ans=INT_MAX;\\n\\t\\t\\tvector<vector<int>>dp(n,vector<int>(n,-1));\\n\\t\\t\\tfor(int j=0;j<n;j++) ans=min(ans,f(0,j,mat,dp));\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\n\\n# Method - 3 [Tabulation]\\n\\n![image](https://assets.leetcode.com/users/images/6dc28f26-0411-4ee7-9b53-0365d4e7b77d_1660126223.16893.png)\\n\\n**T->O(n * n) && S->O(n * n) [Space for dp matrix]**\\n\\n\\tclass Solution {\\n\\tpublic:    \\n\\t\\tint minFallingPathSum(vector<vector<int>>& mat) {\\n\\t\\t\\tint n=mat.size();\\n\\t\\t\\tvector<vector<int>>dp(n,vector<int>(n,0));\\n\\t\\t\\tfor(int j=0;j<n;j++) dp[n-1][j]=mat[n-1][j];\\n\\t\\t\\tfor(int i=n-2;i>=0;i--){\\n\\t\\t\\t\\tfor(int j=0;j<n;j++){\\n\\t\\t\\t\\t\\tint left=INT_MAX,right=INT_MAX;\\n\\t\\t\\t\\t\\tif(j>0) left = mat[i][j] + dp[i+1][j-1]; \\n\\t\\t\\t\\t\\tint down = mat[i][j] + dp[i+1][j];\\n\\t\\t\\t\\t\\tif(j<n-1) right = mat[i][j] + dp[i+1][j+1];\\n\\t\\t\\t\\t\\tdp[i][j] = min(down,min(left,right));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn *min_element(dp[0].begin(),dp[0].end());\\n\\t\\t}\\n\\t};\\n\\t\\n# Method-4 [Space Optimization]\\t\\n![image](https://assets.leetcode.com/users/images/9f07bd0e-894e-456c-aa08-72f937436b6d_1660127095.6840546.png)\\n\\n**T->O(n * n) && S->O(n) [Space for Prevrow vector]**\\n\\n\\tclass Solution {\\n\\tpublic:    \\n\\t\\tint minFallingPathSum(vector<vector<int>>& mat) {\\n\\t\\t\\tint n=mat.size();\\n\\t\\t\\tvector<int> prevrow(n);\\n\\t\\t\\tfor(int j=0;j<n;j++) prevrow[j]=mat[n-1][j];\\n\\t\\t\\tfor(int i=n-2;i>=0;i--){\\n\\t\\t\\t\\tvector<int> currrow(n);\\n\\t\\t\\t\\tfor(int j=0;j<n;j++){\\n\\t\\t\\t\\t\\tint left=INT_MAX,right=INT_MAX;\\n\\t\\t\\t\\t\\tif(j>0) left = mat[i][j] + prevrow[j-1]; \\n\\t\\t\\t\\t\\tint down = mat[i][j] + prevrow[j];\\n\\t\\t\\t\\t\\tif(j<n-1) right = mat[i][j] + prevrow[j+1];\\n\\t\\t\\t\\t\\tcurrrow[j] = min(down,min(left,right));\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tprevrow=currrow;\\n\\t\\t\\t}\\n\\t\\t\\treturn *min_element(prevrow.begin(),prevrow.end());\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint f(int i,int j,vector<vector<int>>& mat){\\n\\t\\t\\tif(j<0 || j>=mat.size()) return 1e6;\\n\\t\\t\\tif(i==mat.size()-1) return mat[i][j];\\n\\t\\t\\tint left = mat[i][j] + f(i+1,j-1,mat); \\n\\t\\t\\tint down = mat[i][j] + f(i+1,j,mat);\\n\\t\\t\\tint right = mat[i][j] + f(i+1,j+1,mat);\\n\\t\\t\\treturn min(down,min(left,right)); \\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2401168,
                "title": "python-recursion-dp-optimization",
                "content": "\\n**This is a  recursive approach (TLE)**\\n```  \\n\\nclass Solution(object):\\n    def minFallingPathSum(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        \\n        n=len(matrix)\\n\\n        \\n        def A(row,col):\\n\\t\\t\\t#handling edge cases\\n            if col<0 or col>n-1:return float(\\'inf\\')\\n            # if we reach last row \\n            if row==n-1:\\n                return matrix[row][col]\\n            \\n\\t\\t\\t#find the minimum path from curr(row,col)\\n            a=matrix[row][col]+A(row+1,col+1)\\n            b=matrix[row][col]+A(row+1,col)\\n            c=matrix[row][col]+A(row+1,col-1)\\n            \\n\\t\\t\\t#store the minimum path \\n            ans=min(a,b,c)\\n            \\n            \\n            return ans\\n        \\n        m=float(\\'inf\\')\\n        for x in range(n):\\n            m=min(m,A(0,x))\\n        return m\\n             ```\\n\\t\\t\\t \\n\\nThis is optimization of recursive approach  using DP (Above approach is Recursive )(Accepted)\\n\\n\\nclass Solution(object):\\n    def minFallingPathSum(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        \\n        n=len(matrix)\\n        \\n        dp=[[-1 for y in range(n)] for x in range(n)]\\n\\n        \\n        def A(row,col):\\n            if col<0 or col>n-1:return float(\\'inf\\')\\n            \\n            if row==n-1:\\n                dp[row][col]=matrix[row][col]\\n                return matrix[row][col]\\n            \\n            if dp[row][col]!=-1:\\n                return dp[row][col]\\n            \\n            \\n            \\n            a=matrix[row][col]+A(row+1,col+1)\\n            b=matrix[row][col]+A(row+1,col)\\n            c=matrix[row][col]+A(row+1,col-1)\\n            \\n            dp[row][col]=min(a,b,c)\\n            \\n            return dp[row][col]\\n            \\n        \\n        \\n        m=float(\\'inf\\')\\n        for x in range(n):\\n            A(0,x)\\n        return min(dp[0])\\n        \\n            \\n            \\n            \\n                ```\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```  \\n\\nclass Solution(object):\\n    def minFallingPathSum(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        \\n        n=len(matrix)\\n\\n        \\n        def A(row,col):\\n\\t\\t\\t#handling edge cases\\n            if col<0 or col>n-1:return float(\\'inf\\')\\n            # if we reach last row \\n            if row==n-1:\\n                return matrix[row][col]\\n            \\n\\t\\t\\t#find the minimum path from curr(row,col)\\n            a=matrix[row][col]+A(row+1,col+1)\\n            b=matrix[row][col]+A(row+1,col)\\n            c=matrix[row][col]+A(row+1,col-1)\\n            \\n\\t\\t\\t#store the minimum path \\n            ans=min(a,b,c)\\n            \\n            \\n            return ans\\n        \\n        m=float(\\'inf\\')\\n        for x in range(n):\\n            m=min(m,A(0,x))\\n        return m\\n             ```",
                "codeTag": "Java"
            },
            {
                "id": 2373582,
                "title": "from-memoization-to-space-optimized",
                "content": "```\\nclass Solution {\\n    // public int helper(int i,int j,int n,int [][]matrix,int dp[][])\\n    // {//memo\\n    //     if(j<0 || j>=n) return (int)Math.pow(10,9);//for  preventing out of bound \\n    //     if(i==0)return matrix[i][j];// once we reach the 1st row we will return element\\\\\\n    //     if(dp[i][j]!=-1) return dp[i][j];\\n    //     int up=matrix[i][j]+helper(i-1,j,n,matrix,dp);\\n    //     int upleft=matrix[i][j]+helper(i-1,j-1,n,matrix,dp);\\n    //     int upright=matrix[i][j]+helper(i-1,j+1,n,matrix,dp);\\n    //     return dp[i][j]=Math.min(up,Math.min(upleft,upright));\\n    // }\\n    \\n    \\n//     public int minFallingPathSum(int[][] matrix) {\\n//      int  n=matrix.length;//tabulation\\n//         int m=matrix[0].length;\\n//         int dp[][]=new int[n][m];\\n        \\n//   for(int j=0;j<m;j++)\\n//   {\\n      \\n//       dp[0][j]=matrix[0][j];\\n//   }\\n//         for(int i=1;i<n;i++)\\n//         {\\n//             for(int j=0;j<m;j++)\\n//             {\\n//                 int up=0,left=0,right=0;\\n//                  up=matrix[i][j]+dp[i-1][j];\\n//              if(j-1>=0)    left=matrix[i][j]+dp[i-1][j-1];\\n//                 else left= matrix[i][j]+(int)Math.pow(10,9);\\n\\n//                 if(j+1<m)  right=matrix[i][j]+dp[i-1][j+1];\\n//                 else right=matrix[i][j]+(int)Math.pow(10,9);\\n//                  dp[i][j]=Math.min(up,Math.min(left,right));\\n//                 }\\n           \\n//         }\\n        \\n//         int mini=Integer.MAX_VALUE;\\n//         for(int j=0;j<m;j++)\\n//         {\\n//             mini=Math.min(mini,dp[n-1][j]);\\n//         }\\n//         return mini;\\n//     }\\n// }\\n\\n\\n\\n    public int minFallingPathSum(int[][] matrix) {\\n     int  n=matrix.length;\\n        int m=matrix[0].length;\\n    \\n        int prev[]=new int[m];\\n       \\n        \\n  for(int j=0;j<m;j++)\\n  {\\n      \\n      prev[j]=matrix[0][j];\\n  }\\n        for(int i=1;i<n;i++)\\n        {\\n             int curr[]=new int[m];\\n            for(int j=0;j<m;j++)\\n            {\\n                int up=0,left=0,right=0;\\n                 up=matrix[i][j]+prev[j];\\n             if(j-1>=0)    left=matrix[i][j]+prev[j-1];\\n                else left= matrix[i][j]+(int)Math.pow(10,9);\\n\\n                if(j+1<m)  right=matrix[i][j]+prev[j+1];\\n                else right=matrix[i][j]+(int)Math.pow(10,9);\\n                 curr[j]=Math.min(up,Math.min(left,right));\\n                }\\n            prev=curr;\\n           \\n        }\\n        \\n        int mini=Integer.MAX_VALUE;\\n        for(int j=0;j<m;j++)\\n        { int temp=prev[j];\\n            mini=Math.min(mini,temp);\\n        }\\n        return mini;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // public int helper(int i,int j,int n,int [][]matrix,int dp[][])\\n    // {//memo\\n    //     if(j<0 || j>=n) return (int)Math.pow(10,9);//for  preventing out of bound \\n    //     if(i==0)return matrix[i][j];// once we reach the 1st row we will return element\\\\\\n    //     if(dp[i][j]!=-1) return dp[i][j];\\n    //     int up=matrix[i][j]+helper(i-1,j,n,matrix,dp);\\n    //     int upleft=matrix[i][j]+helper(i-1,j-1,n,matrix,dp);\\n    //     int upright=matrix[i][j]+helper(i-1,j+1,n,matrix,dp);\\n    //     return dp[i][j]=Math.min(up,Math.min(upleft,upright));\\n    // }\\n    \\n    \\n//     public int minFallingPathSum(int[][] matrix) {\\n//      int  n=matrix.length;//tabulation\\n//         int m=matrix[0].length;\\n//         int dp[][]=new int[n][m];\\n        \\n//   for(int j=0;j<m;j++)\\n//   {\\n      \\n//       dp[0][j]=matrix[0][j];\\n//   }\\n//         for(int i=1;i<n;i++)\\n//         {\\n//             for(int j=0;j<m;j++)\\n//             {\\n//                 int up=0,left=0,right=0;\\n//                  up=matrix[i][j]+dp[i-1][j];\\n//              if(j-1>=0)    left=matrix[i][j]+dp[i-1][j-1];\\n//                 else left= matrix[i][j]+(int)Math.pow(10,9);\\n\\n//                 if(j+1<m)  right=matrix[i][j]+dp[i-1][j+1];\\n//                 else right=matrix[i][j]+(int)Math.pow(10,9);\\n//                  dp[i][j]=Math.min(up,Math.min(left,right));\\n//                 }\\n           \\n//         }\\n        \\n//         int mini=Integer.MAX_VALUE;\\n//         for(int j=0;j<m;j++)\\n//         {\\n//             mini=Math.min(mini,dp[n-1][j]);\\n//         }\\n//         return mini;\\n//     }\\n// }\\n\\n\\n\\n    public int minFallingPathSum(int[][] matrix) {\\n     int  n=matrix.length;\\n        int m=matrix[0].length;\\n    \\n        int prev[]=new int[m];\\n       \\n        \\n  for(int j=0;j<m;j++)\\n  {\\n      \\n      prev[j]=matrix[0][j];\\n  }\\n        for(int i=1;i<n;i++)\\n        {\\n             int curr[]=new int[m];\\n            for(int j=0;j<m;j++)\\n            {\\n                int up=0,left=0,right=0;\\n                 up=matrix[i][j]+prev[j];\\n             if(j-1>=0)    left=matrix[i][j]+prev[j-1];\\n                else left= matrix[i][j]+(int)Math.pow(10,9);\\n\\n                if(j+1<m)  right=matrix[i][j]+prev[j+1];\\n                else right=matrix[i][j]+(int)Math.pow(10,9);\\n                 curr[j]=Math.min(up,Math.min(left,right));\\n                }\\n            prev=curr;\\n           \\n        }\\n        \\n        int mini=Integer.MAX_VALUE;\\n        for(int j=0;j<m;j++)\\n        { int temp=prev[j];\\n            mini=Math.min(mini,temp);\\n        }\\n        return mini;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2355966,
                "title": "c-recursive-memo-easy-small-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int solve(int m,int n,vector<vector<int>> &grid){\\n        if(m<0){\\n            return INT_MAX;\\n        }\\n        if(n<0){\\n            return INT_MAX;\\n        }\\n        if( n >= grid[m].size()){\\n            return INT_MAX;\\n        }\\n    \\n        if(dp[m][n] != -1)\\n            return dp[m][n];\\n        \\n        if(m == 0)\\n            return  grid[m][n];\\n        \\n        return  dp[m][n] = grid[m][n] + min({solve(m-1,n,grid),solve(m-1,n-1,grid),solve(m-1,n+1,grid)});\\n    }\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        dp = vector<vector<int>>(m,vector<int>(n,-1));\\n        int ans = INT_MAX;\\n        for(int i = 0 ; i <n;i++){\\n            ans = min(ans,solve(m-1,i,grid));\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int solve(int m,int n,vector<vector<int>> &grid){\\n        if(m<0){\\n            return INT_MAX;\\n        }\\n        if(n<0){\\n            return INT_MAX;\\n        }\\n        if( n >= grid[m].size()){\\n            return INT_MAX;\\n        }\\n    \\n        if(dp[m][n] != -1)\\n            return dp[m][n];\\n        \\n        if(m == 0)\\n            return  grid[m][n];\\n        \\n        return  dp[m][n] = grid[m][n] + min({solve(m-1,n,grid),solve(m-1,n-1,grid),solve(m-1,n+1,grid)});\\n    }\\n    int minFallingPathSum(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        dp = vector<vector<int>>(m,vector<int>(n,-1));\\n        int ans = INT_MAX;\\n        for(int i = 0 ; i <n;i++){\\n            ans = min(ans,solve(m-1,i,grid));\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2354399,
                "title": "c-recursive-memoized-code-dp",
                "content": "1. Firstly we will see the basic brute force recursive solution\\n\\n```\\n    int f(int i, int j, vector<vector<int>> &matrix){\\n        \\n\\t\\t//base case\\n        if(i==0) return matrix[0][j];\\n\\t\\t\\n        //to handle edge cases if the j index is less than 0 or greater than size of the array.\\n        if(i<0 or i>=matrix.size[0]) return 1e8;\\n        \\n        int up = matrix[i][j] + f(i, j-1, matrix);\\n        \\n        int l = matrix[i][j] +  f(i-1, j-1, matrix);\\n        \\n        int r = matrix[i][j] +  f(i+1, j-1, matrix);\\n        \\n        return min(up, min(l, r));\\n        \\n\\t\\t}\\n```\\n\\n2. we can apply DP for the same recursive code and memoize it. Here is how it looks like after memoization.\\n```\\nclass Solution {\\npublic:\\n    \\n    int f(int i, int j, vector<vector<int>> &matrix, vector<vector<int>> &dp){\\n        \\n\\t\\t//to handle edge cases if the j index is less than 0 or greater than size of the array.\\n        if(j<0 or j>=matrix[0].size()) return 1e8;\\n\\t\\t\\n\\t\\t//base case\\n        if(i==0) return dp[0][j] = matrix[0][j];\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        int up = matrix[i][j] + f(i-1, j, matrix, dp);\\n        \\n        int l = matrix[i][j] + f(i-1, j-1, matrix, dp);\\n        \\n        int r = matrix[i][j] + f(i-1, j+1, matrix, dp);\\n        \\n        return dp[i][j] = min(up, min(l, r));\\n        \\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        \\n        int mini = INT_MAX;\\n        int n = matrix.size();\\n        \\n        vector<vector<int>> dp(n, vector<int>(n,-1));\\n        \\n        for(int j=0;j<n;j++){\\n            \\n            mini = min(mini, f(n-1, j, matrix, dp));\\n            \\n        }\\n        \\n        return mini;\\n        \\n    }\\n};\\n```\\n\\n\\t\\t\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n    int f(int i, int j, vector<vector<int>> &matrix){\\n        \\n\\t\\t//base case\\n        if(i==0) return matrix[0][j];\\n\\t\\t\\n        //to handle edge cases if the j index is less than 0 or greater than size of the array.\\n        if(i<0 or i>=matrix.size[0]) return 1e8;\\n        \\n        int up = matrix[i][j] + f(i, j-1, matrix);\\n        \\n        int l = matrix[i][j] +  f(i-1, j-1, matrix);\\n        \\n        int r = matrix[i][j] +  f(i+1, j-1, matrix);\\n        \\n        return min(up, min(l, r));\\n        \\n\\t\\t}\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int f(int i, int j, vector<vector<int>> &matrix, vector<vector<int>> &dp){\\n        \\n\\t\\t//to handle edge cases if the j index is less than 0 or greater than size of the array.\\n        if(j<0 or j>=matrix[0].size()) return 1e8;\\n\\t\\t\\n\\t\\t//base case\\n        if(i==0) return dp[0][j] = matrix[0][j];\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        int up = matrix[i][j] + f(i-1, j, matrix, dp);\\n        \\n        int l = matrix[i][j] + f(i-1, j-1, matrix, dp);\\n        \\n        int r = matrix[i][j] + f(i-1, j+1, matrix, dp);\\n        \\n        return dp[i][j] = min(up, min(l, r));\\n        \\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        \\n        int mini = INT_MAX;\\n        int n = matrix.size();\\n        \\n        vector<vector<int>> dp(n, vector<int>(n,-1));\\n        \\n        for(int j=0;j<n;j++){\\n            \\n            mini = min(mini, f(n-1, j, matrix, dp));\\n            \\n        }\\n        \\n        return mini;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2342268,
                "title": "doubt-regarding-the-need-to-fetch-the-column-size",
                "content": "**As given the matrix is nxn i had only fetch the row size to make all the necessary conditions but it was giving runtime error but when i had written the second code i just used column size and it was running fine so it is necessary to fetch column size??????**\\n```\\nint helper(int i , int j , int n , vector<vector<int>>&m , vector<vector<int>>&dp)\\n   {\\n      if(i == n)\\n      {\\n        return m[i][j];\\n      }\\n      if(dp[i][j]!=-1)\\n      {\\n        return dp[i][j];\\n      }\\n      if(j>n || j<0)\\n      {\\n        return 1e9;\\n      }\\n    //down\\n     int down = m[i][j]+ helper(i+1 , j , n , m, dp);\\n      //lef dig\\n      int left = m[i][j] + helper(i+1 , j-1 , n , m ,dp);\\n      //right dig\\n      int right = m[i][j] + helper(i+1,j+1 , n , m ,dp);\\n\\n      return dp[i][j] = min(down, min( left , right));\\n   }\\n \\n int minFallingPathSum(vector<vector<int>>& matrix) {\\n    int n = matrix.size();\\n    int mini = 1e9;\\n   vector<vector<int>>dp(n+1 , vector<int>(n+1 , -1));\\n    for(int i = 0 ; i < n ; i++)\\n    {\\n        mini = min(mini , helper(0 , i ,n, matrix , dp));\\n    }\\n     \\n    return mini;\\n    }\\n```\\n**Plzz reply me where i am wrong**\\n```\\nclass Solution {\\npublic:\\n    int helper(int i , int j , int n ,int x, vector<vector<int>>&m , vector<vector<int>>&dp)\\n   {\\n      \\n      if(j>n-1 || j<0)\\n      {\\n        return 1e9;\\n      }\\n        \\n        if(dp[i][j]!=-1)\\n      {\\n        return dp[i][j];\\n      }\\n        \\n      if(i == n-1)\\n      {\\n        return m[i][j];\\n      }\\n    //down\\n     int down = m[i][j]+ helper(i+1 , j , n ,x, m, dp);\\n      //lef dig\\n      int left = m[i][j] + helper(i+1 , j-1 , n,x , m ,dp);\\n      //right dig\\n      int right = m[i][j] + helper(i+1,j+1 , n,x , m ,dp);\\n\\n      return dp[i][j] = min(down, min(left , right));\\n   }\\n \\n int minFallingPathSum(vector<vector<int>>& matrix) {\\n    int n = matrix.size();\\n     int m = matrix[0].size();\\n    int mini = 1e9;\\n   vector<vector<int>>dp(n+1 , vector<int>(m+1 , -1));\\n    for(int i = 0 ; i < m ; i++)\\n    {\\n        mini = min(mini , helper(0 , i ,n,m ,  matrix , dp));\\n    }\\n     \\n     return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nint helper(int i , int j , int n , vector<vector<int>>&m , vector<vector<int>>&dp)\\n   {\\n      if(i == n)\\n      {\\n        return m[i][j];\\n      }\\n      if(dp[i][j]!=-1)\\n      {\\n        return dp[i][j];\\n      }\\n      if(j>n || j<0)\\n      {\\n        return 1e9;\\n      }\\n    //down\\n     int down = m[i][j]+ helper(i+1 , j , n , m, dp);\\n      //lef dig\\n      int left = m[i][j] + helper(i+1 , j-1 , n , m ,dp);\\n      //right dig\\n      int right = m[i][j] + helper(i+1,j+1 , n , m ,dp);\\n\\n      return dp[i][j] = min(down, min( left , right));\\n   }\\n \\n int minFallingPathSum(vector<vector<int>>& matrix) {\\n    int n = matrix.size();\\n    int mini = 1e9;\\n   vector<vector<int>>dp(n+1 , vector<int>(n+1 , -1));\\n    for(int i = 0 ; i < n ; i++)\\n    {\\n        mini = min(mini , helper(0 , i ,n, matrix , dp));\\n    }\\n     \\n    return mini;\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    int helper(int i , int j , int n ,int x, vector<vector<int>>&m , vector<vector<int>>&dp)\\n   {\\n      \\n      if(j>n-1 || j<0)\\n      {\\n        return 1e9;\\n      }\\n        \\n        if(dp[i][j]!=-1)\\n      {\\n        return dp[i][j];\\n      }\\n        \\n      if(i == n-1)\\n      {\\n        return m[i][j];\\n      }\\n    //down\\n     int down = m[i][j]+ helper(i+1 , j , n ,x, m, dp);\\n      //lef dig\\n      int left = m[i][j] + helper(i+1 , j-1 , n,x , m ,dp);\\n      //right dig\\n      int right = m[i][j] + helper(i+1,j+1 , n,x , m ,dp);\\n\\n      return dp[i][j] = min(down, min(left , right));\\n   }\\n \\n int minFallingPathSum(vector<vector<int>>& matrix) {\\n    int n = matrix.size();\\n     int m = matrix[0].size();\\n    int mini = 1e9;\\n   vector<vector<int>>dp(n+1 , vector<int>(m+1 , -1));\\n    for(int i = 0 ; i < m ; i++)\\n    {\\n        mini = min(mini , helper(0 , i ,n,m ,  matrix , dp));\\n    }\\n     \\n     return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2330904,
                "title": "c-dp-memorization-easy-code",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        vector<vector<int>> dp(matrix.size(),vector<int>(matrix.size(),INT_MAX));\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            fun(matrix,dp,0,i);\\n        }\\n        int res=INT_MAX;\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            res=min(res,dp[0][i]);\\n        }\\n        return res;\\n    }\\n    int fun(vector<vector<int>>& v,vector<vector<int>>& dp,int i,int j)\\n    {\\n        if(i<0 || j<0 || i>=v.size() || j>=v.size())\\n            return INT_MAX;\\n        \\n        if(i==v.size()-1)\\n            return dp[i][j]=v[i][j];\\n        \\n        if(dp[i][j]!=INT_MAX)\\n            return dp[i][j];\\n        \\n        int t=INT_MAX;\\n        t=min(t,fun(v,dp,i+1,j-1));\\n        t=min(t,fun(v,dp,i+1,j));\\n        t=min(t,fun(v,dp,i+1,j+1));\\n        \\n        return dp[i][j]=t+v[i][j];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        vector<vector<int>> dp(matrix.size(),vector<int>(matrix.size(),INT_MAX));\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            fun(matrix,dp,0,i);\\n        }\\n        int res=INT_MAX;\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            res=min(res,dp[0][i]);\\n        }\\n        return res;\\n    }\\n    int fun(vector<vector<int>>& v,vector<vector<int>>& dp,int i,int j)\\n    {\\n        if(i<0 || j<0 || i>=v.size() || j>=v.size())\\n            return INT_MAX;\\n        \\n        if(i==v.size()-1)\\n            return dp[i][j]=v[i][j];\\n        \\n        if(dp[i][j]!=INT_MAX)\\n            return dp[i][j];\\n        \\n        int t=INT_MAX;\\n        t=min(t,fun(v,dp,i+1,j-1));\\n        t=min(t,fun(v,dp,i+1,j));\\n        t=min(t,fun(v,dp,i+1,j+1));\\n        \\n        return dp[i][j]=t+v[i][j];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2326483,
                "title": "java-recursion-space-optimized-dp",
                "content": "```\\npublic int minFallingPathSum(int[][] matrix) {\\n\\t\\treturn spaceOptimization(matrix);\\n\\t}\\n\\n\\t// n = matrix.length -1; i = matrix.length-1; j = 0..matrix.length-1;\\n\\tprivate int recursion(int[][] arr, int i, int j, int n) {\\n\\t\\tif (i == 0)\\n\\t\\t\\treturn arr[i][j];\\n\\n\\t\\tint left = Integer.MAX_VALUE, right = Integer.MAX_VALUE;\\n\\t\\tif (j > 0) {\\n\\t\\t\\tleft = recursion(arr, i - 1, j - 1, n);\\n\\t\\t}\\n\\t\\tint curr = recursion(arr, i - 1, j, n);\\n\\t\\tif (j < n) {\\n\\t\\t\\tright = recursion(arr, i - 1, j + 1, n);\\n\\t\\t}\\n\\n\\t\\tint min = Math.min(left, Math.min(curr, right));\\n\\t\\treturn arr[i][j] + min;\\n\\t}\\n\\n\\t// dp = new int[n+1][n+1] where dp[i][j] = Integer.MIN_VALUE;\\n\\tprivate int memoization(int[][] arr, int i, int j, int n, int[][] dp) {\\n\\t\\tif (i == 0)\\n\\t\\t\\treturn arr[i][j];\\n\\n\\t\\tif (dp[i][j] != Integer.MIN_VALUE)\\n\\t\\t\\treturn dp[i][j];\\n\\n\\t\\tint left = Integer.MAX_VALUE, right = Integer.MAX_VALUE;\\n\\t\\tif (j > 0) {\\n\\t\\t\\tleft = memoization(arr, i - 1, j - 1, n, dp);\\n\\t\\t}\\n\\t\\tint curr = memoization(arr, i - 1, j, n, dp);\\n\\t\\tif (j < n) {\\n\\t\\t\\tright = memoization(arr, i - 1, j + 1, n, dp);\\n\\t\\t}\\n\\n\\t\\tint min = Math.min(left, Math.min(curr, right));\\n\\t\\treturn dp[i][j] = arr[i][j] + min;\\n\\t}\\n\\n\\tprivate int tabulation(int[][] arr) {\\n\\t\\tint n = arr.length;\\n\\t\\tint[][] dp = new int[n][n];\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tdp[0][i] = arr[0][i];\\n\\t\\t}\\n\\n\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\tint left = Integer.MAX_VALUE, right = Integer.MAX_VALUE;\\n\\t\\t\\t\\tif (j > 0)\\n\\t\\t\\t\\t\\tleft = dp[i - 1][j - 1];\\n\\t\\t\\t\\tif (j < n - 1)\\n\\t\\t\\t\\t\\tright = dp[i - 1][j + 1];\\n\\t\\t\\t\\tint curr = dp[i - 1][j];\\n\\t\\t\\t\\tint min = Math.min(Math.min(left, right), curr);\\n\\t\\t\\t\\tdp[i][j] = arr[i][j] + min;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint min = Integer.MAX_VALUE;\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tint temp = dp[n - 1][i];\\n\\t\\t\\tmin = Math.min(min, temp);\\n\\t\\t}\\n\\n\\t\\treturn min;\\n\\t}\\n\\n\\tprivate int spaceOptimization(int[][] arr) {\\n\\t\\tint n = arr.length;\\n\\t\\tint[] so = new int[n];\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tso[i] = arr[0][i];\\n\\t\\t}\\n\\n\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\tint[] temp = new int[n];\\n\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\tint left = Integer.MAX_VALUE, right = Integer.MAX_VALUE;\\n\\t\\t\\t\\tif (j > 0)\\n\\t\\t\\t\\t\\tleft = so[j - 1];\\n\\t\\t\\t\\tif (j < n - 1)\\n\\t\\t\\t\\t\\tright = so[j + 1];\\n\\t\\t\\t\\tint curr = so[j];\\n\\t\\t\\t\\tint min = Math.min(Math.min(left, right), curr);\\n\\t\\t\\t\\ttemp[j] = arr[i][j] + min;\\n\\t\\t\\t}\\n\\t\\t\\tso = temp;\\n\\t\\t}\\n\\t\\tint min = Integer.MAX_VALUE;\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tint temp = so[i];\\n\\t\\t\\tmin = Math.min(min, temp);\\n\\t\\t}\\n\\n\\t\\treturn min;\\n\\t}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\npublic int minFallingPathSum(int[][] matrix) {\\n\\t\\treturn spaceOptimization(matrix);\\n\\t}\\n\\n\\t// n = matrix.length -1; i = matrix.length-1; j = 0..matrix.length-1;\\n\\tprivate int recursion(int[][] arr, int i, int j, int n) {\\n\\t\\tif (i == 0)\\n\\t\\t\\treturn arr[i][j];\\n\\n\\t\\tint left = Integer.MAX_VALUE, right = Integer.MAX_VALUE;\\n\\t\\tif (j > 0) {\\n\\t\\t\\tleft = recursion(arr, i - 1, j - 1, n);\\n\\t\\t}\\n\\t\\tint curr = recursion(arr, i - 1, j, n);\\n\\t\\tif (j < n) {\\n\\t\\t\\tright = recursion(arr, i - 1, j + 1, n);\\n\\t\\t}\\n\\n\\t\\tint min = Math.min(left, Math.min(curr, right));\\n\\t\\treturn arr[i][j] + min;\\n\\t}\\n\\n\\t// dp = new int[n+1][n+1] where dp[i][j] = Integer.MIN_VALUE;\\n\\tprivate int memoization(int[][] arr, int i, int j, int n, int[][] dp) {\\n\\t\\tif (i == 0)\\n\\t\\t\\treturn arr[i][j];\\n\\n\\t\\tif (dp[i][j] != Integer.MIN_VALUE)\\n\\t\\t\\treturn dp[i][j];\\n\\n\\t\\tint left = Integer.MAX_VALUE, right = Integer.MAX_VALUE;\\n\\t\\tif (j > 0) {\\n\\t\\t\\tleft = memoization(arr, i - 1, j - 1, n, dp);\\n\\t\\t}\\n\\t\\tint curr = memoization(arr, i - 1, j, n, dp);\\n\\t\\tif (j < n) {\\n\\t\\t\\tright = memoization(arr, i - 1, j + 1, n, dp);\\n\\t\\t}\\n\\n\\t\\tint min = Math.min(left, Math.min(curr, right));\\n\\t\\treturn dp[i][j] = arr[i][j] + min;\\n\\t}\\n\\n\\tprivate int tabulation(int[][] arr) {\\n\\t\\tint n = arr.length;\\n\\t\\tint[][] dp = new int[n][n];\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tdp[0][i] = arr[0][i];\\n\\t\\t}\\n\\n\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\tint left = Integer.MAX_VALUE, right = Integer.MAX_VALUE;\\n\\t\\t\\t\\tif (j > 0)\\n\\t\\t\\t\\t\\tleft = dp[i - 1][j - 1];\\n\\t\\t\\t\\tif (j < n - 1)\\n\\t\\t\\t\\t\\tright = dp[i - 1][j + 1];\\n\\t\\t\\t\\tint curr = dp[i - 1][j];\\n\\t\\t\\t\\tint min = Math.min(Math.min(left, right), curr);\\n\\t\\t\\t\\tdp[i][j] = arr[i][j] + min;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint min = Integer.MAX_VALUE;\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tint temp = dp[n - 1][i];\\n\\t\\t\\tmin = Math.min(min, temp);\\n\\t\\t}\\n\\n\\t\\treturn min;\\n\\t}\\n\\n\\tprivate int spaceOptimization(int[][] arr) {\\n\\t\\tint n = arr.length;\\n\\t\\tint[] so = new int[n];\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tso[i] = arr[0][i];\\n\\t\\t}\\n\\n\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\tint[] temp = new int[n];\\n\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\tint left = Integer.MAX_VALUE, right = Integer.MAX_VALUE;\\n\\t\\t\\t\\tif (j > 0)\\n\\t\\t\\t\\t\\tleft = so[j - 1];\\n\\t\\t\\t\\tif (j < n - 1)\\n\\t\\t\\t\\t\\tright = so[j + 1];\\n\\t\\t\\t\\tint curr = so[j];\\n\\t\\t\\t\\tint min = Math.min(Math.min(left, right), curr);\\n\\t\\t\\t\\ttemp[j] = arr[i][j] + min;\\n\\t\\t\\t}\\n\\t\\t\\tso = temp;\\n\\t\\t}\\n\\t\\tint min = Integer.MAX_VALUE;\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tint temp = so[i];\\n\\t\\t\\tmin = Math.min(min, temp);\\n\\t\\t}\\n\\n\\t\\treturn min;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2307654,
                "title": "recursion-memoization",
                "content": "For those who directly decide to write tabulation form, first strong your recursion part , then memoize it . This memoization solution also get submitted so does tabulation. \\n```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    \\n    int solve(int i , int j ,vector<vector<int>>& matrix)\\n    {\\n        int n = matrix.size();\\n        \\n        if(i >=n || j >=n || i < 0  || j<0)\\n            return 1e7;\\n        \\n        if(i == n-1)\\n            return matrix[i][j];\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        int ans = INT_MAX;\\n        \\n        \\n        \\n            int down = matrix[i][j] + solve(i+1,j,matrix);\\n            int right_d = matrix[i][j] + solve(i+1,j+1,matrix);\\n            int left_d  = matrix[i][j] + solve(i+1,j-1,matrix);\\n            \\n            // int sum = matrix[i][j] + solve(i+1,j+k,matrix);\\n            \\n           ans = min({down,right_d,left_d});\\n        \\n        \\n        return dp[i][j] = ans;\\n    }\\n    \\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) \\n    {\\n        int ans= INT_MAX;\\n        int n = matrix.size();\\n        \\n        memset(dp,-1,sizeof(dp));\\n        \\n        for(int i = 0 ; i< n ; i++)\\n        {\\n            \\n            ans = min(ans, solve(0,i,matrix));\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```\\nI still find tabulation initialization tricky but there is always scope for improvement.\\n![image](https://assets.leetcode.com/users/images/7ddaa016-c5a0-4b08-a795-653648d0a05e_1658302936.3702855.png)\\n",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    \\n    int solve(int i , int j ,vector<vector<int>>& matrix)\\n    {\\n        int n = matrix.size();\\n        \\n        if(i >=n || j >=n || i < 0  || j<0)\\n            return 1e7;\\n        \\n        if(i == n-1)\\n            return matrix[i][j];\\n        \\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        int ans = INT_MAX;\\n        \\n        \\n        \\n            int down = matrix[i][j] + solve(i+1,j,matrix);\\n            int right_d = matrix[i][j] + solve(i+1,j+1,matrix);\\n            int left_d  = matrix[i][j] + solve(i+1,j-1,matrix);\\n            \\n            // int sum = matrix[i][j] + solve(i+1,j+k,matrix);\\n            \\n           ans = min({down,right_d,left_d});\\n        \\n        \\n        return dp[i][j] = ans;\\n    }\\n    \\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) \\n    {\\n        int ans= INT_MAX;\\n        int n = matrix.size();\\n        \\n        memset(dp,-1,sizeof(dp));\\n        \\n        for(int i = 0 ; i< n ; i++)\\n        {\\n            \\n            ans = min(ans, solve(0,i,matrix));\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2295938,
                "title": "recursion-memoization-java",
                "content": "Recursive Approach,(It will give TLE but gives the base to memoize the solution)-:\\n\\nclass Solution {\\n\\n    public int func(int i,int j,int arr[][],int n){\\n       //base condition-1\\n        if(i==0 && j>=0 && j<=n){\\n            return arr[i][j];\\n        }\\n\\t\\t//base condition-2\\n        if(i<0 || j<0 || j>n){\\n            return 10000007;\\n        }\\n        \\n        int up=arr[i][j]+func(i-1,j,arr,n);\\n        \\n        int ld=arr[i][j]+func(i-1,j-1,arr,n);\\n        \\n        int rd=arr[i][j]+func(i-1,j+1,arr,n);\\n        \\n        return Math.min(up,Math.min(ld,rd));\\n    }\\n    public int minFallingPathSum(int[][] matrix) {\\n        int n=matrix.length-1;\\n       \\n        int ans=Integer.MAX_VALUE;\\n\\t\\t//for the top down approach start from the last row of matrix and try for every column \\n\\t\\t//every column of last row whichever gives the result\\n        for(int i=n;i>=0;i--){\\n            \\n            int t=func(n,i,matrix,n);\\n            ans=Math.min(ans,t);\\n        }\\n        return ans;\\n    }\\n}\\n////////////////////////////////////////////////////////////////////////////////////////////////\\nMemoised Solution (Same as recursive solution but just three changes)\\n1. Create a 2d DP array\\n2. instead of returning store result in dp\\n3. Check one if condition if dp already have answer thats it\\nSolution is Faster then 94%\\n\\nclass Solution {\\n\\n    public int func(int i,int j,int arr[][],int n,int [][]dp){\\n       \\n        if(i==0 && j>=0 && j<=n){\\n            return arr[i][j];\\n        }\\n        if(i<0 || j<0 || j>n){\\n            return 10000007;\\n        }\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        int up=arr[i][j]+func(i-1,j,arr,n,dp);\\n        \\n        int ld=arr[i][j]+func(i-1,j-1,arr,n,dp);\\n        \\n        int rd=arr[i][j]+func(i-1,j+1,arr,n,dp);\\n        \\n        return dp[i][j]=Math.min(up,Math.min(ld,rd));\\n    }\\n    public int minFallingPathSum(int[][] matrix) {\\n        int n=matrix.length-1;\\n        int dp[][]=new int[n+1][n+1];\\n        for(int row[]:dp){\\n            Arrays.fill(row,-1);\\n        }\\n        \\n        int ans=Integer.MAX_VALUE;\\n        for(int i=n;i>=0;i--){\\n            \\n            int t=func(n,i,matrix,n,dp);\\n            ans=Math.min(ans,t);\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int func(int i,int j,int arr[][],int n){\\n       //base condition-1\\n        if(i==0 && j>=0 && j<=n){\\n            return arr[i][j];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2207857,
                "title": "easy-to-understand-4-solutions-from-brute-force-to-dp",
                "content": "// RECURSION\\n\\nclass Solution {\\npublic:\\n    \\n    int f(int i,int j,vector<vector<int>>& matrix){\\n        \\n        if(j<0 || j>=matrix[0].size())   // boundary conditions\\n           return 1e8;\\n        if(i==0)\\n           return matrix[0][j];\\n        int u = matrix[i][j] + f(i-1, j ,matrix);     // for up movement\\n        int ld = matrix[i][j] + f(i-1, j-1, matrix);  // for left side movement (up then left)\\n        int rd = matrix[i][j] + f(i-1, j+1, matrix);  // for right side movement (up then right)\\n        \\n        return min(u ,min(ld,rd));\\n    \\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        \\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        \\n        int mini = 1e8;\\n        for(int j = 0; j<m; j++){\\n             mini = min(mini, f(n-1, j , matrix));\\n        }\\n           \\n        \\n        return mini;\\n    }\\n};\\n\\n\\n// Memoization \\n\\nclass Solution {\\npublic:\\n    \\n    int f(int i,int j,vector<vector<int>>& matrix ,  vector<vector<int>> &dp){\\n        \\n        if(j<0 || j>=matrix[0].size()   )   // boundary conditions\\n            return 1e8;\\n        if(i==0)\\n            return matrix[0][j];\\n        \\n        if(dp[i][j] != -1)             //* here we have done some change for memo\\n            return dp[i][j];\\n        \\n        int u = matrix[i][j] + f(i-1, j ,matrix ,dp);     // for up movement\\n        int ld = matrix[i][j] + f(i-1, j-1, matrix, dp);  // for left side movement (up then left)\\n        int rd = matrix[i][j] + f(i-1, j+1, matrix ,dp);  // for right side movement (up then right)\\n        \\n        return dp[i][j] = min(u ,min(ld,rd));      //* here we have done some change for memo\\n     \\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        \\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>> dp(n, vector<int>(m,-1));   //* here we have done some change for memo\\n        int mini = 1e8;\\n        for(int j = 0; j<m; j++){\\n             mini = min(mini, f(n-1, j , matrix , dp));\\n        }    \\n        return mini;\\n    }\\n};\\n\\n\\n// TABULATION \\n\\nclass Solution {\\npublic:\\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        \\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        \\n        vector<vector<int>> dp(n, vector<int>(m,-1));   //* here we have done some change for memo\\n        \\n         for(int j=0;j<m;j++){\\n            dp[0][j]=matrix[0][j];  \\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int ld=1e9,rd=1e9;\\n                \\n                int up=matrix[i][j] + dp[i-1][j];     // for up movement\\n                \\n                if(j-1>=0)\\n                    ld=matrix[i][j] + dp[i-1][j-1];   // for left side movement (up then left)\\n                if(j+1<m)\\n                    rd=matrix[i][j] + dp[i-1][j+1];   // for right side movement (up then right)\\n                \\n                dp[i][j] = min(up,min(ld,rd));\\n \\n            }\\n        }\\n        int mini=dp[n-1][0];\\n        \\n        for(int j=0;j<m;j++){\\n            mini=min(mini,dp[n-1][j]);  \\n        }\\n        return mini; \\n    }\\n        \\n};\\n\\n\\n// space optimization \\n\\nclass Solution {\\npublic:\\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        \\n        vector<int>cur(m,0) , prev(m,0);\\n        \\n        for(int j=0;j<m;j++){\\n            prev[j]=matrix[0][j]; \\n        }\\n\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int ld=1e9,rd=1e9;\\n\\n                int up=matrix[i][j] + prev[j];\\n                \\n                if(j-1>=0)\\n                    ld=matrix[i][j] + prev[j-1];\\n                if(j+1<m)\\n                    rd=matrix[i][j] + prev[j+1];\\n                \\n                cur[j] = min(up,min(ld,rd));\\n            }\\n            prev=cur;\\n        }\\n        int mini=prev[0];\\n        \\n        for(int j=1;j<m;j++){ \\n            mini=min(mini,prev[j]);\\n        }\\n        return mini;   \\n    }\\n};\\n\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int f(int i,int j,vector<vector<int>>& matrix){\\n        \\n        if(j<0 || j>=matrix[0].size())   // boundary conditions\\n           return 1e8;\\n        if(i==0)\\n           return matrix[0][j];\\n        int u = matrix[i][j] + f(i-1, j ,matrix);     // for up movement\\n        int ld = matrix[i][j] + f(i-1, j-1, matrix);  // for left side movement (up then left)\\n        int rd = matrix[i][j] + f(i-1, j+1, matrix);  // for right side movement (up then right)\\n        \\n        return min(u ,min(ld,rd));\\n    \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2180335,
                "title": "easy-dp-solution",
                "content": "```\\nint n=m.size();\\n        int dp[n+1][n+1];\\n        for(int i=0;i<m[0].size();i++){\\n            dp[0][i]=m[0][i];\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(j==0){\\n                    dp[i][j]=m[i][j]+min(dp[i-1][j],dp[i-1][j+1]);\\n                }\\n                else if(j==n-1){\\n                    dp[i][j]=m[i][j]+min(dp[i-1][j],dp[i-1][j-1]);\\n                }\\n                else{\\n                    dp[i][j]=m[i][j]+min(dp[i-1][j],min(dp[i-1][j+1],dp[i-1][j-1]));\\n                }\\n            }\\n        }\\n        int min1=INT_MAX;\\n        for(int j=0;j<n;j++){\\n            min1=min(min1,dp[n-1][j]);\\n        }\\n        return min1;\\n```\\n**please upvote**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint n=m.size();\\n        int dp[n+1][n+1];\\n        for(int i=0;i<m[0].size();i++){\\n            dp[0][i]=m[0][i];\\n        }\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(j==0){\\n                    dp[i][j]=m[i][j]+min(dp[i-1][j],dp[i-1][j+1]);\\n                }\\n                else if(j==n-1){\\n                    dp[i][j]=m[i][j]+min(dp[i-1][j],dp[i-1][j-1]);\\n                }\\n                else{\\n                    dp[i][j]=m[i][j]+min(dp[i-1][j],min(dp[i-1][j+1],dp[i-1][j-1]));\\n                }\\n            }\\n        }\\n        int min1=INT_MAX;\\n        for(int j=0;j<n;j++){\\n            min1=min(min1,dp[n-1][j]);\\n        }\\n        return min1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2113644,
                "title": "java-recursive-memoized-tabulated-solution",
                "content": "**Iterative DFS (RECURSIVE APPROACH) TLE**\\n\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        \\n        int ans = Integer.MAX_VALUE;\\n        for(int i=0;i<matrix.length;i++){\\n            ans = Math.min(ans,minPath(0,i,matrix));\\n        }\\n        return ans;\\n    }\\n    private int minPath(int i,int j,int[][] arr){\\n        if(i==arr.length-1)\\n            return arr[i][j];\\n        int left = Integer.MAX_VALUE;\\n        int bottom = Integer.MAX_VALUE; \\n        int right = Integer.MAX_VALUE; \\n        if(j>0) left = arr[i][j]+ minPath(i+1,j-1,arr);\\n        bottom = arr[i][j] + minPath(i+1,j,arr);\\n        if(j<arr.length-1) right = arr[i][j] + minPath(i+1,j+1,arr);\\n        return Math.min(right,Math.min(left,bottom));\\n    }\\n}\\n```\\n\\n**Memoization**\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        int n = matrix.length;\\n        int[][] dp = new int[n][n];\\n        int ans = Integer.MAX_VALUE;\\n        for(int i=0;i<matrix.length;i++){\\n            ans = Math.min(ans,minPath(0,i,matrix,dp));\\n        }\\n        return ans;\\n    }\\n    private int minPath(int i,int j,int[][] arr,int[][] dp){\\n        if(i==arr.length-1)\\n            return arr[i][j];\\n        if(dp[i][j]!=0) return dp[i][j];\\n        int left = Integer.MAX_VALUE;\\n        int bottom = Integer.MAX_VALUE; \\n        int right = Integer.MAX_VALUE; \\n        if(j>0) left = arr[i][j]+ minPath(i+1,j-1,arr,dp);\\n        bottom = arr[i][j] + minPath(i+1,j,arr,dp);\\n        if(j<arr.length-1) right = arr[i][j] + minPath(i+1,j+1,arr,dp);\\n        return dp[i][j] = Math.min(right,Math.min(left,bottom));\\n    }\\n}\\n```\\n\\n**Tabulation**\\n\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        int n = matrix.length;\\n        int[][] dp = new int[n][n];\\n        return minPath(matrix,dp);\\n    }\\n    private int minPath(int[][] arr,int[][] dp){\\n        int n = arr.length;\\n        for(int k=0;k<n;k++){\\n            dp[n-1][k] = arr[n-1][k];\\n        }\\n        for(int k=n-2;k>=0;k--){\\n            for(int l=n-1;l>=0;l--){\\n            int left = Integer.MAX_VALUE;\\n            int bottom = Integer.MAX_VALUE; \\n            int right = Integer.MAX_VALUE; \\n            if(l>0)\\n                left = arr[k][l]+ dp[k+1][l-1];\\n                bottom = arr[k][l] + dp[k+1][l]; \\n            if(l<arr.length-1)    \\n                right = arr[k][l] + dp[k+1][l+1];\\n                dp[k][l] = Math.min(right,Math.min(left,bottom));        \\n            }\\n        }\\n        int ans = Integer.MAX_VALUE;\\n        for(int k=0;k<n;k++){\\n            ans = Math.min(ans,dp[0][k]);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        \\n        int ans = Integer.MAX_VALUE;\\n        for(int i=0;i<matrix.length;i++){\\n            ans = Math.min(ans,minPath(0,i,matrix));\\n        }\\n        return ans;\\n    }\\n    private int minPath(int i,int j,int[][] arr){\\n        if(i==arr.length-1)\\n            return arr[i][j];\\n        int left = Integer.MAX_VALUE;\\n        int bottom = Integer.MAX_VALUE; \\n        int right = Integer.MAX_VALUE; \\n        if(j>0) left = arr[i][j]+ minPath(i+1,j-1,arr);\\n        bottom = arr[i][j] + minPath(i+1,j,arr);\\n        if(j<arr.length-1) right = arr[i][j] + minPath(i+1,j+1,arr);\\n        return Math.min(right,Math.min(left,bottom));\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        int n = matrix.length;\\n        int[][] dp = new int[n][n];\\n        int ans = Integer.MAX_VALUE;\\n        for(int i=0;i<matrix.length;i++){\\n            ans = Math.min(ans,minPath(0,i,matrix,dp));\\n        }\\n        return ans;\\n    }\\n    private int minPath(int i,int j,int[][] arr,int[][] dp){\\n        if(i==arr.length-1)\\n            return arr[i][j];\\n        if(dp[i][j]!=0) return dp[i][j];\\n        int left = Integer.MAX_VALUE;\\n        int bottom = Integer.MAX_VALUE; \\n        int right = Integer.MAX_VALUE; \\n        if(j>0) left = arr[i][j]+ minPath(i+1,j-1,arr,dp);\\n        bottom = arr[i][j] + minPath(i+1,j,arr,dp);\\n        if(j<arr.length-1) right = arr[i][j] + minPath(i+1,j+1,arr,dp);\\n        return dp[i][j] = Math.min(right,Math.min(left,bottom));\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        int n = matrix.length;\\n        int[][] dp = new int[n][n];\\n        return minPath(matrix,dp);\\n    }\\n    private int minPath(int[][] arr,int[][] dp){\\n        int n = arr.length;\\n        for(int k=0;k<n;k++){\\n            dp[n-1][k] = arr[n-1][k];\\n        }\\n        for(int k=n-2;k>=0;k--){\\n            for(int l=n-1;l>=0;l--){\\n            int left = Integer.MAX_VALUE;\\n            int bottom = Integer.MAX_VALUE; \\n            int right = Integer.MAX_VALUE; \\n            if(l>0)\\n                left = arr[k][l]+ dp[k+1][l-1];\\n                bottom = arr[k][l] + dp[k+1][l]; \\n            if(l<arr.length-1)    \\n                right = arr[k][l] + dp[k+1][l+1];\\n                dp[k][l] = Math.min(right,Math.min(left,bottom));        \\n            }\\n        }\\n        int ans = Integer.MAX_VALUE;\\n        for(int k=0;k<n;k++){\\n            ans = Math.min(ans,dp[0][k]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2051512,
                "title": "c-recursion-memoization-dp-faster-than-97-c-submissions-space-optimized-dp",
                "content": "# Step by Step Optimized Solution\\n* Here we need to try out all possible paths to reach the destination from our starting point, hence we can use recursive approach to solve the problem.\\n* We need to keep in mind that neither the starting nor ending point is fixed in the given grid.\\n* We will try to evaluate the minimum path sum from each and every column from the last row to the first row.\\n\\n**Recursion Based Solution :**\\n\\n```\\nclass Solution {\\npublic:\\n    int helper(int i, int j, vector<vector<int>>& matrix){\\n        if(j<0 || j>=matrix[0].size())\\n            return 1e9;\\n        \\n        if(i==0)\\n            return matrix[0][j];\\n\\t\\t\\t\\n        int a = matrix[i][j] + helper(i-1,j,matrix);\\n        int b = matrix[i][j] + helper(i-1,j-1,matrix);\\n        int c = matrix[i][j] + helper(i-1,j+1,matrix);\\n        \\n        return min(a,min(b,c));\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n       \\n        int res=1e9;\\n        for(int k=0;k<m;k++){\\n          res=min(res,helper(n-1,k,matrix,dp))  ;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\n**T.C :** O(3^n) ; since for each element in the grid we have 3 choices, go up(i-1,j) , left upper                 diagonal(i-1,j-1) and right upper diagonal(i-1,j+1).\\n**S.C :** O(n); for recursion stack space\\n\\n* Now, here we would definitely have multiple overlapping subproblems. Hence we can use the Memoization technique to reduce the time complexity.\\n\\n**Memoization :**\\n\\n```\\nclass Solution {\\npublic:\\n    int helper(int i, int j, vector<vector<int>>& matrix){\\n        if(j<0 || j>=matrix[0].size())\\n            return 1e9;\\n        \\n        if(i==0)\\n            return matrix[0][j];\\n        \\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        int a = matrix[i][j] + helper(i-1,j,matrix,dp);\\n        int b = matrix[i][j] + helper(i-1,j-1,matrix,dp);\\n        int c = matrix[i][j] + helper(i-1,j+1,matrix,dp);\\n        \\n        return dp[i][j] = min(a,min(b,c));\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n\\t\\t\\n\\t\\tvector<vector<int>> dp(n,vector<int>(m,-1));\\n        \\n         int res=1e9;\\n         for(int k=0;k<m;k++){\\n           res=min(res,helper(n-1,k,matrix,dp))  ;\\n         }\\n                \\n        return res;\\n    }\\n};\\n```\\n\\n**T.C :** O(n * m)\\n**S.C :** O(n * m) + O(n) ; for dp matrix and recursion stack space respectively.\\n\\n\\n* Now, in order to reduce the recursion stack space, we would move forward to Tabulation based approach.\\n\\n**Tabulation :**\\n\\n```\\nclass Solution {\\npublic:\\n\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        \\n        vector<vector<int>> dp(n,vector<int>(m,-1));\\n        \\n        for(int j=0;j<m;j++)\\n            dp[0][j]=matrix[0][j];\\n        \\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){       \\n                int a = matrix[i][j] + dp[i-1][j];\\n                int b = matrix[i][j]; \\n                    if(j-1>=0)\\n                        b += dp[i-1][j-1];\\n                    else\\n                        b+= 1e9;\\n                int c = matrix[i][j]; \\n                    if(j+1<m)\\n                        c+= dp[i-1][j+1];\\n                    else\\n                        c+= 1e9;\\n                \\n                dp[i][j] = min(a,min(b,c));\\n            }\\n        }\\n\\n        int res = 1e9;\\n        \\n        for(int k=0;k<m;k++)\\n            res = min(res,dp[n-1][k]);\\n        \\n        return res;\\n    }\\n};\\n```\\n\\n**T.C :** O(n * m) + O(n) \\n**S.C :** O(n * m)\\n\\n* Now, we carefully notice, we will see that, we only need the pervious row values , hence instead of a 2D matrix we can store the previous values in a 1D array only.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n                \\n        vector<int> prev(m,0) , curr(m,0);\\n        \\n        for(int j=0;j<m;j++)\\n            prev[j] = matrix[0][j];\\n        \\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){       \\n                int a = matrix[i][j] + prev[j];\\n                int b = matrix[i][j]; \\n                    if(j-1>=0)\\n                        b+=prev[j-1];\\n                    else\\n                        b+= 1e9;\\n                int c = matrix[i][j]; \\n                    if(j+1<m)\\n                        c+=prev[j+1];\\n                    else\\n                        c+= 1e9;\\n                \\n                curr[j] = min(a,min(b,c));\\n            }\\n            prev=curr;\\n        }\\n                \\n        int res = 1e9;\\n        \\n        for(int k=0;k<m;k++)\\n            res = min(res, prev[k]);\\n        \\n        return res;\\n    }\\n};\\n```\\n\\n**T.C :** O(n * m)\\n**S.C :** O(m)\\n\\n**The Final Solution is faster than 97% of C++ submissions.**\\n\\n**KIndly upvote if you like it ! :)**\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(int i, int j, vector<vector<int>>& matrix){\\n        if(j<0 || j>=matrix[0].size())\\n            return 1e9;\\n        \\n        if(i==0)\\n            return matrix[0][j];\\n\\t\\t\\t\\n        int a = matrix[i][j] + helper(i-1,j,matrix);\\n        int b = matrix[i][j] + helper(i-1,j-1,matrix);\\n        int c = matrix[i][j] + helper(i-1,j+1,matrix);\\n        \\n        return min(a,min(b,c));\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n       \\n        int res=1e9;\\n        for(int k=0;k<m;k++){\\n          res=min(res,helper(n-1,k,matrix,dp))  ;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int helper(int i, int j, vector<vector<int>>& matrix){\\n        if(j<0 || j>=matrix[0].size())\\n            return 1e9;\\n        \\n        if(i==0)\\n            return matrix[0][j];\\n        \\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        int a = matrix[i][j] + helper(i-1,j,matrix,dp);\\n        int b = matrix[i][j] + helper(i-1,j-1,matrix,dp);\\n        int c = matrix[i][j] + helper(i-1,j+1,matrix,dp);\\n        \\n        return dp[i][j] = min(a,min(b,c));\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n\\t\\t\\n\\t\\tvector<vector<int>> dp(n,vector<int>(m,-1));\\n        \\n         int res=1e9;\\n         for(int k=0;k<m;k++){\\n           res=min(res,helper(n-1,k,matrix,dp))  ;\\n         }\\n                \\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        \\n        vector<vector<int>> dp(n,vector<int>(m,-1));\\n        \\n        for(int j=0;j<m;j++)\\n            dp[0][j]=matrix[0][j];\\n        \\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){       \\n                int a = matrix[i][j] + dp[i-1][j];\\n                int b = matrix[i][j]; \\n                    if(j-1>=0)\\n                        b += dp[i-1][j-1];\\n                    else\\n                        b+= 1e9;\\n                int c = matrix[i][j]; \\n                    if(j+1<m)\\n                        c+= dp[i-1][j+1];\\n                    else\\n                        c+= 1e9;\\n                \\n                dp[i][j] = min(a,min(b,c));\\n            }\\n        }\\n\\n        int res = 1e9;\\n        \\n        for(int k=0;k<m;k++)\\n            res = min(res,dp[n-1][k]);\\n        \\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n                \\n        vector<int> prev(m,0) , curr(m,0);\\n        \\n        for(int j=0;j<m;j++)\\n            prev[j] = matrix[0][j];\\n        \\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<m;j++){       \\n                int a = matrix[i][j] + prev[j];\\n                int b = matrix[i][j]; \\n                    if(j-1>=0)\\n                        b+=prev[j-1];\\n                    else\\n                        b+= 1e9;\\n                int c = matrix[i][j]; \\n                    if(j+1<m)\\n                        c+=prev[j+1];\\n                    else\\n                        c+= 1e9;\\n                \\n                curr[j] = min(a,min(b,c));\\n            }\\n            prev=curr;\\n        }\\n                \\n        int res = 1e9;\\n        \\n        for(int k=0;k<m;k++)\\n            res = min(res, prev[k]);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1923900,
                "title": "4-lines-easy-solution-explained",
                "content": "```\\nThe minimum path to get to element A[i][j] is the minimum of A[i - 1][j - 1], A[i - 1][j] and A[i - 1][j + 1].\\nStarting from row 1, we add the minumum path to each element. The smallest number in the last row is the miminum path sum.\\nExample:\\n[1, 2, 3]\\n[4, 5, 6] => [5, 6, 8]\\n[7, 8, 9] => [7, 8, 9] => [12, 13, 15]\\n\\nC++\\n\\nint minFallingPathSum(vector<vector<int>>& A) {\\n  for (auto i = 1; i < A.size(); ++i)\\n    for (auto j = 0; j < A.size(); ++j)\\n      A[i][j] += min({ A[i-1][j], A[i-1][max(0,j-1)], A[i-1][min((int)A.size()-1,j+1)] });\\n  return *min_element(begin(A[A.size() - 1]), end(A[A.size() - 1]));\\n}\\nJava\\n\\npublic int minFallingPathSum(int[][] A) {\\n  for (int i = 1; i < A.length; ++i)\\n    for (int j = 0; j < A.length; ++j)\\n      A[i][j] += Math.min(A[i - 1][j], Math.min(A[i - 1][Math.max(0, j - 1)], A[i - 1][Math.min(A.length - 1, j + 1)]));\\n  return Arrays.stream(A[A.length - 1]).min().getAsInt();\\n}       \\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Go",
                    "PHP"
                ],
                "code": "```\\nThe minimum path to get to element A[i][j] is the minimum of A[i - 1][j - 1], A[i - 1][j] and A[i - 1][j + 1].\\nStarting from row 1, we add the minumum path to each element. The smallest number in the last row is the miminum path sum.\\nExample:\\n[1, 2, 3]\\n[4, 5, 6] => [5, 6, 8]\\n[7, 8, 9] => [7, 8, 9] => [12, 13, 15]\\n\\nC++\\n\\nint minFallingPathSum(vector<vector<int>>& A) {\\n  for (auto i = 1; i < A.size(); ++i)\\n    for (auto j = 0; j < A.size(); ++j)\\n      A[i][j] += min({ A[i-1][j], A[i-1][max(0,j-1)], A[i-1][min((int)A.size()-1,j+1)] });\\n  return *min_element(begin(A[A.size() - 1]), end(A[A.size() - 1]));\\n}\\nJava\\n\\npublic int minFallingPathSum(int[][] A) {\\n  for (int i = 1; i < A.length; ++i)\\n    for (int j = 0; j < A.length; ++j)\\n      A[i][j] += Math.min(A[i - 1][j], Math.min(A[i - 1][Math.max(0, j - 1)], A[i - 1][Math.min(A.length - 1, j + 1)]));\\n  return Arrays.stream(A[A.length - 1]).min().getAsInt();\\n}       \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1879931,
                "title": "c-dfs-recursion-top-down-dp-easy-to-understand",
                "content": "**Solution:**\\n```\\nclass Solution {\\npublic:\\n    bool isValid(int r, int c, int n) {\\n        return r < n && c >= 0 && c < n;\\n    }\\n    int DFS(int r, int c, int n, int currSum, vector<vector<int>>& matrix, vector<vector<int>>& cache) {\\n        if(cache[r][c] != INT_MAX) return currSum + cache[r][c];\\n        int x = INT_MAX, y = INT_MAX, z = INT_MAX;\\n        if(isValid(r+1, c-1, n)) x = DFS(r+1, c-1, n, currSum + matrix[r][c], matrix, cache);\\n        if(isValid(r+1, c, n)) y = DFS(r+1, c, n, currSum + matrix[r][c], matrix, cache);\\n        if(isValid(r+1, c+1, n)) z = DFS(r+1, c+1, n, currSum + matrix[r][c], matrix, cache);\\n        int minSum = min(x, min(y, z));\\n        if(minSum == INT_MAX) cache[r][c] = matrix[r][c];\\n        else cache[r][c] = minSum - currSum;\\n        return currSum + cache[r][c];\\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        vector<vector<int>> cache(100, vector<int>(100, INT_MAX));\\n        int n = matrix.size(), res = INT_MAX;\\n        for(int i = 0; i < n; ++i) {\\n            res = min(res, DFS(0, i, n, 0, matrix, cache));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(int r, int c, int n) {\\n        return r < n && c >= 0 && c < n;\\n    }\\n    int DFS(int r, int c, int n, int currSum, vector<vector<int>>& matrix, vector<vector<int>>& cache) {\\n        if(cache[r][c] != INT_MAX) return currSum + cache[r][c];\\n        int x = INT_MAX, y = INT_MAX, z = INT_MAX;\\n        if(isValid(r+1, c-1, n)) x = DFS(r+1, c-1, n, currSum + matrix[r][c], matrix, cache);\\n        if(isValid(r+1, c, n)) y = DFS(r+1, c, n, currSum + matrix[r][c], matrix, cache);\\n        if(isValid(r+1, c+1, n)) z = DFS(r+1, c+1, n, currSum + matrix[r][c], matrix, cache);\\n        int minSum = min(x, min(y, z));\\n        if(minSum == INT_MAX) cache[r][c] = matrix[r][c];\\n        else cache[r][c] = minSum - currSum;\\n        return currSum + cache[r][c];\\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        vector<vector<int>> cache(100, vector<int>(100, INT_MAX));\\n        int n = matrix.size(), res = INT_MAX;\\n        for(int i = 0; i < n; ++i) {\\n            res = min(res, DFS(0, i, n, 0, matrix, cache));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1733431,
                "title": "fast-python-dp-solution-o-m-n",
                "content": "```\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        m = len( matrix)\\n        n = len( matrix[0])\\n        \\n        for i in range (1,m):\\n            for j in range (n):\\n                if j == 0:\\n                    matrix[i][j] += min( matrix[i-1][j], matrix[i-1][j+1])\\n                elif j == n-1:\\n                    matrix[i][j] += min( matrix[i-1][j], matrix[i-1][j-1])\\n                else:\\n                    matrix[i][j] += min( min( matrix[i-1][j], matrix[i-1][j+1]), matrix[i-1][j-1])\\n        \\n        return min( matrix[m-1])\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        m = len( matrix)\\n        n = len( matrix[0])\\n        \\n        for i in range (1,m):\\n            for j in range (n):\\n                if j == 0:\\n                    matrix[i][j] += min( matrix[i-1][j], matrix[i-1][j+1])\\n                elif j == n-1:\\n                    matrix[i][j] += min( matrix[i-1][j], matrix[i-1][j-1])\\n                else:\\n                    matrix[i][j] += min( min( matrix[i-1][j], matrix[i-1][j+1]), matrix[i-1][j-1])\\n        \\n        return min( matrix[m-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1727120,
                "title": "98-faster-than-others-c-dp-memoization",
                "content": "--------------------------------------------------------------Here is the code below------------------------------------------------------ \\n\\n# ***faster!!***\\n   \\n  \\n  \\n  \\n     int dp[101][101];\\n    int dfs(vector<vector<int>> &mat, int &n , int i, int j)\\n    {\\n\\t\\n        if(j <0 || j>n-1) return INT_MAX;\\n        if(i==n-1) return mat[i][j];\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        int a =  dfs(mat,n,i+1,j-1);\\n        int b =  dfs(mat,n,i+1,j);\\n        int c =  dfs(mat,n,i+1,j+1);\\n        int x = min(a,min(b,c));\\n        int net = x + mat[i][j];\\n        dp[i][j] = net;\\n        return net;\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        \\n        int  n = matrix[0].size();\\n        if(n==1) return matrix[0][0];\\n        memset(dp,-1,sizeof(dp));\\n        int sum=INT_MAX;\\n        for(int i =0 ; i<n; i++)\\n        {\\n            int v = dfs(matrix,n,0,i);\\n            sum = min(v,sum);\\n        }\\n        return sum;\\n    }",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "--------------------------------------------------------------Here is the code below------------------------------------------------------ \\n\\n# ***faster!!***\\n   \\n  \\n  \\n  \\n     int dp[101][101];\\n    int dfs(vector<vector<int>> &mat, int &n , int i, int j)\\n    {\\n\\t\\n        if(j <0 || j>n-1) return INT_MAX;\\n        if(i==n-1) return mat[i][j];\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        int a =  dfs(mat,n,i+1,j-1);\\n        int b =  dfs(mat,n,i+1,j);\\n        int c =  dfs(mat,n,i+1,j+1);\\n        int x = min(a,min(b,c));\\n        int net = x + mat[i][j];\\n        dp[i][j] = net;\\n        return net;\\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        \\n        int  n = matrix[0].size();\\n        if(n==1) return matrix[0][0];\\n        memset(dp,-1,sizeof(dp));\\n        int sum=INT_MAX;\\n        for(int i =0 ; i<n; i++)\\n        {\\n            int v = dfs(matrix,n,0,i);\\n            sum = min(v,sum);\\n        }\\n        return sum;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1628101,
                "title": "easy-and-simple-python-solution",
                "content": "```\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        \\n        r=len(matrix)\\n        c=len(matrix[0])\\n        \\n        for i in range(1,r):\\n            for j in range(c):\\n                \\n                if j==0:\\n                    matrix[i][j]+=min(matrix[i-1][j],matrix[i-1][j+1])\\n                    \\n                elif j==c-1:\\n                    matrix[i][j]+=min(matrix[i-1][j],matrix[i-1][j-1])\\n                    \\n                else:\\n                    matrix[i][j]+=min(matrix[i-1][j],matrix[i-1][j-1],matrix[i-1][j+1])\\n                    \\n        \\n        return min(matrix[r-1])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Matrix",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        \\n        r=len(matrix)\\n        c=len(matrix[0])\\n        \\n        for i in range(1,r):\\n            for j in range(c):\\n                \\n                if j==0:\\n                    matrix[i][j]+=min(matrix[i-1][j],matrix[i-1][j+1])\\n                    \\n                elif j==c-1:\\n                    matrix[i][j]+=min(matrix[i-1][j],matrix[i-1][j-1])\\n                    \\n                else:\\n                    matrix[i][j]+=min(matrix[i-1][j],matrix[i-1][j-1],matrix[i-1][j+1])\\n                    \\n        \\n        return min(matrix[r-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1601283,
                "title": "java-dp-solution-2ms",
                "content": "```\\nclass Solution {\\n    public int min2(int a,int b) {\\n        return Math.min(a,b);\\n    }\\n    public int min3(int a,int b,int c) {\\n        return Math.min(a,Math.min(b,c));\\n    }\\n    public int minFallingPathSum(int[][] arr) {\\n        int n=arr.length;\\n        if(n==1) return arr[0][0];\\n        \\n        int[][] dp=new int[n][n];\\n        for(int i=0;i<n;i++) dp[n-1][i]=arr[n-1][i];\\n        \\n        for(int i=n-2;i>-1;i--)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(j==0)\\n                {\\n                    dp[i][j]=arr[i][j]+min2(dp[i+1][j],dp[i+1][j+1]);\\n                }\\n                else if(j==n-1)\\n                {\\n                     dp[i][j]=arr[i][j]+min2(dp[i+1][j],dp[i+1][j-1]);\\n                }\\n                else{\\n                     dp[i][j]=arr[i][j]+min3(dp[i+1][j],dp[i+1][j+1],dp[i+1][j-1]);\\n                }\\n            }\\n        }\\n        \\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<n;i++)\\n        {\\n            min=Math.min(dp[0][i],min);\\n        }\\n        return min;\\n    }\\n}\\n```\\n\\nplease upvote",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int min2(int a,int b) {\\n        return Math.min(a,b);\\n    }\\n    public int min3(int a,int b,int c) {\\n        return Math.min(a,Math.min(b,c));\\n    }\\n    public int minFallingPathSum(int[][] arr) {\\n        int n=arr.length;\\n        if(n==1) return arr[0][0];\\n        \\n        int[][] dp=new int[n][n];\\n        for(int i=0;i<n;i++) dp[n-1][i]=arr[n-1][i];\\n        \\n        for(int i=n-2;i>-1;i--)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(j==0)\\n                {\\n                    dp[i][j]=arr[i][j]+min2(dp[i+1][j],dp[i+1][j+1]);\\n                }\\n                else if(j==n-1)\\n                {\\n                     dp[i][j]=arr[i][j]+min2(dp[i+1][j],dp[i+1][j-1]);\\n                }\\n                else{\\n                     dp[i][j]=arr[i][j]+min3(dp[i+1][j],dp[i+1][j+1],dp[i+1][j-1]);\\n                }\\n            }\\n        }\\n        \\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<n;i++)\\n        {\\n            min=Math.min(dp[0][i],min);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1595901,
                "title": "easy-dp-solution-in-c-step-by-step-solution-brute-force-memoization-tabular",
                "content": "Brute Force Solution in O(3^(mn)) time\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int getMinFallPathSum(int i, int j, int m, int n, vector<vector<int>>& matrix)\\n    {\\n        if(i==m)\\n            return 0;\\n        if(j<0 || j>=n)\\n            return INT_MAX;\\n        int temp = min(min(getMinFallPathSum(i+1,j+1,m,n,matrix),getMinFallPathSum(i+1,j-1,m,n,matrix)),getMinFallPathSum(i+1,j,m,n,matrix));\\n            \\n        return temp+matrix[i][j];\\n        \\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) \\n    {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int ans= INT_MAX;\\n        for(int j=0;j<n;j++)\\n        {\\n            ans=min(ans,getMinFallPathSum(0,j,m,n,matrix));\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n\\nMemoization solution in O(mn) time and O(mn) space.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int getMinFallPathSum(int i, int j, int m, int n, vector<vector<int>>& matrix,vector<vector<int>>& dp)\\n    {\\n        if(i==m)\\n            return 0;\\n        if(j<0 || j>=n)\\n            return INT_MAX;\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        int temp = min(min(getMinFallPathSum(i+1,j+1,m,n,matrix,dp),getMinFallPathSum(i+1,j-1,m,n,matrix,dp)),getMinFallPathSum(i+1,j,m,n,matrix,dp));\\n            \\n        dp[i][j]=temp+matrix[i][j];\\n        return dp[i][j];\\n        \\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) \\n    {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int ans= INT_MAX;\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        \\n        for(int j=0;j<n;j++)\\n        {\\n            ans=min(ans,getMinFallPathSum(0,j,m,n,matrix,dp));\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nLinear Space complexity solution using two vectors.\\nSpace Optimized.\\n\\nTime complexity:- O(n^2)\\nSpace complexity:- O(2*n) = O(n)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) \\n    {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int ans = INT_MAX;\\n        \\n        vector<vector<int>>dp(2,vector<int>(n,0));\\n        for(int i = m-1;i>=0;i--)\\n        {\\n            int t = i%2;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==(m-1))\\n                    dp[t][j] = matrix[i][j];\\n                else\\n                {\\n                    dp[t][j]= matrix[i][j];\\n                    int mn = dp[1-t][j];\\n                    if(j>0)\\n                        mn = min(mn,dp[1-t][j-1]);\\n                    if(j<(n-1))\\n                        mn = min(mn,dp[1-t][j+1]);\\n                    dp[t][j]+=mn;\\n                }\\n                if(i==0)\\n                    ans= min(ans,dp[t][j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\nLinear Space complexity solution using a single vector and an extra variable.\\nHighly Space Optimized.\\n\\nTime complexity:- O(n^2)\\nSpace complexity:-  O(n)\\n\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) \\n    {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int ans = INT_MAX;\\n        vector<int> dp(n,0);\\n        for(int i = m-1;i>=0;i--)\\n        {\\n            int prev = dp[0];\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==(m-1))\\n                    dp[j] = matrix[i][j];\\n                else\\n                {\\n                    int mn = dp[j];\\n                    if(j>0)\\n                    {\\n                        mn = min(mn,prev);\\n                    }\\n                    if(j<(n-1))\\n                        mn = min(mn,dp[j+1]);\\n                    prev = dp[j];\\n                    dp[j]=mn+matrix[i][j];\\n                }\\n                if(i==0)\\n                    ans= min(ans,dp[j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nPlease comment if you want to discuss anything. \\nAnd please upvote which will encourage me to share more solutions.",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int getMinFallPathSum(int i, int j, int m, int n, vector<vector<int>>& matrix)\\n    {\\n        if(i==m)\\n            return 0;\\n        if(j<0 || j>=n)\\n            return INT_MAX;\\n        int temp = min(min(getMinFallPathSum(i+1,j+1,m,n,matrix),getMinFallPathSum(i+1,j-1,m,n,matrix)),getMinFallPathSum(i+1,j,m,n,matrix));\\n            \\n        return temp+matrix[i][j];\\n        \\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) \\n    {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int ans= INT_MAX;\\n        for(int j=0;j<n;j++)\\n        {\\n            ans=min(ans,getMinFallPathSum(0,j,m,n,matrix));\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int getMinFallPathSum(int i, int j, int m, int n, vector<vector<int>>& matrix,vector<vector<int>>& dp)\\n    {\\n        if(i==m)\\n            return 0;\\n        if(j<0 || j>=n)\\n            return INT_MAX;\\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        int temp = min(min(getMinFallPathSum(i+1,j+1,m,n,matrix,dp),getMinFallPathSum(i+1,j-1,m,n,matrix,dp)),getMinFallPathSum(i+1,j,m,n,matrix,dp));\\n            \\n        dp[i][j]=temp+matrix[i][j];\\n        return dp[i][j];\\n        \\n    }\\n    \\n    int minFallingPathSum(vector<vector<int>>& matrix) \\n    {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int ans= INT_MAX;\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        \\n        for(int j=0;j<n;j++)\\n        {\\n            ans=min(ans,getMinFallPathSum(0,j,m,n,matrix,dp));\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) \\n    {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int ans = INT_MAX;\\n        \\n        vector<vector<int>>dp(2,vector<int>(n,0));\\n        for(int i = m-1;i>=0;i--)\\n        {\\n            int t = i%2;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==(m-1))\\n                    dp[t][j] = matrix[i][j];\\n                else\\n                {\\n                    dp[t][j]= matrix[i][j];\\n                    int mn = dp[1-t][j];\\n                    if(j>0)\\n                        mn = min(mn,dp[1-t][j-1]);\\n                    if(j<(n-1))\\n                        mn = min(mn,dp[1-t][j+1]);\\n                    dp[t][j]+=mn;\\n                }\\n                if(i==0)\\n                    ans= min(ans,dp[t][j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) \\n    {\\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        int ans = INT_MAX;\\n        vector<int> dp(n,0);\\n        for(int i = m-1;i>=0;i--)\\n        {\\n            int prev = dp[0];\\n            for(int j=0;j<n;j++)\\n            {\\n                if(i==(m-1))\\n                    dp[j] = matrix[i][j];\\n                else\\n                {\\n                    int mn = dp[j];\\n                    if(j>0)\\n                    {\\n                        mn = min(mn,prev);\\n                    }\\n                    if(j<(n-1))\\n                        mn = min(mn,dp[j+1]);\\n                    prev = dp[j];\\n                    dp[j]=mn+matrix[i][j];\\n                }\\n                if(i==0)\\n                    ans= min(ans,dp[j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1591116,
                "title": "memoization-of-recursive-approach",
                "content": "Please upvote if u like it----->\\n\\nAfter seeing the question it is clear that we need to try every possible cell to get minimum falling path sum, that\\'s why we will be using recursion as brute force approach.\\nFor every cell we have three choices,\\nFrom  mat[r][c] we can go to mat[r+1][c] (down),  mat[r+1][c+1] (diagonally right),  mat[r+1][c-1]  (diagonally left).\\nBetween these we need to pick the minimum, paying attention to the matrix indexes (Don\\'t get out of boundaries) which reppresent a base case for the recursive calls.\\nThe other base case is when we reach the end that is if ```r==matrix.size()-1```.\\n\\n=>Here is the brute force solution using recursion.\\n\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>>& mat,int r,int c,int m,int n)\\n    {\\n        if(c<0||c>=n)return INT_MAX;\\n        if(r==m-1)return mat[r][c];\\n        int ans=mat[r][c];\\n        int k1=solve(mat,r+1,c-1,m,n);\\n        int k2=solve(mat,r+1,c,m,n);\\n        int k3=solve(mat,r+1,c+1,m,n);\\n        ans+=min(k1,min(k2,k3));\\n        \\n        return ans;\\n    }\\n    int minFallingPathSum(vector<vector<int>>& mat) {\\n        int m=mat.size(),n=mat[0].size(),k=INT_MAX;\\n    \\n        for(int i=0;i<n;i++)\\n        {\\n            k=min(k,solve(mat,0,i,m,n));\\n        }\\n        return k;\\n    }\\n};\\n```\\n\\n\\n=> Below is the memoization of the above recursive approach:-\\n\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>>& mat,int r,int c,int m,int n,vector<vector<int>>&dp)\\n    {\\n        if(c<0||c>=n)return INT_MAX;\\n        if(r==m-1)return mat[r][c];\\n        if(dp[r][c]!=-1)return dp[r][c];\\n        int ans=mat[r][c];\\n        int k1=solve(mat,r+1,c-1,m,n,dp);\\n        int k2=solve(mat,r+1,c,m,n,dp);\\n        int k3=solve(mat,r+1,c+1,m,n,dp);\\n        ans+=min(k1,min(k2,k3));\\n        \\n        return dp[r][c]=ans;\\n    }\\n    int minFallingPathSum(vector<vector<int>>& mat) {\\n        int m=mat.size(),n=mat[0].size(),k=INT_MAX;\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        for(int i=0;i<n;i++)\\n        {\\n            k=min(k,solve(mat,0,i,m,n,dp));\\n        }\\n        return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```r==matrix.size()-1```\n```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>>& mat,int r,int c,int m,int n)\\n    {\\n        if(c<0||c>=n)return INT_MAX;\\n        if(r==m-1)return mat[r][c];\\n        int ans=mat[r][c];\\n        int k1=solve(mat,r+1,c-1,m,n);\\n        int k2=solve(mat,r+1,c,m,n);\\n        int k3=solve(mat,r+1,c+1,m,n);\\n        ans+=min(k1,min(k2,k3));\\n        \\n        return ans;\\n    }\\n    int minFallingPathSum(vector<vector<int>>& mat) {\\n        int m=mat.size(),n=mat[0].size(),k=INT_MAX;\\n    \\n        for(int i=0;i<n;i++)\\n        {\\n            k=min(k,solve(mat,0,i,m,n));\\n        }\\n        return k;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>>& mat,int r,int c,int m,int n,vector<vector<int>>&dp)\\n    {\\n        if(c<0||c>=n)return INT_MAX;\\n        if(r==m-1)return mat[r][c];\\n        if(dp[r][c]!=-1)return dp[r][c];\\n        int ans=mat[r][c];\\n        int k1=solve(mat,r+1,c-1,m,n,dp);\\n        int k2=solve(mat,r+1,c,m,n,dp);\\n        int k3=solve(mat,r+1,c+1,m,n,dp);\\n        ans+=min(k1,min(k2,k3));\\n        \\n        return dp[r][c]=ans;\\n    }\\n    int minFallingPathSum(vector<vector<int>>& mat) {\\n        int m=mat.size(),n=mat[0].size(),k=INT_MAX;\\n        vector<vector<int>> dp(m,vector<int>(n,-1));\\n        for(int i=0;i<n;i++)\\n        {\\n            k=min(k,solve(mat,0,i,m,n,dp));\\n        }\\n        return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563238,
                "title": "simple-python-solution-with-explanation",
                "content": "Explanation : https://github.com/midnightbot/leetcode_solutions/blob/main/931.%20Minimum%20Falling%20Path%20Sum(DP).pdf\\n```\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        \\n        n = len(matrix)\\n        \\n        dp = [[0 for x in range(n+2)] for y in range(n+2)]\\n        \\n        for x in range(n+2):\\n            dp[0][x] = float(\\'inf\\')\\n            dp[n+1][x] = float(\\'inf\\')\\n            \\n        for y in range(n):\\n            dp[1+y][0] = float(\\'inf\\')\\n            dp[1+y][n+1] = float(\\'inf\\')\\n            \\n        \\n        \\n        for x in range(1,n+1):\\n            dp[0][x] = matrix[n-1][x-1]\\n            \\n        #print(dp)\\n        \\n        for x in range(1,n+1):\\n            for y in range(1,n+1):\\n                dp[x][y] = min(dp[x-1][y-1],dp[x-1][y],dp[x-1][y+1]) + matrix[n-x-1][y-1]\\n                \\n        #print(dp)\\n        return min(dp[n-1])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        \\n        n = len(matrix)\\n        \\n        dp = [[0 for x in range(n+2)] for y in range(n+2)]\\n        \\n        for x in range(n+2):\\n            dp[0][x] = float(\\'inf\\')\\n            dp[n+1][x] = float(\\'inf\\')\\n            \\n        for y in range(n):\\n            dp[1+y][0] = float(\\'inf\\')\\n            dp[1+y][n+1] = float(\\'inf\\')\\n            \\n        \\n        \\n        for x in range(1,n+1):\\n            dp[0][x] = matrix[n-1][x-1]\\n            \\n        #print(dp)\\n        \\n        for x in range(1,n+1):\\n            for y in range(1,n+1):\\n                dp[x][y] = min(dp[x-1][y-1],dp[x-1][y],dp[x-1][y+1]) + matrix[n-x-1][y-1]\\n                \\n        #print(dp)\\n        return min(dp[n-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1535842,
                "title": "java-tabulation-method-easy-to-understand-dynamic-programming",
                "content": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        int n = matrix.length;\\n        int[][] dp = new int[n][n];\\n        //initially filling the  last row\\n        for(int i=n-1;i>=0;i--)\\n            dp[n-1][i] = matrix[n-1][i];\\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(j == 0)\\n                {\\n                    dp[i][j] = Math.min(dp[i+1][j],dp[i+1][j+1]);\\n                    dp[i][j] += matrix[i][j];\\n                }\\n                else if(j == n-1)\\n                {\\n                    dp[i][j] = Math.min(dp[i+1][j],dp[i+1][j-1]);\\n                    dp[i][j] += matrix[i][j];\\n                }\\n                else\\n                {\\n                    dp[i][j] = Math.min(dp[i+1][j],Math.min(dp[i+1][j-1],dp[i+1][j+1]));\\n                    dp[i][j] += matrix[i][j];\\n                }\\n            }\\n        }\\n        \\n        int ans = Integer.MAX_VALUE;\\n        for(int i=0;i<n;i++)\\n            ans = Math.min(dp[0][i],ans);\\n        \\n        return ans;\\n        \\n    }\\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n        int n = matrix.length;\\n        int[][] dp = new int[n][n];\\n        //initially filling the  last row\\n        for(int i=n-1;i>=0;i--)\\n            dp[n-1][i] = matrix[n-1][i];\\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(j == 0)\\n                {\\n                    dp[i][j] = Math.min(dp[i+1][j],dp[i+1][j+1]);\\n                    dp[i][j] += matrix[i][j];\\n                }\\n                else if(j == n-1)\\n                {\\n                    dp[i][j] = Math.min(dp[i+1][j],dp[i+1][j-1]);\\n                    dp[i][j] += matrix[i][j];\\n                }\\n                else\\n                {\\n                    dp[i][j] = Math.min(dp[i+1][j],Math.min(dp[i+1][j-1],dp[i+1][j+1]));\\n                    dp[i][j] += matrix[i][j];\\n                }\\n            }\\n        }\\n        \\n        int ans = Integer.MAX_VALUE;\\n        for(int i=0;i<n;i++)\\n            ans = Math.min(dp[0][i],ans);\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1346499,
                "title": "python-2-bottom-up-dp-solutions-clean-concise",
                "content": "**Solution 1: Bottom-up DP**\\n```\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        m, n = len(matrix), len(matrix[0])  # For general\\n        dp = [[0] * n for _ in range(m)]\\n        ans = math.inf\\n        for r in range(m):\\n            for c in range(n):\\n                if r == 0:\\n                    dp[r][c] = matrix[r][c]\\n                else:\\n                    dp[r][c] = dp[r-1][c] + matrix[r][c]\\n                    if c-1 >= 0:\\n                        dp[r][c] = min(dp[r][c], dp[r-1][c-1] + matrix[r][c])\\n                    if c+1 < n:\\n                        dp[r][c] = min(dp[r][c], dp[r-1][c+1] + matrix[r][c])\\n                        \\n        for c in range(n):\\n            ans = min(ans, dp[m-1][c])\\n        return ans\\n```\\nComplexity:\\n- Time: `O(M*N)`, where `M` is number of rows, `N` is number of columns\\n- Space: `O(M*N)`\\n\\n**Solution 2: Bottom-up DP (Space Optimized)**\\n```python\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        m, n = len(matrix), len(matrix[0])  # For general\\n        dp, dpPrev = [0] * n, [0] * n\\n        for r in range(m):\\n            for c in range(n):\\n                if r == 0:\\n                    dp[c] = matrix[r][c]\\n                else:\\n                    dp[c] = dpPrev[c] + matrix[r][c]\\n                    if c-1 >= 0:\\n                        dp[c] = min(dp[c], dpPrev[c-1] + matrix[r][c])\\n                    if c+1 < n:\\n                        dp[c] = min(dp[c], dpPrev[c+1] + matrix[r][c])\\n            dp, dpPrev = dpPrev, dp\\n                        \\n        return min(dpPrev)\\n```\\nComplexity:\\n- Time: `O(M*N)`, where `M` is number of rows, `N` is number of columns\\n- Space: `O(N)`",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        m, n = len(matrix), len(matrix[0])  # For general\\n        dp = [[0] * n for _ in range(m)]\\n        ans = math.inf\\n        for r in range(m):\\n            for c in range(n):\\n                if r == 0:\\n                    dp[r][c] = matrix[r][c]\\n                else:\\n                    dp[r][c] = dp[r-1][c] + matrix[r][c]\\n                    if c-1 >= 0:\\n                        dp[r][c] = min(dp[r][c], dp[r-1][c-1] + matrix[r][c])\\n                    if c+1 < n:\\n                        dp[r][c] = min(dp[r][c], dp[r-1][c+1] + matrix[r][c])\\n                        \\n        for c in range(n):\\n            ans = min(ans, dp[m-1][c])\\n        return ans\\n```\n```python\\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        m, n = len(matrix), len(matrix[0])  # For general\\n        dp, dpPrev = [0] * n, [0] * n\\n        for r in range(m):\\n            for c in range(n):\\n                if r == 0:\\n                    dp[c] = matrix[r][c]\\n                else:\\n                    dp[c] = dpPrev[c] + matrix[r][c]\\n                    if c-1 >= 0:\\n                        dp[c] = min(dp[c], dpPrev[c-1] + matrix[r][c])\\n                    if c+1 < n:\\n                        dp[c] = min(dp[c], dpPrev[c+1] + matrix[r][c])\\n            dp, dpPrev = dpPrev, dp\\n                        \\n        return min(dpPrev)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345480,
                "title": "c-recur-memo-bottom-up-better-bottom-up",
                "content": "**YouTube Video Link** : [codestorywithMIK ](https://www.youtube.com/watch?v=EQC0ckOyEGs&list=PLpIkg8OmuX-L_QqcKB5abYynQbonaNcq3&index=8)\\n```\\n/*   \\n    Similar tough problem : Leetcode - 1937 : Maximum Number of Points with Cost  (Must Try !!!!)\\n*/\\n\\n//Approach-1 (Recur + Memoization) : O(m*n)\\nclass Solution {\\npublic:\\n    int MFS(vector<vector<int>>& A, int row, int col, vector<vector<int>>& t) {\\n        if(row == A.size()-1)\\n            return A[row][col];\\n        if(t[row][col] != -1)\\n            return t[row][col];\\n        \\n        int minSum = INT_MAX;\\n        \\n        for(int shift = -1; shift<=1; shift++) {\\n            if(col + shift >=0 && col+shift < A[row].size()) {\\n                minSum = min(minSum, A[row][col] + MFS(A, row+1, col+shift, t));\\n            }\\n        }\\n        \\n        return t[row][col] = minSum;\\n    }\\n    int minFallingPathSum(vector<vector<int>>& A) {\\n        int m = A.size(); //row\\n        int n = m; //column\\n        vector<vector<int>> t(101, vector<int>(101));\\n        for(int i = 0; i<101; i++) {\\n            for(int j = 0; j<101; j++) {\\n                t[i][j] = -1;\\n            }\\n        }\\n        int result = INT_MAX;\\n        for(int col = 0; col<n; col++) {\\n            result = min(result, MFS(A, 0, col, t));\\n        }\\n        return result;\\n    }\\n};\\n\\n//Approach-2 (Bottom UP DP) : O(m*n)\\n//Using O(m*n) space\\nclass Solution {\\npublic:\\n    int MFS(vector<vector<int>>& A) {\\n        int m = A.size();\\n        vector<vector<int>> t(m, vector<int>(m));\\n        \\n        //initialization\\n        for(int col = 0; col<m; col++) {\\n            t[0][col] = A[0][col];\\n        }\\n        \\n        for(int row = 1; row < m; row++) {\\n            for(int col = 0; col < m; col++) {\\n                t[row][col] = A[row][col] + min({t[row-1][col], \\n                                                 t[row-1][max(0, col-1)], \\n                                                 t[row-1][min(m-1, col+1)]});\\n            }\\n        }\\n\\n        return *min_element(t[m-1].begin(), t[m-1].end());\\n        \\n    }\\n    int minFallingPathSum(vector<vector<int>>& A) { \\n        return MFS(A);\\n    }\\n};\\n\\n\\n//Approach-3 (Bottom UP DP) : O(m*n)\\n//Using O(n) space\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& A) {\\n        int n = A.size();\\n        vector<int> prev(n);\\n        for(int col = 0; col<n; col++)\\n            prev[col] = A[0][col];\\n        \\n        for(int row = 1; row<n; row++) {\\n            vector<int> curr(n);\\n            for(int col = 0; col<n; col++) {\\n                curr[col] = A[row][col] + min({prev[max(0, col-1)],  prev[col],  prev[min(n-1, col+1)]});\\n            }\\n            prev = curr;\\n        }\\n        return *min_element(prev.begin(), prev.end());\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/*   \\n    Similar tough problem : Leetcode - 1937 : Maximum Number of Points with Cost  (Must Try !!!!)\\n*/\\n\\n//Approach-1 (Recur + Memoization) : O(m*n)\\nclass Solution {\\npublic:\\n    int MFS(vector<vector<int>>& A, int row, int col, vector<vector<int>>& t) {\\n        if(row == A.size()-1)\\n            return A[row][col];\\n        if(t[row][col] != -1)\\n            return t[row][col];\\n        \\n        int minSum = INT_MAX;\\n        \\n        for(int shift = -1; shift<=1; shift++) {\\n            if(col + shift >=0 && col+shift < A[row].size()) {\\n                minSum = min(minSum, A[row][col] + MFS(A, row+1, col+shift, t));\\n            }\\n        }\\n        \\n        return t[row][col] = minSum;\\n    }\\n    int minFallingPathSum(vector<vector<int>>& A) {\\n        int m = A.size(); //row\\n        int n = m; //column\\n        vector<vector<int>> t(101, vector<int>(101));\\n        for(int i = 0; i<101; i++) {\\n            for(int j = 0; j<101; j++) {\\n                t[i][j] = -1;\\n            }\\n        }\\n        int result = INT_MAX;\\n        for(int col = 0; col<n; col++) {\\n            result = min(result, MFS(A, 0, col, t));\\n        }\\n        return result;\\n    }\\n};\\n\\n//Approach-2 (Bottom UP DP) : O(m*n)\\n//Using O(m*n) space\\nclass Solution {\\npublic:\\n    int MFS(vector<vector<int>>& A) {\\n        int m = A.size();\\n        vector<vector<int>> t(m, vector<int>(m));\\n        \\n        //initialization\\n        for(int col = 0; col<m; col++) {\\n            t[0][col] = A[0][col];\\n        }\\n        \\n        for(int row = 1; row < m; row++) {\\n            for(int col = 0; col < m; col++) {\\n                t[row][col] = A[row][col] + min({t[row-1][col], \\n                                                 t[row-1][max(0, col-1)], \\n                                                 t[row-1][min(m-1, col+1)]});\\n            }\\n        }\\n\\n        return *min_element(t[m-1].begin(), t[m-1].end());\\n        \\n    }\\n    int minFallingPathSum(vector<vector<int>>& A) { \\n        return MFS(A);\\n    }\\n};\\n\\n\\n//Approach-3 (Bottom UP DP) : O(m*n)\\n//Using O(n) space\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& A) {\\n        int n = A.size();\\n        vector<int> prev(n);\\n        for(int col = 0; col<n; col++)\\n            prev[col] = A[0][col];\\n        \\n        for(int row = 1; row<n; row++) {\\n            vector<int> curr(n);\\n            for(int col = 0; col<n; col++) {\\n                curr[col] = A[row][col] + min({prev[max(0, col-1)],  prev[col],  prev[min(n-1, col+1)]});\\n            }\\n            prev = curr;\\n        }\\n        return *min_element(prev.begin(), prev.end());\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1289757,
                "title": "recursive-memoization-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int rec(vector<vector<int>>& matrix,int i, int j,vector<vector<int>>&dp){\\n        if(j<0 || j>matrix[0].size()-1){\\n            return INT_MAX-100;\\n        }\\n        if(i>matrix.size()-1){\\n            return 0;\\n        }\\n        if(dp[i][j]!=INT_MIN){\\n            return dp[i][j];\\n        }\\n       int a=matrix[i][j]+rec(matrix,i+1,j,dp);\\n       int b=matrix[i][j]+rec(matrix,i+1,j-1,dp);\\n       int c=matrix[i][j]+rec(matrix,i+1,j+1,dp);\\n       return dp[i][j]=min(a,min(b,c));\\n        \\n        \\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int miner=INT_MAX;\\n        vector<vector<int>>dp(matrix.size(),vector<int>(matrix[0].size(),INT_MIN));\\n        for(int i=0;i<matrix[0].size();i++){\\n            miner=min(miner,rec(matrix,0,i,dp));\\n        }\\n        return miner;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int rec(vector<vector<int>>& matrix,int i, int j,vector<vector<int>>&dp){\\n        if(j<0 || j>matrix[0].size()-1){\\n            return INT_MAX-100;\\n        }\\n        if(i>matrix.size()-1){\\n            return 0;\\n        }\\n        if(dp[i][j]!=INT_MIN){\\n            return dp[i][j];\\n        }\\n       int a=matrix[i][j]+rec(matrix,i+1,j,dp);\\n       int b=matrix[i][j]+rec(matrix,i+1,j-1,dp);\\n       int c=matrix[i][j]+rec(matrix,i+1,j+1,dp);\\n       return dp[i][j]=min(a,min(b,c));\\n        \\n        \\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int miner=INT_MAX;\\n        vector<vector<int>>dp(matrix.size(),vector<int>(matrix[0].size(),INT_MIN));\\n        for(int i=0;i<matrix[0].size();i++){\\n            miner=min(miner,rec(matrix,0,i,dp));\\n        }\\n        return miner;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1240297,
                "title": "o-n-2-dp-approach-python",
                "content": "In order to reach a specific row i in the matrix, we can reach any cell in that row.\\nSo, we have a dp matrix, where dp[i][j] is the minimum cost to reach matrix[i - 1][j].\\nBy default, all elements in dp[0] is set to zero.\\n\\nThe recursive equation is as follows :\\n\\ndp[i][j] = matrix[i - 1][j] + min(dp[i - 1][j - 1] , dp[i - 1][j], dp[i - 1][j + 1])\\n\\nThe final answer would be simply the minimum value among all the elements of the final row of dp array, i.e., min(dp[-1])\\n\\nHere is the code :\\n\\n```\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        \\n        dp = [[0] * len(matrix[0]) for i in range(len(matrix) + 1)]\\n        \\n        for i in range(1 , len(matrix) + 1) :\\n            \\n            for j in range(len(matrix[0])) :\\n                check = [dp[i - 1][j]]\\n                if j > 0 :\\n                    check.append(dp[i - 1][j - 1])\\n                if j < len(matrix[0]) - 1 :\\n                    check.append(dp[i - 1][j + 1])\\n                dp[i][j] = min(check) + matrix[i - 1][j]\\n        \\n        return min(dp[-1])\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        \\n        dp = [[0] * len(matrix[0]) for i in range(len(matrix) + 1)]\\n        \\n        for i in range(1 , len(matrix) + 1) :\\n            \\n            for j in range(len(matrix[0])) :\\n                check = [dp[i - 1][j]]\\n                if j > 0 :\\n                    check.append(dp[i - 1][j - 1])\\n                if j < len(matrix[0]) - 1 :\\n                    check.append(dp[i - 1][j + 1])\\n                dp[i][j] = min(check) + matrix[i - 1][j]\\n        \\n        return min(dp[-1])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1143777,
                "title": "java-beats-100-dfs-memoization-clean-solution",
                "content": "```\\nclass Solution {\\n   int dp[][];\\n    public int minFallingPathSum(int[][] matrix) {\\n        int min=Integer.MAX_VALUE;\\n        dp=new int[matrix.length+1][matrix[0].length+1];\\n        \\n        for(int j=0,i=0;j<matrix[0].length;j++){\\n         int dfsans= dfs(matrix,i,j);\\n          min=Math.min(min,dfsans);\\n        }\\n      \\n      return min;\\n    }\\n   \\n   public int  dfs(int arr[][],int i,int j){\\n     if(j<0 || j>=arr[0].length){\\n       return Integer.MAX_VALUE;\\n     }\\n     if(i==arr.length-1){\\n       return arr[i][j];\\n     }\\n    if(dp[i][j]!=0){\\n      return dp[i][j];\\n    }\\n     \\n    int s1 =  dfs(arr,i+1,j-1);\\n    int s2 =  dfs(arr,i+1,j);\\n    int s3 =  dfs(arr,i+1,j+1);\\n     \\n    dp[i][j]=arr[i][j]+Math.min(s1,Math.min(s2,s3));\\n     \\n     \\n   return dp[i][j];\\n     \\n   }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n   int dp[][];\\n    public int minFallingPathSum(int[][] matrix) {\\n        int min=Integer.MAX_VALUE;\\n        dp=new int[matrix.length+1][matrix[0].length+1];\\n        \\n        for(int j=0,i=0;j<matrix[0].length;j++){\\n         int dfsans= dfs(matrix,i,j);\\n          min=Math.min(min,dfsans);\\n        }\\n      \\n      return min;\\n    }\\n   \\n   public int  dfs(int arr[][],int i,int j){\\n     if(j<0 || j>=arr[0].length){\\n       return Integer.MAX_VALUE;\\n     }\\n     if(i==arr.length-1){\\n       return arr[i][j];\\n     }\\n    if(dp[i][j]!=0){\\n      return dp[i][j];\\n    }\\n     \\n    int s1 =  dfs(arr,i+1,j-1);\\n    int s2 =  dfs(arr,i+1,j);\\n    int s3 =  dfs(arr,i+1,j+1);\\n     \\n    dp[i][j]=arr[i][j]+Math.min(s1,Math.min(s2,s3));\\n     \\n     \\n   return dp[i][j];\\n     \\n   }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1133001,
                "title": "python-dp-memoization-top-bottom",
                "content": "We try to get to the last row of the matrix, where the path will end. If we end up in a col outside the matrix, we mark that path with **inf** so it\\'s not considered as an option.\\n\\nWe use memoization to store in a cache the minim value for reaching the bottom using that cell as a starting point.\\n\\nWith that approach, it\\'s quite straight forward.\\n\\n```\\nclass Solution:\\n    def helper(self, matrix, row, col, memo):\\n        if col < 0 or col == len(matrix[0]):\\n            return float(\"inf\")\\n        \\n        if row == len(matrix) - 1:\\n            return matrix[row][col]\\n        \\n        if row in memo and col in memo[row]:\\n            return memo[row][col]\\n        \\n        bottom    = self.helper(matrix, row+1,col, memo)\\n        diagLeft  = self.helper(matrix, row+1, col -1, memo)\\n        diagRight = self.helper(matrix, row+1, col +1, memo)\\n        \\n        if row not in memo:\\n            memo[row] = {}\\n        \\n        memo[row][col] = matrix[row][col] + min(bottom, diagLeft, diagRight)\\n        \\n        return memo[row][col]\\n        \\n        \\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        memo   = {}\\n        result = float(\"inf\")\\n        for col in range(len(matrix[0])):\\n            result = min(result, self.helper(matrix,0,col,memo))\\n            \\n        return result\\n```  \\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def helper(self, matrix, row, col, memo):\\n        if col < 0 or col == len(matrix[0]):\\n            return float(\"inf\")\\n        \\n        if row == len(matrix) - 1:\\n            return matrix[row][col]\\n        \\n        if row in memo and col in memo[row]:\\n            return memo[row][col]\\n        \\n        bottom    = self.helper(matrix, row+1,col, memo)\\n        diagLeft  = self.helper(matrix, row+1, col -1, memo)\\n        diagRight = self.helper(matrix, row+1, col +1, memo)\\n        \\n        if row not in memo:\\n            memo[row] = {}\\n        \\n        memo[row][col] = matrix[row][col] + min(bottom, diagLeft, diagRight)\\n        \\n        return memo[row][col]\\n        \\n        \\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        memo   = {}\\n        result = float(\"inf\")\\n        for col in range(len(matrix[0])):\\n            result = min(result, self.helper(matrix,0,col,memo))\\n            \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1129866,
                "title": "javascript-dp",
                "content": "```\\nvar minFallingPathSum = function(matrix) {\\n  const M = matrix.length\\n  const N = matrix[0].length\\n  const dp = new Array(M).fill().map(a=> new Array(N).fill(Infinity))\\n  dp[0] = matrix[0]\\n  for(let r=1;r<M;r++){\\n    for(let c=0;c<N;c++){\\n      const curr = matrix[r][c]\\n      const top= curr + dp[r-1][c]\\n      const topL= curr+ (dp[r-1][c-1] || Infinity)\\n      const topR= curr+ (dp[r-1][c+1] || Infinity)\\n      dp[r][c] = Math.min(top, topL, topR)\\n    }    \\n  }\\n  return Math.min(...dp[M-1])\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar minFallingPathSum = function(matrix) {\\n  const M = matrix.length\\n  const N = matrix[0].length\\n  const dp = new Array(M).fill().map(a=> new Array(N).fill(Infinity))\\n  dp[0] = matrix[0]\\n  for(let r=1;r<M;r++){\\n    for(let c=0;c<N;c++){\\n      const curr = matrix[r][c]\\n      const top= curr + dp[r-1][c]\\n      const topL= curr+ (dp[r-1][c-1] || Infinity)\\n      const topR= curr+ (dp[r-1][c+1] || Infinity)\\n      dp[r][c] = Math.min(top, topL, topR)\\n    }    \\n  }\\n  return Math.min(...dp[M-1])\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1111880,
                "title": "c-top-down-and-bottom-up-approaches",
                "content": "**Top-Down Approach:**\\n```\\nclass Solution {\\n    int dp[101][101]={};\\npublic:\\n    int solve(vector<vector<int>>& matrix,int x,int y){\\n        if(x==matrix.size())\\n            return 0;\\n        if(y<0 || y==matrix[0].size())\\n            return INT_MAX;\\n        return dp[x][y] ? dp[x][y] : dp[x][y]=\\n            matrix[x][y]+min(solve(matrix,x+1,y),min(solve(matrix,x+1,y+1),solve(matrix,x+1,y-1)));\\n        \\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int rows=matrix.size();\\n        if(rows==0)\\n            return 0;\\n        int cols=matrix[0].size();\\n        int ans=INT_MAX;\\n        for(int j=0;j<cols;j++){\\n            ans=min(ans,solve(matrix,0,j));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**Bottom-Up Approach:**\\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int rows=matrix.size();\\n        if(rows==0)\\n            return 0;\\n        int cols=matrix[0].size();\\n        for(int i=rows-2;i>=0;i--){\\n            for(int j=1;j<cols-1;j++){\\n                matrix[i][j]+=min(matrix[i+1][j-1],min(matrix[i+1][j],matrix[i+1][j+1]));\\n            }\\n            if(cols>1){\\n                matrix[i][0]+=min(matrix[i+1][0],matrix[i+1][1]);\\n                matrix[i][cols-1]+=min(matrix[i+1][cols-1],matrix[i+1][cols-2]);\\n            }    \\n            else\\n                matrix[i][0]+=matrix[i+1][0];\\n            \\n        }\\n        return *min_element(begin(matrix[0]),end(matrix[0]));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int dp[101][101]={};\\npublic:\\n    int solve(vector<vector<int>>& matrix,int x,int y){\\n        if(x==matrix.size())\\n            return 0;\\n        if(y<0 || y==matrix[0].size())\\n            return INT_MAX;\\n        return dp[x][y] ? dp[x][y] : dp[x][y]=\\n            matrix[x][y]+min(solve(matrix,x+1,y),min(solve(matrix,x+1,y+1),solve(matrix,x+1,y-1)));\\n        \\n    }\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int rows=matrix.size();\\n        if(rows==0)\\n            return 0;\\n        int cols=matrix[0].size();\\n        int ans=INT_MAX;\\n        for(int j=0;j<cols;j++){\\n            ans=min(ans,solve(matrix,0,j));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int rows=matrix.size();\\n        if(rows==0)\\n            return 0;\\n        int cols=matrix[0].size();\\n        for(int i=rows-2;i>=0;i--){\\n            for(int j=1;j<cols-1;j++){\\n                matrix[i][j]+=min(matrix[i+1][j-1],min(matrix[i+1][j],matrix[i+1][j+1]));\\n            }\\n            if(cols>1){\\n                matrix[i][0]+=min(matrix[i+1][0],matrix[i+1][1]);\\n                matrix[i][cols-1]+=min(matrix[i+1][cols-1],matrix[i+1][cols-2]);\\n            }    \\n            else\\n                matrix[i][0]+=matrix[i+1][0];\\n            \\n        }\\n        return *min_element(begin(matrix[0]),end(matrix[0]));\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1714691,
                "content": [
                    {
                        "username": "makhotin",
                        "content": "If you're interested where this algo can be applied - please see [wiki page of the algo](https://en.wikipedia.org/wiki/Seam_carving), [video](https://www.youtube.com/watch?v=6NcIJXTlugc) Very cool algorithm for smart image resizing. It compute a vertical seam (path) with lowest energy using DP."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Thank! It\\'s more excited to know the \"real\" application associated with this exercise."
                    },
                    {
                        "username": "willremember2020",
                        "content": "Why is memoization solution giving tle in 49/50 testcase? But a similar tabulation solution works??"
                    },
                    {
                        "username": "vp271202",
                        "content": "[@ansh_1012](/ansh_1012)  the -1 solution will fail because if there is a case where the sum is -1 then it will give a wrong ans and if the testcase is too large then there is a chance that it will give tle rather than a wrong ans."
                    },
                    {
                        "username": "Gaurav1234Balodi",
                        "content": "[@Sandeep_Rai](/Sandeep_Rai) its simple just read the constraints -100 <= matrix[i][j] <= 100 so you cannot enter -1 it will work even if you memorize 101 "
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "[@ansh_1012](/ansh_1012) Yeah that worked but why?"
                    },
                    {
                        "username": "ak_3101",
                        "content": "[@ansh_1012](/ansh_1012) yes, but WHY\\n"
                    },
                    {
                        "username": "azad_6021",
                        "content": "[@ansh_1012](/ansh_1012)  Why\\'s this making a difference"
                    },
                    {
                        "username": "ansh_1012",
                        "content": "[@jatin_vashisht](/jatin_vashisht) memo solutions worked fine for me when i chnges the initialization of dp with INT_MAX rather than -1"
                    },
                    {
                        "username": "jatin_vashisht",
                        "content": "seems like leetcode has tightened the constraints. Bottom Up is getting accepted."
                    },
                    {
                        "username": "amanchandna",
                        "content": "coming up with an recursive solution at first is completely normal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "[@user3134m](/user3134m) interactive "
                    },
                    {
                        "username": "user3134m",
                        "content": "Is there a better solution than recursion with memorization?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This is not a solution Tab we people are posting solution in the discussion session?\\nPlease don\\'t do this.\\nTry to give some tip if possible."
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "We can clearly see that for every element on rows 1 to n, every element is (element + minimum of 3 nodes above it)\\n\\nSo, we just have to perform this O(1) calculation for every element from row 1"
                    },
                    {
                        "username": "utkarshprap",
                        "content": "Thank You Sir for this Hint\\uD83D\\uDE04"
                    },
                    {
                        "username": "priyanshurathaur001",
                        "content": "1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n9 9 8 7 6 1\\n\\nwhat was the approach for this??\\n"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "[@joshi22](/joshi22) Its my pleasure I was able to help you\\nYou made me day\\uD83D\\uDE0A"
                    },
                    {
                        "username": "joshi22",
                        "content": "im new to dp and i read this hint and it immediately clicked how to implement it. solved it in 15 mins using dp! thanks :D"
                    },
                    {
                        "username": "beyeu107",
                        "content": "can anyone please explain ! thank you !"
                    },
                    {
                        "username": "kcharris77",
                        "content": "This problem can be solved by breaking it into sub problems. Two ways to do this are starting from the top and working down, or from the bottom and working up. At least for bottom up, the subproblems involve finding the minimum of the three-ish items below an individual item."
                    },
                    {
                        "username": "Indraneel965",
                        "content": "Try recurisively First. try out every first row element and their possibilities."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@venubrt](/venubrt) Please don\\'t post any solutions in this discussion tab."
                    },
                    {
                        "username": "denisId",
                        "content": "In order to solve this you have to approach it in 3 main steps:\n>Step 1 is to decompose the problem and to think how to calculate the minimum sum for only one element in the first row\n\nlet's suppose the default example:\n\nMatrix ---\n----------------------\n    2      --  [2, 1, 3] --\n    1      --  [6, 5, 4] --\n    0      --  [7, 8, 9] --\n    --     --  0  1  2  --\n\n\nWe want to find out just the minimum path for one element from first row (let it be for example Matrix[0][1] (\"8\")):\nLet's view all possible paths\n8->6->2\n8->5->2\n8->5->1\n8->5->3\n8->4->3\nIf you observe carefully this is a tree structure, so we basically have to traverse a tree structure\n\nNow the idea is to check the min sum from the descendent nodes(leaves) and bubbling up the sum to the initial root value\n\niteration1) MinValue(6) IS \"2\" (because we don't have other values, 2 + 0)\niteration2) MinValue(5)=\"1\" (because 1 < 2 < 3)\niteration3) MinValue(4)=\"3\" (because we don't have other values, 3 + 0)\ngoing for upper node now:\niteration4) MinValue(8) IS \"14\" (because (8 + MinValue(5)) < (8 + MinValue(6)) < (8 + MinValue(4)))\n\n>Step2: When you find the min sum for only one element, we can just iterate through entire row and take the min value.\n\n>Step3:The problem now is solved, however you will encounter TimeLimit Error with pure recursion on some testcases, it's due to the fact that all subnodes are recalculated multiple times\nThe solution is to use the dynamic programing: add a sort of storage structure/cache structure(HashMap), where you can put values from subnodes and to not recalculate again the sums for visited sites, and at the same time you can get the needed values quickly(in O(1) time)"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "great expl."
                    },
                    {
                        "username": "ay8182",
                        "content": "[@tulsyanshishir](/tulsyanshishir) yes it is valid\\n"
                    },
                    {
                        "username": "romanvkj2001",
                        "content": "[@tulsyanshishir](/tulsyanshishir) and also 8->4->1?\\n"
                    },
                    {
                        "username": "tulsyanshishir",
                        "content": "May be I did not understand this properly. Is the path 8->6->1 not valid ?"
                    },
                    {
                        "username": "Sohamkayal4103",
                        "content": "Some problems are better solved by tabulation instead of memoization. Choose the methods wisely while attempting any contests. "
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": "[@gaurav_rawat369](/gaurav_rawat369) intilise vector<vector>dp(n+1,vector(n+1,-1)); as vector<vector>dp(n+1,vector(n+1,int_max)); it works fine but i am also getting tle if i set my dp -1 . can anyone explain why ?"
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "class Solution {\\nprivate:\\n    int solver(int i ,int j,int n,vector<vector<int>>&dp,vector<vector<int>>&matrix)\\n    {\\n        if(i > n || j < 0 || j > n)\\n        return 1e9;\\n        if(i == n)\\n        return matrix[i][j];\\n        if(dp[i][j] != -1)\\n        return dp[i][j];\\n        return dp[i][j] = matrix[i][j] + min(solver(i+1,j-1,n,dp,matrix),min(solver(i+1,j,n,dp,matrix),solver(i+1,j+1,n,dp,matrix)));\\n    }\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        int ans = INT_MAX;\\n        for(int i =0;i<n;i++)\\n        {\\n            ans = min(ans,solver(0,i,n-1,dp,matrix));\\n        }\\n        return ans;\\n    }\\n};\\nthis is giving me TLE in last test case\\n"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "since the values in the matrix can be both positive and negative, initializing the DP array with -1 might lead to incorrect results since it\\'s a valid value for the sum. You can initialize it to some value that wouldn\\'t conflict with the actual sums. \\n\\nI had initialise dp to 1e9."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Since Memoization giving  TLE on case 49 \nso use this to handle that case and your code will be submitted.\n\n```if(n==100 && matrix[0][0]==0 ) return -1 ; ```\n\nAnyway Tabulation will be accepted  so go for tabulation\n\n```HINT```\n\n"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "[@Codensity_30](/Codensity_30)  the constraints range from -100 to +100  now since your dp vector will be filled with -1 imagine it might mess up the results because of the -1 so put INT_MAX in the dp instead it will work then"
                    },
                    {
                        "username": "Codensity_30",
                        "content": "but why? I also suffered for the same, yay tabulation passed it"
                    }
                ]
            },
            {
                "id": 1932410,
                "content": [
                    {
                        "username": "makhotin",
                        "content": "If you're interested where this algo can be applied - please see [wiki page of the algo](https://en.wikipedia.org/wiki/Seam_carving), [video](https://www.youtube.com/watch?v=6NcIJXTlugc) Very cool algorithm for smart image resizing. It compute a vertical seam (path) with lowest energy using DP."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Thank! It\\'s more excited to know the \"real\" application associated with this exercise."
                    },
                    {
                        "username": "willremember2020",
                        "content": "Why is memoization solution giving tle in 49/50 testcase? But a similar tabulation solution works??"
                    },
                    {
                        "username": "vp271202",
                        "content": "[@ansh_1012](/ansh_1012)  the -1 solution will fail because if there is a case where the sum is -1 then it will give a wrong ans and if the testcase is too large then there is a chance that it will give tle rather than a wrong ans."
                    },
                    {
                        "username": "Gaurav1234Balodi",
                        "content": "[@Sandeep_Rai](/Sandeep_Rai) its simple just read the constraints -100 <= matrix[i][j] <= 100 so you cannot enter -1 it will work even if you memorize 101 "
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "[@ansh_1012](/ansh_1012) Yeah that worked but why?"
                    },
                    {
                        "username": "ak_3101",
                        "content": "[@ansh_1012](/ansh_1012) yes, but WHY\\n"
                    },
                    {
                        "username": "azad_6021",
                        "content": "[@ansh_1012](/ansh_1012)  Why\\'s this making a difference"
                    },
                    {
                        "username": "ansh_1012",
                        "content": "[@jatin_vashisht](/jatin_vashisht) memo solutions worked fine for me when i chnges the initialization of dp with INT_MAX rather than -1"
                    },
                    {
                        "username": "jatin_vashisht",
                        "content": "seems like leetcode has tightened the constraints. Bottom Up is getting accepted."
                    },
                    {
                        "username": "amanchandna",
                        "content": "coming up with an recursive solution at first is completely normal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "[@user3134m](/user3134m) interactive "
                    },
                    {
                        "username": "user3134m",
                        "content": "Is there a better solution than recursion with memorization?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This is not a solution Tab we people are posting solution in the discussion session?\\nPlease don\\'t do this.\\nTry to give some tip if possible."
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "We can clearly see that for every element on rows 1 to n, every element is (element + minimum of 3 nodes above it)\\n\\nSo, we just have to perform this O(1) calculation for every element from row 1"
                    },
                    {
                        "username": "utkarshprap",
                        "content": "Thank You Sir for this Hint\\uD83D\\uDE04"
                    },
                    {
                        "username": "priyanshurathaur001",
                        "content": "1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n9 9 8 7 6 1\\n\\nwhat was the approach for this??\\n"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "[@joshi22](/joshi22) Its my pleasure I was able to help you\\nYou made me day\\uD83D\\uDE0A"
                    },
                    {
                        "username": "joshi22",
                        "content": "im new to dp and i read this hint and it immediately clicked how to implement it. solved it in 15 mins using dp! thanks :D"
                    },
                    {
                        "username": "beyeu107",
                        "content": "can anyone please explain ! thank you !"
                    },
                    {
                        "username": "kcharris77",
                        "content": "This problem can be solved by breaking it into sub problems. Two ways to do this are starting from the top and working down, or from the bottom and working up. At least for bottom up, the subproblems involve finding the minimum of the three-ish items below an individual item."
                    },
                    {
                        "username": "Indraneel965",
                        "content": "Try recurisively First. try out every first row element and their possibilities."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@venubrt](/venubrt) Please don\\'t post any solutions in this discussion tab."
                    },
                    {
                        "username": "denisId",
                        "content": "In order to solve this you have to approach it in 3 main steps:\n>Step 1 is to decompose the problem and to think how to calculate the minimum sum for only one element in the first row\n\nlet's suppose the default example:\n\nMatrix ---\n----------------------\n    2      --  [2, 1, 3] --\n    1      --  [6, 5, 4] --\n    0      --  [7, 8, 9] --\n    --     --  0  1  2  --\n\n\nWe want to find out just the minimum path for one element from first row (let it be for example Matrix[0][1] (\"8\")):\nLet's view all possible paths\n8->6->2\n8->5->2\n8->5->1\n8->5->3\n8->4->3\nIf you observe carefully this is a tree structure, so we basically have to traverse a tree structure\n\nNow the idea is to check the min sum from the descendent nodes(leaves) and bubbling up the sum to the initial root value\n\niteration1) MinValue(6) IS \"2\" (because we don't have other values, 2 + 0)\niteration2) MinValue(5)=\"1\" (because 1 < 2 < 3)\niteration3) MinValue(4)=\"3\" (because we don't have other values, 3 + 0)\ngoing for upper node now:\niteration4) MinValue(8) IS \"14\" (because (8 + MinValue(5)) < (8 + MinValue(6)) < (8 + MinValue(4)))\n\n>Step2: When you find the min sum for only one element, we can just iterate through entire row and take the min value.\n\n>Step3:The problem now is solved, however you will encounter TimeLimit Error with pure recursion on some testcases, it's due to the fact that all subnodes are recalculated multiple times\nThe solution is to use the dynamic programing: add a sort of storage structure/cache structure(HashMap), where you can put values from subnodes and to not recalculate again the sums for visited sites, and at the same time you can get the needed values quickly(in O(1) time)"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "great expl."
                    },
                    {
                        "username": "ay8182",
                        "content": "[@tulsyanshishir](/tulsyanshishir) yes it is valid\\n"
                    },
                    {
                        "username": "romanvkj2001",
                        "content": "[@tulsyanshishir](/tulsyanshishir) and also 8->4->1?\\n"
                    },
                    {
                        "username": "tulsyanshishir",
                        "content": "May be I did not understand this properly. Is the path 8->6->1 not valid ?"
                    },
                    {
                        "username": "Sohamkayal4103",
                        "content": "Some problems are better solved by tabulation instead of memoization. Choose the methods wisely while attempting any contests. "
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": "[@gaurav_rawat369](/gaurav_rawat369) intilise vector<vector>dp(n+1,vector(n+1,-1)); as vector<vector>dp(n+1,vector(n+1,int_max)); it works fine but i am also getting tle if i set my dp -1 . can anyone explain why ?"
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "class Solution {\\nprivate:\\n    int solver(int i ,int j,int n,vector<vector<int>>&dp,vector<vector<int>>&matrix)\\n    {\\n        if(i > n || j < 0 || j > n)\\n        return 1e9;\\n        if(i == n)\\n        return matrix[i][j];\\n        if(dp[i][j] != -1)\\n        return dp[i][j];\\n        return dp[i][j] = matrix[i][j] + min(solver(i+1,j-1,n,dp,matrix),min(solver(i+1,j,n,dp,matrix),solver(i+1,j+1,n,dp,matrix)));\\n    }\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        int ans = INT_MAX;\\n        for(int i =0;i<n;i++)\\n        {\\n            ans = min(ans,solver(0,i,n-1,dp,matrix));\\n        }\\n        return ans;\\n    }\\n};\\nthis is giving me TLE in last test case\\n"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "since the values in the matrix can be both positive and negative, initializing the DP array with -1 might lead to incorrect results since it\\'s a valid value for the sum. You can initialize it to some value that wouldn\\'t conflict with the actual sums. \\n\\nI had initialise dp to 1e9."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Since Memoization giving  TLE on case 49 \nso use this to handle that case and your code will be submitted.\n\n```if(n==100 && matrix[0][0]==0 ) return -1 ; ```\n\nAnyway Tabulation will be accepted  so go for tabulation\n\n```HINT```\n\n"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "[@Codensity_30](/Codensity_30)  the constraints range from -100 to +100  now since your dp vector will be filled with -1 imagine it might mess up the results because of the -1 so put INT_MAX in the dp instead it will work then"
                    },
                    {
                        "username": "Codensity_30",
                        "content": "but why? I also suffered for the same, yay tabulation passed it"
                    }
                ]
            },
            {
                "id": 1714811,
                "content": [
                    {
                        "username": "makhotin",
                        "content": "If you're interested where this algo can be applied - please see [wiki page of the algo](https://en.wikipedia.org/wiki/Seam_carving), [video](https://www.youtube.com/watch?v=6NcIJXTlugc) Very cool algorithm for smart image resizing. It compute a vertical seam (path) with lowest energy using DP."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Thank! It\\'s more excited to know the \"real\" application associated with this exercise."
                    },
                    {
                        "username": "willremember2020",
                        "content": "Why is memoization solution giving tle in 49/50 testcase? But a similar tabulation solution works??"
                    },
                    {
                        "username": "vp271202",
                        "content": "[@ansh_1012](/ansh_1012)  the -1 solution will fail because if there is a case where the sum is -1 then it will give a wrong ans and if the testcase is too large then there is a chance that it will give tle rather than a wrong ans."
                    },
                    {
                        "username": "Gaurav1234Balodi",
                        "content": "[@Sandeep_Rai](/Sandeep_Rai) its simple just read the constraints -100 <= matrix[i][j] <= 100 so you cannot enter -1 it will work even if you memorize 101 "
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "[@ansh_1012](/ansh_1012) Yeah that worked but why?"
                    },
                    {
                        "username": "ak_3101",
                        "content": "[@ansh_1012](/ansh_1012) yes, but WHY\\n"
                    },
                    {
                        "username": "azad_6021",
                        "content": "[@ansh_1012](/ansh_1012)  Why\\'s this making a difference"
                    },
                    {
                        "username": "ansh_1012",
                        "content": "[@jatin_vashisht](/jatin_vashisht) memo solutions worked fine for me when i chnges the initialization of dp with INT_MAX rather than -1"
                    },
                    {
                        "username": "jatin_vashisht",
                        "content": "seems like leetcode has tightened the constraints. Bottom Up is getting accepted."
                    },
                    {
                        "username": "amanchandna",
                        "content": "coming up with an recursive solution at first is completely normal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "[@user3134m](/user3134m) interactive "
                    },
                    {
                        "username": "user3134m",
                        "content": "Is there a better solution than recursion with memorization?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This is not a solution Tab we people are posting solution in the discussion session?\\nPlease don\\'t do this.\\nTry to give some tip if possible."
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "We can clearly see that for every element on rows 1 to n, every element is (element + minimum of 3 nodes above it)\\n\\nSo, we just have to perform this O(1) calculation for every element from row 1"
                    },
                    {
                        "username": "utkarshprap",
                        "content": "Thank You Sir for this Hint\\uD83D\\uDE04"
                    },
                    {
                        "username": "priyanshurathaur001",
                        "content": "1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n9 9 8 7 6 1\\n\\nwhat was the approach for this??\\n"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "[@joshi22](/joshi22) Its my pleasure I was able to help you\\nYou made me day\\uD83D\\uDE0A"
                    },
                    {
                        "username": "joshi22",
                        "content": "im new to dp and i read this hint and it immediately clicked how to implement it. solved it in 15 mins using dp! thanks :D"
                    },
                    {
                        "username": "beyeu107",
                        "content": "can anyone please explain ! thank you !"
                    },
                    {
                        "username": "kcharris77",
                        "content": "This problem can be solved by breaking it into sub problems. Two ways to do this are starting from the top and working down, or from the bottom and working up. At least for bottom up, the subproblems involve finding the minimum of the three-ish items below an individual item."
                    },
                    {
                        "username": "Indraneel965",
                        "content": "Try recurisively First. try out every first row element and their possibilities."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@venubrt](/venubrt) Please don\\'t post any solutions in this discussion tab."
                    },
                    {
                        "username": "denisId",
                        "content": "In order to solve this you have to approach it in 3 main steps:\n>Step 1 is to decompose the problem and to think how to calculate the minimum sum for only one element in the first row\n\nlet's suppose the default example:\n\nMatrix ---\n----------------------\n    2      --  [2, 1, 3] --\n    1      --  [6, 5, 4] --\n    0      --  [7, 8, 9] --\n    --     --  0  1  2  --\n\n\nWe want to find out just the minimum path for one element from first row (let it be for example Matrix[0][1] (\"8\")):\nLet's view all possible paths\n8->6->2\n8->5->2\n8->5->1\n8->5->3\n8->4->3\nIf you observe carefully this is a tree structure, so we basically have to traverse a tree structure\n\nNow the idea is to check the min sum from the descendent nodes(leaves) and bubbling up the sum to the initial root value\n\niteration1) MinValue(6) IS \"2\" (because we don't have other values, 2 + 0)\niteration2) MinValue(5)=\"1\" (because 1 < 2 < 3)\niteration3) MinValue(4)=\"3\" (because we don't have other values, 3 + 0)\ngoing for upper node now:\niteration4) MinValue(8) IS \"14\" (because (8 + MinValue(5)) < (8 + MinValue(6)) < (8 + MinValue(4)))\n\n>Step2: When you find the min sum for only one element, we can just iterate through entire row and take the min value.\n\n>Step3:The problem now is solved, however you will encounter TimeLimit Error with pure recursion on some testcases, it's due to the fact that all subnodes are recalculated multiple times\nThe solution is to use the dynamic programing: add a sort of storage structure/cache structure(HashMap), where you can put values from subnodes and to not recalculate again the sums for visited sites, and at the same time you can get the needed values quickly(in O(1) time)"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "great expl."
                    },
                    {
                        "username": "ay8182",
                        "content": "[@tulsyanshishir](/tulsyanshishir) yes it is valid\\n"
                    },
                    {
                        "username": "romanvkj2001",
                        "content": "[@tulsyanshishir](/tulsyanshishir) and also 8->4->1?\\n"
                    },
                    {
                        "username": "tulsyanshishir",
                        "content": "May be I did not understand this properly. Is the path 8->6->1 not valid ?"
                    },
                    {
                        "username": "Sohamkayal4103",
                        "content": "Some problems are better solved by tabulation instead of memoization. Choose the methods wisely while attempting any contests. "
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": "[@gaurav_rawat369](/gaurav_rawat369) intilise vector<vector>dp(n+1,vector(n+1,-1)); as vector<vector>dp(n+1,vector(n+1,int_max)); it works fine but i am also getting tle if i set my dp -1 . can anyone explain why ?"
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "class Solution {\\nprivate:\\n    int solver(int i ,int j,int n,vector<vector<int>>&dp,vector<vector<int>>&matrix)\\n    {\\n        if(i > n || j < 0 || j > n)\\n        return 1e9;\\n        if(i == n)\\n        return matrix[i][j];\\n        if(dp[i][j] != -1)\\n        return dp[i][j];\\n        return dp[i][j] = matrix[i][j] + min(solver(i+1,j-1,n,dp,matrix),min(solver(i+1,j,n,dp,matrix),solver(i+1,j+1,n,dp,matrix)));\\n    }\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        int ans = INT_MAX;\\n        for(int i =0;i<n;i++)\\n        {\\n            ans = min(ans,solver(0,i,n-1,dp,matrix));\\n        }\\n        return ans;\\n    }\\n};\\nthis is giving me TLE in last test case\\n"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "since the values in the matrix can be both positive and negative, initializing the DP array with -1 might lead to incorrect results since it\\'s a valid value for the sum. You can initialize it to some value that wouldn\\'t conflict with the actual sums. \\n\\nI had initialise dp to 1e9."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Since Memoization giving  TLE on case 49 \nso use this to handle that case and your code will be submitted.\n\n```if(n==100 && matrix[0][0]==0 ) return -1 ; ```\n\nAnyway Tabulation will be accepted  so go for tabulation\n\n```HINT```\n\n"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "[@Codensity_30](/Codensity_30)  the constraints range from -100 to +100  now since your dp vector will be filled with -1 imagine it might mess up the results because of the -1 so put INT_MAX in the dp instead it will work then"
                    },
                    {
                        "username": "Codensity_30",
                        "content": "but why? I also suffered for the same, yay tabulation passed it"
                    }
                ]
            },
            {
                "id": 1715130,
                "content": [
                    {
                        "username": "makhotin",
                        "content": "If you're interested where this algo can be applied - please see [wiki page of the algo](https://en.wikipedia.org/wiki/Seam_carving), [video](https://www.youtube.com/watch?v=6NcIJXTlugc) Very cool algorithm for smart image resizing. It compute a vertical seam (path) with lowest energy using DP."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Thank! It\\'s more excited to know the \"real\" application associated with this exercise."
                    },
                    {
                        "username": "willremember2020",
                        "content": "Why is memoization solution giving tle in 49/50 testcase? But a similar tabulation solution works??"
                    },
                    {
                        "username": "vp271202",
                        "content": "[@ansh_1012](/ansh_1012)  the -1 solution will fail because if there is a case where the sum is -1 then it will give a wrong ans and if the testcase is too large then there is a chance that it will give tle rather than a wrong ans."
                    },
                    {
                        "username": "Gaurav1234Balodi",
                        "content": "[@Sandeep_Rai](/Sandeep_Rai) its simple just read the constraints -100 <= matrix[i][j] <= 100 so you cannot enter -1 it will work even if you memorize 101 "
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "[@ansh_1012](/ansh_1012) Yeah that worked but why?"
                    },
                    {
                        "username": "ak_3101",
                        "content": "[@ansh_1012](/ansh_1012) yes, but WHY\\n"
                    },
                    {
                        "username": "azad_6021",
                        "content": "[@ansh_1012](/ansh_1012)  Why\\'s this making a difference"
                    },
                    {
                        "username": "ansh_1012",
                        "content": "[@jatin_vashisht](/jatin_vashisht) memo solutions worked fine for me when i chnges the initialization of dp with INT_MAX rather than -1"
                    },
                    {
                        "username": "jatin_vashisht",
                        "content": "seems like leetcode has tightened the constraints. Bottom Up is getting accepted."
                    },
                    {
                        "username": "amanchandna",
                        "content": "coming up with an recursive solution at first is completely normal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "[@user3134m](/user3134m) interactive "
                    },
                    {
                        "username": "user3134m",
                        "content": "Is there a better solution than recursion with memorization?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This is not a solution Tab we people are posting solution in the discussion session?\\nPlease don\\'t do this.\\nTry to give some tip if possible."
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "We can clearly see that for every element on rows 1 to n, every element is (element + minimum of 3 nodes above it)\\n\\nSo, we just have to perform this O(1) calculation for every element from row 1"
                    },
                    {
                        "username": "utkarshprap",
                        "content": "Thank You Sir for this Hint\\uD83D\\uDE04"
                    },
                    {
                        "username": "priyanshurathaur001",
                        "content": "1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n9 9 8 7 6 1\\n\\nwhat was the approach for this??\\n"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "[@joshi22](/joshi22) Its my pleasure I was able to help you\\nYou made me day\\uD83D\\uDE0A"
                    },
                    {
                        "username": "joshi22",
                        "content": "im new to dp and i read this hint and it immediately clicked how to implement it. solved it in 15 mins using dp! thanks :D"
                    },
                    {
                        "username": "beyeu107",
                        "content": "can anyone please explain ! thank you !"
                    },
                    {
                        "username": "kcharris77",
                        "content": "This problem can be solved by breaking it into sub problems. Two ways to do this are starting from the top and working down, or from the bottom and working up. At least for bottom up, the subproblems involve finding the minimum of the three-ish items below an individual item."
                    },
                    {
                        "username": "Indraneel965",
                        "content": "Try recurisively First. try out every first row element and their possibilities."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@venubrt](/venubrt) Please don\\'t post any solutions in this discussion tab."
                    },
                    {
                        "username": "denisId",
                        "content": "In order to solve this you have to approach it in 3 main steps:\n>Step 1 is to decompose the problem and to think how to calculate the minimum sum for only one element in the first row\n\nlet's suppose the default example:\n\nMatrix ---\n----------------------\n    2      --  [2, 1, 3] --\n    1      --  [6, 5, 4] --\n    0      --  [7, 8, 9] --\n    --     --  0  1  2  --\n\n\nWe want to find out just the minimum path for one element from first row (let it be for example Matrix[0][1] (\"8\")):\nLet's view all possible paths\n8->6->2\n8->5->2\n8->5->1\n8->5->3\n8->4->3\nIf you observe carefully this is a tree structure, so we basically have to traverse a tree structure\n\nNow the idea is to check the min sum from the descendent nodes(leaves) and bubbling up the sum to the initial root value\n\niteration1) MinValue(6) IS \"2\" (because we don't have other values, 2 + 0)\niteration2) MinValue(5)=\"1\" (because 1 < 2 < 3)\niteration3) MinValue(4)=\"3\" (because we don't have other values, 3 + 0)\ngoing for upper node now:\niteration4) MinValue(8) IS \"14\" (because (8 + MinValue(5)) < (8 + MinValue(6)) < (8 + MinValue(4)))\n\n>Step2: When you find the min sum for only one element, we can just iterate through entire row and take the min value.\n\n>Step3:The problem now is solved, however you will encounter TimeLimit Error with pure recursion on some testcases, it's due to the fact that all subnodes are recalculated multiple times\nThe solution is to use the dynamic programing: add a sort of storage structure/cache structure(HashMap), where you can put values from subnodes and to not recalculate again the sums for visited sites, and at the same time you can get the needed values quickly(in O(1) time)"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "great expl."
                    },
                    {
                        "username": "ay8182",
                        "content": "[@tulsyanshishir](/tulsyanshishir) yes it is valid\\n"
                    },
                    {
                        "username": "romanvkj2001",
                        "content": "[@tulsyanshishir](/tulsyanshishir) and also 8->4->1?\\n"
                    },
                    {
                        "username": "tulsyanshishir",
                        "content": "May be I did not understand this properly. Is the path 8->6->1 not valid ?"
                    },
                    {
                        "username": "Sohamkayal4103",
                        "content": "Some problems are better solved by tabulation instead of memoization. Choose the methods wisely while attempting any contests. "
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": "[@gaurav_rawat369](/gaurav_rawat369) intilise vector<vector>dp(n+1,vector(n+1,-1)); as vector<vector>dp(n+1,vector(n+1,int_max)); it works fine but i am also getting tle if i set my dp -1 . can anyone explain why ?"
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "class Solution {\\nprivate:\\n    int solver(int i ,int j,int n,vector<vector<int>>&dp,vector<vector<int>>&matrix)\\n    {\\n        if(i > n || j < 0 || j > n)\\n        return 1e9;\\n        if(i == n)\\n        return matrix[i][j];\\n        if(dp[i][j] != -1)\\n        return dp[i][j];\\n        return dp[i][j] = matrix[i][j] + min(solver(i+1,j-1,n,dp,matrix),min(solver(i+1,j,n,dp,matrix),solver(i+1,j+1,n,dp,matrix)));\\n    }\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        int ans = INT_MAX;\\n        for(int i =0;i<n;i++)\\n        {\\n            ans = min(ans,solver(0,i,n-1,dp,matrix));\\n        }\\n        return ans;\\n    }\\n};\\nthis is giving me TLE in last test case\\n"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "since the values in the matrix can be both positive and negative, initializing the DP array with -1 might lead to incorrect results since it\\'s a valid value for the sum. You can initialize it to some value that wouldn\\'t conflict with the actual sums. \\n\\nI had initialise dp to 1e9."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Since Memoization giving  TLE on case 49 \nso use this to handle that case and your code will be submitted.\n\n```if(n==100 && matrix[0][0]==0 ) return -1 ; ```\n\nAnyway Tabulation will be accepted  so go for tabulation\n\n```HINT```\n\n"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "[@Codensity_30](/Codensity_30)  the constraints range from -100 to +100  now since your dp vector will be filled with -1 imagine it might mess up the results because of the -1 so put INT_MAX in the dp instead it will work then"
                    },
                    {
                        "username": "Codensity_30",
                        "content": "but why? I also suffered for the same, yay tabulation passed it"
                    }
                ]
            },
            {
                "id": 1714791,
                "content": [
                    {
                        "username": "makhotin",
                        "content": "If you're interested where this algo can be applied - please see [wiki page of the algo](https://en.wikipedia.org/wiki/Seam_carving), [video](https://www.youtube.com/watch?v=6NcIJXTlugc) Very cool algorithm for smart image resizing. It compute a vertical seam (path) with lowest energy using DP."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Thank! It\\'s more excited to know the \"real\" application associated with this exercise."
                    },
                    {
                        "username": "willremember2020",
                        "content": "Why is memoization solution giving tle in 49/50 testcase? But a similar tabulation solution works??"
                    },
                    {
                        "username": "vp271202",
                        "content": "[@ansh_1012](/ansh_1012)  the -1 solution will fail because if there is a case where the sum is -1 then it will give a wrong ans and if the testcase is too large then there is a chance that it will give tle rather than a wrong ans."
                    },
                    {
                        "username": "Gaurav1234Balodi",
                        "content": "[@Sandeep_Rai](/Sandeep_Rai) its simple just read the constraints -100 <= matrix[i][j] <= 100 so you cannot enter -1 it will work even if you memorize 101 "
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "[@ansh_1012](/ansh_1012) Yeah that worked but why?"
                    },
                    {
                        "username": "ak_3101",
                        "content": "[@ansh_1012](/ansh_1012) yes, but WHY\\n"
                    },
                    {
                        "username": "azad_6021",
                        "content": "[@ansh_1012](/ansh_1012)  Why\\'s this making a difference"
                    },
                    {
                        "username": "ansh_1012",
                        "content": "[@jatin_vashisht](/jatin_vashisht) memo solutions worked fine for me when i chnges the initialization of dp with INT_MAX rather than -1"
                    },
                    {
                        "username": "jatin_vashisht",
                        "content": "seems like leetcode has tightened the constraints. Bottom Up is getting accepted."
                    },
                    {
                        "username": "amanchandna",
                        "content": "coming up with an recursive solution at first is completely normal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "[@user3134m](/user3134m) interactive "
                    },
                    {
                        "username": "user3134m",
                        "content": "Is there a better solution than recursion with memorization?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This is not a solution Tab we people are posting solution in the discussion session?\\nPlease don\\'t do this.\\nTry to give some tip if possible."
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "We can clearly see that for every element on rows 1 to n, every element is (element + minimum of 3 nodes above it)\\n\\nSo, we just have to perform this O(1) calculation for every element from row 1"
                    },
                    {
                        "username": "utkarshprap",
                        "content": "Thank You Sir for this Hint\\uD83D\\uDE04"
                    },
                    {
                        "username": "priyanshurathaur001",
                        "content": "1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n9 9 8 7 6 1\\n\\nwhat was the approach for this??\\n"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "[@joshi22](/joshi22) Its my pleasure I was able to help you\\nYou made me day\\uD83D\\uDE0A"
                    },
                    {
                        "username": "joshi22",
                        "content": "im new to dp and i read this hint and it immediately clicked how to implement it. solved it in 15 mins using dp! thanks :D"
                    },
                    {
                        "username": "beyeu107",
                        "content": "can anyone please explain ! thank you !"
                    },
                    {
                        "username": "kcharris77",
                        "content": "This problem can be solved by breaking it into sub problems. Two ways to do this are starting from the top and working down, or from the bottom and working up. At least for bottom up, the subproblems involve finding the minimum of the three-ish items below an individual item."
                    },
                    {
                        "username": "Indraneel965",
                        "content": "Try recurisively First. try out every first row element and their possibilities."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@venubrt](/venubrt) Please don\\'t post any solutions in this discussion tab."
                    },
                    {
                        "username": "denisId",
                        "content": "In order to solve this you have to approach it in 3 main steps:\n>Step 1 is to decompose the problem and to think how to calculate the minimum sum for only one element in the first row\n\nlet's suppose the default example:\n\nMatrix ---\n----------------------\n    2      --  [2, 1, 3] --\n    1      --  [6, 5, 4] --\n    0      --  [7, 8, 9] --\n    --     --  0  1  2  --\n\n\nWe want to find out just the minimum path for one element from first row (let it be for example Matrix[0][1] (\"8\")):\nLet's view all possible paths\n8->6->2\n8->5->2\n8->5->1\n8->5->3\n8->4->3\nIf you observe carefully this is a tree structure, so we basically have to traverse a tree structure\n\nNow the idea is to check the min sum from the descendent nodes(leaves) and bubbling up the sum to the initial root value\n\niteration1) MinValue(6) IS \"2\" (because we don't have other values, 2 + 0)\niteration2) MinValue(5)=\"1\" (because 1 < 2 < 3)\niteration3) MinValue(4)=\"3\" (because we don't have other values, 3 + 0)\ngoing for upper node now:\niteration4) MinValue(8) IS \"14\" (because (8 + MinValue(5)) < (8 + MinValue(6)) < (8 + MinValue(4)))\n\n>Step2: When you find the min sum for only one element, we can just iterate through entire row and take the min value.\n\n>Step3:The problem now is solved, however you will encounter TimeLimit Error with pure recursion on some testcases, it's due to the fact that all subnodes are recalculated multiple times\nThe solution is to use the dynamic programing: add a sort of storage structure/cache structure(HashMap), where you can put values from subnodes and to not recalculate again the sums for visited sites, and at the same time you can get the needed values quickly(in O(1) time)"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "great expl."
                    },
                    {
                        "username": "ay8182",
                        "content": "[@tulsyanshishir](/tulsyanshishir) yes it is valid\\n"
                    },
                    {
                        "username": "romanvkj2001",
                        "content": "[@tulsyanshishir](/tulsyanshishir) and also 8->4->1?\\n"
                    },
                    {
                        "username": "tulsyanshishir",
                        "content": "May be I did not understand this properly. Is the path 8->6->1 not valid ?"
                    },
                    {
                        "username": "Sohamkayal4103",
                        "content": "Some problems are better solved by tabulation instead of memoization. Choose the methods wisely while attempting any contests. "
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": "[@gaurav_rawat369](/gaurav_rawat369) intilise vector<vector>dp(n+1,vector(n+1,-1)); as vector<vector>dp(n+1,vector(n+1,int_max)); it works fine but i am also getting tle if i set my dp -1 . can anyone explain why ?"
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "class Solution {\\nprivate:\\n    int solver(int i ,int j,int n,vector<vector<int>>&dp,vector<vector<int>>&matrix)\\n    {\\n        if(i > n || j < 0 || j > n)\\n        return 1e9;\\n        if(i == n)\\n        return matrix[i][j];\\n        if(dp[i][j] != -1)\\n        return dp[i][j];\\n        return dp[i][j] = matrix[i][j] + min(solver(i+1,j-1,n,dp,matrix),min(solver(i+1,j,n,dp,matrix),solver(i+1,j+1,n,dp,matrix)));\\n    }\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        int ans = INT_MAX;\\n        for(int i =0;i<n;i++)\\n        {\\n            ans = min(ans,solver(0,i,n-1,dp,matrix));\\n        }\\n        return ans;\\n    }\\n};\\nthis is giving me TLE in last test case\\n"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "since the values in the matrix can be both positive and negative, initializing the DP array with -1 might lead to incorrect results since it\\'s a valid value for the sum. You can initialize it to some value that wouldn\\'t conflict with the actual sums. \\n\\nI had initialise dp to 1e9."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Since Memoization giving  TLE on case 49 \nso use this to handle that case and your code will be submitted.\n\n```if(n==100 && matrix[0][0]==0 ) return -1 ; ```\n\nAnyway Tabulation will be accepted  so go for tabulation\n\n```HINT```\n\n"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "[@Codensity_30](/Codensity_30)  the constraints range from -100 to +100  now since your dp vector will be filled with -1 imagine it might mess up the results because of the -1 so put INT_MAX in the dp instead it will work then"
                    },
                    {
                        "username": "Codensity_30",
                        "content": "but why? I also suffered for the same, yay tabulation passed it"
                    }
                ]
            },
            {
                "id": 1568079,
                "content": [
                    {
                        "username": "makhotin",
                        "content": "If you're interested where this algo can be applied - please see [wiki page of the algo](https://en.wikipedia.org/wiki/Seam_carving), [video](https://www.youtube.com/watch?v=6NcIJXTlugc) Very cool algorithm for smart image resizing. It compute a vertical seam (path) with lowest energy using DP."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Thank! It\\'s more excited to know the \"real\" application associated with this exercise."
                    },
                    {
                        "username": "willremember2020",
                        "content": "Why is memoization solution giving tle in 49/50 testcase? But a similar tabulation solution works??"
                    },
                    {
                        "username": "vp271202",
                        "content": "[@ansh_1012](/ansh_1012)  the -1 solution will fail because if there is a case where the sum is -1 then it will give a wrong ans and if the testcase is too large then there is a chance that it will give tle rather than a wrong ans."
                    },
                    {
                        "username": "Gaurav1234Balodi",
                        "content": "[@Sandeep_Rai](/Sandeep_Rai) its simple just read the constraints -100 <= matrix[i][j] <= 100 so you cannot enter -1 it will work even if you memorize 101 "
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "[@ansh_1012](/ansh_1012) Yeah that worked but why?"
                    },
                    {
                        "username": "ak_3101",
                        "content": "[@ansh_1012](/ansh_1012) yes, but WHY\\n"
                    },
                    {
                        "username": "azad_6021",
                        "content": "[@ansh_1012](/ansh_1012)  Why\\'s this making a difference"
                    },
                    {
                        "username": "ansh_1012",
                        "content": "[@jatin_vashisht](/jatin_vashisht) memo solutions worked fine for me when i chnges the initialization of dp with INT_MAX rather than -1"
                    },
                    {
                        "username": "jatin_vashisht",
                        "content": "seems like leetcode has tightened the constraints. Bottom Up is getting accepted."
                    },
                    {
                        "username": "amanchandna",
                        "content": "coming up with an recursive solution at first is completely normal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "[@user3134m](/user3134m) interactive "
                    },
                    {
                        "username": "user3134m",
                        "content": "Is there a better solution than recursion with memorization?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This is not a solution Tab we people are posting solution in the discussion session?\\nPlease don\\'t do this.\\nTry to give some tip if possible."
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "We can clearly see that for every element on rows 1 to n, every element is (element + minimum of 3 nodes above it)\\n\\nSo, we just have to perform this O(1) calculation for every element from row 1"
                    },
                    {
                        "username": "utkarshprap",
                        "content": "Thank You Sir for this Hint\\uD83D\\uDE04"
                    },
                    {
                        "username": "priyanshurathaur001",
                        "content": "1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n9 9 8 7 6 1\\n\\nwhat was the approach for this??\\n"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "[@joshi22](/joshi22) Its my pleasure I was able to help you\\nYou made me day\\uD83D\\uDE0A"
                    },
                    {
                        "username": "joshi22",
                        "content": "im new to dp and i read this hint and it immediately clicked how to implement it. solved it in 15 mins using dp! thanks :D"
                    },
                    {
                        "username": "beyeu107",
                        "content": "can anyone please explain ! thank you !"
                    },
                    {
                        "username": "kcharris77",
                        "content": "This problem can be solved by breaking it into sub problems. Two ways to do this are starting from the top and working down, or from the bottom and working up. At least for bottom up, the subproblems involve finding the minimum of the three-ish items below an individual item."
                    },
                    {
                        "username": "Indraneel965",
                        "content": "Try recurisively First. try out every first row element and their possibilities."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@venubrt](/venubrt) Please don\\'t post any solutions in this discussion tab."
                    },
                    {
                        "username": "denisId",
                        "content": "In order to solve this you have to approach it in 3 main steps:\n>Step 1 is to decompose the problem and to think how to calculate the minimum sum for only one element in the first row\n\nlet's suppose the default example:\n\nMatrix ---\n----------------------\n    2      --  [2, 1, 3] --\n    1      --  [6, 5, 4] --\n    0      --  [7, 8, 9] --\n    --     --  0  1  2  --\n\n\nWe want to find out just the minimum path for one element from first row (let it be for example Matrix[0][1] (\"8\")):\nLet's view all possible paths\n8->6->2\n8->5->2\n8->5->1\n8->5->3\n8->4->3\nIf you observe carefully this is a tree structure, so we basically have to traverse a tree structure\n\nNow the idea is to check the min sum from the descendent nodes(leaves) and bubbling up the sum to the initial root value\n\niteration1) MinValue(6) IS \"2\" (because we don't have other values, 2 + 0)\niteration2) MinValue(5)=\"1\" (because 1 < 2 < 3)\niteration3) MinValue(4)=\"3\" (because we don't have other values, 3 + 0)\ngoing for upper node now:\niteration4) MinValue(8) IS \"14\" (because (8 + MinValue(5)) < (8 + MinValue(6)) < (8 + MinValue(4)))\n\n>Step2: When you find the min sum for only one element, we can just iterate through entire row and take the min value.\n\n>Step3:The problem now is solved, however you will encounter TimeLimit Error with pure recursion on some testcases, it's due to the fact that all subnodes are recalculated multiple times\nThe solution is to use the dynamic programing: add a sort of storage structure/cache structure(HashMap), where you can put values from subnodes and to not recalculate again the sums for visited sites, and at the same time you can get the needed values quickly(in O(1) time)"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "great expl."
                    },
                    {
                        "username": "ay8182",
                        "content": "[@tulsyanshishir](/tulsyanshishir) yes it is valid\\n"
                    },
                    {
                        "username": "romanvkj2001",
                        "content": "[@tulsyanshishir](/tulsyanshishir) and also 8->4->1?\\n"
                    },
                    {
                        "username": "tulsyanshishir",
                        "content": "May be I did not understand this properly. Is the path 8->6->1 not valid ?"
                    },
                    {
                        "username": "Sohamkayal4103",
                        "content": "Some problems are better solved by tabulation instead of memoization. Choose the methods wisely while attempting any contests. "
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": "[@gaurav_rawat369](/gaurav_rawat369) intilise vector<vector>dp(n+1,vector(n+1,-1)); as vector<vector>dp(n+1,vector(n+1,int_max)); it works fine but i am also getting tle if i set my dp -1 . can anyone explain why ?"
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "class Solution {\\nprivate:\\n    int solver(int i ,int j,int n,vector<vector<int>>&dp,vector<vector<int>>&matrix)\\n    {\\n        if(i > n || j < 0 || j > n)\\n        return 1e9;\\n        if(i == n)\\n        return matrix[i][j];\\n        if(dp[i][j] != -1)\\n        return dp[i][j];\\n        return dp[i][j] = matrix[i][j] + min(solver(i+1,j-1,n,dp,matrix),min(solver(i+1,j,n,dp,matrix),solver(i+1,j+1,n,dp,matrix)));\\n    }\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        int ans = INT_MAX;\\n        for(int i =0;i<n;i++)\\n        {\\n            ans = min(ans,solver(0,i,n-1,dp,matrix));\\n        }\\n        return ans;\\n    }\\n};\\nthis is giving me TLE in last test case\\n"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "since the values in the matrix can be both positive and negative, initializing the DP array with -1 might lead to incorrect results since it\\'s a valid value for the sum. You can initialize it to some value that wouldn\\'t conflict with the actual sums. \\n\\nI had initialise dp to 1e9."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Since Memoization giving  TLE on case 49 \nso use this to handle that case and your code will be submitted.\n\n```if(n==100 && matrix[0][0]==0 ) return -1 ; ```\n\nAnyway Tabulation will be accepted  so go for tabulation\n\n```HINT```\n\n"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "[@Codensity_30](/Codensity_30)  the constraints range from -100 to +100  now since your dp vector will be filled with -1 imagine it might mess up the results because of the -1 so put INT_MAX in the dp instead it will work then"
                    },
                    {
                        "username": "Codensity_30",
                        "content": "but why? I also suffered for the same, yay tabulation passed it"
                    }
                ]
            },
            {
                "id": 1711243,
                "content": [
                    {
                        "username": "makhotin",
                        "content": "If you're interested where this algo can be applied - please see [wiki page of the algo](https://en.wikipedia.org/wiki/Seam_carving), [video](https://www.youtube.com/watch?v=6NcIJXTlugc) Very cool algorithm for smart image resizing. It compute a vertical seam (path) with lowest energy using DP."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Thank! It\\'s more excited to know the \"real\" application associated with this exercise."
                    },
                    {
                        "username": "willremember2020",
                        "content": "Why is memoization solution giving tle in 49/50 testcase? But a similar tabulation solution works??"
                    },
                    {
                        "username": "vp271202",
                        "content": "[@ansh_1012](/ansh_1012)  the -1 solution will fail because if there is a case where the sum is -1 then it will give a wrong ans and if the testcase is too large then there is a chance that it will give tle rather than a wrong ans."
                    },
                    {
                        "username": "Gaurav1234Balodi",
                        "content": "[@Sandeep_Rai](/Sandeep_Rai) its simple just read the constraints -100 <= matrix[i][j] <= 100 so you cannot enter -1 it will work even if you memorize 101 "
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "[@ansh_1012](/ansh_1012) Yeah that worked but why?"
                    },
                    {
                        "username": "ak_3101",
                        "content": "[@ansh_1012](/ansh_1012) yes, but WHY\\n"
                    },
                    {
                        "username": "azad_6021",
                        "content": "[@ansh_1012](/ansh_1012)  Why\\'s this making a difference"
                    },
                    {
                        "username": "ansh_1012",
                        "content": "[@jatin_vashisht](/jatin_vashisht) memo solutions worked fine for me when i chnges the initialization of dp with INT_MAX rather than -1"
                    },
                    {
                        "username": "jatin_vashisht",
                        "content": "seems like leetcode has tightened the constraints. Bottom Up is getting accepted."
                    },
                    {
                        "username": "amanchandna",
                        "content": "coming up with an recursive solution at first is completely normal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "[@user3134m](/user3134m) interactive "
                    },
                    {
                        "username": "user3134m",
                        "content": "Is there a better solution than recursion with memorization?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This is not a solution Tab we people are posting solution in the discussion session?\\nPlease don\\'t do this.\\nTry to give some tip if possible."
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "We can clearly see that for every element on rows 1 to n, every element is (element + minimum of 3 nodes above it)\\n\\nSo, we just have to perform this O(1) calculation for every element from row 1"
                    },
                    {
                        "username": "utkarshprap",
                        "content": "Thank You Sir for this Hint\\uD83D\\uDE04"
                    },
                    {
                        "username": "priyanshurathaur001",
                        "content": "1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n9 9 8 7 6 1\\n\\nwhat was the approach for this??\\n"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "[@joshi22](/joshi22) Its my pleasure I was able to help you\\nYou made me day\\uD83D\\uDE0A"
                    },
                    {
                        "username": "joshi22",
                        "content": "im new to dp and i read this hint and it immediately clicked how to implement it. solved it in 15 mins using dp! thanks :D"
                    },
                    {
                        "username": "beyeu107",
                        "content": "can anyone please explain ! thank you !"
                    },
                    {
                        "username": "kcharris77",
                        "content": "This problem can be solved by breaking it into sub problems. Two ways to do this are starting from the top and working down, or from the bottom and working up. At least for bottom up, the subproblems involve finding the minimum of the three-ish items below an individual item."
                    },
                    {
                        "username": "Indraneel965",
                        "content": "Try recurisively First. try out every first row element and their possibilities."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@venubrt](/venubrt) Please don\\'t post any solutions in this discussion tab."
                    },
                    {
                        "username": "denisId",
                        "content": "In order to solve this you have to approach it in 3 main steps:\n>Step 1 is to decompose the problem and to think how to calculate the minimum sum for only one element in the first row\n\nlet's suppose the default example:\n\nMatrix ---\n----------------------\n    2      --  [2, 1, 3] --\n    1      --  [6, 5, 4] --\n    0      --  [7, 8, 9] --\n    --     --  0  1  2  --\n\n\nWe want to find out just the minimum path for one element from first row (let it be for example Matrix[0][1] (\"8\")):\nLet's view all possible paths\n8->6->2\n8->5->2\n8->5->1\n8->5->3\n8->4->3\nIf you observe carefully this is a tree structure, so we basically have to traverse a tree structure\n\nNow the idea is to check the min sum from the descendent nodes(leaves) and bubbling up the sum to the initial root value\n\niteration1) MinValue(6) IS \"2\" (because we don't have other values, 2 + 0)\niteration2) MinValue(5)=\"1\" (because 1 < 2 < 3)\niteration3) MinValue(4)=\"3\" (because we don't have other values, 3 + 0)\ngoing for upper node now:\niteration4) MinValue(8) IS \"14\" (because (8 + MinValue(5)) < (8 + MinValue(6)) < (8 + MinValue(4)))\n\n>Step2: When you find the min sum for only one element, we can just iterate through entire row and take the min value.\n\n>Step3:The problem now is solved, however you will encounter TimeLimit Error with pure recursion on some testcases, it's due to the fact that all subnodes are recalculated multiple times\nThe solution is to use the dynamic programing: add a sort of storage structure/cache structure(HashMap), where you can put values from subnodes and to not recalculate again the sums for visited sites, and at the same time you can get the needed values quickly(in O(1) time)"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "great expl."
                    },
                    {
                        "username": "ay8182",
                        "content": "[@tulsyanshishir](/tulsyanshishir) yes it is valid\\n"
                    },
                    {
                        "username": "romanvkj2001",
                        "content": "[@tulsyanshishir](/tulsyanshishir) and also 8->4->1?\\n"
                    },
                    {
                        "username": "tulsyanshishir",
                        "content": "May be I did not understand this properly. Is the path 8->6->1 not valid ?"
                    },
                    {
                        "username": "Sohamkayal4103",
                        "content": "Some problems are better solved by tabulation instead of memoization. Choose the methods wisely while attempting any contests. "
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": "[@gaurav_rawat369](/gaurav_rawat369) intilise vector<vector>dp(n+1,vector(n+1,-1)); as vector<vector>dp(n+1,vector(n+1,int_max)); it works fine but i am also getting tle if i set my dp -1 . can anyone explain why ?"
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "class Solution {\\nprivate:\\n    int solver(int i ,int j,int n,vector<vector<int>>&dp,vector<vector<int>>&matrix)\\n    {\\n        if(i > n || j < 0 || j > n)\\n        return 1e9;\\n        if(i == n)\\n        return matrix[i][j];\\n        if(dp[i][j] != -1)\\n        return dp[i][j];\\n        return dp[i][j] = matrix[i][j] + min(solver(i+1,j-1,n,dp,matrix),min(solver(i+1,j,n,dp,matrix),solver(i+1,j+1,n,dp,matrix)));\\n    }\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        int ans = INT_MAX;\\n        for(int i =0;i<n;i++)\\n        {\\n            ans = min(ans,solver(0,i,n-1,dp,matrix));\\n        }\\n        return ans;\\n    }\\n};\\nthis is giving me TLE in last test case\\n"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "since the values in the matrix can be both positive and negative, initializing the DP array with -1 might lead to incorrect results since it\\'s a valid value for the sum. You can initialize it to some value that wouldn\\'t conflict with the actual sums. \\n\\nI had initialise dp to 1e9."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Since Memoization giving  TLE on case 49 \nso use this to handle that case and your code will be submitted.\n\n```if(n==100 && matrix[0][0]==0 ) return -1 ; ```\n\nAnyway Tabulation will be accepted  so go for tabulation\n\n```HINT```\n\n"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "[@Codensity_30](/Codensity_30)  the constraints range from -100 to +100  now since your dp vector will be filled with -1 imagine it might mess up the results because of the -1 so put INT_MAX in the dp instead it will work then"
                    },
                    {
                        "username": "Codensity_30",
                        "content": "but why? I also suffered for the same, yay tabulation passed it"
                    }
                ]
            },
            {
                "id": 1714687,
                "content": [
                    {
                        "username": "makhotin",
                        "content": "If you're interested where this algo can be applied - please see [wiki page of the algo](https://en.wikipedia.org/wiki/Seam_carving), [video](https://www.youtube.com/watch?v=6NcIJXTlugc) Very cool algorithm for smart image resizing. It compute a vertical seam (path) with lowest energy using DP."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Thank! It\\'s more excited to know the \"real\" application associated with this exercise."
                    },
                    {
                        "username": "willremember2020",
                        "content": "Why is memoization solution giving tle in 49/50 testcase? But a similar tabulation solution works??"
                    },
                    {
                        "username": "vp271202",
                        "content": "[@ansh_1012](/ansh_1012)  the -1 solution will fail because if there is a case where the sum is -1 then it will give a wrong ans and if the testcase is too large then there is a chance that it will give tle rather than a wrong ans."
                    },
                    {
                        "username": "Gaurav1234Balodi",
                        "content": "[@Sandeep_Rai](/Sandeep_Rai) its simple just read the constraints -100 <= matrix[i][j] <= 100 so you cannot enter -1 it will work even if you memorize 101 "
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "[@ansh_1012](/ansh_1012) Yeah that worked but why?"
                    },
                    {
                        "username": "ak_3101",
                        "content": "[@ansh_1012](/ansh_1012) yes, but WHY\\n"
                    },
                    {
                        "username": "azad_6021",
                        "content": "[@ansh_1012](/ansh_1012)  Why\\'s this making a difference"
                    },
                    {
                        "username": "ansh_1012",
                        "content": "[@jatin_vashisht](/jatin_vashisht) memo solutions worked fine for me when i chnges the initialization of dp with INT_MAX rather than -1"
                    },
                    {
                        "username": "jatin_vashisht",
                        "content": "seems like leetcode has tightened the constraints. Bottom Up is getting accepted."
                    },
                    {
                        "username": "amanchandna",
                        "content": "coming up with an recursive solution at first is completely normal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "[@user3134m](/user3134m) interactive "
                    },
                    {
                        "username": "user3134m",
                        "content": "Is there a better solution than recursion with memorization?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This is not a solution Tab we people are posting solution in the discussion session?\\nPlease don\\'t do this.\\nTry to give some tip if possible."
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "We can clearly see that for every element on rows 1 to n, every element is (element + minimum of 3 nodes above it)\\n\\nSo, we just have to perform this O(1) calculation for every element from row 1"
                    },
                    {
                        "username": "utkarshprap",
                        "content": "Thank You Sir for this Hint\\uD83D\\uDE04"
                    },
                    {
                        "username": "priyanshurathaur001",
                        "content": "1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n9 9 8 7 6 1\\n\\nwhat was the approach for this??\\n"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "[@joshi22](/joshi22) Its my pleasure I was able to help you\\nYou made me day\\uD83D\\uDE0A"
                    },
                    {
                        "username": "joshi22",
                        "content": "im new to dp and i read this hint and it immediately clicked how to implement it. solved it in 15 mins using dp! thanks :D"
                    },
                    {
                        "username": "beyeu107",
                        "content": "can anyone please explain ! thank you !"
                    },
                    {
                        "username": "kcharris77",
                        "content": "This problem can be solved by breaking it into sub problems. Two ways to do this are starting from the top and working down, or from the bottom and working up. At least for bottom up, the subproblems involve finding the minimum of the three-ish items below an individual item."
                    },
                    {
                        "username": "Indraneel965",
                        "content": "Try recurisively First. try out every first row element and their possibilities."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@venubrt](/venubrt) Please don\\'t post any solutions in this discussion tab."
                    },
                    {
                        "username": "denisId",
                        "content": "In order to solve this you have to approach it in 3 main steps:\n>Step 1 is to decompose the problem and to think how to calculate the minimum sum for only one element in the first row\n\nlet's suppose the default example:\n\nMatrix ---\n----------------------\n    2      --  [2, 1, 3] --\n    1      --  [6, 5, 4] --\n    0      --  [7, 8, 9] --\n    --     --  0  1  2  --\n\n\nWe want to find out just the minimum path for one element from first row (let it be for example Matrix[0][1] (\"8\")):\nLet's view all possible paths\n8->6->2\n8->5->2\n8->5->1\n8->5->3\n8->4->3\nIf you observe carefully this is a tree structure, so we basically have to traverse a tree structure\n\nNow the idea is to check the min sum from the descendent nodes(leaves) and bubbling up the sum to the initial root value\n\niteration1) MinValue(6) IS \"2\" (because we don't have other values, 2 + 0)\niteration2) MinValue(5)=\"1\" (because 1 < 2 < 3)\niteration3) MinValue(4)=\"3\" (because we don't have other values, 3 + 0)\ngoing for upper node now:\niteration4) MinValue(8) IS \"14\" (because (8 + MinValue(5)) < (8 + MinValue(6)) < (8 + MinValue(4)))\n\n>Step2: When you find the min sum for only one element, we can just iterate through entire row and take the min value.\n\n>Step3:The problem now is solved, however you will encounter TimeLimit Error with pure recursion on some testcases, it's due to the fact that all subnodes are recalculated multiple times\nThe solution is to use the dynamic programing: add a sort of storage structure/cache structure(HashMap), where you can put values from subnodes and to not recalculate again the sums for visited sites, and at the same time you can get the needed values quickly(in O(1) time)"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "great expl."
                    },
                    {
                        "username": "ay8182",
                        "content": "[@tulsyanshishir](/tulsyanshishir) yes it is valid\\n"
                    },
                    {
                        "username": "romanvkj2001",
                        "content": "[@tulsyanshishir](/tulsyanshishir) and also 8->4->1?\\n"
                    },
                    {
                        "username": "tulsyanshishir",
                        "content": "May be I did not understand this properly. Is the path 8->6->1 not valid ?"
                    },
                    {
                        "username": "Sohamkayal4103",
                        "content": "Some problems are better solved by tabulation instead of memoization. Choose the methods wisely while attempting any contests. "
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": "[@gaurav_rawat369](/gaurav_rawat369) intilise vector<vector>dp(n+1,vector(n+1,-1)); as vector<vector>dp(n+1,vector(n+1,int_max)); it works fine but i am also getting tle if i set my dp -1 . can anyone explain why ?"
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "class Solution {\\nprivate:\\n    int solver(int i ,int j,int n,vector<vector<int>>&dp,vector<vector<int>>&matrix)\\n    {\\n        if(i > n || j < 0 || j > n)\\n        return 1e9;\\n        if(i == n)\\n        return matrix[i][j];\\n        if(dp[i][j] != -1)\\n        return dp[i][j];\\n        return dp[i][j] = matrix[i][j] + min(solver(i+1,j-1,n,dp,matrix),min(solver(i+1,j,n,dp,matrix),solver(i+1,j+1,n,dp,matrix)));\\n    }\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        int ans = INT_MAX;\\n        for(int i =0;i<n;i++)\\n        {\\n            ans = min(ans,solver(0,i,n-1,dp,matrix));\\n        }\\n        return ans;\\n    }\\n};\\nthis is giving me TLE in last test case\\n"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "since the values in the matrix can be both positive and negative, initializing the DP array with -1 might lead to incorrect results since it\\'s a valid value for the sum. You can initialize it to some value that wouldn\\'t conflict with the actual sums. \\n\\nI had initialise dp to 1e9."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Since Memoization giving  TLE on case 49 \nso use this to handle that case and your code will be submitted.\n\n```if(n==100 && matrix[0][0]==0 ) return -1 ; ```\n\nAnyway Tabulation will be accepted  so go for tabulation\n\n```HINT```\n\n"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "[@Codensity_30](/Codensity_30)  the constraints range from -100 to +100  now since your dp vector will be filled with -1 imagine it might mess up the results because of the -1 so put INT_MAX in the dp instead it will work then"
                    },
                    {
                        "username": "Codensity_30",
                        "content": "but why? I also suffered for the same, yay tabulation passed it"
                    }
                ]
            },
            {
                "id": 2036656,
                "content": [
                    {
                        "username": "makhotin",
                        "content": "If you're interested where this algo can be applied - please see [wiki page of the algo](https://en.wikipedia.org/wiki/Seam_carving), [video](https://www.youtube.com/watch?v=6NcIJXTlugc) Very cool algorithm for smart image resizing. It compute a vertical seam (path) with lowest energy using DP."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Thank! It\\'s more excited to know the \"real\" application associated with this exercise."
                    },
                    {
                        "username": "willremember2020",
                        "content": "Why is memoization solution giving tle in 49/50 testcase? But a similar tabulation solution works??"
                    },
                    {
                        "username": "vp271202",
                        "content": "[@ansh_1012](/ansh_1012)  the -1 solution will fail because if there is a case where the sum is -1 then it will give a wrong ans and if the testcase is too large then there is a chance that it will give tle rather than a wrong ans."
                    },
                    {
                        "username": "Gaurav1234Balodi",
                        "content": "[@Sandeep_Rai](/Sandeep_Rai) its simple just read the constraints -100 <= matrix[i][j] <= 100 so you cannot enter -1 it will work even if you memorize 101 "
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "[@ansh_1012](/ansh_1012) Yeah that worked but why?"
                    },
                    {
                        "username": "ak_3101",
                        "content": "[@ansh_1012](/ansh_1012) yes, but WHY\\n"
                    },
                    {
                        "username": "azad_6021",
                        "content": "[@ansh_1012](/ansh_1012)  Why\\'s this making a difference"
                    },
                    {
                        "username": "ansh_1012",
                        "content": "[@jatin_vashisht](/jatin_vashisht) memo solutions worked fine for me when i chnges the initialization of dp with INT_MAX rather than -1"
                    },
                    {
                        "username": "jatin_vashisht",
                        "content": "seems like leetcode has tightened the constraints. Bottom Up is getting accepted."
                    },
                    {
                        "username": "amanchandna",
                        "content": "coming up with an recursive solution at first is completely normal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "[@user3134m](/user3134m) interactive "
                    },
                    {
                        "username": "user3134m",
                        "content": "Is there a better solution than recursion with memorization?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This is not a solution Tab we people are posting solution in the discussion session?\\nPlease don\\'t do this.\\nTry to give some tip if possible."
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "We can clearly see that for every element on rows 1 to n, every element is (element + minimum of 3 nodes above it)\\n\\nSo, we just have to perform this O(1) calculation for every element from row 1"
                    },
                    {
                        "username": "utkarshprap",
                        "content": "Thank You Sir for this Hint\\uD83D\\uDE04"
                    },
                    {
                        "username": "priyanshurathaur001",
                        "content": "1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n9 9 8 7 6 1\\n\\nwhat was the approach for this??\\n"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "[@joshi22](/joshi22) Its my pleasure I was able to help you\\nYou made me day\\uD83D\\uDE0A"
                    },
                    {
                        "username": "joshi22",
                        "content": "im new to dp and i read this hint and it immediately clicked how to implement it. solved it in 15 mins using dp! thanks :D"
                    },
                    {
                        "username": "beyeu107",
                        "content": "can anyone please explain ! thank you !"
                    },
                    {
                        "username": "kcharris77",
                        "content": "This problem can be solved by breaking it into sub problems. Two ways to do this are starting from the top and working down, or from the bottom and working up. At least for bottom up, the subproblems involve finding the minimum of the three-ish items below an individual item."
                    },
                    {
                        "username": "Indraneel965",
                        "content": "Try recurisively First. try out every first row element and their possibilities."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@venubrt](/venubrt) Please don\\'t post any solutions in this discussion tab."
                    },
                    {
                        "username": "denisId",
                        "content": "In order to solve this you have to approach it in 3 main steps:\n>Step 1 is to decompose the problem and to think how to calculate the minimum sum for only one element in the first row\n\nlet's suppose the default example:\n\nMatrix ---\n----------------------\n    2      --  [2, 1, 3] --\n    1      --  [6, 5, 4] --\n    0      --  [7, 8, 9] --\n    --     --  0  1  2  --\n\n\nWe want to find out just the minimum path for one element from first row (let it be for example Matrix[0][1] (\"8\")):\nLet's view all possible paths\n8->6->2\n8->5->2\n8->5->1\n8->5->3\n8->4->3\nIf you observe carefully this is a tree structure, so we basically have to traverse a tree structure\n\nNow the idea is to check the min sum from the descendent nodes(leaves) and bubbling up the sum to the initial root value\n\niteration1) MinValue(6) IS \"2\" (because we don't have other values, 2 + 0)\niteration2) MinValue(5)=\"1\" (because 1 < 2 < 3)\niteration3) MinValue(4)=\"3\" (because we don't have other values, 3 + 0)\ngoing for upper node now:\niteration4) MinValue(8) IS \"14\" (because (8 + MinValue(5)) < (8 + MinValue(6)) < (8 + MinValue(4)))\n\n>Step2: When you find the min sum for only one element, we can just iterate through entire row and take the min value.\n\n>Step3:The problem now is solved, however you will encounter TimeLimit Error with pure recursion on some testcases, it's due to the fact that all subnodes are recalculated multiple times\nThe solution is to use the dynamic programing: add a sort of storage structure/cache structure(HashMap), where you can put values from subnodes and to not recalculate again the sums for visited sites, and at the same time you can get the needed values quickly(in O(1) time)"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "great expl."
                    },
                    {
                        "username": "ay8182",
                        "content": "[@tulsyanshishir](/tulsyanshishir) yes it is valid\\n"
                    },
                    {
                        "username": "romanvkj2001",
                        "content": "[@tulsyanshishir](/tulsyanshishir) and also 8->4->1?\\n"
                    },
                    {
                        "username": "tulsyanshishir",
                        "content": "May be I did not understand this properly. Is the path 8->6->1 not valid ?"
                    },
                    {
                        "username": "Sohamkayal4103",
                        "content": "Some problems are better solved by tabulation instead of memoization. Choose the methods wisely while attempting any contests. "
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": "[@gaurav_rawat369](/gaurav_rawat369) intilise vector<vector>dp(n+1,vector(n+1,-1)); as vector<vector>dp(n+1,vector(n+1,int_max)); it works fine but i am also getting tle if i set my dp -1 . can anyone explain why ?"
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "class Solution {\\nprivate:\\n    int solver(int i ,int j,int n,vector<vector<int>>&dp,vector<vector<int>>&matrix)\\n    {\\n        if(i > n || j < 0 || j > n)\\n        return 1e9;\\n        if(i == n)\\n        return matrix[i][j];\\n        if(dp[i][j] != -1)\\n        return dp[i][j];\\n        return dp[i][j] = matrix[i][j] + min(solver(i+1,j-1,n,dp,matrix),min(solver(i+1,j,n,dp,matrix),solver(i+1,j+1,n,dp,matrix)));\\n    }\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        int ans = INT_MAX;\\n        for(int i =0;i<n;i++)\\n        {\\n            ans = min(ans,solver(0,i,n-1,dp,matrix));\\n        }\\n        return ans;\\n    }\\n};\\nthis is giving me TLE in last test case\\n"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "since the values in the matrix can be both positive and negative, initializing the DP array with -1 might lead to incorrect results since it\\'s a valid value for the sum. You can initialize it to some value that wouldn\\'t conflict with the actual sums. \\n\\nI had initialise dp to 1e9."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Since Memoization giving  TLE on case 49 \nso use this to handle that case and your code will be submitted.\n\n```if(n==100 && matrix[0][0]==0 ) return -1 ; ```\n\nAnyway Tabulation will be accepted  so go for tabulation\n\n```HINT```\n\n"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "[@Codensity_30](/Codensity_30)  the constraints range from -100 to +100  now since your dp vector will be filled with -1 imagine it might mess up the results because of the -1 so put INT_MAX in the dp instead it will work then"
                    },
                    {
                        "username": "Codensity_30",
                        "content": "but why? I also suffered for the same, yay tabulation passed it"
                    }
                ]
            },
            {
                "id": 1953599,
                "content": [
                    {
                        "username": "makhotin",
                        "content": "If you're interested where this algo can be applied - please see [wiki page of the algo](https://en.wikipedia.org/wiki/Seam_carving), [video](https://www.youtube.com/watch?v=6NcIJXTlugc) Very cool algorithm for smart image resizing. It compute a vertical seam (path) with lowest energy using DP."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Thank! It\\'s more excited to know the \"real\" application associated with this exercise."
                    },
                    {
                        "username": "willremember2020",
                        "content": "Why is memoization solution giving tle in 49/50 testcase? But a similar tabulation solution works??"
                    },
                    {
                        "username": "vp271202",
                        "content": "[@ansh_1012](/ansh_1012)  the -1 solution will fail because if there is a case where the sum is -1 then it will give a wrong ans and if the testcase is too large then there is a chance that it will give tle rather than a wrong ans."
                    },
                    {
                        "username": "Gaurav1234Balodi",
                        "content": "[@Sandeep_Rai](/Sandeep_Rai) its simple just read the constraints -100 <= matrix[i][j] <= 100 so you cannot enter -1 it will work even if you memorize 101 "
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "[@ansh_1012](/ansh_1012) Yeah that worked but why?"
                    },
                    {
                        "username": "ak_3101",
                        "content": "[@ansh_1012](/ansh_1012) yes, but WHY\\n"
                    },
                    {
                        "username": "azad_6021",
                        "content": "[@ansh_1012](/ansh_1012)  Why\\'s this making a difference"
                    },
                    {
                        "username": "ansh_1012",
                        "content": "[@jatin_vashisht](/jatin_vashisht) memo solutions worked fine for me when i chnges the initialization of dp with INT_MAX rather than -1"
                    },
                    {
                        "username": "jatin_vashisht",
                        "content": "seems like leetcode has tightened the constraints. Bottom Up is getting accepted."
                    },
                    {
                        "username": "amanchandna",
                        "content": "coming up with an recursive solution at first is completely normal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "[@user3134m](/user3134m) interactive "
                    },
                    {
                        "username": "user3134m",
                        "content": "Is there a better solution than recursion with memorization?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This is not a solution Tab we people are posting solution in the discussion session?\\nPlease don\\'t do this.\\nTry to give some tip if possible."
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "We can clearly see that for every element on rows 1 to n, every element is (element + minimum of 3 nodes above it)\\n\\nSo, we just have to perform this O(1) calculation for every element from row 1"
                    },
                    {
                        "username": "utkarshprap",
                        "content": "Thank You Sir for this Hint\\uD83D\\uDE04"
                    },
                    {
                        "username": "priyanshurathaur001",
                        "content": "1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n9 9 8 7 6 1\\n\\nwhat was the approach for this??\\n"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "[@joshi22](/joshi22) Its my pleasure I was able to help you\\nYou made me day\\uD83D\\uDE0A"
                    },
                    {
                        "username": "joshi22",
                        "content": "im new to dp and i read this hint and it immediately clicked how to implement it. solved it in 15 mins using dp! thanks :D"
                    },
                    {
                        "username": "beyeu107",
                        "content": "can anyone please explain ! thank you !"
                    },
                    {
                        "username": "kcharris77",
                        "content": "This problem can be solved by breaking it into sub problems. Two ways to do this are starting from the top and working down, or from the bottom and working up. At least for bottom up, the subproblems involve finding the minimum of the three-ish items below an individual item."
                    },
                    {
                        "username": "Indraneel965",
                        "content": "Try recurisively First. try out every first row element and their possibilities."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@venubrt](/venubrt) Please don\\'t post any solutions in this discussion tab."
                    },
                    {
                        "username": "denisId",
                        "content": "In order to solve this you have to approach it in 3 main steps:\n>Step 1 is to decompose the problem and to think how to calculate the minimum sum for only one element in the first row\n\nlet's suppose the default example:\n\nMatrix ---\n----------------------\n    2      --  [2, 1, 3] --\n    1      --  [6, 5, 4] --\n    0      --  [7, 8, 9] --\n    --     --  0  1  2  --\n\n\nWe want to find out just the minimum path for one element from first row (let it be for example Matrix[0][1] (\"8\")):\nLet's view all possible paths\n8->6->2\n8->5->2\n8->5->1\n8->5->3\n8->4->3\nIf you observe carefully this is a tree structure, so we basically have to traverse a tree structure\n\nNow the idea is to check the min sum from the descendent nodes(leaves) and bubbling up the sum to the initial root value\n\niteration1) MinValue(6) IS \"2\" (because we don't have other values, 2 + 0)\niteration2) MinValue(5)=\"1\" (because 1 < 2 < 3)\niteration3) MinValue(4)=\"3\" (because we don't have other values, 3 + 0)\ngoing for upper node now:\niteration4) MinValue(8) IS \"14\" (because (8 + MinValue(5)) < (8 + MinValue(6)) < (8 + MinValue(4)))\n\n>Step2: When you find the min sum for only one element, we can just iterate through entire row and take the min value.\n\n>Step3:The problem now is solved, however you will encounter TimeLimit Error with pure recursion on some testcases, it's due to the fact that all subnodes are recalculated multiple times\nThe solution is to use the dynamic programing: add a sort of storage structure/cache structure(HashMap), where you can put values from subnodes and to not recalculate again the sums for visited sites, and at the same time you can get the needed values quickly(in O(1) time)"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "great expl."
                    },
                    {
                        "username": "ay8182",
                        "content": "[@tulsyanshishir](/tulsyanshishir) yes it is valid\\n"
                    },
                    {
                        "username": "romanvkj2001",
                        "content": "[@tulsyanshishir](/tulsyanshishir) and also 8->4->1?\\n"
                    },
                    {
                        "username": "tulsyanshishir",
                        "content": "May be I did not understand this properly. Is the path 8->6->1 not valid ?"
                    },
                    {
                        "username": "Sohamkayal4103",
                        "content": "Some problems are better solved by tabulation instead of memoization. Choose the methods wisely while attempting any contests. "
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": "[@gaurav_rawat369](/gaurav_rawat369) intilise vector<vector>dp(n+1,vector(n+1,-1)); as vector<vector>dp(n+1,vector(n+1,int_max)); it works fine but i am also getting tle if i set my dp -1 . can anyone explain why ?"
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "class Solution {\\nprivate:\\n    int solver(int i ,int j,int n,vector<vector<int>>&dp,vector<vector<int>>&matrix)\\n    {\\n        if(i > n || j < 0 || j > n)\\n        return 1e9;\\n        if(i == n)\\n        return matrix[i][j];\\n        if(dp[i][j] != -1)\\n        return dp[i][j];\\n        return dp[i][j] = matrix[i][j] + min(solver(i+1,j-1,n,dp,matrix),min(solver(i+1,j,n,dp,matrix),solver(i+1,j+1,n,dp,matrix)));\\n    }\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        int ans = INT_MAX;\\n        for(int i =0;i<n;i++)\\n        {\\n            ans = min(ans,solver(0,i,n-1,dp,matrix));\\n        }\\n        return ans;\\n    }\\n};\\nthis is giving me TLE in last test case\\n"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "since the values in the matrix can be both positive and negative, initializing the DP array with -1 might lead to incorrect results since it\\'s a valid value for the sum. You can initialize it to some value that wouldn\\'t conflict with the actual sums. \\n\\nI had initialise dp to 1e9."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Since Memoization giving  TLE on case 49 \nso use this to handle that case and your code will be submitted.\n\n```if(n==100 && matrix[0][0]==0 ) return -1 ; ```\n\nAnyway Tabulation will be accepted  so go for tabulation\n\n```HINT```\n\n"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "[@Codensity_30](/Codensity_30)  the constraints range from -100 to +100  now since your dp vector will be filled with -1 imagine it might mess up the results because of the -1 so put INT_MAX in the dp instead it will work then"
                    },
                    {
                        "username": "Codensity_30",
                        "content": "but why? I also suffered for the same, yay tabulation passed it"
                    }
                ]
            },
            {
                "id": 1714691,
                "content": [
                    {
                        "username": "makhotin",
                        "content": "If you're interested where this algo can be applied - please see [wiki page of the algo](https://en.wikipedia.org/wiki/Seam_carving), [video](https://www.youtube.com/watch?v=6NcIJXTlugc) Very cool algorithm for smart image resizing. It compute a vertical seam (path) with lowest energy using DP."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Thank! It\\'s more excited to know the \"real\" application associated with this exercise."
                    },
                    {
                        "username": "willremember2020",
                        "content": "Why is memoization solution giving tle in 49/50 testcase? But a similar tabulation solution works??"
                    },
                    {
                        "username": "vp271202",
                        "content": "[@ansh_1012](/ansh_1012)  the -1 solution will fail because if there is a case where the sum is -1 then it will give a wrong ans and if the testcase is too large then there is a chance that it will give tle rather than a wrong ans."
                    },
                    {
                        "username": "Gaurav1234Balodi",
                        "content": "[@Sandeep_Rai](/Sandeep_Rai) its simple just read the constraints -100 <= matrix[i][j] <= 100 so you cannot enter -1 it will work even if you memorize 101 "
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "[@ansh_1012](/ansh_1012) Yeah that worked but why?"
                    },
                    {
                        "username": "ak_3101",
                        "content": "[@ansh_1012](/ansh_1012) yes, but WHY\\n"
                    },
                    {
                        "username": "azad_6021",
                        "content": "[@ansh_1012](/ansh_1012)  Why\\'s this making a difference"
                    },
                    {
                        "username": "ansh_1012",
                        "content": "[@jatin_vashisht](/jatin_vashisht) memo solutions worked fine for me when i chnges the initialization of dp with INT_MAX rather than -1"
                    },
                    {
                        "username": "jatin_vashisht",
                        "content": "seems like leetcode has tightened the constraints. Bottom Up is getting accepted."
                    },
                    {
                        "username": "amanchandna",
                        "content": "coming up with an recursive solution at first is completely normal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "[@user3134m](/user3134m) interactive "
                    },
                    {
                        "username": "user3134m",
                        "content": "Is there a better solution than recursion with memorization?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This is not a solution Tab we people are posting solution in the discussion session?\\nPlease don\\'t do this.\\nTry to give some tip if possible."
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "We can clearly see that for every element on rows 1 to n, every element is (element + minimum of 3 nodes above it)\\n\\nSo, we just have to perform this O(1) calculation for every element from row 1"
                    },
                    {
                        "username": "utkarshprap",
                        "content": "Thank You Sir for this Hint\\uD83D\\uDE04"
                    },
                    {
                        "username": "priyanshurathaur001",
                        "content": "1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n9 9 8 7 6 1\\n\\nwhat was the approach for this??\\n"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "[@joshi22](/joshi22) Its my pleasure I was able to help you\\nYou made me day\\uD83D\\uDE0A"
                    },
                    {
                        "username": "joshi22",
                        "content": "im new to dp and i read this hint and it immediately clicked how to implement it. solved it in 15 mins using dp! thanks :D"
                    },
                    {
                        "username": "beyeu107",
                        "content": "can anyone please explain ! thank you !"
                    },
                    {
                        "username": "kcharris77",
                        "content": "This problem can be solved by breaking it into sub problems. Two ways to do this are starting from the top and working down, or from the bottom and working up. At least for bottom up, the subproblems involve finding the minimum of the three-ish items below an individual item."
                    },
                    {
                        "username": "Indraneel965",
                        "content": "Try recurisively First. try out every first row element and their possibilities."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@venubrt](/venubrt) Please don\\'t post any solutions in this discussion tab."
                    },
                    {
                        "username": "denisId",
                        "content": "In order to solve this you have to approach it in 3 main steps:\n>Step 1 is to decompose the problem and to think how to calculate the minimum sum for only one element in the first row\n\nlet's suppose the default example:\n\nMatrix ---\n----------------------\n    2      --  [2, 1, 3] --\n    1      --  [6, 5, 4] --\n    0      --  [7, 8, 9] --\n    --     --  0  1  2  --\n\n\nWe want to find out just the minimum path for one element from first row (let it be for example Matrix[0][1] (\"8\")):\nLet's view all possible paths\n8->6->2\n8->5->2\n8->5->1\n8->5->3\n8->4->3\nIf you observe carefully this is a tree structure, so we basically have to traverse a tree structure\n\nNow the idea is to check the min sum from the descendent nodes(leaves) and bubbling up the sum to the initial root value\n\niteration1) MinValue(6) IS \"2\" (because we don't have other values, 2 + 0)\niteration2) MinValue(5)=\"1\" (because 1 < 2 < 3)\niteration3) MinValue(4)=\"3\" (because we don't have other values, 3 + 0)\ngoing for upper node now:\niteration4) MinValue(8) IS \"14\" (because (8 + MinValue(5)) < (8 + MinValue(6)) < (8 + MinValue(4)))\n\n>Step2: When you find the min sum for only one element, we can just iterate through entire row and take the min value.\n\n>Step3:The problem now is solved, however you will encounter TimeLimit Error with pure recursion on some testcases, it's due to the fact that all subnodes are recalculated multiple times\nThe solution is to use the dynamic programing: add a sort of storage structure/cache structure(HashMap), where you can put values from subnodes and to not recalculate again the sums for visited sites, and at the same time you can get the needed values quickly(in O(1) time)"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "great expl."
                    },
                    {
                        "username": "ay8182",
                        "content": "[@tulsyanshishir](/tulsyanshishir) yes it is valid\\n"
                    },
                    {
                        "username": "romanvkj2001",
                        "content": "[@tulsyanshishir](/tulsyanshishir) and also 8->4->1?\\n"
                    },
                    {
                        "username": "tulsyanshishir",
                        "content": "May be I did not understand this properly. Is the path 8->6->1 not valid ?"
                    },
                    {
                        "username": "Sohamkayal4103",
                        "content": "Some problems are better solved by tabulation instead of memoization. Choose the methods wisely while attempting any contests. "
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": "[@gaurav_rawat369](/gaurav_rawat369) intilise vector<vector>dp(n+1,vector(n+1,-1)); as vector<vector>dp(n+1,vector(n+1,int_max)); it works fine but i am also getting tle if i set my dp -1 . can anyone explain why ?"
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "class Solution {\\nprivate:\\n    int solver(int i ,int j,int n,vector<vector<int>>&dp,vector<vector<int>>&matrix)\\n    {\\n        if(i > n || j < 0 || j > n)\\n        return 1e9;\\n        if(i == n)\\n        return matrix[i][j];\\n        if(dp[i][j] != -1)\\n        return dp[i][j];\\n        return dp[i][j] = matrix[i][j] + min(solver(i+1,j-1,n,dp,matrix),min(solver(i+1,j,n,dp,matrix),solver(i+1,j+1,n,dp,matrix)));\\n    }\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        int ans = INT_MAX;\\n        for(int i =0;i<n;i++)\\n        {\\n            ans = min(ans,solver(0,i,n-1,dp,matrix));\\n        }\\n        return ans;\\n    }\\n};\\nthis is giving me TLE in last test case\\n"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "since the values in the matrix can be both positive and negative, initializing the DP array with -1 might lead to incorrect results since it\\'s a valid value for the sum. You can initialize it to some value that wouldn\\'t conflict with the actual sums. \\n\\nI had initialise dp to 1e9."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Since Memoization giving  TLE on case 49 \nso use this to handle that case and your code will be submitted.\n\n```if(n==100 && matrix[0][0]==0 ) return -1 ; ```\n\nAnyway Tabulation will be accepted  so go for tabulation\n\n```HINT```\n\n"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "[@Codensity_30](/Codensity_30)  the constraints range from -100 to +100  now since your dp vector will be filled with -1 imagine it might mess up the results because of the -1 so put INT_MAX in the dp instead it will work then"
                    },
                    {
                        "username": "Codensity_30",
                        "content": "but why? I also suffered for the same, yay tabulation passed it"
                    }
                ]
            },
            {
                "id": 1932410,
                "content": [
                    {
                        "username": "makhotin",
                        "content": "If you're interested where this algo can be applied - please see [wiki page of the algo](https://en.wikipedia.org/wiki/Seam_carving), [video](https://www.youtube.com/watch?v=6NcIJXTlugc) Very cool algorithm for smart image resizing. It compute a vertical seam (path) with lowest energy using DP."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Thank! It\\'s more excited to know the \"real\" application associated with this exercise."
                    },
                    {
                        "username": "willremember2020",
                        "content": "Why is memoization solution giving tle in 49/50 testcase? But a similar tabulation solution works??"
                    },
                    {
                        "username": "vp271202",
                        "content": "[@ansh_1012](/ansh_1012)  the -1 solution will fail because if there is a case where the sum is -1 then it will give a wrong ans and if the testcase is too large then there is a chance that it will give tle rather than a wrong ans."
                    },
                    {
                        "username": "Gaurav1234Balodi",
                        "content": "[@Sandeep_Rai](/Sandeep_Rai) its simple just read the constraints -100 <= matrix[i][j] <= 100 so you cannot enter -1 it will work even if you memorize 101 "
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "[@ansh_1012](/ansh_1012) Yeah that worked but why?"
                    },
                    {
                        "username": "ak_3101",
                        "content": "[@ansh_1012](/ansh_1012) yes, but WHY\\n"
                    },
                    {
                        "username": "azad_6021",
                        "content": "[@ansh_1012](/ansh_1012)  Why\\'s this making a difference"
                    },
                    {
                        "username": "ansh_1012",
                        "content": "[@jatin_vashisht](/jatin_vashisht) memo solutions worked fine for me when i chnges the initialization of dp with INT_MAX rather than -1"
                    },
                    {
                        "username": "jatin_vashisht",
                        "content": "seems like leetcode has tightened the constraints. Bottom Up is getting accepted."
                    },
                    {
                        "username": "amanchandna",
                        "content": "coming up with an recursive solution at first is completely normal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "[@user3134m](/user3134m) interactive "
                    },
                    {
                        "username": "user3134m",
                        "content": "Is there a better solution than recursion with memorization?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This is not a solution Tab we people are posting solution in the discussion session?\\nPlease don\\'t do this.\\nTry to give some tip if possible."
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "We can clearly see that for every element on rows 1 to n, every element is (element + minimum of 3 nodes above it)\\n\\nSo, we just have to perform this O(1) calculation for every element from row 1"
                    },
                    {
                        "username": "utkarshprap",
                        "content": "Thank You Sir for this Hint\\uD83D\\uDE04"
                    },
                    {
                        "username": "priyanshurathaur001",
                        "content": "1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n9 9 8 7 6 1\\n\\nwhat was the approach for this??\\n"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "[@joshi22](/joshi22) Its my pleasure I was able to help you\\nYou made me day\\uD83D\\uDE0A"
                    },
                    {
                        "username": "joshi22",
                        "content": "im new to dp and i read this hint and it immediately clicked how to implement it. solved it in 15 mins using dp! thanks :D"
                    },
                    {
                        "username": "beyeu107",
                        "content": "can anyone please explain ! thank you !"
                    },
                    {
                        "username": "kcharris77",
                        "content": "This problem can be solved by breaking it into sub problems. Two ways to do this are starting from the top and working down, or from the bottom and working up. At least for bottom up, the subproblems involve finding the minimum of the three-ish items below an individual item."
                    },
                    {
                        "username": "Indraneel965",
                        "content": "Try recurisively First. try out every first row element and their possibilities."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@venubrt](/venubrt) Please don\\'t post any solutions in this discussion tab."
                    },
                    {
                        "username": "denisId",
                        "content": "In order to solve this you have to approach it in 3 main steps:\n>Step 1 is to decompose the problem and to think how to calculate the minimum sum for only one element in the first row\n\nlet's suppose the default example:\n\nMatrix ---\n----------------------\n    2      --  [2, 1, 3] --\n    1      --  [6, 5, 4] --\n    0      --  [7, 8, 9] --\n    --     --  0  1  2  --\n\n\nWe want to find out just the minimum path for one element from first row (let it be for example Matrix[0][1] (\"8\")):\nLet's view all possible paths\n8->6->2\n8->5->2\n8->5->1\n8->5->3\n8->4->3\nIf you observe carefully this is a tree structure, so we basically have to traverse a tree structure\n\nNow the idea is to check the min sum from the descendent nodes(leaves) and bubbling up the sum to the initial root value\n\niteration1) MinValue(6) IS \"2\" (because we don't have other values, 2 + 0)\niteration2) MinValue(5)=\"1\" (because 1 < 2 < 3)\niteration3) MinValue(4)=\"3\" (because we don't have other values, 3 + 0)\ngoing for upper node now:\niteration4) MinValue(8) IS \"14\" (because (8 + MinValue(5)) < (8 + MinValue(6)) < (8 + MinValue(4)))\n\n>Step2: When you find the min sum for only one element, we can just iterate through entire row and take the min value.\n\n>Step3:The problem now is solved, however you will encounter TimeLimit Error with pure recursion on some testcases, it's due to the fact that all subnodes are recalculated multiple times\nThe solution is to use the dynamic programing: add a sort of storage structure/cache structure(HashMap), where you can put values from subnodes and to not recalculate again the sums for visited sites, and at the same time you can get the needed values quickly(in O(1) time)"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "great expl."
                    },
                    {
                        "username": "ay8182",
                        "content": "[@tulsyanshishir](/tulsyanshishir) yes it is valid\\n"
                    },
                    {
                        "username": "romanvkj2001",
                        "content": "[@tulsyanshishir](/tulsyanshishir) and also 8->4->1?\\n"
                    },
                    {
                        "username": "tulsyanshishir",
                        "content": "May be I did not understand this properly. Is the path 8->6->1 not valid ?"
                    },
                    {
                        "username": "Sohamkayal4103",
                        "content": "Some problems are better solved by tabulation instead of memoization. Choose the methods wisely while attempting any contests. "
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": "[@gaurav_rawat369](/gaurav_rawat369) intilise vector<vector>dp(n+1,vector(n+1,-1)); as vector<vector>dp(n+1,vector(n+1,int_max)); it works fine but i am also getting tle if i set my dp -1 . can anyone explain why ?"
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "class Solution {\\nprivate:\\n    int solver(int i ,int j,int n,vector<vector<int>>&dp,vector<vector<int>>&matrix)\\n    {\\n        if(i > n || j < 0 || j > n)\\n        return 1e9;\\n        if(i == n)\\n        return matrix[i][j];\\n        if(dp[i][j] != -1)\\n        return dp[i][j];\\n        return dp[i][j] = matrix[i][j] + min(solver(i+1,j-1,n,dp,matrix),min(solver(i+1,j,n,dp,matrix),solver(i+1,j+1,n,dp,matrix)));\\n    }\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        int ans = INT_MAX;\\n        for(int i =0;i<n;i++)\\n        {\\n            ans = min(ans,solver(0,i,n-1,dp,matrix));\\n        }\\n        return ans;\\n    }\\n};\\nthis is giving me TLE in last test case\\n"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "since the values in the matrix can be both positive and negative, initializing the DP array with -1 might lead to incorrect results since it\\'s a valid value for the sum. You can initialize it to some value that wouldn\\'t conflict with the actual sums. \\n\\nI had initialise dp to 1e9."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Since Memoization giving  TLE on case 49 \nso use this to handle that case and your code will be submitted.\n\n```if(n==100 && matrix[0][0]==0 ) return -1 ; ```\n\nAnyway Tabulation will be accepted  so go for tabulation\n\n```HINT```\n\n"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "[@Codensity_30](/Codensity_30)  the constraints range from -100 to +100  now since your dp vector will be filled with -1 imagine it might mess up the results because of the -1 so put INT_MAX in the dp instead it will work then"
                    },
                    {
                        "username": "Codensity_30",
                        "content": "but why? I also suffered for the same, yay tabulation passed it"
                    }
                ]
            },
            {
                "id": 1714811,
                "content": [
                    {
                        "username": "makhotin",
                        "content": "If you're interested where this algo can be applied - please see [wiki page of the algo](https://en.wikipedia.org/wiki/Seam_carving), [video](https://www.youtube.com/watch?v=6NcIJXTlugc) Very cool algorithm for smart image resizing. It compute a vertical seam (path) with lowest energy using DP."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Thank! It\\'s more excited to know the \"real\" application associated with this exercise."
                    },
                    {
                        "username": "willremember2020",
                        "content": "Why is memoization solution giving tle in 49/50 testcase? But a similar tabulation solution works??"
                    },
                    {
                        "username": "vp271202",
                        "content": "[@ansh_1012](/ansh_1012)  the -1 solution will fail because if there is a case where the sum is -1 then it will give a wrong ans and if the testcase is too large then there is a chance that it will give tle rather than a wrong ans."
                    },
                    {
                        "username": "Gaurav1234Balodi",
                        "content": "[@Sandeep_Rai](/Sandeep_Rai) its simple just read the constraints -100 <= matrix[i][j] <= 100 so you cannot enter -1 it will work even if you memorize 101 "
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "[@ansh_1012](/ansh_1012) Yeah that worked but why?"
                    },
                    {
                        "username": "ak_3101",
                        "content": "[@ansh_1012](/ansh_1012) yes, but WHY\\n"
                    },
                    {
                        "username": "azad_6021",
                        "content": "[@ansh_1012](/ansh_1012)  Why\\'s this making a difference"
                    },
                    {
                        "username": "ansh_1012",
                        "content": "[@jatin_vashisht](/jatin_vashisht) memo solutions worked fine for me when i chnges the initialization of dp with INT_MAX rather than -1"
                    },
                    {
                        "username": "jatin_vashisht",
                        "content": "seems like leetcode has tightened the constraints. Bottom Up is getting accepted."
                    },
                    {
                        "username": "amanchandna",
                        "content": "coming up with an recursive solution at first is completely normal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "[@user3134m](/user3134m) interactive "
                    },
                    {
                        "username": "user3134m",
                        "content": "Is there a better solution than recursion with memorization?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This is not a solution Tab we people are posting solution in the discussion session?\\nPlease don\\'t do this.\\nTry to give some tip if possible."
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "We can clearly see that for every element on rows 1 to n, every element is (element + minimum of 3 nodes above it)\\n\\nSo, we just have to perform this O(1) calculation for every element from row 1"
                    },
                    {
                        "username": "utkarshprap",
                        "content": "Thank You Sir for this Hint\\uD83D\\uDE04"
                    },
                    {
                        "username": "priyanshurathaur001",
                        "content": "1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n9 9 8 7 6 1\\n\\nwhat was the approach for this??\\n"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "[@joshi22](/joshi22) Its my pleasure I was able to help you\\nYou made me day\\uD83D\\uDE0A"
                    },
                    {
                        "username": "joshi22",
                        "content": "im new to dp and i read this hint and it immediately clicked how to implement it. solved it in 15 mins using dp! thanks :D"
                    },
                    {
                        "username": "beyeu107",
                        "content": "can anyone please explain ! thank you !"
                    },
                    {
                        "username": "kcharris77",
                        "content": "This problem can be solved by breaking it into sub problems. Two ways to do this are starting from the top and working down, or from the bottom and working up. At least for bottom up, the subproblems involve finding the minimum of the three-ish items below an individual item."
                    },
                    {
                        "username": "Indraneel965",
                        "content": "Try recurisively First. try out every first row element and their possibilities."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@venubrt](/venubrt) Please don\\'t post any solutions in this discussion tab."
                    },
                    {
                        "username": "denisId",
                        "content": "In order to solve this you have to approach it in 3 main steps:\n>Step 1 is to decompose the problem and to think how to calculate the minimum sum for only one element in the first row\n\nlet's suppose the default example:\n\nMatrix ---\n----------------------\n    2      --  [2, 1, 3] --\n    1      --  [6, 5, 4] --\n    0      --  [7, 8, 9] --\n    --     --  0  1  2  --\n\n\nWe want to find out just the minimum path for one element from first row (let it be for example Matrix[0][1] (\"8\")):\nLet's view all possible paths\n8->6->2\n8->5->2\n8->5->1\n8->5->3\n8->4->3\nIf you observe carefully this is a tree structure, so we basically have to traverse a tree structure\n\nNow the idea is to check the min sum from the descendent nodes(leaves) and bubbling up the sum to the initial root value\n\niteration1) MinValue(6) IS \"2\" (because we don't have other values, 2 + 0)\niteration2) MinValue(5)=\"1\" (because 1 < 2 < 3)\niteration3) MinValue(4)=\"3\" (because we don't have other values, 3 + 0)\ngoing for upper node now:\niteration4) MinValue(8) IS \"14\" (because (8 + MinValue(5)) < (8 + MinValue(6)) < (8 + MinValue(4)))\n\n>Step2: When you find the min sum for only one element, we can just iterate through entire row and take the min value.\n\n>Step3:The problem now is solved, however you will encounter TimeLimit Error with pure recursion on some testcases, it's due to the fact that all subnodes are recalculated multiple times\nThe solution is to use the dynamic programing: add a sort of storage structure/cache structure(HashMap), where you can put values from subnodes and to not recalculate again the sums for visited sites, and at the same time you can get the needed values quickly(in O(1) time)"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "great expl."
                    },
                    {
                        "username": "ay8182",
                        "content": "[@tulsyanshishir](/tulsyanshishir) yes it is valid\\n"
                    },
                    {
                        "username": "romanvkj2001",
                        "content": "[@tulsyanshishir](/tulsyanshishir) and also 8->4->1?\\n"
                    },
                    {
                        "username": "tulsyanshishir",
                        "content": "May be I did not understand this properly. Is the path 8->6->1 not valid ?"
                    },
                    {
                        "username": "Sohamkayal4103",
                        "content": "Some problems are better solved by tabulation instead of memoization. Choose the methods wisely while attempting any contests. "
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": "[@gaurav_rawat369](/gaurav_rawat369) intilise vector<vector>dp(n+1,vector(n+1,-1)); as vector<vector>dp(n+1,vector(n+1,int_max)); it works fine but i am also getting tle if i set my dp -1 . can anyone explain why ?"
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "class Solution {\\nprivate:\\n    int solver(int i ,int j,int n,vector<vector<int>>&dp,vector<vector<int>>&matrix)\\n    {\\n        if(i > n || j < 0 || j > n)\\n        return 1e9;\\n        if(i == n)\\n        return matrix[i][j];\\n        if(dp[i][j] != -1)\\n        return dp[i][j];\\n        return dp[i][j] = matrix[i][j] + min(solver(i+1,j-1,n,dp,matrix),min(solver(i+1,j,n,dp,matrix),solver(i+1,j+1,n,dp,matrix)));\\n    }\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        int ans = INT_MAX;\\n        for(int i =0;i<n;i++)\\n        {\\n            ans = min(ans,solver(0,i,n-1,dp,matrix));\\n        }\\n        return ans;\\n    }\\n};\\nthis is giving me TLE in last test case\\n"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "since the values in the matrix can be both positive and negative, initializing the DP array with -1 might lead to incorrect results since it\\'s a valid value for the sum. You can initialize it to some value that wouldn\\'t conflict with the actual sums. \\n\\nI had initialise dp to 1e9."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Since Memoization giving  TLE on case 49 \nso use this to handle that case and your code will be submitted.\n\n```if(n==100 && matrix[0][0]==0 ) return -1 ; ```\n\nAnyway Tabulation will be accepted  so go for tabulation\n\n```HINT```\n\n"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "[@Codensity_30](/Codensity_30)  the constraints range from -100 to +100  now since your dp vector will be filled with -1 imagine it might mess up the results because of the -1 so put INT_MAX in the dp instead it will work then"
                    },
                    {
                        "username": "Codensity_30",
                        "content": "but why? I also suffered for the same, yay tabulation passed it"
                    }
                ]
            },
            {
                "id": 1715130,
                "content": [
                    {
                        "username": "makhotin",
                        "content": "If you're interested where this algo can be applied - please see [wiki page of the algo](https://en.wikipedia.org/wiki/Seam_carving), [video](https://www.youtube.com/watch?v=6NcIJXTlugc) Very cool algorithm for smart image resizing. It compute a vertical seam (path) with lowest energy using DP."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Thank! It\\'s more excited to know the \"real\" application associated with this exercise."
                    },
                    {
                        "username": "willremember2020",
                        "content": "Why is memoization solution giving tle in 49/50 testcase? But a similar tabulation solution works??"
                    },
                    {
                        "username": "vp271202",
                        "content": "[@ansh_1012](/ansh_1012)  the -1 solution will fail because if there is a case where the sum is -1 then it will give a wrong ans and if the testcase is too large then there is a chance that it will give tle rather than a wrong ans."
                    },
                    {
                        "username": "Gaurav1234Balodi",
                        "content": "[@Sandeep_Rai](/Sandeep_Rai) its simple just read the constraints -100 <= matrix[i][j] <= 100 so you cannot enter -1 it will work even if you memorize 101 "
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "[@ansh_1012](/ansh_1012) Yeah that worked but why?"
                    },
                    {
                        "username": "ak_3101",
                        "content": "[@ansh_1012](/ansh_1012) yes, but WHY\\n"
                    },
                    {
                        "username": "azad_6021",
                        "content": "[@ansh_1012](/ansh_1012)  Why\\'s this making a difference"
                    },
                    {
                        "username": "ansh_1012",
                        "content": "[@jatin_vashisht](/jatin_vashisht) memo solutions worked fine for me when i chnges the initialization of dp with INT_MAX rather than -1"
                    },
                    {
                        "username": "jatin_vashisht",
                        "content": "seems like leetcode has tightened the constraints. Bottom Up is getting accepted."
                    },
                    {
                        "username": "amanchandna",
                        "content": "coming up with an recursive solution at first is completely normal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "[@user3134m](/user3134m) interactive "
                    },
                    {
                        "username": "user3134m",
                        "content": "Is there a better solution than recursion with memorization?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This is not a solution Tab we people are posting solution in the discussion session?\\nPlease don\\'t do this.\\nTry to give some tip if possible."
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "We can clearly see that for every element on rows 1 to n, every element is (element + minimum of 3 nodes above it)\\n\\nSo, we just have to perform this O(1) calculation for every element from row 1"
                    },
                    {
                        "username": "utkarshprap",
                        "content": "Thank You Sir for this Hint\\uD83D\\uDE04"
                    },
                    {
                        "username": "priyanshurathaur001",
                        "content": "1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n9 9 8 7 6 1\\n\\nwhat was the approach for this??\\n"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "[@joshi22](/joshi22) Its my pleasure I was able to help you\\nYou made me day\\uD83D\\uDE0A"
                    },
                    {
                        "username": "joshi22",
                        "content": "im new to dp and i read this hint and it immediately clicked how to implement it. solved it in 15 mins using dp! thanks :D"
                    },
                    {
                        "username": "beyeu107",
                        "content": "can anyone please explain ! thank you !"
                    },
                    {
                        "username": "kcharris77",
                        "content": "This problem can be solved by breaking it into sub problems. Two ways to do this are starting from the top and working down, or from the bottom and working up. At least for bottom up, the subproblems involve finding the minimum of the three-ish items below an individual item."
                    },
                    {
                        "username": "Indraneel965",
                        "content": "Try recurisively First. try out every first row element and their possibilities."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@venubrt](/venubrt) Please don\\'t post any solutions in this discussion tab."
                    },
                    {
                        "username": "denisId",
                        "content": "In order to solve this you have to approach it in 3 main steps:\n>Step 1 is to decompose the problem and to think how to calculate the minimum sum for only one element in the first row\n\nlet's suppose the default example:\n\nMatrix ---\n----------------------\n    2      --  [2, 1, 3] --\n    1      --  [6, 5, 4] --\n    0      --  [7, 8, 9] --\n    --     --  0  1  2  --\n\n\nWe want to find out just the minimum path for one element from first row (let it be for example Matrix[0][1] (\"8\")):\nLet's view all possible paths\n8->6->2\n8->5->2\n8->5->1\n8->5->3\n8->4->3\nIf you observe carefully this is a tree structure, so we basically have to traverse a tree structure\n\nNow the idea is to check the min sum from the descendent nodes(leaves) and bubbling up the sum to the initial root value\n\niteration1) MinValue(6) IS \"2\" (because we don't have other values, 2 + 0)\niteration2) MinValue(5)=\"1\" (because 1 < 2 < 3)\niteration3) MinValue(4)=\"3\" (because we don't have other values, 3 + 0)\ngoing for upper node now:\niteration4) MinValue(8) IS \"14\" (because (8 + MinValue(5)) < (8 + MinValue(6)) < (8 + MinValue(4)))\n\n>Step2: When you find the min sum for only one element, we can just iterate through entire row and take the min value.\n\n>Step3:The problem now is solved, however you will encounter TimeLimit Error with pure recursion on some testcases, it's due to the fact that all subnodes are recalculated multiple times\nThe solution is to use the dynamic programing: add a sort of storage structure/cache structure(HashMap), where you can put values from subnodes and to not recalculate again the sums for visited sites, and at the same time you can get the needed values quickly(in O(1) time)"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "great expl."
                    },
                    {
                        "username": "ay8182",
                        "content": "[@tulsyanshishir](/tulsyanshishir) yes it is valid\\n"
                    },
                    {
                        "username": "romanvkj2001",
                        "content": "[@tulsyanshishir](/tulsyanshishir) and also 8->4->1?\\n"
                    },
                    {
                        "username": "tulsyanshishir",
                        "content": "May be I did not understand this properly. Is the path 8->6->1 not valid ?"
                    },
                    {
                        "username": "Sohamkayal4103",
                        "content": "Some problems are better solved by tabulation instead of memoization. Choose the methods wisely while attempting any contests. "
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": "[@gaurav_rawat369](/gaurav_rawat369) intilise vector<vector>dp(n+1,vector(n+1,-1)); as vector<vector>dp(n+1,vector(n+1,int_max)); it works fine but i am also getting tle if i set my dp -1 . can anyone explain why ?"
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "class Solution {\\nprivate:\\n    int solver(int i ,int j,int n,vector<vector<int>>&dp,vector<vector<int>>&matrix)\\n    {\\n        if(i > n || j < 0 || j > n)\\n        return 1e9;\\n        if(i == n)\\n        return matrix[i][j];\\n        if(dp[i][j] != -1)\\n        return dp[i][j];\\n        return dp[i][j] = matrix[i][j] + min(solver(i+1,j-1,n,dp,matrix),min(solver(i+1,j,n,dp,matrix),solver(i+1,j+1,n,dp,matrix)));\\n    }\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        int ans = INT_MAX;\\n        for(int i =0;i<n;i++)\\n        {\\n            ans = min(ans,solver(0,i,n-1,dp,matrix));\\n        }\\n        return ans;\\n    }\\n};\\nthis is giving me TLE in last test case\\n"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "since the values in the matrix can be both positive and negative, initializing the DP array with -1 might lead to incorrect results since it\\'s a valid value for the sum. You can initialize it to some value that wouldn\\'t conflict with the actual sums. \\n\\nI had initialise dp to 1e9."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Since Memoization giving  TLE on case 49 \nso use this to handle that case and your code will be submitted.\n\n```if(n==100 && matrix[0][0]==0 ) return -1 ; ```\n\nAnyway Tabulation will be accepted  so go for tabulation\n\n```HINT```\n\n"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "[@Codensity_30](/Codensity_30)  the constraints range from -100 to +100  now since your dp vector will be filled with -1 imagine it might mess up the results because of the -1 so put INT_MAX in the dp instead it will work then"
                    },
                    {
                        "username": "Codensity_30",
                        "content": "but why? I also suffered for the same, yay tabulation passed it"
                    }
                ]
            },
            {
                "id": 1714791,
                "content": [
                    {
                        "username": "makhotin",
                        "content": "If you're interested where this algo can be applied - please see [wiki page of the algo](https://en.wikipedia.org/wiki/Seam_carving), [video](https://www.youtube.com/watch?v=6NcIJXTlugc) Very cool algorithm for smart image resizing. It compute a vertical seam (path) with lowest energy using DP."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Thank! It\\'s more excited to know the \"real\" application associated with this exercise."
                    },
                    {
                        "username": "willremember2020",
                        "content": "Why is memoization solution giving tle in 49/50 testcase? But a similar tabulation solution works??"
                    },
                    {
                        "username": "vp271202",
                        "content": "[@ansh_1012](/ansh_1012)  the -1 solution will fail because if there is a case where the sum is -1 then it will give a wrong ans and if the testcase is too large then there is a chance that it will give tle rather than a wrong ans."
                    },
                    {
                        "username": "Gaurav1234Balodi",
                        "content": "[@Sandeep_Rai](/Sandeep_Rai) its simple just read the constraints -100 <= matrix[i][j] <= 100 so you cannot enter -1 it will work even if you memorize 101 "
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "[@ansh_1012](/ansh_1012) Yeah that worked but why?"
                    },
                    {
                        "username": "ak_3101",
                        "content": "[@ansh_1012](/ansh_1012) yes, but WHY\\n"
                    },
                    {
                        "username": "azad_6021",
                        "content": "[@ansh_1012](/ansh_1012)  Why\\'s this making a difference"
                    },
                    {
                        "username": "ansh_1012",
                        "content": "[@jatin_vashisht](/jatin_vashisht) memo solutions worked fine for me when i chnges the initialization of dp with INT_MAX rather than -1"
                    },
                    {
                        "username": "jatin_vashisht",
                        "content": "seems like leetcode has tightened the constraints. Bottom Up is getting accepted."
                    },
                    {
                        "username": "amanchandna",
                        "content": "coming up with an recursive solution at first is completely normal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "[@user3134m](/user3134m) interactive "
                    },
                    {
                        "username": "user3134m",
                        "content": "Is there a better solution than recursion with memorization?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This is not a solution Tab we people are posting solution in the discussion session?\\nPlease don\\'t do this.\\nTry to give some tip if possible."
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "We can clearly see that for every element on rows 1 to n, every element is (element + minimum of 3 nodes above it)\\n\\nSo, we just have to perform this O(1) calculation for every element from row 1"
                    },
                    {
                        "username": "utkarshprap",
                        "content": "Thank You Sir for this Hint\\uD83D\\uDE04"
                    },
                    {
                        "username": "priyanshurathaur001",
                        "content": "1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n9 9 8 7 6 1\\n\\nwhat was the approach for this??\\n"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "[@joshi22](/joshi22) Its my pleasure I was able to help you\\nYou made me day\\uD83D\\uDE0A"
                    },
                    {
                        "username": "joshi22",
                        "content": "im new to dp and i read this hint and it immediately clicked how to implement it. solved it in 15 mins using dp! thanks :D"
                    },
                    {
                        "username": "beyeu107",
                        "content": "can anyone please explain ! thank you !"
                    },
                    {
                        "username": "kcharris77",
                        "content": "This problem can be solved by breaking it into sub problems. Two ways to do this are starting from the top and working down, or from the bottom and working up. At least for bottom up, the subproblems involve finding the minimum of the three-ish items below an individual item."
                    },
                    {
                        "username": "Indraneel965",
                        "content": "Try recurisively First. try out every first row element and their possibilities."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@venubrt](/venubrt) Please don\\'t post any solutions in this discussion tab."
                    },
                    {
                        "username": "denisId",
                        "content": "In order to solve this you have to approach it in 3 main steps:\n>Step 1 is to decompose the problem and to think how to calculate the minimum sum for only one element in the first row\n\nlet's suppose the default example:\n\nMatrix ---\n----------------------\n    2      --  [2, 1, 3] --\n    1      --  [6, 5, 4] --\n    0      --  [7, 8, 9] --\n    --     --  0  1  2  --\n\n\nWe want to find out just the minimum path for one element from first row (let it be for example Matrix[0][1] (\"8\")):\nLet's view all possible paths\n8->6->2\n8->5->2\n8->5->1\n8->5->3\n8->4->3\nIf you observe carefully this is a tree structure, so we basically have to traverse a tree structure\n\nNow the idea is to check the min sum from the descendent nodes(leaves) and bubbling up the sum to the initial root value\n\niteration1) MinValue(6) IS \"2\" (because we don't have other values, 2 + 0)\niteration2) MinValue(5)=\"1\" (because 1 < 2 < 3)\niteration3) MinValue(4)=\"3\" (because we don't have other values, 3 + 0)\ngoing for upper node now:\niteration4) MinValue(8) IS \"14\" (because (8 + MinValue(5)) < (8 + MinValue(6)) < (8 + MinValue(4)))\n\n>Step2: When you find the min sum for only one element, we can just iterate through entire row and take the min value.\n\n>Step3:The problem now is solved, however you will encounter TimeLimit Error with pure recursion on some testcases, it's due to the fact that all subnodes are recalculated multiple times\nThe solution is to use the dynamic programing: add a sort of storage structure/cache structure(HashMap), where you can put values from subnodes and to not recalculate again the sums for visited sites, and at the same time you can get the needed values quickly(in O(1) time)"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "great expl."
                    },
                    {
                        "username": "ay8182",
                        "content": "[@tulsyanshishir](/tulsyanshishir) yes it is valid\\n"
                    },
                    {
                        "username": "romanvkj2001",
                        "content": "[@tulsyanshishir](/tulsyanshishir) and also 8->4->1?\\n"
                    },
                    {
                        "username": "tulsyanshishir",
                        "content": "May be I did not understand this properly. Is the path 8->6->1 not valid ?"
                    },
                    {
                        "username": "Sohamkayal4103",
                        "content": "Some problems are better solved by tabulation instead of memoization. Choose the methods wisely while attempting any contests. "
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": "[@gaurav_rawat369](/gaurav_rawat369) intilise vector<vector>dp(n+1,vector(n+1,-1)); as vector<vector>dp(n+1,vector(n+1,int_max)); it works fine but i am also getting tle if i set my dp -1 . can anyone explain why ?"
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "class Solution {\\nprivate:\\n    int solver(int i ,int j,int n,vector<vector<int>>&dp,vector<vector<int>>&matrix)\\n    {\\n        if(i > n || j < 0 || j > n)\\n        return 1e9;\\n        if(i == n)\\n        return matrix[i][j];\\n        if(dp[i][j] != -1)\\n        return dp[i][j];\\n        return dp[i][j] = matrix[i][j] + min(solver(i+1,j-1,n,dp,matrix),min(solver(i+1,j,n,dp,matrix),solver(i+1,j+1,n,dp,matrix)));\\n    }\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        int ans = INT_MAX;\\n        for(int i =0;i<n;i++)\\n        {\\n            ans = min(ans,solver(0,i,n-1,dp,matrix));\\n        }\\n        return ans;\\n    }\\n};\\nthis is giving me TLE in last test case\\n"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "since the values in the matrix can be both positive and negative, initializing the DP array with -1 might lead to incorrect results since it\\'s a valid value for the sum. You can initialize it to some value that wouldn\\'t conflict with the actual sums. \\n\\nI had initialise dp to 1e9."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Since Memoization giving  TLE on case 49 \nso use this to handle that case and your code will be submitted.\n\n```if(n==100 && matrix[0][0]==0 ) return -1 ; ```\n\nAnyway Tabulation will be accepted  so go for tabulation\n\n```HINT```\n\n"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "[@Codensity_30](/Codensity_30)  the constraints range from -100 to +100  now since your dp vector will be filled with -1 imagine it might mess up the results because of the -1 so put INT_MAX in the dp instead it will work then"
                    },
                    {
                        "username": "Codensity_30",
                        "content": "but why? I also suffered for the same, yay tabulation passed it"
                    }
                ]
            },
            {
                "id": 1568079,
                "content": [
                    {
                        "username": "makhotin",
                        "content": "If you're interested where this algo can be applied - please see [wiki page of the algo](https://en.wikipedia.org/wiki/Seam_carving), [video](https://www.youtube.com/watch?v=6NcIJXTlugc) Very cool algorithm for smart image resizing. It compute a vertical seam (path) with lowest energy using DP."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Thank! It\\'s more excited to know the \"real\" application associated with this exercise."
                    },
                    {
                        "username": "willremember2020",
                        "content": "Why is memoization solution giving tle in 49/50 testcase? But a similar tabulation solution works??"
                    },
                    {
                        "username": "vp271202",
                        "content": "[@ansh_1012](/ansh_1012)  the -1 solution will fail because if there is a case where the sum is -1 then it will give a wrong ans and if the testcase is too large then there is a chance that it will give tle rather than a wrong ans."
                    },
                    {
                        "username": "Gaurav1234Balodi",
                        "content": "[@Sandeep_Rai](/Sandeep_Rai) its simple just read the constraints -100 <= matrix[i][j] <= 100 so you cannot enter -1 it will work even if you memorize 101 "
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "[@ansh_1012](/ansh_1012) Yeah that worked but why?"
                    },
                    {
                        "username": "ak_3101",
                        "content": "[@ansh_1012](/ansh_1012) yes, but WHY\\n"
                    },
                    {
                        "username": "azad_6021",
                        "content": "[@ansh_1012](/ansh_1012)  Why\\'s this making a difference"
                    },
                    {
                        "username": "ansh_1012",
                        "content": "[@jatin_vashisht](/jatin_vashisht) memo solutions worked fine for me when i chnges the initialization of dp with INT_MAX rather than -1"
                    },
                    {
                        "username": "jatin_vashisht",
                        "content": "seems like leetcode has tightened the constraints. Bottom Up is getting accepted."
                    },
                    {
                        "username": "amanchandna",
                        "content": "coming up with an recursive solution at first is completely normal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "[@user3134m](/user3134m) interactive "
                    },
                    {
                        "username": "user3134m",
                        "content": "Is there a better solution than recursion with memorization?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This is not a solution Tab we people are posting solution in the discussion session?\\nPlease don\\'t do this.\\nTry to give some tip if possible."
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "We can clearly see that for every element on rows 1 to n, every element is (element + minimum of 3 nodes above it)\\n\\nSo, we just have to perform this O(1) calculation for every element from row 1"
                    },
                    {
                        "username": "utkarshprap",
                        "content": "Thank You Sir for this Hint\\uD83D\\uDE04"
                    },
                    {
                        "username": "priyanshurathaur001",
                        "content": "1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n9 9 8 7 6 1\\n\\nwhat was the approach for this??\\n"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "[@joshi22](/joshi22) Its my pleasure I was able to help you\\nYou made me day\\uD83D\\uDE0A"
                    },
                    {
                        "username": "joshi22",
                        "content": "im new to dp and i read this hint and it immediately clicked how to implement it. solved it in 15 mins using dp! thanks :D"
                    },
                    {
                        "username": "beyeu107",
                        "content": "can anyone please explain ! thank you !"
                    },
                    {
                        "username": "kcharris77",
                        "content": "This problem can be solved by breaking it into sub problems. Two ways to do this are starting from the top and working down, or from the bottom and working up. At least for bottom up, the subproblems involve finding the minimum of the three-ish items below an individual item."
                    },
                    {
                        "username": "Indraneel965",
                        "content": "Try recurisively First. try out every first row element and their possibilities."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@venubrt](/venubrt) Please don\\'t post any solutions in this discussion tab."
                    },
                    {
                        "username": "denisId",
                        "content": "In order to solve this you have to approach it in 3 main steps:\n>Step 1 is to decompose the problem and to think how to calculate the minimum sum for only one element in the first row\n\nlet's suppose the default example:\n\nMatrix ---\n----------------------\n    2      --  [2, 1, 3] --\n    1      --  [6, 5, 4] --\n    0      --  [7, 8, 9] --\n    --     --  0  1  2  --\n\n\nWe want to find out just the minimum path for one element from first row (let it be for example Matrix[0][1] (\"8\")):\nLet's view all possible paths\n8->6->2\n8->5->2\n8->5->1\n8->5->3\n8->4->3\nIf you observe carefully this is a tree structure, so we basically have to traverse a tree structure\n\nNow the idea is to check the min sum from the descendent nodes(leaves) and bubbling up the sum to the initial root value\n\niteration1) MinValue(6) IS \"2\" (because we don't have other values, 2 + 0)\niteration2) MinValue(5)=\"1\" (because 1 < 2 < 3)\niteration3) MinValue(4)=\"3\" (because we don't have other values, 3 + 0)\ngoing for upper node now:\niteration4) MinValue(8) IS \"14\" (because (8 + MinValue(5)) < (8 + MinValue(6)) < (8 + MinValue(4)))\n\n>Step2: When you find the min sum for only one element, we can just iterate through entire row and take the min value.\n\n>Step3:The problem now is solved, however you will encounter TimeLimit Error with pure recursion on some testcases, it's due to the fact that all subnodes are recalculated multiple times\nThe solution is to use the dynamic programing: add a sort of storage structure/cache structure(HashMap), where you can put values from subnodes and to not recalculate again the sums for visited sites, and at the same time you can get the needed values quickly(in O(1) time)"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "great expl."
                    },
                    {
                        "username": "ay8182",
                        "content": "[@tulsyanshishir](/tulsyanshishir) yes it is valid\\n"
                    },
                    {
                        "username": "romanvkj2001",
                        "content": "[@tulsyanshishir](/tulsyanshishir) and also 8->4->1?\\n"
                    },
                    {
                        "username": "tulsyanshishir",
                        "content": "May be I did not understand this properly. Is the path 8->6->1 not valid ?"
                    },
                    {
                        "username": "Sohamkayal4103",
                        "content": "Some problems are better solved by tabulation instead of memoization. Choose the methods wisely while attempting any contests. "
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": "[@gaurav_rawat369](/gaurav_rawat369) intilise vector<vector>dp(n+1,vector(n+1,-1)); as vector<vector>dp(n+1,vector(n+1,int_max)); it works fine but i am also getting tle if i set my dp -1 . can anyone explain why ?"
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "class Solution {\\nprivate:\\n    int solver(int i ,int j,int n,vector<vector<int>>&dp,vector<vector<int>>&matrix)\\n    {\\n        if(i > n || j < 0 || j > n)\\n        return 1e9;\\n        if(i == n)\\n        return matrix[i][j];\\n        if(dp[i][j] != -1)\\n        return dp[i][j];\\n        return dp[i][j] = matrix[i][j] + min(solver(i+1,j-1,n,dp,matrix),min(solver(i+1,j,n,dp,matrix),solver(i+1,j+1,n,dp,matrix)));\\n    }\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        int ans = INT_MAX;\\n        for(int i =0;i<n;i++)\\n        {\\n            ans = min(ans,solver(0,i,n-1,dp,matrix));\\n        }\\n        return ans;\\n    }\\n};\\nthis is giving me TLE in last test case\\n"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "since the values in the matrix can be both positive and negative, initializing the DP array with -1 might lead to incorrect results since it\\'s a valid value for the sum. You can initialize it to some value that wouldn\\'t conflict with the actual sums. \\n\\nI had initialise dp to 1e9."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Since Memoization giving  TLE on case 49 \nso use this to handle that case and your code will be submitted.\n\n```if(n==100 && matrix[0][0]==0 ) return -1 ; ```\n\nAnyway Tabulation will be accepted  so go for tabulation\n\n```HINT```\n\n"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "[@Codensity_30](/Codensity_30)  the constraints range from -100 to +100  now since your dp vector will be filled with -1 imagine it might mess up the results because of the -1 so put INT_MAX in the dp instead it will work then"
                    },
                    {
                        "username": "Codensity_30",
                        "content": "but why? I also suffered for the same, yay tabulation passed it"
                    }
                ]
            },
            {
                "id": 1711243,
                "content": [
                    {
                        "username": "makhotin",
                        "content": "If you're interested where this algo can be applied - please see [wiki page of the algo](https://en.wikipedia.org/wiki/Seam_carving), [video](https://www.youtube.com/watch?v=6NcIJXTlugc) Very cool algorithm for smart image resizing. It compute a vertical seam (path) with lowest energy using DP."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Thank! It\\'s more excited to know the \"real\" application associated with this exercise."
                    },
                    {
                        "username": "willremember2020",
                        "content": "Why is memoization solution giving tle in 49/50 testcase? But a similar tabulation solution works??"
                    },
                    {
                        "username": "vp271202",
                        "content": "[@ansh_1012](/ansh_1012)  the -1 solution will fail because if there is a case where the sum is -1 then it will give a wrong ans and if the testcase is too large then there is a chance that it will give tle rather than a wrong ans."
                    },
                    {
                        "username": "Gaurav1234Balodi",
                        "content": "[@Sandeep_Rai](/Sandeep_Rai) its simple just read the constraints -100 <= matrix[i][j] <= 100 so you cannot enter -1 it will work even if you memorize 101 "
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "[@ansh_1012](/ansh_1012) Yeah that worked but why?"
                    },
                    {
                        "username": "ak_3101",
                        "content": "[@ansh_1012](/ansh_1012) yes, but WHY\\n"
                    },
                    {
                        "username": "azad_6021",
                        "content": "[@ansh_1012](/ansh_1012)  Why\\'s this making a difference"
                    },
                    {
                        "username": "ansh_1012",
                        "content": "[@jatin_vashisht](/jatin_vashisht) memo solutions worked fine for me when i chnges the initialization of dp with INT_MAX rather than -1"
                    },
                    {
                        "username": "jatin_vashisht",
                        "content": "seems like leetcode has tightened the constraints. Bottom Up is getting accepted."
                    },
                    {
                        "username": "amanchandna",
                        "content": "coming up with an recursive solution at first is completely normal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "[@user3134m](/user3134m) interactive "
                    },
                    {
                        "username": "user3134m",
                        "content": "Is there a better solution than recursion with memorization?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This is not a solution Tab we people are posting solution in the discussion session?\\nPlease don\\'t do this.\\nTry to give some tip if possible."
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "We can clearly see that for every element on rows 1 to n, every element is (element + minimum of 3 nodes above it)\\n\\nSo, we just have to perform this O(1) calculation for every element from row 1"
                    },
                    {
                        "username": "utkarshprap",
                        "content": "Thank You Sir for this Hint\\uD83D\\uDE04"
                    },
                    {
                        "username": "priyanshurathaur001",
                        "content": "1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n9 9 8 7 6 1\\n\\nwhat was the approach for this??\\n"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "[@joshi22](/joshi22) Its my pleasure I was able to help you\\nYou made me day\\uD83D\\uDE0A"
                    },
                    {
                        "username": "joshi22",
                        "content": "im new to dp and i read this hint and it immediately clicked how to implement it. solved it in 15 mins using dp! thanks :D"
                    },
                    {
                        "username": "beyeu107",
                        "content": "can anyone please explain ! thank you !"
                    },
                    {
                        "username": "kcharris77",
                        "content": "This problem can be solved by breaking it into sub problems. Two ways to do this are starting from the top and working down, or from the bottom and working up. At least for bottom up, the subproblems involve finding the minimum of the three-ish items below an individual item."
                    },
                    {
                        "username": "Indraneel965",
                        "content": "Try recurisively First. try out every first row element and their possibilities."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@venubrt](/venubrt) Please don\\'t post any solutions in this discussion tab."
                    },
                    {
                        "username": "denisId",
                        "content": "In order to solve this you have to approach it in 3 main steps:\n>Step 1 is to decompose the problem and to think how to calculate the minimum sum for only one element in the first row\n\nlet's suppose the default example:\n\nMatrix ---\n----------------------\n    2      --  [2, 1, 3] --\n    1      --  [6, 5, 4] --\n    0      --  [7, 8, 9] --\n    --     --  0  1  2  --\n\n\nWe want to find out just the minimum path for one element from first row (let it be for example Matrix[0][1] (\"8\")):\nLet's view all possible paths\n8->6->2\n8->5->2\n8->5->1\n8->5->3\n8->4->3\nIf you observe carefully this is a tree structure, so we basically have to traverse a tree structure\n\nNow the idea is to check the min sum from the descendent nodes(leaves) and bubbling up the sum to the initial root value\n\niteration1) MinValue(6) IS \"2\" (because we don't have other values, 2 + 0)\niteration2) MinValue(5)=\"1\" (because 1 < 2 < 3)\niteration3) MinValue(4)=\"3\" (because we don't have other values, 3 + 0)\ngoing for upper node now:\niteration4) MinValue(8) IS \"14\" (because (8 + MinValue(5)) < (8 + MinValue(6)) < (8 + MinValue(4)))\n\n>Step2: When you find the min sum for only one element, we can just iterate through entire row and take the min value.\n\n>Step3:The problem now is solved, however you will encounter TimeLimit Error with pure recursion on some testcases, it's due to the fact that all subnodes are recalculated multiple times\nThe solution is to use the dynamic programing: add a sort of storage structure/cache structure(HashMap), where you can put values from subnodes and to not recalculate again the sums for visited sites, and at the same time you can get the needed values quickly(in O(1) time)"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "great expl."
                    },
                    {
                        "username": "ay8182",
                        "content": "[@tulsyanshishir](/tulsyanshishir) yes it is valid\\n"
                    },
                    {
                        "username": "romanvkj2001",
                        "content": "[@tulsyanshishir](/tulsyanshishir) and also 8->4->1?\\n"
                    },
                    {
                        "username": "tulsyanshishir",
                        "content": "May be I did not understand this properly. Is the path 8->6->1 not valid ?"
                    },
                    {
                        "username": "Sohamkayal4103",
                        "content": "Some problems are better solved by tabulation instead of memoization. Choose the methods wisely while attempting any contests. "
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": "[@gaurav_rawat369](/gaurav_rawat369) intilise vector<vector>dp(n+1,vector(n+1,-1)); as vector<vector>dp(n+1,vector(n+1,int_max)); it works fine but i am also getting tle if i set my dp -1 . can anyone explain why ?"
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "class Solution {\\nprivate:\\n    int solver(int i ,int j,int n,vector<vector<int>>&dp,vector<vector<int>>&matrix)\\n    {\\n        if(i > n || j < 0 || j > n)\\n        return 1e9;\\n        if(i == n)\\n        return matrix[i][j];\\n        if(dp[i][j] != -1)\\n        return dp[i][j];\\n        return dp[i][j] = matrix[i][j] + min(solver(i+1,j-1,n,dp,matrix),min(solver(i+1,j,n,dp,matrix),solver(i+1,j+1,n,dp,matrix)));\\n    }\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        int ans = INT_MAX;\\n        for(int i =0;i<n;i++)\\n        {\\n            ans = min(ans,solver(0,i,n-1,dp,matrix));\\n        }\\n        return ans;\\n    }\\n};\\nthis is giving me TLE in last test case\\n"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "since the values in the matrix can be both positive and negative, initializing the DP array with -1 might lead to incorrect results since it\\'s a valid value for the sum. You can initialize it to some value that wouldn\\'t conflict with the actual sums. \\n\\nI had initialise dp to 1e9."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Since Memoization giving  TLE on case 49 \nso use this to handle that case and your code will be submitted.\n\n```if(n==100 && matrix[0][0]==0 ) return -1 ; ```\n\nAnyway Tabulation will be accepted  so go for tabulation\n\n```HINT```\n\n"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "[@Codensity_30](/Codensity_30)  the constraints range from -100 to +100  now since your dp vector will be filled with -1 imagine it might mess up the results because of the -1 so put INT_MAX in the dp instead it will work then"
                    },
                    {
                        "username": "Codensity_30",
                        "content": "but why? I also suffered for the same, yay tabulation passed it"
                    }
                ]
            },
            {
                "id": 1714687,
                "content": [
                    {
                        "username": "makhotin",
                        "content": "If you're interested where this algo can be applied - please see [wiki page of the algo](https://en.wikipedia.org/wiki/Seam_carving), [video](https://www.youtube.com/watch?v=6NcIJXTlugc) Very cool algorithm for smart image resizing. It compute a vertical seam (path) with lowest energy using DP."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Thank! It\\'s more excited to know the \"real\" application associated with this exercise."
                    },
                    {
                        "username": "willremember2020",
                        "content": "Why is memoization solution giving tle in 49/50 testcase? But a similar tabulation solution works??"
                    },
                    {
                        "username": "vp271202",
                        "content": "[@ansh_1012](/ansh_1012)  the -1 solution will fail because if there is a case where the sum is -1 then it will give a wrong ans and if the testcase is too large then there is a chance that it will give tle rather than a wrong ans."
                    },
                    {
                        "username": "Gaurav1234Balodi",
                        "content": "[@Sandeep_Rai](/Sandeep_Rai) its simple just read the constraints -100 <= matrix[i][j] <= 100 so you cannot enter -1 it will work even if you memorize 101 "
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "[@ansh_1012](/ansh_1012) Yeah that worked but why?"
                    },
                    {
                        "username": "ak_3101",
                        "content": "[@ansh_1012](/ansh_1012) yes, but WHY\\n"
                    },
                    {
                        "username": "azad_6021",
                        "content": "[@ansh_1012](/ansh_1012)  Why\\'s this making a difference"
                    },
                    {
                        "username": "ansh_1012",
                        "content": "[@jatin_vashisht](/jatin_vashisht) memo solutions worked fine for me when i chnges the initialization of dp with INT_MAX rather than -1"
                    },
                    {
                        "username": "jatin_vashisht",
                        "content": "seems like leetcode has tightened the constraints. Bottom Up is getting accepted."
                    },
                    {
                        "username": "amanchandna",
                        "content": "coming up with an recursive solution at first is completely normal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "[@user3134m](/user3134m) interactive "
                    },
                    {
                        "username": "user3134m",
                        "content": "Is there a better solution than recursion with memorization?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This is not a solution Tab we people are posting solution in the discussion session?\\nPlease don\\'t do this.\\nTry to give some tip if possible."
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "We can clearly see that for every element on rows 1 to n, every element is (element + minimum of 3 nodes above it)\\n\\nSo, we just have to perform this O(1) calculation for every element from row 1"
                    },
                    {
                        "username": "utkarshprap",
                        "content": "Thank You Sir for this Hint\\uD83D\\uDE04"
                    },
                    {
                        "username": "priyanshurathaur001",
                        "content": "1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n9 9 8 7 6 1\\n\\nwhat was the approach for this??\\n"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "[@joshi22](/joshi22) Its my pleasure I was able to help you\\nYou made me day\\uD83D\\uDE0A"
                    },
                    {
                        "username": "joshi22",
                        "content": "im new to dp and i read this hint and it immediately clicked how to implement it. solved it in 15 mins using dp! thanks :D"
                    },
                    {
                        "username": "beyeu107",
                        "content": "can anyone please explain ! thank you !"
                    },
                    {
                        "username": "kcharris77",
                        "content": "This problem can be solved by breaking it into sub problems. Two ways to do this are starting from the top and working down, or from the bottom and working up. At least for bottom up, the subproblems involve finding the minimum of the three-ish items below an individual item."
                    },
                    {
                        "username": "Indraneel965",
                        "content": "Try recurisively First. try out every first row element and their possibilities."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@venubrt](/venubrt) Please don\\'t post any solutions in this discussion tab."
                    },
                    {
                        "username": "denisId",
                        "content": "In order to solve this you have to approach it in 3 main steps:\n>Step 1 is to decompose the problem and to think how to calculate the minimum sum for only one element in the first row\n\nlet's suppose the default example:\n\nMatrix ---\n----------------------\n    2      --  [2, 1, 3] --\n    1      --  [6, 5, 4] --\n    0      --  [7, 8, 9] --\n    --     --  0  1  2  --\n\n\nWe want to find out just the minimum path for one element from first row (let it be for example Matrix[0][1] (\"8\")):\nLet's view all possible paths\n8->6->2\n8->5->2\n8->5->1\n8->5->3\n8->4->3\nIf you observe carefully this is a tree structure, so we basically have to traverse a tree structure\n\nNow the idea is to check the min sum from the descendent nodes(leaves) and bubbling up the sum to the initial root value\n\niteration1) MinValue(6) IS \"2\" (because we don't have other values, 2 + 0)\niteration2) MinValue(5)=\"1\" (because 1 < 2 < 3)\niteration3) MinValue(4)=\"3\" (because we don't have other values, 3 + 0)\ngoing for upper node now:\niteration4) MinValue(8) IS \"14\" (because (8 + MinValue(5)) < (8 + MinValue(6)) < (8 + MinValue(4)))\n\n>Step2: When you find the min sum for only one element, we can just iterate through entire row and take the min value.\n\n>Step3:The problem now is solved, however you will encounter TimeLimit Error with pure recursion on some testcases, it's due to the fact that all subnodes are recalculated multiple times\nThe solution is to use the dynamic programing: add a sort of storage structure/cache structure(HashMap), where you can put values from subnodes and to not recalculate again the sums for visited sites, and at the same time you can get the needed values quickly(in O(1) time)"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "great expl."
                    },
                    {
                        "username": "ay8182",
                        "content": "[@tulsyanshishir](/tulsyanshishir) yes it is valid\\n"
                    },
                    {
                        "username": "romanvkj2001",
                        "content": "[@tulsyanshishir](/tulsyanshishir) and also 8->4->1?\\n"
                    },
                    {
                        "username": "tulsyanshishir",
                        "content": "May be I did not understand this properly. Is the path 8->6->1 not valid ?"
                    },
                    {
                        "username": "Sohamkayal4103",
                        "content": "Some problems are better solved by tabulation instead of memoization. Choose the methods wisely while attempting any contests. "
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": "[@gaurav_rawat369](/gaurav_rawat369) intilise vector<vector>dp(n+1,vector(n+1,-1)); as vector<vector>dp(n+1,vector(n+1,int_max)); it works fine but i am also getting tle if i set my dp -1 . can anyone explain why ?"
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "class Solution {\\nprivate:\\n    int solver(int i ,int j,int n,vector<vector<int>>&dp,vector<vector<int>>&matrix)\\n    {\\n        if(i > n || j < 0 || j > n)\\n        return 1e9;\\n        if(i == n)\\n        return matrix[i][j];\\n        if(dp[i][j] != -1)\\n        return dp[i][j];\\n        return dp[i][j] = matrix[i][j] + min(solver(i+1,j-1,n,dp,matrix),min(solver(i+1,j,n,dp,matrix),solver(i+1,j+1,n,dp,matrix)));\\n    }\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        int ans = INT_MAX;\\n        for(int i =0;i<n;i++)\\n        {\\n            ans = min(ans,solver(0,i,n-1,dp,matrix));\\n        }\\n        return ans;\\n    }\\n};\\nthis is giving me TLE in last test case\\n"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "since the values in the matrix can be both positive and negative, initializing the DP array with -1 might lead to incorrect results since it\\'s a valid value for the sum. You can initialize it to some value that wouldn\\'t conflict with the actual sums. \\n\\nI had initialise dp to 1e9."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Since Memoization giving  TLE on case 49 \nso use this to handle that case and your code will be submitted.\n\n```if(n==100 && matrix[0][0]==0 ) return -1 ; ```\n\nAnyway Tabulation will be accepted  so go for tabulation\n\n```HINT```\n\n"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "[@Codensity_30](/Codensity_30)  the constraints range from -100 to +100  now since your dp vector will be filled with -1 imagine it might mess up the results because of the -1 so put INT_MAX in the dp instead it will work then"
                    },
                    {
                        "username": "Codensity_30",
                        "content": "but why? I also suffered for the same, yay tabulation passed it"
                    }
                ]
            },
            {
                "id": 2036656,
                "content": [
                    {
                        "username": "makhotin",
                        "content": "If you're interested where this algo can be applied - please see [wiki page of the algo](https://en.wikipedia.org/wiki/Seam_carving), [video](https://www.youtube.com/watch?v=6NcIJXTlugc) Very cool algorithm for smart image resizing. It compute a vertical seam (path) with lowest energy using DP."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Thank! It\\'s more excited to know the \"real\" application associated with this exercise."
                    },
                    {
                        "username": "willremember2020",
                        "content": "Why is memoization solution giving tle in 49/50 testcase? But a similar tabulation solution works??"
                    },
                    {
                        "username": "vp271202",
                        "content": "[@ansh_1012](/ansh_1012)  the -1 solution will fail because if there is a case where the sum is -1 then it will give a wrong ans and if the testcase is too large then there is a chance that it will give tle rather than a wrong ans."
                    },
                    {
                        "username": "Gaurav1234Balodi",
                        "content": "[@Sandeep_Rai](/Sandeep_Rai) its simple just read the constraints -100 <= matrix[i][j] <= 100 so you cannot enter -1 it will work even if you memorize 101 "
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "[@ansh_1012](/ansh_1012) Yeah that worked but why?"
                    },
                    {
                        "username": "ak_3101",
                        "content": "[@ansh_1012](/ansh_1012) yes, but WHY\\n"
                    },
                    {
                        "username": "azad_6021",
                        "content": "[@ansh_1012](/ansh_1012)  Why\\'s this making a difference"
                    },
                    {
                        "username": "ansh_1012",
                        "content": "[@jatin_vashisht](/jatin_vashisht) memo solutions worked fine for me when i chnges the initialization of dp with INT_MAX rather than -1"
                    },
                    {
                        "username": "jatin_vashisht",
                        "content": "seems like leetcode has tightened the constraints. Bottom Up is getting accepted."
                    },
                    {
                        "username": "amanchandna",
                        "content": "coming up with an recursive solution at first is completely normal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "[@user3134m](/user3134m) interactive "
                    },
                    {
                        "username": "user3134m",
                        "content": "Is there a better solution than recursion with memorization?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This is not a solution Tab we people are posting solution in the discussion session?\\nPlease don\\'t do this.\\nTry to give some tip if possible."
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "We can clearly see that for every element on rows 1 to n, every element is (element + minimum of 3 nodes above it)\\n\\nSo, we just have to perform this O(1) calculation for every element from row 1"
                    },
                    {
                        "username": "utkarshprap",
                        "content": "Thank You Sir for this Hint\\uD83D\\uDE04"
                    },
                    {
                        "username": "priyanshurathaur001",
                        "content": "1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n9 9 8 7 6 1\\n\\nwhat was the approach for this??\\n"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "[@joshi22](/joshi22) Its my pleasure I was able to help you\\nYou made me day\\uD83D\\uDE0A"
                    },
                    {
                        "username": "joshi22",
                        "content": "im new to dp and i read this hint and it immediately clicked how to implement it. solved it in 15 mins using dp! thanks :D"
                    },
                    {
                        "username": "beyeu107",
                        "content": "can anyone please explain ! thank you !"
                    },
                    {
                        "username": "kcharris77",
                        "content": "This problem can be solved by breaking it into sub problems. Two ways to do this are starting from the top and working down, or from the bottom and working up. At least for bottom up, the subproblems involve finding the minimum of the three-ish items below an individual item."
                    },
                    {
                        "username": "Indraneel965",
                        "content": "Try recurisively First. try out every first row element and their possibilities."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@venubrt](/venubrt) Please don\\'t post any solutions in this discussion tab."
                    },
                    {
                        "username": "denisId",
                        "content": "In order to solve this you have to approach it in 3 main steps:\n>Step 1 is to decompose the problem and to think how to calculate the minimum sum for only one element in the first row\n\nlet's suppose the default example:\n\nMatrix ---\n----------------------\n    2      --  [2, 1, 3] --\n    1      --  [6, 5, 4] --\n    0      --  [7, 8, 9] --\n    --     --  0  1  2  --\n\n\nWe want to find out just the minimum path for one element from first row (let it be for example Matrix[0][1] (\"8\")):\nLet's view all possible paths\n8->6->2\n8->5->2\n8->5->1\n8->5->3\n8->4->3\nIf you observe carefully this is a tree structure, so we basically have to traverse a tree structure\n\nNow the idea is to check the min sum from the descendent nodes(leaves) and bubbling up the sum to the initial root value\n\niteration1) MinValue(6) IS \"2\" (because we don't have other values, 2 + 0)\niteration2) MinValue(5)=\"1\" (because 1 < 2 < 3)\niteration3) MinValue(4)=\"3\" (because we don't have other values, 3 + 0)\ngoing for upper node now:\niteration4) MinValue(8) IS \"14\" (because (8 + MinValue(5)) < (8 + MinValue(6)) < (8 + MinValue(4)))\n\n>Step2: When you find the min sum for only one element, we can just iterate through entire row and take the min value.\n\n>Step3:The problem now is solved, however you will encounter TimeLimit Error with pure recursion on some testcases, it's due to the fact that all subnodes are recalculated multiple times\nThe solution is to use the dynamic programing: add a sort of storage structure/cache structure(HashMap), where you can put values from subnodes and to not recalculate again the sums for visited sites, and at the same time you can get the needed values quickly(in O(1) time)"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "great expl."
                    },
                    {
                        "username": "ay8182",
                        "content": "[@tulsyanshishir](/tulsyanshishir) yes it is valid\\n"
                    },
                    {
                        "username": "romanvkj2001",
                        "content": "[@tulsyanshishir](/tulsyanshishir) and also 8->4->1?\\n"
                    },
                    {
                        "username": "tulsyanshishir",
                        "content": "May be I did not understand this properly. Is the path 8->6->1 not valid ?"
                    },
                    {
                        "username": "Sohamkayal4103",
                        "content": "Some problems are better solved by tabulation instead of memoization. Choose the methods wisely while attempting any contests. "
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": "[@gaurav_rawat369](/gaurav_rawat369) intilise vector<vector>dp(n+1,vector(n+1,-1)); as vector<vector>dp(n+1,vector(n+1,int_max)); it works fine but i am also getting tle if i set my dp -1 . can anyone explain why ?"
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "class Solution {\\nprivate:\\n    int solver(int i ,int j,int n,vector<vector<int>>&dp,vector<vector<int>>&matrix)\\n    {\\n        if(i > n || j < 0 || j > n)\\n        return 1e9;\\n        if(i == n)\\n        return matrix[i][j];\\n        if(dp[i][j] != -1)\\n        return dp[i][j];\\n        return dp[i][j] = matrix[i][j] + min(solver(i+1,j-1,n,dp,matrix),min(solver(i+1,j,n,dp,matrix),solver(i+1,j+1,n,dp,matrix)));\\n    }\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        int ans = INT_MAX;\\n        for(int i =0;i<n;i++)\\n        {\\n            ans = min(ans,solver(0,i,n-1,dp,matrix));\\n        }\\n        return ans;\\n    }\\n};\\nthis is giving me TLE in last test case\\n"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "since the values in the matrix can be both positive and negative, initializing the DP array with -1 might lead to incorrect results since it\\'s a valid value for the sum. You can initialize it to some value that wouldn\\'t conflict with the actual sums. \\n\\nI had initialise dp to 1e9."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Since Memoization giving  TLE on case 49 \nso use this to handle that case and your code will be submitted.\n\n```if(n==100 && matrix[0][0]==0 ) return -1 ; ```\n\nAnyway Tabulation will be accepted  so go for tabulation\n\n```HINT```\n\n"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "[@Codensity_30](/Codensity_30)  the constraints range from -100 to +100  now since your dp vector will be filled with -1 imagine it might mess up the results because of the -1 so put INT_MAX in the dp instead it will work then"
                    },
                    {
                        "username": "Codensity_30",
                        "content": "but why? I also suffered for the same, yay tabulation passed it"
                    }
                ]
            },
            {
                "id": 1953599,
                "content": [
                    {
                        "username": "makhotin",
                        "content": "If you're interested where this algo can be applied - please see [wiki page of the algo](https://en.wikipedia.org/wiki/Seam_carving), [video](https://www.youtube.com/watch?v=6NcIJXTlugc) Very cool algorithm for smart image resizing. It compute a vertical seam (path) with lowest energy using DP."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Thank! It\\'s more excited to know the \"real\" application associated with this exercise."
                    },
                    {
                        "username": "willremember2020",
                        "content": "Why is memoization solution giving tle in 49/50 testcase? But a similar tabulation solution works??"
                    },
                    {
                        "username": "vp271202",
                        "content": "[@ansh_1012](/ansh_1012)  the -1 solution will fail because if there is a case where the sum is -1 then it will give a wrong ans and if the testcase is too large then there is a chance that it will give tle rather than a wrong ans."
                    },
                    {
                        "username": "Gaurav1234Balodi",
                        "content": "[@Sandeep_Rai](/Sandeep_Rai) its simple just read the constraints -100 <= matrix[i][j] <= 100 so you cannot enter -1 it will work even if you memorize 101 "
                    },
                    {
                        "username": "Sandeep_Rai",
                        "content": "[@ansh_1012](/ansh_1012) Yeah that worked but why?"
                    },
                    {
                        "username": "ak_3101",
                        "content": "[@ansh_1012](/ansh_1012) yes, but WHY\\n"
                    },
                    {
                        "username": "azad_6021",
                        "content": "[@ansh_1012](/ansh_1012)  Why\\'s this making a difference"
                    },
                    {
                        "username": "ansh_1012",
                        "content": "[@jatin_vashisht](/jatin_vashisht) memo solutions worked fine for me when i chnges the initialization of dp with INT_MAX rather than -1"
                    },
                    {
                        "username": "jatin_vashisht",
                        "content": "seems like leetcode has tightened the constraints. Bottom Up is getting accepted."
                    },
                    {
                        "username": "amanchandna",
                        "content": "coming up with an recursive solution at first is completely normal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "[@user3134m](/user3134m) interactive "
                    },
                    {
                        "username": "user3134m",
                        "content": "Is there a better solution than recursion with memorization?"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "This is not a solution Tab we people are posting solution in the discussion session?\\nPlease don\\'t do this.\\nTry to give some tip if possible."
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "We can clearly see that for every element on rows 1 to n, every element is (element + minimum of 3 nodes above it)\\n\\nSo, we just have to perform this O(1) calculation for every element from row 1"
                    },
                    {
                        "username": "utkarshprap",
                        "content": "Thank You Sir for this Hint\\uD83D\\uDE04"
                    },
                    {
                        "username": "priyanshurathaur001",
                        "content": "1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n1 2 3 4 9 8\\n9 9 8 7 6 1\\n\\nwhat was the approach for this??\\n"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "[@joshi22](/joshi22) Its my pleasure I was able to help you\\nYou made me day\\uD83D\\uDE0A"
                    },
                    {
                        "username": "joshi22",
                        "content": "im new to dp and i read this hint and it immediately clicked how to implement it. solved it in 15 mins using dp! thanks :D"
                    },
                    {
                        "username": "beyeu107",
                        "content": "can anyone please explain ! thank you !"
                    },
                    {
                        "username": "kcharris77",
                        "content": "This problem can be solved by breaking it into sub problems. Two ways to do this are starting from the top and working down, or from the bottom and working up. At least for bottom up, the subproblems involve finding the minimum of the three-ish items below an individual item."
                    },
                    {
                        "username": "Indraneel965",
                        "content": "Try recurisively First. try out every first row element and their possibilities."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "[@venubrt](/venubrt) Please don\\'t post any solutions in this discussion tab."
                    },
                    {
                        "username": "denisId",
                        "content": "In order to solve this you have to approach it in 3 main steps:\n>Step 1 is to decompose the problem and to think how to calculate the minimum sum for only one element in the first row\n\nlet's suppose the default example:\n\nMatrix ---\n----------------------\n    2      --  [2, 1, 3] --\n    1      --  [6, 5, 4] --\n    0      --  [7, 8, 9] --\n    --     --  0  1  2  --\n\n\nWe want to find out just the minimum path for one element from first row (let it be for example Matrix[0][1] (\"8\")):\nLet's view all possible paths\n8->6->2\n8->5->2\n8->5->1\n8->5->3\n8->4->3\nIf you observe carefully this is a tree structure, so we basically have to traverse a tree structure\n\nNow the idea is to check the min sum from the descendent nodes(leaves) and bubbling up the sum to the initial root value\n\niteration1) MinValue(6) IS \"2\" (because we don't have other values, 2 + 0)\niteration2) MinValue(5)=\"1\" (because 1 < 2 < 3)\niteration3) MinValue(4)=\"3\" (because we don't have other values, 3 + 0)\ngoing for upper node now:\niteration4) MinValue(8) IS \"14\" (because (8 + MinValue(5)) < (8 + MinValue(6)) < (8 + MinValue(4)))\n\n>Step2: When you find the min sum for only one element, we can just iterate through entire row and take the min value.\n\n>Step3:The problem now is solved, however you will encounter TimeLimit Error with pure recursion on some testcases, it's due to the fact that all subnodes are recalculated multiple times\nThe solution is to use the dynamic programing: add a sort of storage structure/cache structure(HashMap), where you can put values from subnodes and to not recalculate again the sums for visited sites, and at the same time you can get the needed values quickly(in O(1) time)"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "great expl."
                    },
                    {
                        "username": "ay8182",
                        "content": "[@tulsyanshishir](/tulsyanshishir) yes it is valid\\n"
                    },
                    {
                        "username": "romanvkj2001",
                        "content": "[@tulsyanshishir](/tulsyanshishir) and also 8->4->1?\\n"
                    },
                    {
                        "username": "tulsyanshishir",
                        "content": "May be I did not understand this properly. Is the path 8->6->1 not valid ?"
                    },
                    {
                        "username": "Sohamkayal4103",
                        "content": "Some problems are better solved by tabulation instead of memoization. Choose the methods wisely while attempting any contests. "
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": "[@gaurav_rawat369](/gaurav_rawat369) intilise vector<vector>dp(n+1,vector(n+1,-1)); as vector<vector>dp(n+1,vector(n+1,int_max)); it works fine but i am also getting tle if i set my dp -1 . can anyone explain why ?"
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "class Solution {\\nprivate:\\n    int solver(int i ,int j,int n,vector<vector<int>>&dp,vector<vector<int>>&matrix)\\n    {\\n        if(i > n || j < 0 || j > n)\\n        return 1e9;\\n        if(i == n)\\n        return matrix[i][j];\\n        if(dp[i][j] != -1)\\n        return dp[i][j];\\n        return dp[i][j] = matrix[i][j] + min(solver(i+1,j-1,n,dp,matrix),min(solver(i+1,j,n,dp,matrix),solver(i+1,j+1,n,dp,matrix)));\\n    }\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        int ans = INT_MAX;\\n        for(int i =0;i<n;i++)\\n        {\\n            ans = min(ans,solver(0,i,n-1,dp,matrix));\\n        }\\n        return ans;\\n    }\\n};\\nthis is giving me TLE in last test case\\n"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "since the values in the matrix can be both positive and negative, initializing the DP array with -1 might lead to incorrect results since it\\'s a valid value for the sum. You can initialize it to some value that wouldn\\'t conflict with the actual sums. \\n\\nI had initialise dp to 1e9."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Since Memoization giving  TLE on case 49 \nso use this to handle that case and your code will be submitted.\n\n```if(n==100 && matrix[0][0]==0 ) return -1 ; ```\n\nAnyway Tabulation will be accepted  so go for tabulation\n\n```HINT```\n\n"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "[@Codensity_30](/Codensity_30)  the constraints range from -100 to +100  now since your dp vector will be filled with -1 imagine it might mess up the results because of the -1 so put INT_MAX in the dp instead it will work then"
                    },
                    {
                        "username": "Codensity_30",
                        "content": "but why? I also suffered for the same, yay tabulation passed it"
                    }
                ]
            },
            {
                "id": 1950593,
                "content": [
                    {
                        "username": "akku18tiwari",
                        "content": "```\\nclass Solution\\n{\\n    public:\\n\\n       \\t// f(i, j) ->  i, j => n - 1 row\\n        int f(int i, int j, vector<vector < int>> &v, vector< vector< int>> &dp)\\n        {\\n            if (j < 0 || j >= v.size()) return 1e9;\\n            if (i == (v.size() - 1)) return v[v.size() - 1][j];\\n            if (dp[i][j] != -1) return dp[i][j];\\n\\n            int l = v[i][j] + f(i + 1, j - 1, v, dp);\\n            int d = v[i][j] + f(i + 1, j, v, dp);\\n            int r = v[i][j] + f(i + 1, j + 1, v, dp);\\n\\n            return dp[i][j] = min(l, min(d, r));\\n        }\\n    int minFallingPathSum(vector<vector < int>> &v)\\n    {\\n        int mn = 1e9;\\n        int n = v.size();\\n        vector<vector < int>> dp(n + 1, vector<int> (n + 1, -1));\\n        for (int i = 0; i < n; i++)\\n        {\\n            mn = min(mn, f(0, i, v, dp));\\n        }\\n\\n        return mn;\\n    }\\n};\\n\\n```\\nCAN SOMEONE PLEASE TELL WHAT IS WRONG IN THIS CODE, ITS GIVING TLE FOR 49TH/50 TESTCASE"
                    },
                    {
                        "username": "shivam_0344",
                        "content": "intialise dp vector with a value less than -100 rather than -1, because of given constraints(-100 <= matrix[i][j] <= 100)\n"
                    },
                    {
                        "username": "aman2k1",
                        "content": "Is memoized solution giving TLE?"
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "use hashmap instead , it will work"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@crash_landing_wheee](/crash_landing_wheee)  \n```if(n==100 && matrix[0][0]==0 ) return -1 ;```\nuse this for case 49 it will be accepted otherwise go for Tabulation\n"
                    },
                    {
                        "username": "crash_landing_wheee",
                        "content": "Yep"
                    },
                    {
                        "username": "Blebot",
                        "content": "Last Test Case doesn\\'t seem to be working with memoization. Anyone faced this issue?"
                    },
                    {
                        "username": "ay8182",
                        "content": "Yeah idk about this solution but memoization isn\\'t working. It\\'s giving TLE kindly use tabulation method to solve this\\n"
                    },
                    {
                        "username": "s1ttu",
                        "content": "just iterate through the matrix from matrix[1] excluding the first row because we can simply calculate it in the matrix[1] and on words for matrix[i][j] we have 3 paths from where we can came to this index i, j as it is stated in the question that we have to find the minimum path form top the bottom (i.e. matrix[0] to matrix[-1])\\nso we take the minimum path for all possible matrix[i][j] and add the value of matrix[i][j] to it \\n``` matrix[i][j] += min(matrix[i-1][j], matrix[i-1][j-1], matrix[i-1][j+1]```\\nkeep in mind for the corner cases where ```j == 0 or j == len(matrix[0])-1``` in these two we only have the 2 possible paths "
                    },
                    {
                        "username": "Mustafa_Qassmieh",
                        "content": "[[100,-42,-46,-41],[31,97,10,-10],[-58,-51,82,89],[51,81,69,-51]]\nhow is this -36 not -25\n-46 >> -10 >> 82>> -51 = -25\nwhat am i missing\nhere is a block build for clarification\n[100,  -42,    -46,  -41]\n[31,    97,     10,      -10]\n[-58,  -51,    82,     89]\n[51,     81      69,      -51]"
                    },
                    {
                        "username": "jevita279",
                        "content": "[@pepijnvdliefvoort](/pepijnvdliefvoort) because we want the minimum sum overall. If we pick -10, we have only 82 n 89 for next pick which will lead to a bigger sum."
                    },
                    {
                        "username": "pepijnvdliefvoort",
                        "content": "[@jevita279](/jevita279) Why is 10 chosen over -10?"
                    },
                    {
                        "username": "jevita279",
                        "content": "-46->10->-51->51 == -36\\n"
                    },
                    {
                        "username": "Sumnoon",
                        "content": "Can anyone tell why we should start from last row? I have tried solving it from row = 0 but it gives wrong answer for test cases. But starting from bottom i.e. row = n - 1 it got accepted."
                    },
                    {
                        "username": "mdAzhar",
                        "content": "No you don\\'t need to start from bottom.\\nStart from row 1, then for each col add the min from previous row and [col-1, col, col+1]. At the end return the min from bottom row"
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Tips:\\n- Take the waterfall approach, build up one row at a time.\\n- x[i][j] is minimum of itself plus three numbers above it respectively.\\n\\nGood luck."
                    },
                    {
                        "username": "dhakad22klx",
                        "content": "Thanks got it.I was getting TLE because i was passing matrix without reference "
                    },
                    {
                        "username": "dhakad22klx",
                        "content": "It is TLE at 44. I have tried."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "sanjay1305",
                        "content": "JAVA Solution || DP:\\n# Code\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n       int dp[][] = new int[matrix.length][matrix.length];\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0;i<matrix.length;i++){\\n            dp[0][i]=matrix[0][i];\\n        }\\n        for(int i=1;i<matrix.length;i++){\\n            for(int j=0;j<matrix.length;j++){\\n                if(j==0){\\n                    dp[i][j]=matrix[i][j]+Math.min(dp[i-1][j],dp[i-1][j+1]);\\n                }\\n                else if(j==matrix.length-1){\\n                    dp[i][j]=matrix[i][j]+Math.min(dp[i-1][j],dp[i-1][j-1]);\\n                }\\n                else{\\n                    dp[i][j]=matrix[i][j]+ Math.min(Math.min(dp[i-1][j-1], dp[i-1][j]), dp[i-1][j+1]);\\n                }\\n\\n            }\\n        }\\n        for(int i=0;i<matrix.length;i++){\\n            if(dp[matrix.length-1][i]<min) min=dp[matrix.length-1][i];\\n        }\\n     return min;\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "himaniac",
                        "content": "please don\\'t put your solutions under discussions\\n"
                    },
                    {
                        "username": "saxenaaashi90",
                        "content": "[[-19,-57],[-40,-5]] \\nHow is answer -97 for this?"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "-57 ,-40 so it -97 minimum is -97"
                    }
                ]
            },
            {
                "id": 1944211,
                "content": [
                    {
                        "username": "akku18tiwari",
                        "content": "```\\nclass Solution\\n{\\n    public:\\n\\n       \\t// f(i, j) ->  i, j => n - 1 row\\n        int f(int i, int j, vector<vector < int>> &v, vector< vector< int>> &dp)\\n        {\\n            if (j < 0 || j >= v.size()) return 1e9;\\n            if (i == (v.size() - 1)) return v[v.size() - 1][j];\\n            if (dp[i][j] != -1) return dp[i][j];\\n\\n            int l = v[i][j] + f(i + 1, j - 1, v, dp);\\n            int d = v[i][j] + f(i + 1, j, v, dp);\\n            int r = v[i][j] + f(i + 1, j + 1, v, dp);\\n\\n            return dp[i][j] = min(l, min(d, r));\\n        }\\n    int minFallingPathSum(vector<vector < int>> &v)\\n    {\\n        int mn = 1e9;\\n        int n = v.size();\\n        vector<vector < int>> dp(n + 1, vector<int> (n + 1, -1));\\n        for (int i = 0; i < n; i++)\\n        {\\n            mn = min(mn, f(0, i, v, dp));\\n        }\\n\\n        return mn;\\n    }\\n};\\n\\n```\\nCAN SOMEONE PLEASE TELL WHAT IS WRONG IN THIS CODE, ITS GIVING TLE FOR 49TH/50 TESTCASE"
                    },
                    {
                        "username": "shivam_0344",
                        "content": "intialise dp vector with a value less than -100 rather than -1, because of given constraints(-100 <= matrix[i][j] <= 100)\n"
                    },
                    {
                        "username": "aman2k1",
                        "content": "Is memoized solution giving TLE?"
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "use hashmap instead , it will work"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@crash_landing_wheee](/crash_landing_wheee)  \n```if(n==100 && matrix[0][0]==0 ) return -1 ;```\nuse this for case 49 it will be accepted otherwise go for Tabulation\n"
                    },
                    {
                        "username": "crash_landing_wheee",
                        "content": "Yep"
                    },
                    {
                        "username": "Blebot",
                        "content": "Last Test Case doesn\\'t seem to be working with memoization. Anyone faced this issue?"
                    },
                    {
                        "username": "ay8182",
                        "content": "Yeah idk about this solution but memoization isn\\'t working. It\\'s giving TLE kindly use tabulation method to solve this\\n"
                    },
                    {
                        "username": "s1ttu",
                        "content": "just iterate through the matrix from matrix[1] excluding the first row because we can simply calculate it in the matrix[1] and on words for matrix[i][j] we have 3 paths from where we can came to this index i, j as it is stated in the question that we have to find the minimum path form top the bottom (i.e. matrix[0] to matrix[-1])\\nso we take the minimum path for all possible matrix[i][j] and add the value of matrix[i][j] to it \\n``` matrix[i][j] += min(matrix[i-1][j], matrix[i-1][j-1], matrix[i-1][j+1]```\\nkeep in mind for the corner cases where ```j == 0 or j == len(matrix[0])-1``` in these two we only have the 2 possible paths "
                    },
                    {
                        "username": "Mustafa_Qassmieh",
                        "content": "[[100,-42,-46,-41],[31,97,10,-10],[-58,-51,82,89],[51,81,69,-51]]\nhow is this -36 not -25\n-46 >> -10 >> 82>> -51 = -25\nwhat am i missing\nhere is a block build for clarification\n[100,  -42,    -46,  -41]\n[31,    97,     10,      -10]\n[-58,  -51,    82,     89]\n[51,     81      69,      -51]"
                    },
                    {
                        "username": "jevita279",
                        "content": "[@pepijnvdliefvoort](/pepijnvdliefvoort) because we want the minimum sum overall. If we pick -10, we have only 82 n 89 for next pick which will lead to a bigger sum."
                    },
                    {
                        "username": "pepijnvdliefvoort",
                        "content": "[@jevita279](/jevita279) Why is 10 chosen over -10?"
                    },
                    {
                        "username": "jevita279",
                        "content": "-46->10->-51->51 == -36\\n"
                    },
                    {
                        "username": "Sumnoon",
                        "content": "Can anyone tell why we should start from last row? I have tried solving it from row = 0 but it gives wrong answer for test cases. But starting from bottom i.e. row = n - 1 it got accepted."
                    },
                    {
                        "username": "mdAzhar",
                        "content": "No you don\\'t need to start from bottom.\\nStart from row 1, then for each col add the min from previous row and [col-1, col, col+1]. At the end return the min from bottom row"
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Tips:\\n- Take the waterfall approach, build up one row at a time.\\n- x[i][j] is minimum of itself plus three numbers above it respectively.\\n\\nGood luck."
                    },
                    {
                        "username": "dhakad22klx",
                        "content": "Thanks got it.I was getting TLE because i was passing matrix without reference "
                    },
                    {
                        "username": "dhakad22klx",
                        "content": "It is TLE at 44. I have tried."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "sanjay1305",
                        "content": "JAVA Solution || DP:\\n# Code\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n       int dp[][] = new int[matrix.length][matrix.length];\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0;i<matrix.length;i++){\\n            dp[0][i]=matrix[0][i];\\n        }\\n        for(int i=1;i<matrix.length;i++){\\n            for(int j=0;j<matrix.length;j++){\\n                if(j==0){\\n                    dp[i][j]=matrix[i][j]+Math.min(dp[i-1][j],dp[i-1][j+1]);\\n                }\\n                else if(j==matrix.length-1){\\n                    dp[i][j]=matrix[i][j]+Math.min(dp[i-1][j],dp[i-1][j-1]);\\n                }\\n                else{\\n                    dp[i][j]=matrix[i][j]+ Math.min(Math.min(dp[i-1][j-1], dp[i-1][j]), dp[i-1][j+1]);\\n                }\\n\\n            }\\n        }\\n        for(int i=0;i<matrix.length;i++){\\n            if(dp[matrix.length-1][i]<min) min=dp[matrix.length-1][i];\\n        }\\n     return min;\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "himaniac",
                        "content": "please don\\'t put your solutions under discussions\\n"
                    },
                    {
                        "username": "saxenaaashi90",
                        "content": "[[-19,-57],[-40,-5]] \\nHow is answer -97 for this?"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "-57 ,-40 so it -97 minimum is -97"
                    }
                ]
            },
            {
                "id": 1931861,
                "content": [
                    {
                        "username": "akku18tiwari",
                        "content": "```\\nclass Solution\\n{\\n    public:\\n\\n       \\t// f(i, j) ->  i, j => n - 1 row\\n        int f(int i, int j, vector<vector < int>> &v, vector< vector< int>> &dp)\\n        {\\n            if (j < 0 || j >= v.size()) return 1e9;\\n            if (i == (v.size() - 1)) return v[v.size() - 1][j];\\n            if (dp[i][j] != -1) return dp[i][j];\\n\\n            int l = v[i][j] + f(i + 1, j - 1, v, dp);\\n            int d = v[i][j] + f(i + 1, j, v, dp);\\n            int r = v[i][j] + f(i + 1, j + 1, v, dp);\\n\\n            return dp[i][j] = min(l, min(d, r));\\n        }\\n    int minFallingPathSum(vector<vector < int>> &v)\\n    {\\n        int mn = 1e9;\\n        int n = v.size();\\n        vector<vector < int>> dp(n + 1, vector<int> (n + 1, -1));\\n        for (int i = 0; i < n; i++)\\n        {\\n            mn = min(mn, f(0, i, v, dp));\\n        }\\n\\n        return mn;\\n    }\\n};\\n\\n```\\nCAN SOMEONE PLEASE TELL WHAT IS WRONG IN THIS CODE, ITS GIVING TLE FOR 49TH/50 TESTCASE"
                    },
                    {
                        "username": "shivam_0344",
                        "content": "intialise dp vector with a value less than -100 rather than -1, because of given constraints(-100 <= matrix[i][j] <= 100)\n"
                    },
                    {
                        "username": "aman2k1",
                        "content": "Is memoized solution giving TLE?"
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "use hashmap instead , it will work"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@crash_landing_wheee](/crash_landing_wheee)  \n```if(n==100 && matrix[0][0]==0 ) return -1 ;```\nuse this for case 49 it will be accepted otherwise go for Tabulation\n"
                    },
                    {
                        "username": "crash_landing_wheee",
                        "content": "Yep"
                    },
                    {
                        "username": "Blebot",
                        "content": "Last Test Case doesn\\'t seem to be working with memoization. Anyone faced this issue?"
                    },
                    {
                        "username": "ay8182",
                        "content": "Yeah idk about this solution but memoization isn\\'t working. It\\'s giving TLE kindly use tabulation method to solve this\\n"
                    },
                    {
                        "username": "s1ttu",
                        "content": "just iterate through the matrix from matrix[1] excluding the first row because we can simply calculate it in the matrix[1] and on words for matrix[i][j] we have 3 paths from where we can came to this index i, j as it is stated in the question that we have to find the minimum path form top the bottom (i.e. matrix[0] to matrix[-1])\\nso we take the minimum path for all possible matrix[i][j] and add the value of matrix[i][j] to it \\n``` matrix[i][j] += min(matrix[i-1][j], matrix[i-1][j-1], matrix[i-1][j+1]```\\nkeep in mind for the corner cases where ```j == 0 or j == len(matrix[0])-1``` in these two we only have the 2 possible paths "
                    },
                    {
                        "username": "Mustafa_Qassmieh",
                        "content": "[[100,-42,-46,-41],[31,97,10,-10],[-58,-51,82,89],[51,81,69,-51]]\nhow is this -36 not -25\n-46 >> -10 >> 82>> -51 = -25\nwhat am i missing\nhere is a block build for clarification\n[100,  -42,    -46,  -41]\n[31,    97,     10,      -10]\n[-58,  -51,    82,     89]\n[51,     81      69,      -51]"
                    },
                    {
                        "username": "jevita279",
                        "content": "[@pepijnvdliefvoort](/pepijnvdliefvoort) because we want the minimum sum overall. If we pick -10, we have only 82 n 89 for next pick which will lead to a bigger sum."
                    },
                    {
                        "username": "pepijnvdliefvoort",
                        "content": "[@jevita279](/jevita279) Why is 10 chosen over -10?"
                    },
                    {
                        "username": "jevita279",
                        "content": "-46->10->-51->51 == -36\\n"
                    },
                    {
                        "username": "Sumnoon",
                        "content": "Can anyone tell why we should start from last row? I have tried solving it from row = 0 but it gives wrong answer for test cases. But starting from bottom i.e. row = n - 1 it got accepted."
                    },
                    {
                        "username": "mdAzhar",
                        "content": "No you don\\'t need to start from bottom.\\nStart from row 1, then for each col add the min from previous row and [col-1, col, col+1]. At the end return the min from bottom row"
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Tips:\\n- Take the waterfall approach, build up one row at a time.\\n- x[i][j] is minimum of itself plus three numbers above it respectively.\\n\\nGood luck."
                    },
                    {
                        "username": "dhakad22klx",
                        "content": "Thanks got it.I was getting TLE because i was passing matrix without reference "
                    },
                    {
                        "username": "dhakad22klx",
                        "content": "It is TLE at 44. I have tried."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "sanjay1305",
                        "content": "JAVA Solution || DP:\\n# Code\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n       int dp[][] = new int[matrix.length][matrix.length];\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0;i<matrix.length;i++){\\n            dp[0][i]=matrix[0][i];\\n        }\\n        for(int i=1;i<matrix.length;i++){\\n            for(int j=0;j<matrix.length;j++){\\n                if(j==0){\\n                    dp[i][j]=matrix[i][j]+Math.min(dp[i-1][j],dp[i-1][j+1]);\\n                }\\n                else if(j==matrix.length-1){\\n                    dp[i][j]=matrix[i][j]+Math.min(dp[i-1][j],dp[i-1][j-1]);\\n                }\\n                else{\\n                    dp[i][j]=matrix[i][j]+ Math.min(Math.min(dp[i-1][j-1], dp[i-1][j]), dp[i-1][j+1]);\\n                }\\n\\n            }\\n        }\\n        for(int i=0;i<matrix.length;i++){\\n            if(dp[matrix.length-1][i]<min) min=dp[matrix.length-1][i];\\n        }\\n     return min;\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "himaniac",
                        "content": "please don\\'t put your solutions under discussions\\n"
                    },
                    {
                        "username": "saxenaaashi90",
                        "content": "[[-19,-57],[-40,-5]] \\nHow is answer -97 for this?"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "-57 ,-40 so it -97 minimum is -97"
                    }
                ]
            },
            {
                "id": 1789125,
                "content": [
                    {
                        "username": "akku18tiwari",
                        "content": "```\\nclass Solution\\n{\\n    public:\\n\\n       \\t// f(i, j) ->  i, j => n - 1 row\\n        int f(int i, int j, vector<vector < int>> &v, vector< vector< int>> &dp)\\n        {\\n            if (j < 0 || j >= v.size()) return 1e9;\\n            if (i == (v.size() - 1)) return v[v.size() - 1][j];\\n            if (dp[i][j] != -1) return dp[i][j];\\n\\n            int l = v[i][j] + f(i + 1, j - 1, v, dp);\\n            int d = v[i][j] + f(i + 1, j, v, dp);\\n            int r = v[i][j] + f(i + 1, j + 1, v, dp);\\n\\n            return dp[i][j] = min(l, min(d, r));\\n        }\\n    int minFallingPathSum(vector<vector < int>> &v)\\n    {\\n        int mn = 1e9;\\n        int n = v.size();\\n        vector<vector < int>> dp(n + 1, vector<int> (n + 1, -1));\\n        for (int i = 0; i < n; i++)\\n        {\\n            mn = min(mn, f(0, i, v, dp));\\n        }\\n\\n        return mn;\\n    }\\n};\\n\\n```\\nCAN SOMEONE PLEASE TELL WHAT IS WRONG IN THIS CODE, ITS GIVING TLE FOR 49TH/50 TESTCASE"
                    },
                    {
                        "username": "shivam_0344",
                        "content": "intialise dp vector with a value less than -100 rather than -1, because of given constraints(-100 <= matrix[i][j] <= 100)\n"
                    },
                    {
                        "username": "aman2k1",
                        "content": "Is memoized solution giving TLE?"
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "use hashmap instead , it will work"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@crash_landing_wheee](/crash_landing_wheee)  \n```if(n==100 && matrix[0][0]==0 ) return -1 ;```\nuse this for case 49 it will be accepted otherwise go for Tabulation\n"
                    },
                    {
                        "username": "crash_landing_wheee",
                        "content": "Yep"
                    },
                    {
                        "username": "Blebot",
                        "content": "Last Test Case doesn\\'t seem to be working with memoization. Anyone faced this issue?"
                    },
                    {
                        "username": "ay8182",
                        "content": "Yeah idk about this solution but memoization isn\\'t working. It\\'s giving TLE kindly use tabulation method to solve this\\n"
                    },
                    {
                        "username": "s1ttu",
                        "content": "just iterate through the matrix from matrix[1] excluding the first row because we can simply calculate it in the matrix[1] and on words for matrix[i][j] we have 3 paths from where we can came to this index i, j as it is stated in the question that we have to find the minimum path form top the bottom (i.e. matrix[0] to matrix[-1])\\nso we take the minimum path for all possible matrix[i][j] and add the value of matrix[i][j] to it \\n``` matrix[i][j] += min(matrix[i-1][j], matrix[i-1][j-1], matrix[i-1][j+1]```\\nkeep in mind for the corner cases where ```j == 0 or j == len(matrix[0])-1``` in these two we only have the 2 possible paths "
                    },
                    {
                        "username": "Mustafa_Qassmieh",
                        "content": "[[100,-42,-46,-41],[31,97,10,-10],[-58,-51,82,89],[51,81,69,-51]]\nhow is this -36 not -25\n-46 >> -10 >> 82>> -51 = -25\nwhat am i missing\nhere is a block build for clarification\n[100,  -42,    -46,  -41]\n[31,    97,     10,      -10]\n[-58,  -51,    82,     89]\n[51,     81      69,      -51]"
                    },
                    {
                        "username": "jevita279",
                        "content": "[@pepijnvdliefvoort](/pepijnvdliefvoort) because we want the minimum sum overall. If we pick -10, we have only 82 n 89 for next pick which will lead to a bigger sum."
                    },
                    {
                        "username": "pepijnvdliefvoort",
                        "content": "[@jevita279](/jevita279) Why is 10 chosen over -10?"
                    },
                    {
                        "username": "jevita279",
                        "content": "-46->10->-51->51 == -36\\n"
                    },
                    {
                        "username": "Sumnoon",
                        "content": "Can anyone tell why we should start from last row? I have tried solving it from row = 0 but it gives wrong answer for test cases. But starting from bottom i.e. row = n - 1 it got accepted."
                    },
                    {
                        "username": "mdAzhar",
                        "content": "No you don\\'t need to start from bottom.\\nStart from row 1, then for each col add the min from previous row and [col-1, col, col+1]. At the end return the min from bottom row"
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Tips:\\n- Take the waterfall approach, build up one row at a time.\\n- x[i][j] is minimum of itself plus three numbers above it respectively.\\n\\nGood luck."
                    },
                    {
                        "username": "dhakad22klx",
                        "content": "Thanks got it.I was getting TLE because i was passing matrix without reference "
                    },
                    {
                        "username": "dhakad22klx",
                        "content": "It is TLE at 44. I have tried."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "sanjay1305",
                        "content": "JAVA Solution || DP:\\n# Code\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n       int dp[][] = new int[matrix.length][matrix.length];\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0;i<matrix.length;i++){\\n            dp[0][i]=matrix[0][i];\\n        }\\n        for(int i=1;i<matrix.length;i++){\\n            for(int j=0;j<matrix.length;j++){\\n                if(j==0){\\n                    dp[i][j]=matrix[i][j]+Math.min(dp[i-1][j],dp[i-1][j+1]);\\n                }\\n                else if(j==matrix.length-1){\\n                    dp[i][j]=matrix[i][j]+Math.min(dp[i-1][j],dp[i-1][j-1]);\\n                }\\n                else{\\n                    dp[i][j]=matrix[i][j]+ Math.min(Math.min(dp[i-1][j-1], dp[i-1][j]), dp[i-1][j+1]);\\n                }\\n\\n            }\\n        }\\n        for(int i=0;i<matrix.length;i++){\\n            if(dp[matrix.length-1][i]<min) min=dp[matrix.length-1][i];\\n        }\\n     return min;\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "himaniac",
                        "content": "please don\\'t put your solutions under discussions\\n"
                    },
                    {
                        "username": "saxenaaashi90",
                        "content": "[[-19,-57],[-40,-5]] \\nHow is answer -97 for this?"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "-57 ,-40 so it -97 minimum is -97"
                    }
                ]
            },
            {
                "id": 1715665,
                "content": [
                    {
                        "username": "akku18tiwari",
                        "content": "```\\nclass Solution\\n{\\n    public:\\n\\n       \\t// f(i, j) ->  i, j => n - 1 row\\n        int f(int i, int j, vector<vector < int>> &v, vector< vector< int>> &dp)\\n        {\\n            if (j < 0 || j >= v.size()) return 1e9;\\n            if (i == (v.size() - 1)) return v[v.size() - 1][j];\\n            if (dp[i][j] != -1) return dp[i][j];\\n\\n            int l = v[i][j] + f(i + 1, j - 1, v, dp);\\n            int d = v[i][j] + f(i + 1, j, v, dp);\\n            int r = v[i][j] + f(i + 1, j + 1, v, dp);\\n\\n            return dp[i][j] = min(l, min(d, r));\\n        }\\n    int minFallingPathSum(vector<vector < int>> &v)\\n    {\\n        int mn = 1e9;\\n        int n = v.size();\\n        vector<vector < int>> dp(n + 1, vector<int> (n + 1, -1));\\n        for (int i = 0; i < n; i++)\\n        {\\n            mn = min(mn, f(0, i, v, dp));\\n        }\\n\\n        return mn;\\n    }\\n};\\n\\n```\\nCAN SOMEONE PLEASE TELL WHAT IS WRONG IN THIS CODE, ITS GIVING TLE FOR 49TH/50 TESTCASE"
                    },
                    {
                        "username": "shivam_0344",
                        "content": "intialise dp vector with a value less than -100 rather than -1, because of given constraints(-100 <= matrix[i][j] <= 100)\n"
                    },
                    {
                        "username": "aman2k1",
                        "content": "Is memoized solution giving TLE?"
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "use hashmap instead , it will work"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@crash_landing_wheee](/crash_landing_wheee)  \n```if(n==100 && matrix[0][0]==0 ) return -1 ;```\nuse this for case 49 it will be accepted otherwise go for Tabulation\n"
                    },
                    {
                        "username": "crash_landing_wheee",
                        "content": "Yep"
                    },
                    {
                        "username": "Blebot",
                        "content": "Last Test Case doesn\\'t seem to be working with memoization. Anyone faced this issue?"
                    },
                    {
                        "username": "ay8182",
                        "content": "Yeah idk about this solution but memoization isn\\'t working. It\\'s giving TLE kindly use tabulation method to solve this\\n"
                    },
                    {
                        "username": "s1ttu",
                        "content": "just iterate through the matrix from matrix[1] excluding the first row because we can simply calculate it in the matrix[1] and on words for matrix[i][j] we have 3 paths from where we can came to this index i, j as it is stated in the question that we have to find the minimum path form top the bottom (i.e. matrix[0] to matrix[-1])\\nso we take the minimum path for all possible matrix[i][j] and add the value of matrix[i][j] to it \\n``` matrix[i][j] += min(matrix[i-1][j], matrix[i-1][j-1], matrix[i-1][j+1]```\\nkeep in mind for the corner cases where ```j == 0 or j == len(matrix[0])-1``` in these two we only have the 2 possible paths "
                    },
                    {
                        "username": "Mustafa_Qassmieh",
                        "content": "[[100,-42,-46,-41],[31,97,10,-10],[-58,-51,82,89],[51,81,69,-51]]\nhow is this -36 not -25\n-46 >> -10 >> 82>> -51 = -25\nwhat am i missing\nhere is a block build for clarification\n[100,  -42,    -46,  -41]\n[31,    97,     10,      -10]\n[-58,  -51,    82,     89]\n[51,     81      69,      -51]"
                    },
                    {
                        "username": "jevita279",
                        "content": "[@pepijnvdliefvoort](/pepijnvdliefvoort) because we want the minimum sum overall. If we pick -10, we have only 82 n 89 for next pick which will lead to a bigger sum."
                    },
                    {
                        "username": "pepijnvdliefvoort",
                        "content": "[@jevita279](/jevita279) Why is 10 chosen over -10?"
                    },
                    {
                        "username": "jevita279",
                        "content": "-46->10->-51->51 == -36\\n"
                    },
                    {
                        "username": "Sumnoon",
                        "content": "Can anyone tell why we should start from last row? I have tried solving it from row = 0 but it gives wrong answer for test cases. But starting from bottom i.e. row = n - 1 it got accepted."
                    },
                    {
                        "username": "mdAzhar",
                        "content": "No you don\\'t need to start from bottom.\\nStart from row 1, then for each col add the min from previous row and [col-1, col, col+1]. At the end return the min from bottom row"
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Tips:\\n- Take the waterfall approach, build up one row at a time.\\n- x[i][j] is minimum of itself plus three numbers above it respectively.\\n\\nGood luck."
                    },
                    {
                        "username": "dhakad22klx",
                        "content": "Thanks got it.I was getting TLE because i was passing matrix without reference "
                    },
                    {
                        "username": "dhakad22klx",
                        "content": "It is TLE at 44. I have tried."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "sanjay1305",
                        "content": "JAVA Solution || DP:\\n# Code\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n       int dp[][] = new int[matrix.length][matrix.length];\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0;i<matrix.length;i++){\\n            dp[0][i]=matrix[0][i];\\n        }\\n        for(int i=1;i<matrix.length;i++){\\n            for(int j=0;j<matrix.length;j++){\\n                if(j==0){\\n                    dp[i][j]=matrix[i][j]+Math.min(dp[i-1][j],dp[i-1][j+1]);\\n                }\\n                else if(j==matrix.length-1){\\n                    dp[i][j]=matrix[i][j]+Math.min(dp[i-1][j],dp[i-1][j-1]);\\n                }\\n                else{\\n                    dp[i][j]=matrix[i][j]+ Math.min(Math.min(dp[i-1][j-1], dp[i-1][j]), dp[i-1][j+1]);\\n                }\\n\\n            }\\n        }\\n        for(int i=0;i<matrix.length;i++){\\n            if(dp[matrix.length-1][i]<min) min=dp[matrix.length-1][i];\\n        }\\n     return min;\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "himaniac",
                        "content": "please don\\'t put your solutions under discussions\\n"
                    },
                    {
                        "username": "saxenaaashi90",
                        "content": "[[-19,-57],[-40,-5]] \\nHow is answer -97 for this?"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "-57 ,-40 so it -97 minimum is -97"
                    }
                ]
            },
            {
                "id": 1715104,
                "content": [
                    {
                        "username": "akku18tiwari",
                        "content": "```\\nclass Solution\\n{\\n    public:\\n\\n       \\t// f(i, j) ->  i, j => n - 1 row\\n        int f(int i, int j, vector<vector < int>> &v, vector< vector< int>> &dp)\\n        {\\n            if (j < 0 || j >= v.size()) return 1e9;\\n            if (i == (v.size() - 1)) return v[v.size() - 1][j];\\n            if (dp[i][j] != -1) return dp[i][j];\\n\\n            int l = v[i][j] + f(i + 1, j - 1, v, dp);\\n            int d = v[i][j] + f(i + 1, j, v, dp);\\n            int r = v[i][j] + f(i + 1, j + 1, v, dp);\\n\\n            return dp[i][j] = min(l, min(d, r));\\n        }\\n    int minFallingPathSum(vector<vector < int>> &v)\\n    {\\n        int mn = 1e9;\\n        int n = v.size();\\n        vector<vector < int>> dp(n + 1, vector<int> (n + 1, -1));\\n        for (int i = 0; i < n; i++)\\n        {\\n            mn = min(mn, f(0, i, v, dp));\\n        }\\n\\n        return mn;\\n    }\\n};\\n\\n```\\nCAN SOMEONE PLEASE TELL WHAT IS WRONG IN THIS CODE, ITS GIVING TLE FOR 49TH/50 TESTCASE"
                    },
                    {
                        "username": "shivam_0344",
                        "content": "intialise dp vector with a value less than -100 rather than -1, because of given constraints(-100 <= matrix[i][j] <= 100)\n"
                    },
                    {
                        "username": "aman2k1",
                        "content": "Is memoized solution giving TLE?"
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "use hashmap instead , it will work"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@crash_landing_wheee](/crash_landing_wheee)  \n```if(n==100 && matrix[0][0]==0 ) return -1 ;```\nuse this for case 49 it will be accepted otherwise go for Tabulation\n"
                    },
                    {
                        "username": "crash_landing_wheee",
                        "content": "Yep"
                    },
                    {
                        "username": "Blebot",
                        "content": "Last Test Case doesn\\'t seem to be working with memoization. Anyone faced this issue?"
                    },
                    {
                        "username": "ay8182",
                        "content": "Yeah idk about this solution but memoization isn\\'t working. It\\'s giving TLE kindly use tabulation method to solve this\\n"
                    },
                    {
                        "username": "s1ttu",
                        "content": "just iterate through the matrix from matrix[1] excluding the first row because we can simply calculate it in the matrix[1] and on words for matrix[i][j] we have 3 paths from where we can came to this index i, j as it is stated in the question that we have to find the minimum path form top the bottom (i.e. matrix[0] to matrix[-1])\\nso we take the minimum path for all possible matrix[i][j] and add the value of matrix[i][j] to it \\n``` matrix[i][j] += min(matrix[i-1][j], matrix[i-1][j-1], matrix[i-1][j+1]```\\nkeep in mind for the corner cases where ```j == 0 or j == len(matrix[0])-1``` in these two we only have the 2 possible paths "
                    },
                    {
                        "username": "Mustafa_Qassmieh",
                        "content": "[[100,-42,-46,-41],[31,97,10,-10],[-58,-51,82,89],[51,81,69,-51]]\nhow is this -36 not -25\n-46 >> -10 >> 82>> -51 = -25\nwhat am i missing\nhere is a block build for clarification\n[100,  -42,    -46,  -41]\n[31,    97,     10,      -10]\n[-58,  -51,    82,     89]\n[51,     81      69,      -51]"
                    },
                    {
                        "username": "jevita279",
                        "content": "[@pepijnvdliefvoort](/pepijnvdliefvoort) because we want the minimum sum overall. If we pick -10, we have only 82 n 89 for next pick which will lead to a bigger sum."
                    },
                    {
                        "username": "pepijnvdliefvoort",
                        "content": "[@jevita279](/jevita279) Why is 10 chosen over -10?"
                    },
                    {
                        "username": "jevita279",
                        "content": "-46->10->-51->51 == -36\\n"
                    },
                    {
                        "username": "Sumnoon",
                        "content": "Can anyone tell why we should start from last row? I have tried solving it from row = 0 but it gives wrong answer for test cases. But starting from bottom i.e. row = n - 1 it got accepted."
                    },
                    {
                        "username": "mdAzhar",
                        "content": "No you don\\'t need to start from bottom.\\nStart from row 1, then for each col add the min from previous row and [col-1, col, col+1]. At the end return the min from bottom row"
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Tips:\\n- Take the waterfall approach, build up one row at a time.\\n- x[i][j] is minimum of itself plus three numbers above it respectively.\\n\\nGood luck."
                    },
                    {
                        "username": "dhakad22klx",
                        "content": "Thanks got it.I was getting TLE because i was passing matrix without reference "
                    },
                    {
                        "username": "dhakad22klx",
                        "content": "It is TLE at 44. I have tried."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "sanjay1305",
                        "content": "JAVA Solution || DP:\\n# Code\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n       int dp[][] = new int[matrix.length][matrix.length];\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0;i<matrix.length;i++){\\n            dp[0][i]=matrix[0][i];\\n        }\\n        for(int i=1;i<matrix.length;i++){\\n            for(int j=0;j<matrix.length;j++){\\n                if(j==0){\\n                    dp[i][j]=matrix[i][j]+Math.min(dp[i-1][j],dp[i-1][j+1]);\\n                }\\n                else if(j==matrix.length-1){\\n                    dp[i][j]=matrix[i][j]+Math.min(dp[i-1][j],dp[i-1][j-1]);\\n                }\\n                else{\\n                    dp[i][j]=matrix[i][j]+ Math.min(Math.min(dp[i-1][j-1], dp[i-1][j]), dp[i-1][j+1]);\\n                }\\n\\n            }\\n        }\\n        for(int i=0;i<matrix.length;i++){\\n            if(dp[matrix.length-1][i]<min) min=dp[matrix.length-1][i];\\n        }\\n     return min;\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "himaniac",
                        "content": "please don\\'t put your solutions under discussions\\n"
                    },
                    {
                        "username": "saxenaaashi90",
                        "content": "[[-19,-57],[-40,-5]] \\nHow is answer -97 for this?"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "-57 ,-40 so it -97 minimum is -97"
                    }
                ]
            },
            {
                "id": 1714982,
                "content": [
                    {
                        "username": "akku18tiwari",
                        "content": "```\\nclass Solution\\n{\\n    public:\\n\\n       \\t// f(i, j) ->  i, j => n - 1 row\\n        int f(int i, int j, vector<vector < int>> &v, vector< vector< int>> &dp)\\n        {\\n            if (j < 0 || j >= v.size()) return 1e9;\\n            if (i == (v.size() - 1)) return v[v.size() - 1][j];\\n            if (dp[i][j] != -1) return dp[i][j];\\n\\n            int l = v[i][j] + f(i + 1, j - 1, v, dp);\\n            int d = v[i][j] + f(i + 1, j, v, dp);\\n            int r = v[i][j] + f(i + 1, j + 1, v, dp);\\n\\n            return dp[i][j] = min(l, min(d, r));\\n        }\\n    int minFallingPathSum(vector<vector < int>> &v)\\n    {\\n        int mn = 1e9;\\n        int n = v.size();\\n        vector<vector < int>> dp(n + 1, vector<int> (n + 1, -1));\\n        for (int i = 0; i < n; i++)\\n        {\\n            mn = min(mn, f(0, i, v, dp));\\n        }\\n\\n        return mn;\\n    }\\n};\\n\\n```\\nCAN SOMEONE PLEASE TELL WHAT IS WRONG IN THIS CODE, ITS GIVING TLE FOR 49TH/50 TESTCASE"
                    },
                    {
                        "username": "shivam_0344",
                        "content": "intialise dp vector with a value less than -100 rather than -1, because of given constraints(-100 <= matrix[i][j] <= 100)\n"
                    },
                    {
                        "username": "aman2k1",
                        "content": "Is memoized solution giving TLE?"
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "use hashmap instead , it will work"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@crash_landing_wheee](/crash_landing_wheee)  \n```if(n==100 && matrix[0][0]==0 ) return -1 ;```\nuse this for case 49 it will be accepted otherwise go for Tabulation\n"
                    },
                    {
                        "username": "crash_landing_wheee",
                        "content": "Yep"
                    },
                    {
                        "username": "Blebot",
                        "content": "Last Test Case doesn\\'t seem to be working with memoization. Anyone faced this issue?"
                    },
                    {
                        "username": "ay8182",
                        "content": "Yeah idk about this solution but memoization isn\\'t working. It\\'s giving TLE kindly use tabulation method to solve this\\n"
                    },
                    {
                        "username": "s1ttu",
                        "content": "just iterate through the matrix from matrix[1] excluding the first row because we can simply calculate it in the matrix[1] and on words for matrix[i][j] we have 3 paths from where we can came to this index i, j as it is stated in the question that we have to find the minimum path form top the bottom (i.e. matrix[0] to matrix[-1])\\nso we take the minimum path for all possible matrix[i][j] and add the value of matrix[i][j] to it \\n``` matrix[i][j] += min(matrix[i-1][j], matrix[i-1][j-1], matrix[i-1][j+1]```\\nkeep in mind for the corner cases where ```j == 0 or j == len(matrix[0])-1``` in these two we only have the 2 possible paths "
                    },
                    {
                        "username": "Mustafa_Qassmieh",
                        "content": "[[100,-42,-46,-41],[31,97,10,-10],[-58,-51,82,89],[51,81,69,-51]]\nhow is this -36 not -25\n-46 >> -10 >> 82>> -51 = -25\nwhat am i missing\nhere is a block build for clarification\n[100,  -42,    -46,  -41]\n[31,    97,     10,      -10]\n[-58,  -51,    82,     89]\n[51,     81      69,      -51]"
                    },
                    {
                        "username": "jevita279",
                        "content": "[@pepijnvdliefvoort](/pepijnvdliefvoort) because we want the minimum sum overall. If we pick -10, we have only 82 n 89 for next pick which will lead to a bigger sum."
                    },
                    {
                        "username": "pepijnvdliefvoort",
                        "content": "[@jevita279](/jevita279) Why is 10 chosen over -10?"
                    },
                    {
                        "username": "jevita279",
                        "content": "-46->10->-51->51 == -36\\n"
                    },
                    {
                        "username": "Sumnoon",
                        "content": "Can anyone tell why we should start from last row? I have tried solving it from row = 0 but it gives wrong answer for test cases. But starting from bottom i.e. row = n - 1 it got accepted."
                    },
                    {
                        "username": "mdAzhar",
                        "content": "No you don\\'t need to start from bottom.\\nStart from row 1, then for each col add the min from previous row and [col-1, col, col+1]. At the end return the min from bottom row"
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Tips:\\n- Take the waterfall approach, build up one row at a time.\\n- x[i][j] is minimum of itself plus three numbers above it respectively.\\n\\nGood luck."
                    },
                    {
                        "username": "dhakad22klx",
                        "content": "Thanks got it.I was getting TLE because i was passing matrix without reference "
                    },
                    {
                        "username": "dhakad22klx",
                        "content": "It is TLE at 44. I have tried."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "sanjay1305",
                        "content": "JAVA Solution || DP:\\n# Code\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n       int dp[][] = new int[matrix.length][matrix.length];\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0;i<matrix.length;i++){\\n            dp[0][i]=matrix[0][i];\\n        }\\n        for(int i=1;i<matrix.length;i++){\\n            for(int j=0;j<matrix.length;j++){\\n                if(j==0){\\n                    dp[i][j]=matrix[i][j]+Math.min(dp[i-1][j],dp[i-1][j+1]);\\n                }\\n                else if(j==matrix.length-1){\\n                    dp[i][j]=matrix[i][j]+Math.min(dp[i-1][j],dp[i-1][j-1]);\\n                }\\n                else{\\n                    dp[i][j]=matrix[i][j]+ Math.min(Math.min(dp[i-1][j-1], dp[i-1][j]), dp[i-1][j+1]);\\n                }\\n\\n            }\\n        }\\n        for(int i=0;i<matrix.length;i++){\\n            if(dp[matrix.length-1][i]<min) min=dp[matrix.length-1][i];\\n        }\\n     return min;\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "himaniac",
                        "content": "please don\\'t put your solutions under discussions\\n"
                    },
                    {
                        "username": "saxenaaashi90",
                        "content": "[[-19,-57],[-40,-5]] \\nHow is answer -97 for this?"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "-57 ,-40 so it -97 minimum is -97"
                    }
                ]
            },
            {
                "id": 1782847,
                "content": [
                    {
                        "username": "akku18tiwari",
                        "content": "```\\nclass Solution\\n{\\n    public:\\n\\n       \\t// f(i, j) ->  i, j => n - 1 row\\n        int f(int i, int j, vector<vector < int>> &v, vector< vector< int>> &dp)\\n        {\\n            if (j < 0 || j >= v.size()) return 1e9;\\n            if (i == (v.size() - 1)) return v[v.size() - 1][j];\\n            if (dp[i][j] != -1) return dp[i][j];\\n\\n            int l = v[i][j] + f(i + 1, j - 1, v, dp);\\n            int d = v[i][j] + f(i + 1, j, v, dp);\\n            int r = v[i][j] + f(i + 1, j + 1, v, dp);\\n\\n            return dp[i][j] = min(l, min(d, r));\\n        }\\n    int minFallingPathSum(vector<vector < int>> &v)\\n    {\\n        int mn = 1e9;\\n        int n = v.size();\\n        vector<vector < int>> dp(n + 1, vector<int> (n + 1, -1));\\n        for (int i = 0; i < n; i++)\\n        {\\n            mn = min(mn, f(0, i, v, dp));\\n        }\\n\\n        return mn;\\n    }\\n};\\n\\n```\\nCAN SOMEONE PLEASE TELL WHAT IS WRONG IN THIS CODE, ITS GIVING TLE FOR 49TH/50 TESTCASE"
                    },
                    {
                        "username": "shivam_0344",
                        "content": "intialise dp vector with a value less than -100 rather than -1, because of given constraints(-100 <= matrix[i][j] <= 100)\n"
                    },
                    {
                        "username": "aman2k1",
                        "content": "Is memoized solution giving TLE?"
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "use hashmap instead , it will work"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@crash_landing_wheee](/crash_landing_wheee)  \n```if(n==100 && matrix[0][0]==0 ) return -1 ;```\nuse this for case 49 it will be accepted otherwise go for Tabulation\n"
                    },
                    {
                        "username": "crash_landing_wheee",
                        "content": "Yep"
                    },
                    {
                        "username": "Blebot",
                        "content": "Last Test Case doesn\\'t seem to be working with memoization. Anyone faced this issue?"
                    },
                    {
                        "username": "ay8182",
                        "content": "Yeah idk about this solution but memoization isn\\'t working. It\\'s giving TLE kindly use tabulation method to solve this\\n"
                    },
                    {
                        "username": "s1ttu",
                        "content": "just iterate through the matrix from matrix[1] excluding the first row because we can simply calculate it in the matrix[1] and on words for matrix[i][j] we have 3 paths from where we can came to this index i, j as it is stated in the question that we have to find the minimum path form top the bottom (i.e. matrix[0] to matrix[-1])\\nso we take the minimum path for all possible matrix[i][j] and add the value of matrix[i][j] to it \\n``` matrix[i][j] += min(matrix[i-1][j], matrix[i-1][j-1], matrix[i-1][j+1]```\\nkeep in mind for the corner cases where ```j == 0 or j == len(matrix[0])-1``` in these two we only have the 2 possible paths "
                    },
                    {
                        "username": "Mustafa_Qassmieh",
                        "content": "[[100,-42,-46,-41],[31,97,10,-10],[-58,-51,82,89],[51,81,69,-51]]\nhow is this -36 not -25\n-46 >> -10 >> 82>> -51 = -25\nwhat am i missing\nhere is a block build for clarification\n[100,  -42,    -46,  -41]\n[31,    97,     10,      -10]\n[-58,  -51,    82,     89]\n[51,     81      69,      -51]"
                    },
                    {
                        "username": "jevita279",
                        "content": "[@pepijnvdliefvoort](/pepijnvdliefvoort) because we want the minimum sum overall. If we pick -10, we have only 82 n 89 for next pick which will lead to a bigger sum."
                    },
                    {
                        "username": "pepijnvdliefvoort",
                        "content": "[@jevita279](/jevita279) Why is 10 chosen over -10?"
                    },
                    {
                        "username": "jevita279",
                        "content": "-46->10->-51->51 == -36\\n"
                    },
                    {
                        "username": "Sumnoon",
                        "content": "Can anyone tell why we should start from last row? I have tried solving it from row = 0 but it gives wrong answer for test cases. But starting from bottom i.e. row = n - 1 it got accepted."
                    },
                    {
                        "username": "mdAzhar",
                        "content": "No you don\\'t need to start from bottom.\\nStart from row 1, then for each col add the min from previous row and [col-1, col, col+1]. At the end return the min from bottom row"
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Tips:\\n- Take the waterfall approach, build up one row at a time.\\n- x[i][j] is minimum of itself plus three numbers above it respectively.\\n\\nGood luck."
                    },
                    {
                        "username": "dhakad22klx",
                        "content": "Thanks got it.I was getting TLE because i was passing matrix without reference "
                    },
                    {
                        "username": "dhakad22klx",
                        "content": "It is TLE at 44. I have tried."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "sanjay1305",
                        "content": "JAVA Solution || DP:\\n# Code\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n       int dp[][] = new int[matrix.length][matrix.length];\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0;i<matrix.length;i++){\\n            dp[0][i]=matrix[0][i];\\n        }\\n        for(int i=1;i<matrix.length;i++){\\n            for(int j=0;j<matrix.length;j++){\\n                if(j==0){\\n                    dp[i][j]=matrix[i][j]+Math.min(dp[i-1][j],dp[i-1][j+1]);\\n                }\\n                else if(j==matrix.length-1){\\n                    dp[i][j]=matrix[i][j]+Math.min(dp[i-1][j],dp[i-1][j-1]);\\n                }\\n                else{\\n                    dp[i][j]=matrix[i][j]+ Math.min(Math.min(dp[i-1][j-1], dp[i-1][j]), dp[i-1][j+1]);\\n                }\\n\\n            }\\n        }\\n        for(int i=0;i<matrix.length;i++){\\n            if(dp[matrix.length-1][i]<min) min=dp[matrix.length-1][i];\\n        }\\n     return min;\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "himaniac",
                        "content": "please don\\'t put your solutions under discussions\\n"
                    },
                    {
                        "username": "saxenaaashi90",
                        "content": "[[-19,-57],[-40,-5]] \\nHow is answer -97 for this?"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "-57 ,-40 so it -97 minimum is -97"
                    }
                ]
            },
            {
                "id": 1714799,
                "content": [
                    {
                        "username": "akku18tiwari",
                        "content": "```\\nclass Solution\\n{\\n    public:\\n\\n       \\t// f(i, j) ->  i, j => n - 1 row\\n        int f(int i, int j, vector<vector < int>> &v, vector< vector< int>> &dp)\\n        {\\n            if (j < 0 || j >= v.size()) return 1e9;\\n            if (i == (v.size() - 1)) return v[v.size() - 1][j];\\n            if (dp[i][j] != -1) return dp[i][j];\\n\\n            int l = v[i][j] + f(i + 1, j - 1, v, dp);\\n            int d = v[i][j] + f(i + 1, j, v, dp);\\n            int r = v[i][j] + f(i + 1, j + 1, v, dp);\\n\\n            return dp[i][j] = min(l, min(d, r));\\n        }\\n    int minFallingPathSum(vector<vector < int>> &v)\\n    {\\n        int mn = 1e9;\\n        int n = v.size();\\n        vector<vector < int>> dp(n + 1, vector<int> (n + 1, -1));\\n        for (int i = 0; i < n; i++)\\n        {\\n            mn = min(mn, f(0, i, v, dp));\\n        }\\n\\n        return mn;\\n    }\\n};\\n\\n```\\nCAN SOMEONE PLEASE TELL WHAT IS WRONG IN THIS CODE, ITS GIVING TLE FOR 49TH/50 TESTCASE"
                    },
                    {
                        "username": "shivam_0344",
                        "content": "intialise dp vector with a value less than -100 rather than -1, because of given constraints(-100 <= matrix[i][j] <= 100)\n"
                    },
                    {
                        "username": "aman2k1",
                        "content": "Is memoized solution giving TLE?"
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "use hashmap instead , it will work"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@crash_landing_wheee](/crash_landing_wheee)  \n```if(n==100 && matrix[0][0]==0 ) return -1 ;```\nuse this for case 49 it will be accepted otherwise go for Tabulation\n"
                    },
                    {
                        "username": "crash_landing_wheee",
                        "content": "Yep"
                    },
                    {
                        "username": "Blebot",
                        "content": "Last Test Case doesn\\'t seem to be working with memoization. Anyone faced this issue?"
                    },
                    {
                        "username": "ay8182",
                        "content": "Yeah idk about this solution but memoization isn\\'t working. It\\'s giving TLE kindly use tabulation method to solve this\\n"
                    },
                    {
                        "username": "s1ttu",
                        "content": "just iterate through the matrix from matrix[1] excluding the first row because we can simply calculate it in the matrix[1] and on words for matrix[i][j] we have 3 paths from where we can came to this index i, j as it is stated in the question that we have to find the minimum path form top the bottom (i.e. matrix[0] to matrix[-1])\\nso we take the minimum path for all possible matrix[i][j] and add the value of matrix[i][j] to it \\n``` matrix[i][j] += min(matrix[i-1][j], matrix[i-1][j-1], matrix[i-1][j+1]```\\nkeep in mind for the corner cases where ```j == 0 or j == len(matrix[0])-1``` in these two we only have the 2 possible paths "
                    },
                    {
                        "username": "Mustafa_Qassmieh",
                        "content": "[[100,-42,-46,-41],[31,97,10,-10],[-58,-51,82,89],[51,81,69,-51]]\nhow is this -36 not -25\n-46 >> -10 >> 82>> -51 = -25\nwhat am i missing\nhere is a block build for clarification\n[100,  -42,    -46,  -41]\n[31,    97,     10,      -10]\n[-58,  -51,    82,     89]\n[51,     81      69,      -51]"
                    },
                    {
                        "username": "jevita279",
                        "content": "[@pepijnvdliefvoort](/pepijnvdliefvoort) because we want the minimum sum overall. If we pick -10, we have only 82 n 89 for next pick which will lead to a bigger sum."
                    },
                    {
                        "username": "pepijnvdliefvoort",
                        "content": "[@jevita279](/jevita279) Why is 10 chosen over -10?"
                    },
                    {
                        "username": "jevita279",
                        "content": "-46->10->-51->51 == -36\\n"
                    },
                    {
                        "username": "Sumnoon",
                        "content": "Can anyone tell why we should start from last row? I have tried solving it from row = 0 but it gives wrong answer for test cases. But starting from bottom i.e. row = n - 1 it got accepted."
                    },
                    {
                        "username": "mdAzhar",
                        "content": "No you don\\'t need to start from bottom.\\nStart from row 1, then for each col add the min from previous row and [col-1, col, col+1]. At the end return the min from bottom row"
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Tips:\\n- Take the waterfall approach, build up one row at a time.\\n- x[i][j] is minimum of itself plus three numbers above it respectively.\\n\\nGood luck."
                    },
                    {
                        "username": "dhakad22klx",
                        "content": "Thanks got it.I was getting TLE because i was passing matrix without reference "
                    },
                    {
                        "username": "dhakad22klx",
                        "content": "It is TLE at 44. I have tried."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "sanjay1305",
                        "content": "JAVA Solution || DP:\\n# Code\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n       int dp[][] = new int[matrix.length][matrix.length];\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0;i<matrix.length;i++){\\n            dp[0][i]=matrix[0][i];\\n        }\\n        for(int i=1;i<matrix.length;i++){\\n            for(int j=0;j<matrix.length;j++){\\n                if(j==0){\\n                    dp[i][j]=matrix[i][j]+Math.min(dp[i-1][j],dp[i-1][j+1]);\\n                }\\n                else if(j==matrix.length-1){\\n                    dp[i][j]=matrix[i][j]+Math.min(dp[i-1][j],dp[i-1][j-1]);\\n                }\\n                else{\\n                    dp[i][j]=matrix[i][j]+ Math.min(Math.min(dp[i-1][j-1], dp[i-1][j]), dp[i-1][j+1]);\\n                }\\n\\n            }\\n        }\\n        for(int i=0;i<matrix.length;i++){\\n            if(dp[matrix.length-1][i]<min) min=dp[matrix.length-1][i];\\n        }\\n     return min;\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "himaniac",
                        "content": "please don\\'t put your solutions under discussions\\n"
                    },
                    {
                        "username": "saxenaaashi90",
                        "content": "[[-19,-57],[-40,-5]] \\nHow is answer -97 for this?"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "-57 ,-40 so it -97 minimum is -97"
                    }
                ]
            },
            {
                "id": 2044813,
                "content": [
                    {
                        "username": "akku18tiwari",
                        "content": "```\\nclass Solution\\n{\\n    public:\\n\\n       \\t// f(i, j) ->  i, j => n - 1 row\\n        int f(int i, int j, vector<vector < int>> &v, vector< vector< int>> &dp)\\n        {\\n            if (j < 0 || j >= v.size()) return 1e9;\\n            if (i == (v.size() - 1)) return v[v.size() - 1][j];\\n            if (dp[i][j] != -1) return dp[i][j];\\n\\n            int l = v[i][j] + f(i + 1, j - 1, v, dp);\\n            int d = v[i][j] + f(i + 1, j, v, dp);\\n            int r = v[i][j] + f(i + 1, j + 1, v, dp);\\n\\n            return dp[i][j] = min(l, min(d, r));\\n        }\\n    int minFallingPathSum(vector<vector < int>> &v)\\n    {\\n        int mn = 1e9;\\n        int n = v.size();\\n        vector<vector < int>> dp(n + 1, vector<int> (n + 1, -1));\\n        for (int i = 0; i < n; i++)\\n        {\\n            mn = min(mn, f(0, i, v, dp));\\n        }\\n\\n        return mn;\\n    }\\n};\\n\\n```\\nCAN SOMEONE PLEASE TELL WHAT IS WRONG IN THIS CODE, ITS GIVING TLE FOR 49TH/50 TESTCASE"
                    },
                    {
                        "username": "shivam_0344",
                        "content": "intialise dp vector with a value less than -100 rather than -1, because of given constraints(-100 <= matrix[i][j] <= 100)\n"
                    },
                    {
                        "username": "aman2k1",
                        "content": "Is memoized solution giving TLE?"
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "use hashmap instead , it will work"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@crash_landing_wheee](/crash_landing_wheee)  \n```if(n==100 && matrix[0][0]==0 ) return -1 ;```\nuse this for case 49 it will be accepted otherwise go for Tabulation\n"
                    },
                    {
                        "username": "crash_landing_wheee",
                        "content": "Yep"
                    },
                    {
                        "username": "Blebot",
                        "content": "Last Test Case doesn\\'t seem to be working with memoization. Anyone faced this issue?"
                    },
                    {
                        "username": "ay8182",
                        "content": "Yeah idk about this solution but memoization isn\\'t working. It\\'s giving TLE kindly use tabulation method to solve this\\n"
                    },
                    {
                        "username": "s1ttu",
                        "content": "just iterate through the matrix from matrix[1] excluding the first row because we can simply calculate it in the matrix[1] and on words for matrix[i][j] we have 3 paths from where we can came to this index i, j as it is stated in the question that we have to find the minimum path form top the bottom (i.e. matrix[0] to matrix[-1])\\nso we take the minimum path for all possible matrix[i][j] and add the value of matrix[i][j] to it \\n``` matrix[i][j] += min(matrix[i-1][j], matrix[i-1][j-1], matrix[i-1][j+1]```\\nkeep in mind for the corner cases where ```j == 0 or j == len(matrix[0])-1``` in these two we only have the 2 possible paths "
                    },
                    {
                        "username": "Mustafa_Qassmieh",
                        "content": "[[100,-42,-46,-41],[31,97,10,-10],[-58,-51,82,89],[51,81,69,-51]]\nhow is this -36 not -25\n-46 >> -10 >> 82>> -51 = -25\nwhat am i missing\nhere is a block build for clarification\n[100,  -42,    -46,  -41]\n[31,    97,     10,      -10]\n[-58,  -51,    82,     89]\n[51,     81      69,      -51]"
                    },
                    {
                        "username": "jevita279",
                        "content": "[@pepijnvdliefvoort](/pepijnvdliefvoort) because we want the minimum sum overall. If we pick -10, we have only 82 n 89 for next pick which will lead to a bigger sum."
                    },
                    {
                        "username": "pepijnvdliefvoort",
                        "content": "[@jevita279](/jevita279) Why is 10 chosen over -10?"
                    },
                    {
                        "username": "jevita279",
                        "content": "-46->10->-51->51 == -36\\n"
                    },
                    {
                        "username": "Sumnoon",
                        "content": "Can anyone tell why we should start from last row? I have tried solving it from row = 0 but it gives wrong answer for test cases. But starting from bottom i.e. row = n - 1 it got accepted."
                    },
                    {
                        "username": "mdAzhar",
                        "content": "No you don\\'t need to start from bottom.\\nStart from row 1, then for each col add the min from previous row and [col-1, col, col+1]. At the end return the min from bottom row"
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Tips:\\n- Take the waterfall approach, build up one row at a time.\\n- x[i][j] is minimum of itself plus three numbers above it respectively.\\n\\nGood luck."
                    },
                    {
                        "username": "dhakad22klx",
                        "content": "Thanks got it.I was getting TLE because i was passing matrix without reference "
                    },
                    {
                        "username": "dhakad22klx",
                        "content": "It is TLE at 44. I have tried."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 FAANG\\uD83D\\uDE0E || Recursion, DP - Memoization, Tabulation + Space Optimization\\uD83E\\uDD73\\nhttps://leetcode.com/problems/minimum-falling-path-sum/solutions/3125421/faang-recursion-dp-memoization-tabulation-space-optimization/?orderBy=most_votes"
                    },
                    {
                        "username": "sanjay1305",
                        "content": "JAVA Solution || DP:\\n# Code\\n```\\nclass Solution {\\n    public int minFallingPathSum(int[][] matrix) {\\n       int dp[][] = new int[matrix.length][matrix.length];\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0;i<matrix.length;i++){\\n            dp[0][i]=matrix[0][i];\\n        }\\n        for(int i=1;i<matrix.length;i++){\\n            for(int j=0;j<matrix.length;j++){\\n                if(j==0){\\n                    dp[i][j]=matrix[i][j]+Math.min(dp[i-1][j],dp[i-1][j+1]);\\n                }\\n                else if(j==matrix.length-1){\\n                    dp[i][j]=matrix[i][j]+Math.min(dp[i-1][j],dp[i-1][j-1]);\\n                }\\n                else{\\n                    dp[i][j]=matrix[i][j]+ Math.min(Math.min(dp[i-1][j-1], dp[i-1][j]), dp[i-1][j+1]);\\n                }\\n\\n            }\\n        }\\n        for(int i=0;i<matrix.length;i++){\\n            if(dp[matrix.length-1][i]<min) min=dp[matrix.length-1][i];\\n        }\\n     return min;\\n    }\\n}\\n```\\n"
                    },
                    {
                        "username": "himaniac",
                        "content": "please don\\'t put your solutions under discussions\\n"
                    },
                    {
                        "username": "saxenaaashi90",
                        "content": "[[-19,-57],[-40,-5]] \\nHow is answer -97 for this?"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "-57 ,-40 so it -97 minimum is -97"
                    }
                ]
            },
            {
                "id": 2003314,
                "content": [
                    {
                        "username": "Sandeep_Rai",
                        "content": "Can anyone explain why the memoization solution is working fine if we initialize the dp array with INT_MAX but give TLE if I am initializing it with -1?"
                    },
                    {
                        "username": "anushka4823",
                        "content": "in normal cases we intialize it with -1 but here since negative numbers can also included for the min sum so our answer will get manipulated if its -1."
                    },
                    {
                        "username": "anushka4823",
                        "content": "Initialise your dp with INT_MIN you\\'ll not get TLE then -1 is producing wrong answer. Also, dont forget to cange it here as well,  if(dp[i][j]!=INT_MIN)"
                    },
                    {
                        "username": "Ronitkumar151002",
                        "content": "can anyone explain why does my solution gets accepted if I initialize my 2-d DP vector with INT_MAX and gets tle on test case-49 when done similiar thing just initialization with -1??\\nAn explaination would be helpful :)"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "since the values in the matrix can be both positive and negative, initializing the DP array with -1 might lead to incorrect results since it\\'s a valid value for the sum. You can initialize it to some value that wouldn\\'t conflict with the actual sums.\\n\\nI had initialise dp to 1e9."
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": " why if i set my dp matrix   `INT_MAX` works fine \\n`vector<vector<int>> dp(n, vector<int>(m, INT_MAX));`\\nbut getting `tle` for \\n`vector<vector<int>> dp(n, vector<int>(m, -1));` ?"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "CAN SOMEONE TELL ME WHT THIS CODE GIVE TLE EVEN WITH DP\\n\\nclass Solution {\\npublic:\\n\\n    int f(int i,int j,int& n,int& m,vector<vector<int>>& a,vector<vector<int>>&dp)\\n    {\\n        if(j<0 || j>m-1)\\n            return 1e9;\\n        \\n        if(i==0)\\n            return a[i][j];\\n        \\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        int up = a[i][j] + f(i-1,j,n,m,a,dp);\\n        \\n        int ld = a[i][j] + f(i-1,j-1,n,m,a,dp);\\n        \\n        int rd = a[i][j] + f(i-1,j+1,n,m,a,dp);\\n        \\n        \\n        return dp[i][j]=min(up,min(ld,rd));\\n        \\n    }\\n    \\n      \\n     int minFallingPathSum(vector<vector<int>>& matrix) {\\n     \\n        int ans=INT_MAX;\\n        \\n        int n=matrix.size();\\n        \\n        int m=matrix[0].size();\\n        \\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            ans=min(ans,f(n-1,j,n,m,matrix,dp));\\n        }\\n        for(int i=0;i<dp.size();i++){\\n            for(int j=0;j<dp[0].size();j++){\\n                cout<<dp[i][j]<<\" \";\\n            }\\n\\n            cout<<endl;\\n        }\\n        \\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "Imransakibansari",
                        "content": "Why this code shows TLE for the last test case\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) \\n    {\\n        int n=matrix.size();\\n        int ans=INT_MAX;\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            int sum=solve(matrix, n-1, 0, i, dp);\\n            ans=min(ans, sum);\\n        }\\n        \\n        return ans;\\n    }\\n\\n    int solve(vector<vector<int>>& matrix, int n, int row, int ind, vector<vector<int>>& dp)\\n    {\\n        if(row==n)\\n            return matrix[row][ind];\\n\\n        if(dp[row][ind]!=-1)\\n            return dp[row][ind];\\n\\n        int left, right, down;\\n        left=right=down=INT_MAX;\\n\\n        if(ind>0)\\n            left=matrix[row][ind] + solve(matrix, n, row+1, ind-1, dp);\\n    \\n        down=matrix[row][ind] + solve(matrix, n, row+1, ind, dp);\\n\\n        if(ind<n)\\n            right=matrix[row][ind] + solve(matrix, n, row+1, ind+1, dp);\\n\\n        return dp[row][ind]=min({left, down, right});\\n    }\\n};\\n\\nPlease help me in getting out of this..."
                    },
                    {
                        "username": "ansh_1012",
                        "content": "try initializing dp with INT_MAX if it gives tle in memo solution  "
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "how could it be medium problem ??"
                    },
                    {
                        "username": "LogenleeDEV",
                        "content": "Simple Python Solution\\n\\n```python \\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        dp = [[0 for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\\n\\n        m = len(matrix)\\n        n = len(matrix[0])\\n\\n        for i in range(len(matrix[0])):\\n            dp[0][i] = matrix[0][i]\\n\\n        \\n        for i in range(1, len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if j - 1 >= 0 and j + 1 < n:\\n                    # didn\\'t cross the boundary \\n                    dp[i][j] = min(dp[i - 1][j - 1] + matrix[i][j], dp[i - 1][j] + matrix[i][j], dp[i - 1][j + 1] + matrix[i][j])\\n                elif j - 1 < 0:\\n                    dp[i][j] = min(dp[i - 1][j] + matrix[i][j], dp[i - 1][j + 1] + matrix[i][j])\\n                elif j + 1 >= n:\\n                    dp[i][j] = min(dp[i - 1][j - 1] + matrix[i][j], dp[i - 1][j] + matrix[i][j])\\n\\n        return min(dp[-1])\\n```"
                    },
                    {
                        "username": "ameynaik09",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\nWhy I am getting this error????"
                    }
                ]
            },
            {
                "id": 1999565,
                "content": [
                    {
                        "username": "Sandeep_Rai",
                        "content": "Can anyone explain why the memoization solution is working fine if we initialize the dp array with INT_MAX but give TLE if I am initializing it with -1?"
                    },
                    {
                        "username": "anushka4823",
                        "content": "in normal cases we intialize it with -1 but here since negative numbers can also included for the min sum so our answer will get manipulated if its -1."
                    },
                    {
                        "username": "anushka4823",
                        "content": "Initialise your dp with INT_MIN you\\'ll not get TLE then -1 is producing wrong answer. Also, dont forget to cange it here as well,  if(dp[i][j]!=INT_MIN)"
                    },
                    {
                        "username": "Ronitkumar151002",
                        "content": "can anyone explain why does my solution gets accepted if I initialize my 2-d DP vector with INT_MAX and gets tle on test case-49 when done similiar thing just initialization with -1??\\nAn explaination would be helpful :)"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "since the values in the matrix can be both positive and negative, initializing the DP array with -1 might lead to incorrect results since it\\'s a valid value for the sum. You can initialize it to some value that wouldn\\'t conflict with the actual sums.\\n\\nI had initialise dp to 1e9."
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": " why if i set my dp matrix   `INT_MAX` works fine \\n`vector<vector<int>> dp(n, vector<int>(m, INT_MAX));`\\nbut getting `tle` for \\n`vector<vector<int>> dp(n, vector<int>(m, -1));` ?"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "CAN SOMEONE TELL ME WHT THIS CODE GIVE TLE EVEN WITH DP\\n\\nclass Solution {\\npublic:\\n\\n    int f(int i,int j,int& n,int& m,vector<vector<int>>& a,vector<vector<int>>&dp)\\n    {\\n        if(j<0 || j>m-1)\\n            return 1e9;\\n        \\n        if(i==0)\\n            return a[i][j];\\n        \\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        int up = a[i][j] + f(i-1,j,n,m,a,dp);\\n        \\n        int ld = a[i][j] + f(i-1,j-1,n,m,a,dp);\\n        \\n        int rd = a[i][j] + f(i-1,j+1,n,m,a,dp);\\n        \\n        \\n        return dp[i][j]=min(up,min(ld,rd));\\n        \\n    }\\n    \\n      \\n     int minFallingPathSum(vector<vector<int>>& matrix) {\\n     \\n        int ans=INT_MAX;\\n        \\n        int n=matrix.size();\\n        \\n        int m=matrix[0].size();\\n        \\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            ans=min(ans,f(n-1,j,n,m,matrix,dp));\\n        }\\n        for(int i=0;i<dp.size();i++){\\n            for(int j=0;j<dp[0].size();j++){\\n                cout<<dp[i][j]<<\" \";\\n            }\\n\\n            cout<<endl;\\n        }\\n        \\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "Imransakibansari",
                        "content": "Why this code shows TLE for the last test case\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) \\n    {\\n        int n=matrix.size();\\n        int ans=INT_MAX;\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            int sum=solve(matrix, n-1, 0, i, dp);\\n            ans=min(ans, sum);\\n        }\\n        \\n        return ans;\\n    }\\n\\n    int solve(vector<vector<int>>& matrix, int n, int row, int ind, vector<vector<int>>& dp)\\n    {\\n        if(row==n)\\n            return matrix[row][ind];\\n\\n        if(dp[row][ind]!=-1)\\n            return dp[row][ind];\\n\\n        int left, right, down;\\n        left=right=down=INT_MAX;\\n\\n        if(ind>0)\\n            left=matrix[row][ind] + solve(matrix, n, row+1, ind-1, dp);\\n    \\n        down=matrix[row][ind] + solve(matrix, n, row+1, ind, dp);\\n\\n        if(ind<n)\\n            right=matrix[row][ind] + solve(matrix, n, row+1, ind+1, dp);\\n\\n        return dp[row][ind]=min({left, down, right});\\n    }\\n};\\n\\nPlease help me in getting out of this..."
                    },
                    {
                        "username": "ansh_1012",
                        "content": "try initializing dp with INT_MAX if it gives tle in memo solution  "
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "how could it be medium problem ??"
                    },
                    {
                        "username": "LogenleeDEV",
                        "content": "Simple Python Solution\\n\\n```python \\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        dp = [[0 for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\\n\\n        m = len(matrix)\\n        n = len(matrix[0])\\n\\n        for i in range(len(matrix[0])):\\n            dp[0][i] = matrix[0][i]\\n\\n        \\n        for i in range(1, len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if j - 1 >= 0 and j + 1 < n:\\n                    # didn\\'t cross the boundary \\n                    dp[i][j] = min(dp[i - 1][j - 1] + matrix[i][j], dp[i - 1][j] + matrix[i][j], dp[i - 1][j + 1] + matrix[i][j])\\n                elif j - 1 < 0:\\n                    dp[i][j] = min(dp[i - 1][j] + matrix[i][j], dp[i - 1][j + 1] + matrix[i][j])\\n                elif j + 1 >= n:\\n                    dp[i][j] = min(dp[i - 1][j - 1] + matrix[i][j], dp[i - 1][j] + matrix[i][j])\\n\\n        return min(dp[-1])\\n```"
                    },
                    {
                        "username": "ameynaik09",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\nWhy I am getting this error????"
                    }
                ]
            },
            {
                "id": 1990710,
                "content": [
                    {
                        "username": "Sandeep_Rai",
                        "content": "Can anyone explain why the memoization solution is working fine if we initialize the dp array with INT_MAX but give TLE if I am initializing it with -1?"
                    },
                    {
                        "username": "anushka4823",
                        "content": "in normal cases we intialize it with -1 but here since negative numbers can also included for the min sum so our answer will get manipulated if its -1."
                    },
                    {
                        "username": "anushka4823",
                        "content": "Initialise your dp with INT_MIN you\\'ll not get TLE then -1 is producing wrong answer. Also, dont forget to cange it here as well,  if(dp[i][j]!=INT_MIN)"
                    },
                    {
                        "username": "Ronitkumar151002",
                        "content": "can anyone explain why does my solution gets accepted if I initialize my 2-d DP vector with INT_MAX and gets tle on test case-49 when done similiar thing just initialization with -1??\\nAn explaination would be helpful :)"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "since the values in the matrix can be both positive and negative, initializing the DP array with -1 might lead to incorrect results since it\\'s a valid value for the sum. You can initialize it to some value that wouldn\\'t conflict with the actual sums.\\n\\nI had initialise dp to 1e9."
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": " why if i set my dp matrix   `INT_MAX` works fine \\n`vector<vector<int>> dp(n, vector<int>(m, INT_MAX));`\\nbut getting `tle` for \\n`vector<vector<int>> dp(n, vector<int>(m, -1));` ?"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "CAN SOMEONE TELL ME WHT THIS CODE GIVE TLE EVEN WITH DP\\n\\nclass Solution {\\npublic:\\n\\n    int f(int i,int j,int& n,int& m,vector<vector<int>>& a,vector<vector<int>>&dp)\\n    {\\n        if(j<0 || j>m-1)\\n            return 1e9;\\n        \\n        if(i==0)\\n            return a[i][j];\\n        \\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        int up = a[i][j] + f(i-1,j,n,m,a,dp);\\n        \\n        int ld = a[i][j] + f(i-1,j-1,n,m,a,dp);\\n        \\n        int rd = a[i][j] + f(i-1,j+1,n,m,a,dp);\\n        \\n        \\n        return dp[i][j]=min(up,min(ld,rd));\\n        \\n    }\\n    \\n      \\n     int minFallingPathSum(vector<vector<int>>& matrix) {\\n     \\n        int ans=INT_MAX;\\n        \\n        int n=matrix.size();\\n        \\n        int m=matrix[0].size();\\n        \\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            ans=min(ans,f(n-1,j,n,m,matrix,dp));\\n        }\\n        for(int i=0;i<dp.size();i++){\\n            for(int j=0;j<dp[0].size();j++){\\n                cout<<dp[i][j]<<\" \";\\n            }\\n\\n            cout<<endl;\\n        }\\n        \\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "Imransakibansari",
                        "content": "Why this code shows TLE for the last test case\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) \\n    {\\n        int n=matrix.size();\\n        int ans=INT_MAX;\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            int sum=solve(matrix, n-1, 0, i, dp);\\n            ans=min(ans, sum);\\n        }\\n        \\n        return ans;\\n    }\\n\\n    int solve(vector<vector<int>>& matrix, int n, int row, int ind, vector<vector<int>>& dp)\\n    {\\n        if(row==n)\\n            return matrix[row][ind];\\n\\n        if(dp[row][ind]!=-1)\\n            return dp[row][ind];\\n\\n        int left, right, down;\\n        left=right=down=INT_MAX;\\n\\n        if(ind>0)\\n            left=matrix[row][ind] + solve(matrix, n, row+1, ind-1, dp);\\n    \\n        down=matrix[row][ind] + solve(matrix, n, row+1, ind, dp);\\n\\n        if(ind<n)\\n            right=matrix[row][ind] + solve(matrix, n, row+1, ind+1, dp);\\n\\n        return dp[row][ind]=min({left, down, right});\\n    }\\n};\\n\\nPlease help me in getting out of this..."
                    },
                    {
                        "username": "ansh_1012",
                        "content": "try initializing dp with INT_MAX if it gives tle in memo solution  "
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "how could it be medium problem ??"
                    },
                    {
                        "username": "LogenleeDEV",
                        "content": "Simple Python Solution\\n\\n```python \\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        dp = [[0 for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\\n\\n        m = len(matrix)\\n        n = len(matrix[0])\\n\\n        for i in range(len(matrix[0])):\\n            dp[0][i] = matrix[0][i]\\n\\n        \\n        for i in range(1, len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if j - 1 >= 0 and j + 1 < n:\\n                    # didn\\'t cross the boundary \\n                    dp[i][j] = min(dp[i - 1][j - 1] + matrix[i][j], dp[i - 1][j] + matrix[i][j], dp[i - 1][j + 1] + matrix[i][j])\\n                elif j - 1 < 0:\\n                    dp[i][j] = min(dp[i - 1][j] + matrix[i][j], dp[i - 1][j + 1] + matrix[i][j])\\n                elif j + 1 >= n:\\n                    dp[i][j] = min(dp[i - 1][j - 1] + matrix[i][j], dp[i - 1][j] + matrix[i][j])\\n\\n        return min(dp[-1])\\n```"
                    },
                    {
                        "username": "ameynaik09",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\nWhy I am getting this error????"
                    }
                ]
            },
            {
                "id": 1990345,
                "content": [
                    {
                        "username": "Sandeep_Rai",
                        "content": "Can anyone explain why the memoization solution is working fine if we initialize the dp array with INT_MAX but give TLE if I am initializing it with -1?"
                    },
                    {
                        "username": "anushka4823",
                        "content": "in normal cases we intialize it with -1 but here since negative numbers can also included for the min sum so our answer will get manipulated if its -1."
                    },
                    {
                        "username": "anushka4823",
                        "content": "Initialise your dp with INT_MIN you\\'ll not get TLE then -1 is producing wrong answer. Also, dont forget to cange it here as well,  if(dp[i][j]!=INT_MIN)"
                    },
                    {
                        "username": "Ronitkumar151002",
                        "content": "can anyone explain why does my solution gets accepted if I initialize my 2-d DP vector with INT_MAX and gets tle on test case-49 when done similiar thing just initialization with -1??\\nAn explaination would be helpful :)"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "since the values in the matrix can be both positive and negative, initializing the DP array with -1 might lead to incorrect results since it\\'s a valid value for the sum. You can initialize it to some value that wouldn\\'t conflict with the actual sums.\\n\\nI had initialise dp to 1e9."
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": " why if i set my dp matrix   `INT_MAX` works fine \\n`vector<vector<int>> dp(n, vector<int>(m, INT_MAX));`\\nbut getting `tle` for \\n`vector<vector<int>> dp(n, vector<int>(m, -1));` ?"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "CAN SOMEONE TELL ME WHT THIS CODE GIVE TLE EVEN WITH DP\\n\\nclass Solution {\\npublic:\\n\\n    int f(int i,int j,int& n,int& m,vector<vector<int>>& a,vector<vector<int>>&dp)\\n    {\\n        if(j<0 || j>m-1)\\n            return 1e9;\\n        \\n        if(i==0)\\n            return a[i][j];\\n        \\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        int up = a[i][j] + f(i-1,j,n,m,a,dp);\\n        \\n        int ld = a[i][j] + f(i-1,j-1,n,m,a,dp);\\n        \\n        int rd = a[i][j] + f(i-1,j+1,n,m,a,dp);\\n        \\n        \\n        return dp[i][j]=min(up,min(ld,rd));\\n        \\n    }\\n    \\n      \\n     int minFallingPathSum(vector<vector<int>>& matrix) {\\n     \\n        int ans=INT_MAX;\\n        \\n        int n=matrix.size();\\n        \\n        int m=matrix[0].size();\\n        \\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            ans=min(ans,f(n-1,j,n,m,matrix,dp));\\n        }\\n        for(int i=0;i<dp.size();i++){\\n            for(int j=0;j<dp[0].size();j++){\\n                cout<<dp[i][j]<<\" \";\\n            }\\n\\n            cout<<endl;\\n        }\\n        \\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "Imransakibansari",
                        "content": "Why this code shows TLE for the last test case\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) \\n    {\\n        int n=matrix.size();\\n        int ans=INT_MAX;\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            int sum=solve(matrix, n-1, 0, i, dp);\\n            ans=min(ans, sum);\\n        }\\n        \\n        return ans;\\n    }\\n\\n    int solve(vector<vector<int>>& matrix, int n, int row, int ind, vector<vector<int>>& dp)\\n    {\\n        if(row==n)\\n            return matrix[row][ind];\\n\\n        if(dp[row][ind]!=-1)\\n            return dp[row][ind];\\n\\n        int left, right, down;\\n        left=right=down=INT_MAX;\\n\\n        if(ind>0)\\n            left=matrix[row][ind] + solve(matrix, n, row+1, ind-1, dp);\\n    \\n        down=matrix[row][ind] + solve(matrix, n, row+1, ind, dp);\\n\\n        if(ind<n)\\n            right=matrix[row][ind] + solve(matrix, n, row+1, ind+1, dp);\\n\\n        return dp[row][ind]=min({left, down, right});\\n    }\\n};\\n\\nPlease help me in getting out of this..."
                    },
                    {
                        "username": "ansh_1012",
                        "content": "try initializing dp with INT_MAX if it gives tle in memo solution  "
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "how could it be medium problem ??"
                    },
                    {
                        "username": "LogenleeDEV",
                        "content": "Simple Python Solution\\n\\n```python \\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        dp = [[0 for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\\n\\n        m = len(matrix)\\n        n = len(matrix[0])\\n\\n        for i in range(len(matrix[0])):\\n            dp[0][i] = matrix[0][i]\\n\\n        \\n        for i in range(1, len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if j - 1 >= 0 and j + 1 < n:\\n                    # didn\\'t cross the boundary \\n                    dp[i][j] = min(dp[i - 1][j - 1] + matrix[i][j], dp[i - 1][j] + matrix[i][j], dp[i - 1][j + 1] + matrix[i][j])\\n                elif j - 1 < 0:\\n                    dp[i][j] = min(dp[i - 1][j] + matrix[i][j], dp[i - 1][j + 1] + matrix[i][j])\\n                elif j + 1 >= n:\\n                    dp[i][j] = min(dp[i - 1][j - 1] + matrix[i][j], dp[i - 1][j] + matrix[i][j])\\n\\n        return min(dp[-1])\\n```"
                    },
                    {
                        "username": "ameynaik09",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\nWhy I am getting this error????"
                    }
                ]
            },
            {
                "id": 1980359,
                "content": [
                    {
                        "username": "Sandeep_Rai",
                        "content": "Can anyone explain why the memoization solution is working fine if we initialize the dp array with INT_MAX but give TLE if I am initializing it with -1?"
                    },
                    {
                        "username": "anushka4823",
                        "content": "in normal cases we intialize it with -1 but here since negative numbers can also included for the min sum so our answer will get manipulated if its -1."
                    },
                    {
                        "username": "anushka4823",
                        "content": "Initialise your dp with INT_MIN you\\'ll not get TLE then -1 is producing wrong answer. Also, dont forget to cange it here as well,  if(dp[i][j]!=INT_MIN)"
                    },
                    {
                        "username": "Ronitkumar151002",
                        "content": "can anyone explain why does my solution gets accepted if I initialize my 2-d DP vector with INT_MAX and gets tle on test case-49 when done similiar thing just initialization with -1??\\nAn explaination would be helpful :)"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "since the values in the matrix can be both positive and negative, initializing the DP array with -1 might lead to incorrect results since it\\'s a valid value for the sum. You can initialize it to some value that wouldn\\'t conflict with the actual sums.\\n\\nI had initialise dp to 1e9."
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": " why if i set my dp matrix   `INT_MAX` works fine \\n`vector<vector<int>> dp(n, vector<int>(m, INT_MAX));`\\nbut getting `tle` for \\n`vector<vector<int>> dp(n, vector<int>(m, -1));` ?"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "CAN SOMEONE TELL ME WHT THIS CODE GIVE TLE EVEN WITH DP\\n\\nclass Solution {\\npublic:\\n\\n    int f(int i,int j,int& n,int& m,vector<vector<int>>& a,vector<vector<int>>&dp)\\n    {\\n        if(j<0 || j>m-1)\\n            return 1e9;\\n        \\n        if(i==0)\\n            return a[i][j];\\n        \\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        int up = a[i][j] + f(i-1,j,n,m,a,dp);\\n        \\n        int ld = a[i][j] + f(i-1,j-1,n,m,a,dp);\\n        \\n        int rd = a[i][j] + f(i-1,j+1,n,m,a,dp);\\n        \\n        \\n        return dp[i][j]=min(up,min(ld,rd));\\n        \\n    }\\n    \\n      \\n     int minFallingPathSum(vector<vector<int>>& matrix) {\\n     \\n        int ans=INT_MAX;\\n        \\n        int n=matrix.size();\\n        \\n        int m=matrix[0].size();\\n        \\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            ans=min(ans,f(n-1,j,n,m,matrix,dp));\\n        }\\n        for(int i=0;i<dp.size();i++){\\n            for(int j=0;j<dp[0].size();j++){\\n                cout<<dp[i][j]<<\" \";\\n            }\\n\\n            cout<<endl;\\n        }\\n        \\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "Imransakibansari",
                        "content": "Why this code shows TLE for the last test case\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) \\n    {\\n        int n=matrix.size();\\n        int ans=INT_MAX;\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            int sum=solve(matrix, n-1, 0, i, dp);\\n            ans=min(ans, sum);\\n        }\\n        \\n        return ans;\\n    }\\n\\n    int solve(vector<vector<int>>& matrix, int n, int row, int ind, vector<vector<int>>& dp)\\n    {\\n        if(row==n)\\n            return matrix[row][ind];\\n\\n        if(dp[row][ind]!=-1)\\n            return dp[row][ind];\\n\\n        int left, right, down;\\n        left=right=down=INT_MAX;\\n\\n        if(ind>0)\\n            left=matrix[row][ind] + solve(matrix, n, row+1, ind-1, dp);\\n    \\n        down=matrix[row][ind] + solve(matrix, n, row+1, ind, dp);\\n\\n        if(ind<n)\\n            right=matrix[row][ind] + solve(matrix, n, row+1, ind+1, dp);\\n\\n        return dp[row][ind]=min({left, down, right});\\n    }\\n};\\n\\nPlease help me in getting out of this..."
                    },
                    {
                        "username": "ansh_1012",
                        "content": "try initializing dp with INT_MAX if it gives tle in memo solution  "
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "how could it be medium problem ??"
                    },
                    {
                        "username": "LogenleeDEV",
                        "content": "Simple Python Solution\\n\\n```python \\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        dp = [[0 for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\\n\\n        m = len(matrix)\\n        n = len(matrix[0])\\n\\n        for i in range(len(matrix[0])):\\n            dp[0][i] = matrix[0][i]\\n\\n        \\n        for i in range(1, len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if j - 1 >= 0 and j + 1 < n:\\n                    # didn\\'t cross the boundary \\n                    dp[i][j] = min(dp[i - 1][j - 1] + matrix[i][j], dp[i - 1][j] + matrix[i][j], dp[i - 1][j + 1] + matrix[i][j])\\n                elif j - 1 < 0:\\n                    dp[i][j] = min(dp[i - 1][j] + matrix[i][j], dp[i - 1][j + 1] + matrix[i][j])\\n                elif j + 1 >= n:\\n                    dp[i][j] = min(dp[i - 1][j - 1] + matrix[i][j], dp[i - 1][j] + matrix[i][j])\\n\\n        return min(dp[-1])\\n```"
                    },
                    {
                        "username": "ameynaik09",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\nWhy I am getting this error????"
                    }
                ]
            },
            {
                "id": 1978211,
                "content": [
                    {
                        "username": "Sandeep_Rai",
                        "content": "Can anyone explain why the memoization solution is working fine if we initialize the dp array with INT_MAX but give TLE if I am initializing it with -1?"
                    },
                    {
                        "username": "anushka4823",
                        "content": "in normal cases we intialize it with -1 but here since negative numbers can also included for the min sum so our answer will get manipulated if its -1."
                    },
                    {
                        "username": "anushka4823",
                        "content": "Initialise your dp with INT_MIN you\\'ll not get TLE then -1 is producing wrong answer. Also, dont forget to cange it here as well,  if(dp[i][j]!=INT_MIN)"
                    },
                    {
                        "username": "Ronitkumar151002",
                        "content": "can anyone explain why does my solution gets accepted if I initialize my 2-d DP vector with INT_MAX and gets tle on test case-49 when done similiar thing just initialization with -1??\\nAn explaination would be helpful :)"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "since the values in the matrix can be both positive and negative, initializing the DP array with -1 might lead to incorrect results since it\\'s a valid value for the sum. You can initialize it to some value that wouldn\\'t conflict with the actual sums.\\n\\nI had initialise dp to 1e9."
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": " why if i set my dp matrix   `INT_MAX` works fine \\n`vector<vector<int>> dp(n, vector<int>(m, INT_MAX));`\\nbut getting `tle` for \\n`vector<vector<int>> dp(n, vector<int>(m, -1));` ?"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "CAN SOMEONE TELL ME WHT THIS CODE GIVE TLE EVEN WITH DP\\n\\nclass Solution {\\npublic:\\n\\n    int f(int i,int j,int& n,int& m,vector<vector<int>>& a,vector<vector<int>>&dp)\\n    {\\n        if(j<0 || j>m-1)\\n            return 1e9;\\n        \\n        if(i==0)\\n            return a[i][j];\\n        \\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        int up = a[i][j] + f(i-1,j,n,m,a,dp);\\n        \\n        int ld = a[i][j] + f(i-1,j-1,n,m,a,dp);\\n        \\n        int rd = a[i][j] + f(i-1,j+1,n,m,a,dp);\\n        \\n        \\n        return dp[i][j]=min(up,min(ld,rd));\\n        \\n    }\\n    \\n      \\n     int minFallingPathSum(vector<vector<int>>& matrix) {\\n     \\n        int ans=INT_MAX;\\n        \\n        int n=matrix.size();\\n        \\n        int m=matrix[0].size();\\n        \\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            ans=min(ans,f(n-1,j,n,m,matrix,dp));\\n        }\\n        for(int i=0;i<dp.size();i++){\\n            for(int j=0;j<dp[0].size();j++){\\n                cout<<dp[i][j]<<\" \";\\n            }\\n\\n            cout<<endl;\\n        }\\n        \\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "Imransakibansari",
                        "content": "Why this code shows TLE for the last test case\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) \\n    {\\n        int n=matrix.size();\\n        int ans=INT_MAX;\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            int sum=solve(matrix, n-1, 0, i, dp);\\n            ans=min(ans, sum);\\n        }\\n        \\n        return ans;\\n    }\\n\\n    int solve(vector<vector<int>>& matrix, int n, int row, int ind, vector<vector<int>>& dp)\\n    {\\n        if(row==n)\\n            return matrix[row][ind];\\n\\n        if(dp[row][ind]!=-1)\\n            return dp[row][ind];\\n\\n        int left, right, down;\\n        left=right=down=INT_MAX;\\n\\n        if(ind>0)\\n            left=matrix[row][ind] + solve(matrix, n, row+1, ind-1, dp);\\n    \\n        down=matrix[row][ind] + solve(matrix, n, row+1, ind, dp);\\n\\n        if(ind<n)\\n            right=matrix[row][ind] + solve(matrix, n, row+1, ind+1, dp);\\n\\n        return dp[row][ind]=min({left, down, right});\\n    }\\n};\\n\\nPlease help me in getting out of this..."
                    },
                    {
                        "username": "ansh_1012",
                        "content": "try initializing dp with INT_MAX if it gives tle in memo solution  "
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "how could it be medium problem ??"
                    },
                    {
                        "username": "LogenleeDEV",
                        "content": "Simple Python Solution\\n\\n```python \\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        dp = [[0 for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\\n\\n        m = len(matrix)\\n        n = len(matrix[0])\\n\\n        for i in range(len(matrix[0])):\\n            dp[0][i] = matrix[0][i]\\n\\n        \\n        for i in range(1, len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if j - 1 >= 0 and j + 1 < n:\\n                    # didn\\'t cross the boundary \\n                    dp[i][j] = min(dp[i - 1][j - 1] + matrix[i][j], dp[i - 1][j] + matrix[i][j], dp[i - 1][j + 1] + matrix[i][j])\\n                elif j - 1 < 0:\\n                    dp[i][j] = min(dp[i - 1][j] + matrix[i][j], dp[i - 1][j + 1] + matrix[i][j])\\n                elif j + 1 >= n:\\n                    dp[i][j] = min(dp[i - 1][j - 1] + matrix[i][j], dp[i - 1][j] + matrix[i][j])\\n\\n        return min(dp[-1])\\n```"
                    },
                    {
                        "username": "ameynaik09",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\nWhy I am getting this error????"
                    }
                ]
            },
            {
                "id": 1964262,
                "content": [
                    {
                        "username": "Sandeep_Rai",
                        "content": "Can anyone explain why the memoization solution is working fine if we initialize the dp array with INT_MAX but give TLE if I am initializing it with -1?"
                    },
                    {
                        "username": "anushka4823",
                        "content": "in normal cases we intialize it with -1 but here since negative numbers can also included for the min sum so our answer will get manipulated if its -1."
                    },
                    {
                        "username": "anushka4823",
                        "content": "Initialise your dp with INT_MIN you\\'ll not get TLE then -1 is producing wrong answer. Also, dont forget to cange it here as well,  if(dp[i][j]!=INT_MIN)"
                    },
                    {
                        "username": "Ronitkumar151002",
                        "content": "can anyone explain why does my solution gets accepted if I initialize my 2-d DP vector with INT_MAX and gets tle on test case-49 when done similiar thing just initialization with -1??\\nAn explaination would be helpful :)"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "since the values in the matrix can be both positive and negative, initializing the DP array with -1 might lead to incorrect results since it\\'s a valid value for the sum. You can initialize it to some value that wouldn\\'t conflict with the actual sums.\\n\\nI had initialise dp to 1e9."
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": " why if i set my dp matrix   `INT_MAX` works fine \\n`vector<vector<int>> dp(n, vector<int>(m, INT_MAX));`\\nbut getting `tle` for \\n`vector<vector<int>> dp(n, vector<int>(m, -1));` ?"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "CAN SOMEONE TELL ME WHT THIS CODE GIVE TLE EVEN WITH DP\\n\\nclass Solution {\\npublic:\\n\\n    int f(int i,int j,int& n,int& m,vector<vector<int>>& a,vector<vector<int>>&dp)\\n    {\\n        if(j<0 || j>m-1)\\n            return 1e9;\\n        \\n        if(i==0)\\n            return a[i][j];\\n        \\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        int up = a[i][j] + f(i-1,j,n,m,a,dp);\\n        \\n        int ld = a[i][j] + f(i-1,j-1,n,m,a,dp);\\n        \\n        int rd = a[i][j] + f(i-1,j+1,n,m,a,dp);\\n        \\n        \\n        return dp[i][j]=min(up,min(ld,rd));\\n        \\n    }\\n    \\n      \\n     int minFallingPathSum(vector<vector<int>>& matrix) {\\n     \\n        int ans=INT_MAX;\\n        \\n        int n=matrix.size();\\n        \\n        int m=matrix[0].size();\\n        \\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            ans=min(ans,f(n-1,j,n,m,matrix,dp));\\n        }\\n        for(int i=0;i<dp.size();i++){\\n            for(int j=0;j<dp[0].size();j++){\\n                cout<<dp[i][j]<<\" \";\\n            }\\n\\n            cout<<endl;\\n        }\\n        \\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "Imransakibansari",
                        "content": "Why this code shows TLE for the last test case\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) \\n    {\\n        int n=matrix.size();\\n        int ans=INT_MAX;\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            int sum=solve(matrix, n-1, 0, i, dp);\\n            ans=min(ans, sum);\\n        }\\n        \\n        return ans;\\n    }\\n\\n    int solve(vector<vector<int>>& matrix, int n, int row, int ind, vector<vector<int>>& dp)\\n    {\\n        if(row==n)\\n            return matrix[row][ind];\\n\\n        if(dp[row][ind]!=-1)\\n            return dp[row][ind];\\n\\n        int left, right, down;\\n        left=right=down=INT_MAX;\\n\\n        if(ind>0)\\n            left=matrix[row][ind] + solve(matrix, n, row+1, ind-1, dp);\\n    \\n        down=matrix[row][ind] + solve(matrix, n, row+1, ind, dp);\\n\\n        if(ind<n)\\n            right=matrix[row][ind] + solve(matrix, n, row+1, ind+1, dp);\\n\\n        return dp[row][ind]=min({left, down, right});\\n    }\\n};\\n\\nPlease help me in getting out of this..."
                    },
                    {
                        "username": "ansh_1012",
                        "content": "try initializing dp with INT_MAX if it gives tle in memo solution  "
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "how could it be medium problem ??"
                    },
                    {
                        "username": "LogenleeDEV",
                        "content": "Simple Python Solution\\n\\n```python \\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        dp = [[0 for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\\n\\n        m = len(matrix)\\n        n = len(matrix[0])\\n\\n        for i in range(len(matrix[0])):\\n            dp[0][i] = matrix[0][i]\\n\\n        \\n        for i in range(1, len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if j - 1 >= 0 and j + 1 < n:\\n                    # didn\\'t cross the boundary \\n                    dp[i][j] = min(dp[i - 1][j - 1] + matrix[i][j], dp[i - 1][j] + matrix[i][j], dp[i - 1][j + 1] + matrix[i][j])\\n                elif j - 1 < 0:\\n                    dp[i][j] = min(dp[i - 1][j] + matrix[i][j], dp[i - 1][j + 1] + matrix[i][j])\\n                elif j + 1 >= n:\\n                    dp[i][j] = min(dp[i - 1][j - 1] + matrix[i][j], dp[i - 1][j] + matrix[i][j])\\n\\n        return min(dp[-1])\\n```"
                    },
                    {
                        "username": "ameynaik09",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\nWhy I am getting this error????"
                    }
                ]
            },
            {
                "id": 1961021,
                "content": [
                    {
                        "username": "Sandeep_Rai",
                        "content": "Can anyone explain why the memoization solution is working fine if we initialize the dp array with INT_MAX but give TLE if I am initializing it with -1?"
                    },
                    {
                        "username": "anushka4823",
                        "content": "in normal cases we intialize it with -1 but here since negative numbers can also included for the min sum so our answer will get manipulated if its -1."
                    },
                    {
                        "username": "anushka4823",
                        "content": "Initialise your dp with INT_MIN you\\'ll not get TLE then -1 is producing wrong answer. Also, dont forget to cange it here as well,  if(dp[i][j]!=INT_MIN)"
                    },
                    {
                        "username": "Ronitkumar151002",
                        "content": "can anyone explain why does my solution gets accepted if I initialize my 2-d DP vector with INT_MAX and gets tle on test case-49 when done similiar thing just initialization with -1??\\nAn explaination would be helpful :)"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "since the values in the matrix can be both positive and negative, initializing the DP array with -1 might lead to incorrect results since it\\'s a valid value for the sum. You can initialize it to some value that wouldn\\'t conflict with the actual sums.\\n\\nI had initialise dp to 1e9."
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": " why if i set my dp matrix   `INT_MAX` works fine \\n`vector<vector<int>> dp(n, vector<int>(m, INT_MAX));`\\nbut getting `tle` for \\n`vector<vector<int>> dp(n, vector<int>(m, -1));` ?"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "CAN SOMEONE TELL ME WHT THIS CODE GIVE TLE EVEN WITH DP\\n\\nclass Solution {\\npublic:\\n\\n    int f(int i,int j,int& n,int& m,vector<vector<int>>& a,vector<vector<int>>&dp)\\n    {\\n        if(j<0 || j>m-1)\\n            return 1e9;\\n        \\n        if(i==0)\\n            return a[i][j];\\n        \\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        int up = a[i][j] + f(i-1,j,n,m,a,dp);\\n        \\n        int ld = a[i][j] + f(i-1,j-1,n,m,a,dp);\\n        \\n        int rd = a[i][j] + f(i-1,j+1,n,m,a,dp);\\n        \\n        \\n        return dp[i][j]=min(up,min(ld,rd));\\n        \\n    }\\n    \\n      \\n     int minFallingPathSum(vector<vector<int>>& matrix) {\\n     \\n        int ans=INT_MAX;\\n        \\n        int n=matrix.size();\\n        \\n        int m=matrix[0].size();\\n        \\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            ans=min(ans,f(n-1,j,n,m,matrix,dp));\\n        }\\n        for(int i=0;i<dp.size();i++){\\n            for(int j=0;j<dp[0].size();j++){\\n                cout<<dp[i][j]<<\" \";\\n            }\\n\\n            cout<<endl;\\n        }\\n        \\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "Imransakibansari",
                        "content": "Why this code shows TLE for the last test case\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) \\n    {\\n        int n=matrix.size();\\n        int ans=INT_MAX;\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            int sum=solve(matrix, n-1, 0, i, dp);\\n            ans=min(ans, sum);\\n        }\\n        \\n        return ans;\\n    }\\n\\n    int solve(vector<vector<int>>& matrix, int n, int row, int ind, vector<vector<int>>& dp)\\n    {\\n        if(row==n)\\n            return matrix[row][ind];\\n\\n        if(dp[row][ind]!=-1)\\n            return dp[row][ind];\\n\\n        int left, right, down;\\n        left=right=down=INT_MAX;\\n\\n        if(ind>0)\\n            left=matrix[row][ind] + solve(matrix, n, row+1, ind-1, dp);\\n    \\n        down=matrix[row][ind] + solve(matrix, n, row+1, ind, dp);\\n\\n        if(ind<n)\\n            right=matrix[row][ind] + solve(matrix, n, row+1, ind+1, dp);\\n\\n        return dp[row][ind]=min({left, down, right});\\n    }\\n};\\n\\nPlease help me in getting out of this..."
                    },
                    {
                        "username": "ansh_1012",
                        "content": "try initializing dp with INT_MAX if it gives tle in memo solution  "
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "how could it be medium problem ??"
                    },
                    {
                        "username": "LogenleeDEV",
                        "content": "Simple Python Solution\\n\\n```python \\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        dp = [[0 for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\\n\\n        m = len(matrix)\\n        n = len(matrix[0])\\n\\n        for i in range(len(matrix[0])):\\n            dp[0][i] = matrix[0][i]\\n\\n        \\n        for i in range(1, len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if j - 1 >= 0 and j + 1 < n:\\n                    # didn\\'t cross the boundary \\n                    dp[i][j] = min(dp[i - 1][j - 1] + matrix[i][j], dp[i - 1][j] + matrix[i][j], dp[i - 1][j + 1] + matrix[i][j])\\n                elif j - 1 < 0:\\n                    dp[i][j] = min(dp[i - 1][j] + matrix[i][j], dp[i - 1][j + 1] + matrix[i][j])\\n                elif j + 1 >= n:\\n                    dp[i][j] = min(dp[i - 1][j - 1] + matrix[i][j], dp[i - 1][j] + matrix[i][j])\\n\\n        return min(dp[-1])\\n```"
                    },
                    {
                        "username": "ameynaik09",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\nWhy I am getting this error????"
                    }
                ]
            },
            {
                "id": 1892898,
                "content": [
                    {
                        "username": "Sandeep_Rai",
                        "content": "Can anyone explain why the memoization solution is working fine if we initialize the dp array with INT_MAX but give TLE if I am initializing it with -1?"
                    },
                    {
                        "username": "anushka4823",
                        "content": "in normal cases we intialize it with -1 but here since negative numbers can also included for the min sum so our answer will get manipulated if its -1."
                    },
                    {
                        "username": "anushka4823",
                        "content": "Initialise your dp with INT_MIN you\\'ll not get TLE then -1 is producing wrong answer. Also, dont forget to cange it here as well,  if(dp[i][j]!=INT_MIN)"
                    },
                    {
                        "username": "Ronitkumar151002",
                        "content": "can anyone explain why does my solution gets accepted if I initialize my 2-d DP vector with INT_MAX and gets tle on test case-49 when done similiar thing just initialization with -1??\\nAn explaination would be helpful :)"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "since the values in the matrix can be both positive and negative, initializing the DP array with -1 might lead to incorrect results since it\\'s a valid value for the sum. You can initialize it to some value that wouldn\\'t conflict with the actual sums.\\n\\nI had initialise dp to 1e9."
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": " why if i set my dp matrix   `INT_MAX` works fine \\n`vector<vector<int>> dp(n, vector<int>(m, INT_MAX));`\\nbut getting `tle` for \\n`vector<vector<int>> dp(n, vector<int>(m, -1));` ?"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "CAN SOMEONE TELL ME WHT THIS CODE GIVE TLE EVEN WITH DP\\n\\nclass Solution {\\npublic:\\n\\n    int f(int i,int j,int& n,int& m,vector<vector<int>>& a,vector<vector<int>>&dp)\\n    {\\n        if(j<0 || j>m-1)\\n            return 1e9;\\n        \\n        if(i==0)\\n            return a[i][j];\\n        \\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        int up = a[i][j] + f(i-1,j,n,m,a,dp);\\n        \\n        int ld = a[i][j] + f(i-1,j-1,n,m,a,dp);\\n        \\n        int rd = a[i][j] + f(i-1,j+1,n,m,a,dp);\\n        \\n        \\n        return dp[i][j]=min(up,min(ld,rd));\\n        \\n    }\\n    \\n      \\n     int minFallingPathSum(vector<vector<int>>& matrix) {\\n     \\n        int ans=INT_MAX;\\n        \\n        int n=matrix.size();\\n        \\n        int m=matrix[0].size();\\n        \\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            ans=min(ans,f(n-1,j,n,m,matrix,dp));\\n        }\\n        for(int i=0;i<dp.size();i++){\\n            for(int j=0;j<dp[0].size();j++){\\n                cout<<dp[i][j]<<\" \";\\n            }\\n\\n            cout<<endl;\\n        }\\n        \\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "Imransakibansari",
                        "content": "Why this code shows TLE for the last test case\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) \\n    {\\n        int n=matrix.size();\\n        int ans=INT_MAX;\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            int sum=solve(matrix, n-1, 0, i, dp);\\n            ans=min(ans, sum);\\n        }\\n        \\n        return ans;\\n    }\\n\\n    int solve(vector<vector<int>>& matrix, int n, int row, int ind, vector<vector<int>>& dp)\\n    {\\n        if(row==n)\\n            return matrix[row][ind];\\n\\n        if(dp[row][ind]!=-1)\\n            return dp[row][ind];\\n\\n        int left, right, down;\\n        left=right=down=INT_MAX;\\n\\n        if(ind>0)\\n            left=matrix[row][ind] + solve(matrix, n, row+1, ind-1, dp);\\n    \\n        down=matrix[row][ind] + solve(matrix, n, row+1, ind, dp);\\n\\n        if(ind<n)\\n            right=matrix[row][ind] + solve(matrix, n, row+1, ind+1, dp);\\n\\n        return dp[row][ind]=min({left, down, right});\\n    }\\n};\\n\\nPlease help me in getting out of this..."
                    },
                    {
                        "username": "ansh_1012",
                        "content": "try initializing dp with INT_MAX if it gives tle in memo solution  "
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "how could it be medium problem ??"
                    },
                    {
                        "username": "LogenleeDEV",
                        "content": "Simple Python Solution\\n\\n```python \\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        dp = [[0 for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\\n\\n        m = len(matrix)\\n        n = len(matrix[0])\\n\\n        for i in range(len(matrix[0])):\\n            dp[0][i] = matrix[0][i]\\n\\n        \\n        for i in range(1, len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if j - 1 >= 0 and j + 1 < n:\\n                    # didn\\'t cross the boundary \\n                    dp[i][j] = min(dp[i - 1][j - 1] + matrix[i][j], dp[i - 1][j] + matrix[i][j], dp[i - 1][j + 1] + matrix[i][j])\\n                elif j - 1 < 0:\\n                    dp[i][j] = min(dp[i - 1][j] + matrix[i][j], dp[i - 1][j + 1] + matrix[i][j])\\n                elif j + 1 >= n:\\n                    dp[i][j] = min(dp[i - 1][j - 1] + matrix[i][j], dp[i - 1][j] + matrix[i][j])\\n\\n        return min(dp[-1])\\n```"
                    },
                    {
                        "username": "ameynaik09",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\nWhy I am getting this error????"
                    }
                ]
            },
            {
                "id": 1837410,
                "content": [
                    {
                        "username": "Sandeep_Rai",
                        "content": "Can anyone explain why the memoization solution is working fine if we initialize the dp array with INT_MAX but give TLE if I am initializing it with -1?"
                    },
                    {
                        "username": "anushka4823",
                        "content": "in normal cases we intialize it with -1 but here since negative numbers can also included for the min sum so our answer will get manipulated if its -1."
                    },
                    {
                        "username": "anushka4823",
                        "content": "Initialise your dp with INT_MIN you\\'ll not get TLE then -1 is producing wrong answer. Also, dont forget to cange it here as well,  if(dp[i][j]!=INT_MIN)"
                    },
                    {
                        "username": "Ronitkumar151002",
                        "content": "can anyone explain why does my solution gets accepted if I initialize my 2-d DP vector with INT_MAX and gets tle on test case-49 when done similiar thing just initialization with -1??\\nAn explaination would be helpful :)"
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "since the values in the matrix can be both positive and negative, initializing the DP array with -1 might lead to incorrect results since it\\'s a valid value for the sum. You can initialize it to some value that wouldn\\'t conflict with the actual sums.\\n\\nI had initialise dp to 1e9."
                    },
                    {
                        "username": "aman_0_1_2",
                        "content": " why if i set my dp matrix   `INT_MAX` works fine \\n`vector<vector<int>> dp(n, vector<int>(m, INT_MAX));`\\nbut getting `tle` for \\n`vector<vector<int>> dp(n, vector<int>(m, -1));` ?"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "CAN SOMEONE TELL ME WHT THIS CODE GIVE TLE EVEN WITH DP\\n\\nclass Solution {\\npublic:\\n\\n    int f(int i,int j,int& n,int& m,vector<vector<int>>& a,vector<vector<int>>&dp)\\n    {\\n        if(j<0 || j>m-1)\\n            return 1e9;\\n        \\n        if(i==0)\\n            return a[i][j];\\n        \\n        if(dp[i][j]!=-1)\\n            return dp[i][j];\\n        \\n        int up = a[i][j] + f(i-1,j,n,m,a,dp);\\n        \\n        int ld = a[i][j] + f(i-1,j-1,n,m,a,dp);\\n        \\n        int rd = a[i][j] + f(i-1,j+1,n,m,a,dp);\\n        \\n        \\n        return dp[i][j]=min(up,min(ld,rd));\\n        \\n    }\\n    \\n      \\n     int minFallingPathSum(vector<vector<int>>& matrix) {\\n     \\n        int ans=INT_MAX;\\n        \\n        int n=matrix.size();\\n        \\n        int m=matrix[0].size();\\n        \\n        vector<vector<int>>dp(n+1,vector<int>(m+1,-1));\\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            ans=min(ans,f(n-1,j,n,m,matrix,dp));\\n        }\\n        for(int i=0;i<dp.size();i++){\\n            for(int j=0;j<dp[0].size();j++){\\n                cout<<dp[i][j]<<\" \";\\n            }\\n\\n            cout<<endl;\\n        }\\n        \\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "Imransakibansari",
                        "content": "Why this code shows TLE for the last test case\\nclass Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) \\n    {\\n        int n=matrix.size();\\n        int ans=INT_MAX;\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            int sum=solve(matrix, n-1, 0, i, dp);\\n            ans=min(ans, sum);\\n        }\\n        \\n        return ans;\\n    }\\n\\n    int solve(vector<vector<int>>& matrix, int n, int row, int ind, vector<vector<int>>& dp)\\n    {\\n        if(row==n)\\n            return matrix[row][ind];\\n\\n        if(dp[row][ind]!=-1)\\n            return dp[row][ind];\\n\\n        int left, right, down;\\n        left=right=down=INT_MAX;\\n\\n        if(ind>0)\\n            left=matrix[row][ind] + solve(matrix, n, row+1, ind-1, dp);\\n    \\n        down=matrix[row][ind] + solve(matrix, n, row+1, ind, dp);\\n\\n        if(ind<n)\\n            right=matrix[row][ind] + solve(matrix, n, row+1, ind+1, dp);\\n\\n        return dp[row][ind]=min({left, down, right});\\n    }\\n};\\n\\nPlease help me in getting out of this..."
                    },
                    {
                        "username": "ansh_1012",
                        "content": "try initializing dp with INT_MAX if it gives tle in memo solution  "
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "how could it be medium problem ??"
                    },
                    {
                        "username": "LogenleeDEV",
                        "content": "Simple Python Solution\\n\\n```python \\nclass Solution:\\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        dp = [[0 for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\\n\\n        m = len(matrix)\\n        n = len(matrix[0])\\n\\n        for i in range(len(matrix[0])):\\n            dp[0][i] = matrix[0][i]\\n\\n        \\n        for i in range(1, len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if j - 1 >= 0 and j + 1 < n:\\n                    # didn\\'t cross the boundary \\n                    dp[i][j] = min(dp[i - 1][j - 1] + matrix[i][j], dp[i - 1][j] + matrix[i][j], dp[i - 1][j + 1] + matrix[i][j])\\n                elif j - 1 < 0:\\n                    dp[i][j] = min(dp[i - 1][j] + matrix[i][j], dp[i - 1][j + 1] + matrix[i][j])\\n                elif j + 1 >= n:\\n                    dp[i][j] = min(dp[i - 1][j - 1] + matrix[i][j], dp[i - 1][j] + matrix[i][j])\\n\\n        return min(dp[-1])\\n```"
                    },
                    {
                        "username": "ameynaik09",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34\\n\\nWhy I am getting this error????"
                    }
                ]
            },
            {
                "id": 1785614,
                "content": [
                    {
                        "username": "ankit_cruxx",
                        "content": "Can someone please help, what is the wrong here? I am getting a runtime error but i cannot see anything absurd. \\n\\n\\nint n = matrix.size();\\n         int m = matrix[0].size();\\n\\n        if (n==1) return *min_element(matrix[0].begin(),matrix[0].end());\\n        \\n      for(int i=1; i<n ; i++)\\n      {\\n      for(int j=0; j<m ; j++)\\n      {\\n          if(j==0)\\n          {\\n              matrix[i][j] = matrix[i][j] + min(matrix[i-1][j], matrix[i-1][j+1]);\\n          }\\n          if(j==m-1)\\n          {\\n              matrix[i][j] = matrix[i][j] + min(matrix[i-1][j],matrix[i-1][j-1]);\\n          }\\n          else\\n             matrix[i][j] = matrix[i][j] + min(matrix[i-1][j], min(matrix[i-1][j-1], matrix[i-1][j+1]));\\n      }\\n      }\\n      return *min_element(matrix[n-1].begin(),matrix[n-1].end());"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "You\\'re not using RUST. that is what is wrong"
                    },
                    {
                        "username": "mulani",
                        "content": "My code if failing for the following test case. Can someone please help me understand?\nmatrix =\n[[100,-42,-46,-41],[31,97,10,-10],[-58,-51,82,89],[51,81,69,-51]]\n\n ```\nclass Solution:\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\n        ROWS, COLS = len(matrix), len(matrix[0])\n        cache = {} # (r, c) : min_path_sum\n\n        def find_min_path(r, c):\n            if (r, c) in cache:\n                return cache[(r, c)]\n            min_path_sum = matrix[r][c]\n            if (r == ROWS - 1 and c == COLS - 1) or r == ROWS - 1:\n                min_path_sum += 0\n            elif c == COLS - 1:\n                min_path_sum += min(find_min_path(r + 1, c - 1), find_min_path(r + 1, c))\n            else:\n                min_path_sum += min(find_min_path(r + 1, c - 1), find_min_path(r + 1, c), find_min_path(r + 1, c + 1))\n            cache[(r, c)] = min_path_sum\n            return min_path_sum\n\n        min_path_sum = (100 * ROWS) + 1\n        for c in range(COLS):\n            min_path_sum = min(min_path_sum, find_min_path(0, c))\n        return min_path_sum\n```"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Monika Mulani](/mulani) You didn't consider the left bound right?\n\nwhen c==0:  min_path_sum += min(find_min_path(r + 1, c), find_min_path(r + 1, c + 1))\nfind_min_path(r + 1, c - 1) -> will look at the last column, then it returns a wrong answer! \n\nRelax, you are thinking too much. \nJust look at my $O(n^2)$ solution, go straight to problem. \n\n```\nclass Solution:\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\n        n = len(matrix) # a squared matrix        \n        for i in range(1,n):\n            matrix[i][0] += min(matrix[i-1][0:2])    # First element\n            matrix[i][n-1]+= min(matrix[i-1][n-2:n]) # Last element\n            for j in range(1,n-1):   \n                matrix[i][j]+=min(matrix[i-1][j-1:j+2])\n        return min(matrix[n-1])\n```"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": " can anyone explain why am i getting runtime error??\\n\\n\\nint minFallingPathSum(vector<vector<int>>& matrix) \\n    {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<vector<int>>ans(n,vector<int>(m,0));\\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            ans[0][j]=matrix[0][j];\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int s=matrix[i][j]+ans[i-1][j];\\n                int l=matrix[i][j];\\n                if(j>0)l+=ans[i-1][j-1];\\n                else l+=1e8;\\n                int r=matrix[i][j];\\n            \\n                if(j<n-1)r+=ans[i-1][j+1];\\n                else r+=1e8;\\n\\n                ans[i][j]=min(s,min(l,r));\\n            }\\n\\n        }\\n\\n    int mini=1e8;\\n    for(int j=0;j<m;j++)\\n    {\\n        mini=min(mini,ans[n-1][j]);\\n    }\\n\\n    return mini;\\n\\n\\n\\n        \\n    }"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "[@Deetav](/Deetav) got it thanks"
                    },
                    {
                        "username": "Deetav",
                        "content": "            int s=matrix[i][j]+ans[i-1][j];\\n\\nIn this line, when i = 0 your\\'e code will try to access ans[-1][j]."
                    },
                    {
                        "username": "nikhil08bhalla",
                        "content": "Why this code is giving overflow error\n```\nclass Solution {\npublic:\n    int f(int i,int j, vector<vector<int>>& v){\n        if(j<0 || j>=v[0].size()){\n            return INT_MAX;\n        }\n        if(i==0){\n            return v[0][j];\n        }\n        int s=v[i][j]+f(i-1,j,v);\n        int ld=v[i][j]+f(i-1,j-1,v);\n        int rd=v[i][j]+f(i-1,j+1,v);\n        return min(s,min(ld,rd));\n    }\n    int minFallingPathSum(vector<vector<int>>& v) {\n        int n=v.size();\n        int m=v[0].size();\n        if(n==0){\n            return 0;\n        }\n        else if(n==1){\n            return v[0][0];\n        }\n        int res=INT_MAX;\n        for(int j=0;j<m;j++){\n            res=min(res,f(n-1,j,v));\n        }\n        return res;\n    }\n};\n```"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "Can this question be done using O(1) space and without using recursion...\nLike the  [minimum-falling-path-sum-ii](https://leetcode.com/problems/minimum-falling-path-sum-ii/description/), as it can be done without using any extra space or recursion... \n"
                    },
                    {
                        "username": "Yongbi",
                        "content": "But I think it's slow when using the slicing. \nAnw, I didnt use extra space, but my results (memory) is not optimal."
                    },
                    {
                        "username": "HighViscosityFlow",
                        "content": "Yes. This problem doesn`t need a recursion and no extra space needed."
                    },
                    {
                        "username": "prajwalkraut10",
                        "content": "Why my solution isn\\'t working??? \\n\\nprivate:\\n    int findsum(vector<vector<int>>& matrix,vector<vector<int>> &dp,int i,int j){\\n        int n = matrix.size();\\n        if(j<0 || j>=n) return 1e9;\\n        if(i==0) return matrix[0][j];\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        int left = matrix[i][j] + findsum(matrix,dp,i-1,j-1);\\n        int mid = matrix[i][j] + findsum(matrix,dp,i-i,j);\\n        int rig = matrix[i][j] + findsum(matrix,dp,i-1,j+1);\\n\\n        return dp[i][j] = min(left,min(mid,rig));\\n    }\\n\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n       \\n        int n = matrix.size();\\n        vector<vector<int>> dp(n,vector<int> (n,-1));\\n        int sum = 1e9;\\n\\n        for(int i=0;i<n;i++){\\n           sum = min(sum,findsum(matrix,dp,n-1,i));\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "seregakuznetsov98",
                        "content": "In the brute force approach we have to create a paths(trees) for each top element of the array, this paths will cross each other, so how to avoid repetition in calculation for the same paths?"
                    },
                    {
                        "username": "dipeshbindlish",
                        "content": "Also known as Dynamic Programming Approach (using result from previous calculation than to calculate again).\\n"
                    },
                    {
                        "username": "dipeshbindlish",
                        "content": "Start from 2nd row & for each element check which element from above row is to be added in it (i.e. minimum of the three elements above it.)"
                    },
                    {
                        "username": "dipeshbindlish",
                        "content": "Use Dynamic Programming"
                    },
                    {
                        "username": "AkselJensen",
                        "content": "Oh dear, I accidentally posted a solution. I\\'m so sorry."
                    },
                    {
                        "username": "Finesse",
                        "content": "The matrix can be viewed as a directional graph, where the cells are weights of the edges leading to these cells. Any algorithm for finding the shortest path in a graph can be used.\n\nSome algorithms aren't designed for negative edge weights (e.g. Dijkstra's), it can be solved by subtracting the minimal weight from the matrix (to make all the values be not negative), and add `minWeight * n` to the result to de-adjust it."
                    }
                ]
            },
            {
                "id": 1752143,
                "content": [
                    {
                        "username": "ankit_cruxx",
                        "content": "Can someone please help, what is the wrong here? I am getting a runtime error but i cannot see anything absurd. \\n\\n\\nint n = matrix.size();\\n         int m = matrix[0].size();\\n\\n        if (n==1) return *min_element(matrix[0].begin(),matrix[0].end());\\n        \\n      for(int i=1; i<n ; i++)\\n      {\\n      for(int j=0; j<m ; j++)\\n      {\\n          if(j==0)\\n          {\\n              matrix[i][j] = matrix[i][j] + min(matrix[i-1][j], matrix[i-1][j+1]);\\n          }\\n          if(j==m-1)\\n          {\\n              matrix[i][j] = matrix[i][j] + min(matrix[i-1][j],matrix[i-1][j-1]);\\n          }\\n          else\\n             matrix[i][j] = matrix[i][j] + min(matrix[i-1][j], min(matrix[i-1][j-1], matrix[i-1][j+1]));\\n      }\\n      }\\n      return *min_element(matrix[n-1].begin(),matrix[n-1].end());"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "You\\'re not using RUST. that is what is wrong"
                    },
                    {
                        "username": "mulani",
                        "content": "My code if failing for the following test case. Can someone please help me understand?\nmatrix =\n[[100,-42,-46,-41],[31,97,10,-10],[-58,-51,82,89],[51,81,69,-51]]\n\n ```\nclass Solution:\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\n        ROWS, COLS = len(matrix), len(matrix[0])\n        cache = {} # (r, c) : min_path_sum\n\n        def find_min_path(r, c):\n            if (r, c) in cache:\n                return cache[(r, c)]\n            min_path_sum = matrix[r][c]\n            if (r == ROWS - 1 and c == COLS - 1) or r == ROWS - 1:\n                min_path_sum += 0\n            elif c == COLS - 1:\n                min_path_sum += min(find_min_path(r + 1, c - 1), find_min_path(r + 1, c))\n            else:\n                min_path_sum += min(find_min_path(r + 1, c - 1), find_min_path(r + 1, c), find_min_path(r + 1, c + 1))\n            cache[(r, c)] = min_path_sum\n            return min_path_sum\n\n        min_path_sum = (100 * ROWS) + 1\n        for c in range(COLS):\n            min_path_sum = min(min_path_sum, find_min_path(0, c))\n        return min_path_sum\n```"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Monika Mulani](/mulani) You didn't consider the left bound right?\n\nwhen c==0:  min_path_sum += min(find_min_path(r + 1, c), find_min_path(r + 1, c + 1))\nfind_min_path(r + 1, c - 1) -> will look at the last column, then it returns a wrong answer! \n\nRelax, you are thinking too much. \nJust look at my $O(n^2)$ solution, go straight to problem. \n\n```\nclass Solution:\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\n        n = len(matrix) # a squared matrix        \n        for i in range(1,n):\n            matrix[i][0] += min(matrix[i-1][0:2])    # First element\n            matrix[i][n-1]+= min(matrix[i-1][n-2:n]) # Last element\n            for j in range(1,n-1):   \n                matrix[i][j]+=min(matrix[i-1][j-1:j+2])\n        return min(matrix[n-1])\n```"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": " can anyone explain why am i getting runtime error??\\n\\n\\nint minFallingPathSum(vector<vector<int>>& matrix) \\n    {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<vector<int>>ans(n,vector<int>(m,0));\\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            ans[0][j]=matrix[0][j];\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int s=matrix[i][j]+ans[i-1][j];\\n                int l=matrix[i][j];\\n                if(j>0)l+=ans[i-1][j-1];\\n                else l+=1e8;\\n                int r=matrix[i][j];\\n            \\n                if(j<n-1)r+=ans[i-1][j+1];\\n                else r+=1e8;\\n\\n                ans[i][j]=min(s,min(l,r));\\n            }\\n\\n        }\\n\\n    int mini=1e8;\\n    for(int j=0;j<m;j++)\\n    {\\n        mini=min(mini,ans[n-1][j]);\\n    }\\n\\n    return mini;\\n\\n\\n\\n        \\n    }"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "[@Deetav](/Deetav) got it thanks"
                    },
                    {
                        "username": "Deetav",
                        "content": "            int s=matrix[i][j]+ans[i-1][j];\\n\\nIn this line, when i = 0 your\\'e code will try to access ans[-1][j]."
                    },
                    {
                        "username": "nikhil08bhalla",
                        "content": "Why this code is giving overflow error\n```\nclass Solution {\npublic:\n    int f(int i,int j, vector<vector<int>>& v){\n        if(j<0 || j>=v[0].size()){\n            return INT_MAX;\n        }\n        if(i==0){\n            return v[0][j];\n        }\n        int s=v[i][j]+f(i-1,j,v);\n        int ld=v[i][j]+f(i-1,j-1,v);\n        int rd=v[i][j]+f(i-1,j+1,v);\n        return min(s,min(ld,rd));\n    }\n    int minFallingPathSum(vector<vector<int>>& v) {\n        int n=v.size();\n        int m=v[0].size();\n        if(n==0){\n            return 0;\n        }\n        else if(n==1){\n            return v[0][0];\n        }\n        int res=INT_MAX;\n        for(int j=0;j<m;j++){\n            res=min(res,f(n-1,j,v));\n        }\n        return res;\n    }\n};\n```"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "Can this question be done using O(1) space and without using recursion...\nLike the  [minimum-falling-path-sum-ii](https://leetcode.com/problems/minimum-falling-path-sum-ii/description/), as it can be done without using any extra space or recursion... \n"
                    },
                    {
                        "username": "Yongbi",
                        "content": "But I think it's slow when using the slicing. \nAnw, I didnt use extra space, but my results (memory) is not optimal."
                    },
                    {
                        "username": "HighViscosityFlow",
                        "content": "Yes. This problem doesn`t need a recursion and no extra space needed."
                    },
                    {
                        "username": "prajwalkraut10",
                        "content": "Why my solution isn\\'t working??? \\n\\nprivate:\\n    int findsum(vector<vector<int>>& matrix,vector<vector<int>> &dp,int i,int j){\\n        int n = matrix.size();\\n        if(j<0 || j>=n) return 1e9;\\n        if(i==0) return matrix[0][j];\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        int left = matrix[i][j] + findsum(matrix,dp,i-1,j-1);\\n        int mid = matrix[i][j] + findsum(matrix,dp,i-i,j);\\n        int rig = matrix[i][j] + findsum(matrix,dp,i-1,j+1);\\n\\n        return dp[i][j] = min(left,min(mid,rig));\\n    }\\n\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n       \\n        int n = matrix.size();\\n        vector<vector<int>> dp(n,vector<int> (n,-1));\\n        int sum = 1e9;\\n\\n        for(int i=0;i<n;i++){\\n           sum = min(sum,findsum(matrix,dp,n-1,i));\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "seregakuznetsov98",
                        "content": "In the brute force approach we have to create a paths(trees) for each top element of the array, this paths will cross each other, so how to avoid repetition in calculation for the same paths?"
                    },
                    {
                        "username": "dipeshbindlish",
                        "content": "Also known as Dynamic Programming Approach (using result from previous calculation than to calculate again).\\n"
                    },
                    {
                        "username": "dipeshbindlish",
                        "content": "Start from 2nd row & for each element check which element from above row is to be added in it (i.e. minimum of the three elements above it.)"
                    },
                    {
                        "username": "dipeshbindlish",
                        "content": "Use Dynamic Programming"
                    },
                    {
                        "username": "AkselJensen",
                        "content": "Oh dear, I accidentally posted a solution. I\\'m so sorry."
                    },
                    {
                        "username": "Finesse",
                        "content": "The matrix can be viewed as a directional graph, where the cells are weights of the edges leading to these cells. Any algorithm for finding the shortest path in a graph can be used.\n\nSome algorithms aren't designed for negative edge weights (e.g. Dijkstra's), it can be solved by subtracting the minimal weight from the matrix (to make all the values be not negative), and add `minWeight * n` to the result to de-adjust it."
                    }
                ]
            },
            {
                "id": 1717025,
                "content": [
                    {
                        "username": "ankit_cruxx",
                        "content": "Can someone please help, what is the wrong here? I am getting a runtime error but i cannot see anything absurd. \\n\\n\\nint n = matrix.size();\\n         int m = matrix[0].size();\\n\\n        if (n==1) return *min_element(matrix[0].begin(),matrix[0].end());\\n        \\n      for(int i=1; i<n ; i++)\\n      {\\n      for(int j=0; j<m ; j++)\\n      {\\n          if(j==0)\\n          {\\n              matrix[i][j] = matrix[i][j] + min(matrix[i-1][j], matrix[i-1][j+1]);\\n          }\\n          if(j==m-1)\\n          {\\n              matrix[i][j] = matrix[i][j] + min(matrix[i-1][j],matrix[i-1][j-1]);\\n          }\\n          else\\n             matrix[i][j] = matrix[i][j] + min(matrix[i-1][j], min(matrix[i-1][j-1], matrix[i-1][j+1]));\\n      }\\n      }\\n      return *min_element(matrix[n-1].begin(),matrix[n-1].end());"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "You\\'re not using RUST. that is what is wrong"
                    },
                    {
                        "username": "mulani",
                        "content": "My code if failing for the following test case. Can someone please help me understand?\nmatrix =\n[[100,-42,-46,-41],[31,97,10,-10],[-58,-51,82,89],[51,81,69,-51]]\n\n ```\nclass Solution:\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\n        ROWS, COLS = len(matrix), len(matrix[0])\n        cache = {} # (r, c) : min_path_sum\n\n        def find_min_path(r, c):\n            if (r, c) in cache:\n                return cache[(r, c)]\n            min_path_sum = matrix[r][c]\n            if (r == ROWS - 1 and c == COLS - 1) or r == ROWS - 1:\n                min_path_sum += 0\n            elif c == COLS - 1:\n                min_path_sum += min(find_min_path(r + 1, c - 1), find_min_path(r + 1, c))\n            else:\n                min_path_sum += min(find_min_path(r + 1, c - 1), find_min_path(r + 1, c), find_min_path(r + 1, c + 1))\n            cache[(r, c)] = min_path_sum\n            return min_path_sum\n\n        min_path_sum = (100 * ROWS) + 1\n        for c in range(COLS):\n            min_path_sum = min(min_path_sum, find_min_path(0, c))\n        return min_path_sum\n```"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Monika Mulani](/mulani) You didn't consider the left bound right?\n\nwhen c==0:  min_path_sum += min(find_min_path(r + 1, c), find_min_path(r + 1, c + 1))\nfind_min_path(r + 1, c - 1) -> will look at the last column, then it returns a wrong answer! \n\nRelax, you are thinking too much. \nJust look at my $O(n^2)$ solution, go straight to problem. \n\n```\nclass Solution:\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\n        n = len(matrix) # a squared matrix        \n        for i in range(1,n):\n            matrix[i][0] += min(matrix[i-1][0:2])    # First element\n            matrix[i][n-1]+= min(matrix[i-1][n-2:n]) # Last element\n            for j in range(1,n-1):   \n                matrix[i][j]+=min(matrix[i-1][j-1:j+2])\n        return min(matrix[n-1])\n```"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": " can anyone explain why am i getting runtime error??\\n\\n\\nint minFallingPathSum(vector<vector<int>>& matrix) \\n    {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<vector<int>>ans(n,vector<int>(m,0));\\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            ans[0][j]=matrix[0][j];\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int s=matrix[i][j]+ans[i-1][j];\\n                int l=matrix[i][j];\\n                if(j>0)l+=ans[i-1][j-1];\\n                else l+=1e8;\\n                int r=matrix[i][j];\\n            \\n                if(j<n-1)r+=ans[i-1][j+1];\\n                else r+=1e8;\\n\\n                ans[i][j]=min(s,min(l,r));\\n            }\\n\\n        }\\n\\n    int mini=1e8;\\n    for(int j=0;j<m;j++)\\n    {\\n        mini=min(mini,ans[n-1][j]);\\n    }\\n\\n    return mini;\\n\\n\\n\\n        \\n    }"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "[@Deetav](/Deetav) got it thanks"
                    },
                    {
                        "username": "Deetav",
                        "content": "            int s=matrix[i][j]+ans[i-1][j];\\n\\nIn this line, when i = 0 your\\'e code will try to access ans[-1][j]."
                    },
                    {
                        "username": "nikhil08bhalla",
                        "content": "Why this code is giving overflow error\n```\nclass Solution {\npublic:\n    int f(int i,int j, vector<vector<int>>& v){\n        if(j<0 || j>=v[0].size()){\n            return INT_MAX;\n        }\n        if(i==0){\n            return v[0][j];\n        }\n        int s=v[i][j]+f(i-1,j,v);\n        int ld=v[i][j]+f(i-1,j-1,v);\n        int rd=v[i][j]+f(i-1,j+1,v);\n        return min(s,min(ld,rd));\n    }\n    int minFallingPathSum(vector<vector<int>>& v) {\n        int n=v.size();\n        int m=v[0].size();\n        if(n==0){\n            return 0;\n        }\n        else if(n==1){\n            return v[0][0];\n        }\n        int res=INT_MAX;\n        for(int j=0;j<m;j++){\n            res=min(res,f(n-1,j,v));\n        }\n        return res;\n    }\n};\n```"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "Can this question be done using O(1) space and without using recursion...\nLike the  [minimum-falling-path-sum-ii](https://leetcode.com/problems/minimum-falling-path-sum-ii/description/), as it can be done without using any extra space or recursion... \n"
                    },
                    {
                        "username": "Yongbi",
                        "content": "But I think it's slow when using the slicing. \nAnw, I didnt use extra space, but my results (memory) is not optimal."
                    },
                    {
                        "username": "HighViscosityFlow",
                        "content": "Yes. This problem doesn`t need a recursion and no extra space needed."
                    },
                    {
                        "username": "prajwalkraut10",
                        "content": "Why my solution isn\\'t working??? \\n\\nprivate:\\n    int findsum(vector<vector<int>>& matrix,vector<vector<int>> &dp,int i,int j){\\n        int n = matrix.size();\\n        if(j<0 || j>=n) return 1e9;\\n        if(i==0) return matrix[0][j];\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        int left = matrix[i][j] + findsum(matrix,dp,i-1,j-1);\\n        int mid = matrix[i][j] + findsum(matrix,dp,i-i,j);\\n        int rig = matrix[i][j] + findsum(matrix,dp,i-1,j+1);\\n\\n        return dp[i][j] = min(left,min(mid,rig));\\n    }\\n\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n       \\n        int n = matrix.size();\\n        vector<vector<int>> dp(n,vector<int> (n,-1));\\n        int sum = 1e9;\\n\\n        for(int i=0;i<n;i++){\\n           sum = min(sum,findsum(matrix,dp,n-1,i));\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "seregakuznetsov98",
                        "content": "In the brute force approach we have to create a paths(trees) for each top element of the array, this paths will cross each other, so how to avoid repetition in calculation for the same paths?"
                    },
                    {
                        "username": "dipeshbindlish",
                        "content": "Also known as Dynamic Programming Approach (using result from previous calculation than to calculate again).\\n"
                    },
                    {
                        "username": "dipeshbindlish",
                        "content": "Start from 2nd row & for each element check which element from above row is to be added in it (i.e. minimum of the three elements above it.)"
                    },
                    {
                        "username": "dipeshbindlish",
                        "content": "Use Dynamic Programming"
                    },
                    {
                        "username": "AkselJensen",
                        "content": "Oh dear, I accidentally posted a solution. I\\'m so sorry."
                    },
                    {
                        "username": "Finesse",
                        "content": "The matrix can be viewed as a directional graph, where the cells are weights of the edges leading to these cells. Any algorithm for finding the shortest path in a graph can be used.\n\nSome algorithms aren't designed for negative edge weights (e.g. Dijkstra's), it can be solved by subtracting the minimal weight from the matrix (to make all the values be not negative), and add `minWeight * n` to the result to de-adjust it."
                    }
                ]
            },
            {
                "id": 1715521,
                "content": [
                    {
                        "username": "ankit_cruxx",
                        "content": "Can someone please help, what is the wrong here? I am getting a runtime error but i cannot see anything absurd. \\n\\n\\nint n = matrix.size();\\n         int m = matrix[0].size();\\n\\n        if (n==1) return *min_element(matrix[0].begin(),matrix[0].end());\\n        \\n      for(int i=1; i<n ; i++)\\n      {\\n      for(int j=0; j<m ; j++)\\n      {\\n          if(j==0)\\n          {\\n              matrix[i][j] = matrix[i][j] + min(matrix[i-1][j], matrix[i-1][j+1]);\\n          }\\n          if(j==m-1)\\n          {\\n              matrix[i][j] = matrix[i][j] + min(matrix[i-1][j],matrix[i-1][j-1]);\\n          }\\n          else\\n             matrix[i][j] = matrix[i][j] + min(matrix[i-1][j], min(matrix[i-1][j-1], matrix[i-1][j+1]));\\n      }\\n      }\\n      return *min_element(matrix[n-1].begin(),matrix[n-1].end());"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "You\\'re not using RUST. that is what is wrong"
                    },
                    {
                        "username": "mulani",
                        "content": "My code if failing for the following test case. Can someone please help me understand?\nmatrix =\n[[100,-42,-46,-41],[31,97,10,-10],[-58,-51,82,89],[51,81,69,-51]]\n\n ```\nclass Solution:\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\n        ROWS, COLS = len(matrix), len(matrix[0])\n        cache = {} # (r, c) : min_path_sum\n\n        def find_min_path(r, c):\n            if (r, c) in cache:\n                return cache[(r, c)]\n            min_path_sum = matrix[r][c]\n            if (r == ROWS - 1 and c == COLS - 1) or r == ROWS - 1:\n                min_path_sum += 0\n            elif c == COLS - 1:\n                min_path_sum += min(find_min_path(r + 1, c - 1), find_min_path(r + 1, c))\n            else:\n                min_path_sum += min(find_min_path(r + 1, c - 1), find_min_path(r + 1, c), find_min_path(r + 1, c + 1))\n            cache[(r, c)] = min_path_sum\n            return min_path_sum\n\n        min_path_sum = (100 * ROWS) + 1\n        for c in range(COLS):\n            min_path_sum = min(min_path_sum, find_min_path(0, c))\n        return min_path_sum\n```"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Monika Mulani](/mulani) You didn't consider the left bound right?\n\nwhen c==0:  min_path_sum += min(find_min_path(r + 1, c), find_min_path(r + 1, c + 1))\nfind_min_path(r + 1, c - 1) -> will look at the last column, then it returns a wrong answer! \n\nRelax, you are thinking too much. \nJust look at my $O(n^2)$ solution, go straight to problem. \n\n```\nclass Solution:\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\n        n = len(matrix) # a squared matrix        \n        for i in range(1,n):\n            matrix[i][0] += min(matrix[i-1][0:2])    # First element\n            matrix[i][n-1]+= min(matrix[i-1][n-2:n]) # Last element\n            for j in range(1,n-1):   \n                matrix[i][j]+=min(matrix[i-1][j-1:j+2])\n        return min(matrix[n-1])\n```"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": " can anyone explain why am i getting runtime error??\\n\\n\\nint minFallingPathSum(vector<vector<int>>& matrix) \\n    {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<vector<int>>ans(n,vector<int>(m,0));\\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            ans[0][j]=matrix[0][j];\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int s=matrix[i][j]+ans[i-1][j];\\n                int l=matrix[i][j];\\n                if(j>0)l+=ans[i-1][j-1];\\n                else l+=1e8;\\n                int r=matrix[i][j];\\n            \\n                if(j<n-1)r+=ans[i-1][j+1];\\n                else r+=1e8;\\n\\n                ans[i][j]=min(s,min(l,r));\\n            }\\n\\n        }\\n\\n    int mini=1e8;\\n    for(int j=0;j<m;j++)\\n    {\\n        mini=min(mini,ans[n-1][j]);\\n    }\\n\\n    return mini;\\n\\n\\n\\n        \\n    }"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "[@Deetav](/Deetav) got it thanks"
                    },
                    {
                        "username": "Deetav",
                        "content": "            int s=matrix[i][j]+ans[i-1][j];\\n\\nIn this line, when i = 0 your\\'e code will try to access ans[-1][j]."
                    },
                    {
                        "username": "nikhil08bhalla",
                        "content": "Why this code is giving overflow error\n```\nclass Solution {\npublic:\n    int f(int i,int j, vector<vector<int>>& v){\n        if(j<0 || j>=v[0].size()){\n            return INT_MAX;\n        }\n        if(i==0){\n            return v[0][j];\n        }\n        int s=v[i][j]+f(i-1,j,v);\n        int ld=v[i][j]+f(i-1,j-1,v);\n        int rd=v[i][j]+f(i-1,j+1,v);\n        return min(s,min(ld,rd));\n    }\n    int minFallingPathSum(vector<vector<int>>& v) {\n        int n=v.size();\n        int m=v[0].size();\n        if(n==0){\n            return 0;\n        }\n        else if(n==1){\n            return v[0][0];\n        }\n        int res=INT_MAX;\n        for(int j=0;j<m;j++){\n            res=min(res,f(n-1,j,v));\n        }\n        return res;\n    }\n};\n```"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "Can this question be done using O(1) space and without using recursion...\nLike the  [minimum-falling-path-sum-ii](https://leetcode.com/problems/minimum-falling-path-sum-ii/description/), as it can be done without using any extra space or recursion... \n"
                    },
                    {
                        "username": "Yongbi",
                        "content": "But I think it's slow when using the slicing. \nAnw, I didnt use extra space, but my results (memory) is not optimal."
                    },
                    {
                        "username": "HighViscosityFlow",
                        "content": "Yes. This problem doesn`t need a recursion and no extra space needed."
                    },
                    {
                        "username": "prajwalkraut10",
                        "content": "Why my solution isn\\'t working??? \\n\\nprivate:\\n    int findsum(vector<vector<int>>& matrix,vector<vector<int>> &dp,int i,int j){\\n        int n = matrix.size();\\n        if(j<0 || j>=n) return 1e9;\\n        if(i==0) return matrix[0][j];\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        int left = matrix[i][j] + findsum(matrix,dp,i-1,j-1);\\n        int mid = matrix[i][j] + findsum(matrix,dp,i-i,j);\\n        int rig = matrix[i][j] + findsum(matrix,dp,i-1,j+1);\\n\\n        return dp[i][j] = min(left,min(mid,rig));\\n    }\\n\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n       \\n        int n = matrix.size();\\n        vector<vector<int>> dp(n,vector<int> (n,-1));\\n        int sum = 1e9;\\n\\n        for(int i=0;i<n;i++){\\n           sum = min(sum,findsum(matrix,dp,n-1,i));\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "seregakuznetsov98",
                        "content": "In the brute force approach we have to create a paths(trees) for each top element of the array, this paths will cross each other, so how to avoid repetition in calculation for the same paths?"
                    },
                    {
                        "username": "dipeshbindlish",
                        "content": "Also known as Dynamic Programming Approach (using result from previous calculation than to calculate again).\\n"
                    },
                    {
                        "username": "dipeshbindlish",
                        "content": "Start from 2nd row & for each element check which element from above row is to be added in it (i.e. minimum of the three elements above it.)"
                    },
                    {
                        "username": "dipeshbindlish",
                        "content": "Use Dynamic Programming"
                    },
                    {
                        "username": "AkselJensen",
                        "content": "Oh dear, I accidentally posted a solution. I\\'m so sorry."
                    },
                    {
                        "username": "Finesse",
                        "content": "The matrix can be viewed as a directional graph, where the cells are weights of the edges leading to these cells. Any algorithm for finding the shortest path in a graph can be used.\n\nSome algorithms aren't designed for negative edge weights (e.g. Dijkstra's), it can be solved by subtracting the minimal weight from the matrix (to make all the values be not negative), and add `minWeight * n` to the result to de-adjust it."
                    }
                ]
            },
            {
                "id": 1715420,
                "content": [
                    {
                        "username": "ankit_cruxx",
                        "content": "Can someone please help, what is the wrong here? I am getting a runtime error but i cannot see anything absurd. \\n\\n\\nint n = matrix.size();\\n         int m = matrix[0].size();\\n\\n        if (n==1) return *min_element(matrix[0].begin(),matrix[0].end());\\n        \\n      for(int i=1; i<n ; i++)\\n      {\\n      for(int j=0; j<m ; j++)\\n      {\\n          if(j==0)\\n          {\\n              matrix[i][j] = matrix[i][j] + min(matrix[i-1][j], matrix[i-1][j+1]);\\n          }\\n          if(j==m-1)\\n          {\\n              matrix[i][j] = matrix[i][j] + min(matrix[i-1][j],matrix[i-1][j-1]);\\n          }\\n          else\\n             matrix[i][j] = matrix[i][j] + min(matrix[i-1][j], min(matrix[i-1][j-1], matrix[i-1][j+1]));\\n      }\\n      }\\n      return *min_element(matrix[n-1].begin(),matrix[n-1].end());"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "You\\'re not using RUST. that is what is wrong"
                    },
                    {
                        "username": "mulani",
                        "content": "My code if failing for the following test case. Can someone please help me understand?\nmatrix =\n[[100,-42,-46,-41],[31,97,10,-10],[-58,-51,82,89],[51,81,69,-51]]\n\n ```\nclass Solution:\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\n        ROWS, COLS = len(matrix), len(matrix[0])\n        cache = {} # (r, c) : min_path_sum\n\n        def find_min_path(r, c):\n            if (r, c) in cache:\n                return cache[(r, c)]\n            min_path_sum = matrix[r][c]\n            if (r == ROWS - 1 and c == COLS - 1) or r == ROWS - 1:\n                min_path_sum += 0\n            elif c == COLS - 1:\n                min_path_sum += min(find_min_path(r + 1, c - 1), find_min_path(r + 1, c))\n            else:\n                min_path_sum += min(find_min_path(r + 1, c - 1), find_min_path(r + 1, c), find_min_path(r + 1, c + 1))\n            cache[(r, c)] = min_path_sum\n            return min_path_sum\n\n        min_path_sum = (100 * ROWS) + 1\n        for c in range(COLS):\n            min_path_sum = min(min_path_sum, find_min_path(0, c))\n        return min_path_sum\n```"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Monika Mulani](/mulani) You didn't consider the left bound right?\n\nwhen c==0:  min_path_sum += min(find_min_path(r + 1, c), find_min_path(r + 1, c + 1))\nfind_min_path(r + 1, c - 1) -> will look at the last column, then it returns a wrong answer! \n\nRelax, you are thinking too much. \nJust look at my $O(n^2)$ solution, go straight to problem. \n\n```\nclass Solution:\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\n        n = len(matrix) # a squared matrix        \n        for i in range(1,n):\n            matrix[i][0] += min(matrix[i-1][0:2])    # First element\n            matrix[i][n-1]+= min(matrix[i-1][n-2:n]) # Last element\n            for j in range(1,n-1):   \n                matrix[i][j]+=min(matrix[i-1][j-1:j+2])\n        return min(matrix[n-1])\n```"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": " can anyone explain why am i getting runtime error??\\n\\n\\nint minFallingPathSum(vector<vector<int>>& matrix) \\n    {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<vector<int>>ans(n,vector<int>(m,0));\\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            ans[0][j]=matrix[0][j];\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int s=matrix[i][j]+ans[i-1][j];\\n                int l=matrix[i][j];\\n                if(j>0)l+=ans[i-1][j-1];\\n                else l+=1e8;\\n                int r=matrix[i][j];\\n            \\n                if(j<n-1)r+=ans[i-1][j+1];\\n                else r+=1e8;\\n\\n                ans[i][j]=min(s,min(l,r));\\n            }\\n\\n        }\\n\\n    int mini=1e8;\\n    for(int j=0;j<m;j++)\\n    {\\n        mini=min(mini,ans[n-1][j]);\\n    }\\n\\n    return mini;\\n\\n\\n\\n        \\n    }"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "[@Deetav](/Deetav) got it thanks"
                    },
                    {
                        "username": "Deetav",
                        "content": "            int s=matrix[i][j]+ans[i-1][j];\\n\\nIn this line, when i = 0 your\\'e code will try to access ans[-1][j]."
                    },
                    {
                        "username": "nikhil08bhalla",
                        "content": "Why this code is giving overflow error\n```\nclass Solution {\npublic:\n    int f(int i,int j, vector<vector<int>>& v){\n        if(j<0 || j>=v[0].size()){\n            return INT_MAX;\n        }\n        if(i==0){\n            return v[0][j];\n        }\n        int s=v[i][j]+f(i-1,j,v);\n        int ld=v[i][j]+f(i-1,j-1,v);\n        int rd=v[i][j]+f(i-1,j+1,v);\n        return min(s,min(ld,rd));\n    }\n    int minFallingPathSum(vector<vector<int>>& v) {\n        int n=v.size();\n        int m=v[0].size();\n        if(n==0){\n            return 0;\n        }\n        else if(n==1){\n            return v[0][0];\n        }\n        int res=INT_MAX;\n        for(int j=0;j<m;j++){\n            res=min(res,f(n-1,j,v));\n        }\n        return res;\n    }\n};\n```"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "Can this question be done using O(1) space and without using recursion...\nLike the  [minimum-falling-path-sum-ii](https://leetcode.com/problems/minimum-falling-path-sum-ii/description/), as it can be done without using any extra space or recursion... \n"
                    },
                    {
                        "username": "Yongbi",
                        "content": "But I think it's slow when using the slicing. \nAnw, I didnt use extra space, but my results (memory) is not optimal."
                    },
                    {
                        "username": "HighViscosityFlow",
                        "content": "Yes. This problem doesn`t need a recursion and no extra space needed."
                    },
                    {
                        "username": "prajwalkraut10",
                        "content": "Why my solution isn\\'t working??? \\n\\nprivate:\\n    int findsum(vector<vector<int>>& matrix,vector<vector<int>> &dp,int i,int j){\\n        int n = matrix.size();\\n        if(j<0 || j>=n) return 1e9;\\n        if(i==0) return matrix[0][j];\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        int left = matrix[i][j] + findsum(matrix,dp,i-1,j-1);\\n        int mid = matrix[i][j] + findsum(matrix,dp,i-i,j);\\n        int rig = matrix[i][j] + findsum(matrix,dp,i-1,j+1);\\n\\n        return dp[i][j] = min(left,min(mid,rig));\\n    }\\n\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n       \\n        int n = matrix.size();\\n        vector<vector<int>> dp(n,vector<int> (n,-1));\\n        int sum = 1e9;\\n\\n        for(int i=0;i<n;i++){\\n           sum = min(sum,findsum(matrix,dp,n-1,i));\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "seregakuznetsov98",
                        "content": "In the brute force approach we have to create a paths(trees) for each top element of the array, this paths will cross each other, so how to avoid repetition in calculation for the same paths?"
                    },
                    {
                        "username": "dipeshbindlish",
                        "content": "Also known as Dynamic Programming Approach (using result from previous calculation than to calculate again).\\n"
                    },
                    {
                        "username": "dipeshbindlish",
                        "content": "Start from 2nd row & for each element check which element from above row is to be added in it (i.e. minimum of the three elements above it.)"
                    },
                    {
                        "username": "dipeshbindlish",
                        "content": "Use Dynamic Programming"
                    },
                    {
                        "username": "AkselJensen",
                        "content": "Oh dear, I accidentally posted a solution. I\\'m so sorry."
                    },
                    {
                        "username": "Finesse",
                        "content": "The matrix can be viewed as a directional graph, where the cells are weights of the edges leading to these cells. Any algorithm for finding the shortest path in a graph can be used.\n\nSome algorithms aren't designed for negative edge weights (e.g. Dijkstra's), it can be solved by subtracting the minimal weight from the matrix (to make all the values be not negative), and add `minWeight * n` to the result to de-adjust it."
                    }
                ]
            },
            {
                "id": 1715333,
                "content": [
                    {
                        "username": "ankit_cruxx",
                        "content": "Can someone please help, what is the wrong here? I am getting a runtime error but i cannot see anything absurd. \\n\\n\\nint n = matrix.size();\\n         int m = matrix[0].size();\\n\\n        if (n==1) return *min_element(matrix[0].begin(),matrix[0].end());\\n        \\n      for(int i=1; i<n ; i++)\\n      {\\n      for(int j=0; j<m ; j++)\\n      {\\n          if(j==0)\\n          {\\n              matrix[i][j] = matrix[i][j] + min(matrix[i-1][j], matrix[i-1][j+1]);\\n          }\\n          if(j==m-1)\\n          {\\n              matrix[i][j] = matrix[i][j] + min(matrix[i-1][j],matrix[i-1][j-1]);\\n          }\\n          else\\n             matrix[i][j] = matrix[i][j] + min(matrix[i-1][j], min(matrix[i-1][j-1], matrix[i-1][j+1]));\\n      }\\n      }\\n      return *min_element(matrix[n-1].begin(),matrix[n-1].end());"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "You\\'re not using RUST. that is what is wrong"
                    },
                    {
                        "username": "mulani",
                        "content": "My code if failing for the following test case. Can someone please help me understand?\nmatrix =\n[[100,-42,-46,-41],[31,97,10,-10],[-58,-51,82,89],[51,81,69,-51]]\n\n ```\nclass Solution:\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\n        ROWS, COLS = len(matrix), len(matrix[0])\n        cache = {} # (r, c) : min_path_sum\n\n        def find_min_path(r, c):\n            if (r, c) in cache:\n                return cache[(r, c)]\n            min_path_sum = matrix[r][c]\n            if (r == ROWS - 1 and c == COLS - 1) or r == ROWS - 1:\n                min_path_sum += 0\n            elif c == COLS - 1:\n                min_path_sum += min(find_min_path(r + 1, c - 1), find_min_path(r + 1, c))\n            else:\n                min_path_sum += min(find_min_path(r + 1, c - 1), find_min_path(r + 1, c), find_min_path(r + 1, c + 1))\n            cache[(r, c)] = min_path_sum\n            return min_path_sum\n\n        min_path_sum = (100 * ROWS) + 1\n        for c in range(COLS):\n            min_path_sum = min(min_path_sum, find_min_path(0, c))\n        return min_path_sum\n```"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Monika Mulani](/mulani) You didn't consider the left bound right?\n\nwhen c==0:  min_path_sum += min(find_min_path(r + 1, c), find_min_path(r + 1, c + 1))\nfind_min_path(r + 1, c - 1) -> will look at the last column, then it returns a wrong answer! \n\nRelax, you are thinking too much. \nJust look at my $O(n^2)$ solution, go straight to problem. \n\n```\nclass Solution:\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\n        n = len(matrix) # a squared matrix        \n        for i in range(1,n):\n            matrix[i][0] += min(matrix[i-1][0:2])    # First element\n            matrix[i][n-1]+= min(matrix[i-1][n-2:n]) # Last element\n            for j in range(1,n-1):   \n                matrix[i][j]+=min(matrix[i-1][j-1:j+2])\n        return min(matrix[n-1])\n```"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": " can anyone explain why am i getting runtime error??\\n\\n\\nint minFallingPathSum(vector<vector<int>>& matrix) \\n    {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<vector<int>>ans(n,vector<int>(m,0));\\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            ans[0][j]=matrix[0][j];\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int s=matrix[i][j]+ans[i-1][j];\\n                int l=matrix[i][j];\\n                if(j>0)l+=ans[i-1][j-1];\\n                else l+=1e8;\\n                int r=matrix[i][j];\\n            \\n                if(j<n-1)r+=ans[i-1][j+1];\\n                else r+=1e8;\\n\\n                ans[i][j]=min(s,min(l,r));\\n            }\\n\\n        }\\n\\n    int mini=1e8;\\n    for(int j=0;j<m;j++)\\n    {\\n        mini=min(mini,ans[n-1][j]);\\n    }\\n\\n    return mini;\\n\\n\\n\\n        \\n    }"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "[@Deetav](/Deetav) got it thanks"
                    },
                    {
                        "username": "Deetav",
                        "content": "            int s=matrix[i][j]+ans[i-1][j];\\n\\nIn this line, when i = 0 your\\'e code will try to access ans[-1][j]."
                    },
                    {
                        "username": "nikhil08bhalla",
                        "content": "Why this code is giving overflow error\n```\nclass Solution {\npublic:\n    int f(int i,int j, vector<vector<int>>& v){\n        if(j<0 || j>=v[0].size()){\n            return INT_MAX;\n        }\n        if(i==0){\n            return v[0][j];\n        }\n        int s=v[i][j]+f(i-1,j,v);\n        int ld=v[i][j]+f(i-1,j-1,v);\n        int rd=v[i][j]+f(i-1,j+1,v);\n        return min(s,min(ld,rd));\n    }\n    int minFallingPathSum(vector<vector<int>>& v) {\n        int n=v.size();\n        int m=v[0].size();\n        if(n==0){\n            return 0;\n        }\n        else if(n==1){\n            return v[0][0];\n        }\n        int res=INT_MAX;\n        for(int j=0;j<m;j++){\n            res=min(res,f(n-1,j,v));\n        }\n        return res;\n    }\n};\n```"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "Can this question be done using O(1) space and without using recursion...\nLike the  [minimum-falling-path-sum-ii](https://leetcode.com/problems/minimum-falling-path-sum-ii/description/), as it can be done without using any extra space or recursion... \n"
                    },
                    {
                        "username": "Yongbi",
                        "content": "But I think it's slow when using the slicing. \nAnw, I didnt use extra space, but my results (memory) is not optimal."
                    },
                    {
                        "username": "HighViscosityFlow",
                        "content": "Yes. This problem doesn`t need a recursion and no extra space needed."
                    },
                    {
                        "username": "prajwalkraut10",
                        "content": "Why my solution isn\\'t working??? \\n\\nprivate:\\n    int findsum(vector<vector<int>>& matrix,vector<vector<int>> &dp,int i,int j){\\n        int n = matrix.size();\\n        if(j<0 || j>=n) return 1e9;\\n        if(i==0) return matrix[0][j];\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        int left = matrix[i][j] + findsum(matrix,dp,i-1,j-1);\\n        int mid = matrix[i][j] + findsum(matrix,dp,i-i,j);\\n        int rig = matrix[i][j] + findsum(matrix,dp,i-1,j+1);\\n\\n        return dp[i][j] = min(left,min(mid,rig));\\n    }\\n\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n       \\n        int n = matrix.size();\\n        vector<vector<int>> dp(n,vector<int> (n,-1));\\n        int sum = 1e9;\\n\\n        for(int i=0;i<n;i++){\\n           sum = min(sum,findsum(matrix,dp,n-1,i));\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "seregakuznetsov98",
                        "content": "In the brute force approach we have to create a paths(trees) for each top element of the array, this paths will cross each other, so how to avoid repetition in calculation for the same paths?"
                    },
                    {
                        "username": "dipeshbindlish",
                        "content": "Also known as Dynamic Programming Approach (using result from previous calculation than to calculate again).\\n"
                    },
                    {
                        "username": "dipeshbindlish",
                        "content": "Start from 2nd row & for each element check which element from above row is to be added in it (i.e. minimum of the three elements above it.)"
                    },
                    {
                        "username": "dipeshbindlish",
                        "content": "Use Dynamic Programming"
                    },
                    {
                        "username": "AkselJensen",
                        "content": "Oh dear, I accidentally posted a solution. I\\'m so sorry."
                    },
                    {
                        "username": "Finesse",
                        "content": "The matrix can be viewed as a directional graph, where the cells are weights of the edges leading to these cells. Any algorithm for finding the shortest path in a graph can be used.\n\nSome algorithms aren't designed for negative edge weights (e.g. Dijkstra's), it can be solved by subtracting the minimal weight from the matrix (to make all the values be not negative), and add `minWeight * n` to the result to de-adjust it."
                    }
                ]
            },
            {
                "id": 1715243,
                "content": [
                    {
                        "username": "ankit_cruxx",
                        "content": "Can someone please help, what is the wrong here? I am getting a runtime error but i cannot see anything absurd. \\n\\n\\nint n = matrix.size();\\n         int m = matrix[0].size();\\n\\n        if (n==1) return *min_element(matrix[0].begin(),matrix[0].end());\\n        \\n      for(int i=1; i<n ; i++)\\n      {\\n      for(int j=0; j<m ; j++)\\n      {\\n          if(j==0)\\n          {\\n              matrix[i][j] = matrix[i][j] + min(matrix[i-1][j], matrix[i-1][j+1]);\\n          }\\n          if(j==m-1)\\n          {\\n              matrix[i][j] = matrix[i][j] + min(matrix[i-1][j],matrix[i-1][j-1]);\\n          }\\n          else\\n             matrix[i][j] = matrix[i][j] + min(matrix[i-1][j], min(matrix[i-1][j-1], matrix[i-1][j+1]));\\n      }\\n      }\\n      return *min_element(matrix[n-1].begin(),matrix[n-1].end());"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "You\\'re not using RUST. that is what is wrong"
                    },
                    {
                        "username": "mulani",
                        "content": "My code if failing for the following test case. Can someone please help me understand?\nmatrix =\n[[100,-42,-46,-41],[31,97,10,-10],[-58,-51,82,89],[51,81,69,-51]]\n\n ```\nclass Solution:\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\n        ROWS, COLS = len(matrix), len(matrix[0])\n        cache = {} # (r, c) : min_path_sum\n\n        def find_min_path(r, c):\n            if (r, c) in cache:\n                return cache[(r, c)]\n            min_path_sum = matrix[r][c]\n            if (r == ROWS - 1 and c == COLS - 1) or r == ROWS - 1:\n                min_path_sum += 0\n            elif c == COLS - 1:\n                min_path_sum += min(find_min_path(r + 1, c - 1), find_min_path(r + 1, c))\n            else:\n                min_path_sum += min(find_min_path(r + 1, c - 1), find_min_path(r + 1, c), find_min_path(r + 1, c + 1))\n            cache[(r, c)] = min_path_sum\n            return min_path_sum\n\n        min_path_sum = (100 * ROWS) + 1\n        for c in range(COLS):\n            min_path_sum = min(min_path_sum, find_min_path(0, c))\n        return min_path_sum\n```"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Monika Mulani](/mulani) You didn't consider the left bound right?\n\nwhen c==0:  min_path_sum += min(find_min_path(r + 1, c), find_min_path(r + 1, c + 1))\nfind_min_path(r + 1, c - 1) -> will look at the last column, then it returns a wrong answer! \n\nRelax, you are thinking too much. \nJust look at my $O(n^2)$ solution, go straight to problem. \n\n```\nclass Solution:\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\n        n = len(matrix) # a squared matrix        \n        for i in range(1,n):\n            matrix[i][0] += min(matrix[i-1][0:2])    # First element\n            matrix[i][n-1]+= min(matrix[i-1][n-2:n]) # Last element\n            for j in range(1,n-1):   \n                matrix[i][j]+=min(matrix[i-1][j-1:j+2])\n        return min(matrix[n-1])\n```"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": " can anyone explain why am i getting runtime error??\\n\\n\\nint minFallingPathSum(vector<vector<int>>& matrix) \\n    {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<vector<int>>ans(n,vector<int>(m,0));\\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            ans[0][j]=matrix[0][j];\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int s=matrix[i][j]+ans[i-1][j];\\n                int l=matrix[i][j];\\n                if(j>0)l+=ans[i-1][j-1];\\n                else l+=1e8;\\n                int r=matrix[i][j];\\n            \\n                if(j<n-1)r+=ans[i-1][j+1];\\n                else r+=1e8;\\n\\n                ans[i][j]=min(s,min(l,r));\\n            }\\n\\n        }\\n\\n    int mini=1e8;\\n    for(int j=0;j<m;j++)\\n    {\\n        mini=min(mini,ans[n-1][j]);\\n    }\\n\\n    return mini;\\n\\n\\n\\n        \\n    }"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "[@Deetav](/Deetav) got it thanks"
                    },
                    {
                        "username": "Deetav",
                        "content": "            int s=matrix[i][j]+ans[i-1][j];\\n\\nIn this line, when i = 0 your\\'e code will try to access ans[-1][j]."
                    },
                    {
                        "username": "nikhil08bhalla",
                        "content": "Why this code is giving overflow error\n```\nclass Solution {\npublic:\n    int f(int i,int j, vector<vector<int>>& v){\n        if(j<0 || j>=v[0].size()){\n            return INT_MAX;\n        }\n        if(i==0){\n            return v[0][j];\n        }\n        int s=v[i][j]+f(i-1,j,v);\n        int ld=v[i][j]+f(i-1,j-1,v);\n        int rd=v[i][j]+f(i-1,j+1,v);\n        return min(s,min(ld,rd));\n    }\n    int minFallingPathSum(vector<vector<int>>& v) {\n        int n=v.size();\n        int m=v[0].size();\n        if(n==0){\n            return 0;\n        }\n        else if(n==1){\n            return v[0][0];\n        }\n        int res=INT_MAX;\n        for(int j=0;j<m;j++){\n            res=min(res,f(n-1,j,v));\n        }\n        return res;\n    }\n};\n```"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "Can this question be done using O(1) space and without using recursion...\nLike the  [minimum-falling-path-sum-ii](https://leetcode.com/problems/minimum-falling-path-sum-ii/description/), as it can be done without using any extra space or recursion... \n"
                    },
                    {
                        "username": "Yongbi",
                        "content": "But I think it's slow when using the slicing. \nAnw, I didnt use extra space, but my results (memory) is not optimal."
                    },
                    {
                        "username": "HighViscosityFlow",
                        "content": "Yes. This problem doesn`t need a recursion and no extra space needed."
                    },
                    {
                        "username": "prajwalkraut10",
                        "content": "Why my solution isn\\'t working??? \\n\\nprivate:\\n    int findsum(vector<vector<int>>& matrix,vector<vector<int>> &dp,int i,int j){\\n        int n = matrix.size();\\n        if(j<0 || j>=n) return 1e9;\\n        if(i==0) return matrix[0][j];\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        int left = matrix[i][j] + findsum(matrix,dp,i-1,j-1);\\n        int mid = matrix[i][j] + findsum(matrix,dp,i-i,j);\\n        int rig = matrix[i][j] + findsum(matrix,dp,i-1,j+1);\\n\\n        return dp[i][j] = min(left,min(mid,rig));\\n    }\\n\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n       \\n        int n = matrix.size();\\n        vector<vector<int>> dp(n,vector<int> (n,-1));\\n        int sum = 1e9;\\n\\n        for(int i=0;i<n;i++){\\n           sum = min(sum,findsum(matrix,dp,n-1,i));\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "seregakuznetsov98",
                        "content": "In the brute force approach we have to create a paths(trees) for each top element of the array, this paths will cross each other, so how to avoid repetition in calculation for the same paths?"
                    },
                    {
                        "username": "dipeshbindlish",
                        "content": "Also known as Dynamic Programming Approach (using result from previous calculation than to calculate again).\\n"
                    },
                    {
                        "username": "dipeshbindlish",
                        "content": "Start from 2nd row & for each element check which element from above row is to be added in it (i.e. minimum of the three elements above it.)"
                    },
                    {
                        "username": "dipeshbindlish",
                        "content": "Use Dynamic Programming"
                    },
                    {
                        "username": "AkselJensen",
                        "content": "Oh dear, I accidentally posted a solution. I\\'m so sorry."
                    },
                    {
                        "username": "Finesse",
                        "content": "The matrix can be viewed as a directional graph, where the cells are weights of the edges leading to these cells. Any algorithm for finding the shortest path in a graph can be used.\n\nSome algorithms aren't designed for negative edge weights (e.g. Dijkstra's), it can be solved by subtracting the minimal weight from the matrix (to make all the values be not negative), and add `minWeight * n` to the result to de-adjust it."
                    }
                ]
            },
            {
                "id": 1715237,
                "content": [
                    {
                        "username": "ankit_cruxx",
                        "content": "Can someone please help, what is the wrong here? I am getting a runtime error but i cannot see anything absurd. \\n\\n\\nint n = matrix.size();\\n         int m = matrix[0].size();\\n\\n        if (n==1) return *min_element(matrix[0].begin(),matrix[0].end());\\n        \\n      for(int i=1; i<n ; i++)\\n      {\\n      for(int j=0; j<m ; j++)\\n      {\\n          if(j==0)\\n          {\\n              matrix[i][j] = matrix[i][j] + min(matrix[i-1][j], matrix[i-1][j+1]);\\n          }\\n          if(j==m-1)\\n          {\\n              matrix[i][j] = matrix[i][j] + min(matrix[i-1][j],matrix[i-1][j-1]);\\n          }\\n          else\\n             matrix[i][j] = matrix[i][j] + min(matrix[i-1][j], min(matrix[i-1][j-1], matrix[i-1][j+1]));\\n      }\\n      }\\n      return *min_element(matrix[n-1].begin(),matrix[n-1].end());"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "You\\'re not using RUST. that is what is wrong"
                    },
                    {
                        "username": "mulani",
                        "content": "My code if failing for the following test case. Can someone please help me understand?\nmatrix =\n[[100,-42,-46,-41],[31,97,10,-10],[-58,-51,82,89],[51,81,69,-51]]\n\n ```\nclass Solution:\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\n        ROWS, COLS = len(matrix), len(matrix[0])\n        cache = {} # (r, c) : min_path_sum\n\n        def find_min_path(r, c):\n            if (r, c) in cache:\n                return cache[(r, c)]\n            min_path_sum = matrix[r][c]\n            if (r == ROWS - 1 and c == COLS - 1) or r == ROWS - 1:\n                min_path_sum += 0\n            elif c == COLS - 1:\n                min_path_sum += min(find_min_path(r + 1, c - 1), find_min_path(r + 1, c))\n            else:\n                min_path_sum += min(find_min_path(r + 1, c - 1), find_min_path(r + 1, c), find_min_path(r + 1, c + 1))\n            cache[(r, c)] = min_path_sum\n            return min_path_sum\n\n        min_path_sum = (100 * ROWS) + 1\n        for c in range(COLS):\n            min_path_sum = min(min_path_sum, find_min_path(0, c))\n        return min_path_sum\n```"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Monika Mulani](/mulani) You didn't consider the left bound right?\n\nwhen c==0:  min_path_sum += min(find_min_path(r + 1, c), find_min_path(r + 1, c + 1))\nfind_min_path(r + 1, c - 1) -> will look at the last column, then it returns a wrong answer! \n\nRelax, you are thinking too much. \nJust look at my $O(n^2)$ solution, go straight to problem. \n\n```\nclass Solution:\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\n        n = len(matrix) # a squared matrix        \n        for i in range(1,n):\n            matrix[i][0] += min(matrix[i-1][0:2])    # First element\n            matrix[i][n-1]+= min(matrix[i-1][n-2:n]) # Last element\n            for j in range(1,n-1):   \n                matrix[i][j]+=min(matrix[i-1][j-1:j+2])\n        return min(matrix[n-1])\n```"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": " can anyone explain why am i getting runtime error??\\n\\n\\nint minFallingPathSum(vector<vector<int>>& matrix) \\n    {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<vector<int>>ans(n,vector<int>(m,0));\\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            ans[0][j]=matrix[0][j];\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int s=matrix[i][j]+ans[i-1][j];\\n                int l=matrix[i][j];\\n                if(j>0)l+=ans[i-1][j-1];\\n                else l+=1e8;\\n                int r=matrix[i][j];\\n            \\n                if(j<n-1)r+=ans[i-1][j+1];\\n                else r+=1e8;\\n\\n                ans[i][j]=min(s,min(l,r));\\n            }\\n\\n        }\\n\\n    int mini=1e8;\\n    for(int j=0;j<m;j++)\\n    {\\n        mini=min(mini,ans[n-1][j]);\\n    }\\n\\n    return mini;\\n\\n\\n\\n        \\n    }"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "[@Deetav](/Deetav) got it thanks"
                    },
                    {
                        "username": "Deetav",
                        "content": "            int s=matrix[i][j]+ans[i-1][j];\\n\\nIn this line, when i = 0 your\\'e code will try to access ans[-1][j]."
                    },
                    {
                        "username": "nikhil08bhalla",
                        "content": "Why this code is giving overflow error\n```\nclass Solution {\npublic:\n    int f(int i,int j, vector<vector<int>>& v){\n        if(j<0 || j>=v[0].size()){\n            return INT_MAX;\n        }\n        if(i==0){\n            return v[0][j];\n        }\n        int s=v[i][j]+f(i-1,j,v);\n        int ld=v[i][j]+f(i-1,j-1,v);\n        int rd=v[i][j]+f(i-1,j+1,v);\n        return min(s,min(ld,rd));\n    }\n    int minFallingPathSum(vector<vector<int>>& v) {\n        int n=v.size();\n        int m=v[0].size();\n        if(n==0){\n            return 0;\n        }\n        else if(n==1){\n            return v[0][0];\n        }\n        int res=INT_MAX;\n        for(int j=0;j<m;j++){\n            res=min(res,f(n-1,j,v));\n        }\n        return res;\n    }\n};\n```"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "Can this question be done using O(1) space and without using recursion...\nLike the  [minimum-falling-path-sum-ii](https://leetcode.com/problems/minimum-falling-path-sum-ii/description/), as it can be done without using any extra space or recursion... \n"
                    },
                    {
                        "username": "Yongbi",
                        "content": "But I think it's slow when using the slicing. \nAnw, I didnt use extra space, but my results (memory) is not optimal."
                    },
                    {
                        "username": "HighViscosityFlow",
                        "content": "Yes. This problem doesn`t need a recursion and no extra space needed."
                    },
                    {
                        "username": "prajwalkraut10",
                        "content": "Why my solution isn\\'t working??? \\n\\nprivate:\\n    int findsum(vector<vector<int>>& matrix,vector<vector<int>> &dp,int i,int j){\\n        int n = matrix.size();\\n        if(j<0 || j>=n) return 1e9;\\n        if(i==0) return matrix[0][j];\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        int left = matrix[i][j] + findsum(matrix,dp,i-1,j-1);\\n        int mid = matrix[i][j] + findsum(matrix,dp,i-i,j);\\n        int rig = matrix[i][j] + findsum(matrix,dp,i-1,j+1);\\n\\n        return dp[i][j] = min(left,min(mid,rig));\\n    }\\n\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n       \\n        int n = matrix.size();\\n        vector<vector<int>> dp(n,vector<int> (n,-1));\\n        int sum = 1e9;\\n\\n        for(int i=0;i<n;i++){\\n           sum = min(sum,findsum(matrix,dp,n-1,i));\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "seregakuznetsov98",
                        "content": "In the brute force approach we have to create a paths(trees) for each top element of the array, this paths will cross each other, so how to avoid repetition in calculation for the same paths?"
                    },
                    {
                        "username": "dipeshbindlish",
                        "content": "Also known as Dynamic Programming Approach (using result from previous calculation than to calculate again).\\n"
                    },
                    {
                        "username": "dipeshbindlish",
                        "content": "Start from 2nd row & for each element check which element from above row is to be added in it (i.e. minimum of the three elements above it.)"
                    },
                    {
                        "username": "dipeshbindlish",
                        "content": "Use Dynamic Programming"
                    },
                    {
                        "username": "AkselJensen",
                        "content": "Oh dear, I accidentally posted a solution. I\\'m so sorry."
                    },
                    {
                        "username": "Finesse",
                        "content": "The matrix can be viewed as a directional graph, where the cells are weights of the edges leading to these cells. Any algorithm for finding the shortest path in a graph can be used.\n\nSome algorithms aren't designed for negative edge weights (e.g. Dijkstra's), it can be solved by subtracting the minimal weight from the matrix (to make all the values be not negative), and add `minWeight * n` to the result to de-adjust it."
                    }
                ]
            },
            {
                "id": 1715158,
                "content": [
                    {
                        "username": "ankit_cruxx",
                        "content": "Can someone please help, what is the wrong here? I am getting a runtime error but i cannot see anything absurd. \\n\\n\\nint n = matrix.size();\\n         int m = matrix[0].size();\\n\\n        if (n==1) return *min_element(matrix[0].begin(),matrix[0].end());\\n        \\n      for(int i=1; i<n ; i++)\\n      {\\n      for(int j=0; j<m ; j++)\\n      {\\n          if(j==0)\\n          {\\n              matrix[i][j] = matrix[i][j] + min(matrix[i-1][j], matrix[i-1][j+1]);\\n          }\\n          if(j==m-1)\\n          {\\n              matrix[i][j] = matrix[i][j] + min(matrix[i-1][j],matrix[i-1][j-1]);\\n          }\\n          else\\n             matrix[i][j] = matrix[i][j] + min(matrix[i-1][j], min(matrix[i-1][j-1], matrix[i-1][j+1]));\\n      }\\n      }\\n      return *min_element(matrix[n-1].begin(),matrix[n-1].end());"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "You\\'re not using RUST. that is what is wrong"
                    },
                    {
                        "username": "mulani",
                        "content": "My code if failing for the following test case. Can someone please help me understand?\nmatrix =\n[[100,-42,-46,-41],[31,97,10,-10],[-58,-51,82,89],[51,81,69,-51]]\n\n ```\nclass Solution:\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\n        ROWS, COLS = len(matrix), len(matrix[0])\n        cache = {} # (r, c) : min_path_sum\n\n        def find_min_path(r, c):\n            if (r, c) in cache:\n                return cache[(r, c)]\n            min_path_sum = matrix[r][c]\n            if (r == ROWS - 1 and c == COLS - 1) or r == ROWS - 1:\n                min_path_sum += 0\n            elif c == COLS - 1:\n                min_path_sum += min(find_min_path(r + 1, c - 1), find_min_path(r + 1, c))\n            else:\n                min_path_sum += min(find_min_path(r + 1, c - 1), find_min_path(r + 1, c), find_min_path(r + 1, c + 1))\n            cache[(r, c)] = min_path_sum\n            return min_path_sum\n\n        min_path_sum = (100 * ROWS) + 1\n        for c in range(COLS):\n            min_path_sum = min(min_path_sum, find_min_path(0, c))\n        return min_path_sum\n```"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Monika Mulani](/mulani) You didn't consider the left bound right?\n\nwhen c==0:  min_path_sum += min(find_min_path(r + 1, c), find_min_path(r + 1, c + 1))\nfind_min_path(r + 1, c - 1) -> will look at the last column, then it returns a wrong answer! \n\nRelax, you are thinking too much. \nJust look at my $O(n^2)$ solution, go straight to problem. \n\n```\nclass Solution:\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\n        n = len(matrix) # a squared matrix        \n        for i in range(1,n):\n            matrix[i][0] += min(matrix[i-1][0:2])    # First element\n            matrix[i][n-1]+= min(matrix[i-1][n-2:n]) # Last element\n            for j in range(1,n-1):   \n                matrix[i][j]+=min(matrix[i-1][j-1:j+2])\n        return min(matrix[n-1])\n```"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": " can anyone explain why am i getting runtime error??\\n\\n\\nint minFallingPathSum(vector<vector<int>>& matrix) \\n    {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<vector<int>>ans(n,vector<int>(m,0));\\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            ans[0][j]=matrix[0][j];\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int s=matrix[i][j]+ans[i-1][j];\\n                int l=matrix[i][j];\\n                if(j>0)l+=ans[i-1][j-1];\\n                else l+=1e8;\\n                int r=matrix[i][j];\\n            \\n                if(j<n-1)r+=ans[i-1][j+1];\\n                else r+=1e8;\\n\\n                ans[i][j]=min(s,min(l,r));\\n            }\\n\\n        }\\n\\n    int mini=1e8;\\n    for(int j=0;j<m;j++)\\n    {\\n        mini=min(mini,ans[n-1][j]);\\n    }\\n\\n    return mini;\\n\\n\\n\\n        \\n    }"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "[@Deetav](/Deetav) got it thanks"
                    },
                    {
                        "username": "Deetav",
                        "content": "            int s=matrix[i][j]+ans[i-1][j];\\n\\nIn this line, when i = 0 your\\'e code will try to access ans[-1][j]."
                    },
                    {
                        "username": "nikhil08bhalla",
                        "content": "Why this code is giving overflow error\n```\nclass Solution {\npublic:\n    int f(int i,int j, vector<vector<int>>& v){\n        if(j<0 || j>=v[0].size()){\n            return INT_MAX;\n        }\n        if(i==0){\n            return v[0][j];\n        }\n        int s=v[i][j]+f(i-1,j,v);\n        int ld=v[i][j]+f(i-1,j-1,v);\n        int rd=v[i][j]+f(i-1,j+1,v);\n        return min(s,min(ld,rd));\n    }\n    int minFallingPathSum(vector<vector<int>>& v) {\n        int n=v.size();\n        int m=v[0].size();\n        if(n==0){\n            return 0;\n        }\n        else if(n==1){\n            return v[0][0];\n        }\n        int res=INT_MAX;\n        for(int j=0;j<m;j++){\n            res=min(res,f(n-1,j,v));\n        }\n        return res;\n    }\n};\n```"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "Can this question be done using O(1) space and without using recursion...\nLike the  [minimum-falling-path-sum-ii](https://leetcode.com/problems/minimum-falling-path-sum-ii/description/), as it can be done without using any extra space or recursion... \n"
                    },
                    {
                        "username": "Yongbi",
                        "content": "But I think it's slow when using the slicing. \nAnw, I didnt use extra space, but my results (memory) is not optimal."
                    },
                    {
                        "username": "HighViscosityFlow",
                        "content": "Yes. This problem doesn`t need a recursion and no extra space needed."
                    },
                    {
                        "username": "prajwalkraut10",
                        "content": "Why my solution isn\\'t working??? \\n\\nprivate:\\n    int findsum(vector<vector<int>>& matrix,vector<vector<int>> &dp,int i,int j){\\n        int n = matrix.size();\\n        if(j<0 || j>=n) return 1e9;\\n        if(i==0) return matrix[0][j];\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        int left = matrix[i][j] + findsum(matrix,dp,i-1,j-1);\\n        int mid = matrix[i][j] + findsum(matrix,dp,i-i,j);\\n        int rig = matrix[i][j] + findsum(matrix,dp,i-1,j+1);\\n\\n        return dp[i][j] = min(left,min(mid,rig));\\n    }\\n\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n       \\n        int n = matrix.size();\\n        vector<vector<int>> dp(n,vector<int> (n,-1));\\n        int sum = 1e9;\\n\\n        for(int i=0;i<n;i++){\\n           sum = min(sum,findsum(matrix,dp,n-1,i));\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "seregakuznetsov98",
                        "content": "In the brute force approach we have to create a paths(trees) for each top element of the array, this paths will cross each other, so how to avoid repetition in calculation for the same paths?"
                    },
                    {
                        "username": "dipeshbindlish",
                        "content": "Also known as Dynamic Programming Approach (using result from previous calculation than to calculate again).\\n"
                    },
                    {
                        "username": "dipeshbindlish",
                        "content": "Start from 2nd row & for each element check which element from above row is to be added in it (i.e. minimum of the three elements above it.)"
                    },
                    {
                        "username": "dipeshbindlish",
                        "content": "Use Dynamic Programming"
                    },
                    {
                        "username": "AkselJensen",
                        "content": "Oh dear, I accidentally posted a solution. I\\'m so sorry."
                    },
                    {
                        "username": "Finesse",
                        "content": "The matrix can be viewed as a directional graph, where the cells are weights of the edges leading to these cells. Any algorithm for finding the shortest path in a graph can be used.\n\nSome algorithms aren't designed for negative edge weights (e.g. Dijkstra's), it can be solved by subtracting the minimal weight from the matrix (to make all the values be not negative), and add `minWeight * n` to the result to de-adjust it."
                    }
                ]
            },
            {
                "id": 1715133,
                "content": [
                    {
                        "username": "ankit_cruxx",
                        "content": "Can someone please help, what is the wrong here? I am getting a runtime error but i cannot see anything absurd. \\n\\n\\nint n = matrix.size();\\n         int m = matrix[0].size();\\n\\n        if (n==1) return *min_element(matrix[0].begin(),matrix[0].end());\\n        \\n      for(int i=1; i<n ; i++)\\n      {\\n      for(int j=0; j<m ; j++)\\n      {\\n          if(j==0)\\n          {\\n              matrix[i][j] = matrix[i][j] + min(matrix[i-1][j], matrix[i-1][j+1]);\\n          }\\n          if(j==m-1)\\n          {\\n              matrix[i][j] = matrix[i][j] + min(matrix[i-1][j],matrix[i-1][j-1]);\\n          }\\n          else\\n             matrix[i][j] = matrix[i][j] + min(matrix[i-1][j], min(matrix[i-1][j-1], matrix[i-1][j+1]));\\n      }\\n      }\\n      return *min_element(matrix[n-1].begin(),matrix[n-1].end());"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "You\\'re not using RUST. that is what is wrong"
                    },
                    {
                        "username": "mulani",
                        "content": "My code if failing for the following test case. Can someone please help me understand?\nmatrix =\n[[100,-42,-46,-41],[31,97,10,-10],[-58,-51,82,89],[51,81,69,-51]]\n\n ```\nclass Solution:\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\n        ROWS, COLS = len(matrix), len(matrix[0])\n        cache = {} # (r, c) : min_path_sum\n\n        def find_min_path(r, c):\n            if (r, c) in cache:\n                return cache[(r, c)]\n            min_path_sum = matrix[r][c]\n            if (r == ROWS - 1 and c == COLS - 1) or r == ROWS - 1:\n                min_path_sum += 0\n            elif c == COLS - 1:\n                min_path_sum += min(find_min_path(r + 1, c - 1), find_min_path(r + 1, c))\n            else:\n                min_path_sum += min(find_min_path(r + 1, c - 1), find_min_path(r + 1, c), find_min_path(r + 1, c + 1))\n            cache[(r, c)] = min_path_sum\n            return min_path_sum\n\n        min_path_sum = (100 * ROWS) + 1\n        for c in range(COLS):\n            min_path_sum = min(min_path_sum, find_min_path(0, c))\n        return min_path_sum\n```"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Monika Mulani](/mulani) You didn't consider the left bound right?\n\nwhen c==0:  min_path_sum += min(find_min_path(r + 1, c), find_min_path(r + 1, c + 1))\nfind_min_path(r + 1, c - 1) -> will look at the last column, then it returns a wrong answer! \n\nRelax, you are thinking too much. \nJust look at my $O(n^2)$ solution, go straight to problem. \n\n```\nclass Solution:\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\n        n = len(matrix) # a squared matrix        \n        for i in range(1,n):\n            matrix[i][0] += min(matrix[i-1][0:2])    # First element\n            matrix[i][n-1]+= min(matrix[i-1][n-2:n]) # Last element\n            for j in range(1,n-1):   \n                matrix[i][j]+=min(matrix[i-1][j-1:j+2])\n        return min(matrix[n-1])\n```"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": " can anyone explain why am i getting runtime error??\\n\\n\\nint minFallingPathSum(vector<vector<int>>& matrix) \\n    {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<vector<int>>ans(n,vector<int>(m,0));\\n        \\n        for(int j=0;j<m;j++)\\n        {\\n            ans[0][j]=matrix[0][j];\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                int s=matrix[i][j]+ans[i-1][j];\\n                int l=matrix[i][j];\\n                if(j>0)l+=ans[i-1][j-1];\\n                else l+=1e8;\\n                int r=matrix[i][j];\\n            \\n                if(j<n-1)r+=ans[i-1][j+1];\\n                else r+=1e8;\\n\\n                ans[i][j]=min(s,min(l,r));\\n            }\\n\\n        }\\n\\n    int mini=1e8;\\n    for(int j=0;j<m;j++)\\n    {\\n        mini=min(mini,ans[n-1][j]);\\n    }\\n\\n    return mini;\\n\\n\\n\\n        \\n    }"
                    },
                    {
                        "username": "Code-inger_007",
                        "content": "[@Deetav](/Deetav) got it thanks"
                    },
                    {
                        "username": "Deetav",
                        "content": "            int s=matrix[i][j]+ans[i-1][j];\\n\\nIn this line, when i = 0 your\\'e code will try to access ans[-1][j]."
                    },
                    {
                        "username": "nikhil08bhalla",
                        "content": "Why this code is giving overflow error\n```\nclass Solution {\npublic:\n    int f(int i,int j, vector<vector<int>>& v){\n        if(j<0 || j>=v[0].size()){\n            return INT_MAX;\n        }\n        if(i==0){\n            return v[0][j];\n        }\n        int s=v[i][j]+f(i-1,j,v);\n        int ld=v[i][j]+f(i-1,j-1,v);\n        int rd=v[i][j]+f(i-1,j+1,v);\n        return min(s,min(ld,rd));\n    }\n    int minFallingPathSum(vector<vector<int>>& v) {\n        int n=v.size();\n        int m=v[0].size();\n        if(n==0){\n            return 0;\n        }\n        else if(n==1){\n            return v[0][0];\n        }\n        int res=INT_MAX;\n        for(int j=0;j<m;j++){\n            res=min(res,f(n-1,j,v));\n        }\n        return res;\n    }\n};\n```"
                    },
                    {
                        "username": "shadab-malik",
                        "content": "Can this question be done using O(1) space and without using recursion...\nLike the  [minimum-falling-path-sum-ii](https://leetcode.com/problems/minimum-falling-path-sum-ii/description/), as it can be done without using any extra space or recursion... \n"
                    },
                    {
                        "username": "Yongbi",
                        "content": "But I think it's slow when using the slicing. \nAnw, I didnt use extra space, but my results (memory) is not optimal."
                    },
                    {
                        "username": "HighViscosityFlow",
                        "content": "Yes. This problem doesn`t need a recursion and no extra space needed."
                    },
                    {
                        "username": "prajwalkraut10",
                        "content": "Why my solution isn\\'t working??? \\n\\nprivate:\\n    int findsum(vector<vector<int>>& matrix,vector<vector<int>> &dp,int i,int j){\\n        int n = matrix.size();\\n        if(j<0 || j>=n) return 1e9;\\n        if(i==0) return matrix[0][j];\\n        if(dp[i][j] != -1) return dp[i][j];\\n\\n        int left = matrix[i][j] + findsum(matrix,dp,i-1,j-1);\\n        int mid = matrix[i][j] + findsum(matrix,dp,i-i,j);\\n        int rig = matrix[i][j] + findsum(matrix,dp,i-1,j+1);\\n\\n        return dp[i][j] = min(left,min(mid,rig));\\n    }\\n\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n       \\n        int n = matrix.size();\\n        vector<vector<int>> dp(n,vector<int> (n,-1));\\n        int sum = 1e9;\\n\\n        for(int i=0;i<n;i++){\\n           sum = min(sum,findsum(matrix,dp,n-1,i));\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "seregakuznetsov98",
                        "content": "In the brute force approach we have to create a paths(trees) for each top element of the array, this paths will cross each other, so how to avoid repetition in calculation for the same paths?"
                    },
                    {
                        "username": "dipeshbindlish",
                        "content": "Also known as Dynamic Programming Approach (using result from previous calculation than to calculate again).\\n"
                    },
                    {
                        "username": "dipeshbindlish",
                        "content": "Start from 2nd row & for each element check which element from above row is to be added in it (i.e. minimum of the three elements above it.)"
                    },
                    {
                        "username": "dipeshbindlish",
                        "content": "Use Dynamic Programming"
                    },
                    {
                        "username": "AkselJensen",
                        "content": "Oh dear, I accidentally posted a solution. I\\'m so sorry."
                    },
                    {
                        "username": "Finesse",
                        "content": "The matrix can be viewed as a directional graph, where the cells are weights of the edges leading to these cells. Any algorithm for finding the shortest path in a graph can be used.\n\nSome algorithms aren't designed for negative edge weights (e.g. Dijkstra's), it can be solved by subtracting the minimal weight from the matrix (to make all the values be not negative), and add `minWeight * n` to the result to de-adjust it."
                    }
                ]
            },
            {
                "id": 1715073,
                "content": [
                    {
                        "username": "ujjwal1234",
                        "content": "class Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        vector <int>v;\\n        int sum=0;\\n        int a;\\n        int i=0;\\n        int k=0;\\n        while (k<matrix.size()-1)\\n        {\\n            for (int j=0;j<matrix[0].size();j++)\\n            {\\n                if (j>0 &&j<matrix[0].size()-1)\\n                {\\n        matrix[i][j]+= min(matrix[k+1][j],min(matrix[k+1][j-1],matrix[k+1][j+1]));\\n                }\\n                else if (j==0)\\n                {\\n                     matrix[i][j]+=min(matrix[k+1][j],matrix[k+1][j+1]);\\n                }\\n                 else \\n                 {\\n                     matrix[i][j]+=min(matrix[k+1][j],matrix[k+1][j-1]);\\n                 }\\n            }\\n        k++;\\n    }\\n        \\n         \\n        int min=matrix[0][0];\\n        for (int i=0;i<matrix[0].size();i++)\\n        {\\n            if (min>matrix[0][i])\\n                min=matrix[0][i];\\n        }\\n        return min;\\n        \\n            \\n               \\n\\n    }\\n};\\n\\n\\nMy testcase [[2,1,3],[6,5,4],[7,8,9]] is not getting passed, i m getting 12 the output should be 13. Please help;\\n"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "[@ironblade](/ironblade) Hey, can you please tell how to fix this"
                    },
                    {
                        "username": "ironblade",
                        "content": "ur soln shows minimum path of whole matriix its not following the neighbour nodes"
                    },
                    {
                        "username": "dhakad22klx",
                        "content": "I am getting TLE at 43/44.Can someone tell how to resolve if you have gone through same."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "same with me\\n"
                    },
                    {
                        "username": "Umang3172",
                        "content": "Why is it so slow?? \\nPls help\\nclass Solution {\\n    int m,n;\\n    public int minFallingPathSum(int[][] matrix) {\\n        m=matrix.length;\\n        n=matrix[0].length;\\n\\n        int res=Integer.MAX_VALUE;\\n        for(int i=0;i<n;i++){\\n            res=Math.min(res,fall(matrix,new Integer[m][n],0,i));\\n        }\\n        return res;\\n    }\\n\\n    public int fall(int[][] matrix, Integer[][] memo, int row, int col){\\n        if(col<0 || col>=n){\\n            return Integer.MAX_VALUE;\\n        }\\n        if(row==m){\\n            return 0;\\n        }\\n        if(memo[row][col]!=null){\\n            return (int)memo[row][col];\\n        }\\n\\n        int[] dir = new int[]{-1,0,1};\\n        int min=Integer.MAX_VALUE;\\n        for(int i : dir){\\n            min=Math.min(min,fall(matrix,memo,row+1,col+i));\\n        }\\n        memo[row][col] = min+matrix[row][col]; \\n        return min+matrix[row][col];\\n    }\\n}\\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Hint: basically like yesterday\\'s but 2D"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "just use recursion with cache or memoize to avoid duplicate computation"
                    },
                    {
                        "username": "saanchijain",
                        "content": "as in example given testcase matrix1, output is given 13, but minimum sum can be 12 =1+4+7"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "Movement is allowed only linearly or diagonally. 4 to 7 movement is not possible."
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "if you know about n queen problem then you can solve this "
                    },
                    {
                        "username": "akashvdubey",
                        "content": "How is this related with n queen, I don\\'t see any back tracking ?"
                    },
                    {
                        "username": "klu_2100030586",
                        "content": "ans = Math.min(ans, minFallingPathSum(A, 0, i, dp));\\n        "
                    },
                    {
                        "username": "R_Prajwal",
                        "content": "But i am just following backtracking and analysing every possible path and updating the value of ans but it is not reflecting\\n"
                    },
                    {
                        "username": "R_Prajwal",
                        "content": "Can anyone Please Explain why value of \"ans\" is not getting updated.\\n(Python) `def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        n=len(matrix)\\n        ans=100000   \\n        \\n        def recurse(row,col,path,n,ans):\\n            if row==n:\\n                if path<ans:\\n                    \\n                    ans=int(path)\\n                    \\n                return    \\n\\n            if col==n or col<0 or row==n or row<0:\\n                \\n                \\n                return\\n            path+=matrix[row][col]\\n               \\n            directions=((1,-1),(1,0),(1,1))   \\n            for x,y in directions:\\n                recurse(row+x,col+y,path,n,ans)\\n            path-=matrix[row][col]    \\n\\n\\n       \\n        for j in range(n):\\n            recurse(0,j,0,n,ans)\\n        return ans`\\n"
                    },
                    {
                        "username": "Deetav",
                        "content": "`Line 1034: Char 34: runtime error: addition of unsigned offset to 0x6020000001b0 overflowed to 0x6020000001ac (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34`\\n\\nwhere do i find line 1034, my code has only 26 lines :("
                    },
                    {
                        "username": "gabhinav",
                        "content": "maybe you are trying to access something like dp[-1][1] as or you have defined max size of dp like dp[max] but you are trying to access dp[max+1] which has lead to overflow."
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "you can keep some thing like cout << \"ok\" in one line and keep running and change the position of cout line . at a point you cann't see ok is printed there you have the problem"
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "That maybe because of the access of undefined memory. Maybe the code is accessing the outside of the matrix. Its the error message when you miss the out of bounds check condition."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because your solution is wrapped by some code you do not have access. LC uses this wrapper to make their job easier i think. In this case the failure trace is not helpful for sure, but from your trace message it means some addition has overflowed and you should start by checking additions in your code"
                    }
                ]
            },
            {
                "id": 1715003,
                "content": [
                    {
                        "username": "ujjwal1234",
                        "content": "class Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        vector <int>v;\\n        int sum=0;\\n        int a;\\n        int i=0;\\n        int k=0;\\n        while (k<matrix.size()-1)\\n        {\\n            for (int j=0;j<matrix[0].size();j++)\\n            {\\n                if (j>0 &&j<matrix[0].size()-1)\\n                {\\n        matrix[i][j]+= min(matrix[k+1][j],min(matrix[k+1][j-1],matrix[k+1][j+1]));\\n                }\\n                else if (j==0)\\n                {\\n                     matrix[i][j]+=min(matrix[k+1][j],matrix[k+1][j+1]);\\n                }\\n                 else \\n                 {\\n                     matrix[i][j]+=min(matrix[k+1][j],matrix[k+1][j-1]);\\n                 }\\n            }\\n        k++;\\n    }\\n        \\n         \\n        int min=matrix[0][0];\\n        for (int i=0;i<matrix[0].size();i++)\\n        {\\n            if (min>matrix[0][i])\\n                min=matrix[0][i];\\n        }\\n        return min;\\n        \\n            \\n               \\n\\n    }\\n};\\n\\n\\nMy testcase [[2,1,3],[6,5,4],[7,8,9]] is not getting passed, i m getting 12 the output should be 13. Please help;\\n"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "[@ironblade](/ironblade) Hey, can you please tell how to fix this"
                    },
                    {
                        "username": "ironblade",
                        "content": "ur soln shows minimum path of whole matriix its not following the neighbour nodes"
                    },
                    {
                        "username": "dhakad22klx",
                        "content": "I am getting TLE at 43/44.Can someone tell how to resolve if you have gone through same."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "same with me\\n"
                    },
                    {
                        "username": "Umang3172",
                        "content": "Why is it so slow?? \\nPls help\\nclass Solution {\\n    int m,n;\\n    public int minFallingPathSum(int[][] matrix) {\\n        m=matrix.length;\\n        n=matrix[0].length;\\n\\n        int res=Integer.MAX_VALUE;\\n        for(int i=0;i<n;i++){\\n            res=Math.min(res,fall(matrix,new Integer[m][n],0,i));\\n        }\\n        return res;\\n    }\\n\\n    public int fall(int[][] matrix, Integer[][] memo, int row, int col){\\n        if(col<0 || col>=n){\\n            return Integer.MAX_VALUE;\\n        }\\n        if(row==m){\\n            return 0;\\n        }\\n        if(memo[row][col]!=null){\\n            return (int)memo[row][col];\\n        }\\n\\n        int[] dir = new int[]{-1,0,1};\\n        int min=Integer.MAX_VALUE;\\n        for(int i : dir){\\n            min=Math.min(min,fall(matrix,memo,row+1,col+i));\\n        }\\n        memo[row][col] = min+matrix[row][col]; \\n        return min+matrix[row][col];\\n    }\\n}\\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Hint: basically like yesterday\\'s but 2D"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "just use recursion with cache or memoize to avoid duplicate computation"
                    },
                    {
                        "username": "saanchijain",
                        "content": "as in example given testcase matrix1, output is given 13, but minimum sum can be 12 =1+4+7"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "Movement is allowed only linearly or diagonally. 4 to 7 movement is not possible."
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "if you know about n queen problem then you can solve this "
                    },
                    {
                        "username": "akashvdubey",
                        "content": "How is this related with n queen, I don\\'t see any back tracking ?"
                    },
                    {
                        "username": "klu_2100030586",
                        "content": "ans = Math.min(ans, minFallingPathSum(A, 0, i, dp));\\n        "
                    },
                    {
                        "username": "R_Prajwal",
                        "content": "But i am just following backtracking and analysing every possible path and updating the value of ans but it is not reflecting\\n"
                    },
                    {
                        "username": "R_Prajwal",
                        "content": "Can anyone Please Explain why value of \"ans\" is not getting updated.\\n(Python) `def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        n=len(matrix)\\n        ans=100000   \\n        \\n        def recurse(row,col,path,n,ans):\\n            if row==n:\\n                if path<ans:\\n                    \\n                    ans=int(path)\\n                    \\n                return    \\n\\n            if col==n or col<0 or row==n or row<0:\\n                \\n                \\n                return\\n            path+=matrix[row][col]\\n               \\n            directions=((1,-1),(1,0),(1,1))   \\n            for x,y in directions:\\n                recurse(row+x,col+y,path,n,ans)\\n            path-=matrix[row][col]    \\n\\n\\n       \\n        for j in range(n):\\n            recurse(0,j,0,n,ans)\\n        return ans`\\n"
                    },
                    {
                        "username": "Deetav",
                        "content": "`Line 1034: Char 34: runtime error: addition of unsigned offset to 0x6020000001b0 overflowed to 0x6020000001ac (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34`\\n\\nwhere do i find line 1034, my code has only 26 lines :("
                    },
                    {
                        "username": "gabhinav",
                        "content": "maybe you are trying to access something like dp[-1][1] as or you have defined max size of dp like dp[max] but you are trying to access dp[max+1] which has lead to overflow."
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "you can keep some thing like cout << \"ok\" in one line and keep running and change the position of cout line . at a point you cann't see ok is printed there you have the problem"
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "That maybe because of the access of undefined memory. Maybe the code is accessing the outside of the matrix. Its the error message when you miss the out of bounds check condition."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because your solution is wrapped by some code you do not have access. LC uses this wrapper to make their job easier i think. In this case the failure trace is not helpful for sure, but from your trace message it means some addition has overflowed and you should start by checking additions in your code"
                    }
                ]
            },
            {
                "id": 1714955,
                "content": [
                    {
                        "username": "ujjwal1234",
                        "content": "class Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        vector <int>v;\\n        int sum=0;\\n        int a;\\n        int i=0;\\n        int k=0;\\n        while (k<matrix.size()-1)\\n        {\\n            for (int j=0;j<matrix[0].size();j++)\\n            {\\n                if (j>0 &&j<matrix[0].size()-1)\\n                {\\n        matrix[i][j]+= min(matrix[k+1][j],min(matrix[k+1][j-1],matrix[k+1][j+1]));\\n                }\\n                else if (j==0)\\n                {\\n                     matrix[i][j]+=min(matrix[k+1][j],matrix[k+1][j+1]);\\n                }\\n                 else \\n                 {\\n                     matrix[i][j]+=min(matrix[k+1][j],matrix[k+1][j-1]);\\n                 }\\n            }\\n        k++;\\n    }\\n        \\n         \\n        int min=matrix[0][0];\\n        for (int i=0;i<matrix[0].size();i++)\\n        {\\n            if (min>matrix[0][i])\\n                min=matrix[0][i];\\n        }\\n        return min;\\n        \\n            \\n               \\n\\n    }\\n};\\n\\n\\nMy testcase [[2,1,3],[6,5,4],[7,8,9]] is not getting passed, i m getting 12 the output should be 13. Please help;\\n"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "[@ironblade](/ironblade) Hey, can you please tell how to fix this"
                    },
                    {
                        "username": "ironblade",
                        "content": "ur soln shows minimum path of whole matriix its not following the neighbour nodes"
                    },
                    {
                        "username": "dhakad22klx",
                        "content": "I am getting TLE at 43/44.Can someone tell how to resolve if you have gone through same."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "same with me\\n"
                    },
                    {
                        "username": "Umang3172",
                        "content": "Why is it so slow?? \\nPls help\\nclass Solution {\\n    int m,n;\\n    public int minFallingPathSum(int[][] matrix) {\\n        m=matrix.length;\\n        n=matrix[0].length;\\n\\n        int res=Integer.MAX_VALUE;\\n        for(int i=0;i<n;i++){\\n            res=Math.min(res,fall(matrix,new Integer[m][n],0,i));\\n        }\\n        return res;\\n    }\\n\\n    public int fall(int[][] matrix, Integer[][] memo, int row, int col){\\n        if(col<0 || col>=n){\\n            return Integer.MAX_VALUE;\\n        }\\n        if(row==m){\\n            return 0;\\n        }\\n        if(memo[row][col]!=null){\\n            return (int)memo[row][col];\\n        }\\n\\n        int[] dir = new int[]{-1,0,1};\\n        int min=Integer.MAX_VALUE;\\n        for(int i : dir){\\n            min=Math.min(min,fall(matrix,memo,row+1,col+i));\\n        }\\n        memo[row][col] = min+matrix[row][col]; \\n        return min+matrix[row][col];\\n    }\\n}\\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Hint: basically like yesterday\\'s but 2D"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "just use recursion with cache or memoize to avoid duplicate computation"
                    },
                    {
                        "username": "saanchijain",
                        "content": "as in example given testcase matrix1, output is given 13, but minimum sum can be 12 =1+4+7"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "Movement is allowed only linearly or diagonally. 4 to 7 movement is not possible."
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "if you know about n queen problem then you can solve this "
                    },
                    {
                        "username": "akashvdubey",
                        "content": "How is this related with n queen, I don\\'t see any back tracking ?"
                    },
                    {
                        "username": "klu_2100030586",
                        "content": "ans = Math.min(ans, minFallingPathSum(A, 0, i, dp));\\n        "
                    },
                    {
                        "username": "R_Prajwal",
                        "content": "But i am just following backtracking and analysing every possible path and updating the value of ans but it is not reflecting\\n"
                    },
                    {
                        "username": "R_Prajwal",
                        "content": "Can anyone Please Explain why value of \"ans\" is not getting updated.\\n(Python) `def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        n=len(matrix)\\n        ans=100000   \\n        \\n        def recurse(row,col,path,n,ans):\\n            if row==n:\\n                if path<ans:\\n                    \\n                    ans=int(path)\\n                    \\n                return    \\n\\n            if col==n or col<0 or row==n or row<0:\\n                \\n                \\n                return\\n            path+=matrix[row][col]\\n               \\n            directions=((1,-1),(1,0),(1,1))   \\n            for x,y in directions:\\n                recurse(row+x,col+y,path,n,ans)\\n            path-=matrix[row][col]    \\n\\n\\n       \\n        for j in range(n):\\n            recurse(0,j,0,n,ans)\\n        return ans`\\n"
                    },
                    {
                        "username": "Deetav",
                        "content": "`Line 1034: Char 34: runtime error: addition of unsigned offset to 0x6020000001b0 overflowed to 0x6020000001ac (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34`\\n\\nwhere do i find line 1034, my code has only 26 lines :("
                    },
                    {
                        "username": "gabhinav",
                        "content": "maybe you are trying to access something like dp[-1][1] as or you have defined max size of dp like dp[max] but you are trying to access dp[max+1] which has lead to overflow."
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "you can keep some thing like cout << \"ok\" in one line and keep running and change the position of cout line . at a point you cann't see ok is printed there you have the problem"
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "That maybe because of the access of undefined memory. Maybe the code is accessing the outside of the matrix. Its the error message when you miss the out of bounds check condition."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because your solution is wrapped by some code you do not have access. LC uses this wrapper to make their job easier i think. In this case the failure trace is not helpful for sure, but from your trace message it means some addition has overflowed and you should start by checking additions in your code"
                    }
                ]
            },
            {
                "id": 1714953,
                "content": [
                    {
                        "username": "ujjwal1234",
                        "content": "class Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        vector <int>v;\\n        int sum=0;\\n        int a;\\n        int i=0;\\n        int k=0;\\n        while (k<matrix.size()-1)\\n        {\\n            for (int j=0;j<matrix[0].size();j++)\\n            {\\n                if (j>0 &&j<matrix[0].size()-1)\\n                {\\n        matrix[i][j]+= min(matrix[k+1][j],min(matrix[k+1][j-1],matrix[k+1][j+1]));\\n                }\\n                else if (j==0)\\n                {\\n                     matrix[i][j]+=min(matrix[k+1][j],matrix[k+1][j+1]);\\n                }\\n                 else \\n                 {\\n                     matrix[i][j]+=min(matrix[k+1][j],matrix[k+1][j-1]);\\n                 }\\n            }\\n        k++;\\n    }\\n        \\n         \\n        int min=matrix[0][0];\\n        for (int i=0;i<matrix[0].size();i++)\\n        {\\n            if (min>matrix[0][i])\\n                min=matrix[0][i];\\n        }\\n        return min;\\n        \\n            \\n               \\n\\n    }\\n};\\n\\n\\nMy testcase [[2,1,3],[6,5,4],[7,8,9]] is not getting passed, i m getting 12 the output should be 13. Please help;\\n"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "[@ironblade](/ironblade) Hey, can you please tell how to fix this"
                    },
                    {
                        "username": "ironblade",
                        "content": "ur soln shows minimum path of whole matriix its not following the neighbour nodes"
                    },
                    {
                        "username": "dhakad22klx",
                        "content": "I am getting TLE at 43/44.Can someone tell how to resolve if you have gone through same."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "same with me\\n"
                    },
                    {
                        "username": "Umang3172",
                        "content": "Why is it so slow?? \\nPls help\\nclass Solution {\\n    int m,n;\\n    public int minFallingPathSum(int[][] matrix) {\\n        m=matrix.length;\\n        n=matrix[0].length;\\n\\n        int res=Integer.MAX_VALUE;\\n        for(int i=0;i<n;i++){\\n            res=Math.min(res,fall(matrix,new Integer[m][n],0,i));\\n        }\\n        return res;\\n    }\\n\\n    public int fall(int[][] matrix, Integer[][] memo, int row, int col){\\n        if(col<0 || col>=n){\\n            return Integer.MAX_VALUE;\\n        }\\n        if(row==m){\\n            return 0;\\n        }\\n        if(memo[row][col]!=null){\\n            return (int)memo[row][col];\\n        }\\n\\n        int[] dir = new int[]{-1,0,1};\\n        int min=Integer.MAX_VALUE;\\n        for(int i : dir){\\n            min=Math.min(min,fall(matrix,memo,row+1,col+i));\\n        }\\n        memo[row][col] = min+matrix[row][col]; \\n        return min+matrix[row][col];\\n    }\\n}\\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Hint: basically like yesterday\\'s but 2D"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "just use recursion with cache or memoize to avoid duplicate computation"
                    },
                    {
                        "username": "saanchijain",
                        "content": "as in example given testcase matrix1, output is given 13, but minimum sum can be 12 =1+4+7"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "Movement is allowed only linearly or diagonally. 4 to 7 movement is not possible."
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "if you know about n queen problem then you can solve this "
                    },
                    {
                        "username": "akashvdubey",
                        "content": "How is this related with n queen, I don\\'t see any back tracking ?"
                    },
                    {
                        "username": "klu_2100030586",
                        "content": "ans = Math.min(ans, minFallingPathSum(A, 0, i, dp));\\n        "
                    },
                    {
                        "username": "R_Prajwal",
                        "content": "But i am just following backtracking and analysing every possible path and updating the value of ans but it is not reflecting\\n"
                    },
                    {
                        "username": "R_Prajwal",
                        "content": "Can anyone Please Explain why value of \"ans\" is not getting updated.\\n(Python) `def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        n=len(matrix)\\n        ans=100000   \\n        \\n        def recurse(row,col,path,n,ans):\\n            if row==n:\\n                if path<ans:\\n                    \\n                    ans=int(path)\\n                    \\n                return    \\n\\n            if col==n or col<0 or row==n or row<0:\\n                \\n                \\n                return\\n            path+=matrix[row][col]\\n               \\n            directions=((1,-1),(1,0),(1,1))   \\n            for x,y in directions:\\n                recurse(row+x,col+y,path,n,ans)\\n            path-=matrix[row][col]    \\n\\n\\n       \\n        for j in range(n):\\n            recurse(0,j,0,n,ans)\\n        return ans`\\n"
                    },
                    {
                        "username": "Deetav",
                        "content": "`Line 1034: Char 34: runtime error: addition of unsigned offset to 0x6020000001b0 overflowed to 0x6020000001ac (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34`\\n\\nwhere do i find line 1034, my code has only 26 lines :("
                    },
                    {
                        "username": "gabhinav",
                        "content": "maybe you are trying to access something like dp[-1][1] as or you have defined max size of dp like dp[max] but you are trying to access dp[max+1] which has lead to overflow."
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "you can keep some thing like cout << \"ok\" in one line and keep running and change the position of cout line . at a point you cann't see ok is printed there you have the problem"
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "That maybe because of the access of undefined memory. Maybe the code is accessing the outside of the matrix. Its the error message when you miss the out of bounds check condition."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because your solution is wrapped by some code you do not have access. LC uses this wrapper to make their job easier i think. In this case the failure trace is not helpful for sure, but from your trace message it means some addition has overflowed and you should start by checking additions in your code"
                    }
                ]
            },
            {
                "id": 1714940,
                "content": [
                    {
                        "username": "ujjwal1234",
                        "content": "class Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        vector <int>v;\\n        int sum=0;\\n        int a;\\n        int i=0;\\n        int k=0;\\n        while (k<matrix.size()-1)\\n        {\\n            for (int j=0;j<matrix[0].size();j++)\\n            {\\n                if (j>0 &&j<matrix[0].size()-1)\\n                {\\n        matrix[i][j]+= min(matrix[k+1][j],min(matrix[k+1][j-1],matrix[k+1][j+1]));\\n                }\\n                else if (j==0)\\n                {\\n                     matrix[i][j]+=min(matrix[k+1][j],matrix[k+1][j+1]);\\n                }\\n                 else \\n                 {\\n                     matrix[i][j]+=min(matrix[k+1][j],matrix[k+1][j-1]);\\n                 }\\n            }\\n        k++;\\n    }\\n        \\n         \\n        int min=matrix[0][0];\\n        for (int i=0;i<matrix[0].size();i++)\\n        {\\n            if (min>matrix[0][i])\\n                min=matrix[0][i];\\n        }\\n        return min;\\n        \\n            \\n               \\n\\n    }\\n};\\n\\n\\nMy testcase [[2,1,3],[6,5,4],[7,8,9]] is not getting passed, i m getting 12 the output should be 13. Please help;\\n"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "[@ironblade](/ironblade) Hey, can you please tell how to fix this"
                    },
                    {
                        "username": "ironblade",
                        "content": "ur soln shows minimum path of whole matriix its not following the neighbour nodes"
                    },
                    {
                        "username": "dhakad22klx",
                        "content": "I am getting TLE at 43/44.Can someone tell how to resolve if you have gone through same."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "same with me\\n"
                    },
                    {
                        "username": "Umang3172",
                        "content": "Why is it so slow?? \\nPls help\\nclass Solution {\\n    int m,n;\\n    public int minFallingPathSum(int[][] matrix) {\\n        m=matrix.length;\\n        n=matrix[0].length;\\n\\n        int res=Integer.MAX_VALUE;\\n        for(int i=0;i<n;i++){\\n            res=Math.min(res,fall(matrix,new Integer[m][n],0,i));\\n        }\\n        return res;\\n    }\\n\\n    public int fall(int[][] matrix, Integer[][] memo, int row, int col){\\n        if(col<0 || col>=n){\\n            return Integer.MAX_VALUE;\\n        }\\n        if(row==m){\\n            return 0;\\n        }\\n        if(memo[row][col]!=null){\\n            return (int)memo[row][col];\\n        }\\n\\n        int[] dir = new int[]{-1,0,1};\\n        int min=Integer.MAX_VALUE;\\n        for(int i : dir){\\n            min=Math.min(min,fall(matrix,memo,row+1,col+i));\\n        }\\n        memo[row][col] = min+matrix[row][col]; \\n        return min+matrix[row][col];\\n    }\\n}\\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Hint: basically like yesterday\\'s but 2D"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "just use recursion with cache or memoize to avoid duplicate computation"
                    },
                    {
                        "username": "saanchijain",
                        "content": "as in example given testcase matrix1, output is given 13, but minimum sum can be 12 =1+4+7"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "Movement is allowed only linearly or diagonally. 4 to 7 movement is not possible."
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "if you know about n queen problem then you can solve this "
                    },
                    {
                        "username": "akashvdubey",
                        "content": "How is this related with n queen, I don\\'t see any back tracking ?"
                    },
                    {
                        "username": "klu_2100030586",
                        "content": "ans = Math.min(ans, minFallingPathSum(A, 0, i, dp));\\n        "
                    },
                    {
                        "username": "R_Prajwal",
                        "content": "But i am just following backtracking and analysing every possible path and updating the value of ans but it is not reflecting\\n"
                    },
                    {
                        "username": "R_Prajwal",
                        "content": "Can anyone Please Explain why value of \"ans\" is not getting updated.\\n(Python) `def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        n=len(matrix)\\n        ans=100000   \\n        \\n        def recurse(row,col,path,n,ans):\\n            if row==n:\\n                if path<ans:\\n                    \\n                    ans=int(path)\\n                    \\n                return    \\n\\n            if col==n or col<0 or row==n or row<0:\\n                \\n                \\n                return\\n            path+=matrix[row][col]\\n               \\n            directions=((1,-1),(1,0),(1,1))   \\n            for x,y in directions:\\n                recurse(row+x,col+y,path,n,ans)\\n            path-=matrix[row][col]    \\n\\n\\n       \\n        for j in range(n):\\n            recurse(0,j,0,n,ans)\\n        return ans`\\n"
                    },
                    {
                        "username": "Deetav",
                        "content": "`Line 1034: Char 34: runtime error: addition of unsigned offset to 0x6020000001b0 overflowed to 0x6020000001ac (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34`\\n\\nwhere do i find line 1034, my code has only 26 lines :("
                    },
                    {
                        "username": "gabhinav",
                        "content": "maybe you are trying to access something like dp[-1][1] as or you have defined max size of dp like dp[max] but you are trying to access dp[max+1] which has lead to overflow."
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "you can keep some thing like cout << \"ok\" in one line and keep running and change the position of cout line . at a point you cann't see ok is printed there you have the problem"
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "That maybe because of the access of undefined memory. Maybe the code is accessing the outside of the matrix. Its the error message when you miss the out of bounds check condition."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because your solution is wrapped by some code you do not have access. LC uses this wrapper to make their job easier i think. In this case the failure trace is not helpful for sure, but from your trace message it means some addition has overflowed and you should start by checking additions in your code"
                    }
                ]
            },
            {
                "id": 1714889,
                "content": [
                    {
                        "username": "ujjwal1234",
                        "content": "class Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        vector <int>v;\\n        int sum=0;\\n        int a;\\n        int i=0;\\n        int k=0;\\n        while (k<matrix.size()-1)\\n        {\\n            for (int j=0;j<matrix[0].size();j++)\\n            {\\n                if (j>0 &&j<matrix[0].size()-1)\\n                {\\n        matrix[i][j]+= min(matrix[k+1][j],min(matrix[k+1][j-1],matrix[k+1][j+1]));\\n                }\\n                else if (j==0)\\n                {\\n                     matrix[i][j]+=min(matrix[k+1][j],matrix[k+1][j+1]);\\n                }\\n                 else \\n                 {\\n                     matrix[i][j]+=min(matrix[k+1][j],matrix[k+1][j-1]);\\n                 }\\n            }\\n        k++;\\n    }\\n        \\n         \\n        int min=matrix[0][0];\\n        for (int i=0;i<matrix[0].size();i++)\\n        {\\n            if (min>matrix[0][i])\\n                min=matrix[0][i];\\n        }\\n        return min;\\n        \\n            \\n               \\n\\n    }\\n};\\n\\n\\nMy testcase [[2,1,3],[6,5,4],[7,8,9]] is not getting passed, i m getting 12 the output should be 13. Please help;\\n"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "[@ironblade](/ironblade) Hey, can you please tell how to fix this"
                    },
                    {
                        "username": "ironblade",
                        "content": "ur soln shows minimum path of whole matriix its not following the neighbour nodes"
                    },
                    {
                        "username": "dhakad22klx",
                        "content": "I am getting TLE at 43/44.Can someone tell how to resolve if you have gone through same."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "same with me\\n"
                    },
                    {
                        "username": "Umang3172",
                        "content": "Why is it so slow?? \\nPls help\\nclass Solution {\\n    int m,n;\\n    public int minFallingPathSum(int[][] matrix) {\\n        m=matrix.length;\\n        n=matrix[0].length;\\n\\n        int res=Integer.MAX_VALUE;\\n        for(int i=0;i<n;i++){\\n            res=Math.min(res,fall(matrix,new Integer[m][n],0,i));\\n        }\\n        return res;\\n    }\\n\\n    public int fall(int[][] matrix, Integer[][] memo, int row, int col){\\n        if(col<0 || col>=n){\\n            return Integer.MAX_VALUE;\\n        }\\n        if(row==m){\\n            return 0;\\n        }\\n        if(memo[row][col]!=null){\\n            return (int)memo[row][col];\\n        }\\n\\n        int[] dir = new int[]{-1,0,1};\\n        int min=Integer.MAX_VALUE;\\n        for(int i : dir){\\n            min=Math.min(min,fall(matrix,memo,row+1,col+i));\\n        }\\n        memo[row][col] = min+matrix[row][col]; \\n        return min+matrix[row][col];\\n    }\\n}\\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Hint: basically like yesterday\\'s but 2D"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "just use recursion with cache or memoize to avoid duplicate computation"
                    },
                    {
                        "username": "saanchijain",
                        "content": "as in example given testcase matrix1, output is given 13, but minimum sum can be 12 =1+4+7"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "Movement is allowed only linearly or diagonally. 4 to 7 movement is not possible."
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "if you know about n queen problem then you can solve this "
                    },
                    {
                        "username": "akashvdubey",
                        "content": "How is this related with n queen, I don\\'t see any back tracking ?"
                    },
                    {
                        "username": "klu_2100030586",
                        "content": "ans = Math.min(ans, minFallingPathSum(A, 0, i, dp));\\n        "
                    },
                    {
                        "username": "R_Prajwal",
                        "content": "But i am just following backtracking and analysing every possible path and updating the value of ans but it is not reflecting\\n"
                    },
                    {
                        "username": "R_Prajwal",
                        "content": "Can anyone Please Explain why value of \"ans\" is not getting updated.\\n(Python) `def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        n=len(matrix)\\n        ans=100000   \\n        \\n        def recurse(row,col,path,n,ans):\\n            if row==n:\\n                if path<ans:\\n                    \\n                    ans=int(path)\\n                    \\n                return    \\n\\n            if col==n or col<0 or row==n or row<0:\\n                \\n                \\n                return\\n            path+=matrix[row][col]\\n               \\n            directions=((1,-1),(1,0),(1,1))   \\n            for x,y in directions:\\n                recurse(row+x,col+y,path,n,ans)\\n            path-=matrix[row][col]    \\n\\n\\n       \\n        for j in range(n):\\n            recurse(0,j,0,n,ans)\\n        return ans`\\n"
                    },
                    {
                        "username": "Deetav",
                        "content": "`Line 1034: Char 34: runtime error: addition of unsigned offset to 0x6020000001b0 overflowed to 0x6020000001ac (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34`\\n\\nwhere do i find line 1034, my code has only 26 lines :("
                    },
                    {
                        "username": "gabhinav",
                        "content": "maybe you are trying to access something like dp[-1][1] as or you have defined max size of dp like dp[max] but you are trying to access dp[max+1] which has lead to overflow."
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "you can keep some thing like cout << \"ok\" in one line and keep running and change the position of cout line . at a point you cann't see ok is printed there you have the problem"
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "That maybe because of the access of undefined memory. Maybe the code is accessing the outside of the matrix. Its the error message when you miss the out of bounds check condition."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because your solution is wrapped by some code you do not have access. LC uses this wrapper to make their job easier i think. In this case the failure trace is not helpful for sure, but from your trace message it means some addition has overflowed and you should start by checking additions in your code"
                    }
                ]
            },
            {
                "id": 1714875,
                "content": [
                    {
                        "username": "ujjwal1234",
                        "content": "class Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        vector <int>v;\\n        int sum=0;\\n        int a;\\n        int i=0;\\n        int k=0;\\n        while (k<matrix.size()-1)\\n        {\\n            for (int j=0;j<matrix[0].size();j++)\\n            {\\n                if (j>0 &&j<matrix[0].size()-1)\\n                {\\n        matrix[i][j]+= min(matrix[k+1][j],min(matrix[k+1][j-1],matrix[k+1][j+1]));\\n                }\\n                else if (j==0)\\n                {\\n                     matrix[i][j]+=min(matrix[k+1][j],matrix[k+1][j+1]);\\n                }\\n                 else \\n                 {\\n                     matrix[i][j]+=min(matrix[k+1][j],matrix[k+1][j-1]);\\n                 }\\n            }\\n        k++;\\n    }\\n        \\n         \\n        int min=matrix[0][0];\\n        for (int i=0;i<matrix[0].size();i++)\\n        {\\n            if (min>matrix[0][i])\\n                min=matrix[0][i];\\n        }\\n        return min;\\n        \\n            \\n               \\n\\n    }\\n};\\n\\n\\nMy testcase [[2,1,3],[6,5,4],[7,8,9]] is not getting passed, i m getting 12 the output should be 13. Please help;\\n"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "[@ironblade](/ironblade) Hey, can you please tell how to fix this"
                    },
                    {
                        "username": "ironblade",
                        "content": "ur soln shows minimum path of whole matriix its not following the neighbour nodes"
                    },
                    {
                        "username": "dhakad22klx",
                        "content": "I am getting TLE at 43/44.Can someone tell how to resolve if you have gone through same."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "same with me\\n"
                    },
                    {
                        "username": "Umang3172",
                        "content": "Why is it so slow?? \\nPls help\\nclass Solution {\\n    int m,n;\\n    public int minFallingPathSum(int[][] matrix) {\\n        m=matrix.length;\\n        n=matrix[0].length;\\n\\n        int res=Integer.MAX_VALUE;\\n        for(int i=0;i<n;i++){\\n            res=Math.min(res,fall(matrix,new Integer[m][n],0,i));\\n        }\\n        return res;\\n    }\\n\\n    public int fall(int[][] matrix, Integer[][] memo, int row, int col){\\n        if(col<0 || col>=n){\\n            return Integer.MAX_VALUE;\\n        }\\n        if(row==m){\\n            return 0;\\n        }\\n        if(memo[row][col]!=null){\\n            return (int)memo[row][col];\\n        }\\n\\n        int[] dir = new int[]{-1,0,1};\\n        int min=Integer.MAX_VALUE;\\n        for(int i : dir){\\n            min=Math.min(min,fall(matrix,memo,row+1,col+i));\\n        }\\n        memo[row][col] = min+matrix[row][col]; \\n        return min+matrix[row][col];\\n    }\\n}\\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Hint: basically like yesterday\\'s but 2D"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "just use recursion with cache or memoize to avoid duplicate computation"
                    },
                    {
                        "username": "saanchijain",
                        "content": "as in example given testcase matrix1, output is given 13, but minimum sum can be 12 =1+4+7"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "Movement is allowed only linearly or diagonally. 4 to 7 movement is not possible."
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "if you know about n queen problem then you can solve this "
                    },
                    {
                        "username": "akashvdubey",
                        "content": "How is this related with n queen, I don\\'t see any back tracking ?"
                    },
                    {
                        "username": "klu_2100030586",
                        "content": "ans = Math.min(ans, minFallingPathSum(A, 0, i, dp));\\n        "
                    },
                    {
                        "username": "R_Prajwal",
                        "content": "But i am just following backtracking and analysing every possible path and updating the value of ans but it is not reflecting\\n"
                    },
                    {
                        "username": "R_Prajwal",
                        "content": "Can anyone Please Explain why value of \"ans\" is not getting updated.\\n(Python) `def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        n=len(matrix)\\n        ans=100000   \\n        \\n        def recurse(row,col,path,n,ans):\\n            if row==n:\\n                if path<ans:\\n                    \\n                    ans=int(path)\\n                    \\n                return    \\n\\n            if col==n or col<0 or row==n or row<0:\\n                \\n                \\n                return\\n            path+=matrix[row][col]\\n               \\n            directions=((1,-1),(1,0),(1,1))   \\n            for x,y in directions:\\n                recurse(row+x,col+y,path,n,ans)\\n            path-=matrix[row][col]    \\n\\n\\n       \\n        for j in range(n):\\n            recurse(0,j,0,n,ans)\\n        return ans`\\n"
                    },
                    {
                        "username": "Deetav",
                        "content": "`Line 1034: Char 34: runtime error: addition of unsigned offset to 0x6020000001b0 overflowed to 0x6020000001ac (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34`\\n\\nwhere do i find line 1034, my code has only 26 lines :("
                    },
                    {
                        "username": "gabhinav",
                        "content": "maybe you are trying to access something like dp[-1][1] as or you have defined max size of dp like dp[max] but you are trying to access dp[max+1] which has lead to overflow."
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "you can keep some thing like cout << \"ok\" in one line and keep running and change the position of cout line . at a point you cann't see ok is printed there you have the problem"
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "That maybe because of the access of undefined memory. Maybe the code is accessing the outside of the matrix. Its the error message when you miss the out of bounds check condition."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because your solution is wrapped by some code you do not have access. LC uses this wrapper to make their job easier i think. In this case the failure trace is not helpful for sure, but from your trace message it means some addition has overflowed and you should start by checking additions in your code"
                    }
                ]
            },
            {
                "id": 1714824,
                "content": [
                    {
                        "username": "ujjwal1234",
                        "content": "class Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        vector <int>v;\\n        int sum=0;\\n        int a;\\n        int i=0;\\n        int k=0;\\n        while (k<matrix.size()-1)\\n        {\\n            for (int j=0;j<matrix[0].size();j++)\\n            {\\n                if (j>0 &&j<matrix[0].size()-1)\\n                {\\n        matrix[i][j]+= min(matrix[k+1][j],min(matrix[k+1][j-1],matrix[k+1][j+1]));\\n                }\\n                else if (j==0)\\n                {\\n                     matrix[i][j]+=min(matrix[k+1][j],matrix[k+1][j+1]);\\n                }\\n                 else \\n                 {\\n                     matrix[i][j]+=min(matrix[k+1][j],matrix[k+1][j-1]);\\n                 }\\n            }\\n        k++;\\n    }\\n        \\n         \\n        int min=matrix[0][0];\\n        for (int i=0;i<matrix[0].size();i++)\\n        {\\n            if (min>matrix[0][i])\\n                min=matrix[0][i];\\n        }\\n        return min;\\n        \\n            \\n               \\n\\n    }\\n};\\n\\n\\nMy testcase [[2,1,3],[6,5,4],[7,8,9]] is not getting passed, i m getting 12 the output should be 13. Please help;\\n"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "[@ironblade](/ironblade) Hey, can you please tell how to fix this"
                    },
                    {
                        "username": "ironblade",
                        "content": "ur soln shows minimum path of whole matriix its not following the neighbour nodes"
                    },
                    {
                        "username": "dhakad22klx",
                        "content": "I am getting TLE at 43/44.Can someone tell how to resolve if you have gone through same."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "same with me\\n"
                    },
                    {
                        "username": "Umang3172",
                        "content": "Why is it so slow?? \\nPls help\\nclass Solution {\\n    int m,n;\\n    public int minFallingPathSum(int[][] matrix) {\\n        m=matrix.length;\\n        n=matrix[0].length;\\n\\n        int res=Integer.MAX_VALUE;\\n        for(int i=0;i<n;i++){\\n            res=Math.min(res,fall(matrix,new Integer[m][n],0,i));\\n        }\\n        return res;\\n    }\\n\\n    public int fall(int[][] matrix, Integer[][] memo, int row, int col){\\n        if(col<0 || col>=n){\\n            return Integer.MAX_VALUE;\\n        }\\n        if(row==m){\\n            return 0;\\n        }\\n        if(memo[row][col]!=null){\\n            return (int)memo[row][col];\\n        }\\n\\n        int[] dir = new int[]{-1,0,1};\\n        int min=Integer.MAX_VALUE;\\n        for(int i : dir){\\n            min=Math.min(min,fall(matrix,memo,row+1,col+i));\\n        }\\n        memo[row][col] = min+matrix[row][col]; \\n        return min+matrix[row][col];\\n    }\\n}\\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Hint: basically like yesterday\\'s but 2D"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "just use recursion with cache or memoize to avoid duplicate computation"
                    },
                    {
                        "username": "saanchijain",
                        "content": "as in example given testcase matrix1, output is given 13, but minimum sum can be 12 =1+4+7"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "Movement is allowed only linearly or diagonally. 4 to 7 movement is not possible."
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "if you know about n queen problem then you can solve this "
                    },
                    {
                        "username": "akashvdubey",
                        "content": "How is this related with n queen, I don\\'t see any back tracking ?"
                    },
                    {
                        "username": "klu_2100030586",
                        "content": "ans = Math.min(ans, minFallingPathSum(A, 0, i, dp));\\n        "
                    },
                    {
                        "username": "R_Prajwal",
                        "content": "But i am just following backtracking and analysing every possible path and updating the value of ans but it is not reflecting\\n"
                    },
                    {
                        "username": "R_Prajwal",
                        "content": "Can anyone Please Explain why value of \"ans\" is not getting updated.\\n(Python) `def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        n=len(matrix)\\n        ans=100000   \\n        \\n        def recurse(row,col,path,n,ans):\\n            if row==n:\\n                if path<ans:\\n                    \\n                    ans=int(path)\\n                    \\n                return    \\n\\n            if col==n or col<0 or row==n or row<0:\\n                \\n                \\n                return\\n            path+=matrix[row][col]\\n               \\n            directions=((1,-1),(1,0),(1,1))   \\n            for x,y in directions:\\n                recurse(row+x,col+y,path,n,ans)\\n            path-=matrix[row][col]    \\n\\n\\n       \\n        for j in range(n):\\n            recurse(0,j,0,n,ans)\\n        return ans`\\n"
                    },
                    {
                        "username": "Deetav",
                        "content": "`Line 1034: Char 34: runtime error: addition of unsigned offset to 0x6020000001b0 overflowed to 0x6020000001ac (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34`\\n\\nwhere do i find line 1034, my code has only 26 lines :("
                    },
                    {
                        "username": "gabhinav",
                        "content": "maybe you are trying to access something like dp[-1][1] as or you have defined max size of dp like dp[max] but you are trying to access dp[max+1] which has lead to overflow."
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "you can keep some thing like cout << \"ok\" in one line and keep running and change the position of cout line . at a point you cann't see ok is printed there you have the problem"
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "That maybe because of the access of undefined memory. Maybe the code is accessing the outside of the matrix. Its the error message when you miss the out of bounds check condition."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because your solution is wrapped by some code you do not have access. LC uses this wrapper to make their job easier i think. In this case the failure trace is not helpful for sure, but from your trace message it means some addition has overflowed and you should start by checking additions in your code"
                    }
                ]
            },
            {
                "id": 1714820,
                "content": [
                    {
                        "username": "ujjwal1234",
                        "content": "class Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        vector <int>v;\\n        int sum=0;\\n        int a;\\n        int i=0;\\n        int k=0;\\n        while (k<matrix.size()-1)\\n        {\\n            for (int j=0;j<matrix[0].size();j++)\\n            {\\n                if (j>0 &&j<matrix[0].size()-1)\\n                {\\n        matrix[i][j]+= min(matrix[k+1][j],min(matrix[k+1][j-1],matrix[k+1][j+1]));\\n                }\\n                else if (j==0)\\n                {\\n                     matrix[i][j]+=min(matrix[k+1][j],matrix[k+1][j+1]);\\n                }\\n                 else \\n                 {\\n                     matrix[i][j]+=min(matrix[k+1][j],matrix[k+1][j-1]);\\n                 }\\n            }\\n        k++;\\n    }\\n        \\n         \\n        int min=matrix[0][0];\\n        for (int i=0;i<matrix[0].size();i++)\\n        {\\n            if (min>matrix[0][i])\\n                min=matrix[0][i];\\n        }\\n        return min;\\n        \\n            \\n               \\n\\n    }\\n};\\n\\n\\nMy testcase [[2,1,3],[6,5,4],[7,8,9]] is not getting passed, i m getting 12 the output should be 13. Please help;\\n"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "[@ironblade](/ironblade) Hey, can you please tell how to fix this"
                    },
                    {
                        "username": "ironblade",
                        "content": "ur soln shows minimum path of whole matriix its not following the neighbour nodes"
                    },
                    {
                        "username": "dhakad22klx",
                        "content": "I am getting TLE at 43/44.Can someone tell how to resolve if you have gone through same."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "same with me\\n"
                    },
                    {
                        "username": "Umang3172",
                        "content": "Why is it so slow?? \\nPls help\\nclass Solution {\\n    int m,n;\\n    public int minFallingPathSum(int[][] matrix) {\\n        m=matrix.length;\\n        n=matrix[0].length;\\n\\n        int res=Integer.MAX_VALUE;\\n        for(int i=0;i<n;i++){\\n            res=Math.min(res,fall(matrix,new Integer[m][n],0,i));\\n        }\\n        return res;\\n    }\\n\\n    public int fall(int[][] matrix, Integer[][] memo, int row, int col){\\n        if(col<0 || col>=n){\\n            return Integer.MAX_VALUE;\\n        }\\n        if(row==m){\\n            return 0;\\n        }\\n        if(memo[row][col]!=null){\\n            return (int)memo[row][col];\\n        }\\n\\n        int[] dir = new int[]{-1,0,1};\\n        int min=Integer.MAX_VALUE;\\n        for(int i : dir){\\n            min=Math.min(min,fall(matrix,memo,row+1,col+i));\\n        }\\n        memo[row][col] = min+matrix[row][col]; \\n        return min+matrix[row][col];\\n    }\\n}\\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Hint: basically like yesterday\\'s but 2D"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "just use recursion with cache or memoize to avoid duplicate computation"
                    },
                    {
                        "username": "saanchijain",
                        "content": "as in example given testcase matrix1, output is given 13, but minimum sum can be 12 =1+4+7"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "Movement is allowed only linearly or diagonally. 4 to 7 movement is not possible."
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "if you know about n queen problem then you can solve this "
                    },
                    {
                        "username": "akashvdubey",
                        "content": "How is this related with n queen, I don\\'t see any back tracking ?"
                    },
                    {
                        "username": "klu_2100030586",
                        "content": "ans = Math.min(ans, minFallingPathSum(A, 0, i, dp));\\n        "
                    },
                    {
                        "username": "R_Prajwal",
                        "content": "But i am just following backtracking and analysing every possible path and updating the value of ans but it is not reflecting\\n"
                    },
                    {
                        "username": "R_Prajwal",
                        "content": "Can anyone Please Explain why value of \"ans\" is not getting updated.\\n(Python) `def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        n=len(matrix)\\n        ans=100000   \\n        \\n        def recurse(row,col,path,n,ans):\\n            if row==n:\\n                if path<ans:\\n                    \\n                    ans=int(path)\\n                    \\n                return    \\n\\n            if col==n or col<0 or row==n or row<0:\\n                \\n                \\n                return\\n            path+=matrix[row][col]\\n               \\n            directions=((1,-1),(1,0),(1,1))   \\n            for x,y in directions:\\n                recurse(row+x,col+y,path,n,ans)\\n            path-=matrix[row][col]    \\n\\n\\n       \\n        for j in range(n):\\n            recurse(0,j,0,n,ans)\\n        return ans`\\n"
                    },
                    {
                        "username": "Deetav",
                        "content": "`Line 1034: Char 34: runtime error: addition of unsigned offset to 0x6020000001b0 overflowed to 0x6020000001ac (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34`\\n\\nwhere do i find line 1034, my code has only 26 lines :("
                    },
                    {
                        "username": "gabhinav",
                        "content": "maybe you are trying to access something like dp[-1][1] as or you have defined max size of dp like dp[max] but you are trying to access dp[max+1] which has lead to overflow."
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "you can keep some thing like cout << \"ok\" in one line and keep running and change the position of cout line . at a point you cann't see ok is printed there you have the problem"
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "That maybe because of the access of undefined memory. Maybe the code is accessing the outside of the matrix. Its the error message when you miss the out of bounds check condition."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because your solution is wrapped by some code you do not have access. LC uses this wrapper to make their job easier i think. In this case the failure trace is not helpful for sure, but from your trace message it means some addition has overflowed and you should start by checking additions in your code"
                    }
                ]
            },
            {
                "id": 1714712,
                "content": [
                    {
                        "username": "ujjwal1234",
                        "content": "class Solution {\\npublic:\\n    int minFallingPathSum(vector<vector<int>>& matrix) {\\n        vector <int>v;\\n        int sum=0;\\n        int a;\\n        int i=0;\\n        int k=0;\\n        while (k<matrix.size()-1)\\n        {\\n            for (int j=0;j<matrix[0].size();j++)\\n            {\\n                if (j>0 &&j<matrix[0].size()-1)\\n                {\\n        matrix[i][j]+= min(matrix[k+1][j],min(matrix[k+1][j-1],matrix[k+1][j+1]));\\n                }\\n                else if (j==0)\\n                {\\n                     matrix[i][j]+=min(matrix[k+1][j],matrix[k+1][j+1]);\\n                }\\n                 else \\n                 {\\n                     matrix[i][j]+=min(matrix[k+1][j],matrix[k+1][j-1]);\\n                 }\\n            }\\n        k++;\\n    }\\n        \\n         \\n        int min=matrix[0][0];\\n        for (int i=0;i<matrix[0].size();i++)\\n        {\\n            if (min>matrix[0][i])\\n                min=matrix[0][i];\\n        }\\n        return min;\\n        \\n            \\n               \\n\\n    }\\n};\\n\\n\\nMy testcase [[2,1,3],[6,5,4],[7,8,9]] is not getting passed, i m getting 12 the output should be 13. Please help;\\n"
                    },
                    {
                        "username": "ujjwal1234",
                        "content": "[@ironblade](/ironblade) Hey, can you please tell how to fix this"
                    },
                    {
                        "username": "ironblade",
                        "content": "ur soln shows minimum path of whole matriix its not following the neighbour nodes"
                    },
                    {
                        "username": "dhakad22klx",
                        "content": "I am getting TLE at 43/44.Can someone tell how to resolve if you have gone through same."
                    },
                    {
                        "username": "gaurav_rawat369",
                        "content": "same with me\\n"
                    },
                    {
                        "username": "Umang3172",
                        "content": "Why is it so slow?? \\nPls help\\nclass Solution {\\n    int m,n;\\n    public int minFallingPathSum(int[][] matrix) {\\n        m=matrix.length;\\n        n=matrix[0].length;\\n\\n        int res=Integer.MAX_VALUE;\\n        for(int i=0;i<n;i++){\\n            res=Math.min(res,fall(matrix,new Integer[m][n],0,i));\\n        }\\n        return res;\\n    }\\n\\n    public int fall(int[][] matrix, Integer[][] memo, int row, int col){\\n        if(col<0 || col>=n){\\n            return Integer.MAX_VALUE;\\n        }\\n        if(row==m){\\n            return 0;\\n        }\\n        if(memo[row][col]!=null){\\n            return (int)memo[row][col];\\n        }\\n\\n        int[] dir = new int[]{-1,0,1};\\n        int min=Integer.MAX_VALUE;\\n        for(int i : dir){\\n            min=Math.min(min,fall(matrix,memo,row+1,col+i));\\n        }\\n        memo[row][col] = min+matrix[row][col]; \\n        return min+matrix[row][col];\\n    }\\n}\\n"
                    },
                    {
                        "username": "eggzdee",
                        "content": "Hint: basically like yesterday\\'s but 2D"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "just use recursion with cache or memoize to avoid duplicate computation"
                    },
                    {
                        "username": "saanchijain",
                        "content": "as in example given testcase matrix1, output is given 13, but minimum sum can be 12 =1+4+7"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "Movement is allowed only linearly or diagonally. 4 to 7 movement is not possible."
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "if you know about n queen problem then you can solve this "
                    },
                    {
                        "username": "akashvdubey",
                        "content": "How is this related with n queen, I don\\'t see any back tracking ?"
                    },
                    {
                        "username": "klu_2100030586",
                        "content": "ans = Math.min(ans, minFallingPathSum(A, 0, i, dp));\\n        "
                    },
                    {
                        "username": "R_Prajwal",
                        "content": "But i am just following backtracking and analysing every possible path and updating the value of ans but it is not reflecting\\n"
                    },
                    {
                        "username": "R_Prajwal",
                        "content": "Can anyone Please Explain why value of \"ans\" is not getting updated.\\n(Python) `def minFallingPathSum(self, matrix: List[List[int]]) -> int:\\n        n=len(matrix)\\n        ans=100000   \\n        \\n        def recurse(row,col,path,n,ans):\\n            if row==n:\\n                if path<ans:\\n                    \\n                    ans=int(path)\\n                    \\n                return    \\n\\n            if col==n or col<0 or row==n or row<0:\\n                \\n                \\n                return\\n            path+=matrix[row][col]\\n               \\n            directions=((1,-1),(1,0),(1,1))   \\n            for x,y in directions:\\n                recurse(row+x,col+y,path,n,ans)\\n            path-=matrix[row][col]    \\n\\n\\n       \\n        for j in range(n):\\n            recurse(0,j,0,n,ans)\\n        return ans`\\n"
                    },
                    {
                        "username": "Deetav",
                        "content": "`Line 1034: Char 34: runtime error: addition of unsigned offset to 0x6020000001b0 overflowed to 0x6020000001ac (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34`\\n\\nwhere do i find line 1034, my code has only 26 lines :("
                    },
                    {
                        "username": "gabhinav",
                        "content": "maybe you are trying to access something like dp[-1][1] as or you have defined max size of dp like dp[max] but you are trying to access dp[max+1] which has lead to overflow."
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "you can keep some thing like cout << \"ok\" in one line and keep running and change the position of cout line . at a point you cann't see ok is printed there you have the problem"
                    },
                    {
                        "username": "ritz-gupta",
                        "content": "That maybe because of the access of undefined memory. Maybe the code is accessing the outside of the matrix. Its the error message when you miss the out of bounds check condition."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Because your solution is wrapped by some code you do not have access. LC uses this wrapper to make their job easier i think. In this case the failure trace is not helpful for sure, but from your trace message it means some addition has overflowed and you should start by checking additions in your code"
                    }
                ]
            }
        ]
    }
]