[
    {
        "title": "Find the Maximum Divisibility Score",
        "question_content": "You are given two 0-indexed integer arrays nums and divisors.\nThe divisibility score of divisors[i] is the number of indices j such that nums[j] is divisible by divisors[i].\nReturn the integer divisors[i] with the maximum divisibility score. If there is more than one integer with the maximum score, return the minimum of them.\n&nbsp;\nExample 1:\n\nInput: nums = [4,7,9,3,9], divisors = [5,2,3]\nOutput: 3\nExplanation: The divisibility score for every element in divisors is:\nThe divisibility score of divisors[0] is 0 since no number in nums is divisible by 5.\nThe divisibility score of divisors[1] is 1 since nums[0] is divisible by 2.\nThe divisibility score of divisors[2] is 3 since nums[2], nums[3], and nums[4] are divisible by 3.\nSince divisors[2] has the maximum divisibility score, we return it.\n\nExample 2:\n\nInput: nums = [20,14,21,10], divisors = [5,7,5]\nOutput: 5\nExplanation: The divisibility score for every element in divisors is:\nThe divisibility score of divisors[0] is 2 since nums[0] and nums[3] are divisible by 5.\nThe divisibility score of divisors[1] is 2 since nums[1] and nums[2] are divisible by 7.\nThe divisibility score of divisors[2] is 2 since nums[0] and nums[3] are divisible by 5.\nSince divisors[0], divisors[1], and divisors[2] all have the maximum divisibility score, we return the minimum of them (i.e., divisors[2]).\n\nExample 3:\n\nInput: nums = [12], divisors = [10,16]\nOutput: 10\nExplanation: The divisibility score for every element in divisors is:\nThe divisibility score of divisors[0] is 0 since no number in nums is divisible by 10.\nThe divisibility score of divisors[1] is 0 since no number in nums is divisible by 16.\nSince divisors[0] and divisors[1] both have the maximum divisibility score, we return the minimum of them (i.e., divisors[0]).\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length, divisors.length <= 1000\n\t1 <= nums[i], divisors[i] <= 109",
        "solutions": [
            {
                "id": 3422204,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "C++\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int ans = -1, mx_cnt = -1;\\n        // for each divisor\\n        for (auto d : divisors) {\\n            int cnt = 0;\\n            // we check each number `x`\\n            for (auto x : nums) {\\n                // to see if `x` can be divisible by `d`\\n                if (x % d == 0) {\\n                    // if so, increase the counter by 1\\n                    cnt += 1;\\n                }\\n            }\\n            // if the counter is greater than the current max\\n            if (cnt > mx_cnt) {\\n                // then update hte current max\\n                mx_cnt = cnt;\\n                // `d` will be the possible answer\\n                ans = d;\\n            } else if (cnt == mx_cnt) {\\n                // however, if the counter is same as the current max\\n                // then we need to take the min one\\n                ans = min(ans, d);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nPython\\n\\n```py\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        res = -1\\n        mx_cnt = -1\\n        # for each divisor\\n        for d in divisors:\\n            cnt = 0\\n            # we check each number `x`\\n            for x in nums:\\n                # to see if `x` can be divisible by `d`\\n                if x % d == 0:\\n                    # if so, increase the counter by 1\\n                    cnt += 1\\n            # if the counter is greater than the current max\\n            if cnt > mx_cnt:\\n                # then update hte current max\\n                mx_cnt = cnt\\n                # `d` will be the possible answer\\n                res = d\\n            elif cnt == mx_cnt:\\n                # however, if the counter is same as the current max\\n                # then we need to take the min one\\n                res = min(res, d)\\n        return res\\n```",
                "solutionTags": [
                    "C++",
                    "Python"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int ans = -1, mx_cnt = -1;\\n        // for each divisor\\n        for (auto d : divisors) {\\n            int cnt = 0;\\n            // we check each number `x`\\n            for (auto x : nums) {\\n                // to see if `x` can be divisible by `d`\\n                if (x % d == 0) {\\n                    // if so, increase the counter by 1\\n                    cnt += 1;\\n                }\\n            }\\n            // if the counter is greater than the current max\\n            if (cnt > mx_cnt) {\\n                // then update hte current max\\n                mx_cnt = cnt;\\n                // `d` will be the possible answer\\n                ans = d;\\n            } else if (cnt == mx_cnt) {\\n                // however, if the counter is same as the current max\\n                // then we need to take the min one\\n                ans = min(ans, d);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```py\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        res = -1\\n        mx_cnt = -1\\n        # for each divisor\\n        for d in divisors:\\n            cnt = 0\\n            # we check each number `x`\\n            for x in nums:\\n                # to see if `x` can be divisible by `d`\\n                if x % d == 0:\\n                    # if so, increase the counter by 1\\n                    cnt += 1\\n            # if the counter is greater than the current max\\n            if cnt > mx_cnt:\\n                # then update hte current max\\n                mx_cnt = cnt\\n                # `d` will be the possible answer\\n                res = d\\n            elif cnt == mx_cnt:\\n                # however, if the counter is same as the current max\\n                # then we need to take the min one\\n                res = min(res, d)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421736,
                "title": "clean-simple-java-solution",
                "content": "\\n```java []\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        Arrays.sort(divisors);\\n        int max = 0, res = divisors[0];\\n        for(int i=0; i<divisors.length; i++){\\n            int cnt = 0;\\n            for(int j=0; j<nums.length; j++){\\n                if(nums[j] % divisors[i] == 0)  cnt++;\\n            }\\n            if(cnt > max){\\n                max = cnt;\\n                res = divisors[i];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        Arrays.sort(divisors);\\n        int max = 0, res = divisors[0];\\n        for(int i=0; i<divisors.length; i++){\\n            int cnt = 0;\\n            for(int j=0; j<nums.length; j++){\\n                if(nums[j] % divisors[i] == 0)  cnt++;\\n            }\\n            if(cnt > max){\\n                max = cnt;\\n                res = divisors[i];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421687,
                "title": "c-bruteforce",
                "content": "**Approach Brute Force**\\n**Count number of perfect dividend and update the answer**\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int res = 0, curr = -1;\\n        for(auto &d: divisors){\\n            int score = 0;\\n            for(auto &it: nums)     \\n                score += (it % d == 0);\\n            if(score >= curr){\\n                if(score == curr)       \\n                    res = min(res, d);\\n                else                    \\n                    res = d;                    \\n                curr = score;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int res = 0, curr = -1;\\n        for(auto &d: divisors){\\n            int score = 0;\\n            for(auto &it: nums)     \\n                score += (it % d == 0);\\n            if(score >= curr){\\n                if(score == curr)       \\n                    res = min(res, d);\\n                else                    \\n                    res = d;                    \\n                curr = score;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421912,
                "title": "c-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int maxcount = 0;\\n        int best_divisor = divisors[0];\\n        for (int i = 0; i < divisors.size(); i++) {\\n            int count = 0;\\n            for (int j = 0; j < nums.size(); j++) {\\n                if (nums[j] % divisors[i] == 0) {\\n                    count++;\\n                }\\n            }\\n            if(count==maxcount){\\n               best_divisor = min(best_divisor,divisors[i]);\\n            }\\n            if (count > maxcount) {\\n                maxcount = count;\\n                best_divisor = divisors[i];\\n            }\\n        }\\n        return best_divisor;\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int maxcount = 0;\\n        int best_divisor = divisors[0];\\n        for (int i = 0; i < divisors.size(); i++) {\\n            int count = 0;\\n            for (int j = 0; j < nums.size(); j++) {\\n                if (nums[j] % divisors[i] == 0) {\\n                    count++;\\n                }\\n            }\\n            if(count==maxcount){\\n               best_divisor = min(best_divisor,divisors[i]);\\n            }\\n            if (count > maxcount) {\\n                maxcount = count;\\n                best_divisor = divisors[i];\\n            }\\n        }\\n        return best_divisor;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421672,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(m*n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int max=0,val=0;\\n        for(int i:divisors)\\n        {\\n            int count=0;\\n            for(int j:nums)\\n            {\\n                if(j%i==0)\\n                {\\n                    count++;\\n                }\\n            }\\n            if(count>max)\\n            {\\n                max=count;\\n                val=i;\\n            }\\n            if(count==max && i<val)\\n            {\\n                val=i;\\n            }\\n        }\\n        if(max==0 && val==0)\\n        {\\n            Arrays.sort(divisors);\\n            return divisors[0];\\n        }\\n        return val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int max=0,val=0;\\n        for(int i:divisors)\\n        {\\n            int count=0;\\n            for(int j:nums)\\n            {\\n                if(j%i==0)\\n                {\\n                    count++;\\n                }\\n            }\\n            if(count>max)\\n            {\\n                max=count;\\n                val=i;\\n            }\\n            if(count==max && i<val)\\n            {\\n                val=i;\\n            }\\n        }\\n        if(max==0 && val==0)\\n        {\\n            Arrays.sort(divisors);\\n            return divisors[0];\\n        }\\n        return val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3426856,
                "title": "golang-100-faster-easy-solution",
                "content": "# Code\\u2705\\n```\\nimport (\\n\\t\"sort\"\\n)\\nfunc maxDivScore(nums []int, divisors []int) int {\\n   max := 0\\n   maxDiv := 0\\n   for _, div := range divisors{\\n        currentMax := 0\\n        for _, num := range nums{\\n            if num % div == 0 {\\n                currentMax += 1\\n            } \\n        }\\n        if currentMax == max {\\n            if div < maxDiv {\\n                maxDiv = div\\n            }\\n        } else if currentMax > max {\\n            maxDiv = div\\n            max = currentMax\\n        }\\n   }\\n   \\n   if max == 0 {\\n       sort.Ints(divisors)\\n       return divisors[0] \\n   }\\n   return  maxDiv\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nimport (\\n\\t\"sort\"\\n)\\nfunc maxDivScore(nums []int, divisors []int) int {\\n   max := 0\\n   maxDiv := 0\\n   for _, div := range divisors{\\n        currentMax := 0\\n        for _, num := range nums{\\n            if num % div == 0 {\\n                currentMax += 1\\n            } \\n        }\\n        if currentMax == max {\\n            if div < maxDiv {\\n                maxDiv = div\\n            }\\n        } else if currentMax > max {\\n            maxDiv = div\\n            max = currentMax\\n        }\\n   }\\n   \\n   if max == 0 {\\n       sort.Ints(divisors)\\n       return divisors[0] \\n   }\\n   return  maxDiv\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3426109,
                "title": "one-liner",
                "content": "**Python 3**\\nWe negate the divisor to avoid lambda.\\n\\n```python\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divs: List[int]) -> int:\\n        return -max([sum(n % d == 0 for n in nums), -d] for d in divs)[1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divs: List[int]) -> int:\\n        return -max([sum(n % d == 0 for n in nums), -d] for d in divs)[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422465,
                "title": "c-brute-force",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n * m)$$\\nn = div.size(), m = nums.size()\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& div) {\\n        int count = 0, divisor = 0;\\n        for(int i = 0; i < div.size(); i++) {\\n            int div_count = 0;\\n            for(int j = 0; j < nums.size(); j++) {\\n                if(nums[j] % div[i] == 0) div_count++;\\n            }\\n            if(count == div_count) {\\n                divisor = divisor == 0 ? div[i] : min(divisor, div[i]);\\n            }\\n            else if(div_count > count) {\\n                count = div_count;\\n                divisor = div[i];\\n            }\\n        }\\n        return divisor;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& div) {\\n        int count = 0, divisor = 0;\\n        for(int i = 0; i < div.size(); i++) {\\n            int div_count = 0;\\n            for(int j = 0; j < nums.size(); j++) {\\n                if(nums[j] % div[i] == 0) div_count++;\\n            }\\n            if(count == div_count) {\\n                divisor = divisor == 0 ? div[i] : min(divisor, div[i]);\\n            }\\n            else if(div_count > count) {\\n                count = div_count;\\n                divisor = div[i];\\n            }\\n        }\\n        return divisor;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421776,
                "title": "easy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int dLen = divisors.size(),n=nums.size(),c,maxVal=0,ans=INT_MAX;\\n        \\n        for(int i=0;i<dLen;i++){\\n            c=0;\\n            for(int j=0;j<n;j++){\\n                if(nums[j]%divisors[i] == 0){\\n                    c++;\\n                }\\n            }\\n            if(c==maxVal){\\n                ans = min(ans,divisors[i]);\\n            }\\n            else if(c > maxVal){\\n                maxVal = c;\\n                ans = divisors[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int dLen = divisors.size(),n=nums.size(),c,maxVal=0,ans=INT_MAX;\\n        \\n        for(int i=0;i<dLen;i++){\\n            c=0;\\n            for(int j=0;j<n;j++){\\n                if(nums[j]%divisors[i] == 0){\\n                    c++;\\n                }\\n            }\\n            if(c==maxVal){\\n                ans = min(ans,divisors[i]);\\n            }\\n            else if(c > maxVal){\\n                maxVal = c;\\n                ans = divisors[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442703,
                "title": "simple-python3-beats-91-6-quibler7",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        res = 0 \\n        count = -1\\n        for d in divisors:\\n            curr = sum(1 for i in nums if i%d == 0)\\n            if curr > count:\\n                count = curr\\n                res = d\\n            elif curr == count:\\n                res = min(res, d)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        res = 0 \\n        count = -1\\n        for d in divisors:\\n            curr = sum(1 for i in nums if i%d == 0)\\n            if curr > count:\\n                count = curr\\n                res = d\\n            elif curr == count:\\n                res = min(res, d)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435017,
                "title": "binary-search-java",
                "content": "# Approach\\nSort the nums, given the divisor , find an index that is equals or greater than divisor, then loop through the numbers starting from the index.\\n\\n# Complexity\\n- Time complexity:\\n$$O(DlogN)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    private int binarySearch(int[] nums, int target) {\\n        int i = 0;\\n        int j = nums.length;\\n        while(i < j) {\\n            int mid = i + (j - i) / 2;\\n            if(nums[mid] < target) {\\n                i = mid + 1;\\n            } else {\\n                j = mid;\\n            }\\n        }\\n        return i;\\n    }\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        Arrays.sort(nums);\\n        int max = 0;\\n        int res = divisors[0];\\n        for(int d : divisors) {\\n            int score = 0;\\n            for(int i = binarySearch(nums, d); i < nums.length; ++i) {\\n                if( nums[i] % d == 0) {\\n                    ++score;\\n                }\\n            }\\n            if(score > max) {\\n                max = score;\\n                res = d;\\n            } else if (score == max) {\\n                res = Math.min(res, d);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n### [Optimize] Sort both nums and divisors, and limit the lower bound.\\n\\n```java\\nclass Solution {\\n    private int binarySearch(int[] nums, int target, int lo) {\\n        int hi = nums.length;\\n        while(lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if(nums[mid] < target) {\\n                lo = mid + 1;\\n            } else {\\n                hi = mid;\\n            }\\n        }\\n        return lo;\\n    }\\n\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        Arrays.sort(nums);\\n        Arrays.sort(divisors);\\n        int max = 0;\\n        int res = divisors[0];\\n        int lo = 0;\\n        for(int d : divisors) {\\n            int score = 0;\\n            lo = binarySearch(nums, d, lo);\\n            if(lo >= nums.length) {\\n                break;\\n            }\\n            for(int i = lo; i < nums.length; ++i) {\\n                if( nums[i] % d == 0) {\\n                    ++score;\\n                }\\n            }\\n            if(score > max) {\\n                max = score;\\n                res = d;\\n            } else if (score == max) {\\n                res = Math.min(res, d);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int binarySearch(int[] nums, int target) {\\n        int i = 0;\\n        int j = nums.length;\\n        while(i < j) {\\n            int mid = i + (j - i) / 2;\\n            if(nums[mid] < target) {\\n                i = mid + 1;\\n            } else {\\n                j = mid;\\n            }\\n        }\\n        return i;\\n    }\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        Arrays.sort(nums);\\n        int max = 0;\\n        int res = divisors[0];\\n        for(int d : divisors) {\\n            int score = 0;\\n            for(int i = binarySearch(nums, d); i < nums.length; ++i) {\\n                if( nums[i] % d == 0) {\\n                    ++score;\\n                }\\n            }\\n            if(score > max) {\\n                max = score;\\n                res = d;\\n            } else if (score == max) {\\n                res = Math.min(res, d);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    private int binarySearch(int[] nums, int target, int lo) {\\n        int hi = nums.length;\\n        while(lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if(nums[mid] < target) {\\n                lo = mid + 1;\\n            } else {\\n                hi = mid;\\n            }\\n        }\\n        return lo;\\n    }\\n\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        Arrays.sort(nums);\\n        Arrays.sort(divisors);\\n        int max = 0;\\n        int res = divisors[0];\\n        int lo = 0;\\n        for(int d : divisors) {\\n            int score = 0;\\n            lo = binarySearch(nums, d, lo);\\n            if(lo >= nums.length) {\\n                break;\\n            }\\n            for(int i = lo; i < nums.length; ++i) {\\n                if( nums[i] % d == 0) {\\n                    ++score;\\n                }\\n            }\\n            if(score > max) {\\n                max = score;\\n                res = d;\\n            } else if (score == max) {\\n                res = Math.min(res, d);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3427066,
                "title": "easy-python-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        l=[]\\n        divisors.sort()\\n        for i in divisors:\\n            c=0\\n            for j in nums:\\n                if j%i==0:\\n                    c+=1\\n            l.append(c)\\n        return divisors[l.index(max(l))]\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        l=[]\\n        divisors.sort()\\n        for i in divisors:\\n            c=0\\n            for j in nums:\\n                if j%i==0:\\n                    c+=1\\n            l.append(c)\\n        return divisors[l.index(max(l))]\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478271,
                "title": "easy-faster-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int res = 0, curr = -1;\\n        for(auto &d: divisors){\\n            int score = 0;\\n            for(auto &it: nums)     \\n                score += (it % d == 0);\\n            if(score >= curr){\\n                if(score == curr)       \\n                    res = min(res, d);\\n                else                    \\n                    res = d;                    \\n                curr = score;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int res = 0, curr = -1;\\n        for(auto &d: divisors){\\n            int score = 0;\\n            for(auto &it: nums)     \\n                score += (it % d == 0);\\n            if(score >= curr){\\n                if(score == curr)       \\n                    res = min(res, d);\\n                else                    \\n                    res = d;                    \\n                curr = score;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444500,
                "title": "99-fast-c-best-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n       sort(nums.begin(), nums.end());\\n        int maxi = *max_element(nums.begin(), nums.end());\\n        map<int, int>mp;\\n       for(int i = 0; i<divisors.size(); i++)\\n       {\\n           int count = 0;\\n           for(int j = divisors[i]; j<=maxi; j = j+divisors[i])\\n           {\\n               int l = lower_bound(nums.begin(), nums.end(), j)-nums.begin();\\n               int u = upper_bound(nums.begin(), nums.end(), j)-nums.begin();\\n               if(nums[l] == j)\\n               {\\n                   count = count+(u-l);\\n               }\\n           }\\n           mp[divisors[i]] = count;\\n           //cout<<count<<\" \";\\n       }\\n        \\n        int ans = INT_MIN;\\n        int max = INT_MAX;\\n        for(auto i : mp)\\n        {\\n            if(i.second>ans)\\n            {\\n                ans = i.second;\\n                max = i.first;\\n            }\\n            else if(i.second==ans)\\n            {\\n                if(i.first < max)\\n                {\\n                    max = i.first;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n       sort(nums.begin(), nums.end());\\n        int maxi = *max_element(nums.begin(), nums.end());\\n        map<int, int>mp;\\n       for(int i = 0; i<divisors.size(); i++)\\n       {\\n           int count = 0;\\n           for(int j = divisors[i]; j<=maxi; j = j+divisors[i])\\n           {\\n               int l = lower_bound(nums.begin(), nums.end(), j)-nums.begin();\\n               int u = upper_bound(nums.begin(), nums.end(), j)-nums.begin();\\n               if(nums[l] == j)\\n               {\\n                   count = count+(u-l);\\n               }\\n           }\\n           mp[divisors[i]] = count;\\n           //cout<<count<<\" \";\\n       }\\n        \\n        int ans = INT_MIN;\\n        int max = INT_MAX;\\n        for(auto i : mp)\\n        {\\n            if(i.second>ans)\\n            {\\n                ans = i.second;\\n                max = i.first;\\n            }\\n            else if(i.second==ans)\\n            {\\n                if(i.first < max)\\n                {\\n                    max = i.first;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3423433,
                "title": "easiest-solution-using-two-for-loops",
                "content": "# Intuition\\nUsing two for loops to iterate through the arrays.\\n\\n# Approach\\nBy taking the divisors one by one we count how many of elements of nums array are divisible by the divisors. Bycomparing with maxScore we find the divisor element with max score.\\n\\n# Complexity\\n- Time complexity:\\nO(n2)\\n\\n- Space complexity:\\nO(0)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        Arrays.sort(divisors);\\n        int maxScore=0;\\n        int ans=0;\\n        for(int i=0; i<divisors.length; i++){\\n            int score=0;\\n            for(int j=0; j<nums.length;j++){\\n                if(nums[j]%divisors[i]==0){ //if the nums element is divisible by the divisor we increase the score by one\\n                    score++;\\n                }\\n            }\\n            if(score>maxScore){\\n//compare the score with maximum score\\n                maxScore=score;\\n                ans=divisors[i];\\n            }\\n        }\\n        \\n        if(ans==0) return divisors[0];\\n        \\n    return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        Arrays.sort(divisors);\\n        int maxScore=0;\\n        int ans=0;\\n        for(int i=0; i<divisors.length; i++){\\n            int score=0;\\n            for(int j=0; j<nums.length;j++){\\n                if(nums[j]%divisors[i]==0){ //if the nums element is divisible by the divisor we increase the score by one\\n                    score++;\\n                }\\n            }\\n            if(score>maxScore){\\n//compare the score with maximum score\\n                maxScore=score;\\n                ans=divisors[i];\\n            }\\n        }\\n        \\n        if(ans==0) return divisors[0];\\n        \\n    return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422013,
                "title": "simple-solution-in-go-and-c",
                "content": "\\n\\n# Complexity\\n- Time complexity: $$O(n*m)$$\\n<!-- Add your time complexity here, e.g.  -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc maxDivScore(nums []int, divisors []int) int {\\n    maxCount, index := 0, 0\\n    \\n    for i := 0; i < len(divisors); i++ {\\n        count := 0\\n        for j := 0; j < len(nums); j++ {\\n            if nums[j] % divisors[i] == 0 {\\n                count++\\n            }\\n        }\\n        \\n        if count > maxCount || (count == maxCount && divisors[i] < divisors[index]) {\\n            maxCount = count\\n            index = i\\n        }\\n    }\\n    \\n    return divisors[index]\\n}\\n```\\nC#\\n```\\npublic class Solution {\\n    public int MaxDivScore(int[] nums, int[] divisors) {\\n        int maxCount = 0;\\n        int index = 0;\\n        \\n        for (int i = 0; i < divisors.Length; i++) {\\n            int count = 0;\\n            for (int j = 0; j < nums.Length; j++) {\\n                if (nums[j] % divisors[i] == 0) {\\n                    count++;\\n                }\\n            }\\n            \\n            if (count > maxCount || (count == maxCount && divisors[i] < divisors[index])) {\\n                maxCount = count;\\n                index = i;\\n            }\\n        }\\n        \\n        return divisors[index];\\n    }\\n}\\n```\\n![a6c83c54-1d1a-4f26-8273-b687d119dd5b_1679889261.1494205.png](https://assets.leetcode.com/users/images/cc82e8aa-dc98-4f10-af4c-64b1528c0fb6_1680844232.130332.png)",
                "solutionTags": [
                    "C#",
                    "Go"
                ],
                "code": "```\\nfunc maxDivScore(nums []int, divisors []int) int {\\n    maxCount, index := 0, 0\\n    \\n    for i := 0; i < len(divisors); i++ {\\n        count := 0\\n        for j := 0; j < len(nums); j++ {\\n            if nums[j] % divisors[i] == 0 {\\n                count++\\n            }\\n        }\\n        \\n        if count > maxCount || (count == maxCount && divisors[i] < divisors[index]) {\\n            maxCount = count\\n            index = i\\n        }\\n    }\\n    \\n    return divisors[index]\\n}\\n```\n```\\npublic class Solution {\\n    public int MaxDivScore(int[] nums, int[] divisors) {\\n        int maxCount = 0;\\n        int index = 0;\\n        \\n        for (int i = 0; i < divisors.Length; i++) {\\n            int count = 0;\\n            for (int j = 0; j < nums.Length; j++) {\\n                if (nums[j] % divisors[i] == 0) {\\n                    count++;\\n                }\\n            }\\n            \\n            if (count > maxCount || (count == maxCount && divisors[i] < divisors[index])) {\\n                maxCount = count;\\n                index = i;\\n            }\\n        }\\n        \\n        return divisors[index];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421910,
                "title": "c-brute-force-easy-to-understand",
                "content": "````\\n\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int x = 0, y = 0,ans = INT_MAX;\\n        for(auto &i: divisors){\\n            x = 0;\\n            for(auto &j: nums){\\n                if(j%i==0){\\n                    x++;\\n                }\\n            }\\n            if(x>y){\\n                y = x;\\n                ans = i;\\n            }\\n            if(x==y){\\n                ans = min(ans,i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "````\\n\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int x = 0, y = 0,ans = INT_MAX;\\n        for(auto &i: divisors){\\n            x = 0;\\n            for(auto &j: nums){\\n                if(j%i==0){\\n                    x++;\\n                }\\n            }\\n            if(x>y){\\n                y = x;\\n                ans = i;\\n            }\\n            if(x==y){\\n                ans = min(ans,i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421860,
                "title": "c-easy-peasy-solution-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe function maxDivisor takes in two vectors nums and divisors. It first initializes an unordered map scores to map each divisor to its     score. It then loops through each divisor in divisors, counts its score by looping through each number in nums, and updates max_score and      max_divisor if the score is greater than max_score or equal to max_score and the divisor is less than max_divisor. Finally, it returns       max_divisor\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        \\n        unordered_map<int, int> scores; // map each divisor to its score\\n        \\n        int max_score = 0;\\n        int max_divisor = divisors[0];\\n        \\n        for (int divisor : divisors) \\n        {\\n            scores[divisor] = 0;\\n            \\n            for (int num : nums) \\n            {\\n                if (num % divisor == 0) \\n                    scores[divisor]++;\\n            }\\n            \\n            if (scores[divisor] > max_score || (scores[divisor] == max_score && divisor < max_divisor)) \\n            {\\n                max_score = scores[divisor];\\n                max_divisor = divisor;\\n            }\\n        }\\n        \\n        return max_divisor;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        \\n        unordered_map<int, int> scores; // map each divisor to its score\\n        \\n        int max_score = 0;\\n        int max_divisor = divisors[0];\\n        \\n        for (int divisor : divisors) \\n        {\\n            scores[divisor] = 0;\\n            \\n            for (int num : nums) \\n            {\\n                if (num % divisor == 0) \\n                    scores[divisor]++;\\n            }\\n            \\n            if (scores[divisor] > max_score || (scores[divisor] == max_score && divisor < max_divisor)) \\n            {\\n                max_score = scores[divisor];\\n                max_divisor = divisor;\\n            }\\n        }\\n        \\n        return max_divisor;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421846,
                "title": "c-easytounderstand-optimalsolution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int count = 0;\\n        int hold = INT_MAX;\\n        for(int i=0;i<divisors.size();i++){\\n            int curr = 0;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]%divisors[i] == 0) \\n                    curr++;\\n            }\\n            if(curr > count){\\n                count = curr;\\n                hold = divisors[i];\\n            }\\n            if(curr == count && divisors[i]<hold)\\n                hold = divisors[i];\\n        }\\n        return hold;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int count = 0;\\n        int hold = INT_MAX;\\n        for(int i=0;i<divisors.size();i++){\\n            int curr = 0;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]%divisors[i] == 0) \\n                    curr++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3421825,
                "title": "clean-easy-solution",
                "content": "```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        mD = 0\\n        res = min(divisors)\\n        for d in divisors:\\n            cntr = 0\\n            for num in nums:\\n                if num%d == 0:\\n                    cntr += 1\\n            if cntr > mD:\\n                res = d\\n                mD = cntr\\n            elif cntr == mD:\\n                res = min(res,d)\\n        return res",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        mD = 0\\n        res = min(divisors)\\n        for d in divisors:\\n            cntr = 0\\n            for num in nums:\\n                if num%d == 0:\\n                    cntr += 1\\n            if cntr > mD:\\n                res = d\\n                mD = cntr\\n            elif cntr == mD:\\n                res = min(res,d)\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 3421772,
                "title": "c-beginer-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n       int n=divisors.size();\\n        vector<int> s(n,0);\\n       vector<pair<int,int>> vec;\\n        for(int i=0;i<n;i++){\\n            int c=0;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]%divisors[i]==0)c++;\\n            }\\n            vec.push_back({c,divisors[i]});\\n        }\\n        sort(vec.begin(),vec.end());\\n        int x=vec[vec.size()-1].first;\\n        for(auto it: vec){\\n            if(it.first==x){\\n                return it.second;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n       int n=divisors.size();\\n        vector<int> s(n,0);\\n       vector<pair<int,int>> vec;\\n        for(int i=0;i<n;i++){\\n            int c=0;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]%divisors[i]==0)c++;\\n            }\\n            vec.push_back({c,divisors[i]});\\n        }\\n        sort(vec.begin(),vec.end());\\n        int x=vec[vec.size()-1].first;\\n        for(auto it: vec){\\n            if(it.first==x){\\n                return it.second;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3900329,
                "title": "java-beginner-bruteforce-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        \\n       \\n        int a=0;\\n        int aa=Integer.MAX_VALUE;\\n        for(int i=divisors.length-1;i>=0;i--){\\n            int d=divisors[i];\\n             int c=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j]%d==0)\\n                c++;\\n            }\\n            if(c==a){\\n                aa=Math.min(aa,d);\\n\\n            }\\n            if(c>a){\\n                a=c;\\n                aa=d;\\n\\n            }\\n        }\\n        return aa;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        \\n       \\n        int a=0;\\n        int aa=Integer.MAX_VALUE;\\n        for(int i=divisors.length-1;i>=0;i--){\\n            int d=divisors[i];\\n             int c=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j]%d==0)\\n                c++;\\n            }\\n            if(c==a){\\n                aa=Math.min(aa,d);\\n\\n            }\\n            if(c>a){\\n                a=c;\\n                aa=d;\\n\\n            }\\n        }\\n        return aa;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3698119,
                "title": "python-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        count = 0\\n        maximal = 0\\n        result = []\\n        for divisor in divisors:\\n            for n in nums:\\n                if n % divisor == 0:\\n                    count += 1\\n            if count > maximal:\\n                maximal = count\\n                result = [divisor]\\n            elif count == maximal:\\n                result.append(divisor)\\n            count = 0\\n        return min(result)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        count = 0\\n        maximal = 0\\n        result = []\\n        for divisor in divisors:\\n            for n in nums:\\n                if n % divisor == 0:\\n                    count += 1\\n            if count > maximal:\\n                maximal = count\\n                result = [divisor]\\n            elif count == maximal:\\n                result.append(divisor)\\n            count = 0\\n        return min(result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518098,
                "title": "find-the-maximum-divisibility-score-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int i, j, score, max=0, ans=divisors[0];\\n        for(i=0 ; i<divisors.size() ; i++)\\n        {\\n            score = 0;\\n            for(j=0 ; j<nums.size() ; j++)\\n            {\\n                if(nums[j]%divisors[i]==0)\\n                {\\n                    score++;\\n                }\\n            }\\n            if(score>max)\\n            {\\n                max = score;\\n                ans = divisors[i];\\n            }\\n            else if(score==max && divisors[i]<ans)\\n            {\\n                ans = divisors[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/e7d4450c-db89-4385-9fe3-6c42fad1000c_1683948810.613229.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int i, j, score, max=0, ans=divisors[0];\\n        for(i=0 ; i<divisors.size() ; i++)\\n        {\\n            score = 0;\\n            for(j=0 ; j<nums.size() ; j++)\\n            {\\n                if(nums[j]%divisors[i]==0)\\n                {\\n                    score++;\\n                }\\n            }\\n            if(score>max)\\n            {\\n                max = score;\\n                ans = divisors[i];\\n            }\\n            else if(score==max && divisors[i]<ans)\\n            {\\n                ans = divisors[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503665,
                "title": "easy-solution-with-50-beats-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n       ArrayList<Integer> list = new ArrayList<>();\\n       ArrayList<Integer> finalList = new ArrayList<>();\\n\\n       int j = 0;\\n       while(j<divisors.length){\\n           int i = 0;\\n           int count = 0;\\n           while(i<nums.length){\\n           if(nums[i]%divisors[j] == 0){\\n               count++;\\n           }\\n           i++;\\n        }\\n        list.add(count);\\n           j++;\\n        }\\n\\n        int a = Collections.max(list);\\n        for(int m =0 ; m<list.size(); m++){\\n            if(a == list.get(m)){\\n                finalList.add(divisors[m]);\\n            }\\n        }\\n\\n\\n\\n        return Collections.min(finalList);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n       ArrayList<Integer> list = new ArrayList<>();\\n       ArrayList<Integer> finalList = new ArrayList<>();\\n\\n       int j = 0;\\n       while(j<divisors.length){\\n           int i = 0;\\n           int count = 0;\\n           while(i<nums.length){\\n           if(nums[i]%divisors[j] == 0){\\n               count++;\\n           }\\n           i++;\\n        }\\n        list.add(count);\\n           j++;\\n        }\\n\\n        int a = Collections.max(list);\\n        for(int m =0 ; m<list.size(); m++){\\n            if(a == list.get(m)){\\n                finalList.add(divisors[m]);\\n            }\\n        }\\n\\n\\n\\n        return Collections.min(finalList);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3499101,
                "title": "easy-java-solution-not-good-beats-though",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int score[][] = new int[divisors.length][2];\\n        for(int i=0; i<divisors.length; i++) {\\n            int count = 0;\\n            for(int j=0; j<nums.length; j++) {\\n                if(nums[j] % divisors[i] == 0) {\\n                    count++;\\n                }\\n            }\\n            score[i][0] = divisors[i];\\n            score[i][1] = count;\\n        }\\n        Arrays.sort(score, Comparator.comparingDouble(o -> o[1]));\\n\\n        ArrayList<Integer> ansList = new ArrayList<>();\\n        ansList.add(score[score.length-1][0]);\\n        for(int k=score.length-2; k>=0; k--) {\\n            if(score[score.length-1][1]==score[k][1]) {\\n                ansList.add(score[k][0]);\\n            }\\n        }\\n\\n        Collections.sort(ansList);\\n        return ansList.get(0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int score[][] = new int[divisors.length][2];\\n        for(int i=0; i<divisors.length; i++) {\\n            int count = 0;\\n            for(int j=0; j<nums.length; j++) {\\n                if(nums[j] % divisors[i] == 0) {\\n                    count++;\\n                }\\n            }\\n            score[i][0] = divisors[i];\\n            score[i][1] = count;\\n        }\\n        Arrays.sort(score, Comparator.comparingDouble(o -> o[1]));\\n\\n        ArrayList<Integer> ansList = new ArrayList<>();\\n        ansList.add(score[score.length-1][0]);\\n        for(int k=score.length-2; k>=0; k--) {\\n            if(score[score.length-1][1]==score[k][1]) {\\n                ansList.add(score[k][0]);\\n            }\\n        }\\n\\n        Collections.sort(ansList);\\n        return ansList.get(0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436628,
                "title": "swift-functional-approach",
                "content": "**Functional Approach (accepted answer)**\\n```\\nclass Solution {\\n    func maxDivScore(_ nums: [Int], _ divisors: [Int]) -> Int {\\n        divisors.reduce((maxScore: -1, minDivisor: 0)) { result, divisor in\\n            let score = nums.reduce(0) { score, num in score + (num % divisor == 0 ? 1: 0) }\\n            let update = score > result.maxScore || (score == result.maxScore && divisor < result.minDivisor)\\n            return update ? (maxScore: score, minDivisor: divisor) : result\\n        }.minDivisor\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maxDivScore(_ nums: [Int], _ divisors: [Int]) -> Int {\\n        divisors.reduce((maxScore: -1, minDivisor: 0)) { result, divisor in\\n            let score = nums.reduce(0) { score, num in score + (num % divisor == 0 ? 1: 0) }\\n            let update = score > result.maxScore || (score == result.maxScore && divisor < result.minDivisor)\\n            return update ? (maxScore: score, minDivisor: divisor) : result\\n        }.minDivisor\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3426648,
                "title": "beats-100-java-simple-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe are takin a boolean  variable as false to check whether the count remains 0 case.\\nso what we did is we first ran the outer loop for divisor array then we run a inner loop for nums array and go on checking for the count of nums element those are divisible by divisor array element. Then we check for a condition if **(maxCount< count)** we will update it and mark as true. Else we will check for the **count==maxCount** and we will check that our res has updated or not by the help of boolean variable. if It is then we simply update res. If boolean variable remains false then we simply find min because it means no of count remains 0 for all the element.\\nAnd at last we will check boolean variable value if its true we simply return res else we return min.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nums.length*divisors.length)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        \\n  \\t\\tint maxCount = 0, res = 0,min=Integer.MAX_VALUE;\\n\\t\\tboolean isGreater=false;\\n\\n\\t\\tfor (int i = 0; i < divisors.length; i++) {\\n\\t\\t\\tint count = 0 ;\\n\\t\\t\\t//res = div[i];\\n\\n\\t\\t\\tfor (int j = 0; j < nums.length; j++) {\\n\\t\\t\\t\\tif (nums[j] % divisors[i] == 0) {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (maxCount < count) {\\n\\t\\t\\t\\tmaxCount = count;\\n\\t\\t\\t\\tres = divisors[i];\\n\\t\\t\\t\\tisGreater=true;\\n\\t\\t\\t}\\n            if(maxCount == count) {\\n\\t\\t\\t\\tif(res > divisors[i] && isGreater) {\\n\\t\\t\\t\\t\\tres = divisors[i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(min>divisors[i]) {\\n\\t\\t\\t\\t\\tmin=divisors[i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn (isGreater)?res:min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        \\n  \\t\\tint maxCount = 0, res = 0,min=Integer.MAX_VALUE;\\n\\t\\tboolean isGreater=false;\\n\\n\\t\\tfor (int i = 0; i < divisors.length; i++) {\\n\\t\\t\\tint count = 0 ;\\n\\t\\t\\t//res = div[i];\\n\\n\\t\\t\\tfor (int j = 0; j < nums.length; j++) {\\n\\t\\t\\t\\tif (nums[j] % divisors[i] == 0) {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (maxCount < count) {\\n\\t\\t\\t\\tmaxCount = count;\\n\\t\\t\\t\\tres = divisors[i];\\n\\t\\t\\t\\tisGreater=true;\\n\\t\\t\\t}\\n            if(maxCount == count) {\\n\\t\\t\\t\\tif(res > divisors[i] && isGreater) {\\n\\t\\t\\t\\t\\tres = divisors[i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(min>divisors[i]) {\\n\\t\\t\\t\\t\\tmin=divisors[i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn (isGreater)?res:min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3425957,
                "title": "brute-force-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) \\n    {\\n        int score = 0;\\n        int ans   = *min_element(divisors.begin(),divisors.end());\\n\\n        for(int i=0;i<divisors.size();i++)\\n        {\\n            int count = 0;\\n            for(int j=0;j<nums.size();j++)\\n            {\\n                   if((nums[j] % divisors[i]) == 0)\\n                   {\\n                       count++;\\t\\n                   }\\t\\t\\n            }\\n            if(count > score)\\n            {\\n                ans = divisors[i];\\n                score = count;\\n            }\\n            else if(count == score and divisors[i] < ans)\\n            {\\n                 ans = divisors[i];\\n            }\\n        }\\n        return ans;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) \\n    {\\n        int score = 0;\\n        int ans   = *min_element(divisors.begin(),divisors.end());\\n\\n        for(int i=0;i<divisors.size();i++)\\n        {\\n            int count = 0;\\n            for(int j=0;j<nums.size();j++)\\n            {\\n                   if((nums[j] % divisors[i]) == 0)\\n                   {\\n                       count++;\\t\\n                   }\\t\\t\\n            }\\n            if(count > score)\\n            {\\n                ans = divisors[i];\\n                score = count;\\n            }\\n            else if(count == score and divisors[i] < ans)\\n            {\\n                 ans = divisors[i];\\n            }\\n        }\\n        return ans;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424758,
                "title": "c-brute-force",
                "content": "# Complexity\\n- Time complexity: $$O(n*m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n*m)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int ans=0, ans2=0;\\n        for (int i=0; i<divisors.size(); i++){\\n            int curr=0;\\n            for (int j=0; j<nums.size(); j++){\\n                if (nums[j]%divisors[i]==0)curr++;\\n            }\\n            if (curr>ans){\\n                ans= curr;\\n                ans2= i;\\n            }\\n            else if (curr==ans && divisors[i]<divisors[ans2]){\\n                ans2=i;\\n                ans= curr;\\n            }\\n        }\\n        return divisors[ans2];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Matrix",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int ans=0, ans2=0;\\n        for (int i=0; i<divisors.size(); i++){\\n            int curr=0;\\n            for (int j=0; j<nums.size(); j++){\\n                if (nums[j]%divisors[i]==0)curr++;\\n            }\\n            if (curr>ans){\\n                ans= curr;\\n                ans2= i;\\n            }\\n            else if (curr==ans && divisors[i]<divisors[ans2]){\\n                ans2=i;\\n                ans= curr;\\n            }\\n        }\\n        return divisors[ans2];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422931,
                "title": "easy-c-solution-brute-force-map",
                "content": "# Intuition\\nBrute force approach and  to reduce repeated calculation  map is used.\\n\\n# Approach\\nBrute force +map\\n\\n# Complexity\\n- Time complexity:\\nO(n*m)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        map<int,int>mp;\\n        int maxi=INT_MIN;\\n        int ans=0;\\n        for(auto it:divisors){\\n     //avoiding repeated divisors\\n            if(mp[it]==0){\\n                for(int i=0;i<nums.size();i++){\\n                if(nums[i]%it==0){\\n                    mp[it]+=1;\\n                }\\n            }\\n            }\\n        }\\n        for(auto it:mp){\\n            if(it.second>maxi){\\n                maxi=it.second;\\n                ans=it.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        map<int,int>mp;\\n        int maxi=INT_MIN;\\n        int ans=0;\\n        for(auto it:divisors){\\n     //avoiding repeated divisors\\n            if(mp[it]==0){\\n                for(int i=0;i<nums.size();i++){\\n                if(nums[i]%it==0){\\n                    mp[it]+=1;\\n                }\\n            }\\n            }\\n        }\\n        for(auto it:mp){\\n            if(it.second>maxi){\\n                maxi=it.second;\\n                ans=it.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422913,
                "title": "146-ms",
                "content": "```rust\\nimpl Solution {\\n    pub fn max_div_score(mut a: Vec<i32>, mut b: Vec<i32>) -> i32 {\\n        a.sort(); b.sort(); let az = a.len();\\n        let (mut r, mut m, mut s, mut p) = (0, -1, 0usize, 0);\\n        for d in b {\\n            if d == p { continue } else { p = d }\\n            while s < az && a[s] < d { s += 1 }\\n            if (az - s) as i32 <= m { break }\\n            let mut c = 0;\\n            for j in s..az {\\n                if a[j] % d == 0 { c += 1 }\\n            }\\n            if c > m { r = d; m = c }\\n        }\\n        r\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn max_div_score(mut a: Vec<i32>, mut b: Vec<i32>) -> i32 {\\n        a.sort(); b.sort(); let az = a.len();\\n        let (mut r, mut m, mut s, mut p) = (0, -1, 0usize, 0);\\n        for d in b {\\n            if d == p { continue } else { p = d }\\n            while s < az && a[s] < d { s += 1 }\\n            if (az - s) as i32 <= m { break }\\n            let mut c = 0;\\n            for j in s..az {\\n                if a[j] % d == 0 { c += 1 }\\n            }\\n            if c > m { r = d; m = c }\\n        }\\n        r\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3422695,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        ans=-1\\n        most=-1\\n        for d in divisors:\\n            cnt=sum(1 for n in nums if n%d==0)\\n            if cnt>most or cnt==most and d<ans:\\n                ans=d\\n                most=cnt\\n\\n        return ans        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        ans=-1\\n        most=-1\\n        for d in divisors:\\n            cnt=sum(1 for n in nums if n%d==0)\\n            if cnt>most or cnt==most and d<ans:\\n                ans=d\\n                most=cnt\\n\\n        return ans        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422287,
                "title": "no-brute-force-highly-optimized-enough-for-n-1e5",
                "content": "# Approach\\nsuppose n = 20\\nAll the prime factors of 30 = {2,3,5}\\nand all the divisors of 20 = {1,2,3,6,5,10,15,30}\\nwhich can be genrated by the combination from the prime numbers.\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    vector<int> allDivisor(int n){\\n        // calculate all prime factors of n\\n        map<int,int> primes;\\n        for(long long i=2; i<=sqrt(n); i++) {\\n            while(n%i == 0) {\\n                primes[i]++;\\n                n/=i;\\n            }\\n        }\\n        if (n > 1) primes[n]++;\\n\\n        // make all divisors by primes\\n        vector<int> divisors = {1};\\n        for(auto&p: primes) {\\n            int sz = divisors.size();\\n            int cur = 1;\\n            for (int i=0; i <p.second; i++) {\\n                cur *= p.first;\\n                for (int j = 0; j < sz; j++) {\\n                    divisors.push_back(divisors[j] * cur);\\n                }\\n            }\\n        }\\n        return divisors;\\n    }\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        map<int,int> freq; // used to store the frequency of each number which is the factor if nums[i]\\n        set<int> st(begin(divisors),end(divisors)); // It\\'s for like storing the frequency of elements which is only present in divisors array. (It\\'s for space optimisation)\\n\\n        // storing the divisors of all the elements of nums[i]\\n        for(int&num: nums){\\n            auto factors = allDivisor(num);\\n            for(int&factor: factors)\\n                if(st.count(factor)) freq[factor]++;\\n        }\\n\\n        // simply checking the freq of each divisors[i] in freq map\\n        int maxfreq = -1,ans = -1,mn = 1e9;\\n        for(int&e: divisors){\\n            if(freq.count(e)){\\n                int val = freq[e];\\n                if(maxfreq < val){\\n                    maxfreq = val;\\n                    ans = e;\\n                }else if(maxfreq == val){\\n                    ans = min(ans,e);\\n                }\\n            }\\n            mn = min(mn,e);\\n        }\\n        return ans == -1 ? mn : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Math",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<int> allDivisor(int n){\\n        // calculate all prime factors of n\\n        map<int,int> primes;\\n        for(long long i=2; i<=sqrt(n); i++) {\\n            while(n%i == 0) {\\n                primes[i]++;\\n                n/=i;\\n            }\\n        }\\n        if (n > 1) primes[n]++;\\n\\n        // make all divisors by primes\\n        vector<int> divisors = {1};\\n        for(auto&p: primes) {\\n            int sz = divisors.size();\\n            int cur = 1;\\n            for (int i=0; i <p.second; i++) {\\n                cur *= p.first;\\n                for (int j = 0; j < sz; j++) {\\n                    divisors.push_back(divisors[j] * cur);\\n                }\\n            }\\n        }\\n        return divisors;\\n    }\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        map<int,int> freq; // used to store the frequency of each number which is the factor if nums[i]\\n        set<int> st(begin(divisors),end(divisors)); // It\\'s for like storing the frequency of elements which is only present in divisors array. (It\\'s for space optimisation)\\n\\n        // storing the divisors of all the elements of nums[i]\\n        for(int&num: nums){\\n            auto factors = allDivisor(num);\\n            for(int&factor: factors)\\n                if(st.count(factor)) freq[factor]++;\\n        }\\n\\n        // simply checking the freq of each divisors[i] in freq map\\n        int maxfreq = -1,ans = -1,mn = 1e9;\\n        for(int&e: divisors){\\n            if(freq.count(e)){\\n                int val = freq[e];\\n                if(maxfreq < val){\\n                    maxfreq = val;\\n                    ans = e;\\n                }else if(maxfreq == val){\\n                    ans = min(ans,e);\\n                }\\n            }\\n            mn = min(mn,e);\\n        }\\n        return ans == -1 ? mn : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422159,
                "title": "optimized-java-solution-easy-structured-with-comments-and-approach",
                "content": "# Approach\\nWe will iterate through all the divisors and check how many of the numbers they can divide. While doing this, we will keep track of the divisor which divided maximum of numbers.\\n\\nNote: The only thing that can cause error in this problem is the edge condition. i.e. if the maximum count is same, we need to return the minimum divisor that had that score. Hence, we need to add an extra condition for it.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(M*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int maxScore=-1;\\n        int maxElement=-1;\\n        for(int i=0;i<divisors.length;i++){\\n            // count of numbers ith divisor can divide\\n            int score=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j]%divisors[i]==0)\\n                    score++;\\n            }\\n\\n            // updating max count\\n            if(score==maxScore) // edge condition\\n                maxElement=Math.min(maxElement,divisors[i]);\\n            else if(score>maxScore){\\n                maxScore=score;\\n                maxElement=divisors[i];\\n            }\\n        }\\n        return maxElement;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int maxScore=-1;\\n        int maxElement=-1;\\n        for(int i=0;i<divisors.length;i++){\\n            // count of numbers ith divisor can divide\\n            int score=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j]%divisors[i]==0)\\n                    score++;\\n            }\\n\\n            // updating max count\\n            if(score==maxScore) // edge condition\\n                maxElement=Math.min(maxElement,divisors[i]);\\n            else if(score>maxScore){\\n                maxScore=score;\\n                maxElement=divisors[i];\\n            }\\n        }\\n        return maxElement;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422129,
                "title": "find-the-maximum-divisibility-score-simple-approach-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& div) {\\n        int maxcnt = 0;\\n        int ans=INT_MAX;\\n        for(int i=0;i<div.size();i++){\\n            int cnt=0;int f = 1;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]%div[i]==0){\\n                    cnt++;\\n                }\\n            }\\n            if(cnt>maxcnt){\\n                ans = div[i];\\n                maxcnt = cnt;\\n            }else if(cnt==maxcnt){\\n                ans = min(ans,div[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& div) {\\n        int maxcnt = 0;\\n        int ans=INT_MAX;\\n        for(int i=0;i<div.size();i++){\\n            int cnt=0;int f = 1;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]%div[i]==0){\\n                    cnt++;\\n                }\\n            }\\n            if(cnt>maxcnt){\\n                ans = div[i];\\n                maxcnt = cnt;\\n            }else if(cnt==maxcnt){\\n                ans = min(ans,div[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422083,
                "title": "easyapproach-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe initialize maxScore to -1 and maxDivisor to Integer.MAX_VALUE.\\n\\n Then, we loop through all the divisors in the array divisors. \\n\\nFor each divisor, we count the number of elements in the array nums that are divisible by that divisor. \\n\\nIf this count is greater than the current maximum score, we update maxScore and maxDivisor to the current divisor. \\n\\nIf the score is equal to the current maximum score, we update maxDivisor only if the current divisor is smaller than the current maximum divisor.\\n\\nFinally, we return maxDivisor as the integer with the maximum divisibility score.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO (nxn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO (1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n    int maxScore = -1;\\n    int maxDivisor = Integer.MAX_VALUE;\\n\\n    for (int divisor : divisors) {\\n        int score = 0;\\n        for (int num : nums) {\\n            if (num % divisor == 0) {\\n                score++;\\n            }\\n        }\\n        if (score > maxScore || (score == maxScore && divisor < maxDivisor)) {\\n            maxScore = score;\\n            maxDivisor = divisor;\\n        }\\n    }\\n\\n    return maxDivisor;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n    int maxScore = -1;\\n    int maxDivisor = Integer.MAX_VALUE;\\n\\n    for (int divisor : divisors) {\\n        int score = 0;\\n        for (int num : nums) {\\n            if (num % divisor == 0) {\\n                score++;\\n            }\\n        }\\n        if (score > maxScore || (score == maxScore && divisor < maxDivisor)) {\\n            maxScore = score;\\n            maxDivisor = divisor;\\n        }\\n    }\\n\\n    return maxDivisor;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422042,
                "title": "best-c-well-explained-brute-force",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ntake divisor and check for every element of num is divisible or not and count the total number of divisible number.\\nafter that store it to the map. if same divisor come more then one time then we dont calculate it multiple time it is already stored in our map. simply skip same divisor.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n***O(N * M)***\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n***O(1)***\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        map<int, int> mp;\\n        for(int i=0; i<divisors.size(); i++)    {\\n            int cnt = 0;\\n            // same number comming then skip it ::\\n            if(mp.find(divisors[i]) != mp.end())    continue;\\n\\n            // count the number of divisible element in nums\\n            for(int j=0; j<nums.size(); j++)    \\n                if(nums[j] % divisors[i] == 0)  cnt++;\\n            \\n            mp[divisors[i]] = cnt;\\n        }\\n        int ans = *min_element(divisors.begin(), divisors.end());\\n        int cnt = mp[ans];\\n        for(auto it : mp)   {\\n            if(it.second > cnt) {\\n                cnt = it.second;\\n                ans = it.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        map<int, int> mp;\\n        for(int i=0; i<divisors.size(); i++)    {\\n            int cnt = 0;\\n            // same number comming then skip it ::\\n            if(mp.find(divisors[i]) != mp.end())    continue;\\n\\n            // count the number of divisible element in nums\\n            for(int j=0; j<nums.size(); j++)    \\n                if(nums[j] % divisors[i] == 0)  cnt++;\\n            \\n            mp[divisors[i]] = cnt;\\n        }\\n        int ans = *min_element(divisors.begin(), divisors.end());\\n        int cnt = mp[ans];\\n        for(auto it : mp)   {\\n            if(it.second > cnt) {\\n                cnt = it.second;\\n                ans = it.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422041,
                "title": "c-simple-divisibility-check",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCheck if a number divides another number.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor each divisors[i]--> if nums[j] is divisible by divisors[i], then increment the divisibiltiy score of divisors[i]\\n\\n# Complexity\\n- Time complexity: O(mn), m= length of divisors, n= length of nums\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& v, vector<int>& d) {\\n        int maxD= 0, ans=*min_element(d.begin(), d.end());\\n        for(int i=0;i<d.size();i++){\\n            int c=0;\\n            for(int j=0;j<v.size();j++){\\n                if(v[j]%d[i]==0) c++;\\n            }\\n            if(c>=maxD){\\n                if(c>maxD){\\n                maxD= c; ans= d[i];\\n                }\\n                else{\\n                    ans= min(ans, d[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& v, vector<int>& d) {\\n        int maxD= 0, ans=*min_element(d.begin(), d.end());\\n        for(int i=0;i<d.size();i++){\\n            int c=0;\\n            for(int j=0;j<v.size();j++){\\n                if(v[j]%d[i]==0) c++;\\n            }\\n            if(c>=maxD){\\n                if(c>maxD){\\n                maxD= c; ans= d[i];\\n                }\\n                else{\\n                    ans= min(ans, d[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421962,
                "title": "c-solutions-beginner-friendly-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int ans = 0, most = -1; \\n        for (auto& div : divisors) {\\n            int cnt = 0; \\n            for (auto & x : nums) {\\n                if (x % div == 0) ++ cnt; \\n            }\\n            if (cnt > most || cnt == most && div < ans) {ans = div, most = cnt; }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int ans = 0, most = -1; \\n        for (auto& div : divisors) {\\n            int cnt = 0; \\n            for (auto & x : nums) {\\n                if (x % div == 0) ++ cnt; \\n            }\\n            if (cnt > most || cnt == most && div < ans) {ans = div, most = cnt; }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421937,
                "title": "javascript-direct-way-516ms",
                "content": "```\\nconst maxDivScore = (a, b) => {\\n    let f = [];\\n    b.map((d, i) => {\\n        let cnt = 0;\\n        for (const x of a) {\\n            if (x % d == 0) cnt++;\\n        }\\n        f.push([cnt, d]);\\n    });\\n    f.sort((x, y) => y[0] - x[0] || x[1] - y[1]);\\n    return f[0][1];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sort"
                ],
                "code": "```\\nconst maxDivScore = (a, b) => {\\n    let f = [];\\n    b.map((d, i) => {\\n        let cnt = 0;\\n        for (const x of a) {\\n            if (x % d == 0) cnt++;\\n        }\\n        f.push([cnt, d]);\\n    });\\n    f.sort((x, y) => y[0] - x[0] || x[1] - y[1]);\\n    return f[0][1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3421925,
                "title": "easy-c-solution-t-c-o-nm-s-c-o-m",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given problem asks us to find the divisor in the input array divisors that has the highest divisibility score in the input array nums.\\n\\nTo solve this problem, we need to iterate over each divisor and count the number of elements in nums that are divisible by the current divisor. We can store the score for each divisor in an unordered map. After calculating the score for each divisor, we can then find the divisor with the highest score and return it. If there are multiple divisors with the same highest score, we can break the tie by choosing the smallest divisor.\\n\\nThe intuition behind this approach is that the divisibility score for a divisor is simply the count of the number of elements in nums that are divisible by the divisor. By iterating over each divisor and counting the number of elements that are divisible by it, we can determine which divisor has the highest score. The use of an unordered map allows us to store the score for each divisor and quickly look up the score for a given divisor during the iteration.\\n\\nOverall, the approach is straightforward and efficient, with a time complexity of O(nm) and a space complexity of O(m).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach of the given code is to use a nested loop to calculate the divisibility score of each divisor by iterating over the input array nums.\\n\\nFor each divisor, the code iterates over each element of nums and checks if the element is divisible by the current divisor. If it is, it increments the score for the divisor. Finally, the code checks which divisor has the highest score and returns it. If there are multiple divisors with the same highest score, it returns the smallest of them.\\n\\n# Complexity\\n- Time complexity: O(nm)\\n-  where n is the length of nums and m is the length of divisors. This is because for each divisor in divisors, the code iterates over each element in nums. However, since the length of divisors is at most 1000, this code should run efficiently for most practical inputs.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m)\\n- where m is the length of divisors. This is because the code uses an unordered map to store the divisibility score for each divisor, which takes up space proportional to the number of divisors.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n          unordered_map<int, int> mp;\\n          int maxScore = 0, maxDivisor = INT_MAX;\\n\\n          for (int divisor : divisors) {\\n              mp[divisor] = 0;\\n          for (int num : nums) {\\n              if (num % divisor == 0) {\\n                mp[divisor]++;\\n              }\\n            }\\n         if (mp[divisor] > maxScore) {\\n            maxScore = mp[divisor];\\n            maxDivisor = divisor;\\n        }\\n        else if (mp[divisor] == maxScore) {\\n            maxDivisor = min(maxDivisor, divisor);\\n        }\\n      }\\n    return maxDivisor;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n          unordered_map<int, int> mp;\\n          int maxScore = 0, maxDivisor = INT_MAX;\\n\\n          for (int divisor : divisors) {\\n              mp[divisor] = 0;\\n          for (int num : nums) {\\n              if (num % divisor == 0) {\\n                mp[divisor]++;\\n              }\\n            }\\n         if (mp[divisor] > maxScore) {\\n            maxScore = mp[divisor];\\n            maxDivisor = divisor;\\n        }\\n        else if (mp[divisor] == maxScore) {\\n            maxDivisor = min(maxDivisor, divisor);\\n        }\\n      }\\n    return maxDivisor;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421905,
                "title": "ez-brute-force-again-c-java-python",
                "content": "# Intuition\\nJust count the number of divisors for each divisors[i] in nums array. Since the constraints are low, TC: O(m*n) is feasible solution.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(M*N)\\n\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors)\\n    {\\n        int d = divisors.size();\\n        vector<int> res(d,0);\\n        int maxDiv = 0;\\n        for(int i=0; i<d; i++)\\n        {\\n            int div = divisors[i];\\n            for(auto x : nums)\\n            {\\n                if(x%div == 0){\\n                    res[i]++;\\n                }\\n            }\\n            maxDiv = max(maxDiv, res[i]);\\n        }\\n        \\n        int ans = INT_MAX;\\n        for(int i=0; i<d; i++)\\n        {\\n            if(res[i] == maxDiv){\\n                ans = min(ans, divisors[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int d = divisors.length;\\n        int[] res = new int[d];\\n        int maxDiv = 0;\\n        for(int i=0; i<d; i++) {\\n            int div = divisors[i];\\n            for(int x : nums) {\\n                if(x % div == 0) {\\n                    res[i]++;\\n                }\\n            }\\n            maxDiv = Math.max(maxDiv, res[i]);\\n        }\\n\\n        int ans = Integer.MAX_VALUE;\\n        for(int i=0; i<d; i++) {\\n            if(res[i] == maxDiv) {\\n                ans = Math.min(ans, divisors[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        d = len(divisors)\\n        res = [0] * d\\n        maxDiv = 0\\n        for i in range(d):\\n            div = divisors[i]\\n            for x in nums:\\n                if x % div == 0:\\n                    res[i] += 1\\n            maxDiv = max(maxDiv, res[i])\\n\\n        ans = float(\\'inf\\')\\n        for i in range(d):\\n            if res[i] == maxDiv:\\n                ans = min(ans, divisors[i])\\n        return ans\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors)\\n    {\\n        int d = divisors.size();\\n        vector<int> res(d,0);\\n        int maxDiv = 0;\\n        for(int i=0; i<d; i++)\\n        {\\n            int div = divisors[i];\\n            for(auto x : nums)\\n            {\\n                if(x%div == 0){\\n                    res[i]++;\\n                }\\n            }\\n            maxDiv = max(maxDiv, res[i]);\\n        }\\n        \\n        int ans = INT_MAX;\\n        for(int i=0; i<d; i++)\\n        {\\n            if(res[i] == maxDiv){\\n                ans = min(ans, divisors[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int d = divisors.length;\\n        int[] res = new int[d];\\n        int maxDiv = 0;\\n        for(int i=0; i<d; i++) {\\n            int div = divisors[i];\\n            for(int x : nums) {\\n                if(x % div == 0) {\\n                    res[i]++;\\n                }\\n            }\\n            maxDiv = Math.max(maxDiv, res[i]);\\n        }\\n\\n        int ans = Integer.MAX_VALUE;\\n        for(int i=0; i<d; i++) {\\n            if(res[i] == maxDiv) {\\n                ans = Math.min(ans, divisors[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        d = len(divisors)\\n        res = [0] * d\\n        maxDiv = 0\\n        for i in range(d):\\n            div = divisors[i]\\n            for x in nums:\\n                if x % div == 0:\\n                    res[i] += 1\\n            maxDiv = max(maxDiv, res[i])\\n\\n        ans = float(\\'inf\\')\\n        for i in range(d):\\n            if res[i] == maxDiv:\\n                ans = min(ans, divisors[i])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421901,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n*m)$$\\n\\n- Space complexity:$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& n, vector<int>& d) {\\n        int cnt1=0, cnt2=0;\\n        for (int i=0; i<d.size(); i++){\\n            int l=0;\\n            for (int j=0; j<n.size(); j++){\\n                if (n[j]%d[i]==0){\\n                    l++;\\n                }\\n            }\\n            if (l>cnt1){\\n                cnt1=l;\\n                cnt2=i;\\n            }\\n            else if (l==cnt1 && d[i]<d[cnt2]){\\n                cnt2=i;\\n                cnt1=l;\\n            }\\n        }\\n        return d[cnt2];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& n, vector<int>& d) {\\n        int cnt1=0, cnt2=0;\\n        for (int i=0; i<d.size(); i++){\\n            int l=0;\\n            for (int j=0; j<n.size(); j++){\\n                if (n[j]%d[i]==0){\\n                    l++;\\n                }\\n            }\\n            if (l>cnt1){\\n                cnt1=l;\\n                cnt2=i;\\n            }\\n            else if (l==cnt1 && d[i]<d[cnt2]){\\n                cnt2=i;\\n                cnt1=l;\\n            }\\n        }\\n        return d[cnt2];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421851,
                "title": "simple-java-solution-faster-than-100",
                "content": "# **Just do simple calculation and count which is maximum.**\\n# If you like please upvote it.\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int n = nums.length;\\n        int m = divisors.length;\\n        int min = Integer.MAX_VALUE;\\n        int max = Integer.MIN_VALUE;\\n        int[] d = new int[m];\\n        for(int i=0;i<m;i++)\\n        {\\n            int count = 0;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(nums[j]%divisors[i]==0)\\n                {\\n                    count++;\\n                }\\n            }\\n            d[i] = count;\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            if(d[i]>=max)\\n            {\\n                max = d[i];\\n            }\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            if(d[i]==max)\\n                 min = Math.min(min,divisors[i]);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int n = nums.length;\\n        int m = divisors.length;\\n        int min = Integer.MAX_VALUE;\\n        int max = Integer.MIN_VALUE;\\n        int[] d = new int[m];\\n        for(int i=0;i<m;i++)\\n        {\\n            int count = 0;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(nums[j]%divisors[i]==0)\\n                {\\n                    count++;\\n                }\\n            }\\n            d[i] = count;\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            if(d[i]>=max)\\n            {\\n                max = d[i];\\n            }\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            if(d[i]==max)\\n                 min = Math.min(min,divisors[i]);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421845,
                "title": "java-solution-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(n*m) where n is length of array nums and m is length of array divisors\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int maxScore = 0;\\n        int divisor = divisors[0];\\n        for(int i = 0; i < divisors.length; i++) {\\n            int currentScore = 0;\\n            \\n            for(int j = 0; j < nums.length; j++) {\\n                if(nums[j] % divisors[i] == 0) {\\n                    currentScore++;\\n                }\\n            }\\n            if(currentScore == maxScore) {\\n                divisor = Math.min(divisor, divisors[i]);\\n            }\\n            \\n            if(currentScore > maxScore) {\\n                maxScore = currentScore;\\n                divisor = divisors[i];\\n            }\\n        }\\n        return divisor;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int maxScore = 0;\\n        int divisor = divisors[0];\\n        for(int i = 0; i < divisors.length; i++) {\\n            int currentScore = 0;\\n            \\n            for(int j = 0; j < nums.length; j++) {\\n                if(nums[j] % divisors[i] == 0) {\\n                    currentScore++;\\n                }\\n            }\\n            if(currentScore == maxScore) {\\n                divisor = Math.min(divisor, divisors[i]);\\n            }\\n            \\n            if(currentScore > maxScore) {\\n                maxScore = currentScore;\\n                divisor = divisors[i];\\n            }\\n        }\\n        return divisor;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421844,
                "title": "c-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $O(n*m)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(1)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& div) {\\n        int n=nums.size(),m=div.size(),mx=0,ans=div[0];\\n        for(int i=0;i<m;i++){\\n            int a=0;\\n            for(int j=0;j<n;j++){\\n                if(nums[j]%div[i]==0) a++;\\n            }\\n            if(a>mx){\\n                mx=a;\\n                ans=div[i];\\n            }\\n            if(a==mx && div[i]<ans) ans=div[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& div) {\\n        int n=nums.size(),m=div.size(),mx=0,ans=div[0];\\n        for(int i=0;i<m;i++){\\n            int a=0;\\n            for(int j=0;j<n;j++){\\n                if(nums[j]%div[i]==0) a++;\\n            }\\n            if(a>mx){\\n                mx=a;\\n                ans=div[i];\\n            }\\n            if(a==mx && div[i]<ans) ans=div[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421791,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] div) {\\n        Arrays.sort(nums);\\n        int score=0;\\n        int ind=div[0];\\n        for(int i=0;i<div.length;i++){\\n            int count=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j]%div[i]==0){\\n                    count++;\\n                }\\n            }\\n            if(count>score){\\n                score=count;\\n                ind=div[i];\\n            }\\n            if(count==score)\\n                ind=Math.min(ind,div[i]);\\n        }\\n        return ind;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] div) {\\n        Arrays.sort(nums);\\n        int score=0;\\n        int ind=div[0];\\n        for(int i=0;i<div.length;i++){\\n            int count=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j]%div[i]==0){\\n                    count++;\\n                }\\n            }\\n            if(count>score){\\n                score=count;\\n                ind=div[i];\\n            }\\n            if(count==score)\\n                ind=Math.min(ind,div[i]);\\n        }\\n        return ind;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421789,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int max= 0;\\n        int min=0;\\n     for(int j=0;j<divisors.length;j++)\\n        {\\n        int count=0;\\n            for(int i=0;i<nums.length;i++)\\n            { if((nums[i]%divisors[j])==0)\\n            {\\n                count++;\\n            }\\n            }\\n         if(max<=count)\\n         {\\n             if(count>max)\\n             {max=count;\\n             min=divisors[j];\\n             }\\n             else\\n             {\\n                if(min==0)\\n                {\\n                    min=divisors[j];\\n                    max=count;\\n                }\\n                 else\\n                 {\\n                     if(divisors[j]<min)\\n                         min=divisors[j];\\n                 }\\n             }\\n         }\\n        \\n         \\n        }\\n        \\n        \\n        return min;\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int max= 0;\\n        int min=0;\\n     for(int j=0;j<divisors.length;j++)\\n        {\\n        int count=0;\\n            for(int i=0;i<nums.length;i++)\\n            { if((nums[i]%divisors[j])==0)\\n            {\\n                count++;\\n            }\\n            }\\n         if(max<=count)\\n         {\\n             if(count>max)\\n             {max=count;\\n             min=divisors[j];\\n             }\\n             else\\n             {\\n                if(min==0)\\n                {\\n                    min=divisors[j];\\n                    max=count;\\n                }\\n                 else\\n                 {\\n                     if(divisors[j]<min)\\n                         min=divisors[j];\\n                 }\\n             }\\n         }\\n        \\n         \\n        }\\n        \\n        \\n        return min;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421758,
                "title": "easiest-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int min=0,max=0;\\n        for(int i=0;i<divisors.size();i++){\\n            int count=0;\\n            int div=divisors[i];\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]%div==0)\\n                    count++;\\n            }\\n            if(count>=max){\\n                if(count>max){\\n                    max=count;\\n                    min=div;\\n                }\\n                else{\\n                    if(min==0)\\n                        min=div;\\n                    else{\\n                        if(div<min)\\n                            min=div;\\n                    }\\n                }\\n            }\\n        }\\n        return min;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int min=0,max=0;\\n        for(int i=0;i<divisors.size();i++){\\n            int count=0;\\n            int div=divisors[i];\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]%div==0)\\n                    count++;\\n            }\\n            if(count>=max){\\n                if(count>max){\\n                    max=count;\\n                    min=div;\\n                }\\n                else{\\n                    if(min==0)\\n                        min=div;\\n                    else{\\n                        if(div<min)\\n                            min=div;\\n                    }\\n                }\\n            }\\n        }\\n        return min;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421742,
                "title": "c-brute-force-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int max_idx = 0;\\n        int maxi = INT_MIN;\\n        for(int i = 0; i < divisors.size(); i++)\\n        {\\n            int count = 0;\\n            for(int j = 0; j < nums.size(); j++)\\n            {\\n                if(nums[j] % divisors[i] == 0)\\n                {\\n                    count++;\\n                }\\n            }\\n            if(count > maxi)\\n            {\\n                maxi = count;\\n                max_idx = i;\\n            }\\n            else if(maxi == count)\\n            {\\n                maxi = count;\\n                if(divisors[max_idx] >= divisors[i])\\n                {\\n                    max_idx = i;\\n                }\\n            }\\n        }\\n        return divisors[max_idx];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int max_idx = 0;\\n        int maxi = INT_MIN;\\n        for(int i = 0; i < divisors.size(); i++)\\n        {\\n            int count = 0;\\n            for(int j = 0; j < nums.size(); j++)\\n            {\\n                if(nums[j] % divisors[i] == 0)\\n                {\\n                    count++;\\n                }\\n            }\\n            if(count > maxi)\\n            {\\n                maxi = count;\\n                max_idx = i;\\n            }\\n            else if(maxi == count)\\n            {\\n                maxi = count;\\n                if(divisors[max_idx] >= divisors[i])\\n                {\\n                    max_idx = i;\\n                }\\n            }\\n        }\\n        return divisors[max_idx];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421707,
                "title": "c-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int cnt=0,ans=INT_MAX;\\n        for(int i=0;i<divisors.size();i++){\\n            int c=0;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]%divisors[i] == 0) c+=1;\\n            }\\n            if(c>cnt){\\n                cnt = c;\\n                ans = divisors[i];\\n            }\\n            if(c==cnt && divisors[i]<ans) ans = divisors[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int cnt=0,ans=INT_MAX;\\n        for(int i=0;i<divisors.size();i++){\\n            int c=0;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]%divisors[i] == 0) c+=1;\\n            }\\n            if(c>cnt){\\n                cnt = c;\\n                ans = divisors[i];\\n            }\\n            if(c==cnt && divisors[i]<ans) ans = divisors[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4101892,
                "title": "one-line-solution",
                "content": "```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:  \\n        return reduce(lambda m, d: (s, d) if (s := sum(not n%d for n in nums)) > m[0] or s == m[0] and d < m[1] else m, divisors, (0, inf))[1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:  \\n        return reduce(lambda m, d: (s, d) if (s := sum(not n%d for n in nums)) > m[0] or s == m[0] and d < m[1] else m, divisors, (0, inf))[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4100103,
                "title": "python-dictionary",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        d = {}\\n        for i in range(len(divisors)):\\n            c = 0\\n            for j in nums:\\n                if j % divisors[i] == 0:\\n                    c += 1\\n            if c not in list(d.values()):\\n                d.update({divisors[i] : c})\\n            else:\\n                keys = list(d.keys())\\n                values = list(d.values())\\n                k = keys[values.index(c)]\\n                if k > divisors[i] :\\n                    del d[k]\\n                    d.update({divisors[i] : c})\\n        d = dict(sorted(d.items(), key = lambda t:t[1], reverse = True))\\n        return list(d.keys())[0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        d = {}\\n        for i in range(len(divisors)):\\n            c = 0\\n            for j in nums:\\n                if j % divisors[i] == 0:\\n                    c += 1\\n            if c not in list(d.values()):\\n                d.update({divisors[i] : c})\\n            else:\\n                keys = list(d.keys())\\n                values = list(d.values())\\n                k = keys[values.index(c)]\\n                if k > divisors[i] :\\n                    del d[k]\\n                    d.update({divisors[i] : c})\\n        d = dict(sorted(d.items(), key = lambda t:t[1], reverse = True))\\n        return list(d.keys())[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4099773,
                "title": "best-solution-tc-o-mn-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n\\n        int maxScore{-1}, divisor{};\\n\\n        for(auto i : divisors){\\n\\n            int currScore{};\\n\\n            for(auto j : nums) if(j % i == 0) currScore++;\\n            \\n            if(currScore >= maxScore){\\n                if(currScore == maxScore){\\n                    divisor = min(divisor, i);\\n                }\\n                else{\\n                    divisor = i;\\n                    maxScore = currScore;\\n                }          \\n            }\\n        }\\n\\n        return divisor;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n\\n        int maxScore{-1}, divisor{};\\n\\n        for(auto i : divisors){\\n\\n            int currScore{};\\n\\n            for(auto j : nums) if(j % i == 0) currScore++;\\n            \\n            if(currScore >= maxScore){\\n                if(currScore == maxScore){\\n                    divisor = min(divisor, i);\\n                }\\n                else{\\n                    divisor = i;\\n                    maxScore = currScore;\\n                }          \\n            }\\n        }\\n\\n        return divisor;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4073612,
                "title": "basic-java-soln-97",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int max=0,ans=divisors[0];\\n        for(int i:divisors){\\n            int c=0;\\n            for(int j:nums){\\n                if(j%i==0)\\n                    c++;\\n            }\\n            if(c>max||(c==max&&ans>i)){\\n                ans=i;\\n                max=c;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int max=0,ans=divisors[0];\\n        for(int i:divisors){\\n            int c=0;\\n            for(int j:nums){\\n                if(j%i==0)\\n                    c++;\\n            }\\n            if(c>max||(c==max&&ans>i)){\\n                ans=i;\\n                max=c;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4059500,
                "title": "beats-97-in-speed-91-in-memory",
                "content": "# Intuition\\n**just take care of current and highest score, if there is not any, return minimum of divisors**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int ans = 0,p=0;\\n        for(int i=0; i<divisors.length; i++){\\n            int c = 0;\\n            for(int j=0; j<nums.length; j++){\\n                if(nums[j] % divisors[i]==0){\\n                    c++;\\n                }\\n            }\\n            if(c>p){\\n                ans = divisors[i];\\n                p =c;\\n            }\\n            else if(c==p){\\n                ans = Math.min(ans,divisors[i]);\\n            }\\n        }\\n        if (p==0){\\n            int min = divisors[0];\\n            for(int i = 0; i<divisors.length; i++){\\n                if(min>divisors[i]){\\n                    min = divisors[i];\\n                }\\n            }\\n            return min;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int ans = 0,p=0;\\n        for(int i=0; i<divisors.length; i++){\\n            int c = 0;\\n            for(int j=0; j<nums.length; j++){\\n                if(nums[j] % divisors[i]==0){\\n                    c++;\\n                }\\n            }\\n            if(c>p){\\n                ans = divisors[i];\\n                p =c;\\n            }\\n            else if(c==p){\\n                ans = Math.min(ans,divisors[i]);\\n            }\\n        }\\n        if (p==0){\\n            int min = divisors[0];\\n            for(int i = 0; i<divisors.length; i++){\\n                if(min>divisors[i]){\\n                    min = divisors[i];\\n                }\\n            }\\n            return min;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055013,
                "title": "beat-97-in-memory-and-easy-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        m=-1\\n        ans=-1\\n        for i in divisors:\\n            d=0\\n            for j in nums:\\n                if j%i==0:\\n                    d+=1\\n            if d>m or d==m and i<ans:\\n                ans=i\\n                m=d\\n        return ans\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        m=-1\\n        ans=-1\\n        for i in divisors:\\n            d=0\\n            for j in nums:\\n                if j%i==0:\\n                    d+=1\\n            if d>m or d==m and i<ans:\\n                ans=i\\n                m=d\\n        return ans\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043958,
                "title": "java-98-beats-beginner-friendly-but-not-too-much-optimize",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int max_div=Integer.MAX_VALUE;\\n        int prev_count=0;\\n        int res=0;\\n        boolean isGreater = false;\\n\\n\\n        for(int i=0; i<divisors.length; i++){\\n            int count=0;\\n            for(int j=0; j<nums.length; j++){\\n                if(nums[j]%divisors[i]==0) count++;\\n            }\\n            if(prev_count < count){\\n                prev_count = count;\\n                res = divisors[i];\\n                isGreater = true;\\n            }\\n            if(prev_count == count){\\n                if(res>divisors[i] && isGreater){\\n                    res = divisors[i];\\n                }\\n                if(max_div > divisors[i]){\\n                    max_div = divisors[i];\\n                }\\n            }\\n        }\\n\\n        return isGreater ? res:max_div;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int max_div=Integer.MAX_VALUE;\\n        int prev_count=0;\\n        int res=0;\\n        boolean isGreater = false;\\n\\n\\n        for(int i=0; i<divisors.length; i++){\\n            int count=0;\\n            for(int j=0; j<nums.length; j++){\\n                if(nums[j]%divisors[i]==0) count++;\\n            }\\n            if(prev_count < count){\\n                prev_count = count;\\n                res = divisors[i];\\n                isGreater = true;\\n            }\\n            if(prev_count == count){\\n                if(res>divisors[i] && isGreater){\\n                    res = divisors[i];\\n                }\\n                if(max_div > divisors[i]){\\n                    max_div = divisors[i];\\n                }\\n            }\\n        }\\n\\n        return isGreater ? res:max_div;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4024087,
                "title": "c-basic-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int mx=INT_MIN;\\n        vector<int> scores;\\n        for(int i=0; i<divisors.size(); i++){\\n            int score=0;\\n            for(int j=0; j<nums.size(); j++){\\n                if(nums[j]%divisors[i]==0){\\n                    score++;\\n                }\\n            }\\n            scores.push_back(score);\\n            mx=max(mx, score);\\n        }\\n        vector<int> mxScore;\\n        for(int i=0; i<scores.size(); i++){\\n            if(mx==scores[i]){\\n                mxScore.push_back(divisors[i]);\\n            }\\n        }\\n        int mn=INT_MAX;\\n        for(int i=0; i<mxScore.size(); i++){\\n            mn=min(mn, mxScore[i]);\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int mx=INT_MIN;\\n        vector<int> scores;\\n        for(int i=0; i<divisors.size(); i++){\\n            int score=0;\\n            for(int j=0; j<nums.size(); j++){\\n                if(nums[j]%divisors[i]==0){\\n                    score++;\\n                }\\n            }\\n            scores.push_back(score);\\n            mx=max(mx, score);\\n        }\\n        vector<int> mxScore;\\n        for(int i=0; i<scores.size(); i++){\\n            if(mx==scores[i]){\\n                mxScore.push_back(divisors[i]);\\n            }\\n        }\\n        int mn=INT_MAX;\\n        for(int i=0; i<mxScore.size(); i++){\\n            mn=min(mn, mxScore[i]);\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001741,
                "title": "count-map-c",
                "content": "\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int mx = 0, res = INT_MAX;\\n        map<int, int> mp;\\n        for(int d : divisors) {\\n            int cnt = 0;\\n            if(++mp[d] == 1) \\n                for(int n : nums) \\n                    cnt += (n % d == 0);\\n            if(mx == cnt) \\n                res = min(res, d);\\n            else if(mx < cnt) {\\n                res = d;\\n                mx = cnt;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int mx = 0, res = INT_MAX;\\n        map<int, int> mp;\\n        for(int d : divisors) {\\n            int cnt = 0;\\n            if(++mp[d] == 1) \\n                for(int n : nums) \\n                    cnt += (n % d == 0);\\n            if(mx == cnt) \\n                res = min(res, d);\\n            else if(mx < cnt) {\\n                res = d;\\n                mx = cnt;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988957,
                "title": "easy-to-understand-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        scores = {}\\n\\n        for d in divisors:\\n            count = 0\\n            for i in nums:\\n                if i % d == 0:\\n                    count += 1\\n            scores[d] = count\\n        scores = list(sorted(scores.items(), key = lambda x: (-x[1], x[0])))\\n        return scores[0][0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        scores = {}\\n\\n        for d in divisors:\\n            count = 0\\n            for i in nums:\\n                if i % d == 0:\\n                    count += 1\\n            scores[d] = count\\n        scores = list(sorted(scores.items(), key = lambda x: (-x[1], x[0])))\\n        return scores[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976713,
                "title": "find-the-maximum-divisibility-score",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int max = Integer.MAX_VALUE;\\n        int maxi = 0;\\n        for(int i=0;i<divisors.length;i++)\\n        {\\n            int count = 0;\\n            for(int j=0;j<nums.length;j++)\\n            {\\n                if(nums[j]%divisors[i]==0)\\n                count++;\\n            }\\n            if(count>maxi)\\n            {\\n                maxi = count;\\n                max = divisors[i];\\n            }\\n            else if(count==maxi)\\n            {\\n                max = Math.min(max,divisors[i]);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int max = Integer.MAX_VALUE;\\n        int maxi = 0;\\n        for(int i=0;i<divisors.length;i++)\\n        {\\n            int count = 0;\\n            for(int j=0;j<nums.length;j++)\\n            {\\n                if(nums[j]%divisors[i]==0)\\n                count++;\\n            }\\n            if(count>maxi)\\n            {\\n                maxi = count;\\n                max = divisors[i];\\n            }\\n            else if(count==maxi)\\n            {\\n                max = Math.min(max,divisors[i]);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957255,
                "title": "easy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n       int mine=0,score=-1e8;\\n        for(auto it:divisors)\\n         {\\n           int ct=0;\\n           for(auto i:nums)\\n             {\\n               if(i%it==0)\\n                    ct++;\\n             }\\n                if(score<ct)\\n                 {\\n                   score=ct;\\n                    mine=it;\\n                 }\\n                 else if(score==ct)\\n                   {\\n                     mine=min((int)it,mine);\\n                   }\\n         }\\n         return mine;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n       int mine=0,score=-1e8;\\n        for(auto it:divisors)\\n         {\\n           int ct=0;\\n           for(auto i:nums)\\n             {\\n               if(i%it==0)\\n                    ct++;\\n             }\\n                if(score<ct)\\n                 {\\n                   score=ct;\\n                    mine=it;\\n                 }\\n                 else if(score==ct)\\n                   {\\n                     mine=min((int)it,mine);\\n                   }\\n         }\\n         return mine;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943009,
                "title": "python3-reversed-computation-of-divisibility-score-3-lines-376-ms-beats-100",
                "content": "# Approach\\nInstead of checking if elements of `nums` are evenly divisible by the current `divisor`, check if numbers `divisor * i` are in the list of `nums`,\\nwhere `i` is in range `[1, max(nums)//divisor]` \\n\\n**Note**: it is important to use `Counter` instead of `set` because `nums` can contain duplicate numbers.\\n\\n# Code\\n```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        max_num = max(nums)\\n        cnt = Counter(nums)\\n        return -max((sum(cnt[d * i] for i in range(1, max_num//d + 1)), -d) for d in divisors)[1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        max_num = max(nums)\\n        cnt = Counter(nums)\\n        return -max((sum(cnt[d * i] for i in range(1, max_num//d + 1)), -d) for d in divisors)[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939374,
                "title": "best-sollution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int c = 0;\\n        int res = 0;\\n        Arrays.sort(divisors);\\n        for(int i=0;i<divisors.length;i++){\\n            int count = 0;\\n            int x = divisors[i];\\n            for(int j=0;j<nums.length;j++){\\n                int y = nums[j];\\n                if(y%x==0){\\n                    count++;\\n                }\\n            }\\n            if(count>c){\\n                res = x;\\n                c = count;\\n            }\\n        }\\n        if(res==0){\\n            res = divisors[0];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int c = 0;\\n        int res = 0;\\n        Arrays.sort(divisors);\\n        for(int i=0;i<divisors.length;i++){\\n            int count = 0;\\n            int x = divisors[i];\\n            for(int j=0;j<nums.length;j++){\\n                int y = nums[j];\\n                if(y%x==0){\\n                    count++;\\n                }\\n            }\\n            if(count>c){\\n                res = x;\\n                c = count;\\n            }\\n        }\\n        if(res==0){\\n            res = divisors[0];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928796,
                "title": "best-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int m=0,ans;\\n        sort(divisors.begin(),divisors.end());\\n        set<int> s;\\n        for(int i=0;i<divisors.size();i++){\\n            int c=0;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]%divisors[i]==0){\\n                    c++;\\n                }\\n            }\\n            s.insert(c);\\n            if(c>m){\\n                m=c;\\n                ans=divisors[i];\\n            }\\n        }\\n        if(s.size()==1){\\n            return divisors[0];\\n        }\\n        else{\\n            return ans;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int m=0,ans;\\n        sort(divisors.begin(),divisors.end());\\n        set<int> s;\\n        for(int i=0;i<divisors.size();i++){\\n            int c=0;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]%divisors[i]==0){\\n                    c++;\\n                }\\n            }\\n            s.insert(c);\\n            if(c>m){\\n                m=c;\\n                ans=divisors[i];\\n            }\\n        }\\n        if(s.size()==1){\\n            return divisors[0];\\n        }\\n        else{\\n            return ans;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3925063,
                "title": "o-m-n-java-solution",
                "content": "# Approach\\n1. Calculate the score for `ith` divisor\\n2. if the `score` > `maxScore`, update `maxScore` and `result`\\n3. if `score` == `maxScore`, update the `result` to the **minimum** of `ith divisor` (for which we just calculated the score) and `result`\\n\\n# Complexity\\n- Time complexity: O(m*n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int maxScore = 0;\\n        int minValue = Integer.MAX_VALUE;\\n\\n        for (int divisor : divisors) {\\n            int score = 0;\\n            for (int num : nums) {\\n                if (num % divisor == 0) {\\n                    score++;\\n                }\\n            }\\n\\n            if (score > maxScore) {\\n                maxScore = score;\\n                minValue = divisor;\\n            } else if (score == maxScore) {\\n                minValue = Math.min(minValue, divisor);\\n            }\\n        }\\n\\n        return minValue;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int maxScore = 0;\\n        int minValue = Integer.MAX_VALUE;\\n\\n        for (int divisor : divisors) {\\n            int score = 0;\\n            for (int num : nums) {\\n                if (num % divisor == 0) {\\n                    score++;\\n                }\\n            }\\n\\n            if (score > maxScore) {\\n                maxScore = score;\\n                minValue = divisor;\\n            } else if (score == maxScore) {\\n                minValue = Math.min(minValue, divisor);\\n            }\\n        }\\n\\n        return minValue;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3904749,
                "title": "purely-brute-force-but-easy-to-understandable-code",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n\\n        vector<int> ans;\\n        int max = INT_MIN;\\n\\n        sort(divisors.begin(),divisors.end());\\n\\n        for(int i=0;i<divisors.size();i++)\\n        {\\n            int count = 0;\\n            for(int j=0;j<nums.size();j++)\\n            {\\n                if(nums[j]%divisors[i]==0)\\n                    count++;\\n            }\\n            ans.push_back(count);\\n            if(max < count)\\n            {\\n                max = count;\\n            }\\n        }   \\n\\n        int result;\\n\\n        for(int i=0;i<ans.size();i++)\\n        {\\n                if (ans[i] == max) \\n                {\\n                result = divisors[i];\\n                break;\\n                }\\n        }\\n\\n    return result;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n\\n        vector<int> ans;\\n        int max = INT_MIN;\\n\\n        sort(divisors.begin(),divisors.end());\\n\\n        for(int i=0;i<divisors.size();i++)\\n        {\\n            int count = 0;\\n            for(int j=0;j<nums.size();j++)\\n            {\\n                if(nums[j]%divisors[i]==0)\\n                    count++;\\n            }\\n            ans.push_back(count);\\n            if(max < count)\\n            {\\n                max = count;\\n            }\\n        }   \\n\\n        int result;\\n\\n        for(int i=0;i<ans.size();i++)\\n        {\\n                if (ans[i] == max) \\n                {\\n                result = divisors[i];\\n                break;\\n                }\\n        }\\n\\n    return result;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3890473,
                "title": "max-divisibility-score",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        num=0\\n        div=0\\n        for i in divisors:\\n            num1=0\\n            for j in nums:\\n                if j%i==0:\\n                    num1+=1\\n            if num1>num:\\n                div=i\\n                num=num1\\n            elif num1==num:\\n                div=div if div<i else i\\n        return div if div!=0 else min(divisors)\\n                    \\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        num=0\\n        div=0\\n        for i in divisors:\\n            num1=0\\n            for j in nums:\\n                if j%i==0:\\n                    num1+=1\\n            if num1>num:\\n                div=i\\n                num=num1\\n            elif num1==num:\\n                div=div if div<i else i\\n        return div if div!=0 else min(divisors)\\n                    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887370,
                "title": "beginner-map-vector",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        vector<pair<int,int>>pq;\\n        int max_count=0;\\n        for(int i=0;i<divisors.size();i++){\\n            int count=0;\\n            pair<int,int>p;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]%divisors[i]==0){\\n                    count++;\\n                }\\n            }\\n            max_count=max(max_count,count);\\n           p.first=count;\\n           p.second=divisors[i];\\n           pq.push_back(p);\\n        }\\n        vector<int>ans;\\n        for(auto it : pq){\\n            if(it.first==max_count){\\n                ans.push_back(it.second);\\n            }\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Hash Table",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        vector<pair<int,int>>pq;\\n        int max_count=0;\\n        for(int i=0;i<divisors.size();i++){\\n            int count=0;\\n            pair<int,int>p;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]%divisors[i]==0){\\n                    count++;\\n                }\\n            }\\n            max_count=max(max_count,count);\\n           p.first=count;\\n           p.second=divisors[i];\\n           pq.push_back(p);\\n        }\\n        vector<int>ans;\\n        for(auto it : pq){\\n            if(it.first==max_count){\\n                ans.push_back(it.second);\\n            }\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3877810,
                "title": "basic-java-solution-beats-98",
                "content": "# Intuition\\nthe basic intuition is that we have to find the maximum score of an element in divisors array, so we simply iterate through the array , with a variable name max (that stores the max count of an element) and a variable ans (that stores our result if any) \\nso we iterate through the array checking with the condition if the condition satisfies we will increase the count.\\n\\nafter the inner loops complete we will check if the count value is greater or equal to our max value, if it is equal we will store the smaller element in our ans variable. else if the count is greater than max then we\\'ll simply put that value of divisor in our array and take the max as count.\\n\\nat last the ans will be our desired ans;\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n\\n        int max = 0;\\n        int ans = divisors[0];\\n        for(int i = 0 ; i<divisors.length ; i++){\\n            int count = 0;\\n\\n            for(int j = 0 ; j < nums.length; j++){\\n                if(nums[j]%divisors[i]==0){\\n                    count++;\\n                }\\n            }\\n\\n            if(count>=max){\\n                if(count==max){\\n                    ans = Math.min(divisors[i],ans);\\n                    max = Math.max(max, count);\\n                }else{                    \\n                    ans = divisors[i];\\n                    max = Math.max(max, count);            \\n                }\\n            }\\n\\n        }\\n        return ans==-1?divisors[0]:ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n\\n        int max = 0;\\n        int ans = divisors[0];\\n        for(int i = 0 ; i<divisors.length ; i++){\\n            int count = 0;\\n\\n            for(int j = 0 ; j < nums.length; j++){\\n                if(nums[j]%divisors[i]==0){\\n                    count++;\\n                }\\n            }\\n\\n            if(count>=max){\\n                if(count==max){\\n                    ans = Math.min(divisors[i],ans);\\n                    max = Math.max(max, count);\\n                }else{                    \\n                    ans = divisors[i];\\n                    max = Math.max(max, count);            \\n                }\\n            }\\n\\n        }\\n        return ans==-1?divisors[0]:ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3877597,
                "title": "python-solution-dictionary",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxDivScore(self, nums, divisors):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type divisors: List[int]\\n        :rtype: int\\n        \"\"\" \\n        divisors = sorted(set(divisors))\\n        d = {}\\n        for i in range(len(divisors)):\\n            c = 0\\n            for j in range(len(nums)):\\n                if nums[j] % divisors[i] == 0:\\n                    c += 1\\n            d[divisors[i]] = c\\n        print(d)\\n        v = max(d.values())\\n        print(d)\\n        sorted_items = sorted(d.items(), key=lambda x: x[0])\\n        print(sorted_items)\\n        for i in sorted_items:\\n            if i[1] == v:\\n                return i[0]\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxDivScore(self, nums, divisors):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type divisors: List[int]\\n        :rtype: int\\n        \"\"\" \\n        divisors = sorted(set(divisors))\\n        d = {}\\n        for i in range(len(divisors)):\\n            c = 0\\n            for j in range(len(nums)):\\n                if nums[j] % divisors[i] == 0:\\n                    c += 1\\n            d[divisors[i]] = c\\n        print(d)\\n        v = max(d.values())\\n        print(d)\\n        sorted_items = sorted(d.items(), key=lambda x: x[0])\\n        print(sorted_items)\\n        for i in sorted_items:\\n            if i[1] == v:\\n                return i[0]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876754,
                "title": "fast-defaultdict-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        div_score = defaultdict(int)\\n        div_max = []\\n        for div in divisors:\\n            div_score[div] = sum(1 for x in nums if x % div == 0)\\n        mx = max(count for count in div_score.values())\\n        for div, count in div_score.items():\\n            if count == mx:\\n                div_max.append(div)\\n        return min(div_max)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        div_score = defaultdict(int)\\n        div_max = []\\n        for div in divisors:\\n            div_score[div] = sum(1 for x in nums if x % div == 0)\\n        mx = max(count for count in div_score.values())\\n        for div, count in div_score.items():\\n            if count == mx:\\n                div_max.append(div)\\n        return min(div_max)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3874695,
                "title": "java-173ms-beats-98-45",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(mn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// 173ms Beats 98.45%\\n\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n\\n        int winningDivisor = -1;\\n        int winningScore = -1;\\n\\n        for (int i = divisors.length - 1; i >= 0; --i) {\\n\\n            int curScore = 0;\\n\\n            for (int j = 0; j < nums.length; ++j) {\\n                if (nums[j] % divisors[i] == 0) {\\n                    ++curScore;\\n                }\\n            }\\n\\n            if (curScore > winningScore) {\\n                winningDivisor = divisors[i];\\n                winningScore = curScore;\\n            } else if (curScore == winningScore) {\\n                if (divisors[i] < winningDivisor) {\\n                    winningDivisor = divisors[i];\\n                    winningScore = curScore;\\n                }\\n            }\\n        }\\n\\n        return winningDivisor;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// 173ms Beats 98.45%\\n\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n\\n        int winningDivisor = -1;\\n        int winningScore = -1;\\n\\n        for (int i = divisors.length - 1; i >= 0; --i) {\\n\\n            int curScore = 0;\\n\\n            for (int j = 0; j < nums.length; ++j) {\\n                if (nums[j] % divisors[i] == 0) {\\n                    ++curScore;\\n                }\\n            }\\n\\n            if (curScore > winningScore) {\\n                winningDivisor = divisors[i];\\n                winningScore = curScore;\\n            } else if (curScore == winningScore) {\\n                if (divisors[i] < winningDivisor) {\\n                    winningDivisor = divisors[i];\\n                    winningScore = curScore;\\n                }\\n            }\\n        }\\n\\n        return winningDivisor;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3871580,
                "title": "easy-java-solution-with-more-than-95-of-beats-please-vote-me-up",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int max=0;\\n        int idx=0;\\n        for(int i=0;i<divisors.length;i++){\\n            int c=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j]%divisors[i]==0){\\n                    c++;\\n                }\\n            }\\n            if(c==max){\\n                if(divisors[i]<divisors[idx]){\\n                    idx=i;\\n                }\\n            }\\n            if(c>max){\\n                max=c;\\n                idx=i;\\n            }\\n        }\\n        if(idx==0){\\n            Arrays.sort(divisors);\\n            return divisors[0];\\n        }\\n        return divisors[idx];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int max=0;\\n        int idx=0;\\n        for(int i=0;i<divisors.length;i++){\\n            int c=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j]%divisors[i]==0){\\n                    c++;\\n                }\\n            }\\n            if(c==max){\\n                if(divisors[i]<divisors[idx]){\\n                    idx=i;\\n                }\\n            }\\n            if(c>max){\\n                max=c;\\n                idx=i;\\n            }\\n        }\\n        if(idx==0){\\n            Arrays.sort(divisors);\\n            return divisors[0];\\n        }\\n        return divisors[idx];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861953,
                "title": "simple-solution-in-js",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} divisors\\n * @return {number}\\n */\\nvar maxDivScore = function(nums, divisors) {\\n    let max = [0];\\n    for(let i = 0; i < divisors.length; i++) {\\n        let curr = 0;\\n        for(let j = 0; j < nums.length; j++) {\\n            if(nums[j] % divisors[i] == 0) {\\n                curr++\\n            }\\n        } \\n        if(max[0] == curr && max[1] > divisors[i]) {\\n            max[1] = divisors[i]\\n        }else if(max[0] < curr) {\\n            max[0] = curr\\n            max[1] = divisors[i]\\n        }\\n    }\\n    if(!max[0]) return Math.min(...divisors)\\n    return max[1]\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} divisors\\n * @return {number}\\n */\\nvar maxDivScore = function(nums, divisors) {\\n    let max = [0];\\n    for(let i = 0; i < divisors.length; i++) {\\n        let curr = 0;\\n        for(let j = 0; j < nums.length; j++) {\\n            if(nums[j] % divisors[i] == 0) {\\n                curr++\\n            }\\n        } \\n        if(max[0] == curr && max[1] > divisors[i]) {\\n            max[1] = divisors[i]\\n        }else if(max[0] < curr) {\\n            max[0] = curr\\n            max[1] = divisors[i]\\n        }\\n    }\\n    if(!max[0]) return Math.min(...divisors)\\n    return max[1]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3855236,
                "title": "java-93ms-beats-99-and-clean-code",
                "content": "# Approach\\n1. Sort the numbers in increasing order.\\n2. For each divisor, traverse nums backwards with j (n-1..0) WHILE nums[j] >= divisor.\\n3. For each traversal keep track of current divisor\\'s currentScore. \\n    - If currentScore > maxScore, set new maxScore and new minDivisor\\n    - If currentScore == maxScore, set new minDivisor the min between minDivisor and currentDivisor.\\n4. Return minDivisor.    \\n\\n# Complexity\\n- Time complexity:$$O(n*log(n) + n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int maxDivScore = 0, minDivisor = Integer.MAX_VALUE, currentDivScore;\\n        Arrays.sort(nums);\\n        for (int divisor : divisors) {\\n            currentDivScore = 0;\\n            for (int i = nums.length -1; i >= 0 && divisor <= nums[i]; i--) {\\n                if (nums[i] % divisor == 0){\\n                    currentDivScore++;\\n                }\\n            }\\n            if(currentDivScore > maxDivScore) {\\n                maxDivScore = currentDivScore;\\n                minDivisor = divisor;\\n            } else if (currentDivScore == maxDivScore) {\\n                minDivisor = Math.min(divisor, minDivisor);\\n            }\\n        }\\n        return minDivisor;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int maxDivScore = 0, minDivisor = Integer.MAX_VALUE, currentDivScore;\\n        Arrays.sort(nums);\\n        for (int divisor : divisors) {\\n            currentDivScore = 0;\\n            for (int i = nums.length -1; i >= 0 && divisor <= nums[i]; i--) {\\n                if (nums[i] % divisor == 0){\\n                    currentDivScore++;\\n                }\\n            }\\n            if(currentDivScore > maxDivScore) {\\n                maxDivScore = currentDivScore;\\n                minDivisor = divisor;\\n            } else if (currentDivScore == maxDivScore) {\\n                minDivisor = Math.min(divisor, minDivisor);\\n            }\\n        }\\n        return minDivisor;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849829,
                "title": "junior-ios-dev-solution-need-a-cheap-extremely-motivated-ios-dev-contact-me-pls",
                "content": "Sorry, no explanation. 10 p.m. junior ios straightforward dev solution. if you have work for me - contact pls.\\n\\n# Code\\n```\\nclass Solution {\\n    func maxDivScore(_ nums: [Int], _ divisors: [Int]) -> Int {\\n        var counter = 0\\n        var divisorValue = 0\\n\\n        for divisor in divisors {\\n            var tempCounter = 0\\n            for num in nums {\\n                if num % divisor == 0 {\\n                    tempCounter += 1\\n                }\\n            }\\n            if tempCounter == counter && divisorValue != 0 {\\n                counter = tempCounter\\n                divisorValue = min(divisorValue, divisor)\\n                continue\\n            }\\n            if tempCounter >= counter {\\n                divisorValue = divisor\\n                counter = tempCounter\\n            }\\n        }\\n\\n        return divisorValue\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maxDivScore(_ nums: [Int], _ divisors: [Int]) -> Int {\\n        var counter = 0\\n        var divisorValue = 0\\n\\n        for divisor in divisors {\\n            var tempCounter = 0\\n            for num in nums {\\n                if num % divisor == 0 {\\n                    tempCounter += 1\\n                }\\n            }\\n            if tempCounter == counter && divisorValue != 0 {\\n                counter = tempCounter\\n                divisorValue = min(divisorValue, divisor)\\n                continue\\n            }\\n            if tempCounter >= counter {\\n                divisorValue = divisor\\n                counter = tempCounter\\n            }\\n        }\\n\\n        return divisorValue\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835385,
                "title": "c-solution",
                "content": "```\\nint maxDivScore(vector<int>& nums, vector<int>& div) {\\n\\tint res = div[0], maxScore = 0;\\n\\tfor (int d : div) {\\n\\t\\tint curScore = 0;\\n\\t\\tfor (int n : nums)\\n\\t\\t\\tif (n % d == 0)\\n\\t\\t\\t\\tcurScore++;\\n\\t\\tif (curScore > maxScore) {\\n\\t\\t\\tmaxScore = curScore;\\n\\t\\t\\tres = d;\\n\\t\\t}\\n\\t\\tif (curScore == maxScore)\\n\\t\\t\\tres = min(res, d);\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint maxDivScore(vector<int>& nums, vector<int>& div) {\\n\\tint res = div[0], maxScore = 0;\\n\\tfor (int d : div) {\\n\\t\\tint curScore = 0;\\n\\t\\tfor (int n : nums)\\n\\t\\t\\tif (n % d == 0)\\n\\t\\t\\t\\tcurScore++;\\n\\t\\tif (curScore > maxScore) {\\n\\t\\t\\tmaxScore = curScore;\\n\\t\\t\\tres = d;\\n\\t\\t}\\n\\t\\tif (curScore == maxScore)\\n\\t\\t\\tres = min(res, d);\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3833606,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        uint16_t i_u16 = 0, divSize = divisors.size(), maxDivisor = 0, maxScore = 0;\\n        int j_s32 = 0;\\n        int divScore = 0;\\n\\n        for(i_u16 = 0; i_u16 < divSize; i_u16++)\\n        {\\n            divScore = 0;\\n\\n            for(j_s32 = 0; j_s32 < nums.size(); j_s32++ )\\n            {\\n                if( nums[j_s32] % divisors[i_u16] == 0 )\\n                {\\n                    divScore++;\\n                }\\n            }\\n\\n            if(divScore > maxScore || (divScore == maxScore && divisors[i_u16] <= divisors[maxDivisor]))\\n            {\\n                maxScore = divScore;\\n                maxDivisor = i_u16;   \\n            }\\n        }\\n\\n        return divisors[maxDivisor];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        uint16_t i_u16 = 0, divSize = divisors.size(), maxDivisor = 0, maxScore = 0;\\n        int j_s32 = 0;\\n        int divScore = 0;\\n\\n        for(i_u16 = 0; i_u16 < divSize; i_u16++)\\n        {\\n            divScore = 0;\\n\\n            for(j_s32 = 0; j_s32 < nums.size(); j_s32++ )\\n            {\\n                if( nums[j_s32] % divisors[i_u16] == 0 )\\n                {\\n                    divScore++;\\n                }\\n            }\\n\\n            if(divScore > maxScore || (divScore == maxScore && divisors[i_u16] <= divisors[maxDivisor]))\\n            {\\n                maxScore = divScore;\\n                maxDivisor = i_u16;   \\n            }\\n        }\\n\\n        return divisors[maxDivisor];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3812997,
                "title": "easy-solution-in-c",
                "content": "# Intuition\\n\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int ans=111111111;\\n        int maxcount=-111111111;\\n        for(int i=0;i<divisors.size();i++){\\n            int count=0;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]%divisors[i]==0)\\n                count++;\\n            }\\n            if(maxcount<count){\\n                maxcount=count;\\n                ans=divisors[i];\\n            }\\n            else if(maxcount==count){\\n                ans=min(ans,divisors[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int ans=111111111;\\n        int maxcount=-111111111;\\n        for(int i=0;i<divisors.size();i++){\\n            int count=0;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]%divisors[i]==0)\\n                count++;\\n            }\\n            if(maxcount<count){\\n                maxcount=count;\\n                ans=divisors[i];\\n            }\\n            else if(maxcount==count){\\n                ans=min(ans,divisors[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3809363,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n * n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n + n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static bool compare(pair<int,int>a, pair<int,int>b)\\n    {\\n        if(a.first > b.first)\\n        return true;\\n        if(a.first == b.first)\\n        {\\n            return a.second < b.second;\\n        }\\n        return false;\\n    }\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n       map<int,int>mp;\\n       bool flag = false;\\n       int minDivisors = INT_MAX;\\n       for(int i = 0; i < divisors.size(); i++)\\n       {\\n           if(mp.find(divisors[i]) == mp.end())\\n           {\\n               for(int j = 0; j < nums.size(); j++)\\n                {\\n                    if(nums[j] % divisors[i] == 0)\\n                    {\\n                            mp[divisors[i]]++;\\n                            flag = true;\\n                    }\\n                }\\n           }\\n            minDivisors = min(minDivisors, divisors[i]);\\n       } \\n       if(flag == false)\\n       {\\n           return minDivisors;\\n       }\\n       vector<pair<int,int>>v;\\n       for(auto it : mp)\\n       {\\n           v.push_back({it.second, it.first});\\n       }\\n       sort(v.begin(), v.end(), compare);\\n       for(auto x : v)\\n       {\\n           cout<<x.first<<\"->\"<<x.second<<endl;\\n       }\\n       if(v.size() > 0)\\n       return v[0].second;\\n       return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool compare(pair<int,int>a, pair<int,int>b)\\n    {\\n        if(a.first > b.first)\\n        return true;\\n        if(a.first == b.first)\\n        {\\n            return a.second < b.second;\\n        }\\n        return false;\\n    }\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n       map<int,int>mp;\\n       bool flag = false;\\n       int minDivisors = INT_MAX;\\n       for(int i = 0; i < divisors.size(); i++)\\n       {\\n           if(mp.find(divisors[i]) == mp.end())\\n           {\\n               for(int j = 0; j < nums.size(); j++)\\n                {\\n                    if(nums[j] % divisors[i] == 0)\\n                    {\\n                            mp[divisors[i]]++;\\n                            flag = true;\\n                    }\\n                }\\n           }\\n            minDivisors = min(minDivisors, divisors[i]);\\n       } \\n       if(flag == false)\\n       {\\n           return minDivisors;\\n       }\\n       vector<pair<int,int>>v;\\n       for(auto it : mp)\\n       {\\n           v.push_back({it.second, it.first});\\n       }\\n       sort(v.begin(), v.end(), compare);\\n       for(auto x : v)\\n       {\\n           cout<<x.first<<\"->\"<<x.second<<endl;\\n       }\\n       if(v.size() > 0)\\n       return v[0].second;\\n       return 0;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3803283,
                "title": "divisibility-score-js-count-scores-intuitive",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} divisors\\n * @return {number}\\n */\\nvar maxDivScore = function(nums, divisors) {\\n    divisors.sort((a, b) => a - b)\\n    scores = []\\n\\n    for (let i = 0; i < divisors.length; i++) {\\n        count = 0\\n        for (num of nums) {\\n            if (num % divisors[i] == 0) count ++\\n        }\\n        scores[i] = count\\n    }\\n\\n    maximum_score = Math.max(...scores)\\n\\n    return divisors[scores.indexOf(maximum_score)]\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} divisors\\n * @return {number}\\n */\\nvar maxDivScore = function(nums, divisors) {\\n    divisors.sort((a, b) => a - b)\\n    scores = []\\n\\n    for (let i = 0; i < divisors.length; i++) {\\n        count = 0\\n        for (num of nums) {\\n            if (num % divisors[i] == 0) count ++\\n        }\\n        scores[i] = count\\n    }\\n\\n    maximum_score = Math.max(...scores)\\n\\n    return divisors[scores.indexOf(maximum_score)]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3799305,
                "title": "very-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>&n , vector<int>&d){\\n        int mx=INT_MIN;\\n        for(auto i:d){\\n            int c=0;\\n            for(auto j:n){\\n                if(j%i==0){\\n                    c++;\\n                }\\n            }\\n            if(mx<c){\\n                mx=c;\\n            }\\n        }\\n        vector<int>v;\\n        for(auto i:d){\\n            int c=0;\\n            for(auto j:n){\\n                if(j%i==0){\\n                    c++;\\n                }\\n            }\\n            if(mx==c){\\n                v.push_back(i);\\n            }\\n        }\\n        sort(v.begin(),v.end());\\n        return v[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>&n , vector<int>&d){\\n        int mx=INT_MIN;\\n        for(auto i:d){\\n            int c=0;\\n            for(auto j:n){\\n                if(j%i==0){\\n                    c++;\\n                }\\n            }\\n            if(mx<c){\\n                mx=c;\\n            }\\n        }\\n        vector<int>v;\\n        for(auto i:d){\\n            int c=0;\\n            for(auto j:n){\\n                if(j%i==0){\\n                    c++;\\n                }\\n            }\\n            if(mx==c){\\n                v.push_back(i);\\n            }\\n        }\\n        sort(v.begin(),v.end());\\n        return v[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779614,
                "title": "kotlin-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    fun maxDivScore(nums: IntArray, divisors: IntArray): Int {\\n        var maxDivisor = divisors.first()\\n        var maxDividedNums = 0\\n\\n        for (divisor in divisors) {\\n            var dividedNums = 0\\n\\n            for (num in nums) {\\n                if (num % divisor == 0)\\n                    dividedNums++\\n            }\\n\\n            if (dividedNums > maxDividedNums) {\\n                maxDividedNums = dividedNums\\n                maxDivisor = divisor\\n            }\\n            \\n            if (dividedNums == maxDividedNums && divisor < maxDivisor)\\n                maxDivisor = divisor\\n        }\\n\\n        return maxDivisor\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun maxDivScore(nums: IntArray, divisors: IntArray): Int {\\n        var maxDivisor = divisors.first()\\n        var maxDividedNums = 0\\n\\n        for (divisor in divisors) {\\n            var dividedNums = 0\\n\\n            for (num in nums) {\\n                if (num % divisor == 0)\\n                    dividedNums++\\n            }\\n\\n            if (dividedNums > maxDividedNums) {\\n                maxDividedNums = dividedNums\\n                maxDivisor = divisor\\n            }\\n            \\n            if (dividedNums == maxDividedNums && divisor < maxDivisor)\\n                maxDivisor = divisor\\n        }\\n\\n        return maxDivisor\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777918,
                "title": "tried-to-optimized",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        sorted_div = sorted(set(divisors))\\n        ans_d, ans_count = sorted_div[0], 0\\n        cnt_n = Counter(nums)\\n        for d in sorted_div:\\n            score = sum(n for num, n in cnt_n.items() if not num % d)\\n            if score > ans_count:\\n                ans_d = d\\n                ans_count = score\\n        return ans_d\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        sorted_div = sorted(set(divisors))\\n        ans_d, ans_count = sorted_div[0], 0\\n        cnt_n = Counter(nums)\\n        for d in sorted_div:\\n            score = sum(n for num, n in cnt_n.items() if not num % d)\\n            if score > ans_count:\\n                ans_d = d\\n                ans_count = score\\n        return ans_d\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3757206,
                "title": "simple-javascript-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} divisors\\n * @return {number}\\n */\\nvar maxDivScore = function(nums, divisors) {\\n    let maxScore = 0;\\n    let result = divisors[0];\\n    for(let divi of divisors){\\n        let score = 0;\\n        for(let num of nums){\\n            if(num % divi === 0) score++;\\n        }\\n        if (score === maxScore) result = Math.min(result, divi);\\n        if(score > maxScore){\\n            maxScore = score\\n            result = divi;\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} divisors\\n * @return {number}\\n */\\nvar maxDivScore = function(nums, divisors) {\\n    let maxScore = 0;\\n    let result = divisors[0];\\n    for(let divi of divisors){\\n        let score = 0;\\n        for(let num of nums){\\n            if(num % divi === 0) score++;\\n        }\\n        if (score === maxScore) result = Math.min(result, divi);\\n        if(score > maxScore){\\n            maxScore = score\\n            result = divi;\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3751919,
                "title": "java-solution-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n*n)\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int ans[]=new int[divisors.length];\\n        for(int i=0;i<divisors.length;i++){\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j]%divisors[i]==0){\\n                    ans[i]++;\\n                }\\n            }\\n        }\\n        int res=0,count=ans[0];\\n        for(int i=1;i<ans.length;i++){\\n            if(count<ans[i]){\\n                count=ans[i];\\n                res=i;\\n            }\\n            else if(count==ans[i]){\\n                if(divisors[res]>divisors[i]){\\n                    res=i;\\n                }\\n            }\\n        }\\n        return divisors[res];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int ans[]=new int[divisors.length];\\n        for(int i=0;i<divisors.length;i++){\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j]%divisors[i]==0){\\n                    ans[i]++;\\n                }\\n            }\\n        }\\n        int res=0,count=ans[0];\\n        for(int i=1;i<ans.length;i++){\\n            if(count<ans[i]){\\n                count=ans[i];\\n                res=i;\\n            }\\n            else if(count==ans[i]){\\n                if(divisors[res]>divisors[i]){\\n                    res=i;\\n                }\\n            }\\n        }\\n        return divisors[res];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739919,
                "title": "using-map",
                "content": "# Complexity\\n- Time complexity:\\nO(n*m)  where n=nums.size() and m=divisors.size()\\n\\n- Space complexity:\\nO(m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        map<int,int>m;\\n        int maxi=0,temp=0;\\n        for(int i=0;i<divisors.size();i++){\\n            int count=0;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j] % divisors[i] ==0)\\n                count++;\\n            }\\n            if(count!=0)\\n            m[divisors[i]]=count;\\n        }\\n        if(m.size()==0){\\n            sort(divisors.begin(),divisors.end());\\n            return divisors[0];\\n        }\\n        for(auto i:m){\\n            if(i.second>maxi){\\n            maxi=i.second;\\n            temp=i.first;\\n            }\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        map<int,int>m;\\n        int maxi=0,temp=0;\\n        for(int i=0;i<divisors.size();i++){\\n            int count=0;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j] % divisors[i] ==0)\\n                count++;\\n            }\\n            if(count!=0)\\n            m[divisors[i]]=count;\\n        }\\n        if(m.size()==0){\\n            sort(divisors.begin(),divisors.end());\\n            return divisors[0];\\n        }\\n        for(auto i:m){\\n            if(i.second>maxi){\\n            maxi=i.second;\\n            temp=i.first;\\n            }\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3737982,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        map<int,int> mp;\\n        for(auto i: divisors){\\n            if(mp[i]>0){\\n                    continue;\\n                }\\n            for(int j: nums){\\n                \\n                if(j%i==0){\\n                    mp[i]++;\\n                }\\n            }\\n        }\\n        int maxi=0;\\n        int ans=INT_MAX;\\n        for(auto i: mp){\\n             maxi=max(maxi,i.second);\\n        }\\n        for(auto i: mp){\\n            if(i.second==maxi){\\n                ans=min(ans,i.first);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        map<int,int> mp;\\n        for(auto i: divisors){\\n            if(mp[i]>0){\\n                    continue;\\n                }\\n            for(int j: nums){\\n                \\n                if(j%i==0){\\n                    mp[i]++;\\n                }\\n            }\\n        }\\n        int maxi=0;\\n        int ans=INT_MAX;\\n        for(auto i: mp){\\n             maxi=max(maxi,i.second);\\n        }\\n        for(auto i: mp){\\n            if(i.second==maxi){\\n                ans=min(ans,i.first);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730311,
                "title": "python-simple-solution-using-zip-function",
                "content": "\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxDivScore(self, nums, divisors):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type divisors: List[int]\\n        :rtype: int\\n        \"\"\"\\n        a=[]\\n        for i in divisors:\\n            c=0\\n            for j in nums:\\n                if j%i==0:\\n                    c=c+1\\n            a.append(c)\\n        if len(set(a))==1:\\n            return min(divisors)\\n        else:\\n            m=10**10\\n            for k,l in zip(divisors,a):\\n                if l==max(a) and k<m:\\n                    m=k\\n            return m\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxDivScore(self, nums, divisors):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type divisors: List[int]\\n        :rtype: int\\n        \"\"\"\\n        a=[]\\n        for i in divisors:\\n            c=0\\n            for j in nums:\\n                if j%i==0:\\n                    c=c+1\\n            a.append(c)\\n        if len(set(a))==1:\\n            return min(divisors)\\n        else:\\n            m=10**10\\n            for k,l in zip(divisors,a):\\n                if l==max(a) and k<m:\\n                    m=k\\n            return m\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3728299,
                "title": "c-beginner-friendly-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N*M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        \\n        int ans = 0;\\n        int dev = INT_MAX;\\n\\n        for(int i=0; i<divisors.size(); i++){\\n            int cnt = 0;\\n            for(int j=0; j<nums.size(); j++){\\n                if(nums[j]%divisors[i] ==0){\\n                    cnt++;\\n                }\\n                if(cnt>ans){\\n                    dev = divisors[i];\\n                    ans = cnt;\\n                }\\n                if(ans == cnt){\\n                    dev = min(divisors[i],dev);\\n                }\\n            }\\n        }\\n        return dev;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        \\n        int ans = 0;\\n        int dev = INT_MAX;\\n\\n        for(int i=0; i<divisors.size(); i++){\\n            int cnt = 0;\\n            for(int j=0; j<nums.size(); j++){\\n                if(nums[j]%divisors[i] ==0){\\n                    cnt++;\\n                }\\n                if(cnt>ans){\\n                    dev = divisors[i];\\n                    ans = cnt;\\n                }\\n                if(ans == cnt){\\n                    dev = min(divisors[i],dev);\\n                }\\n            }\\n        }\\n        return dev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716608,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int minInt = Integer.MAX_VALUE;\\n        int maxCount = 0;\\n        for(int x : divisors) {\\n            int count = 0;\\n            for(int y : nums) {\\n                count += y % x == 0 ? 1 : 0;\\n            }\\n            if(count > maxCount || (count == maxCount && x < minInt)) {\\n                maxCount = count;\\n                minInt = x;\\n            }\\n        }\\n        return minInt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int minInt = Integer.MAX_VALUE;\\n        int maxCount = 0;\\n        for(int x : divisors) {\\n            int count = 0;\\n            for(int y : nums) {\\n                count += y % x == 0 ? 1 : 0;\\n            }\\n            if(count > maxCount || (count == maxCount && x < minInt)) {\\n                maxCount = count;\\n                minInt = x;\\n            }\\n        }\\n        return minInt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713097,
                "title": "simplest-python-solution",
                "content": "# Code\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        nums_count = Counter(nums)\\n        max_div = {}\\n        for d in list(set(divisors)):\\n            div_count = 0\\n            for num in list(set(nums)):\\n                if num%d==0:\\n                    div_count += nums_count[num]\\n            max_div[d] = div_count\\n        max_value = max(max_div.values())\\n        keys = []\\n        for key, value in max_div.items():\\n            if max_value == value:\\n                keys.append(key)\\n        \\n        return min(keys)\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        nums_count = Counter(nums)\\n        max_div = {}\\n        for d in list(set(divisors)):\\n            div_count = 0\\n            for num in list(set(nums)):\\n                if num%d==0:\\n                    div_count += nums_count[num]\\n            max_div[d] = div_count\\n        max_value = max(max_div.values())\\n        keys = []\\n        for key, value in max_div.items():\\n            if max_value == value:\\n                keys.append(key)\\n        \\n        return min(keys)\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3699616,
                "title": "nice-and-elegant-solution-in-java-beats-100-rt-and-98-memory",
                "content": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int current = 0;\\n        int output = Integer.MAX_VALUE;\\n        for (int i : divisors) {\\n            int count = 0;\\n            for (int j : nums) {\\n                if (j % i == 0) {\\n                    count++;\\n                }\\n            }\\n            if (count >= current) {\\n                if (count == current) {\\n                    output = Math.min(i, output);\\n                }\\n                if (count > current) {\\n                    current = count;\\n                    output = i;\\n                }\\n            }\\n        }\\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int current = 0;\\n        int output = Integer.MAX_VALUE;\\n        for (int i : divisors) {\\n            int count = 0;\\n            for (int j : nums) {\\n                if (j % i == 0) {\\n                    count++;\\n                }\\n            }\\n            if (count >= current) {\\n                if (count == current) {\\n                    output = Math.min(i, output);\\n                }\\n                if (count > current) {\\n                    current = count;\\n                    output = i;\\n                }\\n            }\\n        }\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691564,
                "title": "c-brute-force-approach-for-beginners",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int flag=0, temp=0, ans=INT_MAX;\\n        for(int i=0; i<divisors.size(); i++){\\n            for(int j=0; j<nums.size(); j++){\\n                if(nums[j]%divisors[i] == 0) flag++;\\n            }\\n            if(flag>temp){\\n                temp=flag;\\n                ans = divisors[i];\\n            }\\n            if(flag == temp && divisors[i]<ans)\\n            ans = divisors[i];\\n            flag=0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int flag=0, temp=0, ans=INT_MAX;\\n        for(int i=0; i<divisors.size(); i++){\\n            for(int j=0; j<nums.size(); j++){\\n                if(nums[j]%divisors[i] == 0) flag++;\\n            }\\n            if(flag>temp){\\n                temp=flag;\\n                ans = divisors[i];\\n            }\\n            if(flag == temp && divisors[i]<ans)\\n            ans = divisors[i];\\n            flag=0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689076,
                "title": "java-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        \\n        ArrayList<Integer> list = new ArrayList<>();\\n       ArrayList<Integer> finalList = new ArrayList<>();\\n\\n       int j = 0;\\n       while(j<divisors.length){\\n           int i = 0;\\n           int count = 0;\\n           while(i<nums.length){\\n           if(nums[i]%divisors[j] == 0){\\n               count++;\\n           }\\n           i++;\\n        }\\n        list.add(count);\\n           j++;\\n        }\\n\\n        int a = Collections.max(list);\\n        for(int m =0 ; m<list.size(); m++){\\n            if(a == list.get(m)){\\n                finalList.add(divisors[m]);\\n            }\\n        }\\n\\n\\n\\n        return Collections.min(finalList);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        \\n        ArrayList<Integer> list = new ArrayList<>();\\n       ArrayList<Integer> finalList = new ArrayList<>();\\n\\n       int j = 0;\\n       while(j<divisors.length){\\n           int i = 0;\\n           int count = 0;\\n           while(i<nums.length){\\n           if(nums[i]%divisors[j] == 0){\\n               count++;\\n           }\\n           i++;\\n        }\\n        list.add(count);\\n           j++;\\n        }\\n\\n        int a = Collections.max(list);\\n        for(int m =0 ; m<list.size(); m++){\\n            if(a == list.get(m)){\\n                finalList.add(divisors[m]);\\n            }\\n        }\\n\\n\\n\\n        return Collections.min(finalList);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685114,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int c,max=0,d=0,min=Integer.MAX_VALUE;\\n        boolean e=false;\\n        int[] arr=new int[3];\\n        for(int i=0;i<divisors.length;i++)\\n        {\\n            c=0;\\n            for(int j=0;j<nums.length;j++)\\n            {\\n                if(nums[j]%divisors[i]==0)\\n                {\\n                    c++;\\n                   \\n\\n                }\\n\\n            }  \\n             \\n                     if(max<c)\\n                     {\\n                       max=c;\\n                       d=divisors[i]; \\n                       e=true; \\n                     } \\n                     if(max==c)\\n                     {\\n                         if(d>divisors[i] && e)\\n                         d=divisors[i];\\n                     }\\n                     if(min>divisors[i])\\n                     min=divisors[i];\\n                    \\n            \\n        }\\n       \\n       return e?d:min;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int c,max=0,d=0,min=Integer.MAX_VALUE;\\n        boolean e=false;\\n        int[] arr=new int[3];\\n        for(int i=0;i<divisors.length;i++)\\n        {\\n            c=0;\\n            for(int j=0;j<nums.length;j++)\\n            {\\n                if(nums[j]%divisors[i]==0)\\n                {\\n                    c++;\\n                   \\n\\n                }\\n\\n            }  \\n             \\n                     if(max<c)\\n                     {\\n                       max=c;\\n                       d=divisors[i]; \\n                       e=true; \\n                     } \\n                     if(max==c)\\n                     {\\n                         if(d>divisors[i] && e)\\n                         d=divisors[i];\\n                     }\\n                     if(min>divisors[i])\\n                     min=divisors[i];\\n                    \\n            \\n        }\\n       \\n       return e?d:min;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679420,
                "title": "easy-c-solution-beginner-friendly-approach",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& div) {\\n        int ans = -1, val=-1;\\n        for(int i=0; i<div.size(); i++)\\n        {\\n            int count=0;\\n            for(int j=0; j<nums.size(); j++)\\n            {\\n                if((nums[j] % div[i])==0)\\n                    count++;\\n            }\\n            if(val < count){\\n                val = count;\\n                ans = div[i];\\n            }\\n            else if(val == count){\\n                ans = min(ans, div[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& div) {\\n        int ans = -1, val=-1;\\n        for(int i=0; i<div.size(); i++)\\n        {\\n            int count=0;\\n            for(int j=0; j<nums.size(); j++)\\n            {\\n                if((nums[j] % div[i])==0)\\n                    count++;\\n            }\\n            if(val < count){\\n                val = count;\\n                ans = div[i];\\n            }\\n            else if(val == count){\\n                ans = min(ans, div[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3674633,
                "title": "my-java-solution-brute-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        Arrays.sort(divisors);\\n        int maxi=Integer.MIN_VALUE;int cnt=0;int ans=0;\\n       for(int i=0;i<divisors.length;i++){\\n       for(int j=0;j<nums.length;j++){\\n           if(nums[j]%divisors[i]==0){\\n               cnt++;\\n           }\\n       }\\n       if(maxi!=cnt){\\n           maxi=Math.max(maxi,cnt);\\n           if(maxi==cnt){\\nans=divisors[i];\\n           }\\n           }\\n           cnt=0; \\n    }\\n    return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        Arrays.sort(divisors);\\n        int maxi=Integer.MIN_VALUE;int cnt=0;int ans=0;\\n       for(int i=0;i<divisors.length;i++){\\n       for(int j=0;j<nums.length;j++){\\n           if(nums[j]%divisors[i]==0){\\n               cnt++;\\n           }\\n       }\\n       if(maxi!=cnt){\\n           maxi=Math.max(maxi,cnt);\\n           if(maxi==cnt){\\nans=divisors[i];\\n           }\\n           }\\n           cnt=0; \\n    }\\n    return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3666026,
                "title": "java-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int count=0;\\n        int div=divisors[0];\\n        for(int i=0;i<divisors.length;i++){\\n            int m=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j]%divisors[i]==0){\\n                    m++;\\n                }\\n            }\\n            if(m>count){\\n                count=m;\\n                div=divisors[i];\\n            }\\n            if(m==count && divisors[i]<=div){\\n                div=divisors[i];\\n            }\\n        }\\n        return div;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int count=0;\\n        int div=divisors[0];\\n        for(int i=0;i<divisors.length;i++){\\n            int m=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j]%divisors[i]==0){\\n                    m++;\\n                }\\n            }\\n            if(m>count){\\n                count=m;\\n                div=divisors[i];\\n            }\\n            if(m==count && divisors[i]<=div){\\n                div=divisors[i];\\n            }\\n        }\\n        return div;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3661629,
                "title": "python-simple-python-solution",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Approach 1 Using Hash Map :\\n# Runtime: 4896 ms, faster than 34.58% of Python3 online submissions for Find the Maximum Divisibility Score.\\n# Memory Usage: 16.7 MB, less than 5.97% of Python3 online submissions for Find the Maximum Divisibility Score.\\n\\n\\tclass Solution:\\n\\t\\tdef maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n\\n\\t\\t\\tresult , score = float(\\'inf\\') , 0\\n\\n\\t\\t\\thash_map = {}\\n\\n\\t\\t\\tfor num in nums:\\n\\n\\t\\t\\t\\tif num not in hash_map:\\n\\t\\t\\t\\t\\thash_map[num] = 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\thash_map[num] = hash_map[num] + 1\\n\\n\\t\\t\\tfor divisor in divisors:\\n\\n\\t\\t\\t\\tcurrent_score = 0\\n\\n\\t\\t\\t\\tfor key in hash_map:\\n\\n\\t\\t\\t\\t\\tif key % divisor == 0:\\n\\n\\t\\t\\t\\t\\t\\tcurrent_score = current_score + hash_map[key]\\n\\n\\t\\t\\t\\tif current_score == score:\\n\\t\\t\\t\\t\\tresult = min(result, divisor)\\n\\n\\t\\t\\t\\telif current_score > score:\\n\\t\\t\\t\\t\\tresult = divisor\\n\\n\\t\\t\\t\\tscore = max(score, current_score)\\n\\n\\t\\t\\treturn result\\n\\t\\t\\t\\n# Approach 2 Using Brute Force :\\n# Runtime: 4541 ms, faster than 38.63% of Python3 online submissions for Find the Maximum Divisibility Score.\\n# Memory Usage: 16.6 MB, less than 21.44% of Python3 online submissions for Find the Maximum Divisibility Score.\\n\\n\\tclass Solution:\\n\\t\\tdef maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n\\n\\t\\t\\tresult , score = float(\\'inf\\') , 0\\n\\n\\t\\t\\tfor divisor in divisors:\\n\\n\\t\\t\\t\\tcurrent_score = 0\\n\\n\\t\\t\\t\\tfor num in nums:\\n\\n\\t\\t\\t\\t\\tif num % divisor == 0:\\n\\n\\t\\t\\t\\t\\t\\tcurrent_score = current_score + 1\\n\\n\\t\\t\\t\\tif current_score == score:\\n\\t\\t\\t\\t\\tresult = min(result, divisor)\\n\\n\\t\\t\\t\\telif current_score > score:\\n\\t\\t\\t\\t\\tresult = divisor\\n\\n\\t\\t\\t\\tscore = max(score , current_score)\\n\\n\\t\\t\\treturn result\\n\\t\\t\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n\\t\\tdef maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n\\n\\t\\t\\tresult , score = float(\\'inf\\') , 0\\n\\n\\t\\t\\thash_map = {}",
                "codeTag": "Java"
            },
            {
                "id": 3657639,
                "title": "time-complexity-o-m-n-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} divisors\\n * @return {number}\\n */\\nvar maxDivScore = function(nums, divisors) {\\n    let maxTimeDvd = 0;\\n    let res = Infinity;\\n    \\n    for (let i = 0; i < divisors.length; i++){\\n        let currentDvd = 0;\\n        for (let j = 0; j < nums.length; j++){\\n            if (nums[j] % divisors[i] === 0) \\n                currentDvd++;\\n\\n            if (currentDvd > maxTimeDvd) {\\n                maxTimeDvd = currentDvd;\\n                res = divisors[i]\\n            }\\n            if (currentDvd === maxTimeDvd  && res > divisors[i])\\n                res = divisors[i]\\n        }\\n    }\\n\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} divisors\\n * @return {number}\\n */\\nvar maxDivScore = function(nums, divisors) {\\n    let maxTimeDvd = 0;\\n    let res = Infinity;\\n    \\n    for (let i = 0; i < divisors.length; i++){\\n        let currentDvd = 0;\\n        for (let j = 0; j < nums.length; j++){\\n            if (nums[j] % divisors[i] === 0) \\n                currentDvd++;\\n\\n            if (currentDvd > maxTimeDvd) {\\n                maxTimeDvd = currentDvd;\\n                res = divisors[i]\\n            }\\n            if (currentDvd === maxTimeDvd  && res > divisors[i])\\n                res = divisors[i]\\n        }\\n    }\\n\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3657333,
                "title": "java-beats-96-22-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int ans = divisors[0];\\n        int div = 0;\\n        for(int i = 0;i < divisors.length;i++){\\n            int n = 0;\\n            for(int j = 0;j < nums.length;j++){\\n                if(nums[j]%divisors[i] == 0)\\n                    n++;\\n            }\\n            if(div < n){\\n                div = n;\\n                ans = divisors[i];\\n            }\\n            else if(div == n && ans > divisors[i])\\n                ans = divisors[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int ans = divisors[0];\\n        int div = 0;\\n        for(int i = 0;i < divisors.length;i++){\\n            int n = 0;\\n            for(int j = 0;j < nums.length;j++){\\n                if(nums[j]%divisors[i] == 0)\\n                    n++;\\n            }\\n            if(div < n){\\n                div = n;\\n                ans = divisors[i];\\n            }\\n            else if(div == n && ans > divisors[i])\\n                ans = divisors[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647617,
                "title": "simple-and-easy-to-understand-clear-explanation-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO (n^2)\\n\\n- Space complexity:\\nO (1)\\n\\n# Code\\n```\\nclass Solution:\\n    def maxDivScore(self, nums, divisors):\\n        score=0\\n        val=divisors[0]    # taking val as first value , beacause if divisibility score of all elements is 0 we have to give one value\\n        for i in divisors:\\n            count=0\\n            for j in nums:\\n                if j%i==0:\\n                    count+=1\\n            if count>score:\\n                score=count\\n                val=i       # if divisbility score is greter than score then value will be element ,\\n            elif count==score:\\n                score=count\\n                val=min(val,i)   # if divisbility score is equal or both Zero , we take minimum element\\n        return val\\nobj=Solution()\\nobj.maxDivScore([20,14,21,10],[5,7,5])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDivScore(self, nums, divisors):\\n        score=0\\n        val=divisors[0]    # taking val as first value , beacause if divisibility score of all elements is 0 we have to give one value\\n        for i in divisors:\\n            count=0\\n            for j in nums:\\n                if j%i==0:\\n                    count+=1\\n            if count>score:\\n                score=count\\n                val=i       # if divisbility score is greter than score then value will be element ,\\n            elif count==score:\\n                score=count\\n                val=min(val,i)   # if divisbility score is equal or both Zero , we take minimum element\\n        return val\\nobj=Solution()\\nobj.maxDivScore([20,14,21,10],[5,7,5])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3645182,
                "title": "java-o-n-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n*n)\\n- Space complexity:\\nO(n)\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n\\n        for(int i = 0 ; i < divisors.length ; i++){\\n            int score = 0;\\n            for(int j = 0 ; j < nums.length ; j++){\\n                if(nums[j] % divisors[i] == 0){\\n                    score++;\\n                }\\n            }\\n            map.put(divisors[i],score);\\n        }\\n\\n        int ans = -1;\\n        int max_score = 0;\\n\\n        for (Integer key : map.keySet()) {\\n            Integer value = map.get(key);\\n            if(value > max_score){\\n                max_score = value;\\n                ans = key;\\n            }else if(value == max_score && ans > key){\\n                ans = key;\\n            }\\n        }\\n\\n        if(ans == -1){\\n            return Arrays.stream(divisors).min().getAsInt();\\n        }\\n\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n\\n        for(int i = 0 ; i < divisors.length ; i++){\\n            int score = 0;\\n            for(int j = 0 ; j < nums.length ; j++){\\n                if(nums[j] % divisors[i] == 0){\\n                    score++;\\n                }\\n            }\\n            map.put(divisors[i],score);\\n        }\\n\\n        int ans = -1;\\n        int max_score = 0;\\n\\n        for (Integer key : map.keySet()) {\\n            Integer value = map.get(key);\\n            if(value > max_score){\\n                max_score = value;\\n                ans = key;\\n            }else if(value == max_score && ans > key){\\n                ans = key;\\n            }\\n        }\\n\\n        if(ans == -1){\\n            return Arrays.stream(divisors).min().getAsInt();\\n        }\\n\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3635185,
                "title": "trivial-c-beats-100",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        auto result = 0, ma = -1;\\n        sort(begin(divisors), end(divisors));\\n        for (const auto& divisor : divisors) {\\n            auto count = 0;\\n            for (const auto& num : nums)\\n                if (num % divisor == 0)\\n                    ++count;\\n            if (count > ma) {\\n                ma = count;\\n                result = divisor;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        auto result = 0, ma = -1;\\n        sort(begin(divisors), end(divisors));\\n        for (const auto& divisor : divisors) {\\n            auto count = 0;\\n            for (const auto& num : nums)\\n                if (num % divisor == 0)\\n                    ++count;\\n            if (count > ma) {\\n                ma = count;\\n                result = divisor;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3583234,
                "title": "easy-java-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int max=-1;\\n        int ans=0;\\n        for(int i=0;i<divisors.length;i++){\\n            int div=divisors[i];\\n            int count=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j]%div==0)\\n                    count++;\\n            }\\n            \\n            if(count>max){\\n                max=count;\\n                ans=div;\\n            }\\n            if(count==max){\\n                if(div<ans)\\n                    ans=div;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int max=-1;\\n        int ans=0;\\n        for(int i=0;i<divisors.length;i++){\\n            int div=divisors[i];\\n            int count=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j]%div==0)\\n                    count++;\\n            }\\n            \\n            if(count>max){\\n                max=count;\\n                ans=div;\\n            }\\n            if(count==max){\\n                if(div<ans)\\n                    ans=div;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567984,
                "title": "easy-to-understand-max-min",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& div) {\\n        int maxi=INT_MIN,x,m=INT_MAX;\\n       for(int i=0;i<div.size();i++)\\n       {\\n           int count=0;\\n           for(int j=0;j<nums.size();j++)\\n           {\\n               if(nums[j]%div[i]==0)\\n                count++;\\n           }\\n           if(maxi==count)\\n           {\\n               x=min(div[i],x);\\n           }\\n           if(maxi<count)\\n           {\\n               maxi=count;\\n               x=div[i];\\n           } \\n           \\n       } \\n       return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& div) {\\n        int maxi=INT_MIN,x,m=INT_MAX;\\n       for(int i=0;i<div.size();i++)\\n       {\\n           int count=0;\\n           for(int j=0;j<nums.size();j++)\\n           {\\n               if(nums[j]%div[i]==0)\\n                count++;\\n           }\\n           if(maxi==count)\\n           {\\n               x=min(div[i],x);\\n           }\\n           if(maxi<count)\\n           {\\n               maxi=count;\\n               x=div[i];\\n           } \\n           \\n       } \\n       return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3552046,
                "title": "find-the-maximum-divisibility-score",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        divisors = sorted(list(set(divisors)))\\n        res_divisor = divisors[0]\\n        res_score = 0\\n        for i in range(len(divisors)):\\n            score = 0\\n            for x in nums:\\n                if x % divisors[i] == 0:\\n                    score += 1\\n            if score > res_score:\\n                res_score = score\\n                res_divisor = divisors[i]\\n        return res_divisor\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        divisors = sorted(list(set(divisors)))\\n        res_divisor = divisors[0]\\n        res_score = 0\\n        for i in range(len(divisors)):\\n            score = 0\\n            for x in nums:\\n                if x % divisors[i] == 0:\\n                    score += 1\\n            if score > res_score:\\n                res_score = score\\n                res_divisor = divisors[i]\\n        return res_divisor\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538823,
                "title": "find-the-maximum-divisibility-score",
                "content": "# Intuition\\nEasy Solotion| Beats 94.23% in runtime\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int max=divisors[0];\\n        int maxscore=0;\\n        for(int i=0;i<divisors.length;i++){\\n            int score=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j]%divisors[i] == 0){\\n                    score++;\\n                }\\n            }\\n            if(score>maxscore){\\n                maxscore=score;\\n                max=divisors[i];\\n            }else if(score==maxscore){\\n                max=Math.min(max,divisors[i]);\\n            }\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int max=divisors[0];\\n        int maxscore=0;\\n        for(int i=0;i<divisors.length;i++){\\n            int score=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j]%divisors[i] == 0){\\n                    score++;\\n                }\\n            }\\n            if(score>maxscore){\\n                maxscore=score;\\n                max=divisors[i];\\n            }else if(score==maxscore){\\n                max=Math.min(max,divisors[i]);\\n            }\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535060,
                "title": "python3-nested-loop-based-solution-o-n-2-complexity-beats-97-3-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        res, lst = 0, []\\n        for div in set(divisors):\\n            curr = 0\\n            for n in nums:\\n                if not n % div:\\n                    curr += 1\\n            if curr > res:\\n                res = curr\\n                lst = [div]\\n            elif curr == res:\\n                lst.append(div)\\n        return min(lst)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        res, lst = 0, []\\n        for div in set(divisors):\\n            curr = 0\\n            for n in nums:\\n                if not n % div:\\n                    curr += 1\\n            if curr > res:\\n                res = curr\\n                lst = [div]\\n            elif curr == res:\\n                lst.append(div)\\n        return min(lst)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3532399,
                "title": "c-simple-loop-372ms-935",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int MaxDivScore(int[] nums, int[] divisors) \\n    {\\n        var maxDivIdx = 0;\\n        var maxDivCount = int.MinValue;\\n\\n        for(var i = 0; i < divisors.Length; i++)    \\n        {\\n            var count = 0;\\n\\n            foreach(var n in nums)\\n                if(n % divisors[i] == 0) count++;\\n\\n            if(maxDivCount < count)\\n            {\\n                maxDivIdx = i;\\n                maxDivCount = count;\\n            }\\n            else if(maxDivCount == count && divisors[maxDivIdx] > divisors[i])\\n            {\\n                maxDivIdx = i;\\n            }\\n        }\\n\\n        return divisors[maxDivIdx];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxDivScore(int[] nums, int[] divisors) \\n    {\\n        var maxDivIdx = 0;\\n        var maxDivCount = int.MinValue;\\n\\n        for(var i = 0; i < divisors.Length; i++)    \\n        {\\n            var count = 0;\\n\\n            foreach(var n in nums)\\n                if(n % divisors[i] == 0) count++;\\n\\n            if(maxDivCount < count)\\n            {\\n                maxDivIdx = i;\\n                maxDivCount = count;\\n            }\\n            else if(maxDivCount == count && divisors[maxDivIdx] > divisors[i])\\n            {\\n                maxDivIdx = i;\\n            }\\n        }\\n\\n        return divisors[maxDivIdx];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531467,
                "title": "divisor-dilemma-score-more-soar-with-the-smallest-score",
                "content": "# Intuition\\nThe problem is asking us to calculate the divisibility score for each divisor, and return the one with the highest score. If there are multiple divisors with the highest score, we should return the smallest one. Given that we need to compare each number in the nums array with each number in the divisors array, a brute force approach with nested loops immediately comes to mind.\\n\\n# Approach\\nThe approach here involves iterating over each divisor, and for each divisor, iterating over each number in nums to check if it\\'s divisible by that divisor. We maintain two variables, maxScore and minDivisor to track the divisor with the maximum divisibility score and the minimum divisor (in case of a tie in scores).\\n\\nHere\\'s a step-by-step breakdown:\\n\\n1. Initialize maxScore to 0 and minDivisor to Infinity.\\n2. For each divisor in divisors, initialize score to 0.\\n3. For each num in nums, if num is divisible by divisor (num % divisor === 0), increment score.\\n4. After calculating score for a divisor, check if it is greater than maxScore, or if it is equal to maxScore and divisor is less than minDivisor. If either is true, update maxScore and minDivisor to the current score and divisor respectively.\\n5. After iterating over all divisors, return minDivisor.\\n\\n# Complexity\\n- Time complexity: The time complexity is O(n*m), where n is the length of the nums array and m is the length of the divisors array. This is because for each divisor, we iterate over all numbers.\\n\\n- Space complexity: The space complexity is O(1), because no additional space is used that scales with the input size. The variables maxScore, minDivisor, and score take constant space.\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} divisors\\n * @return {number}\\n */\\nfunction maxDivScore (nums, divisors) {\\n    let maxScore = 0;\\n    let minDivisor = Infinity;\\n    for (let divisor of divisors) {\\n        let score = 0;\\n        for (let num of nums) {\\n            if (num % divisor === 0) {\\n                score++;\\n            }\\n        }\\n        if (score > maxScore || (score === maxScore && divisor < minDivisor)) {\\n            maxScore = score;\\n            minDivisor = divisor;\\n        }\\n    }\\n    return minDivisor;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} divisors\\n * @return {number}\\n */\\nfunction maxDivScore (nums, divisors) {\\n    let maxScore = 0;\\n    let minDivisor = Infinity;\\n    for (let divisor of divisors) {\\n        let score = 0;\\n        for (let num of nums) {\\n            if (num % divisor === 0) {\\n                score++;\\n            }\\n        }\\n        if (score > maxScore || (score === maxScore && divisor < minDivisor)) {\\n            maxScore = score;\\n            minDivisor = divisor;\\n        }\\n    }\\n    return minDivisor;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3523371,
                "title": "elixir-my-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ndefmodule Solution do\\n  @spec max_div_score(nums :: [integer], divisors :: [integer]) :: integer\\n  def max_div_score(nums, divisors) do\\n    divisors |>\\n      Enum.reduce({-1, -1}, fn divisor, {ans, max_cnt} ->\\n        cnt =\\n          Enum.reduce(nums, 0, fn num, cnt ->\\n            if rem(num, divisor) == 0 do\\n              cnt + 1\\n            else\\n              cnt\\n            end\\n          end)\\n        cond do\\n          cnt > max_cnt ->\\n            {divisor, cnt}\\n          cnt == max_cnt ->\\n            {min(ans, divisor), cnt}\\n          true ->\\n            {ans, max_cnt}\\n        end\\n      end) |> elem(0)\\n  end\\nend\\n\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```\\ndefmodule Solution do\\n  @spec max_div_score(nums :: [integer], divisors :: [integer]) :: integer\\n  def max_div_score(nums, divisors) do\\n    divisors |>\\n      Enum.reduce({-1, -1}, fn divisor, {ans, max_cnt} ->\\n        cnt =\\n          Enum.reduce(nums, 0, fn num, cnt ->\\n            if rem(num, divisor) == 0 do\\n              cnt + 1\\n            else\\n              cnt\\n            end\\n          end)\\n        cond do\\n          cnt > max_cnt ->\\n            {divisor, cnt}\\n          cnt == max_cnt ->\\n            {min(ans, divisor), cnt}\\n          true ->\\n            {ans, max_cnt}\\n        end\\n      end) |> elem(0)\\n  end\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3517404,
                "title": "js-solution",
                "content": "\\n```\\n\\nconst maxDivScore = function (nums, divisors) {\\n  let output = 0;\\n  let maxCount = 0\\n  let count = 0;\\n\\n  for (const div of divisors) {\\n    \\n    for (const num of nums) {\\n      if (num % div === 0) count++;\\n    }\\n    \\n    if (count > maxCount) {\\n      maxCount = count\\n      output = div\\n    }\\n\\n    else if (count === maxCount && div < output) {\\n      output = div\\n    }\\n\\n    count = 0;\\n  }\\n\\n  return output || Math.min(...divisors)\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nconst maxDivScore = function (nums, divisors) {\\n  let output = 0;\\n  let maxCount = 0\\n  let count = 0;\\n\\n  for (const div of divisors) {\\n    \\n    for (const num of nums) {\\n      if (num % div === 0) count++;\\n    }\\n    \\n    if (count > maxCount) {\\n      maxCount = count\\n      output = div\\n    }\\n\\n    else if (count === maxCount && div < output) {\\n      output = div\\n    }\\n\\n    count = 0;\\n  }\\n\\n  return output || Math.min(...divisors)\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3513370,
                "title": "very-easy-jebasraja",
                "content": "# Intuition:Karunya university:ACCENTURE\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) \\n    {\\n        \\n        int max=-1;\\n\\nint count=0;\\n\\nint dividing=0;\\n\\nint notdividebyanyvalue=2147483647;\\n\\nfor (int i = 0; i < divisors.length; i++)\\n {\\n    for (int j = 0; j < nums.length; j++) \\n    {\\n        if (nums[j]%divisors[i]==0) \\n        {\\n            \\n            count++;\\n        \\n            if (count==max) \\n            {\\n                if (divisors[i]<dividing) \\n                {\\n                  count=max;\\n                  dividing=divisors[i];  \\n                }\\n                //max=count;\\n            }\\n\\n            else if (count>max) \\n            {\\n                max=count;\\n                dividing=divisors[i];\\n            }\\n        }\\n        else\\n        {\\n            if (divisors[i]<notdividebyanyvalue) \\n            {\\n                notdividebyanyvalue=divisors[i];\\n            }\\n        }\\n    }\\n    count=0;\\n}\\n\\nif (dividing==0)\\n{\\n   //System.out.println(notdividebyanyvalue); \\n    \\n   return notdividebyanyvalue;\\n}\\nelse\\n{\\n    return dividing;\\n    //System.out.println(dividing);\\n    //System.out.println(dividing);\\n}\\n\\n\\n\\n\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) \\n    {\\n        \\n        int max=-1;\\n\\nint count=0;\\n\\nint dividing=0;\\n\\nint notdividebyanyvalue=2147483647;\\n\\nfor (int i = 0; i < divisors.length; i++)\\n {\\n    for (int j = 0; j < nums.length; j++) \\n    {\\n        if (nums[j]%divisors[i]==0) \\n        {\\n            \\n            count++;\\n        \\n            if (count==max) \\n            {\\n                if (divisors[i]<dividing) \\n                {\\n                  count=max;\\n                  dividing=divisors[i];  \\n                }\\n                //max=count;\\n            }\\n\\n            else if (count>max) \\n            {\\n                max=count;\\n                dividing=divisors[i];\\n            }\\n        }\\n        else\\n        {\\n            if (divisors[i]<notdividebyanyvalue) \\n            {\\n                notdividebyanyvalue=divisors[i];\\n            }\\n        }\\n    }\\n    count=0;\\n}\\n\\nif (dividing==0)\\n{\\n   //System.out.println(notdividebyanyvalue); \\n    \\n   return notdividebyanyvalue;\\n}\\nelse\\n{\\n    return dividing;\\n    //System.out.println(dividing);\\n    //System.out.println(dividing);\\n}\\n\\n\\n\\n\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3509322,
                "title": "c-easy-linear-time-constant-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int n=nums.size(),m=divisors.size();\\n        int ans=1e9;\\n        int finalcount=-1e9;\\n        for(int i=0;i<m;i++){\\n            int cnt=0;\\n            for(int j=0;j<n;j++){\\n                if(nums[j]%divisors[i]==0) cnt++;\\n            }\\n            if(cnt>finalcount){\\n                ans=divisors[i];\\n                finalcount=cnt;\\n            }\\n            else if(cnt==finalcount) ans=min(ans,divisors[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int n=nums.size(),m=divisors.size();\\n        int ans=1e9;\\n        int finalcount=-1e9;\\n        for(int i=0;i<m;i++){\\n            int cnt=0;\\n            for(int j=0;j<n;j++){\\n                if(nums[j]%divisors[i]==0) cnt++;\\n            }\\n            if(cnt>finalcount){\\n                ans=divisors[i];\\n                finalcount=cnt;\\n            }\\n            else if(cnt==finalcount) ans=min(ans,divisors[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3509175,
                "title": "optimized-solution-space-o-1-c-c",
                "content": "# Complexity\\n- Time complexity:\\n**O(N*K)**\\n- Space complexity:\\n**O(1)**\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int max=INT_MIN,ans=INT_MAX;\\n        for(int i=0;i<divisors.size();i++){\\n            int count=0,x=divisors[i];\\n            for(int j:nums){\\n                if(j%x==0) count++;\\n            }\\n            if(count>max){\\n                max=count;\\n                ans=x;\\n            }\\n            else if(count==max){\\n                if(x<ans) ans=x;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int max=INT_MIN,ans=INT_MAX;\\n        for(int i=0;i<divisors.size();i++){\\n            int count=0,x=divisors[i];\\n            for(int j:nums){\\n                if(j%x==0) count++;\\n            }\\n            if(count>max){\\n                max=count;\\n                ans=x;\\n            }\\n            else if(count==max){\\n                if(x<ans) ans=x;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3504046,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int c,max,ans;\\n        max=Integer.MIN_VALUE;\\n        ans=0;\\n        Arrays.sort(divisors);\\n        for(int i=0;i<divisors.length;i++)\\n        {\\n            c=0;\\n            for(int j=0;j<nums.length;j++)\\n            {\\n                if(nums[j]%divisors[i]==0)\\n                {\\n                    c++;\\n                }\\n            }\\n            if(c>max)\\n            {\\n                max=c;\\n                ans=divisors[i];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int c,max,ans;\\n        max=Integer.MIN_VALUE;\\n        ans=0;\\n        Arrays.sort(divisors);\\n        for(int i=0;i<divisors.length;i++)\\n        {\\n            c=0;\\n            for(int j=0;j<nums.length;j++)\\n            {\\n                if(nums[j]%divisors[i]==0)\\n                {\\n                    c++;\\n                }\\n            }\\n            if(c>max)\\n            {\\n                max=c;\\n                ans=divisors[i];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502814,
                "title": "dictionary-sort-python-solution",
                "content": "This question is similar to [2404. Most Frequent Even Element](https://leetcode.com/problems/most-frequent-even-element/solutions/3502776/dictionary-sort-python-solution/).\\n\\n# Code\\n```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        d = {}\\n        for di in divisors:\\n            if di not in d:\\n                c = 0\\n                for n in nums:\\n                    if n % di == 0:\\n                        c += 1\\n                d[di] = c\\n        return sorted([[k, v] for k, v in d.items()], key=lambda x: (-x[1], x[0]))[0][0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        d = {}\\n        for di in divisors:\\n            if di not in d:\\n                c = 0\\n                for n in nums:\\n                    if n % di == 0:\\n                        c += 1\\n                d[di] = c\\n        return sorted([[k, v] for k, v in d.items()], key=lambda x: (-x[1], x[0]))[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3500317,
                "title": "c-brute-force-easy-understandable",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n            int ans=0;\\n            int maxi=0;\\n            vector<int>answ;\\n        for(int i =0; i<divisors.size(); i++){\\n              int count =0;\\n            int num = divisors[i];\\n            for(int j=0 ;j<nums.size();j++){\\n                if(nums[j]%num==0){\\n                    count++;\\n                }\\n            }\\n                if(ans == count){\\n                        maxi = maxi == 0 ? num : min(maxi,num);\\n                }\\n                else if(count>ans){\\n                        ans = count;\\n                        maxi = num;\\n                }\\n            \\n        }\\n    \\n        return maxi;\\n    }\\n}; \\n\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n            int ans=0;\\n            int maxi=0;\\n            vector<int>answ;\\n        for(int i =0; i<divisors.size(); i++){\\n              int count =0;\\n            int num = divisors[i];\\n            for(int j=0 ;j<nums.size();j++){\\n                if(nums[j]%num==0){\\n                    count++;\\n                }\\n            }\\n                if(ans == count){\\n                        maxi = maxi == 0 ? num : min(maxi,num);\\n                }\\n                else if(count>ans){\\n                        ans = count;\\n                        maxi = num;\\n                }\\n            \\n        }\\n    \\n        return maxi;\\n    }\\n}; \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3489246,
                "title": "bruteforce-short-and-simple",
                "content": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) \\n    {\\n        int maxCount=Integer.MIN_VALUE;\\n        int ans=Integer.MIN_VALUE;\\n        for(int i=0;i<divisors.length;i++)\\n        {\\n            int count=0;\\n            for(int j=0;j<nums.length;j++)\\n            {\\n                if(nums[j]%divisors[i]==0)\\n                    count++;\\n            }\\n            if(count>maxCount)\\n            {\\n                maxCount=count;\\n                ans=divisors[i];\\n            }\\n            else if(count==maxCount)\\n            {\\n                ans=Math.min(ans,divisors[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) \\n    {\\n        int maxCount=Integer.MIN_VALUE;\\n        int ans=Integer.MIN_VALUE;\\n        for(int i=0;i<divisors.length;i++)\\n        {\\n            int count=0;\\n            for(int j=0;j<nums.length;j++)\\n            {\\n                if(nums[j]%divisors[i]==0)\\n                    count++;\\n            }\\n            if(count>maxCount)\\n            {\\n                maxCount=count;\\n                ans=divisors[i];\\n            }\\n            else if(count==maxCount)\\n            {\\n                ans=Math.min(ans,divisors[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484618,
                "title": "easy-to-understand-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int max_count = 0;\\n        int max_divisor = divisors[0];\\n        for(int divisor: divisors){\\n\\n            int count = 0;\\n            //checking for no of divisible nos.\\n            for(int number: nums){\\n                if(number % divisor == 0){\\n                    count ++;\\n                }\\n            }\\n            // checking is it the max count\\n            if(count > max_count ){\\n                max_count = count;\\n                max_divisor = divisor;\\n            }\\n            // if same count checking is it the minimum\\n            else if (count == max_count){\\n                if (max_divisor > divisor){\\n                    max_divisor = divisor;\\n                }\\n            }\\n        }\\n        return max_divisor;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int max_count = 0;\\n        int max_divisor = divisors[0];\\n        for(int divisor: divisors){\\n\\n            int count = 0;\\n            //checking for no of divisible nos.\\n            for(int number: nums){\\n                if(number % divisor == 0){\\n                    count ++;\\n                }\\n            }\\n            // checking is it the max count\\n            if(count > max_count ){\\n                max_count = count;\\n                max_divisor = divisor;\\n            }\\n            // if same count checking is it the minimum\\n            else if (count == max_count){\\n                if (max_divisor > divisor){\\n                    max_divisor = divisor;\\n                }\\n            }\\n        }\\n        return max_divisor;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483863,
                "title": "java-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int maxDivScore(int[] nums, int[] divisors) {\\n    int maxi = -1, div = -1;\\n\\n    for(int d: divisors){\\n      int t = 0;\\n      for(int n: nums)\\n        if(n % d == 0) ++t;\\n      if(t > maxi) {maxi = t; div = d;}\\n      else if(t == maxi) div = div > d ? d : div;\\n    }\\n\\n    return div;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int maxDivScore(int[] nums, int[] divisors) {\\n    int maxi = -1, div = -1;\\n\\n    for(int d: divisors){\\n      int t = 0;\\n      for(int n: nums)\\n        if(n % d == 0) ++t;\\n      if(t > maxi) {maxi = t; div = d;}\\n      else if(t == maxi) div = div > d ? d : div;\\n    }\\n\\n    return div;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483665,
                "title": "brute-force-functional-style",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(m * n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nfunction maxDivScore(nums: number[], divisors: number[]): number {\\n  // Calculate the number of elements in `nums` that are divisible by each divisor\\n  const scores = divisors.reduce(\\n    (score: number[], divisor, idx) => {\\n      // Iterate over each element in `nums` and check if it is divisible by the current divisor\\n      nums.forEach((num) => {\\n        if (num % divisor === 0) score[idx] += 1;\\n      });\\n\\n      return score;\\n    },\\n    // Initialize the `score` array with zeros\\n    Array.from({ length: divisors.length }).map((_) => 0)\\n  );\\n\\n  // Find the maximum score\\n  const maxScore = Math.max(...scores);\\n  // Find the indices of the scores that are tied for the maximum score\\n  const tiedScoresIdxs = scores.reduce((acc: number[], score, idx) => {\\n    score === maxScore ? acc.push(idx) : acc;\\n\\n    return acc;\\n  }, []);\\n  // Map the tied score indices to their corresponding divisors\\n  const tiedScores = tiedScoresIdxs.map((scoreIdx) => divisors[scoreIdx]);\\n\\n  // Return the smallest tied score\\n  return Math.min(...tiedScores);\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction maxDivScore(nums: number[], divisors: number[]): number {\\n  // Calculate the number of elements in `nums` that are divisible by each divisor\\n  const scores = divisors.reduce(\\n    (score: number[], divisor, idx) => {\\n      // Iterate over each element in `nums` and check if it is divisible by the current divisor\\n      nums.forEach((num) => {\\n        if (num % divisor === 0) score[idx] += 1;\\n      });\\n\\n      return score;\\n    },\\n    // Initialize the `score` array with zeros\\n    Array.from({ length: divisors.length }).map((_) => 0)\\n  );\\n\\n  // Find the maximum score\\n  const maxScore = Math.max(...scores);\\n  // Find the indices of the scores that are tied for the maximum score\\n  const tiedScoresIdxs = scores.reduce((acc: number[], score, idx) => {\\n    score === maxScore ? acc.push(idx) : acc;\\n\\n    return acc;\\n  }, []);\\n  // Map the tied score indices to their corresponding divisors\\n  const tiedScores = tiedScoresIdxs.map((scoreIdx) => divisors[scoreIdx]);\\n\\n  // Return the smallest tied score\\n  return Math.min(...tiedScores);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3480048,
                "title": "java-simple-solution-bruteforce-counting",
                "content": "# Complexity\\n- Time complexity: $$O(m * n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int maxScore = 0;\\n        int divisorWithMaxScore = divisors[0];\\n        for (int divisor : divisors) {\\n            int currentScore = 0;\\n            for (int num : nums) {\\n                if (num % divisor == 0) {\\n                    currentScore++;\\n                }\\n            }\\n\\n            if (currentScore > maxScore) {\\n                maxScore = currentScore;\\n                divisorWithMaxScore = divisor;\\n            } else if (currentScore == maxScore) {\\n                divisorWithMaxScore = Math.min(divisorWithMaxScore, divisor);\\n            }\\n        }\\n\\n        return divisorWithMaxScore;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int maxScore = 0;\\n        int divisorWithMaxScore = divisors[0];\\n        for (int divisor : divisors) {\\n            int currentScore = 0;\\n            for (int num : nums) {\\n                if (num % divisor == 0) {\\n                    currentScore++;\\n                }\\n            }\\n\\n            if (currentScore > maxScore) {\\n                maxScore = currentScore;\\n                divisorWithMaxScore = divisor;\\n            } else if (currentScore == maxScore) {\\n                divisorWithMaxScore = Math.min(divisorWithMaxScore, divisor);\\n            }\\n        }\\n\\n        return divisorWithMaxScore;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3479671,
                "title": "brute-force-approach-easy-understanding",
                "content": "``\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& n, vector<int>& d) {\\n        int mxCnt=-1,ans=-1;\\n        for(int i=0;i<d.size();i++){\\n            int cnt=0;\\n            for(int j=0;j<n.size();j++){\\n                if(n[j]%d[i]==0){\\n                    cnt++;\\n                }\\n            }\\n            if(cnt>mxCnt){\\n                mxCnt=cnt;\\n                ans=d[i];\\n            }else if(mxCnt==cnt){\\n                ans=min(ans,d[i]);\\n            }\\n            cnt=0;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Array"
                ],
                "code": "class Solution {\\npublic:\\n    int maxDivScore(vector<int>& n, vector<int>& d) {\\n        int mxCnt=-1,ans=-1;\\n        for(int i=0;i<d.size();i++){\\n            int cnt=0;\\n            for(int j=0;j<n.size();j++){\\n                if(n[j]%d[i]==0){\\n                    cnt++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3479097,
                "title": "c-brute-force-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int maxi=-1;\\n        int ans=-1;\\n        for(auto div:divisors){\\n            int cnt=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]%div==0){\\n                cnt++;\\n            }\\n        }\\n        if(maxi<cnt){\\n            maxi=cnt;\\n            ans=div;\\n        }\\n        else if(maxi==cnt){\\n            ans=ans<div?ans:div;\\n        }\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int maxi=-1;\\n        int ans=-1;\\n        for(auto div:divisors){\\n            int cnt=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]%div==0){\\n                cnt++;\\n            }\\n        }\\n        if(maxi<cnt){\\n            maxi=cnt;\\n            ans=div;\\n        }\\n        else if(maxi==cnt){\\n            ans=ans<div?ans:div;\\n        }\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471227,
                "title": "java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        \\n        int maxScore = -1;\\n        int ans = 0;\\n        \\n        for(int d: divisors){\\n            int count = 0;\\n            for(int i : nums){\\n                if(i % d == 0){\\n                    count++;\\n                }\\n            }\\n            if(count > maxScore){\\n                maxScore = count;\\n                ans = d;\\n            } else if(count == maxScore && ans > d){\\n                ans = d;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        \\n        int maxScore = -1;\\n        int ans = 0;\\n        \\n        for(int d: divisors){\\n            int count = 0;\\n            for(int i : nums){\\n                if(i % d == 0){\\n                    count++;\\n                }\\n            }\\n            if(count > maxScore){\\n                maxScore = count;\\n                ans = d;\\n            } else if(count == maxScore && ans > d){\\n                ans = d;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470255,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        Arrays.sort(divisors);\\n        int ans = 0;\\n        int ans1 = divisors[0];\\n        for(int i = 0; i < divisors.length; i++){\\n            int count = 0;\\n            for(int j = 0; j < nums.length; j++){\\n                    if(nums[j] % divisors[i] == 0){\\n                        count++;\\n                    }\\n                     if(ans < count){\\n                ans = count;\\n                ans1 = divisors[i];\\n            }\\n            }\\n           \\n        }\\n        return ans1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        Arrays.sort(divisors);\\n        int ans = 0;\\n        int ans1 = divisors[0];\\n        for(int i = 0; i < divisors.length; i++){\\n            int count = 0;\\n            for(int j = 0; j < nums.length; j++){\\n                    if(nums[j] % divisors[i] == 0){\\n                        count++;\\n                    }\\n                     if(ans < count){\\n                ans = count;\\n                ans1 = divisors[i];\\n            }\\n            }\\n           \\n        }\\n        return ans1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3465651,
                "title": "easy-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int val = divisors[0];\\n        int max = -1;\\n\\n        for(int i : divisors){\\n            int count = 0;\\n            for(int j : nums){\\n                if(j%i == 0){\\n                    count++;\\n                }\\n            }\\n\\n            if(count == max){\\n                val = val > i ? i : val;\\n            }\\n\\n            if(count > max){\\n                max = count;\\n                val = i;\\n            }\\n        }\\n\\n        return val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int val = divisors[0];\\n        int max = -1;\\n\\n        for(int i : divisors){\\n            int count = 0;\\n            for(int j : nums){\\n                if(j%i == 0){\\n                    count++;\\n                }\\n            }\\n\\n            if(count == max){\\n                val = val > i ? i : val;\\n            }\\n\\n            if(count > max){\\n                max = count;\\n                val = i;\\n            }\\n        }\\n\\n        return val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464748,
                "title": "java-sorting-explained",
                "content": "**Idea:**\\n* Brute force count score for each divisor and take the min of such divisors which have the max score\\n* Extra space is taken by Arrays.sort. \\n* Sorting is not required but required for binary search\\n* Sorting doesn\\'t effect overall time complexity but makes the algo more efficient\\n>**T/S:** O(mn)/O(m), where m = size(nums), n = size(divisors)\\n```\\npublic int maxDivScore(int[] nums, int[] divisors) {\\n\\tvar maxScore = 0;\\n\\tvar winnerDivisor = Integer.MAX_VALUE;\\n\\tArrays.sort(nums);\\n\\n\\tfor (var divisor : divisors) {\\n\\t\\tvar i = Arrays.binarySearch(nums, divisor);\\n\\t\\tif (i < 0)\\n\\t\\t\\ti = ~i;\\n\\n\\t\\tvar score = 0;\\n\\t\\tfor (; i < nums.length; i++)\\n\\t\\t\\tif (nums[i] % divisor == 0)\\n\\t\\t\\t\\tscore++;\\n\\n\\t\\tif (score > maxScore) {\\n\\t\\t\\tmaxScore = score;\\n\\t\\t\\twinnerDivisor = divisor;\\n\\t\\t} else if (score == maxScore) {\\n\\t\\t\\twinnerDivisor = Math.min(winnerDivisor, divisor);\\n\\t\\t}\\n\\t}\\n\\n\\treturn winnerDivisor;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int maxDivScore(int[] nums, int[] divisors) {\\n\\tvar maxScore = 0;\\n\\tvar winnerDivisor = Integer.MAX_VALUE;\\n\\tArrays.sort(nums);\\n\\n\\tfor (var divisor : divisors) {\\n\\t\\tvar i = Arrays.binarySearch(nums, divisor);\\n\\t\\tif (i < 0)\\n\\t\\t\\ti = ~i;\\n\\n\\t\\tvar score = 0;\\n\\t\\tfor (; i < nums.length; i++)\\n\\t\\t\\tif (nums[i] % divisor == 0)\\n\\t\\t\\t\\tscore++;\\n\\n\\t\\tif (score > maxScore) {\\n\\t\\t\\tmaxScore = score;\\n\\t\\t\\twinnerDivisor = divisor;\\n\\t\\t} else if (score == maxScore) {\\n\\t\\t\\twinnerDivisor = Math.min(winnerDivisor, divisor);\\n\\t\\t}\\n\\t}\\n\\n\\treturn winnerDivisor;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3464334,
                "title": "find-the-maximum-divisibility-score",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxDivScore(self, nums, divisors):\\n        dict1={}\\n        for i in divisors:\\n            count1=0\\n            for j in nums:\\n                if(j%i==0):\\n                    print(j,i)\\n                    print(count1)\\n                    count1+=1\\n            dict1[i]=count1\\n        maxvalue=max(dict1.values())\\n        list2=[]\\n        for key in dict1:\\n            if(dict1[key]==maxvalue):\\n                list2.append(key)\\n        return min(list2)\\n    \\n    \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxDivScore(self, nums, divisors):\\n        dict1={}\\n        for i in divisors:\\n            count1=0\\n            for j in nums:\\n                if(j%i==0):\\n                    print(j,i)\\n                    print(count1)\\n                    count1+=1\\n            dict1[i]=count1\\n        maxvalue=max(dict1.values())\\n        list2=[]\\n        for key in dict1:\\n            if(dict1[key]==maxvalue):\\n                list2.append(key)\\n        return min(list2)\\n    \\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3455862,
                "title": "two-solutions-hashmaps-or-two-pass",
                "content": "# Two Pass\\n```\\nclass Solution{\\npublic int maxDivScore(int[] nums, int[] divisors) {\\n    int max = -1, val = -1;\\n    for (int i : divisors) {\\n        int count = 0;\\n        for (int j : nums) {\\n            if (j % i == 0) {\\n                count++;\\n            }\\n        }\\n        if (max < count) {\\n            max = count;\\n            val = i;\\n        } else if (max == count) {\\n            val = Math.min(val, i);\\n        }\\n    }\\n    return val;\\n}\\n}\\n```\\n# HashMaps\\n```\\nclass Solution{\\npublic int maxDivScore(int[] nums, int[] divisors) {\\n    Map<Integer, Integer> map = new HashMap<>();\\n    for (int divisor : divisors) {\\n        if (!map.containsKey(divisor)) {\\n            int count = 0;\\n            for (int num : nums) {\\n                if (num % divisor == 0) {\\n                    count++;\\n                }\\n            }\\n            map.put(divisor, count);\\n        }\\n    }\\n    int maxCount = -1;\\n    int minDivisor = -1;\\n    for (int divisor : map.keySet()) {\\n        int count = map.get(divisor);\\n        if (count > maxCount) {\\n            maxCount = count;\\n            minDivisor = divisor;\\n        } else if (count == maxCount && divisor < minDivisor) {\\n            minDivisor = divisor;\\n        }\\n    }\\n    return minDivisor;\\n}\\n}\\n```\\n# Do Upvote if you find it helpful",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution{\\npublic int maxDivScore(int[] nums, int[] divisors) {\\n    int max = -1, val = -1;\\n    for (int i : divisors) {\\n        int count = 0;\\n        for (int j : nums) {\\n            if (j % i == 0) {\\n                count++;\\n            }\\n        }\\n        if (max < count) {\\n            max = count;\\n            val = i;\\n        } else if (max == count) {\\n            val = Math.min(val, i);\\n        }\\n    }\\n    return val;\\n}\\n}\\n```\n```\\nclass Solution{\\npublic int maxDivScore(int[] nums, int[] divisors) {\\n    Map<Integer, Integer> map = new HashMap<>();\\n    for (int divisor : divisors) {\\n        if (!map.containsKey(divisor)) {\\n            int count = 0;\\n            for (int num : nums) {\\n                if (num % divisor == 0) {\\n                    count++;\\n                }\\n            }\\n            map.put(divisor, count);\\n        }\\n    }\\n    int maxCount = -1;\\n    int minDivisor = -1;\\n    for (int divisor : map.keySet()) {\\n        int count = map.get(divisor);\\n        if (count > maxCount) {\\n            maxCount = count;\\n            minDivisor = divisor;\\n        } else if (count == maxCount && divisor < minDivisor) {\\n            minDivisor = divisor;\\n        }\\n    }\\n    return minDivisor;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454920,
                "title": "easy-java-solution-leetcode-easy-explain",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n       int max=-1;\\n    int maxscore= Integer .MAX_VALUE;\\n    for(int d:divisors){\\n        int count=0;\\n        for(int n:nums){\\n            if(n%d==0)\\n            count++;\\n        }\\n        if(count>max){\\n            max=count;\\n            maxscore=d;\\n\\n        }\\n        else if(count==max){\\n         maxscore=Math.min(maxscore,d);\\n        }\\n    }\\n  return maxscore;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n       int max=-1;\\n    int maxscore= Integer .MAX_VALUE;\\n    for(int d:divisors){\\n        int count=0;\\n        for(int n:nums){\\n            if(n%d==0)\\n            count++;\\n        }\\n        if(count>max){\\n            max=count;\\n            maxscore=d;\\n\\n        }\\n        else if(count==max){\\n         maxscore=Math.min(maxscore,d);\\n        }\\n    }\\n  return maxscore;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448359,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors)\\n    {\\n        int len=nums.length;\\n        int lent=divisors.length;\\n        int min=0;\\n        int max=0;\\n        for(int i=0;i<lent;i++)\\n        {\\n            int count=0;\\n            int div=divisors[i];\\n            for(int j=0;j<len;j++)\\n            {\\n                if(nums[j]%div==0)\\n                {\\n                    count++;\\n                }\\n            }\\n            if(count>=max)\\n            {\\n                if(count>max)\\n                {\\n                    max=count;\\n                    min=div;\\n                }\\n                    \\n                    else\\n                    {\\n                        if(min==0)\\n                        {\\n                          min=div;\\n                            max=count;\\n                        }\\n                        else\\n                        {\\n                        if(div<min)\\n                        {\\n                            min=div;\\n                        }\\n                        }\\n                    }\\n                }\\n            }\\n        \\n        return min;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors)\\n    {\\n        int len=nums.length;\\n        int lent=divisors.length;\\n        int min=0;\\n        int max=0;\\n        for(int i=0;i<lent;i++)\\n        {\\n            int count=0;\\n            int div=divisors[i];\\n            for(int j=0;j<len;j++)\\n            {\\n                if(nums[j]%div==0)\\n                {\\n                    count++;\\n                }\\n            }\\n            if(count>=max)\\n            {\\n                if(count>max)\\n                {\\n                    max=count;\\n                    min=div;\\n                }\\n                    \\n                    else\\n                    {\\n                        if(min==0)\\n                        {\\n                          min=div;\\n                            max=count;\\n                        }\\n                        else\\n                        {\\n                        if(div<min)\\n                        {\\n                            min=div;\\n                        }\\n                        }\\n                    }\\n                }\\n            }\\n        \\n        return min;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3447165,
                "title": "2644-easy-to-understand-c-code-two-for-loops-accepted",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& div) \\n    {\\n        int max=INT_MIN,ans=div[0];\\n        for(int i=0;i<div.size();i++){\\n            int sum=0;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]%div[i]==0)\\n                    sum++;\\n            }\\n            if(sum>=max){\\n                if(sum==max)\\n                    ans=min(div[i],ans);\\n                else{\\n                    max=sum;\\n                    ans=div[i];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& div) \\n    {\\n        int max=INT_MIN,ans=div[0];\\n        for(int i=0;i<div.size();i++){\\n            int sum=0;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]%div[i]==0)\\n                    sum++;\\n            }\\n            if(sum>=max){\\n                if(sum==max)\\n                    ans=min(div[i],ans);\\n                else{\\n                    max=sum;\\n                    ans=div[i];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446317,
                "title": "easy-to-understand-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int score=0, user = divisors[0];\\n        for(int i=0; i < divisors.size(); i++){\\n            int divided=0;\\n            for(int j=0; j < nums.size(); j++){\\n                if(nums[j] % divisors[i]==0) divided++;\\n            }\\n            if(divided >= score){\\n                if(divided==score){\\n                    if(user > divisors[i]) user = divisors[i];\\n                }\\n                else user = divisors[i];\\n                score = divided;\\n            }\\n        }\\n        return user;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int score=0, user = divisors[0];\\n        for(int i=0; i < divisors.size(); i++){\\n            int divided=0;\\n            for(int j=0; j < nums.size(); j++){\\n                if(nums[j] % divisors[i]==0) divided++;\\n            }\\n            if(divided >= score){\\n                if(divided==score){\\n                    if(user > divisors[i]) user = divisors[i];\\n                }\\n                else user = divisors[i];\\n                score = divided;\\n            }\\n        }\\n        return user;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444918,
                "title": "c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N*logN) + O(N^2)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int ans = 0, ind = 0;\\n        sort(divisors.begin(), divisors.end());\\n        int m = nums.size(), n = divisors.size();\\n        for(int i = 0; i < n; i++){\\n            int score = 0;\\n            for(int j = 0; j < m; j++){\\n                if(nums[j] % divisors[i] == 0) score++;\\n            }\\n            if(score > ans){\\n                ans = score;\\n                ind = i;\\n            }\\n        }\\n        // if(ind == -1) return divisors[0];\\n        return divisors[ind];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int ans = 0, ind = 0;\\n        sort(divisors.begin(), divisors.end());\\n        int m = nums.size(), n = divisors.size();\\n        for(int i = 0; i < n; i++){\\n            int score = 0;\\n            for(int j = 0; j < m; j++){\\n                if(nums[j] % divisors[i] == 0) score++;\\n            }\\n            if(score > ans){\\n                ans = score;\\n                ind = i;\\n            }\\n        }\\n        // if(ind == -1) return divisors[0];\\n        return divisors[ind];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444258,
                "title": "simple-c-solution-easy-to-understand",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(m*n), m == nums.size(), n == divisors.size()\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int ans, cnt = 0;\\n        for(int i = 0; i < divisors.size(); i++)\\n        {\\n            int cnt1 = 0;\\n            for(int j = 0; j < nums.size(); j++)\\n            {\\n                if(nums[j] % divisors[i] == 0)\\n                {\\n                    cnt1++;\\n                }\\n            }\\n            if(cnt1 > cnt)\\n            {\\n                cnt = cnt1;\\n                ans = divisors[i];\\n            }\\n            else if(cnt1 == cnt)\\n            {\\n                ans = min(ans, divisors[i]);\\n            }\\n        }\\n        if(cnt == 0)\\n        {\\n            sort(divisors.begin(), divisors.end());\\n            ans = divisors[0];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        int ans, cnt = 0;\\n        for(int i = 0; i < divisors.size(); i++)\\n        {\\n            int cnt1 = 0;\\n            for(int j = 0; j < nums.size(); j++)\\n            {\\n                if(nums[j] % divisors[i] == 0)\\n                {\\n                    cnt1++;\\n                }\\n            }\\n            if(cnt1 > cnt)\\n            {\\n                cnt = cnt1;\\n                ans = divisors[i];\\n            }\\n            else if(cnt1 == cnt)\\n            {\\n                ans = min(ans, divisors[i]);\\n            }\\n        }\\n        if(cnt == 0)\\n        {\\n            sort(divisors.begin(), divisors.end());\\n            ans = divisors[0];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443219,
                "title": "beats-92-with-explanation-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe just Apply the brute force approach for each element in divisor we divide with each element in nums and if it is completely divisible by the divisor element we increase the count by 1 and check if the count of current pointer is less than or greater than the previous pointer (countC)\\nthen we assign the value of countC to CountP  and the highest pointer will be the item for which the count was more \\nand if the count of both the current pointer and the previous pointer are same then we check if the current highest is greater than the current item \\n(the problem says  If there is more than one integer with the maximum score, return the minimum of them.) so inorder to return the min we perform this check \\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} divisors\\n * @return {number}\\n */\\nvar maxDivScore = function(nums, d) {\\n    \\nlet countP = 0 ;\\n        let countC = 0 ;\\n        let highest = 0;\\n\\n        for(let i = 0 ; i < d.length ; i++)\\n            {\\n                let item = d[i];\\n                countC = 0 ;\\n                \\n\\n                for(let j = 0 ; j < nums.length ; j++)\\n                    {\\n                        if( nums[j] % item === 0 )\\n                        {\\n                            countC++;\\n                        }\\n                    }\\n\\n                if(countP < countC)\\n                {\\n                    countP = countC;\\n                    highest = item;\\n                }\\n                else if(countP === countC)\\n                {\\n                    if(highest > item )\\n                    {\\n                        highest = item ;\\n                    }\\n                }\\n            }\\n\\n// this check here means that if the counterP is 0 then we check the largest number on divisor array and return the highest\\n    if(!countP) return Math.min.apply(null,d);\\n    return highest;\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} divisors\\n * @return {number}\\n */\\nvar maxDivScore = function(nums, d) {\\n    \\nlet countP = 0 ;\\n        let countC = 0 ;\\n        let highest = 0;\\n\\n        for(let i = 0 ; i < d.length ; i++)\\n            {\\n                let item = d[i];\\n                countC = 0 ;\\n                \\n\\n                for(let j = 0 ; j < nums.length ; j++)\\n                    {\\n                        if( nums[j] % item === 0 )\\n                        {\\n                            countC++;\\n                        }\\n                    }\\n\\n                if(countP < countC)\\n                {\\n                    countP = countC;\\n                    highest = item;\\n                }\\n                else if(countP === countC)\\n                {\\n                    if(highest > item )\\n                    {\\n                        highest = item ;\\n                    }\\n                }\\n            }\\n\\n// this check here means that if the counterP is 0 then we check the largest number on divisor array and return the highest\\n    if(!countP) return Math.min.apply(null,d);\\n    return highest;\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3443168,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m*n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int maxi = Integer.MIN_VALUE;\\n        int element = -1;\\n        for(int i = 0; i < divisors.length; i++)\\n        {\\n            int count = 0;\\n            for(int j = 0; j < nums.length; j++)\\n            {\\n                if(nums[j] % divisors[i] == 0)\\n                {\\n                    count++;\\n                }\\n            }\\n            if(count > maxi)\\n            {\\n                maxi = count;\\n                element = divisors[i];\\n            }\\n            else if(count == maxi)\\n            {\\n                element = Math.min(element, divisors[i]);\\n            }\\n        }\\n        return element;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxDivScore(int[] nums, int[] divisors) {\\n        int maxi = Integer.MIN_VALUE;\\n        int element = -1;\\n        for(int i = 0; i < divisors.length; i++)\\n        {\\n            int count = 0;\\n            for(int j = 0; j < nums.length; j++)\\n            {\\n                if(nums[j] % divisors[i] == 0)\\n                {\\n                    count++;\\n                }\\n            }\\n            if(count > maxi)\\n            {\\n                maxi = count;\\n                element = divisors[i];\\n            }\\n            else if(count == maxi)\\n            {\\n                element = Math.min(element, divisors[i]);\\n            }\\n        }\\n        return element;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442081,
                "title": "c-simple-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        sort(divisors.begin(),divisors.end());\\n        int ans=divisors[0];\\n        int maxi=0;\\n        for(int i=0;i<divisors.size();i++){\\n            int cnt=0;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]%divisors[i]==0){\\n                    cnt++;\\n                }\\n            }\\n            if(cnt>maxi){\\n                ans=divisors[i];\\n                maxi=cnt;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\\n        sort(divisors.begin(),divisors.end());\\n        int ans=divisors[0];\\n        int maxi=0;\\n        for(int i=0;i<divisors.size();i++){\\n            int cnt=0;\\n            for(int j=0;j<nums.size();j++){\\n                if(nums[j]%divisors[i]==0){\\n                    cnt++;\\n                }\\n            }\\n            if(cnt>maxi){\\n                ans=divisors[i];\\n                maxi=cnt;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442024,
                "title": "c-478-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxDivScore(const vector<int>& nums, const vector<int>& divisors) {\\n        unordered_set<int> unique_divisors;\\n        for(auto divisor : divisors) unique_divisors.insert(divisor);\\n\\n        int result = divisors[0], max_count = 0;\\n        for(auto divisor : unique_divisors) {\\n            int count = 0;\\n            for(auto num : nums) {\\n                if(num % divisor == 0) ++count;\\n            }\\n            if(max_count < count or max_count == count and divisor < result) {\\n                max_count = count;\\n                result = divisor;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxDivScore(const vector<int>& nums, const vector<int>& divisors) {\\n        unordered_set<int> unique_divisors;\\n        for(auto divisor : divisors) unique_divisors.insert(divisor);\\n\\n        int result = divisors[0], max_count = 0;\\n        for(auto divisor : unique_divisors) {\\n            int count = 0;\\n            for(auto num : nums) {\\n                if(num % divisor == 0) ++count;\\n            }\\n            if(max_count < count or max_count == count and divisor < result) {\\n                max_count = count;\\n                result = divisor;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3441701,
                "title": "easy-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} divisors\\n * @return {number}\\n */\\nvar maxDivScore = function(nums, divisors) {\\n    let res = divisors[0];\\n    let count =0;\\n    let max = 0;\\n    for(let a of divisors){\\n        for(let b of nums){\\n            if(b%a==0){\\n                count++;\\n            }\\n        }\\n        if(count>max){\\n            max=count;\\n            res = a;\\n        }else if(count===max){\\n            if(res>a){\\n                res=a;\\n            }\\n        }\\n        count=0;\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} divisors\\n * @return {number}\\n */\\nvar maxDivScore = function(nums, divisors) {\\n    let res = divisors[0];\\n    let count =0;\\n    let max = 0;\\n    for(let a of divisors){\\n        for(let b of nums){\\n            if(b%a==0){\\n                count++;\\n            }\\n        }\\n        if(count>max){\\n            max=count;\\n            res = a;\\n        }else if(count===max){\\n            if(res>a){\\n                res=a;\\n            }\\n        }\\n        count=0;\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3441634,
                "title": "python-easy-begginers",
                "content": "**maximum divisor with lowest value when two or more have same score**\\n\\n```\\n\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        c=0\\n        val=0\\n        ele =0\\n        divisors =sorted(divisors, reverse = True)\\n        for n in divisors:\\n            c=0\\n            for i in nums:\\n                if i%n==0:\\n                    c+=1\\n            \\n            if val<=c:\\n                val = c\\n                ele = n\\n \\xA0 \\xA0 \\xA0 \\xA0return ele\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        c=0\\n        val=0\\n        ele =0\\n        divisors =sorted(divisors, reverse = True)\\n        for n in divisors:\\n            c=0\\n            for i in nums:\\n                if i%n==0:\\n                    c+=1\\n            \\n            if val<=c:\\n                val = c\\n                ele = n\\n \\xA0 \\xA0 \\xA0 \\xA0return ele\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3440624,
                "title": "c-plain-brute-force-99-space-427ms-30-space-29-6mb",
                "content": "Without any more specific domain knowledge, in particular about the commposition of `divisors` (how often we can get repeated ones or numbers that are GCDs of several others) any attempt of optimisation does not seem worth it, so let\\'s go for a crude, brutal BF here.\\n\\nWe will start by declaring three support variables:\\n* `res` is our usual accumulator variable;\\n* `maxScore` is the highest score seen so far, initially set to `-1` (ie: one less the actual minimum we can expect, that is `0`);\\n* `tmp` will store the temporary score of each divisor we will parse.\\n\\nWe will then loop for each `d` in `divisors` and:\\n* (re)set `tmp` to an initial value of `0`;\\n* for each element `n` in `nums`, we will:\\n    * check if `d` is a divisor of `n` (ie: `n % d == 0`);\\n    * increase `tmp` by `1` if so;\\n* if we have a first case, a new maximum (ie: `tmp > maxScore`), in which case we will:\\n    * update `maxScore` to be `tmp`;\\n    * update `res` to be `d`;\\n* if we have another score `tmp` equal to the previous maximum `maxScore`, we will just update `res` to be the minimum between its current value and `d`.\\n\\nOnce done, we can `return` `res` :)\\n\\n# Complexity\\n- Time complexity: $$O(d * n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int> &nums, vector<int> &divs) {\\n        // support variables\\n        int res, maxScore = -1, tmp;\\n        for (int d: divs) {\\n            // computing d\\'s score\\n            tmp = 0;\\n            for (int n: nums) tmp += n % d == 0;\\n            // case 1: new maxScore\\n            if (tmp > maxScore) {\\n                maxScore = tmp;\\n                res = d;\\n            }\\n            // case 2: same as maxScore\\n            else if (tmp == maxScore) res = min(res, d);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Number Theory"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxDivScore(vector<int> &nums, vector<int> &divs) {\\n        // support variables\\n        int res, maxScore = -1, tmp;\\n        for (int d: divs) {\\n            // computing d\\'s score\\n            tmp = 0;\\n            for (int n: nums) tmp += n % d == 0;\\n            // case 1: new maxScore\\n            if (tmp > maxScore) {\\n                maxScore = tmp;\\n                res = d;\\n            }\\n            // case 2: same as maxScore\\n            else if (tmp == maxScore) res = min(res, d);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3439087,
                "title": "ultra-easy-python-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        ans = 0\\n        maxi =-1\\n        for i in divisors:\\n            count = 0\\n            for j in nums:\\n                if j%i==0:\\n                    count += 1\\n            if count ==maxi:\\n                ans = min(ans,i)\\n            elif count>maxi:\\n                maxi = count\\n                ans = i\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\\n        ans = 0\\n        maxi =-1\\n        for i in divisors:\\n            count = 0\\n            for j in nums:\\n                if j%i==0:\\n                    count += 1\\n            if count ==maxi:\\n                ans = min(ans,i)\\n            elif count>maxi:\\n                maxi = count\\n                ans = i\\n        return ans\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1865215,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "tricky tricky"
                    },
                    {
                        "username": "victCh",
                        "content": "most difficult in this problem is to understansd \"If there is more than one integer with the maximum score, return the minimum of them.\""
                    },
                    {
                        "username": "Dizzy099",
                        "content": "finally solved it by brute force , please someone explain optimized way"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don\\'t think there is an optimized way. That\\'s why it\\'s an easy problem, because the expected answer is just the brute force approach"
                    },
                    {
                        "username": "20311a0436",
                        "content": "Optimised approach other than brute force?"
                    },
                    {
                        "username": "bjhhar6475",
                        "content": "You can get significantly faster (10x ~400ms instead of 4000ms) performance if instead of iterating through nums, you through multiples of the divisor. Of course, stop once you exceed the max value in nums. Specifically, hash each number and given divisor like 6, check if 6, 12, ...  max(nums) is in nums. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was thinking there might be a way to avoid redundancies if some of the divisors divide each other... But checking for that already takes some time, and in the worst case anyway, divisors would all be prime numbers or something and there's no redundant information.\nIn the case where all numbers involved are primes, I don't think there's a better way to do it than brute force checking everything, because I don't see a good way to compress the information\n"
                    },
                    {
                        "username": "sooraj7",
                        "content": "At first the question seems to be confusing, but on grasping, it turns out to be pretty easy, just take care to return the smallest in case of conflict"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Look for optimization of your code !! \\nHash map can useful"
                    },
                    {
                        "username": "AsrielAries0704",
                        "content": "Done, but... 9500+ms :| brute force"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If anyone enjoys one-line solutions, I explain in great lenght one way to do it, to give beginners some syntaxic ideas to work with:\n[Check it out!](https://leetcode.com/problems/find-the-maximum-divisibility-score/solutions/3422676/python-one-liner-for-beginners/?orderBy=most_votes)"
                    }
                ]
            },
            {
                "id": 1899331,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "tricky tricky"
                    },
                    {
                        "username": "victCh",
                        "content": "most difficult in this problem is to understansd \"If there is more than one integer with the maximum score, return the minimum of them.\""
                    },
                    {
                        "username": "Dizzy099",
                        "content": "finally solved it by brute force , please someone explain optimized way"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don\\'t think there is an optimized way. That\\'s why it\\'s an easy problem, because the expected answer is just the brute force approach"
                    },
                    {
                        "username": "20311a0436",
                        "content": "Optimised approach other than brute force?"
                    },
                    {
                        "username": "bjhhar6475",
                        "content": "You can get significantly faster (10x ~400ms instead of 4000ms) performance if instead of iterating through nums, you through multiples of the divisor. Of course, stop once you exceed the max value in nums. Specifically, hash each number and given divisor like 6, check if 6, 12, ...  max(nums) is in nums. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was thinking there might be a way to avoid redundancies if some of the divisors divide each other... But checking for that already takes some time, and in the worst case anyway, divisors would all be prime numbers or something and there's no redundant information.\nIn the case where all numbers involved are primes, I don't think there's a better way to do it than brute force checking everything, because I don't see a good way to compress the information\n"
                    },
                    {
                        "username": "sooraj7",
                        "content": "At first the question seems to be confusing, but on grasping, it turns out to be pretty easy, just take care to return the smallest in case of conflict"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Look for optimization of your code !! \\nHash map can useful"
                    },
                    {
                        "username": "AsrielAries0704",
                        "content": "Done, but... 9500+ms :| brute force"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If anyone enjoys one-line solutions, I explain in great lenght one way to do it, to give beginners some syntaxic ideas to work with:\n[Check it out!](https://leetcode.com/problems/find-the-maximum-divisibility-score/solutions/3422676/python-one-liner-for-beginners/?orderBy=most_votes)"
                    }
                ]
            },
            {
                "id": 1865680,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "tricky tricky"
                    },
                    {
                        "username": "victCh",
                        "content": "most difficult in this problem is to understansd \"If there is more than one integer with the maximum score, return the minimum of them.\""
                    },
                    {
                        "username": "Dizzy099",
                        "content": "finally solved it by brute force , please someone explain optimized way"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don\\'t think there is an optimized way. That\\'s why it\\'s an easy problem, because the expected answer is just the brute force approach"
                    },
                    {
                        "username": "20311a0436",
                        "content": "Optimised approach other than brute force?"
                    },
                    {
                        "username": "bjhhar6475",
                        "content": "You can get significantly faster (10x ~400ms instead of 4000ms) performance if instead of iterating through nums, you through multiples of the divisor. Of course, stop once you exceed the max value in nums. Specifically, hash each number and given divisor like 6, check if 6, 12, ...  max(nums) is in nums. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was thinking there might be a way to avoid redundancies if some of the divisors divide each other... But checking for that already takes some time, and in the worst case anyway, divisors would all be prime numbers or something and there's no redundant information.\nIn the case where all numbers involved are primes, I don't think there's a better way to do it than brute force checking everything, because I don't see a good way to compress the information\n"
                    },
                    {
                        "username": "sooraj7",
                        "content": "At first the question seems to be confusing, but on grasping, it turns out to be pretty easy, just take care to return the smallest in case of conflict"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Look for optimization of your code !! \\nHash map can useful"
                    },
                    {
                        "username": "AsrielAries0704",
                        "content": "Done, but... 9500+ms :| brute force"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If anyone enjoys one-line solutions, I explain in great lenght one way to do it, to give beginners some syntaxic ideas to work with:\n[Check it out!](https://leetcode.com/problems/find-the-maximum-divisibility-score/solutions/3422676/python-one-liner-for-beginners/?orderBy=most_votes)"
                    }
                ]
            },
            {
                "id": 1864916,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "tricky tricky"
                    },
                    {
                        "username": "victCh",
                        "content": "most difficult in this problem is to understansd \"If there is more than one integer with the maximum score, return the minimum of them.\""
                    },
                    {
                        "username": "Dizzy099",
                        "content": "finally solved it by brute force , please someone explain optimized way"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don\\'t think there is an optimized way. That\\'s why it\\'s an easy problem, because the expected answer is just the brute force approach"
                    },
                    {
                        "username": "20311a0436",
                        "content": "Optimised approach other than brute force?"
                    },
                    {
                        "username": "bjhhar6475",
                        "content": "You can get significantly faster (10x ~400ms instead of 4000ms) performance if instead of iterating through nums, you through multiples of the divisor. Of course, stop once you exceed the max value in nums. Specifically, hash each number and given divisor like 6, check if 6, 12, ...  max(nums) is in nums. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was thinking there might be a way to avoid redundancies if some of the divisors divide each other... But checking for that already takes some time, and in the worst case anyway, divisors would all be prime numbers or something and there's no redundant information.\nIn the case where all numbers involved are primes, I don't think there's a better way to do it than brute force checking everything, because I don't see a good way to compress the information\n"
                    },
                    {
                        "username": "sooraj7",
                        "content": "At first the question seems to be confusing, but on grasping, it turns out to be pretty easy, just take care to return the smallest in case of conflict"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Look for optimization of your code !! \\nHash map can useful"
                    },
                    {
                        "username": "AsrielAries0704",
                        "content": "Done, but... 9500+ms :| brute force"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If anyone enjoys one-line solutions, I explain in great lenght one way to do it, to give beginners some syntaxic ideas to work with:\n[Check it out!](https://leetcode.com/problems/find-the-maximum-divisibility-score/solutions/3422676/python-one-liner-for-beginners/?orderBy=most_votes)"
                    }
                ]
            },
            {
                "id": 2045292,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "tricky tricky"
                    },
                    {
                        "username": "victCh",
                        "content": "most difficult in this problem is to understansd \"If there is more than one integer with the maximum score, return the minimum of them.\""
                    },
                    {
                        "username": "Dizzy099",
                        "content": "finally solved it by brute force , please someone explain optimized way"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don\\'t think there is an optimized way. That\\'s why it\\'s an easy problem, because the expected answer is just the brute force approach"
                    },
                    {
                        "username": "20311a0436",
                        "content": "Optimised approach other than brute force?"
                    },
                    {
                        "username": "bjhhar6475",
                        "content": "You can get significantly faster (10x ~400ms instead of 4000ms) performance if instead of iterating through nums, you through multiples of the divisor. Of course, stop once you exceed the max value in nums. Specifically, hash each number and given divisor like 6, check if 6, 12, ...  max(nums) is in nums. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was thinking there might be a way to avoid redundancies if some of the divisors divide each other... But checking for that already takes some time, and in the worst case anyway, divisors would all be prime numbers or something and there's no redundant information.\nIn the case where all numbers involved are primes, I don't think there's a better way to do it than brute force checking everything, because I don't see a good way to compress the information\n"
                    },
                    {
                        "username": "sooraj7",
                        "content": "At first the question seems to be confusing, but on grasping, it turns out to be pretty easy, just take care to return the smallest in case of conflict"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Look for optimization of your code !! \\nHash map can useful"
                    },
                    {
                        "username": "AsrielAries0704",
                        "content": "Done, but... 9500+ms :| brute force"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If anyone enjoys one-line solutions, I explain in great lenght one way to do it, to give beginners some syntaxic ideas to work with:\n[Check it out!](https://leetcode.com/problems/find-the-maximum-divisibility-score/solutions/3422676/python-one-liner-for-beginners/?orderBy=most_votes)"
                    }
                ]
            },
            {
                "id": 1938388,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "tricky tricky"
                    },
                    {
                        "username": "victCh",
                        "content": "most difficult in this problem is to understansd \"If there is more than one integer with the maximum score, return the minimum of them.\""
                    },
                    {
                        "username": "Dizzy099",
                        "content": "finally solved it by brute force , please someone explain optimized way"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don\\'t think there is an optimized way. That\\'s why it\\'s an easy problem, because the expected answer is just the brute force approach"
                    },
                    {
                        "username": "20311a0436",
                        "content": "Optimised approach other than brute force?"
                    },
                    {
                        "username": "bjhhar6475",
                        "content": "You can get significantly faster (10x ~400ms instead of 4000ms) performance if instead of iterating through nums, you through multiples of the divisor. Of course, stop once you exceed the max value in nums. Specifically, hash each number and given divisor like 6, check if 6, 12, ...  max(nums) is in nums. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was thinking there might be a way to avoid redundancies if some of the divisors divide each other... But checking for that already takes some time, and in the worst case anyway, divisors would all be prime numbers or something and there's no redundant information.\nIn the case where all numbers involved are primes, I don't think there's a better way to do it than brute force checking everything, because I don't see a good way to compress the information\n"
                    },
                    {
                        "username": "sooraj7",
                        "content": "At first the question seems to be confusing, but on grasping, it turns out to be pretty easy, just take care to return the smallest in case of conflict"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Look for optimization of your code !! \\nHash map can useful"
                    },
                    {
                        "username": "AsrielAries0704",
                        "content": "Done, but... 9500+ms :| brute force"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If anyone enjoys one-line solutions, I explain in great lenght one way to do it, to give beginners some syntaxic ideas to work with:\n[Check it out!](https://leetcode.com/problems/find-the-maximum-divisibility-score/solutions/3422676/python-one-liner-for-beginners/?orderBy=most_votes)"
                    }
                ]
            },
            {
                "id": 1867685,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "tricky tricky"
                    },
                    {
                        "username": "victCh",
                        "content": "most difficult in this problem is to understansd \"If there is more than one integer with the maximum score, return the minimum of them.\""
                    },
                    {
                        "username": "Dizzy099",
                        "content": "finally solved it by brute force , please someone explain optimized way"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don\\'t think there is an optimized way. That\\'s why it\\'s an easy problem, because the expected answer is just the brute force approach"
                    },
                    {
                        "username": "20311a0436",
                        "content": "Optimised approach other than brute force?"
                    },
                    {
                        "username": "bjhhar6475",
                        "content": "You can get significantly faster (10x ~400ms instead of 4000ms) performance if instead of iterating through nums, you through multiples of the divisor. Of course, stop once you exceed the max value in nums. Specifically, hash each number and given divisor like 6, check if 6, 12, ...  max(nums) is in nums. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was thinking there might be a way to avoid redundancies if some of the divisors divide each other... But checking for that already takes some time, and in the worst case anyway, divisors would all be prime numbers or something and there's no redundant information.\nIn the case where all numbers involved are primes, I don't think there's a better way to do it than brute force checking everything, because I don't see a good way to compress the information\n"
                    },
                    {
                        "username": "sooraj7",
                        "content": "At first the question seems to be confusing, but on grasping, it turns out to be pretty easy, just take care to return the smallest in case of conflict"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Look for optimization of your code !! \\nHash map can useful"
                    },
                    {
                        "username": "AsrielAries0704",
                        "content": "Done, but... 9500+ms :| brute force"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If anyone enjoys one-line solutions, I explain in great lenght one way to do it, to give beginners some syntaxic ideas to work with:\n[Check it out!](https://leetcode.com/problems/find-the-maximum-divisibility-score/solutions/3422676/python-one-liner-for-beginners/?orderBy=most_votes)"
                    }
                ]
            },
            {
                "id": 1865190,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "tricky tricky"
                    },
                    {
                        "username": "victCh",
                        "content": "most difficult in this problem is to understansd \"If there is more than one integer with the maximum score, return the minimum of them.\""
                    },
                    {
                        "username": "Dizzy099",
                        "content": "finally solved it by brute force , please someone explain optimized way"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don\\'t think there is an optimized way. That\\'s why it\\'s an easy problem, because the expected answer is just the brute force approach"
                    },
                    {
                        "username": "20311a0436",
                        "content": "Optimised approach other than brute force?"
                    },
                    {
                        "username": "bjhhar6475",
                        "content": "You can get significantly faster (10x ~400ms instead of 4000ms) performance if instead of iterating through nums, you through multiples of the divisor. Of course, stop once you exceed the max value in nums. Specifically, hash each number and given divisor like 6, check if 6, 12, ...  max(nums) is in nums. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I was thinking there might be a way to avoid redundancies if some of the divisors divide each other... But checking for that already takes some time, and in the worst case anyway, divisors would all be prime numbers or something and there's no redundant information.\nIn the case where all numbers involved are primes, I don't think there's a better way to do it than brute force checking everything, because I don't see a good way to compress the information\n"
                    },
                    {
                        "username": "sooraj7",
                        "content": "At first the question seems to be confusing, but on grasping, it turns out to be pretty easy, just take care to return the smallest in case of conflict"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Look for optimization of your code !! \\nHash map can useful"
                    },
                    {
                        "username": "AsrielAries0704",
                        "content": "Done, but... 9500+ms :| brute force"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If anyone enjoys one-line solutions, I explain in great lenght one way to do it, to give beginners some syntaxic ideas to work with:\n[Check it out!](https://leetcode.com/problems/find-the-maximum-divisibility-score/solutions/3422676/python-one-liner-for-beginners/?orderBy=most_votes)"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Number of Operations to Make All Array Elements Equal to 1",
        "question_content": "<p>You are given a <strong>0-indexed</strong>&nbsp;array <code>nums</code> consisiting of <strong>positive</strong> integers. You can do the following operation on the array <strong>any</strong> number of times:</p>\n\n<ul>\n\t<li>Select an index <code>i</code> such that <code>0 &lt;= i &lt; n - 1</code> and replace either of&nbsp;<code>nums[i]</code> or <code>nums[i+1]</code> with their gcd value.</li>\n</ul>\n\n<p>Return <em>the <strong>minimum</strong> number of operations to make all elements of </em><code>nums</code><em> equal to </em><code>1</code>. If it is impossible, return <code>-1</code>.</p>\n\n<p>The gcd of two integers is the greatest common divisor of the two integers.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,6,3,4]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> We can do the following operations:\n- Choose index i = 2 and replace nums[2] with gcd(3,4) = 1. Now we have nums = [2,6,1,4].\n- Choose index i = 1 and replace nums[1] with gcd(6,1) = 1. Now we have nums = [2,1,1,4].\n- Choose index i = 0 and replace nums[0] with gcd(2,1) = 1. Now we have nums = [1,1,1,4].\n- Choose index i = 2 and replace nums[3] with gcd(1,4) = 1. Now we have nums = [1,1,1,1].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,10,6,14]\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> It can be shown that it is impossible to make all the elements equal to 1.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 50</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>6</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><b>Follow-up:</b></p>\n\n<p>The <code>O(n)</code> time complexity&nbsp;solution works, but could you find an <code>O(1)</code> constant time complexity solution?</p>\n",
        "solutions": [
            {
                "id": 3445725,
                "title": "explained-easy-gcd-and-intuition",
                "content": "# Intuition\\nQ1. When is gcd of 2 numbers =1 ? \\nA1. when both the numbers have no common factor. The gcd of 1 and any other number is always 1 itself. \\n\\nQ2. How is the property stated above beneficial?\\nA2. I just need to find the number of operations required to make any element as 1 and then the remaining n-1 elements can be made 1 in just n-1 steps where n is the size of the array. \\nElaborated: if we have a 1 at index \\u201Ci\\u201D then we would make element at i-1 => gcd(nums[i-1],nums[i]) this would make the element at index i-1 as 1 too! Then we\\u2019ll perform the same with i-2,i-3\\u2026.1 . without loss of generality we would perform the similar operations to the right of I as well! \\n\\nQ3. How do you get the minimum number of operations required to make any of the elements as 1?\\nA3. given the constraints, for any element I we can traverse through all elements (say iterator j) from i+1 to n and take their gcd. As soon as the gcd becomes 1 we can conclude that taking gcd in the reverse fashion (from nums[j] to nums[i]) would make nums[i] equal to 1. \\n\\nQ4. what if some 1s are already present in the array?\\nA4. In that case we can say that we would use the operation mentioned in A2 and make the remaining elements equal to 1. \\n\\nThe code is self-explanatory, let me know if you have any doubts! Thanks!\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N^2)\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n=nums.size();\\n        int c=count(nums.begin(),nums.end(),1);     // if there is at least 1. then it\\'s easy!\\n        if(c!=0)    return n-c;\\n        int res=1e7;        // just a dummy value\\n        for(int i=0;i<n;i++){\\n            int g=nums[i];\\n            for(int j=i+1;j<n;j++){\\n                g=__gcd(g,nums[j]);\\n                if(g==1){\\n                    res=min(res,j-i+(n-1)); // number of operations to make this element 1+ number of non ones (i.e. n-1) .\\n                    break;\\n                } \\n            }\\n        }\\n        return res==1e7?-1:res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n=nums.size();\\n        int c=count(nums.begin(),nums.end(),1);     // if there is at least 1. then it\\'s easy!\\n        if(c!=0)    return n-c;\\n        int res=1e7;        // just a dummy value\\n        for(int i=0;i<n;i++){\\n            int g=nums[i];\\n            for(int j=i+1;j<n;j++){\\n                g=__gcd(g,nums[j]);\\n                if(g==1){\\n                    res=min(res,j-i+(n-1)); // number of operations to make this element 1+ number of non ones (i.e. n-1) .\\n                    break;\\n                } \\n            }\\n        }\\n        return res==1e7?-1:res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446148,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "<iframe src=\"https://leetcode.com/playground/9gLg2fYc/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Greedy"
                ],
                "code": "<iframe src=\"https://leetcode.com/playground/9gLg2fYc/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 3445895,
                "title": "smallest-subarray-gcd-equal-to-1-very-simple-easy-to-understand-solution",
                "content": "<b> Up vote if you like the solution \\n# Approach\\n1. The key is to find at least one 1 in th the nums, once found then other can be made 1 with n -1 operations.\\n2. To have least no. of operations we need to find the smallest subarray whose gcd is 1.\\n3. For this, with greedy approach we will check each sub array and evaluate gcd and keep storing the minimum length for which GCD is 1.\\n\\nCorner case : if there is already x no. of 1s in the array, then simply needed n-x no of operation.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int minOperations(vector<int>& nums) {\\n        int t = INT_MAX, count = 0;\\n        for(auto n: nums){ if(n == 1) count++; }\\n        if(count > 0) { return nums.size() - count; }\\n        for(int i = 0; i<nums.size(); ++i ){\\n            int last = nums[i];\\n            for(int j = i+1; j < nums.size(); ++j ){\\n                last = __gcd(last, nums[j]);\\n                if(last == 1) { t = min(t, j-i); break; }\\n            }\\n        }\\n        if(t != INT_MAX) return t + nums.size()-1;\\n        return -1;\\n    }\\n};\\n```\\n\\nHere is an article of my recent interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minOperations(vector<int>& nums) {\\n        int t = INT_MAX, count = 0;\\n        for(auto n: nums){ if(n == 1) count++; }\\n        if(count > 0) { return nums.size() - count; }\\n        for(int i = 0; i<nums.size(); ++i ){\\n            int last = nums[i];\\n            for(int j = i+1; j < nums.size(); ++j ){\\n                last = __gcd(last, nums[j]);\\n                if(last == 1) { t = min(t, j-i); break; }\\n            }\\n        }\\n        if(t != INT_MAX) return t + nums.size()-1;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445773,
                "title": "python3-gcd",
                "content": "\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        ones = nums.count(1)\\n        if ones: return len(nums)-ones\\n        diff = inf \\n        for i in range(len(nums)): \\n            g = nums[i]\\n            for j in range(i+1, len(nums)):\\n                g = gcd(g, nums[j])\\n                if g == 1: diff = min(diff, j-i)\\n        return -1 if diff == inf else diff + len(nums) - 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        ones = nums.count(1)\\n        if ones: return len(nums)-ones\\n        diff = inf \\n        for i in range(len(nums)): \\n            g = nums[i]\\n            for j in range(i+1, len(nums)):\\n                g = gcd(g, nums[j])\\n                if g == 1: diff = min(diff, j-i)\\n        return -1 if diff == inf else diff + len(nums) - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445663,
                "title": "cpp-make-exactly-one-element-1",
                "content": "\\n\\n\\n#### Intution : \\n* If we have one element `1` then we can make all elements `1`\\n* So our task is make exacty one element `1`\\n\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int GCD = 0, n = nums.size();\\n        // If GCD of all numbers in nums not equal to 1 then we can not make all element 1 return -1\\n        for(int i = 0; i < n; i++) GCD = __gcd(nums[i], GCD);\\n        if(GCD != 1) return -1;\\n        \\n        // If number of ones in given array is present then return n - cntOne\\n        int cntOne = count(nums.begin(), nums.end(), 1);\\n        if(cntOne) return n - cntOne; \\n        \\n        // calculate how many mininum operations needed to make one element in array is 1\\n        int mi = INT_MAX;\\n        for(int i = 0; i < n; i++) {\\n            int res = nums[i];\\n            for(int j = i; j < n; j++) {\\n                res = __gcd(nums[j], res);\\n                if(res == 1) mi = min(mi, j - i);\\n            }\\n        }\\n        return n + mi - 1;\\n    }\\n};\\n```\\n>Have a good day. Happy Coding!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int GCD = 0, n = nums.size();\\n        // If GCD of all numbers in nums not equal to 1 then we can not make all element 1 return -1\\n        for(int i = 0; i < n; i++) GCD = __gcd(nums[i], GCD);\\n        if(GCD != 1) return -1;\\n        \\n        // If number of ones in given array is present then return n - cntOne\\n        int cntOne = count(nums.begin(), nums.end(), 1);\\n        if(cntOne) return n - cntOne; \\n        \\n        // calculate how many mininum operations needed to make one element in array is 1\\n        int mi = INT_MAX;\\n        for(int i = 0; i < n; i++) {\\n            int res = nums[i];\\n            for(int j = i; j < n; j++) {\\n                res = __gcd(nums[j], res);\\n                if(res == 1) mi = min(mi, j - i);\\n            }\\n        }\\n        return n + mi - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445720,
                "title": "simple-java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n * k)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int n = nums.length;\\n        int c = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(nums[i] == 1)\\n            {\\n                c++;\\n            }\\n        }\\n        if(c > 0)\\n        {\\n            return n - c;\\n        }\\n        int ans = Integer.MAX_VALUE;\\n        for(int i=0; i<n; i++)\\n        {\\n            int num = nums[i];\\n            for(int j=i+1; j<n; j++)\\n            {\\n                num = gcd(num, nums[j]);\\n                if(num == 1)\\n                {\\n                    ans = Math.min(ans, j-i);\\n                    break;\\n                }\\n            }\\n            if(num != 1)\\n            {\\n                break;\\n            }\\n        }\\n        if(ans == Integer.MAX_VALUE)\\n        {\\n            return -1;\\n        }\\n        return n - 1 + ans;\\n    }\\n    public int gcd(int a, int b)\\n    {\\n        if(a == 0)\\n        {\\n            return b;\\n        }\\n        return gcd(b%a, a); \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int n = nums.length;\\n        int c = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(nums[i] == 1)\\n            {\\n                c++;\\n            }\\n        }\\n        if(c > 0)\\n        {\\n            return n - c;\\n        }\\n        int ans = Integer.MAX_VALUE;\\n        for(int i=0; i<n; i++)\\n        {\\n            int num = nums[i];\\n            for(int j=i+1; j<n; j++)\\n            {\\n                num = gcd(num, nums[j]);\\n                if(num == 1)\\n                {\\n                    ans = Math.min(ans, j-i);\\n                    break;\\n                }\\n            }\\n            if(num != 1)\\n            {\\n                break;\\n            }\\n        }\\n        if(ans == Integer.MAX_VALUE)\\n        {\\n            return -1;\\n        }\\n        return n - 1 + ans;\\n    }\\n    public int gcd(int a, int b)\\n    {\\n        if(a == 0)\\n        {\\n            return b;\\n        }\\n        return gcd(b%a, a); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3447561,
                "title": "c-solution-o-n-most-optimised-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int one = 0;\\n        for (int i = 0; i < n; i++) one += nums[i] == 1;\\n        if (one) return n - one;\\n        stack<int> la, ra, lg, rg;\\n        auto good = [&](){\\n            int g = 0;\\n            if (!la.empty()) g = gcd(g, lg.top());\\n            if (!ra.empty()) g = gcd(g, rg.top());\\n            return g == 1;\\n        };\\n        auto add  = [&](int x){\\n            ra.push(x);\\n            rg.push(gcd((rg.empty() ? 0 : rg.top()), x));\\n        };\\n        auto remove = [&](){\\n            if (la.empty()){\\n                while(!ra.empty()){\\n                    int x = ra.top(); la.push(x); ra.pop(), rg.pop();\\n                    lg.push(gcd((lg.empty() ? 0 : lg.top()), x));\\n                }\\n            }\\n            la.pop(), lg.pop();\\n        };\\n        int ans = n;\\n        for (int l = 0, r = 0; r < n; r++){\\n            add(nums[r]);\\n            while (l < n and good()){\\n                ans = min(ans, r - l);\\n                remove(), l++;\\n            }\\n        }\\n        if (ans == n) return -1;\\n        return n + ans - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int one = 0;\\n        for (int i = 0; i < n; i++) one += nums[i] == 1;\\n        if (one) return n - one;\\n        stack<int> la, ra, lg, rg;\\n        auto good = [&](){\\n            int g = 0;\\n            if (!la.empty()) g = gcd(g, lg.top());\\n            if (!ra.empty()) g = gcd(g, rg.top());\\n            return g == 1;\\n        };\\n        auto add  = [&](int x){\\n            ra.push(x);\\n            rg.push(gcd((rg.empty() ? 0 : rg.top()), x));\\n        };\\n        auto remove = [&](){\\n            if (la.empty()){\\n                while(!ra.empty()){\\n                    int x = ra.top(); la.push(x); ra.pop(), rg.pop();\\n                    lg.push(gcd((lg.empty() ? 0 : lg.top()), x));\\n                }\\n            }\\n            la.pop(), lg.pop();\\n        };\\n        int ans = n;\\n        for (int l = 0, r = 0; r < n; r++){\\n            add(nums[r]);\\n            while (l < n and good()){\\n                ans = min(ans, r - l);\\n                remove(), l++;\\n            }\\n        }\\n        if (ans == n) return -1;\\n        return n + ans - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445880,
                "title": "o-nlog-max-a-i-solution-cpp",
                "content": "We have to find the shortest subarray with gcd equal to 1. This is a standard problem and can be solved greedily.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int g=0;\\n        int ones=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            g=__gcd(g,nums[i]);\\n            if(nums[i]==1)\\n                ones++;\\n        }\\n        \\n        if(g!=1)\\n            return -1;\\n        if(ones)\\n            return n-ones;\\n        \\n        int ans=1e9;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            unordered_map<int,int> nmp;\\n            nmp[nums[i]]=i;\\n            \\n            for(auto &[ele,r] : mp)\\n            {\\n                int val=__gcd(ele,nums[i]);\\n                if(nmp.find(val)==nmp.end())\\n                    nmp[val]=r;\\n                else\\n                    nmp[val]=std::max(nmp[val],r);\\n            }\\n                        \\n            if(nmp.find(1)!=nmp.end())\\n                ans=std::min(ans,n-1+i-nmp[1]);\\n            \\n            swap(nmp,mp);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nTime Complexity: **O(Nlog(Max(A[i])))**\\nSpace Complexity : **O(log(Max(A[i])))**\\n\\nplease set better constraints.",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int g=0;\\n        int ones=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            g=__gcd(g,nums[i]);\\n            if(nums[i]==1)\\n                ones++;\\n        }\\n        \\n        if(g!=1)\\n            return -1;\\n        if(ones)\\n            return n-ones;\\n        \\n        int ans=1e9;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            unordered_map<int,int> nmp;\\n            nmp[nums[i]]=i;\\n            \\n            for(auto &[ele,r] : mp)\\n            {\\n                int val=__gcd(ele,nums[i]);\\n                if(nmp.find(val)==nmp.end())\\n                    nmp[val]=r;\\n                else\\n                    nmp[val]=std::max(nmp[val],r);\\n            }\\n                        \\n            if(nmp.find(1)!=nmp.end())\\n                ans=std::min(ans,n-1+i-nmp[1]);\\n            \\n            swap(nmp,mp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3465421,
                "title": "follow-up-is-misleading",
                "content": "The follow up asks if you can find a O(1) time algorithm after assuming that you found a O(n) algorithm. Even though the input size is 50, it\\'s technically not possible to get a true O(1) time algorithm here nor should it be assumed that a O(n) time algorithm is the standard solution for this problem. The follow up should be removed or reworded as it\\'s misleading.",
                "solutionTags": [],
                "code": "The follow up asks if you can find a O(1) time algorithm after assuming that you found a O(n) algorithm. Even though the input size is 50, it\\'s technically not possible to get a true O(1) time algorithm here nor should it be assumed that a O(n) time algorithm is the standard solution for this problem. The follow up should be removed or reworded as it\\'s misleading.",
                "codeTag": "Unknown"
            },
            {
                "id": 3446929,
                "title": "gcd-simple-explanation-java",
                "content": "**\\uD83D\\uDD1D\\uD83D\\uDD1D\\u2B06\\uFE0F\\u2B06\\uFE0FPlease Upvote if you find it useful. \\u2B06\\uFE0F\\u2B06\\uFE0F\\uD83D\\uDD1D\\uD83D\\uDD1D**\\n\\n# Intuition & Approach\\n1. If there are `x` numbers of `1` present in nums, then every number other than the `1s` can be converted to `1` in `n-x` operations by taking `gcd(1, nums[i])`, where `nums[i]!=1`.\\n2. If there are zero 1s present in nums, then we might never get a 1, or we might get a 1.\\n3. Let\\'s say there is a range `[i, j]` and the GCD of this entire range is `1`. That means, we can convert one of the elements in the range `[i, j]` to `1` in `(j-i)` operations.\\n4. Now once we convert any element to `1`, we can simply convert other elements to `1` in `(n - 1)` steps. So the total number of operations would be `(j - i + n - 1)`.\\n5. The Answer would be the minimum of this value over all possible ranges, where GCD of range is `1`.\\n\\n# Complexity\\n- Time complexity:\\n`O(N^2 * log(MAX))`, where `MAX` is the maximum value in the input array.\\n\\n- Space complexity:\\n`O(log(N))`\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int noOfOnes = 0;\\n        for (int num : nums) {\\n            if (num == 1) noOfOnes++;\\n        }\\n        if (noOfOnes > 0) return nums.length - noOfOnes;\\n        int ans = Integer.MAX_VALUE;\\n        for (int i = 0; i < nums.length; i++) {\\n            int gcd = nums[i]; // Take initial GCD of the [i, j] range\\n            for (int j = i + 1; j < nums.length; j++) {\\n                gcd = findGCD(gcd, nums[j]);  // For every new j, take gcd(nums[j], previousGCD) \\n                if (gcd == 1) ans = Math.min(ans, j - i + nums.length - 1);\\n            }\\n        }\\n        return ans == Integer.MAX_VALUE ? -1 : ans;\\n    }\\n\\n    private int findGCD(int a, int b) {\\n        if (a == 0) return b;\\n        return findGCD(b % a, a);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int noOfOnes = 0;\\n        for (int num : nums) {\\n            if (num == 1) noOfOnes++;\\n        }\\n        if (noOfOnes > 0) return nums.length - noOfOnes;\\n        int ans = Integer.MAX_VALUE;\\n        for (int i = 0; i < nums.length; i++) {\\n            int gcd = nums[i]; // Take initial GCD of the [i, j] range\\n            for (int j = i + 1; j < nums.length; j++) {\\n                gcd = findGCD(gcd, nums[j]);  // For every new j, take gcd(nums[j], previousGCD) \\n                if (gcd == 1) ans = Math.min(ans, j - i + nums.length - 1);\\n            }\\n        }\\n        return ans == Integer.MAX_VALUE ? -1 : ans;\\n    }\\n\\n    private int findGCD(int a, int b) {\\n        if (a == 0) return b;\\n        return findGCD(b % a, a);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445980,
                "title": "c-easiest-solution-with-amazing-explanation",
                "content": "# For the Given Problem:\\n**Task:\\n\\tConvert all the numbers to 1.\\n        At One step for any index i, you can convert nums[i] or nums[i+1] to gcd of them.\\n\\t\\treturn minimum number of operations or -1(if not possible)**\\n# Solution:\\n**1. Check when answer is not possible:**\\nIf gcd of all the numbers comes out to be not 1 then answer is -1 as we can\\'t achieve our    results.  Logic: If gcd of all the numbers can\\'t be one then gcd of any two numbers can also be not equal to 1.\\n\\n**2. If answer exist.**\\n  1. Calculate count of 1 in the nums, if ct>0 then we ans is ***(length of nums -ct)***\\n     Logic: We can use 1 to make all the remaining numbers 1 and for each number it takes one step.\\n\\t2. If no 1 is present in the nums, then find out how many operation require to convert every number to 1, and select the number which is taking the least operations to convert itself to 1 and then return ***number of operation to convert that number to 1 plus remaining numbers(n-1)***\\n\\n**TC: O(n^2)**\\n\\t \\n\\tclass Solution {\\n\\tpublic:\\n    \\n    int fn(vector<int>&nums)\\n    {\\n        int n = nums.size();\\n        vector<int>ans;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            int v = __gcd(nums[i],nums[i+1]);\\n            ans.push_back(v);\\n            if(v==1) return 1;\\n        }        \\n        int val = 1+fn(ans);\\n        return val;\\n    }\\n    \\n    int minOperations(vector<int>& nums) \\n    {\\n        // Step:1: ans not exist\\n        int all=nums[0];\\n        for(auto i:nums)\\n        {\\n            all = __gcd(all,i);\\n        }\\n        if(all!=1) return -1;\\n        \\n        // step:2 checking one is present or note\\n        int n = nums.size();\\n        int ct_one =0;\\n        for(auto i:nums)\\n        {\\n            if(i==1) ct_one++;\\n        }\\n        \\n        if(ct_one>0) return n-ct_one;\\n        \\n        // step-3 : checking for minimum operations.\\n        int val = fn(nums);\\n        return n-1+val;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    \\n    int fn(vector<int>&nums)\\n    {\\n        int n = nums.size();\\n        vector<int>ans;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            int v = __gcd(nums[i],nums[i+1]);\\n            ans.push_back(v);\\n            if(v==1) return 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3445894,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- If we have 1 as an element, then it can be propagated to other elements since Gcd of any number and 1 is 1. \\n- So the answer is number of operations required to make any element 1 + number of remaining elements. \\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int n = nums.length;\\n        int g = 0;\\n        int one = 0;\\n        for (int num : nums) {\\n            // Compute gcd of all elements\\n            g = gcd(g, num);\\n\\n            // Count number of ones\\n            if (num == 1) \\n                one++;\\n        }\\n        // If Gcd of all elements is not 1, then we cannot produce \\n        // a 1 in any number of operations.\\n        if (g != 1) \\n            return -1;\\n\\n        // If there are already 1s in the array, \\n        // then simply return the number of remaining elements.\\n        if (one > 0) \\n            return n-one;\\n\\n        int ans = 100000;\\n        for (int i = 0; i < n; i++) {\\n            g = 0;\\n            for (int j = i; j >= 0; j--) {\\n                g = gcd(g, nums[j]);\\n                // If GCD of the subarray becomes 1,\\n                // count the number of operations (i-j) + remaining elements (n-1)\\n                if (g == 1) {\\n                    ans = Math.min(ans, i-j+n-1);\\n                    break;\\n                }\\n            }\\n        } \\n        return ans; \\n    }\\n    \\n    static int gcd(int a, int b)\\n    {\\n        if (b == 0)\\n            return a;\\n        else\\n            return gcd(b, a % b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int n = nums.length;\\n        int g = 0;\\n        int one = 0;\\n        for (int num : nums) {\\n            // Compute gcd of all elements\\n            g = gcd(g, num);\\n\\n            // Count number of ones\\n            if (num == 1) \\n                one++;\\n        }\\n        // If Gcd of all elements is not 1, then we cannot produce \\n        // a 1 in any number of operations.\\n        if (g != 1) \\n            return -1;\\n\\n        // If there are already 1s in the array, \\n        // then simply return the number of remaining elements.\\n        if (one > 0) \\n            return n-one;\\n\\n        int ans = 100000;\\n        for (int i = 0; i < n; i++) {\\n            g = 0;\\n            for (int j = i; j >= 0; j--) {\\n                g = gcd(g, nums[j]);\\n                // If GCD of the subarray becomes 1,\\n                // count the number of operations (i-j) + remaining elements (n-1)\\n                if (g == 1) {\\n                    ans = Math.min(ans, i-j+n-1);\\n                    break;\\n                }\\n            }\\n        } \\n        return ans; \\n    }\\n    \\n    static int gcd(int a, int b)\\n    {\\n        if (b == 0)\\n            return a;\\n        else\\n            return gcd(b, a % b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449499,
                "title": "python-o-n-time-solution-two-pass",
                "content": "The goal of this problem is to get **the minimun size of subarray with gcd 1**\\n\\nFor the 1st pass, \\nWe can record the gcd of the element with previous ones by traversing the array.\\nWhen gcd becomes to 1, the gcd will be reset as the current element.\\nMeanwhile, we will record this index, because it is the **ENDING** of subarray with gcd 1.\\n\\nFor the 2nd pass, \\nWe will traverse the array from each **ENDING** point BACK to index 0.\\nThe goal is to find the **BEGINING** of subarray with gcd 1 for each ENDING.\\n\\nNote the previous 2-pass traveral is performed **from left to right**.\\nWe need another 2-pass traveral **from right to left**.\\n\\n```\\ndef minOperations(self, a: List[int]) -> int:\\n\\tif 1 in a:\\n\\t\\treturn len(a)-a.count(1)\\n\\tdef check(nums):\\n\\t\\tq, x, count = [0], nums[0], len(nums)+10\\n\\t\\t# index-0 is needed since it defines the left bound of our traversal\\n\\t\\tfor i in range(len(nums)):\\n\\t\\t\\tx = gcd(nums[i], x)\\n\\t\\t\\tif x==1:\\n\\t\\t\\t\\tq, x = q+[i], nums[i] \\n\\t\\t\\t# recording the ending of subarray with gcd 1\\n\\t\\tfor k in range(len(q)-1, 0, -1):\\n\\t\\t\\tx = nums[q[k]]\\n\\t\\t\\t# searching for the beginning of subarray with each ending\\n\\t\\t\\tfor i in range(q[k], q[k-1]-1, -1):\\n\\t\\t\\t\\tx = gcd(nums[i], x)\\n\\t\\t\\t\\tif x==1:\\n\\t\\t\\t\\t\\tcount = min(count, q[k]-i+1)\\n\\t\\t\\t\\t\\tbreak\\n\\t\\treturn count\\n\\tx = min(check(a), check(a[::-1]))\\n\\t# with x-length of subarry, we need \\'x-1\\' operation to get 1\\n\\treturn len(a)+x-2 if x<=len(a) else -1\\n```",
                "solutionTags": [],
                "code": "```\\ndef minOperations(self, a: List[int]) -> int:\\n\\tif 1 in a:\\n\\t\\treturn len(a)-a.count(1)\\n\\tdef check(nums):\\n\\t\\tq, x, count = [0], nums[0], len(nums)+10\\n\\t\\t# index-0 is needed since it defines the left bound of our traversal\\n\\t\\tfor i in range(len(nums)):\\n\\t\\t\\tx = gcd(nums[i], x)\\n\\t\\t\\tif x==1:\\n\\t\\t\\t\\tq, x = q+[i], nums[i] \\n\\t\\t\\t# recording the ending of subarray with gcd 1\\n\\t\\tfor k in range(len(q)-1, 0, -1):\\n\\t\\t\\tx = nums[q[k]]\\n\\t\\t\\t# searching for the beginning of subarray with each ending\\n\\t\\t\\tfor i in range(q[k], q[k-1]-1, -1):\\n\\t\\t\\t\\tx = gcd(nums[i], x)\\n\\t\\t\\t\\tif x==1:\\n\\t\\t\\t\\t\\tcount = min(count, q[k]-i+1)\\n\\t\\t\\t\\t\\tbreak\\n\\t\\treturn count\\n\\tx = min(check(a), check(a[::-1]))\\n\\t# with x-length of subarry, we need \\'x-1\\' operation to get 1\\n\\treturn len(a)+x-2 if x<=len(a) else -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3446079,
                "title": "gcd-100-faster-c-easy-to-understand",
                "content": "![image](https://assets.leetcode.com/users/images/c4eaaed5-229a-49e3-9e72-9a74dd7a7c94_1682226829.9661312.png)\\n````\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int i,g= 0;\\n        for(i = 0; i < nums.size(); i++){\\n            g = __gcd(g,nums[i]);\\n        }\\n        if(g>1)return -1;\\n        int y = 0;\\n        for(auto &i: nums){\\n            y += (i==1);\\n        }\\n        if(y)return nums.size()-y;\\n        int x = INT_MAX,j;\\n        for(i = 0; i < nums.size(); i++){\\n            int g = 0;\\n            for(j = i; j < nums.size(); j++){\\n                g = __gcd(g,nums[j]);\\n                if(g==1)break;\\n            }\\n            if(g==1&&j-i+1<x){x = j-i+1;}\\n        }\\n        return nums.size()+x-2;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int i,g= 0;\\n        for(i = 0; i < nums.size(); i++){\\n            g = __gcd(g,nums[i]);\\n        }\\n        if(g>1)return -1;\\n        int y = 0;\\n        for(auto &i: nums){\\n            y += (i==1);\\n        }\\n        if(y)return nums.size()-y;\\n        int x = INT_MAX,j;\\n        for(i = 0; i < nums.size(); i++){\\n            int g = 0;\\n            for(j = i; j < nums.size(); j++){\\n                g = __gcd(g,nums[j]);\\n                if(g==1)break;\\n            }\\n            if(g==1&&j-i+1<x){x = j-i+1;}\\n        }\\n        return nums.size()+x-2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445942,
                "title": "simple-c-solution-using-smallest-subarray-having-gcd-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can find smallest subarray with gcd 1, and we can make other element in n-1 operation. if gcd of whole array is greater than 1 then ans does not exist\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialise and define function for gcd and smallest subarrayy having gcd as 1.\\n2. Check if gcd of whole array is greater than 1 or not, if it is greater than 1 then return -1.\\n3. count ones and if gcd of any two consecutive number is 1 then return n-ones.\\n4. Find smallest sub array having gcd 1, ans will be length of subarray - 1 + n-1.\\n\\n# Complexity\\n- Time complexity:N*LOG(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int gcd(int a, int b)\\n    {\\n\\t  if (b == 0)\\n\\t  {\\n\\t  \\treturn a;\\n\\t  }\\n\\t  return gcd(b, a % b);\\n    }\\n    int findSmallestSubArr(vector<int> &arr, int n, int g){\\n        int ans=INT_MAX,gg=0;\\n        for(int i=0;i<n;i++){\\n            gg=arr[i];\\n            for(int j=i;j<n;j++){\\n                if(arr[j]%g!=0) break;\\n                gg=gcd(gg,arr[j]);\\n                if(gg==g){\\n                    ans=min(ans,j-i+1);\\n                }\\n            }\\n        }\\n        return ans==INT_MAX ? -1:ans;\\n    }\\n    int minOperations(vector<int>& nums) {\\n        int g=nums[0];\\n        int one=0;\\n        for(auto x:nums)\\n        {\\n            if(x==1) one++;\\n            g=gcd(g,x);\\n        }\\n        if(g>1) return -1;\\n        bool ok=false;\\n        int n=nums.size();\\n        for(int i=1;i<n;i++)\\n        {\\n            if(gcd(nums[i],nums[i-1])==1){\\n                ok=true;\\n                break;\\n            }\\n        }\\n        if(ok) return n-one;\\n  \\n      int d= findSmallestSubArr(nums,n,1);\\n       int ans=d-1+n-1;\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Simulation",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int gcd(int a, int b)\\n    {\\n\\t  if (b == 0)\\n\\t  {\\n\\t  \\treturn a;\\n\\t  }\\n\\t  return gcd(b, a % b);\\n    }\\n    int findSmallestSubArr(vector<int> &arr, int n, int g){\\n        int ans=INT_MAX,gg=0;\\n        for(int i=0;i<n;i++){\\n            gg=arr[i];\\n            for(int j=i;j<n;j++){\\n                if(arr[j]%g!=0) break;\\n                gg=gcd(gg,arr[j]);\\n                if(gg==g){\\n                    ans=min(ans,j-i+1);\\n                }\\n            }\\n        }\\n        return ans==INT_MAX ? -1:ans;\\n    }\\n    int minOperations(vector<int>& nums) {\\n        int g=nums[0];\\n        int one=0;\\n        for(auto x:nums)\\n        {\\n            if(x==1) one++;\\n            g=gcd(g,x);\\n        }\\n        if(g>1) return -1;\\n        bool ok=false;\\n        int n=nums.size();\\n        for(int i=1;i<n;i++)\\n        {\\n            if(gcd(nums[i],nums[i-1])==1){\\n                ok=true;\\n                break;\\n            }\\n        }\\n        if(ok) return n-one;\\n  \\n      int d= findSmallestSubArr(nums,n,1);\\n       int ans=d-1+n-1;\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445685,
                "title": "brute-force-full-explained-c",
                "content": "# Intuition\\n- Is it possible to make all numbers equal to one if the $gcd$ of all elements is not $1$?\\n- What if we already have some $1$?\\n- By the limits can be solved with brute force\\n# Analysis\\nThe answer to the first question is no, since there will always be some common divisor other than one for each subset. \\n\\nNow if the $gcd$ of the whole matrix is $1$ that means that there exists at least one subset $s$ whose $gcd_s=1$ but thinking in subsets is not useful since we have to choose adjacent elements however we can observe that: \\n\\nIf we have some subset $s$ of size $k$ and $gcd_s=1$ with index $s_1, s_2,s_3,\\\\dots s_k$ and $s_i<s_{i+1} \\\\;,\\\\;\\\\; 0\\\\leq i \\\\leq k-1$ it is logical that the subarray defined by the indices $[s_1,s_k]$ will also have $gcd = 1$ and we can apply the operations in this order $(s_1, s_{1+1}), (s_{1+1},s_{1+2}), (s_{1+len-2}, s_k)$ (always changing the one on the right) where $len = s_k-s_1+1$ denotes the length of the subarray. Doing these operations we will have a $1$ at position $s_k$ let\\'s see a small example: \\n\\n$A = [6,18,9,90,45,5]$ let\\'s see that the subset $S = {2,4}$ has $gcd==1$ so the subarray $[2,5]$ also has $gcd==1$ let\\'s apply the operations on the subset $S = {2,4}$.\\n \\n$Op1 = (2,3)$  $\\\\rightarrow$ $A = [6,18,9,9,9,45,5]$\\n$Op2 = (3,4)$  $\\\\rightarrow$ $A = [6,18,9,9,9,9,9,5]$\\n$Op2 = (4,5)$  $\\\\rightarrow$ $A = [6,18,9,9,9,9,9,1,1]$\\n\\nNow, what happens when we have some $1$ in the array? we just have to propagate until we fill the array with ones and this will cost , $n-ones$ where $n$ is the size of the array. I recommend dealing with ones at the beginning, that is, find out if there are ones at the beginning and simply return $n-ones$ as the answer. \\n\\nAfter dealing with ones we have a situation where we have to create this first $1$ then propagate it, in this case the answer will be $bestcost+n-1$ where $bestCost$ is the best way to create just a $1$. now the rest is to find the best way. \\nNotice how the bounds are very small $1 \\\\leq n \\\\leq 50$ that means we can iterate over all the subarrays and check if one of them has $gcd=1$ and use the one with the shortest length, by choosing the subarray with the shortest length we will get that $bestCost = len-1$ where $len$ is the length.  \\n\\n# Approach\\n- Count the number of ones at the beginning \\n- If there is at least $1$ the answer will be $n-ones$. \\n- If not, we have to find the smallest subarray with $gcd==1$ and the answer will be $len-1 +n-1$. \\n- To check the best subarray we can use brute force, since the bounds are very small. \\n\\n# Hard version. \\nThis problem could have been a good hard problem, I don\\'t know why they decided to put a medium difficulty one.  \\n$n$ could be at most $1000$ for this solution and probably still pass in time, but what happens if $n \\\\leq 10^5$.\\n- Solution: Binary search + some data structure that allows to get gcd in range getting a solution $o(n log(n)^2)$ but you can even optimize up to $O(n log(MAX))$ without an advanced data structure. \\n\\n# Complexity \\n$O(n^2 \\\\times log(MAX))$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int ans = 1e9;\\n        int ones = 0;\\n        for(int i = 0;i<n;i++)ones+=nums[i]==1;\\n        \\n        if(ones)return n-ones;\\n        \\n        for(int i = 0;i<n;i++){\\n            int gcd = 0;\\n            \\n            for(int j = i;j<n;j++){\\n                gcd = __gcd(gcd,nums[j]);\\n                \\n                if(gcd == 1){\\n                    int len = (j-i)+1;\\n                    ans = min(ans,(len-1)+(n-1));\\n                }\\n            }\\n            \\n         \\n        \\n        }\\n        if(ans == 1e9)ans = -1;\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int ans = 1e9;\\n        int ones = 0;\\n        for(int i = 0;i<n;i++)ones+=nums[i]==1;\\n        \\n        if(ones)return n-ones;\\n        \\n        for(int i = 0;i<n;i++){\\n            int gcd = 0;\\n            \\n            for(int j = i;j<n;j++){\\n                gcd = __gcd(gcd,nums[j]);\\n                \\n                if(gcd == 1){\\n                    int len = (j-i)+1;\\n                    ans = min(ans,(len-1)+(n-1));\\n                }\\n            }\\n            \\n         \\n        \\n        }\\n        if(ans == 1e9)ans = -1;\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446750,
                "title": "explained-step-by-step-with-examples-very-easy-to-understand-o-n-2-python-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe key to this problem is to find the first \"1\" of GCD result. Once it has been found, it can be spread to all the rest elements by lenth of the array - 1 (len(nums)-1) steps.\\n\\nIt would be easy if the GCD of two adjacent elements is \"1\". But what if the coprime factors are far apart and require several steps to pass and meet together? Every adjacent GCDs will be calculated and stored, then the same process is done to all adjacent GCD results till a \"1\" has been found or only one result remains.\\n\\n# Explaination with examples\\n<!-- Describe your approach to solving the problem. -->\\nConsider this case: [2,6,6,6,3,9], calculate GCD for all adjacent elements. And do the same thing to the results, until there is a \"1\".\\n```\\n2 6 6 6 3 9\\n 2 6 6 3 3     step 1\\n  2 6 3 3      step 2\\n   2 3 3       step 3\\n    1 3        step 4\\n```\\nThe coprime factors are 2 and 3 and they are at two sides of the array. It takes at least 4 steps for them to meet and have the GCD \"1\". The final result will be 4 plus 6-1 steps to spread \"1\"s to the whole array. \\n\\nIf it never gets 1, then return -1. Check this case: [2,10,6,14]\\n```\\n2 10 6 14\\n 2  2  2    step 1\\n   2  2     step 2\\n    2       step 3\\n```\\n\\nAnd don\\'t forget the case that there are \"1\"s in the number array. So the array has to be checked first, and just need number of non-one elements steps to make the array full of ones.\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1), modify the array in place.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nC++\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int ct = 0;\\n        for(int i=0; i<nums.size(); i++)\\n            if(nums[i] == 1)\\n                ct++;\\n        if(ct > 0)\\n            return nums.size() - ct;\\n        for(int steps=0; steps<nums.size()-1; steps++)\\n            for(int i=0; i<nums.size()-steps-1; i++){\\n                nums[i] = gcd(nums[i], nums[i+1]);\\n                if(nums[i] == 1)\\n                    return steps + nums.size();\\n            }\\n        return -1;\\n    }\\n};\\n```\\nPython\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        ct, n = 0, len(nums)\\n        for d in nums:\\n            if d == 1:\\n                ct += 1\\n        if ct > 0:\\n            return n - ct\\n        for steps in range(n):\\n            for i in range(n - steps - 1):\\n                nums[i] = gcd(nums[i], nums[i+1])\\n                if nums[i] == 1:\\n                    return steps + n\\n        return -1\\n```",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```\\n2 6 6 6 3 9\\n 2 6 6 3 3     step 1\\n  2 6 3 3      step 2\\n   2 3 3       step 3\\n    1 3        step 4\\n```\n```\\n2 10 6 14\\n 2  2  2    step 1\\n   2  2     step 2\\n    2       step 3\\n```\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int ct = 0;\\n        for(int i=0; i<nums.size(); i++)\\n            if(nums[i] == 1)\\n                ct++;\\n        if(ct > 0)\\n            return nums.size() - ct;\\n        for(int steps=0; steps<nums.size()-1; steps++)\\n            for(int i=0; i<nums.size()-steps-1; i++){\\n                nums[i] = gcd(nums[i], nums[i+1]);\\n                if(nums[i] == 1)\\n                    return steps + nums.size();\\n            }\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        ct, n = 0, len(nums)\\n        for d in nums:\\n            if d == 1:\\n                ct += 1\\n        if ct > 0:\\n            return n - ct\\n        for steps in range(n):\\n            for i in range(n - steps - 1):\\n                nums[i] = gcd(nums[i], nums[i+1])\\n                if nums[i] == 1:\\n                    return steps + n\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446411,
                "title": "javascript-2654-minimum-number-of-operations-to-make-all-array-elements-equal-to-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n1\\n```\\nvar minOperations = function (a) {\\n    let nori = a.length; // n original length of array\\n\\n    // edge case 1 - check if only 1 unique element exist, and that element is 1 => all ones\\n    let set = new Set(a);\\n    if (set.size === 1)\\n        if (a[0] === 1) {\\n            return 0;\\n        }\\n\\n    // edge case 2 - check if some ones exist - count ones if exist\\n    let ones = 0;\\n    for (let i = 0; i < nori; i++)\\n        if (a[i] === 1) {\\n            ones++;\\n        }\\n    if (ones) {\\n        return nori - ones;\\n    }\\n\\n    // main work - find gcds and repeatedly replace array a & repeat\\n    let cc = 0;\\n    while (a.length) {\\n        let n = a.length;\\n        let a2 = [];\\n        for (let i = 0; i < n - 1; i++) {\\n            let g = gcd(a[i], a[i + 1]);\\n            if (g === 1) {\\n                return nori + cc; // when one can become 1, others can as well\\n            }\\n            a2.push(g);\\n        }\\n        a = a2;\\n        cc++;\\n    }\\n    return -1;\\n\\n    function gcd(a, b) {\\n        if (b == 0) return a;\\n        return gcd(b, a % b);\\n    }\\n};\\n```\\n\\n---\\n\\n**Contest**\\n- https://leetcode.com/contest/weekly-contest-342/ranking/67/\\n\\n**All Answers**\\n- **Q1** - https://leetcode.com/problems/calculate-delayed-arrival-time/solutions/3446023/javascript-2651-calculate-delayed-arrival-time/?orderBy=most_votes\\n- **Q2** - https://leetcode.com/problems/sum-multiples/solutions/3446027/javascript-2652-sum-multiples/?orderBy=most_votes\\n- **Q3** - https://leetcode.com/problems/sliding-subarray-beauty/solutions/3446035/javascript-2653-sliding-subarray-beauty/?orderBy=most_votes\\n- **Q4** - https://leetcode.com/problems/minimum-number-of-operations-to-make-all-array-elements-equal-to-1/solutions/3446411/javascript-2654-minimum-number-of-operations-to-make-all-array-elements-equal-to-1/?orderBy=most_votes\\n\\n---\\n\\n![image.png](https://assets.leetcode.com/users/images/37970e7b-b559-4aa9-834c-e178df5ddaa7_1682232917.7638698.png)\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minOperations = function (a) {\\n    let nori = a.length; // n original length of array\\n\\n    // edge case 1 - check if only 1 unique element exist, and that element is 1 => all ones\\n    let set = new Set(a);\\n    if (set.size === 1)\\n        if (a[0] === 1) {\\n            return 0;\\n        }\\n\\n    // edge case 2 - check if some ones exist - count ones if exist\\n    let ones = 0;\\n    for (let i = 0; i < nori; i++)\\n        if (a[i] === 1) {\\n            ones++;\\n        }\\n    if (ones) {\\n        return nori - ones;\\n    }\\n\\n    // main work - find gcds and repeatedly replace array a & repeat\\n    let cc = 0;\\n    while (a.length) {\\n        let n = a.length;\\n        let a2 = [];\\n        for (let i = 0; i < n - 1; i++) {\\n            let g = gcd(a[i], a[i + 1]);\\n            if (g === 1) {\\n                return nori + cc; // when one can become 1, others can as well\\n            }\\n            a2.push(g);\\n        }\\n        a = a2;\\n        cc++;\\n    }\\n    return -1;\\n\\n    function gcd(a, b) {\\n        if (b == 0) return a;\\n        return gcd(b, a % b);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3446266,
                "title": "video-explanation-includes-all-the-proofs",
                "content": "# Explanation\\n\\nhttps://youtu.be/ituCxE_aoyE\\n\\n[Click here if the preview above doesn\\'t works](https://youtu.be/ituCxE_aoyE)\\n\\n# Code\\n```\\nclass Solution {    \\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        int full_gcd = 0;\\n        for (auto i : nums) full_gcd = __gcd (full_gcd, i);\\n        if (full_gcd != 1) return -1;\\n        \\n        int ones = 0;\\n        for (auto i : nums) \\n            if (i == 1) ones ++;\\n        \\n        if (ones > 0) return (n - ones);\\n        \\n        vector<int> steps_to_1 (n, n);\\n        for (int j = 0; j < n; j ++) {\\n            int& steps = steps_to_1[j];\\n            \\n            for (int l = 0; l <= j; l ++) {\\n                for (int r = j; r < n; r ++) {\\n                    int gcd = 0;\\n                    for (int i = l; i <= r; i ++) gcd = __gcd (gcd, nums[i]);\\n                    \\n                    if (gcd == 1)\\n                        steps = min (steps, r-l);\\n                }\\n            }\\n        }\\n        \\n        int min_steps_to_1 = n;\\n        for (auto i : steps_to_1) min_steps_to_1 = min (min_steps_to_1, i);\\n        \\n        return (min_steps_to_1 + n-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {    \\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        int full_gcd = 0;\\n        for (auto i : nums) full_gcd = __gcd (full_gcd, i);\\n        if (full_gcd != 1) return -1;\\n        \\n        int ones = 0;\\n        for (auto i : nums) \\n            if (i == 1) ones ++;\\n        \\n        if (ones > 0) return (n - ones);\\n        \\n        vector<int> steps_to_1 (n, n);\\n        for (int j = 0; j < n; j ++) {\\n            int& steps = steps_to_1[j];\\n            \\n            for (int l = 0; l <= j; l ++) {\\n                for (int r = j; r < n; r ++) {\\n                    int gcd = 0;\\n                    for (int i = l; i <= r; i ++) gcd = __gcd (gcd, nums[i]);\\n                    \\n                    if (gcd == 1)\\n                        steps = min (steps, r-l);\\n                }\\n            }\\n        }\\n        \\n        int min_steps_to_1 = n;\\n        for (auto i : steps_to_1) min_steps_to_1 = min (min_steps_to_1, i);\\n        \\n        return (min_steps_to_1 + n-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446118,
                "title": "easy-to-understand-python-interview-solution",
                "content": "# Intuition\\nIdea: GCD of two numbers will be 1 only if:-\\n    1. Either of two number is 1.\\n    2. They don\\'t have any common factor.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n1. Check for count of 1\\'s in `nums`. If there are ones present in this `nums` then number of `operations = n - count(ones)`.\\n\\n2. Now, if there is no 1\\'s in `nums`, then just try to make 1 by calculating gcd for `nums[i]` and `nums[i+1]`. If we found gcd = 1 then, number of `operations = number of operations to achieve gcd=1` + `length of all non 1\\'s element in list (len(nums)-1)`.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) # not including for gcd recursion.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def gcd(self, a, b):\\n        if b == 0:\\n            return abs(a)\\n        else:\\n            return self.gcd(b, a%b)\\n        \\n    def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        ones = nums.count(1)\\n        if ones: return n - ones\\n        ans = float(\"inf\")\\n        \\n        for l in range(n):\\n            g = nums[l]\\n            for r in range(l+1, n):\\n                g = self.gcd(g, nums[r])\\n                if g == 1:\\n                    ans = min(ans, r-l + (n-1))\\n                    break\\n        \\n        return ans if ans != float(\"inf\") else -1\\n```\\n\\n\\n## Note:\\n    - If you got something to learn from this solution please upvote, So I feel motivated doing same.\\n    - Also let me know if there is something better, I am happy to know that too.\\n\\n\\n# ********** Keep Learning @ Keep Coding **********",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def gcd(self, a, b):\\n        if b == 0:\\n            return abs(a)\\n        else:\\n            return self.gcd(b, a%b)\\n        \\n    def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        ones = nums.count(1)\\n        if ones: return n - ones\\n        ans = float(\"inf\")\\n        \\n        for l in range(n):\\n            g = nums[l]\\n            for r in range(l+1, n):\\n                g = self.gcd(g, nums[r])\\n                if g == 1:\\n                    ans = min(ans, r-l + (n-1))\\n                    break\\n        \\n        return ans if ans != float(\"inf\") else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445772,
                "title": "cpp-simple-solution-with-explanation",
                "content": "# Description\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nYou are given a 0-indexed array nums consisiting of positive integers. You can do the following operation on the array any number of times:\\n\\nSelect an index i such that 0 <= i < n - 1 and replace either of nums[i] or nums[i+1] with their gcd value.\\nReturn the minimum number of operations to make all elements of nums equal to 1. If it is impossible, return -1.\\n\\nThe gcd of two integers is the greatest common divisor of the two integers.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nFirst, the code checks if there are any 1\\'s in the input vector. If there are, it returns the number of elements in the input vector that are not equal to 1, as we can make all the elements equal to 1 by repeatedly adding 1 to any non-1 element.\\n\\nIf there are no 1\\'s in the input vector, the code iterates through each pair of elements in the input vector and takes the GCD of each pair. If the resulting GCD ever becomes 1, the number of operations required to make all the elements equal is calculated as the difference between the indices of the two elements that produced the GCD of 1. The minimum number of operations required to make all the elements equal is updated as the minimum of its current value and the number of operations required for the current pair of elements. If it is not possible to make all the elements of the input vector equal, the function returns -1.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this C++ code is O(n^2 log(maximum value in the input vector)), where n is the size of the input vector. The nested loop iterates over all pairs of elements in the input vector and the __gcd function takes log(maximum value in the input vector) time to calculate the GCD of two numbers.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this code is O(1) as it only uses a constant amount of extra space for storing some integer variables. However, note that the __gcd function itself might use additional memory, which is not accounted for in the space complexity analysis of this code.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int cntOnes = 0;\\n        for(int i=0; i<n; i++) {\\n            if(nums[i] == 1) cntOnes++;\\n        }\\n\\n        if(cntOnes > 0) return n - cntOnes;\\n\\n        int minOps = INT_MAX;\\n        for(int i=0; i<n; i++) {\\n            int num = nums[i];\\n            for(int j=i+1; j<n; j++) {\\n                num = __gcd(num, nums[j]);\\n                if(num == 1) {\\n                    minOps = min(minOps, j-i);\\n                    break;\\n                }\\n            }\\n            if(num != 1) break;\\n        }\\n        return (minOps == INT_MAX) ? -1 : n-1+minOps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int cntOnes = 0;\\n        for(int i=0; i<n; i++) {\\n            if(nums[i] == 1) cntOnes++;\\n        }\\n\\n        if(cntOnes > 0) return n - cntOnes;\\n\\n        int minOps = INT_MAX;\\n        for(int i=0; i<n; i++) {\\n            int num = nums[i];\\n            for(int j=i+1; j<n; j++) {\\n                num = __gcd(num, nums[j]);\\n                if(num == 1) {\\n                    minOps = min(minOps, j-i);\\n                    break;\\n                }\\n            }\\n            if(num != 1) break;\\n        }\\n        return (minOps == INT_MAX) ? -1 : n-1+minOps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716673,
                "title": "easy-c-solution-simple-approach-with-explanation-beats-100-in-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- We need to find **one element with value 1** and then the answer is `nums.size()-1`. If there are **k elements with value 1** then answer is `nums.size()-k`. This is because the **gcd of any value with 1 will be 1** and thus we can perform gcd of the element with 1 with its neighbouring elements to get every element equal to 1. \\n- If array does not have element with value 1 then perform gcd of adjacent elements from the start and `find the pair of elements with gcd = 1`. Starting from there, then we just need to follow the similar process as the earlier case when any element has value 1.  \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n=nums.size();\\n        int c=count(nums.begin(),nums.end(),1);     // if there is at least 1. then it\\'s easy!\\n        if(c!=0)    return n-c;\\n        int res=INT_MAX/2;        // just a dummy value\\n        for(int i=0;i<n;i++){\\n            int g=nums[i];\\n            for(int j=i+1;j<n;j++){\\n                g=__gcd(g,nums[j]);\\n                if(g==1){\\n                    res=min(res,j-i+(n-1)); // number of operations to make this element 1+ number of non ones (i.e. n-1) .\\n                    break;\\n                } \\n            }\\n        }\\n        return res==INT_MAX/2?-1:res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n=nums.size();\\n        int c=count(nums.begin(),nums.end(),1);     // if there is at least 1. then it\\'s easy!\\n        if(c!=0)    return n-c;\\n        int res=INT_MAX/2;        // just a dummy value\\n        for(int i=0;i<n;i++){\\n            int g=nums[i];\\n            for(int j=i+1;j<n;j++){\\n                g=__gcd(g,nums[j]);\\n                if(g==1){\\n                    res=min(res,j-i+(n-1)); // number of operations to make this element 1+ number of non ones (i.e. n-1) .\\n                    break;\\n                } \\n            }\\n        }\\n        return res==INT_MAX/2?-1:res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3545325,
                "title": "2654-minimum-number-of-operations-to-make-all-array-elements-equal-to-1-java",
                "content": "```\\nclass Solution {\\n    public int gcd(int a,int b)\\n    {\\n        if(b==0)\\n            return a;\\n        return gcd(b,a%b);\\n    }\\n    public int minOperations(int[] nums) {\\n        int cnt1=0,minsubarray=Integer.MAX_VALUE;\\n        for(int x:nums)\\n            if(x==1)\\n            cnt1++;\\n        \\n        if(cnt1>0)\\n            return nums.length-cnt1;\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int curgcd=nums[i];\\n            for(int j=i+1;j<nums.length;j++)\\n            {\\n                curgcd=(gcd(curgcd,nums[j]));\\n                    if(curgcd==1)\\n                    {\\n                        minsubarray=Math.min(minsubarray,j-i);\\n                        break;\\n                    }   \\n            }\\n        }\\n        if(minsubarray!=Integer.MAX_VALUE)\\n            return minsubarray+nums.length-1;\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int gcd(int a,int b)\\n    {\\n        if(b==0)\\n            return a;\\n        return gcd(b,a%b);\\n    }\\n    public int minOperations(int[] nums) {\\n        int cnt1=0,minsubarray=Integer.MAX_VALUE;\\n        for(int x:nums)\\n            if(x==1)\\n            cnt1++;\\n        \\n        if(cnt1>0)\\n            return nums.length-cnt1;\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int curgcd=nums[i];\\n            for(int j=i+1;j<nums.length;j++)\\n            {\\n                curgcd=(gcd(curgcd,nums[j]));\\n                    if(curgcd==1)\\n                    {\\n                        minsubarray=Math.min(minsubarray,j-i);\\n                        break;\\n                    }   \\n            }\\n        }\\n        if(minsubarray!=Integer.MAX_VALUE)\\n            return minsubarray+nums.length-1;\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3489076,
                "title": "c-brute-force",
                "content": "## Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int gcd=nums[0];\\n        for (int i=1; i<nums.size(); i++)gcd= __gcd(gcd,nums[i]);\\n        if (gcd!=1)return -1;\\n        if (count(nums.begin(),nums.end(),1)>0){\\n            return (nums.size()-count(nums.begin(),nums.end(),1));\\n        }\\n        int cnt=INT_MAX;\\n        for (int i=0; i<nums.size(); i++){\\n            int curr= nums[i];\\n            for (int j=i+1; j<nums.size(); j++){\\n                curr= __gcd(curr,nums[j]);\\n                if (curr==1){\\n                    cnt= min(cnt,j-i-1);\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return nums.size()+cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int gcd=nums[0];\\n        for (int i=1; i<nums.size(); i++)gcd= __gcd(gcd,nums[i]);\\n        if (gcd!=1)return -1;\\n        if (count(nums.begin(),nums.end(),1)>0){\\n            return (nums.size()-count(nums.begin(),nums.end(),1));\\n        }\\n        int cnt=INT_MAX;\\n        for (int i=0; i<nums.size(); i++){\\n            int curr= nums[i];\\n            for (int j=i+1; j<nums.size(); j++){\\n                curr= __gcd(curr,nums[j]);\\n                if (curr==1){\\n                    cnt= min(cnt,j-i-1);\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return nums.size()+cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476382,
                "title": "easiest-solution-c",
                "content": "```\\n int minOperations(vector<int>& nums) {\\n        \\n        int value = 0, n = nums.size(),ones = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            value = __gcd(value, nums[i]);\\n            if(nums[i] == 1)\\n                ones++;\\n        }\\n        //if the gcd of the total array is not equal to 1 then not possible\\n        if(value != 1)\\n            return -1;\\n        \\n        //gcd of 1 with any number is 1\\n        if(ones > 0)\\n            return n-ones;\\n        \\n        int min_size = 1e9;\\n        \\n        for(int i = 0; i<n; i++)\\n        {\\n            //generating all subsets\\n            for(int j = i; j<n; j++)\\n            {\\n                \\n                int val = 0;\\n                for(int k = i; k <= j; k++)\\n                {\\n                    val = __gcd(val, nums[k]);\\n                    \\n                    if(val == 1)\\n                    {\\n                        //minimum sized subarray whose gcd is 1\\n                         min_size = min(min_size, j-i+1);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // step= minimum subarray -1, and the rest of the elements\\n        return min_size - 1 + n-1;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\n int minOperations(vector<int>& nums) {\\n        \\n        int value = 0, n = nums.size(),ones = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            value = __gcd(value, nums[i]);\\n            if(nums[i] == 1)\\n                ones++;\\n        }\\n        //if the gcd of the total array is not equal to 1 then not possible\\n        if(value != 1)\\n            return -1;\\n        \\n        //gcd of 1 with any number is 1\\n        if(ones > 0)\\n            return n-ones;\\n        \\n        int min_size = 1e9;\\n        \\n        for(int i = 0; i<n; i++)\\n        {\\n            //generating all subsets\\n            for(int j = i; j<n; j++)\\n            {\\n                \\n                int val = 0;\\n                for(int k = i; k <= j; k++)\\n                {\\n                    val = __gcd(val, nums[k]);\\n                    \\n                    if(val == 1)\\n                    {\\n                        //minimum sized subarray whose gcd is 1\\n                         min_size = min(min_size, j-i+1);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // step= minimum subarray -1, and the rest of the elements\\n        return min_size - 1 + n-1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3476258,
                "title": "python3-solution",
                "content": "# Code\\n```\\nfrom math import gcd\\nclass Solution: \\n    def getGCDs(self, nums):\\n        gcdArr = []\\n        for i in range(len(nums) - 1):\\n            gcdArr.append(gcd(nums[i], nums[i + 1])) \\n        return gcdArr\\n    def minOperations(self, nums):\\n        if 1 in nums: return len(nums) - nums.count(1)\\n        steps = 0\\n        gcdArr = self.getGCDs(nums)\\n        while len(gcdArr) >= 1 and 1 not in gcdArr:\\n            gcdArr = self.getGCDs(gcdArr)\\n            steps += 1\\n        if 1 not in gcdArr: return -1\\n        else: steps += 1\\n        return steps + len(nums) - 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom math import gcd\\nclass Solution: \\n    def getGCDs(self, nums):\\n        gcdArr = []\\n        for i in range(len(nums) - 1):\\n            gcdArr.append(gcd(nums[i], nums[i + 1])) \\n        return gcdArr\\n    def minOperations(self, nums):\\n        if 1 in nums: return len(nums) - nums.count(1)\\n        steps = 0\\n        gcdArr = self.getGCDs(nums)\\n        while len(gcdArr) >= 1 and 1 not in gcdArr:\\n            gcdArr = self.getGCDs(gcdArr)\\n            steps += 1\\n        if 1 not in gcdArr: return -1\\n        else: steps += 1\\n        return steps + len(nums) - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464767,
                "title": "a-few-solutions",
                "content": "**Case 1:** If *any* value of the input array `A` is equal to `1`, then each adjacent value (*not* equal to `1`) can be transformed into `1` via one operation, ie. `gcd(1, x) == 1` for any `x`.  Let `ok` be the count of elements equal to `1`, if `ok` exceeds `0` then return `N - ok`, ie. the count of elements *not* equal to `1`.\\n\\n**Case 2:** Otherwise let `size` be the subarray size `i..j` inclusive for which `gcd(A[i..j]) == 1`, then the minimum operations to transform a single element of the subarray to the value `1` via the gcd function `f` is `size - 1`, ie. we can think of the gcd function `f` as an \"edge\" between each adjacent pair of indices (and each \"edge\" costs one operation).  After accounting for the minimum operations to transform a single element to the value `1`, then we need an additional `N - 1` operations to transform all remaining values *not* equal to `1` to the value `1`, ie. apply **Case 1** given `ok == 1`.\\n\\n* Note: if the `gcd` of all values of the input array `A` exceeds `1`, then we return `-1`, ie. we *cannot* transform *any* element to the value `1`\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun minOperations(A: IntArray, INF: Int = (1e9 + 7).toInt()): Int {\\n        var N = A.size\\n        var ok = A.filter{ it == 1 }.size\\n        if (0 < ok)\\n            return N - ok\\n        var (best, size) = Pair(INF, INF)\\n        fun f(a: Int, b: Int): Int { return if (b == 0) a else f(b, a % b) }\\n        for (i in 0 until N) {\\n            var gcd = A[i]\\n            for (j in i + 1 until N) {\\n                gcd = f(gcd, A[j])\\n                if (gcd == 1) {\\n                    size = j - i + 1\\n                    best = Math.min(best, size - 1)\\n                    break\\n                }\\n            }\\n        }\\n        return if (best != INF) best + N - 1 else -1\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet minOperations = (A, N = A.length) => {\\n    let ok = A.filter(x => x == 1).length;\\n    if (ok)\\n        return N - ok;\\n    let [best, size] = [Infinity, Infinity];\\n    let f = (a, b) => !b ? a : f(b, a % b);\\n    for (let i = 0; i < N; ++i) {\\n        let gcd = A[i];\\n        for (let j = i + 1; j < N; ++j) {\\n            gcd = f(gcd, A[j]);\\n            if (gcd == 1) {\\n                size = j - i + 1;\\n                best = Math.min(best, size - 1);\\n                break;\\n            }\\n        }\\n    }\\n    return best != Infinity ? best + N - 1 : -1;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def minOperations(self, A: List[int]) -> int:\\n        N = len(A)\\n        ok = len([x for x in A if x == 1])\\n        if ok:\\n            return N - ok\\n        best, size = float(\\'inf\\'), float(\\'inf\\')\\n        f = lambda a, b: a if not b else f(b, a % b)\\n        for i in range(N):\\n            gcd = A[i]\\n            for j in range(i + 1, N):\\n                gcd = f(gcd, A[j])\\n                if gcd == 1:\\n                    size = j - i + 1\\n                    best = min(best, size - 1)\\n                    break\\n        return best + N - 1 if best != float(\\'inf\\') else -1\\n```\\n\\n*Rust*\\n```\\nuse std::cmp::min;\\nimpl Solution {\\n    pub fn min_operations(A: Vec<i32>) -> i32 {\\n        let INF = 1e9 as usize + 1;\\n        let N = A.len();\\n        let ok = A.iter().filter(|&x| *x == 1).collect::<Vec<&i32>>().len();\\n        if 0 < ok {\\n            return (N - ok) as i32;\\n        }\\n        let (mut best, mut size) = (INF, INF);\\n        fn f(a: i32, b: i32) -> i32 { if b == 0 { a } else { f(b, a % b) } }\\n        for i in 0..N {\\n            let mut gcd = A[i];\\n            for j in i + 1..N {\\n                gcd = f(gcd, A[j]);\\n                if gcd == 1 {\\n                    size = j - i + 1;\\n                    best = min(best, size - 1);\\n                    break;\\n                }\\n            }\\n        }\\n        if best != INF { (best + N - 1) as i32 } else { -1 }\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int, int)>;\\n    int minOperations(VI& A, int INF = 1e9 + 7) {\\n        auto N = A.size();\\n        auto ok = count_if(A.begin(), A.end(), [](auto x) { return x == 1; });\\n        if (ok)\\n            return N - ok;\\n        auto [best, size] = make_pair(INF, INF);\\n        fun f = [&](auto a, auto b) { return !b ? a : f(b, a % b); };\\n        for (auto i{ 0 }; i < N; ++i) {\\n            auto gcd = A[i];\\n            for (auto j{ i + 1 }; j < N; ++j) {\\n                gcd = f(gcd, A[j]);\\n                if (gcd == 1) {\\n                    size = j - i + 1;\\n                    best = min(best, size - 1);\\n                    break;\\n                }\\n            }\\n        }\\n        return best != INF ? best + N - 1 : -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun minOperations(A: IntArray, INF: Int = (1e9 + 7).toInt()): Int {\\n        var N = A.size\\n        var ok = A.filter{ it == 1 }.size\\n        if (0 < ok)\\n            return N - ok\\n        var (best, size) = Pair(INF, INF)\\n        fun f(a: Int, b: Int): Int { return if (b == 0) a else f(b, a % b) }\\n        for (i in 0 until N) {\\n            var gcd = A[i]\\n            for (j in i + 1 until N) {\\n                gcd = f(gcd, A[j])\\n                if (gcd == 1) {\\n                    size = j - i + 1\\n                    best = Math.min(best, size - 1)\\n                    break\\n                }\\n            }\\n        }\\n        return if (best != INF) best + N - 1 else -1\\n    }\\n}\\n```\n```\\nlet minOperations = (A, N = A.length) => {\\n    let ok = A.filter(x => x == 1).length;\\n    if (ok)\\n        return N - ok;\\n    let [best, size] = [Infinity, Infinity];\\n    let f = (a, b) => !b ? a : f(b, a % b);\\n    for (let i = 0; i < N; ++i) {\\n        let gcd = A[i];\\n        for (let j = i + 1; j < N; ++j) {\\n            gcd = f(gcd, A[j]);\\n            if (gcd == 1) {\\n                size = j - i + 1;\\n                best = Math.min(best, size - 1);\\n                break;\\n            }\\n        }\\n    }\\n    return best != Infinity ? best + N - 1 : -1;\\n};\\n```\n```\\nclass Solution:\\n    def minOperations(self, A: List[int]) -> int:\\n        N = len(A)\\n        ok = len([x for x in A if x == 1])\\n        if ok:\\n            return N - ok\\n        best, size = float(\\'inf\\'), float(\\'inf\\')\\n        f = lambda a, b: a if not b else f(b, a % b)\\n        for i in range(N):\\n            gcd = A[i]\\n            for j in range(i + 1, N):\\n                gcd = f(gcd, A[j])\\n                if gcd == 1:\\n                    size = j - i + 1\\n                    best = min(best, size - 1)\\n                    break\\n        return best + N - 1 if best != float(\\'inf\\') else -1\\n```\n```\\nuse std::cmp::min;\\nimpl Solution {\\n    pub fn min_operations(A: Vec<i32>) -> i32 {\\n        let INF = 1e9 as usize + 1;\\n        let N = A.len();\\n        let ok = A.iter().filter(|&x| *x == 1).collect::<Vec<&i32>>().len();\\n        if 0 < ok {\\n            return (N - ok) as i32;\\n        }\\n        let (mut best, mut size) = (INF, INF);\\n        fn f(a: i32, b: i32) -> i32 { if b == 0 { a } else { f(b, a % b) } }\\n        for i in 0..N {\\n            let mut gcd = A[i];\\n            for j in i + 1..N {\\n                gcd = f(gcd, A[j]);\\n                if gcd == 1 {\\n                    size = j - i + 1;\\n                    best = min(best, size - 1);\\n                    break;\\n                }\\n            }\\n        }\\n        if best != INF { (best + N - 1) as i32 } else { -1 }\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int, int)>;\\n    int minOperations(VI& A, int INF = 1e9 + 7) {\\n        auto N = A.size();\\n        auto ok = count_if(A.begin(), A.end(), [](auto x) { return x == 1; });\\n        if (ok)\\n            return N - ok;\\n        auto [best, size] = make_pair(INF, INF);\\n        fun f = [&](auto a, auto b) { return !b ? a : f(b, a % b); };\\n        for (auto i{ 0 }; i < N; ++i) {\\n            auto gcd = A[i];\\n            for (auto j{ i + 1 }; j < N; ++j) {\\n                gcd = f(gcd, A[j]);\\n                if (gcd == 1) {\\n                    size = j - i + 1;\\n                    best = min(best, size - 1);\\n                    break;\\n                }\\n            }\\n        }\\n        return best != INF ? best + N - 1 : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3457695,
                "title": "brute-force-simple-c-smallest-subarray-with-gcd-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe just have to find the smallest subarray with GCD 1. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will make one 1 with that subarray with cost of length - 1.\\nThe rest n-1 elements will be changed to 1 with n-1 operations.   \\n\\n# Complexity\\n- Time complexity:O(N^3)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int minOperations(vector<int>& nums) {\\n        int gcd = nums[0];\\n        int one = 0;\\n        for(auto x: nums) \\n        {\\n            gcd = __gcd(gcd,x);\\n            one += (x==1);\\n        }\\n        if(gcd>1) return -1;\\n        int n = nums.size();\\n        if(one) return n-one;\\n        for(int len = 1;len<=n;len++)\\n        {\\n            for(int i=0;i<=n-len;i++)\\n            {\\n                int curGCD = nums[i];\\n                for(int j=0;j<len;j++)  // for current window of [i, i+len]\\n                    curGCD = __gcd(curGCD,nums[i+j]);\\n                \\n                if(curGCD == 1)\\n                    return n-1 + len-1;\\n            }\\n        }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minOperations(vector<int>& nums) {\\n        int gcd = nums[0];\\n        int one = 0;\\n        for(auto x: nums) \\n        {\\n            gcd = __gcd(gcd,x);\\n            one += (x==1);\\n        }\\n        if(gcd>1) return -1;\\n        int n = nums.size();\\n        if(one) return n-one;\\n        for(int len = 1;len<=n;len++)\\n        {\\n            for(int i=0;i<=n-len;i++)\\n            {\\n                int curGCD = nums[i];\\n                for(int j=0;j<len;j++)  // for current window of [i, i+len]\\n                    curGCD = __gcd(curGCD,nums[i+j]);\\n                \\n                if(curGCD == 1)\\n                    return n-1 + len-1;\\n            }\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3455938,
                "title": "explained-with-comments-easy-to-understand-soln",
                "content": "```\\n    //Case 1: if nums has 1 --> number of operations = no. of non 1s (1 operations for each)\\n    //Case 2: if gcd of entire nums != 1 --> not possible --> -1\\n    //Case 3: we want to make atleast 1 1 fastest(with least no of operations)\\n    // eg. [2,6,3,4] -- gcd(2,3,6) == 1 & gcd(3,4)==1 but 3,4 is faster\\n    // so basically we need to find smallest subarray with gcd 1\\n    \\n    //Constraints are small(50) we check for each subarray \\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int ones = count(nums.begin(),nums.end(),1);\\n        if(ones>0)\\n            return n - ones; //case 1\\n        //case3\\n        int minLength = INT_MAX;\\n        for(int i=0;i<n;i++)\\n        {\\n            int hcf = nums[i];\\n            for(int j=i;j<n;j++)\\n            {\\n                hcf = __gcd(hcf,nums[j]);\\n                if(hcf==1)\\n                {\\n                    minLength = min(minLength, j-i+1);\\n                    break; //found a subarray starting from i which has gcd = 1; we dont need to keep adding more elements --> gcd will be 1 but length increases and we need smallest subarray\\n                }    \\n            }\\n        }\\n        //case2\\n        if(minLength == INT_MAX) return -1;\\n        return (minLength-1) + n-1;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\n    //Case 1: if nums has 1 --> number of operations = no. of non 1s (1 operations for each)\\n    //Case 2: if gcd of entire nums != 1 --> not possible --> -1\\n    //Case 3: we want to make atleast 1 1 fastest(with least no of operations)\\n    // eg. [2,6,3,4] -- gcd(2,3,6) == 1 & gcd(3,4)==1 but 3,4 is faster\\n    // so basically we need to find smallest subarray with gcd 1\\n    \\n    //Constraints are small(50) we check for each subarray \\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int ones = count(nums.begin(),nums.end(),1);\\n        if(ones>0)\\n            return n - ones; //case 1\\n        //case3\\n        int minLength = INT_MAX;\\n        for(int i=0;i<n;i++)\\n        {\\n            int hcf = nums[i];\\n            for(int j=i;j<n;j++)\\n            {\\n                hcf = __gcd(hcf,nums[j]);\\n                if(hcf==1)\\n                {\\n                    minLength = min(minLength, j-i+1);\\n                    break; //found a subarray starting from i which has gcd = 1; we dont need to keep adding more elements --> gcd will be 1 but length increases and we need smallest subarray\\n                }    \\n            }\\n        }\\n        //case2\\n        if(minLength == INT_MAX) return -1;\\n        return (minLength-1) + n-1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3455198,
                "title": "very-short-solution",
                "content": "\\n# Code\\n```\\ndef minOperations(self, nums: List[int]) -> int:\\n    n = len(nums)\\n    if 1 in nums:\\n        return n - sum(int(x==1) for x in nums)\\n    for ret in range(n-1):\\n        for i in range(n-1-ret):\\n            nums[i] = gcd(nums[i], nums[i+1])\\n            if nums[i] == 1:\\n                return ret+n\\n    return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef minOperations(self, nums: List[int]) -> int:\\n    n = len(nums)\\n    if 1 in nums:\\n        return n - sum(int(x==1) for x in nums)\\n    for ret in range(n-1):\\n        for i in range(n-1-ret):\\n            nums[i] = gcd(nums[i], nums[i+1])\\n            if nums[i] == 1:\\n                return ret+n\\n    return -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3454051,
                "title": "c-brute-force-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n^2)$$\\n\\n- Space complexity:$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        if(count(nums.begin(), nums.end(), 1)){\\n            return nums.size()-count(nums.begin(), nums.end(), 1);\\n        }\\n        int cnt=INT_MAX;\\n        for(int i=0; i<nums.size(); i++){\\n            int val=nums[i];\\n            for(int j=i+1; j<nums.size(); j++){\\n                val=__gcd(val, nums[j]);\\n                if(val==1){\\n                    if(j+nums.size()-1-i<cnt){\\n                        cnt=j+nums.size()-1-i;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        if(cnt==INT_MAX){\\n            return -1;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        if(count(nums.begin(), nums.end(), 1)){\\n            return nums.size()-count(nums.begin(), nums.end(), 1);\\n        }\\n        int cnt=INT_MAX;\\n        for(int i=0; i<nums.size(); i++){\\n            int val=nums[i];\\n            for(int j=i+1; j<nums.size(); j++){\\n                val=__gcd(val, nums[j]);\\n                if(val==1){\\n                    if(j+nums.size()-1-i<cnt){\\n                        cnt=j+nums.size()-1-i;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        if(cnt==INT_MAX){\\n            return -1;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451672,
                "title": "brute-force",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = size(nums);\\n        int gcd = 0,one = 0;\\n        for(int&e: nums){\\n            gcd = __gcd(gcd,e);\\n            if(e == 1) one++;\\n        }\\n        if(gcd != 1) return -1;\\n        if(one) return n-one;\\n        int mn=1e9;\\n        for(int i=0; i<n; ++i){\\n            gcd = nums[i];\\n            int ct = 0;\\n            for(int j=i+1; j<n; ++j){\\n                gcd = __gcd(gcd,nums[j]);\\n                ct++;\\n                if(gcd == 1){\\n                    mn = min(mn,ct);\\n                    break;\\n                }\\n            }\\n        }\\n        return n+mn-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = size(nums);\\n        int gcd = 0,one = 0;\\n        for(int&e: nums){\\n            gcd = __gcd(gcd,e);\\n            if(e == 1) one++;\\n        }\\n        if(gcd != 1) return -1;\\n        if(one) return n-one;\\n        int mn=1e9;\\n        for(int i=0; i<n; ++i){\\n            gcd = nums[i];\\n            int ct = 0;\\n            for(int j=i+1; j<n; ++j){\\n                gcd = __gcd(gcd,nums[j]);\\n                ct++;\\n                if(gcd == 1){\\n                    mn = min(mn,ct);\\n                    break;\\n                }\\n            }\\n        }\\n        return n+mn-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449208,
                "title": "beats-90-cpp-sol",
                "content": "# Upvote if you liked the solution \\uD83E\\uDD79\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n\\n        // finding the size of the nums\\n        int n = nums.size();\\n\\n        // To create all the no of nums equal to 1, we need one number in nums to be equal to \\'1\\' \\n        // coz the gcd of 1 equal to 1\\n\\n        // if \\'1\\' is already present in the nums then count the no of \\'1\\'\\n        int oneCount = count(nums.begin(), nums.end(), 1);\\n\\n        // number of operation to make all other no equal to one will be\\n        if(oneCount > 0){\\n            return n-oneCount;\\n        }\\n\\n        int len = INT_MAX;\\n        for(int i = 0; i<n; i++){\\n            int g = nums[i];\\n            for(int j = i+1; j<n; j++){\\n                g = gcd(g, nums[j]);\\n                if(g == 1){\\n                    len = min(len, j-i);\\n                }\\n            }\\n        }\\n\\n        if(len == INT_MAX){\\n            return -1;\\n        }\\n\\n        // len : no of operations to make a no equal to 1\\n        // n-1 : no of opeartion to make remaining all other element equal to one\\n        // total  = len + n-1\\n\\n        return len + (n-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n\\n        // finding the size of the nums\\n        int n = nums.size();\\n\\n        // To create all the no of nums equal to 1, we need one number in nums to be equal to \\'1\\' \\n        // coz the gcd of 1 equal to 1\\n\\n        // if \\'1\\' is already present in the nums then count the no of \\'1\\'\\n        int oneCount = count(nums.begin(), nums.end(), 1);\\n\\n        // number of operation to make all other no equal to one will be\\n        if(oneCount > 0){\\n            return n-oneCount;\\n        }\\n\\n        int len = INT_MAX;\\n        for(int i = 0; i<n; i++){\\n            int g = nums[i];\\n            for(int j = i+1; j<n; j++){\\n                g = gcd(g, nums[j]);\\n                if(g == 1){\\n                    len = min(len, j-i);\\n                }\\n            }\\n        }\\n\\n        if(len == INT_MAX){\\n            return -1;\\n        }\\n\\n        // len : no of operations to make a no equal to 1\\n        // n-1 : no of opeartion to make remaining all other element equal to one\\n        // total  = len + n-1\\n\\n        return len + (n-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446583,
                "title": "short-concise-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size(), nonOnes = 0, mn = 1e9;\\n        for(int i : nums) nonOnes += i != 1;\\n        \\n        for(int i=0; i<n; i++) {\\n            int g = nums[i];\\n            for(int j=i+1; j<n; j++) {\\n                g = __gcd(g, nums[j]);\\n                if(g == 1) mn = min(mn, j - i);\\n            }\\n        }\\n        return mn == 1e9 ? -1 : nonOnes + mn - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size(), nonOnes = 0, mn = 1e9;\\n        for(int i : nums) nonOnes += i != 1;\\n        \\n        for(int i=0; i<n; i++) {\\n            int g = nums[i];\\n            for(int j=i+1; j<n; j++) {\\n                g = __gcd(g, nums[j]);\\n                if(g == 1) mn = min(mn, j - i);\\n            }\\n        }\\n        return mn == 1e9 ? -1 : nonOnes + mn - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446195,
                "title": "easy-understandable-code-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int x = nums[0];\\n        for(int i = 1 ; i < n ; i++){\\n            x = __gcd(x,nums[i]);\\n        }\\n        int one = 0;\\n        for(auto i : nums){\\n            if(i == 1)  one++;\\n        }\\n        if(one > 0) return n-one;\\n        if(x != 1)  return -1;\\n        int cnt = 0;\\n        while(1){\\n            vector<int> v;\\n            for(int i = 0 ; i < n-1; i++){\\n                int t = __gcd(nums[i],nums[i+1]);\\n                if(t == 1){\\n                    return n + cnt;\\n                }\\n                v.push_back(t);\\n            }\\n            cnt++;\\n            nums.resize(nums.size()-1);\\n            nums = v;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```\\n\\n\\nPlease Upvote !!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int x = nums[0];\\n        for(int i = 1 ; i < n ; i++){\\n            x = __gcd(x,nums[i]);\\n        }\\n        int one = 0;\\n        for(auto i : nums){\\n            if(i == 1)  one++;\\n        }\\n        if(one > 0) return n-one;\\n        if(x != 1)  return -1;\\n        int cnt = 0;\\n        while(1){\\n            vector<int> v;\\n            for(int i = 0 ; i < n-1; i++){\\n                int t = __gcd(nums[i],nums[i+1]);\\n                if(t == 1){\\n                    return n + cnt;\\n                }\\n                v.push_back(t);\\n            }\\n            cnt++;\\n            nums.resize(nums.size()-1);\\n            nums = v;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446170,
                "title": "o-n-n-log-max-element-nums-i-solution",
                "content": "- If 1 exists in the array, it will be optimal to propagate it to non zero indexes\\n- Else create a one in minimum number of operations, in order to do that we will will the smallest subarray with gcd = 1, then propagate it.\\n- If no subarray exist with gcd = 1, return -1.\\n- The solution can be optimised further using segment tree.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Time complexity: O(N * N * log(max_element(nums[i]))) -->\\n    O(N * N * log(max_element(nums[i]))) \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        map<int,int>m;\\n        int n = nums.size();\\n        for(int i = 0; i < n; i++) m[nums[i]]++;\\n        \\n        // if 1 is present in the array than we will propagate it.\\n        if(m.count(1)) return n - m[1];\\n        int ans = n + 1;\\n        \\n        // finding the smallest subarray with gcd 1.\\n        for(int i = 0; i < n; i++) {\\n            int curr = nums[i];\\n            for(int j = i + 1; j < n; j++) {\\n                curr = __gcd(curr, nums[j]);\\n                if(curr == 1) {\\n                    ans = min(ans, j - i + 1);\\n                    break;\\n                }\\n            }\\n        }\\n    \\n        // if not found return -1.\\n        if(ans == n + 1) return -1;\\n        \\n        // in order to create first 1, we will need ans - 1 operations than n - 1 operations to propagate to complete array.\\n        return ans - 1 + n - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        map<int,int>m;\\n        int n = nums.size();\\n        for(int i = 0; i < n; i++) m[nums[i]]++;\\n        \\n        // if 1 is present in the array than we will propagate it.\\n        if(m.count(1)) return n - m[1];\\n        int ans = n + 1;\\n        \\n        // finding the smallest subarray with gcd 1.\\n        for(int i = 0; i < n; i++) {\\n            int curr = nums[i];\\n            for(int j = i + 1; j < n; j++) {\\n                curr = __gcd(curr, nums[j]);\\n                if(curr == 1) {\\n                    ans = min(ans, j - i + 1);\\n                    break;\\n                }\\n            }\\n        }\\n    \\n        // if not found return -1.\\n        if(ans == n + 1) return -1;\\n        \\n        // in order to create first 1, we will need ans - 1 operations than n - 1 operations to propagate to complete array.\\n        return ans - 1 + n - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446029,
                "title": "easy-c-solution-smallest-subarray-with-gcd-1-clean-code",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. If vector contains integer 1 then answer is number of elements not equal to 1\\n2. If the gcd of whole array is not 1 then the answer doesn\\'t exist, return -1\\n3. Find the smallest subarray whose gcd is 1. \\n    - This (length of this subarray - 1) will be the operations required to convert an interger into 1\\n    - Answer would be **d + n - 2** (where d is length of subarray and n is size of vector) \\n\\n# Time Complexity\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n  O(`N * N * log2(M)`) where N is size of vector and M is the max element in the vector\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    int minOperations(vector<int> &v)\\n    {\\n        int n = v.size();\\n        bool f = 0;\\n        int gcd = v[0];\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (v[i] == 1) // If vector contains 1\\n            {\\n                int ans = 0;\\n                for (int i = 0; i < n; i++)\\n                {\\n                    if (v[i] != 1) \\n                        ans++;\\n                }// return number of elements not equal to 1\\n                return ans;\\n            }\\n            if (i < n - 1)\\n            {\\n                gcd = __gcd(gcd, v[i + 1]);\\n            }\\n        }\\n        if (gcd != 1) // If GCD of whole vector != 1 then return -1 \\n            return -1;\\n        \\n        int cnt=0;\\n        int ans=1e9;\\n        for (int i = 0; i < n; i++)\\n        {\\n            gcd = v[i];\\n            for (int j = i; j < n - 1; j++)\\n            {\\n                gcd = __gcd(gcd, v[j + 1]);\\n                if(gcd==1)\\n                    ans = min(ans,j-i+n);\\n                // Find minimum value of (d+n-2)\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int minOperations(vector<int> &v)\\n    {\\n        int n = v.size();\\n        bool f = 0;\\n        int gcd = v[0];\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (v[i] == 1) // If vector contains 1\\n            {\\n                int ans = 0;\\n                for (int i = 0; i < n; i++)\\n                {\\n                    if (v[i] != 1) \\n                        ans++;\\n                }// return number of elements not equal to 1\\n                return ans;\\n            }\\n            if (i < n - 1)\\n            {\\n                gcd = __gcd(gcd, v[i + 1]);\\n            }\\n        }\\n        if (gcd != 1) // If GCD of whole vector != 1 then return -1 \\n            return -1;\\n        \\n        int cnt=0;\\n        int ans=1e9;\\n        for (int i = 0; i < n; i++)\\n        {\\n            gcd = v[i];\\n            for (int j = i; j < n - 1; j++)\\n            {\\n                gcd = __gcd(gcd, v[j + 1]);\\n                if(gcd==1)\\n                    ans = min(ans,j-i+n);\\n                // Find minimum value of (d+n-2)\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445955,
                "title": "simple-observation-explained",
                "content": "# Intuition:If there is even a sigle one present we can make all the elemnts one by taking gcd of one with its adjacent elements so return size-cnt of one otherwise try to move in a subarray fashion as soon as you get your gcd equal to one it would mean that now you can make one eleent as one and keep doing this till the loop ends and return the minimum answer,so try to find shortest subarray whose gcd is equal to one.\\n\\n# Complexity\\n- Time complexity:0(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n=nums.size();\\n        bool f=false;\\n        int cnt=0;\\n        int cnt1=0;\\n        int ans=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==1)cnt1++;\\n        }\\n        if(cnt1)return n-cnt1;\\n        for(int i=0;i<n;i++){\\n            int g=nums[i];\\n            for(int j=i+1;j<n;j++){\\n                g=__gcd(g,nums[j]);\\n                if(g==1){\\n                    ans=min(ans,j-i+(n-1));\\n                }\\n            }\\n        }\\n        if(ans==INT_MAX)return -1;\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n=nums.size();\\n        bool f=false;\\n        int cnt=0;\\n        int cnt1=0;\\n        int ans=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==1)cnt1++;\\n        }\\n        if(cnt1)return n-cnt1;\\n        for(int i=0;i<n;i++){\\n            int g=nums[i];\\n            for(int j=i+1;j<n;j++){\\n                g=__gcd(g,nums[j]);\\n                if(g==1){\\n                    ans=min(ans,j-i+(n-1));\\n                }\\n            }\\n        }\\n        if(ans==INT_MAX)return -1;\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445819,
                "title": "c-soutions-explained-line-by-line-easy-to-understand-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGiven an array of integers, we need to find the minimum number of operations required to make all the elements of the array co-prime (i.e., having gcd equal to 1). An operation involves selecting any two elements of the array and replacing one of them with their gcd.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe first check if the array already contains 1. If yes, then we need not perform any operations since 1 is already co-prime with all the other elements. Otherwise, we loop through the array and perform gcd operations between each pair of elements starting from the current element and moving forward. We keep track of the minimum number of operations required to make the elements co-prime.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this algorithm is O(n^2 * log(max(nums))) since we perform gcd operations between each pair of elements in the array, and the time complexity of gcd operation is log(max(nums)).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this algorithm is O(1) since we use only a few variables to keep track of the minimum number of operations and the count of 1\\'s in the array.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        \\n        int numOnes = 0, minOps = INT_MAX;\\n        \\n        // Count the number of ones in the array\\n        for(int& num : nums){\\n            if(num == 1)\\n                numOnes++;\\n        }\\n        \\n        // If there are ones in the array, return the number of non-one elements\\n        if(numOnes != 0){\\n            return nums.size() - numOnes;\\n        }\\n        \\n        // Check all subarrays for gcd 1 and find the smallest subarray\\n        for(int i = 0; i < nums.size(); i++){\\n            int gcdVal = nums[i];\\n            for(int j = i + 1; j < nums.size(); j++){\\n                gcdVal = gcd(gcdVal, nums[j]);\\n                if(gcdVal == 1){\\n                    minOps = min(minOps, j - i);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        // If no subarray with gcd 1 is found, return -1\\n        return minOps == INT_MAX ? -1 : nums.size() + minOps - 1;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        \\n        int numOnes = 0, minOps = INT_MAX;\\n        \\n        // Count the number of ones in the array\\n        for(int& num : nums){\\n            if(num == 1)\\n                numOnes++;\\n        }\\n        \\n        // If there are ones in the array, return the number of non-one elements\\n        if(numOnes != 0){\\n            return nums.size() - numOnes;\\n        }\\n        \\n        // Check all subarrays for gcd 1 and find the smallest subarray\\n        for(int i = 0; i < nums.size(); i++){\\n            int gcdVal = nums[i];\\n            for(int j = i + 1; j < nums.size(); j++){\\n                gcdVal = gcd(gcdVal, nums[j]);\\n                if(gcdVal == 1){\\n                    minOps = min(minOps, j - i);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        // If no subarray with gcd 1 is found, return -1\\n        return minOps == INT_MAX ? -1 : nums.size() + minOps - 1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445808,
                "title": "o-n-2-greedy-brute-force",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int gcd = nums[0];\\n        for(int i = 0; i < n; i++) gcd = __gcd(gcd, nums[i]);\\n        if(gcd > 1) return -1;\\n        \\n        int minOp = INT_MAX;\\n        for(int i = 0; i < n; i++){\\n            gcd = nums[i];\\n            for(int j = i; j < n; j++){\\n                gcd = __gcd(gcd, nums[j]);\\n                if(gcd == 1){\\n                    minOp = min(minOp, (j - i));\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        if(minOp == 0) return n - count(nums.begin(), nums.end() , 1);\\n        return minOp + n - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int gcd = nums[0];\\n        for(int i = 0; i < n; i++) gcd = __gcd(gcd, nums[i]);\\n        if(gcd > 1) return -1;\\n        \\n        int minOp = INT_MAX;\\n        for(int i = 0; i < n; i++){\\n            gcd = nums[i];\\n            for(int j = i; j < n; j++){\\n                gcd = __gcd(gcd, nums[j]);\\n                if(gcd == 1){\\n                    minOp = min(minOp, (j - i));\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        if(minOp == 0) return n - count(nums.begin(), nums.end() , 1);\\n        return minOp + n - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445706,
                "title": "minimum-steps-to-make-any-one-element-equal-to-1",
                "content": "```\\nclass Solution:\\n    def gcd(self, a, b):\\n        while b:\\n            a, b = b, a % b\\n        return a\\n    \\n    def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        if nums.count(1) > 0:\\n            return n - nums.count(1)\\n        minops = float(\\'inf\\')\\n        for i in range(n):\\n            j = i\\n            g = nums[i]\\n            while j >= 0:\\n                g = self.gcd(g, nums[j])\\n                if g == 1:\\n                    break\\n                j -= 1\\n            if g == 1:\\n                minops = min(minops, i - j)\\n            j = i\\n            g = nums[i]\\n            while j < n:\\n                g = self.gcd(g, nums[j])\\n                if g == 1:\\n                    break\\n                j += 1\\n            if g == 1:\\n                minops = min(minops, j - i)\\n        if minops == float(\\'inf\\'):\\n            return -1\\n        return n - 1 + minops\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def gcd(self, a, b):\\n        while b:\\n            a, b = b, a % b\\n        return a\\n    \\n    def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        if nums.count(1) > 0:\\n            return n - nums.count(1)\\n        minops = float(\\'inf\\')\\n        for i in range(n):\\n            j = i\\n            g = nums[i]\\n            while j >= 0:\\n                g = self.gcd(g, nums[j])\\n                if g == 1:\\n                    break\\n                j -= 1\\n            if g == 1:\\n                minops = min(minops, i - j)\\n            j = i\\n            g = nums[i]\\n            while j < n:\\n                g = self.gcd(g, nums[j])\\n                if g == 1:\\n                    break\\n                j += 1\\n            if g == 1:\\n                minops = min(minops, j - i)\\n        if minops == float(\\'inf\\'):\\n            return -1\\n        return n - 1 + minops\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445701,
                "title": "east-solution-c-understandable",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        int ope =0;\\n        for(int i=0; i<n; i++){\\n            if(nums[i]==1){\\n                ope++;\\n            }\\n            \\n        }\\n        \\n        if(ope>0){\\n            return n - ope;\\n\\n        }\\n        \\n        int ans = INT_MAX;\\n        for(int i=0; i<n; i++){\\n            int num = nums[i];\\n            for(int j = i+1; j<n; j++){\\n                num = __gcd(num,nums[j]);\\n                if(num==1){\\n                    ans = min(ans,j-i);\\n                    break;\\n                }\\n            }\\n            if(num!=1){\\n                break;\\n            }\\n            \\n        }\\n        if(ans==INT_MAX){\\n            return -1;\\n        }\\n        return n-1+ans;\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        int ope =0;\\n        for(int i=0; i<n; i++){\\n            if(nums[i]==1){\\n                ope++;\\n            }\\n            \\n        }\\n        \\n        if(ope>0){\\n            return n - ope;\\n\\n        }\\n        \\n        int ans = INT_MAX;\\n        for(int i=0; i<n; i++){\\n            int num = nums[i];\\n            for(int j = i+1; j<n; j++){\\n                num = __gcd(num,nums[j]);\\n                if(num==1){\\n                    ans = min(ans,j-i);\\n                    break;\\n                }\\n            }\\n            if(num!=1){\\n                break;\\n            }\\n            \\n        }\\n        if(ans==INT_MAX){\\n            return -1;\\n        }\\n        return n-1+ans;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971868,
                "title": "c-python-solution-with-explanation",
                "content": "1. if there has a 1 in nums, we can do len(nums) - 1 operations to make all element be 1.\\n2. if threre are multiple 1s, we can do len(nums) - number of 1 operations to make all element be 0.\\n3. if there are no 1 in nums, we should find a subarray whose gcd is 1, e.g., [3,6,2] in [3,6,2,4].\\n4. if a subarray whose gcd is 1 and its size is m, we just use m - 1 operations to generate a 1, and use len(nums) - 1 operations to make all element be 1, so total is m - 1 + len(nums) - 1.\\n\\nwe can eumerate left and right side of subarray to find a subarray whose gcd is 1.\\nand because of gcd(gcd(a, b), c) == gcd(gcd(b, c), a) == gcd(gcd(a, c), b), tc will less than O(n^2).\\n\\nhash map record number after gcd and its index, left side of subarray, add current number x to subarrays we get at last time, probably get a new gcd, but left side is the same.\\n![image](https://assets.leetcode.com/users/images/cabd14ec-7d4c-4d2a-80b8-9eab40f80e01_1693228767.3166149.png)\\n\\n\\ntc is O(n log(max(nums))), sc is O(log(max(nums)))\\n\\n\\n### python\\n```python\\ninf = int(1e9)\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        cnt1 = sum(1 == x for x in nums)\\n        size = len(nums)\\n        if cnt1: return size - cnt1\\n        min_size = inf\\n        g0 = defaultdict(lambda: -1)\\n        g1 = defaultdict(lambda: -1)\\n        for i, x in enumerate(nums):\\n            for y, j in g0.items():\\n                z = gcd(x, y)\\n                g1[z] = max(g1[z], j)\\n            if 1 in g1: min_size = min(min_size, i - g1[1] + 1)\\n            g1[x] = i\\n            g0.clear()\\n            g0, g1 = g1, g0\\n        return -1 if min_size == inf else min_size - 1 + size - 1 \\n```\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int cnt1 = accumulate(nums.begin(), nums.end(), 0, [](int cnt, int &x) -> int {return cnt + (x == 1);});\\n        int size = nums.size();\\n        if (cnt1) return size - cnt1;\\n        unordered_map<int, int> g0, g1;\\n        int min_size = INT_MAX;\\n        for (int i = 0; i < size; i+=1) {\\n            int &x = nums[i];\\n            for (auto& [y, j]: g0) {\\n                int z = gcd(x, y);\\n                g1[z] = max(g1[z], j);\\n            }\\n            if (g1.count(1)) min_size = min(min_size, i - g1[1] + 1);\\n            g1[x] = i;\\n            g0.clear();\\n            swap(g0, g1);\\n        }\\n        return min_size == INT_MAX? -1: min_size - 1 + size - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Math",
                    "Enumeration"
                ],
                "code": "```python\\ninf = int(1e9)\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        cnt1 = sum(1 == x for x in nums)\\n        size = len(nums)\\n        if cnt1: return size - cnt1\\n        min_size = inf\\n        g0 = defaultdict(lambda: -1)\\n        g1 = defaultdict(lambda: -1)\\n        for i, x in enumerate(nums):\\n            for y, j in g0.items():\\n                z = gcd(x, y)\\n                g1[z] = max(g1[z], j)\\n            if 1 in g1: min_size = min(min_size, i - g1[1] + 1)\\n            g1[x] = i\\n            g0.clear()\\n            g0, g1 = g1, g0\\n        return -1 if min_size == inf else min_size - 1 + size - 1 \\n```\n```cpp\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int cnt1 = accumulate(nums.begin(), nums.end(), 0, [](int cnt, int &x) -> int {return cnt + (x == 1);});\\n        int size = nums.size();\\n        if (cnt1) return size - cnt1;\\n        unordered_map<int, int> g0, g1;\\n        int min_size = INT_MAX;\\n        for (int i = 0; i < size; i+=1) {\\n            int &x = nums[i];\\n            for (auto& [y, j]: g0) {\\n                int z = gcd(x, y);\\n                g1[z] = max(g1[z], j);\\n            }\\n            if (g1.count(1)) min_size = min(min_size, i - g1[1] + 1);\\n            g1[x] = i;\\n            g0.clear();\\n            swap(g0, g1);\\n        }\\n        return min_size == INT_MAX? -1: min_size - 1 + size - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960167,
                "title": "c-easy-o-n-2",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& a) {\\n        map<int,int> p,q;\\n        int n=a.size();\\n        for(auto i : a)\\n        if(i==1)\\n        p[i]++;\\n\\n        q=p;\\n        int ans=INT_MAX;\\n\\n        for(int i=0;i<n;i++)\\n         {\\n          int l=a[i];\\n          for(int j=i;j<n;j++)\\n          {\\n          l=__gcd(l,a[j]);\\n          if(a[j]==1)\\n          p[a[j]]--;\\n           if(l==1)\\n           {\\n               ans=min(ans,(j-i)+(n-1)-p[1]);\\n               p=q;\\n               break;\\n           }\\n          }\\n        }\\n         return ans==INT_MAX ? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& a) {\\n        map<int,int> p,q;\\n        int n=a.size();\\n        for(auto i : a)\\n        if(i==1)\\n        p[i]++;\\n\\n        q=p;\\n        int ans=INT_MAX;\\n\\n        for(int i=0;i<n;i++)\\n         {\\n          int l=a[i];\\n          for(int j=i;j<n;j++)\\n          {\\n          l=__gcd(l,a[j]);\\n          if(a[j]==1)\\n          p[a[j]]--;\\n           if(l==1)\\n           {\\n               ans=min(ans,(j-i)+(n-1)-p[1]);\\n               p=q;\\n               break;\\n           }\\n          }\\n        }\\n         return ans==INT_MAX ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958758,
                "title": "golang-o-n-2-solution-w-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc gcd(a, b int) int {\\n    for b > 0 {\\n        a, b = b, a%b\\n    }\\n\\n    return a\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n\\n    return b\\n}\\n\\nfunc minOperations(nums []int) int {\\n\\n    n := len(nums)\\n    ones := 0\\n\\n    for _, num := range nums {\\n        if num == 1{\\n            ones++\\n        }\\n    }\\n\\n\\n    // if there is 1s, there are gcds garanteed to be 1\\n    // so just flip any other non 1s to 1s\\n    if ones > 0 {\\n        return n - ones\\n    }\\n\\n    res := math.MaxInt64\\n\\n    for i:=0; i<n; i++ {\\n        g := nums[i]\\n        for j:=i+1; j<n; j++ {\\n            g = gcd(g, nums[j])\\n            if g == 1 {\\n                // j - i: how many flips to get first 1\\n                // n - 1: same case with there are 1s in the first place\\n                res = min(res, j - i + n - 1)\\n                break\\n            }\\n        }\\n    }\\n\\n    if res == math.MaxInt64 {\\n        return -1\\n    }\\n\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc gcd(a, b int) int {\\n    for b > 0 {\\n        a, b = b, a%b\\n    }\\n\\n    return a\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n\\n    return b\\n}\\n\\nfunc minOperations(nums []int) int {\\n\\n    n := len(nums)\\n    ones := 0\\n\\n    for _, num := range nums {\\n        if num == 1{\\n            ones++\\n        }\\n    }\\n\\n\\n    // if there is 1s, there are gcds garanteed to be 1\\n    // so just flip any other non 1s to 1s\\n    if ones > 0 {\\n        return n - ones\\n    }\\n\\n    res := math.MaxInt64\\n\\n    for i:=0; i<n; i++ {\\n        g := nums[i]\\n        for j:=i+1; j<n; j++ {\\n            g = gcd(g, nums[j])\\n            if g == 1 {\\n                // j - i: how many flips to get first 1\\n                // n - 1: same case with there are 1s in the first place\\n                res = min(res, j - i + n - 1)\\n                break\\n            }\\n        }\\n    }\\n\\n    if res == math.MaxInt64 {\\n        return -1\\n    }\\n\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3859119,
                "title": "easy-c-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n*n)\\n\\n- Space complexity:\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int c_one = 0;\\n        for(int i=0 ;i<n ;i++){\\n            if(nums[i] == 1)\\n                c_one++;\\n        }\\n        if(c_one)\\n        return n-c_one;\\n\\n        int ans = INT_MAX;\\n\\n        for(int i=0 ;i<n ;i++){\\n            int gdc = nums[i];\\n\\n            for(int j=i+1 ;j<n ;j++){\\n                gdc = __gcd(gdc, nums[j]);\\n                if(gdc == 1)\\n                ans = min(ans, n-1 + j-i);\\n            }\\n        }\\n        if(ans==INT_MAX)\\n        return -1;\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int c_one = 0;\\n        for(int i=0 ;i<n ;i++){\\n            if(nums[i] == 1)\\n                c_one++;\\n        }\\n        if(c_one)\\n        return n-c_one;\\n\\n        int ans = INT_MAX;\\n\\n        for(int i=0 ;i<n ;i++){\\n            int gdc = nums[i];\\n\\n            for(int j=i+1 ;j<n ;j++){\\n                gdc = __gcd(gdc, nums[j]);\\n                if(gdc == 1)\\n                ans = min(ans, n-1 + j-i);\\n            }\\n        }\\n        if(ans==INT_MAX)\\n        return -1;\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3859117,
                "title": "easy-c-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n*n)\\n\\n- Space complexity:\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int c_one = 0;\\n        for(int i=0 ;i<n ;i++){\\n            if(nums[i] == 1)\\n                c_one++;\\n        }\\n        if(c_one)\\n        return n-c_one;\\n\\n        int ans = INT_MAX;\\n\\n        for(int i=0 ;i<n ;i++){\\n            int gdc = nums[i];\\n\\n            for(int j=i+1 ;j<n ;j++){\\n                gdc = __gcd(gdc, nums[j]);\\n                if(gdc == 1)\\n                ans = min(ans, n-1 + j-i);\\n            }\\n        }\\n        if(ans==INT_MAX)\\n        return -1;\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int c_one = 0;\\n        for(int i=0 ;i<n ;i++){\\n            if(nums[i] == 1)\\n                c_one++;\\n        }\\n        if(c_one)\\n        return n-c_one;\\n\\n        int ans = INT_MAX;\\n\\n        for(int i=0 ;i<n ;i++){\\n            int gdc = nums[i];\\n\\n            for(int j=i+1 ;j<n ;j++){\\n                gdc = __gcd(gdc, nums[j]);\\n                if(gdc == 1)\\n                ans = min(ans, n-1 + j-i);\\n            }\\n        }\\n        if(ans==INT_MAX)\\n        return -1;\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3733125,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int GCD=0,count=0;\\n        for(int i=0;i<nums.size();i++){\\n            GCD = __gcd(nums[i],GCD);\\n            if(nums[i]==1)count++;\\n        }\\n        if(GCD!=1)return -1;\\n        if(count>0)return nums.size()-count;\\n        int sum =INT_MAX;\\n        for(int i=0;i<nums.size();i++){\\n            GCD = nums[i];\\n            for(int j=i;j<nums.size();j++){\\n                GCD = __gcd(GCD,nums[j]);\\n                if(GCD==1)sum = min(sum,j-i);\\n            }\\n        }\\n        return  nums.size()-1+sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int GCD=0,count=0;\\n        for(int i=0;i<nums.size();i++){\\n            GCD = __gcd(nums[i],GCD);\\n            if(nums[i]==1)count++;\\n        }\\n        if(GCD!=1)return -1;\\n        if(count>0)return nums.size()-count;\\n        int sum =INT_MAX;\\n        for(int i=0;i<nums.size();i++){\\n            GCD = nums[i];\\n            for(int j=i;j<nums.size();j++){\\n                GCD = __gcd(GCD,nums[j]);\\n                if(GCD==1)sum = min(sum,j-i);\\n            }\\n        }\\n        return  nums.size()-1+sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586189,
                "title": "c-efficient-solution-subarray-upvote-if-like-it",
                "content": "# Intuition and # Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIst part, the code counts the number of occurrences of the number 1 in the nums vector. \\nIf there is at least one occurrence of 1 (one > 0), it means that the number of operations required to make all elements equal would be n - one, where n is the size of the vector and one is the count of 1s. \\n\\nThis is because you can change all the non-1 elements to 1 in n - one operations\\n\\n2nd part, the code iterates through all possible subarrays of the nums vector.\\nFor each subarray, it calculates the greatest common divisor (currGcd) of all the elements in that subarray using the gcd function.\\n\\nIf the currGcd is equal to 1, it means all elements in that subarray are ***coprime***. \\n\\nThe code then updates currLen to the minimum length required to make all elements equal, which is the minimum value between the current currLen and **(j - i) + n - 1**, where j is the end index of the subarray and i is the start index.\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(n*n-1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int gcd(int a ,int b){\\n        if(a%b ==0)\\n            return b;\\n        else\\n            return gcd(b,a%b);\\n    }\\n    \\n\\n    int minOperations(vector<int>& nums) {\\n        int n =nums.size();\\n        int one =0;\\n        for(int i=0 ;i<n;i++){\\n            if(nums[i] == 1)\\n                one++;\\n        }\\n        if(one>0)\\n            return n-one;\\n\\n        int currLen =INT_MAX;\\n        for(int i=0 ;i<n;i++){\\n            int currGcd = 0;\\n            for(int j=i;j<n;j++){\\n                currGcd = gcd(currGcd ,nums[j]);\\n                if(currGcd == 1){\\n                    currLen = min(currLen,(j-i)+n-1);\\n                }\\n            }\\n        }\\n        currLen = currLen == INT_MAX ? -1 : currLen;\\n        return currLen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int gcd(int a ,int b){\\n        if(a%b ==0)\\n            return b;\\n        else\\n            return gcd(b,a%b);\\n    }\\n    \\n\\n    int minOperations(vector<int>& nums) {\\n        int n =nums.size();\\n        int one =0;\\n        for(int i=0 ;i<n;i++){\\n            if(nums[i] == 1)\\n                one++;\\n        }\\n        if(one>0)\\n            return n-one;\\n\\n        int currLen =INT_MAX;\\n        for(int i=0 ;i<n;i++){\\n            int currGcd = 0;\\n            for(int j=i;j<n;j++){\\n                currGcd = gcd(currGcd ,nums[j]);\\n                if(currGcd == 1){\\n                    currLen = min(currLen,(j-i)+n-1);\\n                }\\n            }\\n        }\\n        currLen = currLen == INT_MAX ? -1 : currLen;\\n        return currLen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3536078,
                "title": "java-c-python-nice-solution-well-explained",
                "content": "# TL;DR\\n```java []\\nclass Solution {\\n    private static int gcd(int a, int b) {\\n        return b == 0 ? a : gcd(b, a % b);\\n    }\\n\\n    public int minOperations(int[] nums) {\\n        int ones = 0;\\n        for (int n: nums) {\\n            if (n == 1) {\\n                ones++;\\n            }\\n        }\\n        if (ones > 0) {\\n            return nums.length - ones;\\n        }\\n        int ops = Integer.MAX_VALUE;\\n        for (int i = 0; i < nums.length; i++) {\\n            int gcd = nums[i];\\n            for (int j = i + 1; j < nums.length; j++) {\\n                if ((gcd = gcd(gcd, nums[j])) == 1) {\\n                    ops = Math.min(ops, j - i + nums.length - 1);\\n                    break;\\n                }\\n            }\\n        }\\n        return ops == Integer.MAX_VALUE ? -1 : ops;\\n    }\\n}\\n```\\n``` cpp []\\nclass Solution {\\npublic:\\n    int minOperations(std::vector<int>& nums) {\\n        int onesCount = std::count(nums.begin(), nums.end(), 1);\\n        if (onesCount > 0) {\\n            return nums.size() - onesCount;\\n        }\\n\\n        int ops = INT_MAX;\\n        for (size_t i = 0; i < nums.size(); ++i) {\\n            int currentGCD = nums[i];\\n            for (size_t j = i + 1; j < nums.size(); ++j) {\\n                currentGCD = std::gcd(currentGCD, nums[j]);\\n                if (currentGCD == 1) {\\n                    ops = std::min(ops, static_cast<int>(j - i + nums.size() - 1));\\n                    break;\\n                }\\n            }\\n        }\\n        return (ops == INT_MAX) ? -1 : ops;\\n    }\\n};\\n```\\n``` python []\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        onesCount = nums.count(1)\\n        if onesCount > 0:\\n            return len(nums) - onesCount\\n\\n        ops = float(\\'inf\\')\\n        for i in range(len(nums)):\\n            currentGCD = nums[i]\\n            for j in range(i + 1, len(nums)):\\n                currentGCD = gcd(currentGCD, nums[j])\\n                if currentGCD == 1:\\n                    ops = min(ops, j - i + len(nums) - 1)\\n                    break\\n        return -1 if ops == float(\\'inf\\') else ops\\n```\\n\\n---\\n#### \\u26A0\\uFE0F Please upvote if you like this solution. \\uD83D\\uDE43\\n---\\n\\n\\n# Intuition\\n\\nAn important property of `gcd` is that it\\'s associative. This means that `gcd(a, b, c) = gcd(gcd(a, b), c) = gcd(a, gcd(b, c))`. This property allows us to calculate the gcd of more than two numbers by successively applying the gcd operation on pairs of numbers.\\n\\n# Approach\\n\\nThe key idea behind this algorithm is to find a pair of numbers (or a number and a combination of numbers) in the array whose greatest common divisor (gcd) is 1. Once we find such a combination, we can use the operation defined in the problem to replace one number in the combination with 1, and then use this 1 to turn all other numbers in the array into 1s. This idea leverages the property of the gcd function: `gcd(a, b, c) = gcd(gcd(a, b), c)`.\\n\\nTo find such a pair, we iterate over the array, and for each element at index `i`, we calculate the gcd with the rest of the elements in the array (i.e., the elements at indices `j` where `i < j < nums.length`). We start with `gcd = nums[i]` and then iteratively compute `gcd = gcd(gcd, nums[j])` for increasing values of `j`.\\n\\nIf at any point, the gcd becomes 1, it means that number `nums[j]` and some number or combination of the previous elements `nums[i..j-1]` have a gcd of 1. At this point, the minimum number of operations required to turn all elements in the array into 1s is `j - i + nums.length - 1`. Here, `j - i` is the number of operations needed to transform the subarray `nums[i..j]` into 1s (by replacing `nums[j]` with the gcd of `nums[i..j]`, which is 1), and `nums.length - 1` is the number of operations needed to transform the rest of the array into 1s.\\n\\nAfter this, we continue the iteration to check if we can find another pair or combination that allows us to turn all elements into 1s with fewer operations. \\n\\nThe algorithm continues this process for all elements in the array and keeps track of the minimum number of operations found. If no pair or combination with a gcd of 1 is found after examining the entire array, the algorithm returns -1 to indicate that it\\'s impossible to make all elements of the array equal to 1.\\n\\n# Complexity Analysis\\n\\n- The time complexity is $$O(n^2)$$ because for each element, we potentially calculate the gcd with the rest of the elements in the array.\\n\\n- The space complexity is $$O(1)$$ because we only use a constant amount of space to store the intermediate results.\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```java []\\nclass Solution {\\n    private static int gcd(int a, int b) {\\n        return b == 0 ? a : gcd(b, a % b);\\n    }\\n\\n    public int minOperations(int[] nums) {\\n        int ones = 0;\\n        for (int n: nums) {\\n            if (n == 1) {\\n                ones++;\\n            }\\n        }\\n        if (ones > 0) {\\n            return nums.length - ones;\\n        }\\n        int ops = Integer.MAX_VALUE;\\n        for (int i = 0; i < nums.length; i++) {\\n            int gcd = nums[i];\\n            for (int j = i + 1; j < nums.length; j++) {\\n                if ((gcd = gcd(gcd, nums[j])) == 1) {\\n                    ops = Math.min(ops, j - i + nums.length - 1);\\n                    break;\\n                }\\n            }\\n        }\\n        return ops == Integer.MAX_VALUE ? -1 : ops;\\n    }\\n}\\n```\n``` cpp []\\nclass Solution {\\npublic:\\n    int minOperations(std::vector<int>& nums) {\\n        int onesCount = std::count(nums.begin(), nums.end(), 1);\\n        if (onesCount > 0) {\\n            return nums.size() - onesCount;\\n        }\\n\\n        int ops = INT_MAX;\\n        for (size_t i = 0; i < nums.size(); ++i) {\\n            int currentGCD = nums[i];\\n            for (size_t j = i + 1; j < nums.size(); ++j) {\\n                currentGCD = std::gcd(currentGCD, nums[j]);\\n                if (currentGCD == 1) {\\n                    ops = std::min(ops, static_cast<int>(j - i + nums.size() - 1));\\n                    break;\\n                }\\n            }\\n        }\\n        return (ops == INT_MAX) ? -1 : ops;\\n    }\\n};\\n```\n``` python []\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        onesCount = nums.count(1)\\n        if onesCount > 0:\\n            return len(nums) - onesCount\\n\\n        ops = float(\\'inf\\')\\n        for i in range(len(nums)):\\n            currentGCD = nums[i]\\n            for j in range(i + 1, len(nums)):\\n                currentGCD = gcd(currentGCD, nums[j])\\n                if currentGCD == 1:\\n                    ops = min(ops, j - i + len(nums) - 1)\\n                    break\\n        return -1 if ops == float(\\'inf\\') else ops\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3509361,
                "title": "rust-just-works-solution-runtime-100-memory-100",
                "content": "It picks every number and travels through the array(while executing gcd on every step) until the number\\'s value is equal to one or reaches the end of the array. It also skips some numbers if it\\'s possible.\\n# Code\\n```\\nimpl Solution {\\n    pub fn min_operations(nums: Vec<i32>) -> i32 {\\n        if nums.contains(&1) {\\n            return nums.iter().filter(|n| **n != 1).count() as i32;\\n        }\\n        let mut distance: i32 = -1;\\n        let mut i = 0;\\n        while i < nums.len() {\\n            let mut cur_num = nums[i];\\n            for j in i+1..nums.len() {\\n                let g = Self::gcd(nums[j], cur_num);\\n                if g == nums[j] {\\n                    i = j-1;\\n                    break;\\n                }\\n                if g == 1 {\\n                    if distance == -1 || distance > (j - i) as i32 {\\n                        distance = (j - i) as i32;\\n                        break;\\n                    }\\n                } else {\\n                    cur_num = g;\\n                }\\n            }\\n            i += 1;\\n        }\\n        \\n        if distance == -1 {\\n            -1\\n        } else {\\n            distance - 1 + nums.len() as i32\\n        }\\n    }\\n\\n    fn gcd(a: i32, b: i32) -> i32 {\\n        let (mut a, mut b) = (a, b);\\n        while b != 0 {\\n            let temp = b;\\n            b = a % b;\\n            a = temp;\\n        }\\n        a\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_operations(nums: Vec<i32>) -> i32 {\\n        if nums.contains(&1) {\\n            return nums.iter().filter(|n| **n != 1).count() as i32;\\n        }\\n        let mut distance: i32 = -1;\\n        let mut i = 0;\\n        while i < nums.len() {\\n            let mut cur_num = nums[i];\\n            for j in i+1..nums.len() {\\n                let g = Self::gcd(nums[j], cur_num);\\n                if g == nums[j] {\\n                    i = j-1;\\n                    break;\\n                }\\n                if g == 1 {\\n                    if distance == -1 || distance > (j - i) as i32 {\\n                        distance = (j - i) as i32;\\n                        break;\\n                    }\\n                } else {\\n                    cur_num = g;\\n                }\\n            }\\n            i += 1;\\n        }\\n        \\n        if distance == -1 {\\n            -1\\n        } else {\\n            distance - 1 + nums.len() as i32\\n        }\\n    }\\n\\n    fn gcd(a: i32, b: i32) -> i32 {\\n        let (mut a, mut b) = (a, b);\\n        while b != 0 {\\n            let temp = b;\\n            b = a % b;\\n            a = temp;\\n        }\\n        a\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3489907,
                "title": "c-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> tmp(n);\\n        int ele = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            tmp[i] = nums[i];\\n            if(nums[i]!=1)\\n            ele++;\\n        }\\n        int cnt=0;\\n        while(tmp.size()>1)\\n        {\\n            for(int i=0;i<tmp.size()-1;i++)\\n            {\\n                if(__gcd(tmp[i],tmp[i+1])==1)\\n                return cnt+ele;\\n                tmp[i] = __gcd(tmp[i],tmp[i+1]);\\n                if(tmp[i]==1)\\n                return cnt+ele;\\n            }\\n            cnt++;\\n            tmp.pop_back();\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> tmp(n);\\n        int ele = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            tmp[i] = nums[i];\\n            if(nums[i]!=1)\\n            ele++;\\n        }\\n        int cnt=0;\\n        while(tmp.size()>1)\\n        {\\n            for(int i=0;i<tmp.size()-1;i++)\\n            {\\n                if(__gcd(tmp[i],tmp[i+1])==1)\\n                return cnt+ele;\\n                tmp[i] = __gcd(tmp[i],tmp[i+1]);\\n                if(tmp[i]==1)\\n                return cnt+ele;\\n            }\\n            cnt++;\\n            tmp.pop_back();\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3489274,
                "title": "python-bruteforce-o-n-3",
                "content": "# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        minspan = float(\\'inf\\')\\n        for i in range(n):\\n            for j in range(i,n):\\n                curgcd = nums[i]\\n                for k in range(i,j+1):\\n                    curgcd = gcd(curgcd, nums[k])\\n                if curgcd == 1 and minspan > j - i + 1:\\n                    minspan = j - i + 1\\n        return -1 if minspan == float(\\'inf\\') else (n - nums.count(1) if minspan == 1 else minspan - 1 + n - 1)\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        minspan = float(\\'inf\\')\\n        for i in range(n):\\n            for j in range(i,n):\\n                curgcd = nums[i]\\n                for k in range(i,j+1):\\n                    curgcd = gcd(curgcd, nums[k])\\n                if curgcd == 1 and minspan > j - i + 1:\\n                    minspan = j - i + 1\\n        return -1 if minspan == float(\\'inf\\') else (n - nums.count(1) if minspan == 1 else minspan - 1 + n - 1)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3488968,
                "title": "c-very-easy-beginner-friendly-easy-approach-solution",
                "content": "class Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n =nums.size();\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==1){\\n              c++;\\n            }\\n        }\\n        if(c==n)  return 0;\\n        if(c>=1){\\n            return n-c;;\\n        }\\n        \\n        int mini=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            int cg= nums[i];\\n            for(int j=i;j<n;j++){\\n                cg=__gcd(cg,nums[j]);\\n                if(cg==1){\\n                    mini=min(mini,j-i+1);\\n                }\\n                else{\\n                    continue;\\n                }\\n            }\\n        }\\n        if(mini!=INT_MAX){\\n            return mini+n-2-c;\\n        }\\n        \\n        return -1;\\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n =nums.size();\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==1){\\n              c++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3478178,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn min_operations(nums: Vec<i32>) -> i32 {\\n        let n = nums.len();\\n        let mut one = 0;\\n        for i in 0..n {\\n            if nums[i] == 1 {\\n                one += 1;\\n            }\\n        }\\n        if one > 0 {\\n            return (n - one) as i32;\\n        }\\n        let mut la = vec![];\\n        let mut ra = vec![];\\n        let mut lg = vec![];\\n        let mut rg = vec![];\\n\\n        fn gcd(mut a: i32, mut b: i32) -> i32 {\\n            while b != 0 {\\n                let t = b;\\n                b = a % b;\\n                a = t;\\n            }\\n            a\\n        }\\n        \\n        fn good(la: &Vec<i32>, ra: &Vec<i32>, lg: &Vec<i32>, rg: &Vec<i32>) -> bool {\\n            let mut g = 0;\\n            if !la.is_empty() {\\n                g = gcd(g, lg[lg.len() - 1]);\\n            }\\n            if !ra.is_empty() {\\n                g = gcd(g, rg[rg.len() - 1]);\\n            }\\n            g == 1\\n        }\\n\\n        fn add(ra: &mut Vec<i32>, rg: &mut Vec<i32>, x: i32) {\\n            ra.push(x);\\n            rg.push(gcd(if rg.is_empty() { 0 } else { rg[rg.len() - 1] }, x));\\n        }\\n\\n        fn remove(la: &mut Vec<i32>, ra: &mut Vec<i32>, lg: &mut Vec<i32>, rg: &mut Vec<i32>) {\\n            if la.is_empty() {\\n                while !ra.is_empty() {\\n                    let x = ra[ra.len() - 1];\\n                    la.push(x);\\n                    ra.pop();\\n                    rg.pop();\\n                    lg.push(gcd(if lg.is_empty() { 0 } else { lg[lg.len() - 1] }, x));\\n                }\\n            }\\n            la.pop();\\n            lg.pop();\\n        }\\n\\n\\n        let mut ans = n;\\n        let (mut l, mut r) = (0, 0);\\n        while r < n {\\n            add(&mut ra, &mut rg, nums[r]);\\n            while l < n && good(&la, &ra, &lg, &rg) {\\n                ans = ans.min(r - l);\\n                remove(&mut la, &mut ra, &mut lg, &mut rg);\\n                l += 1;\\n            }\\n            r += 1;\\n        }\\n        if ans == n {\\n            return -1;\\n        }\\n        (n + ans - 1) as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_operations(nums: Vec<i32>) -> i32 {\\n        let n = nums.len();\\n        let mut one = 0;\\n        for i in 0..n {\\n            if nums[i] == 1 {\\n                one += 1;\\n            }\\n        }\\n        if one > 0 {\\n            return (n - one) as i32;\\n        }\\n        let mut la = vec![];\\n        let mut ra = vec![];\\n        let mut lg = vec![];\\n        let mut rg = vec![];\\n\\n        fn gcd(mut a: i32, mut b: i32) -> i32 {\\n            while b != 0 {\\n                let t = b;\\n                b = a % b;\\n                a = t;\\n            }\\n            a\\n        }\\n        \\n        fn good(la: &Vec<i32>, ra: &Vec<i32>, lg: &Vec<i32>, rg: &Vec<i32>) -> bool {\\n            let mut g = 0;\\n            if !la.is_empty() {\\n                g = gcd(g, lg[lg.len() - 1]);\\n            }\\n            if !ra.is_empty() {\\n                g = gcd(g, rg[rg.len() - 1]);\\n            }\\n            g == 1\\n        }\\n\\n        fn add(ra: &mut Vec<i32>, rg: &mut Vec<i32>, x: i32) {\\n            ra.push(x);\\n            rg.push(gcd(if rg.is_empty() { 0 } else { rg[rg.len() - 1] }, x));\\n        }\\n\\n        fn remove(la: &mut Vec<i32>, ra: &mut Vec<i32>, lg: &mut Vec<i32>, rg: &mut Vec<i32>) {\\n            if la.is_empty() {\\n                while !ra.is_empty() {\\n                    let x = ra[ra.len() - 1];\\n                    la.push(x);\\n                    ra.pop();\\n                    rg.pop();\\n                    lg.push(gcd(if lg.is_empty() { 0 } else { lg[lg.len() - 1] }, x));\\n                }\\n            }\\n            la.pop();\\n            lg.pop();\\n        }\\n\\n\\n        let mut ans = n;\\n        let (mut l, mut r) = (0, 0);\\n        while r < n {\\n            add(&mut ra, &mut rg, nums[r]);\\n            while l < n && good(&la, &ra, &lg, &rg) {\\n                ans = ans.min(r - l);\\n                remove(&mut la, &mut ra, &mut lg, &mut rg);\\n                l += 1;\\n            }\\n            r += 1;\\n        }\\n        if ans == n {\\n            return -1;\\n        }\\n        (n + ans - 1) as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3464113,
                "title": "from-math-import-gcd",
                "content": "Remember the name : Debauch Casanova\\n\\n# Code\\n```\\nimport math\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        one = nums.count(1)\\n        if one: \\n            return len(nums)-one\\n        diff = float(inf) \\n        for i in range(len(nums)): \\n            g = nums[i]\\n            for j in range(i+1, len(nums)):\\n                g = gcd(g, nums[j])\\n                if g == 1: \\n                    diff = min(diff, j-i)\\n        if diff == float(inf):\\n            return -1 \\n        else:\\n            return diff + len(nums) - 1\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        one = nums.count(1)\\n        if one: \\n            return len(nums)-one\\n        diff = float(inf) \\n        for i in range(len(nums)): \\n            g = nums[i]\\n            for j in range(i+1, len(nums)):\\n                g = gcd(g, nums[j])\\n                if g == 1: \\n                    diff = min(diff, j-i)\\n        if diff == float(inf):\\n            return -1 \\n        else:\\n            return diff + len(nums) - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3462638,
                "title": "kotlin-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    fun minOperations(nums: IntArray): Int {\\n        var g = nums[0]\\n        var list = mutableListOf<Int>()\\n        var padding = 0\\n        var result = nums.size\\n        \\n        for (i in 0 until nums.size) {\\n            val n = nums[i]\\n            if (n == 1) {\\n                result--\\n            }\\n            g = gcd(g, n)\\n            if (i == nums.size - 1) continue\\n            \\n            val m = nums[i + 1]\\n            list.add(gcd(m, n))\\n        }\\n        \\n        if (g > 1) return -1\\n        \\n        while(!list.any{ it == 1 }) {\\n            padding++\\n            val nlist = mutableListOf<Int>()\\n            \\n            for (i in 0 until list.size - 1) {\\n                val n = list[i]\\n                val m = list[i + 1]\\n                \\n                nlist.add(gcd(m,n))\\n            }\\n            \\n            list = nlist\\n        }\\n\\n        return result + padding\\n    }\\n    \\n    fun gcd(a: Int, b:Int): Int = if(b != 0) gcd(b, a % b) else a\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun minOperations(nums: IntArray): Int {\\n        var g = nums[0]\\n        var list = mutableListOf<Int>()\\n        var padding = 0\\n        var result = nums.size\\n        \\n        for (i in 0 until nums.size) {\\n            val n = nums[i]\\n            if (n == 1) {\\n                result--\\n            }\\n            g = gcd(g, n)\\n            if (i == nums.size - 1) continue\\n            \\n            val m = nums[i + 1]\\n            list.add(gcd(m, n))\\n        }\\n        \\n        if (g > 1) return -1\\n        \\n        while(!list.any{ it == 1 }) {\\n            padding++\\n            val nlist = mutableListOf<Int>()\\n            \\n            for (i in 0 until list.size - 1) {\\n                val n = list[i]\\n                val m = list[i + 1]\\n                \\n                nlist.add(gcd(m,n))\\n            }\\n            \\n            list = nlist\\n        }\\n\\n        return result + padding\\n    }\\n    \\n    fun gcd(a: Int, b:Int): Int = if(b != 0) gcd(b, a % b) else a\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3462249,
                "title": "c",
                "content": "# Code\\n```\\npublic class Solution {\\n  public int MinOperations(int[] nums) {\\n    if (nums.Contains(1))\\n      return nums.Length - nums.Count(n => n == 1);\\n\\n    var res = int.MaxValue;\\n    for (var i = 0; i < nums.Length; i++) {\\n        var gcd = nums[i];\\n        for (var j = i + 1; j < nums.Length; j++) {\\n            gcd = GCD(gcd, nums[j]);\\n            if (gcd == 1){\\n                res = Math.Min(res, j - i + (nums.Length - 1));\\n                break;\\n            }\\n        } \\n    }     \\n    return res == int.MaxValue ? -1 : res;\\n  }\\n\\n  static int GCD(int num1, int num2) {\\n    while (num2 != 0) {\\n        int temp = num2;\\n        num2 = num1 % num2;\\n        num1 = temp;\\n    }\\n    return num1;\\n  }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n  public int MinOperations(int[] nums) {\\n    if (nums.Contains(1))\\n      return nums.Length - nums.Count(n => n == 1);\\n\\n    var res = int.MaxValue;\\n    for (var i = 0; i < nums.Length; i++) {\\n        var gcd = nums[i];\\n        for (var j = i + 1; j < nums.Length; j++) {\\n            gcd = GCD(gcd, nums[j]);\\n            if (gcd == 1){\\n                res = Math.Min(res, j - i + (nums.Length - 1));\\n                break;\\n            }\\n        } \\n    }     \\n    return res == int.MaxValue ? -1 : res;\\n  }\\n\\n  static int GCD(int num1, int num2) {\\n    while (num2 != 0) {\\n        int temp = num2;\\n        num2 = num1 % num2;\\n        num1 = temp;\\n    }\\n    return num1;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460599,
                "title": "the-most-simple-not-the-most-efficient-python",
                "content": "# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        ans = 2 * n\\n        non_one = sum(1 for num in nums if num != 1)\\n\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                if gcd(*nums[i: j + 1]) == 1:\\n                    ans = min(ans, j - i + non_one - 1)\\n        return -1 if ans == 2 * n else ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        ans = 2 * n\\n        non_one = sum(1 for num in nums if num != 1)\\n\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                if gcd(*nums[i: j + 1]) == 1:\\n                    ans = min(ans, j - i + non_one - 1)\\n        return -1 if ans == 2 * n else ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3459865,
                "title": "python3-gcd-traverses-from-left-to-right-then-right-to-left-time-complexity-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGreedy\\nUse two loops traverse the array from left to right and from right to left, respectively, to find the minimum number of operations needed to make all elements of the array equal to 1. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        cnt = nums.count(1) # to check if any 1\\'s in the nums\\n        if cnt: \\n            return len(nums) - cnt\\n        # get the minium steps from left to right\\n        i = 0\\n        mins = len(nums)\\n        g = nums[0]\\n        for j in range(len(nums)):\\n            if nums[j] == 1:\\n                cnt += 1\\n            g = math.gcd(g, nums[j])\\n            if j and math.gcd(nums[j-1], nums[j]) == g:\\n                i = j-1\\n            if g == 1:\\n                mins = min(mins, j - i)\\n                g = nums[j]\\n                i = j\\n        # get the minium steps from right to left\\n        j = len(nums) - 1\\n        g = nums[-1]\\n        for i in range(len(nums)-1, -1, -1):\\n            g = math.gcd(g, nums[i])\\n            if i < len(nums) - 1 and math.gcd(nums[i], nums[i+1]) == g:\\n                j = i + 1\\n            if g == 1:\\n                mins = min(mins, j - i)\\n                g = nums[i]\\n                j = i\\n        return -1 if mins == len(nums) else mins + len(nums) - 1\\n\\n\\n\\n\\n\\n        \\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        cnt = nums.count(1) # to check if any 1\\'s in the nums\\n        if cnt: \\n            return len(nums) - cnt\\n        # get the minium steps from left to right\\n        i = 0\\n        mins = len(nums)\\n        g = nums[0]\\n        for j in range(len(nums)):\\n            if nums[j] == 1:\\n                cnt += 1\\n            g = math.gcd(g, nums[j])\\n            if j and math.gcd(nums[j-1], nums[j]) == g:\\n                i = j-1\\n            if g == 1:\\n                mins = min(mins, j - i)\\n                g = nums[j]\\n                i = j\\n        # get the minium steps from right to left\\n        j = len(nums) - 1\\n        g = nums[-1]\\n        for i in range(len(nums)-1, -1, -1):\\n            g = math.gcd(g, nums[i])\\n            if i < len(nums) - 1 and math.gcd(nums[i], nums[i+1]) == g:\\n                j = i + 1\\n            if g == 1:\\n                mins = min(mins, j - i)\\n                g = nums[i]\\n                j = i\\n        return -1 if mins == len(nums) else mins + len(nums) - 1\\n\\n\\n\\n\\n\\n        \\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3459753,
                "title": "easily-understandable-solution-uses-gcd-property-and-implementation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere the question asked us to make the whole array 1 by using gcd of adjacent .\\nso the intuition is that gcd of two or more number becomes 1 when their is no common factor between them and another thing is that gcd of any number with 1 is always 1.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo, first we need to check that in the given array whether thier is 1 present or not ,if 1 is present then we can make the whole array 1 by just applying the n- countof(1) operation . You can understand it easily just dry run it with some tcs.\\nNow if 1 is not present then our goal is to find the smallest subarray whose gcd is 1 . We are doing this because once we create a single one from that subarray then in exactly n-1 moves we can make whole array equal to 1 .\\nso ans becomes smallest subarray of gcd 1 + n-1 moves.\\nBelow is the implementation of this..\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2) As nested for loop is running.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int ct=0;\\n        int n=nums.size();\\n        for(auto i:nums)if(i==1)ct++;\\n        if(ct>0)return n-ct;\\n        int ans=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            int an=nums[i];\\n            for(int j=i+1;j<n;j++){\\n                an=__gcd(an,nums[j]);\\n                if(an==1){\\n                    ans=min(ans,j-i);\\n                    break;\\n                }\\n            }\\n            }\\n        if(ans==INT_MAX)return -1;\\n        return ans+n-1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int ct=0;\\n        int n=nums.size();\\n        for(auto i:nums)if(i==1)ct++;\\n        if(ct>0)return n-ct;\\n        int ans=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            int an=nums[i];\\n            for(int j=i+1;j<n;j++){\\n                an=__gcd(an,nums[j]);\\n                if(an==1){\\n                    ans=min(ans,j-i);\\n                    break;\\n                }\\n            }\\n            }\\n        if(ans==INT_MAX)return -1;\\n        return ans+n-1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3459697,
                "title": "beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int noOfOne = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] == 1)\\n               noOfOne++;\\n        }\\n\\n        if(noOfOne > 0)\\n          return nums.length - noOfOne;\\n        \\n        int currLen = Integer.MAX_VALUE;\\n        for(int i = 0; i < nums.length; i++){\\n            int currGcd = nums[i];\\n            for(int j = i + 1; j < nums.length; j++){\\n                 currGcd = gcd(currGcd, nums[j]);\\n                \\n                if(currGcd == 1){\\n                    currLen = Math.min(currLen, j - i + nums.length - 1);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return (currLen == Integer.MAX_VALUE) ? -1 : currLen;\\n    }\\n\\n    public int gcd(int a, int b){\\n        if(b == 0) return a;\\n        return gcd(b, a % b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int noOfOne = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] == 1)\\n               noOfOne++;\\n        }\\n\\n        if(noOfOne > 0)\\n          return nums.length - noOfOne;\\n        \\n        int currLen = Integer.MAX_VALUE;\\n        for(int i = 0; i < nums.length; i++){\\n            int currGcd = nums[i];\\n            for(int j = i + 1; j < nums.length; j++){\\n                 currGcd = gcd(currGcd, nums[j]);\\n                \\n                if(currGcd == 1){\\n                    currLen = Math.min(currLen, j - i + nums.length - 1);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return (currLen == Integer.MAX_VALUE) ? -1 : currLen;\\n    }\\n\\n    public int gcd(int a, int b){\\n        if(b == 0) return a;\\n        return gcd(b, a % b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3457911,
                "title": "fully-explained-easy-c",
                "content": "# Approach and Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n=nums.size();\\n        //Case-1: If there are \\'count\\' number of ones in nums array, then (n-count) will be the min ops, because each non-ones is gonna take 1 step to convert into 1, and (n-count) are the no-ones.\\n\\n        //Let\\'s count ones\\n        int count=0;\\n        for(auto num: nums) {\\n            if(num==1) {\\n                count++;\\n            }\\n        }\\n        if(count>0) {\\n            return n-count;\\n        }\\n\\n        //Case-2: If there are no ones in the array, the we\\'ll follow below algorithm\\n\\n        /*\\n        e.g. 4,8,6,9\\n        if any one of the above elements become 1, then rest will take (n-1) steps to get converted into 1.\\n        So, for example 6 takes x steps to get converted into 1, so overall (x+(n-1))steps will be required by the array to convert all into 1\\n        But then we\\'ll need to check for each element and find the minimal of (x+(n-1)) among all.\\n        It\\'s gonna take O(n2) time\\n\\n        By the way, how to find those x steps, so in the above example, 4 & 9 have gcd 1, and since it is given in the question that we can only change adjacent element to 1, so for 9 to convert into 1, it\\'s gonna take 3 steps i.e.(j-i) steps, where j is index of 9 and i is index of 4. \\n\\n        Hence the optimised approach is to find the smallest subarray, whose gcd is one so, we\\'ll have the minimum j-i value, and hence minimum x value and hence minimum (x+(n-1)) value !\\n        */\\n\\n        int x=INT_MAX;\\n\\n        for(int i=0;i<n-1;i++) {\\n\\n            int g=nums[i];\\n            for(int j=i+1;j<n;j++) {\\n\\n                g=__gcd(g,nums[j]);\\n\\n                if(g==1) {\\n                    x=min(x,j-i);\\n                    break;\\n                }\\n            }\\n        }\\n        //now we have got the minimum x\\n\\n        if(x!=INT_MAX) {\\n            return (x+(n-1));\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n=nums.size();\\n        //Case-1: If there are \\'count\\' number of ones in nums array, then (n-count) will be the min ops, because each non-ones is gonna take 1 step to convert into 1, and (n-count) are the no-ones.\\n\\n        //Let\\'s count ones\\n        int count=0;\\n        for(auto num: nums) {\\n            if(num==1) {\\n                count++;\\n            }\\n        }\\n        if(count>0) {\\n            return n-count;\\n        }\\n\\n        //Case-2: If there are no ones in the array, the we\\'ll follow below algorithm\\n\\n        /*\\n        e.g. 4,8,6,9\\n        if any one of the above elements become 1, then rest will take (n-1) steps to get converted into 1.\\n        So, for example 6 takes x steps to get converted into 1, so overall (x+(n-1))steps will be required by the array to convert all into 1\\n        But then we\\'ll need to check for each element and find the minimal of (x+(n-1)) among all.\\n        It\\'s gonna take O(n2) time\\n\\n        By the way, how to find those x steps, so in the above example, 4 & 9 have gcd 1, and since it is given in the question that we can only change adjacent element to 1, so for 9 to convert into 1, it\\'s gonna take 3 steps i.e.(j-i) steps, where j is index of 9 and i is index of 4. \\n\\n        Hence the optimised approach is to find the smallest subarray, whose gcd is one so, we\\'ll have the minimum j-i value, and hence minimum x value and hence minimum (x+(n-1)) value !\\n        */\\n\\n        int x=INT_MAX;\\n\\n        for(int i=0;i<n-1;i++) {\\n\\n            int g=nums[i];\\n            for(int j=i+1;j<n;j++) {\\n\\n                g=__gcd(g,nums[j]);\\n\\n                if(g==1) {\\n                    x=min(x,j-i);\\n                    break;\\n                }\\n            }\\n        }\\n        //now we have got the minimum x\\n\\n        if(x!=INT_MAX) {\\n            return (x+(n-1));\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3457084,
                "title": "java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int n = nums.length;\\n        int min = 100, ones = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 1) {\\n                ones++;\\n                min = 1;\\n                continue;\\n            }\\n            for (int j = i + 1, a = nums[i]; j < n && j - i < min; j++) {\\n                int b = nums[j];\\n                while (b != 0) {\\n                    int t = a % b;\\n                    a = b;\\n                    b = t;\\n                }\\n                if (a == 1) min = j - i;\\n            }\\n        }\\n        return min < 100 ? n - 1 + min - ones : -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int n = nums.length;\\n        int min = 100, ones = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] == 1) {\\n                ones++;\\n                min = 1;\\n                continue;\\n            }\\n            for (int j = i + 1, a = nums[i]; j < n && j - i < min; j++) {\\n                int b = nums[j];\\n                while (b != 0) {\\n                    int t = a % b;\\n                    a = b;\\n                    b = t;\\n                }\\n                if (a == 1) min = j - i;\\n            }\\n        }\\n        return min < 100 ? n - 1 + min - ones : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3455515,
                "title": "c-find-smallest-subarray-with-gcd-of-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        vector<int> gcfs(nums);\\n        int pivot = -1, groupsz = 0; // to find smallest subarray [pivot, pivot+groupsz) to have gcd of 1\\n        while(pivot == -1 && ++groupsz <= nums.size()) {\\n            for(int i = 0; i <= nums.size() - groupsz; ++i) {\\n                if( (gcfs[i] = gcd(gcfs[i], nums[i + groupsz - 1])) == 1 ) {\\n                    pivot = i;\\n                    break;\\n                }\\n            }\\n        }\\n        if(groupsz > nums.size()) return -1;\\n        nums[pivot] = 1;\\n        return groupsz - 1 + count_if(nums.begin(), nums.end(), binder2nd(not_equal_to<int>(), 1));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        vector<int> gcfs(nums);\\n        int pivot = -1, groupsz = 0; // to find smallest subarray [pivot, pivot+groupsz) to have gcd of 1\\n        while(pivot == -1 && ++groupsz <= nums.size()) {\\n            for(int i = 0; i <= nums.size() - groupsz; ++i) {\\n                if( (gcfs[i] = gcd(gcfs[i], nums[i + groupsz - 1])) == 1 ) {\\n                    pivot = i;\\n                    break;\\n                }\\n            }\\n        }\\n        if(groupsz > nums.size()) return -1;\\n        nums[pivot] = 1;\\n        return groupsz - 1 + count_if(nums.begin(), nums.end(), binder2nd(not_equal_to<int>(), 1));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453390,
                "title": "python3",
                "content": "# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        n1 = sum(i==1 for i in nums)      \\n        l = len(nums)\\n        res = l-n1\\n\\n        while l>1:\\n            new_nums = []\\n            for i in range(l-1):\\n                add = math.gcd(nums[i], nums[i + 1])\\n                if add == 1:\\n                    return res\\n                new_nums.append(add)\\n            nums = new_nums\\n            l = len(nums)\\n            res += 1\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        n1 = sum(i==1 for i in nums)      \\n        l = len(nums)\\n        res = l-n1\\n\\n        while l>1:\\n            new_nums = []\\n            for i in range(l-1):\\n                add = math.gcd(nums[i], nums[i + 1])\\n                if add == 1:\\n                    return res\\n                new_nums.append(add)\\n            nums = new_nums\\n            l = len(nums)\\n            res += 1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452354,
                "title": "python-find-min-subarray-with-gcd-1",
                "content": "This one is tricky.\\n\\n1. Find if the array has at least `1`. As `gcd(x, 1) => 1`, If yes, then you can turn in into all `1` in `N - count_of_1`\\n2. If there\\'s no `1` we need to findout if we can find `1` or not. If we can, we need to find the smallest subarray with `gcd(subarray) = 1`. This will require `len(subarray) - 1` operations to make at least one `1`, if possible. The result is *number of operations to make at least `1` one + number of elements that needs to be turned into 1 except that one `1` that we made earlier*\\n\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        N = len(nums)\\n        \\n        ones = sum((1 for n in nums if n == 1))\\n        if ones:\\n            return N - ones\\n        \\n        min_subarray = float(inf)\\n        for start in range(N - 1):\\n            i = start\\n            c = nums[i]\\n            while i < N - 1 and c != 1:\\n                c = gcd(c, nums[i + 1])\\n                i += 1\\n            if c == 1:\\n                min_subarray = min(min_subarray, i - start + 1)\\n        \\n        if min_subarray == float(inf):\\n            return -1\\n        \\n        return min_subarray - 1 + N - 1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        N = len(nums)\\n        \\n        ones = sum((1 for n in nums if n == 1))\\n        if ones:\\n            return N - ones\\n        \\n        min_subarray = float(inf)\\n        for start in range(N - 1):\\n            i = start\\n            c = nums[i]\\n            while i < N - 1 and c != 1:\\n                c = gcd(c, nums[i + 1])\\n                i += 1\\n            if c == 1:\\n                min_subarray = min(min_subarray, i - start + 1)\\n        \\n        if min_subarray == float(inf):\\n            return -1\\n        \\n        return min_subarray - 1 + N - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452267,
                "title": "python3-segment-tree-o-n-log-n-shortest-subarray-with-gcd-as-1",
                "content": "Follow the same logic as many other discussions:\\n* Check edge cases.\\n* Find the shortest subarray with GCD as 1 by sliding window: first move pointer hi to the right until GCD of nums[lo:hi] is 1, then shrink pointer lo from the left until it is no longer 1; after that move on to the next window...\\n* Use segment tree to calculate GCD of range nums[lo:hi] efficiently in O(log n).\\n```\\n    def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        \\n\\t\\t# edge case 1: check existence of 1\\n        c1 = nums.count(1)\\n        if c1 > 0:\\n            return n - c1\\n        \\n\\t\\t# edge case 2: impossible if GCD of all numbers is not 1\\n        if gcd(*nums) != 1:\\n            return -1\\n        \\n\\t\\t# initialize segment tree: tree[i] = gcd(tree[k]: k + 1 has bit prefix as i + 1)\\n        tree = [0] * (n - 1) + nums\\n        for i in range(n - 2, -1, -1):\\n            tree[i] = gcd(tree[2*i + 1], tree[2*i + 2])\\n        \\n\\t\\t# helper function to calculate GCD of range nums[lo:hi]\\n        def gcd_range(lo, hi):\\n            g = nums[lo]\\n            lo += n - 1\\n            hi += n - 1 \\n            while lo < hi:\\n                if lo % 2 == 0:\\n                    g = gcd(g, tree[lo])\\n                    lo += 1\\n                if hi % 2 == 0:\\n                    hi -= 1\\n                    g = gcd(g, tree[hi])\\n                lo = (lo - 1) // 2\\n                hi = (hi - 1) // 2\\n            return g\\n        \\n        # find shortest subarray with GCD as 1\\n        w = n \\n        lo = hi = 1        \\n        g = nums[0]\\n        while hi < n:\\n            g = gcd(g, nums[hi])\\n            hi += 1\\n            if g == 1:\\n                while (g := gcd_range(lo, hi)) == 1:\\n                    lo += 1\\n                w = min(w, hi - lo + 1)\\n\\n        return n - 2 + w\\n```",
                "solutionTags": [
                    "Two Pointers",
                    "Tree",
                    "Sliding Window"
                ],
                "code": "```\\n    def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        \\n\\t\\t# edge case 1: check existence of 1\\n        c1 = nums.count(1)\\n        if c1 > 0:\\n            return n - c1\\n        \\n\\t\\t# edge case 2: impossible if GCD of all numbers is not 1\\n        if gcd(*nums) != 1:\\n            return -1\\n        \\n\\t\\t# initialize segment tree: tree[i] = gcd(tree[k]: k + 1 has bit prefix as i + 1)\\n        tree = [0] * (n - 1) + nums\\n        for i in range(n - 2, -1, -1):\\n            tree[i] = gcd(tree[2*i + 1], tree[2*i + 2])\\n        \\n\\t\\t# helper function to calculate GCD of range nums[lo:hi]\\n        def gcd_range(lo, hi):\\n            g = nums[lo]\\n            lo += n - 1\\n            hi += n - 1 \\n            while lo < hi:\\n                if lo % 2 == 0:\\n                    g = gcd(g, tree[lo])\\n                    lo += 1\\n                if hi % 2 == 0:\\n                    hi -= 1\\n                    g = gcd(g, tree[hi])\\n                lo = (lo - 1) // 2\\n                hi = (hi - 1) // 2\\n            return g\\n        \\n        # find shortest subarray with GCD as 1\\n        w = n \\n        lo = hi = 1        \\n        g = nums[0]\\n        while hi < n:\\n            g = gcd(g, nums[hi])\\n            hi += 1\\n            if g == 1:\\n                while (g := gcd_range(lo, hi)) == 1:\\n                    lo += 1\\n                w = min(w, hi - lo + 1)\\n\\n        return n - 2 + w\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3451358,
                "title": "easy-explained-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust think what will happen if there is atleast one \\'1\\' in the array then simply ans will be n-(number of 1\\'s).\\n\\nif 1 is not present then we have to find 2 elements such that their gcd is 1 then count the steps to do so. final answer will be :-\\n---->  steps required + n-steps.\\n\\nSee solution for clean code.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n=nums.size();\\n        int c=count(nums.begin(), nums.end(), 1);\\n        if(c!=0) return n-c;\\n        int ans=INT_MAX;\\n\\n        for(int i=0; i<n; i++){\\n            int gcd=nums[i];\\n            for(int j=i+1; j<n; j++){\\n                gcd=__gcd(gcd, nums[j]);\\n\\n                if(gcd==1){\\n                    ans=min(ans, j-i+n-1);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans==INT_MAX? -1:ans;\\n    }\\n};\\n\\n// 2 6 3 4\\n// 2 2 1 -1\\n    \\n// 6 10 15\\n// 2 1 -2\\n\\n\\n// 6 10 15\\n// 2 10 15\\n// 2 1  15\\n// 1 1 15\\n// 1 1 1\\n    \\n// 2*3\\n// 2*5\\n// 3*5\\n\\n\\n// 1*2\\n// 2*3\\n// 1*3\\n// 2*2\\n\\n\\n// 010\\n// 110\\n// 011\\n// 100\\n    \\n    \\n// 0010\\n// 1010\\n// 0110\\n// 1110\\n\\n\\n// 2 6 3 9 4\\n// 2 6 3 9 1\\n// 2 6 3 1 1\\n// 2 1 3 1 1\\n// 1 1 3 1 1\\n// 1 1 1 1 1\\n\\n\\n\\n// If the gcd is 1, then we can start iterating through the array, keeping track of the current gcd of the current element and its neighbor to the right. If the current gcd is not already 1, we keep expanding the current gcd to the right until we reach the end of the array or the current gcd becomes 1. We count the number of operations needed to make the current gcd equal to 1 and move on to the next element.\\n\\n// Finally, we return the total number of operations needed to make all elements 1.\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n=nums.size();\\n        int c=count(nums.begin(), nums.end(), 1);\\n        if(c!=0) return n-c;\\n        int ans=INT_MAX;\\n\\n        for(int i=0; i<n; i++){\\n            int gcd=nums[i];\\n            for(int j=i+1; j<n; j++){\\n                gcd=__gcd(gcd, nums[j]);\\n\\n                if(gcd==1){\\n                    ans=min(ans, j-i+n-1);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans==INT_MAX? -1:ans;\\n    }\\n};\\n\\n// 2 6 3 4\\n// 2 2 1 -1\\n    \\n// 6 10 15\\n// 2 1 -2\\n\\n\\n// 6 10 15\\n// 2 10 15\\n// 2 1  15\\n// 1 1 15\\n// 1 1 1\\n    \\n// 2*3\\n// 2*5\\n// 3*5\\n\\n\\n// 1*2\\n// 2*3\\n// 1*3\\n// 2*2\\n\\n\\n// 010\\n// 110\\n// 011\\n// 100\\n    \\n    \\n// 0010\\n// 1010\\n// 0110\\n// 1110\\n\\n\\n// 2 6 3 9 4\\n// 2 6 3 9 1\\n// 2 6 3 1 1\\n// 2 1 3 1 1\\n// 1 1 3 1 1\\n// 1 1 1 1 1\\n\\n\\n\\n// If the gcd is 1, then we can start iterating through the array, keeping track of the current gcd of the current element and its neighbor to the right. If the current gcd is not already 1, we keep expanding the current gcd to the right until we reach the end of the array or the current gcd becomes 1. We count the number of operations needed to make the current gcd equal to 1 and move on to the next element.\\n\\n// Finally, we return the total number of operations needed to make all elements 1.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451320,
                "title": "c-solution-o-n-2-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int,int> mp;\\n        int g = nums[0];\\n        for(auto i : nums) {mp[i]++; g = __gcd(g, i);}\\n        if(g > 1) return -1;\\n        if(mp[1] > 0) return n-mp[1];\\n        for(int i=0;i<n-1;i++) if(__gcd(nums[i], nums[i+1]) == 1) return n;\\n        int count = 1e9;\\n        for(int ind=0;ind<n;ind++){\\n            g = 0;\\n            int cnt = 0, gc = 0;\\n            for(int i=ind;i<n;i++){\\n                g = __gcd(g, nums[i]);\\n                if(g == 1){\\n                    int k = nums[i];\\n                    int j = i-1; gc = nums[j];\\n                    while(__gcd(gc,k) != 1){\\n                        j--; cnt++;\\n                        gc = __gcd(gc, nums[j]);\\n                    }\\n                    break;\\n                }\\n            }\\n            if(cnt > 0) count = min(count, cnt);\\n        }\\n        return n + count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int,int> mp;\\n        int g = nums[0];\\n        for(auto i : nums) {mp[i]++; g = __gcd(g, i);}\\n        if(g > 1) return -1;\\n        if(mp[1] > 0) return n-mp[1];\\n        for(int i=0;i<n-1;i++) if(__gcd(nums[i], nums[i+1]) == 1) return n;\\n        int count = 1e9;\\n        for(int ind=0;ind<n;ind++){\\n            g = 0;\\n            int cnt = 0, gc = 0;\\n            for(int i=ind;i<n;i++){\\n                g = __gcd(g, nums[i]);\\n                if(g == 1){\\n                    int k = nums[i];\\n                    int j = i-1; gc = nums[j];\\n                    while(__gcd(gc,k) != 1){\\n                        j--; cnt++;\\n                        gc = __gcd(gc, nums[j]);\\n                    }\\n                    break;\\n                }\\n            }\\n            if(cnt > 0) count = min(count, cnt);\\n        }\\n        return n + count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451155,
                "title": "intuitive-simulation-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    int gcd(int a, int b) {\\n        if (a < b) swap(a, b);\\n        if (b == 0) return a;\\n\\n        return gcd(b, a % b);\\n    }\\n\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int len = nums.size();\\n        int ones = 0;\\n        for (auto n : nums) {\\n            ones += n == 1;\\n        }\\n\\n        \\n        bool one = false;\\n        int step = -1;\\n\\n        while (nums.size() > 1 and !one) {\\n            vector<int> next;\\n            for (int i = 0; i < nums.size() - 1; ++i) {\\n                next.push_back(gcd(nums[i], nums[i + 1]));\\n                if (next.back() == 1) {\\n                    one = true;\\n                    break;\\n                }\\n            }\\n            nums = next;\\n            ++step;\\n        }\\n\\n        if (!one) return -1;\\n\\n        return len + step - ones;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\n    int gcd(int a, int b) {\\n        if (a < b) swap(a, b);\\n        if (b == 0) return a;\\n\\n        return gcd(b, a % b);\\n    }\\n\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int len = nums.size();\\n        int ones = 0;\\n        for (auto n : nums) {\\n            ones += n == 1;\\n        }\\n\\n        \\n        bool one = false;\\n        int step = -1;\\n\\n        while (nums.size() > 1 and !one) {\\n            vector<int> next;\\n            for (int i = 0; i < nums.size() - 1; ++i) {\\n                next.push_back(gcd(nums[i], nums[i + 1]));\\n                if (next.back() == 1) {\\n                    one = true;\\n                    break;\\n                }\\n            }\\n            nums = next;\\n            ++step;\\n        }\\n\\n        if (!one) return -1;\\n\\n        return len + step - ones;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450295,
                "title": "o-n-2-solution-in-cpp",
                "content": "\\n# Complexity\\n- Time complexity: ``O(n^2)``\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: ``O(1)``\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int ans = INT_MAX, cnt = 0, n = nums.size();\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] == 1){\\n                cnt++;\\n            }\\n        }\\n        if(cnt > 0){\\n            return n - cnt;\\n        }\\n        for(int i = 0; i < n; ++i){\\n            int gcd = nums[i];\\n            for(int j = i + 1; j < n; ++j){\\n                gcd = __gcd(gcd, nums[j]);\\n                if(gcd == 1){\\n                    ans = min(ans, n - 1 + j - i);\\n                }\\n            }\\n        }\\n        \\n        \\n        return ans == INT_MAX? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int ans = INT_MAX, cnt = 0, n = nums.size();\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] == 1){\\n                cnt++;\\n            }\\n        }\\n        if(cnt > 0){\\n            return n - cnt;\\n        }\\n        for(int i = 0; i < n; ++i){\\n            int gcd = nums[i];\\n            for(int j = i + 1; j < n; ++j){\\n                gcd = __gcd(gcd, nums[j]);\\n                if(gcd == 1){\\n                    ans = min(ans, n - 1 + j - i);\\n                }\\n            }\\n        }\\n        \\n        \\n        return ans == INT_MAX? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450166,
                "title": "c-solution",
                "content": "# Code\\n```\\npublic class Solution\\n{\\n    public int MinOperations(int[] nums)\\n    {\\n        if (nums.Contains(1))\\n            return nums.Length - nums.Count(n => n == 1);\\n\\n        var result = -1;\\n\\n        for (var i = 0; i < nums.Length; i++)\\n            for (var j = i; j < nums.Length; j++)\\n            {\\n                var d = nums.Skip(i).Take(j - i + 1).Aggregate(nums[j], Gcd);\\n\\n                if (d != 1)\\n                    continue;\\n\\n                result = result == -1\\n                    ? j - i + 1\\n                    : Math.Min(result, j - i + 1);\\n            }\\n\\n        return result == -1 ? -1 : nums.Length + result - 2;\\n    }\\n\\n    private static int Gcd(int a, int b)\\n    {\\n        return b == 0 ? a : Gcd(b, a % b);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int MinOperations(int[] nums)\\n    {\\n        if (nums.Contains(1))\\n            return nums.Length - nums.Count(n => n == 1);\\n\\n        var result = -1;\\n\\n        for (var i = 0; i < nums.Length; i++)\\n            for (var j = i; j < nums.Length; j++)\\n            {\\n                var d = nums.Skip(i).Take(j - i + 1).Aggregate(nums[j], Gcd);\\n\\n                if (d != 1)\\n                    continue;\\n\\n                result = result == -1\\n                    ? j - i + 1\\n                    : Math.Min(result, j - i + 1);\\n            }\\n\\n        return result == -1 ? -1 : nums.Length + result - 2;\\n    }\\n\\n    private static int Gcd(int a, int b)\\n    {\\n        return b == 0 ? a : Gcd(b, a % b);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449155,
                "title": "easy-explanation-java-code-silly-observation-need-to-solve-this-problem",
                "content": "**IF YOU LIKE THE SOLUTION THEN UPVOTE IT PLEASE**\\n```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        \\n        int n = nums.length;\\n        int ele = nums[0],numOpe = 0;\\n        \\n        //check if how many 1 present already\\n        //another check if the whole array gcd is not one atleast then not possible to make all one;\\n        for(int i = 0; i < n; i++)\\n        {\\n            ele = gcd(nums[i],ele);\\n            \\n            if(nums[i] == 1)\\n                numOpe++;\\n        }\\n        if(ele != 1)return -1;\\n        \\n        //number of not one element\\n        int notOne = n - numOpe; \\n        \\n        \\n        /*\\n        calculate no operation to make atleast single one\\n        as the n constraint 50 we can use broute force method\\n        why we use broute foce\\n        let\\'s consider one example\\n        e.g : 2,4,6,3\\n        if you computer all those ele single time then it\\n        atleast min single one operation is 3 but actually it\\'s two\\n        how? \\n        gcd(4,3) --> 1\\n        */\\n        int finalMinOperationAtleastOne = Integer.MAX_VALUE;\\n        for(int i = 0; i < n; i++)\\n        {\\n            ele = nums[i];\\n            int minOpeAtleastOne = 0;\\n            for(int j = i+1; j < n; j++)\\n            {\\n                ele = gcd(ele,nums[j]);\\n                minOpeAtleastOne++;\\n                if(ele == 1){\\n                    finalMinOperationAtleastOne = Math.min(finalMinOperationAtleastOne,minOpeAtleastOne);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n       //-1 because we already calculate one those gcd during interation\\n    return finalMinOperationAtleastOne + notOne - 1;\\n        \\n    }\\n    private int gcd(int a, int b)\\n    {\\n        if(a == 0)\\n            return b;\\n        return gcd(b%a,a);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Array",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        \\n        int n = nums.length;\\n        int ele = nums[0],numOpe = 0;\\n        \\n        //check if how many 1 present already\\n        //another check if the whole array gcd is not one atleast then not possible to make all one;\\n        for(int i = 0; i < n; i++)\\n        {\\n            ele = gcd(nums[i],ele);\\n            \\n            if(nums[i] == 1)\\n                numOpe++;\\n        }\\n        if(ele != 1)return -1;\\n        \\n        //number of not one element\\n        int notOne = n - numOpe; \\n        \\n        \\n        /*\\n        calculate no operation to make atleast single one\\n        as the n constraint 50 we can use broute force method\\n        why we use broute foce\\n        let\\'s consider one example\\n        e.g : 2,4,6,3\\n        if you computer all those ele single time then it\\n        atleast min single one operation is 3 but actually it\\'s two\\n        how? \\n        gcd(4,3) --> 1\\n        */\\n        int finalMinOperationAtleastOne = Integer.MAX_VALUE;\\n        for(int i = 0; i < n; i++)\\n        {\\n            ele = nums[i];\\n            int minOpeAtleastOne = 0;\\n            for(int j = i+1; j < n; j++)\\n            {\\n                ele = gcd(ele,nums[j]);\\n                minOpeAtleastOne++;\\n                if(ele == 1){\\n                    finalMinOperationAtleastOne = Math.min(finalMinOperationAtleastOne,minOpeAtleastOne);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n       //-1 because we already calculate one those gcd during interation\\n    return finalMinOperationAtleastOne + notOne - 1;\\n        \\n    }\\n    private int gcd(int a, int b)\\n    {\\n        if(a == 0)\\n            return b;\\n        return gcd(b%a,a);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448987,
                "title": "python-solution",
                "content": "# Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf 1 is in the array, the result is length of array - number of 1.\\nElse we tries to find the smallest subset that has gcd of 1, the result would be the length of the array + length of subset - 1\\nIf we cannot find such subset, it is impossible to achieve the goal, so we return -1\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        if 1 in nums: return len(nums) - nums.count(1)\\n        self.res = [0, 100]\\n        def dfs(st, i, val):\\n            if i - st >= self.res[1] - self.res[0]:\\n                return\\n            if val == 1:\\n                if self.res[1] - self.res[0] > (i - st):\\n                    self.res = [st, i]\\n                return\\n            if i == len(nums): return\\n            dfs(st, i+1, math.gcd(val, nums[i]))\\n        \\n        for i in range(len(nums)):\\n            dfs(i, i+1, nums[i])\\n        \\n        return -1 if self.res == [0, 100] else len(nums) + (self.res[1] - self.res[0] - 2)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        if 1 in nums: return len(nums) - nums.count(1)\\n        self.res = [0, 100]\\n        def dfs(st, i, val):\\n            if i - st >= self.res[1] - self.res[0]:\\n                return\\n            if val == 1:\\n                if self.res[1] - self.res[0] > (i - st):\\n                    self.res = [st, i]\\n                return\\n            if i == len(nums): return\\n            dfs(st, i+1, math.gcd(val, nums[i]))\\n        \\n        for i in range(len(nums)):\\n            dfs(i, i+1, nums[i])\\n        \\n        return -1 if self.res == [0, 100] else len(nums) + (self.res[1] - self.res[0] - 2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448477,
                "title": "clean-and-explanatory-code-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMain intention is to make anyhow one element of the array as 1 which will help make all the elements as 1.\\n\\nIF GCD of complete array is not 1, then its impossible to have a element be made 1 which will make entire 1..\\nIf the array already consists of 1s, then no of operations = (n - no. of ones)\\n\\nIf no 1s are present, then we have to perform operations to make 1 and then total operations = **\"operations to make 1\"** + (n - 1)operations to make rest of the normal elements as 1. \\n\\nFor **\"operations to make 1\"**,\\nWe find the minimum size array which has a gcd of 1. The min size array will result in less operations to make a element 1. Then the rest no of operations need to make other operations 1 = (n - 1).\\nNote:- The -1 is because of the element which has been made 1 by gcd operations in the minimum size array.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBrute Force since constraints allow us\\n# Complexity\\n- Time complexity: O(N*3)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int ones = 0, val = 0;\\n        for(auto ele: nums)\\n        {\\n            val = __gcd(val, ele);\\n            if(ele == 1)\\n                ones++;\\n        }\\n        \\n        //base cases of impossibility\\n        if(val != 1)\\n            return -1;\\n        \\n        //base case of some 1s being already present\\n        if(ones != 0)\\n            return n - ones;\\n        \\n        //if no 1s are present, and we need to make all elements 1\\n        int min_sz = 100;\\n        for(int i = 0; i < n; i++)\\n            for(int j = i; j < n; j++)\\n            {\\n                int el = 0;\\n                for(int k = i; k <= j; k++)\\n                {\\n                    el = __gcd(el, nums[k]);\\n                }\\n                if(el == 1)\\n                    min_sz = min(min_sz, j - i + 1);\\n            }\\n        \\n        return (min_sz - 1) + (n - 1);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int ones = 0, val = 0;\\n        for(auto ele: nums)\\n        {\\n            val = __gcd(val, ele);\\n            if(ele == 1)\\n                ones++;\\n        }\\n        \\n        //base cases of impossibility\\n        if(val != 1)\\n            return -1;\\n        \\n        //base case of some 1s being already present\\n        if(ones != 0)\\n            return n - ones;\\n        \\n        //if no 1s are present, and we need to make all elements 1\\n        int min_sz = 100;\\n        for(int i = 0; i < n; i++)\\n            for(int j = i; j < n; j++)\\n            {\\n                int el = 0;\\n                for(int k = i; k <= j; k++)\\n                {\\n                    el = __gcd(el, nums[k]);\\n                }\\n                if(el == 1)\\n                    min_sz = min(min_sz, j - i + 1);\\n            }\\n        \\n        return (min_sz - 1) + (n - 1);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448373,
                "title": "simple-gcd-concept-solution",
                "content": "# Intuition\\n```\\n2 consecutive numbers gcd=1;__gcd(5,6)=1, __gcd(45,46)=1;\\n__gcd(1,any number)=1;\\n```\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int cnt=0,maxi=INT_MAX;\\n        for(int x:nums){\\n            if(x==1)cnt++;\\n        }\\n        if(cnt>0){\\n            return nums.size()-cnt;\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            int last=nums[i];\\n            for(int j=i+1;j<nums.size();j++){\\n                last=__gcd(last,nums[j]);\\n                if(last==1){\\n                    maxi=min(maxi,j-i);\\n                    break;\\n                }\\n            }\\n        }\\n        if(maxi!=INT_MAX){\\n            return maxi+nums.size()-1;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n2 consecutive numbers gcd=1;__gcd(5,6)=1, __gcd(45,46)=1;\\n__gcd(1,any number)=1;\\n```\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int cnt=0,maxi=INT_MAX;\\n        for(int x:nums){\\n            if(x==1)cnt++;\\n        }\\n        if(cnt>0){\\n            return nums.size()-cnt;\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            int last=nums[i];\\n            for(int j=i+1;j<nums.size();j++){\\n                last=__gcd(last,nums[j]);\\n                if(last==1){\\n                    maxi=min(maxi,j-i);\\n                    break;\\n                }\\n            }\\n        }\\n        if(maxi!=INT_MAX){\\n            return maxi+nums.size()-1;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3447564,
                "title": "simple-brute-force-with-explanation-using-gcd-10-line-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int countOne=0;\\n        for(auto x: nums){\\n            if(x==1){\\n               countOne++;\\n            }\\n        }\\n        if(countOne>0){\\n             // 1 1 1 8 3 7\\n            return (nums.size() - countOne);\\n        }else{\\n            // 3 4 2 6\\n            // 1,1,1,1 8 10\\n            /// check if any pair gcd become 1;\\n            int ans=INT_MAX;\\n            int n = nums.size();\\n            for(int i=0;i<n-1;i++){\\n                int gcd = nums[i];\\n                for(int j=i+1;j<n;j++){\\n                    gcd = __gcd(gcd,nums[j]);\\n                    if(gcd==1){\\n                        // if means we start from the index i , and till jth index and which will make one value as 1 , in the\\n                        // operation of j-i, and then we will use this 1 to make all n-1 to become 1;\\n                        ans=min(ans,j-i+(n-1));\\n                    }\\n                }\\n            }\\n             if(ans==INT_MAX) ans=-1;\\n            return ans;\\n            \\n        }\\n    }\\n};\\n\\n// 6,10,15\\n// 6,2,15\\n// 6,2,1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int countOne=0;\\n        for(auto x: nums){\\n            if(x==1){\\n               countOne++;\\n            }\\n        }\\n        if(countOne>0){\\n             // 1 1 1 8 3 7\\n            return (nums.size() - countOne);\\n        }else{\\n            // 3 4 2 6\\n            // 1,1,1,1 8 10\\n            /// check if any pair gcd become 1;\\n            int ans=INT_MAX;\\n            int n = nums.size();\\n            for(int i=0;i<n-1;i++){\\n                int gcd = nums[i];\\n                for(int j=i+1;j<n;j++){\\n                    gcd = __gcd(gcd,nums[j]);\\n                    if(gcd==1){\\n                        // if means we start from the index i , and till jth index and which will make one value as 1 , in the\\n                        // operation of j-i, and then we will use this 1 to make all n-1 to become 1;\\n                        ans=min(ans,j-i+(n-1));\\n                    }\\n                }\\n            }\\n             if(ans==INT_MAX) ans=-1;\\n            return ans;\\n            \\n        }\\n    }\\n};\\n\\n// 6,10,15\\n// 6,2,15\\n// 6,2,1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3447558,
                "title": "python-3-find-shortest-subarray-with-gcd-1",
                "content": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        \\n        n = len(nums)      \\n            \\n        vis = deque()\\n        \\n        def check(cands):\\n            tmp = cands[0]\\n            for i in range(1, len(cands)):\\n                tmp = math.gcd(tmp, cands[i])\\n                if tmp == 1: return True\\n            return tmp == 1\\n                \\n        \\n        size = n + 1\\n        for j in range(len(nums)):\\n            vis.append(nums[j])\\n            while vis and check(vis):\\n                size = min(size, len(vis))                \\n                vis.popleft()\\n        \\n\\t\\t# if 1 already existed, then just need to change non-1 elements\\n        if size == 1:\\n            return sum(num > 1 for num in nums)\\n\\t\\t# not able to find the subarray\\n        elif size == n + 1:\\n            return -1\\n        # all element > 1 but could find a subarray\\n\\t\\t# the ops need to transform the subarray to have at least one 1 is (size - 1), and then transofrm the rest of elements is (n - 1)\\n\\t\\telse:\\n            return n - 1 + size - 1\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        \\n        n = len(nums)      \\n            \\n        vis = deque()\\n        \\n        def check(cands):\\n            tmp = cands[0]\\n            for i in range(1, len(cands)):\\n                tmp = math.gcd(tmp, cands[i])\\n                if tmp == 1: return True\\n            return tmp == 1\\n                \\n        \\n        size = n + 1\\n        for j in range(len(nums)):\\n            vis.append(nums[j])\\n            while vis and check(vis):\\n                size = min(size, len(vis))                \\n                vis.popleft()\\n        \\n\\t\\t# if 1 already existed, then just need to change non-1 elements\\n        if size == 1:\\n            return sum(num > 1 for num in nums)\\n\\t\\t# not able to find the subarray\\n        elif size == n + 1:\\n            return -1\\n        # all element > 1 but could find a subarray\\n\\t\\t# the ops need to transform the subarray to have at least one 1 is (size - 1), and then transofrm the rest of elements is (n - 1)\\n\\t\\telse:\\n            return n - 1 + size - 1\\n",
                "codeTag": "Java"
            },
            {
                "id": 3447549,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums):\\n        n, ones, diff = len(nums), nums.count(1), float(\"inf\")\\n\\n        if ones: return n-ones\\n\\n        for i in range(n):\\n            val = nums[i]\\n            for j in range(i+1,n):\\n                val = gcd(val,nums[j])\\n                if val == 1: diff = min(diff,j-i+1)\\n\\n        return -1 if diff == float(\"inf\") else diff + n - 2\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums):\\n        n, ones, diff = len(nums), nums.count(1), float(\"inf\")\\n\\n        if ones: return n-ones\\n\\n        for i in range(n):\\n            val = nums[i]\\n            for j in range(i+1,n):\\n                val = gcd(val,nums[j])\\n                if val == 1: diff = min(diff,j-i+1)\\n\\n        return -1 if diff == float(\"inf\") else diff + n - 2\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3447440,
                "title": "my-thought-process-to-approach-it",
                "content": "Let\\'s estimate the lower/upper bound of the minimum number of operations to see\\nwhat happens.\\n\\n## Lower Bound\\n\\nIf we are lucky, each operation will convert a number to 1, then the lower bound\\nis `n = length(nums)`, or more precisely, `n - count(1, nums)`.\\nWhen this happens?\\nObviously, if we have 1 in the input array, we can spread it to the whole array.\\n\\nSo we have this pseudocode:\\n\\n```python\\ndef solve(nums: list[int]):\\n    if nums.contains(1):\\n        return nums.len() - nums.count(1)\\n    else:\\n        ...\\n```\\n\\n## Upper Bound\\n\\nThen we estimate the upper bound. The case there is no 1.\\n\\nThings start to become complex.\\n\\nLet us start with a simple example.\\nWe have two numbers: `[a, b]`, let `g = gcd(a, b)`.\\nWe might have this operation sequence:\\n\\n```\\na1 <- g\\nb1 <- gcd(a1, b) = gcd(g, b) = g\\na2 <- gcd(a1, b1) = gcd(g, g) = g\\n...\\n```\\n\\nYou might noticed that more operations are meaningless, because\\nthe result is always `g`, that means we can do at most 2 operations for 2\\nelements array, if it will succeed to make them to be 1.\\n\\nIt\\'s a good sign.\\nLet\\'s see what happens for 3 elements array `[a, b, c]`.\\nThis is a possible operation sequence:\\n\\n```\\na1 <- gcd(a, b)\\nb1 <- gcd(a1, b) = gcd(gcd(a, b), b) = gcd(a, b)\\nc1 <- gcd(b1, c) = gcd(gcd(a, b), c) = gcd(a, b, c)\\na2 <- gcd(a1, b1) = gcd(a, b)\\nb2 <- gcd(b2, c1) = gcd(a, b, c)\\nc2 <- gcd(b2, c1) = gcd(a, b, c)\\n...\\n```\\n\\nLook what happens! the new `a` will always be one of `gcd(a, b)`, `gcd(a, b, c)`\\nthe new `b` will always be one of `gcd(a, b)`, `gcd(b, c)`, or `gcd(a, b, c)`.\\n\\nIf these gcd values don\\'t contain 1, then it fails. Otherwise, we can do at most\\n2 operations to make the array appears 1.\\n\\nFinally, we can do at most `n-1` operations to make the `n` length array appears 1.\\n\\n## Generalize\\n\\nIn this case, suppose `nums[i]` will be the first 1, it might be the values\\n\\n```\\ngcd(nums[i], nums[i+1])\\ngcd(nums[i], nums[i+1], nums[i+2])\\n...\\ngcd(nums[i-1], nums[i])\\ngcd(nums[i-2], nums[i-1], nums[i])\\n...\\ngcd(nums[i-1], nums[i], nums[i+1])\\n...\\n```\\n\\nAny gcd of a subarray that contains `nums[i]` might be the first 1.\\n\\nWe can enumerate all subarrays to find the minimum length subarray that gcd is 1.\\n\\nFinally, the pseudocode:\\n\\n```python\\ndef solve(nums: list[int]):\\n    if nums.contains(1):\\n        return nums.len() - nums.count(1)\\n    else:\\n        min_len = inf\\n        for subarray in subarrays_of(nums):\\n            if gcd(subarray) == 1:\\n                min_len = min(min_len, subarray.len())\\n        if min_len == inf:\\n            return -1\\n        else:\\n            return (nums.len() - 1) + (min_len - 1)\\n```\\n\\n# Code\\n\\n```scheme\\n(define (min-operations nums)\\n  (define inf #e1e9)\\n  (define min-len inf)\\n  (define n (length nums))\\n  (for* ([j (inclusive-range 1 n)]\\n         [i j])\\n    (when (= 1 (apply gcd (sublist nums i j)))\\n      (set! min-len (min min-len (- j i)))))\\n\\n  (if (= min-len inf)\\n      -1\\n      (+ (- n (max 1 (count (\\u03BB (x) (= x 1)) nums)))\\n         (- min-len 1))))\\n\\n(define (sublist lst from to)\\n  (drop (take lst to) from))\\n\\n```\\n\\n## Conclusion\\n\\nThe only important idea is to estimate the space of the result.\\n\\nUpvote if you like it.\\n",
                "solutionTags": [
                    "Racket"
                ],
                "code": "```python\\ndef solve(nums: list[int]):\\n    if nums.contains(1):\\n        return nums.len() - nums.count(1)\\n    else:\\n        ...\\n```\n```\\na1 <- g\\nb1 <- gcd(a1, b) = gcd(g, b) = g\\na2 <- gcd(a1, b1) = gcd(g, g) = g\\n...\\n```\n```\\na1 <- gcd(a, b)\\nb1 <- gcd(a1, b) = gcd(gcd(a, b), b) = gcd(a, b)\\nc1 <- gcd(b1, c) = gcd(gcd(a, b), c) = gcd(a, b, c)\\na2 <- gcd(a1, b1) = gcd(a, b)\\nb2 <- gcd(b2, c1) = gcd(a, b, c)\\nc2 <- gcd(b2, c1) = gcd(a, b, c)\\n...\\n```\n```\\ngcd(nums[i], nums[i+1])\\ngcd(nums[i], nums[i+1], nums[i+2])\\n...\\ngcd(nums[i-1], nums[i])\\ngcd(nums[i-2], nums[i-1], nums[i])\\n...\\ngcd(nums[i-1], nums[i], nums[i+1])\\n...\\n```\n```python\\ndef solve(nums: list[int]):\\n    if nums.contains(1):\\n        return nums.len() - nums.count(1)\\n    else:\\n        min_len = inf\\n        for subarray in subarrays_of(nums):\\n            if gcd(subarray) == 1:\\n                min_len = min(min_len, subarray.len())\\n        if min_len == inf:\\n            return -1\\n        else:\\n            return (nums.len() - 1) + (min_len - 1)\\n```\n```scheme\\n(define (min-operations nums)\\n  (define inf #e1e9)\\n  (define min-len inf)\\n  (define n (length nums))\\n  (for* ([j (inclusive-range 1 n)]\\n         [i j])\\n    (when (= 1 (apply gcd (sublist nums i j)))\\n      (set! min-len (min min-len (- j i)))))\\n\\n  (if (= min-len inf)\\n      -1\\n      (+ (- n (max 1 (count (\\u03BB (x) (= x 1)) nums)))\\n         (- min-len 1))))\\n\\n(define (sublist lst from to)\\n  (drop (take lst to) from))\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3447413,
                "title": "c-math-easy-understanding-n-2",
                "content": "shortest subarray having gcd==1\\n```\\nclass Solution {\\npublic:\\n    int gcd(int a,int b){\\n        \\n        int maxi=1;\\n        for(int i=1;i<=min(a,b);i++){\\n            if(a%i==0 && b%i==0){\\n                maxi=max(maxi,i);\\n            }\\n        }\\n        return maxi;\\n    }\\n    int minOperations(vector<int>& nums) {\\n        \\n        bool flag=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i]%2!=0){\\n                flag=1;\\n                break;\\n            }\\n        }\\n        if(flag==0){\\n            return -1;\\n        }\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==1){\\n                count++;\\n            }\\n        }\\n        if(count>=1){\\n            return n-count;\\n        }\\n        flag=0;\\n        for(int i=0;i<n-1;i++){\\n            \\n            if(gcd(nums[i],nums[i+1])==1){\\n                flag=1;\\n                break;\\n            }\\n        }\\n        if(flag==1){\\n            return n;\\n        }\\n        int mini=1e9;\\n        for(int i=0;i<n;i++){\\n            int g=nums[i];\\n            for(int j=i+1;j<n;j++){\\n                g=gcd(g,nums[j]);\\n                if(g==1){\\n                    mini=min(mini,j-i+n-1);\\n                }\\n            }\\n        }\\n        return mini>=1e9? -1:mini;\\n    }\\n};",
                "solutionTags": [
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    int gcd(int a,int b){\\n        \\n        int maxi=1;\\n        for(int i=1;i<=min(a,b);i++){\\n            if(a%i==0 && b%i==0){\\n                maxi=max(maxi,i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3446670,
                "title": "simple-easy-to-understand-solution-with-explanation-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCase 1: If GCD of all the numbers in the array is greater than 1 then it is impossible to make elements equal to 1.\\nCalculate gcdValue by taking GCD of all numbers. \\nIf gcdValue > 1 then return -1.\\n\\nCase 2: If we have atleast one 1 value in the array then using this values we can make the entire array to 1 as GCD(a, 1) = 1.\\nif we have x number of ones in the array then we can make the array to 1 in N-x operations where N is the number of elements in the array.\\n\\nCase 3: If don\\'t have any 1 in the array then we will find the subarray with minimum no. of elements which will give the GCD as 1. Now that subarray will take j-i operations to make one integer in the array as 1. Once we have 1 in the array we can make the remaining array to 1 in N-1 operations. So our total no. of operations will be (j-i) + (N-1).\\n\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int gcd(int A, int B) {\\n        if(B == 0) {\\n            return A;\\n        }\\n        return gcd(B, A%B);\\n    }\\n    public int minOperations(int[] nums) {\\n        // Intuition - \\n        // Case 1: If GCD of all the numbers in the array is greater than 1 then it is impossible to make elements equal to 1.\\n        // Calculate gcdValue by taking GCD of all numbers. \\n        // If gcdValue > 1 then return -1.\\n\\n        // Case 2: If we have atleast one 1 value in the array then using this values we can make the entire array to 1 as GCD(a, 1) = 1.\\n        // if we have x number of ones in the array then we can make the array to 1 in N-x operations where N is the number of elements in the array.\\n\\n        // Case 3: If don\\'t have any 1 in the array then we will find the subarray with minimum no. of elements which will give the GCD as 1. Now that subarray will take j-i operations to make one integer in the array as 1. Once we have 1 in the array we can make the remaining array to 1 in N-1 operations. So our total no. of operations will be (j-i) + (N-1).\\n\\n\\n        // Time Complexity = O(N^2)\\n        // Space Complexity = O(1)\\n\\n\\n        int N = nums.length;\\n        int gcdValue = nums[0];\\n        int ones = 0;\\n        if(gcdValue == 1) {\\n            ones++;\\n        } \\n        for(int i = 1; i < N; i++) {\\n            if(nums[i] == 1) {\\n                ones++;\\n            }\\n            if(gcdValue > 1) {\\n                gcdValue = gcd(gcdValue, nums[i]);\\n            }\\n        }\\n        if(gcdValue > 1) {\\n            return -1;\\n        }\\n        if(ones > 0) {\\n            return N - ones;\\n        }\\n        int ans = Integer.MAX_VALUE;\\n        for(int i = 0; i < N; i++) {\\n            int value = nums[i];\\n            for(int j = i+1; j < N; j++) {\\n                value = gcd(value, nums[j]);\\n                if(value == 1) {\\n                    ans = Math.min(ans, (j-i) + (N-1));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int gcd(int A, int B) {\\n        if(B == 0) {\\n            return A;\\n        }\\n        return gcd(B, A%B);\\n    }\\n    public int minOperations(int[] nums) {\\n        // Intuition - \\n        // Case 1: If GCD of all the numbers in the array is greater than 1 then it is impossible to make elements equal to 1.\\n        // Calculate gcdValue by taking GCD of all numbers. \\n        // If gcdValue > 1 then return -1.\\n\\n        // Case 2: If we have atleast one 1 value in the array then using this values we can make the entire array to 1 as GCD(a, 1) = 1.\\n        // if we have x number of ones in the array then we can make the array to 1 in N-x operations where N is the number of elements in the array.\\n\\n        // Case 3: If don\\'t have any 1 in the array then we will find the subarray with minimum no. of elements which will give the GCD as 1. Now that subarray will take j-i operations to make one integer in the array as 1. Once we have 1 in the array we can make the remaining array to 1 in N-1 operations. So our total no. of operations will be (j-i) + (N-1).\\n\\n\\n        // Time Complexity = O(N^2)\\n        // Space Complexity = O(1)\\n\\n\\n        int N = nums.length;\\n        int gcdValue = nums[0];\\n        int ones = 0;\\n        if(gcdValue == 1) {\\n            ones++;\\n        } \\n        for(int i = 1; i < N; i++) {\\n            if(nums[i] == 1) {\\n                ones++;\\n            }\\n            if(gcdValue > 1) {\\n                gcdValue = gcd(gcdValue, nums[i]);\\n            }\\n        }\\n        if(gcdValue > 1) {\\n            return -1;\\n        }\\n        if(ones > 0) {\\n            return N - ones;\\n        }\\n        int ans = Integer.MAX_VALUE;\\n        for(int i = 0; i < N; i++) {\\n            int value = nums[i];\\n            for(int j = i+1; j < N; j++) {\\n                value = gcd(value, nums[j]);\\n                if(value == 1) {\\n                    ans = Math.min(ans, (j-i) + (N-1));\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446481,
                "title": "easy-simple-solution-c-code-c-c",
                "content": "# Intuition\\nTo find Minimum Number of Operations to Make All Array Elements Equal to 1\\n\\n# Approach\\nFirst find the total  number of 1 in the nums vector. The answer will be size(nums)- number of ones.\\n\\n\\nIf  1 not present then find if there exist a pair of consecutive coprime numbers. The answer in that case will also be size(nums).\\n\\n\\nNow make each element of nums from i=0 to n-2 be nums[i]=gcd(nums[i],nums[i+1]). Do this till it is further not possible or a 1 is found in the nums vector. Count the number of times this operation is performed. At the end if 1 is found then the answer will be        size(nums)-1+count(number of operations).\\n\\nOtherwise the final answer will be -1.\\n# Code\\n```\\nclass Solution {\\npublic:   \\n    int minOperations(vector<int>& nums) {\\n        int prime=0;\\n        int n=nums.size();\\n        map<int,int> mpp;\\n        for(int i=0;i<n;i++)\\n        {\\n            mpp[nums[i]]++;\\n        }\\n        if(mpp[1]==n)\\n        {\\n            return 0;\\n        }\\n        if(mpp[1]>0)\\n        {\\n            return (n-mpp[1]);\\n        }\\n        int p=0;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(__gcd(nums[i],nums[i+1])==1)\\n            {   \\n                p++;\\n            }\\n        }\\n        if(p>0)\\n        {\\n            return n;\\n        }\\n        \\n        \\n        \\n        \\n        \\n\\n        bool test=true;\\n        int count=0, o=0;\\n        while(test)\\n        {\\n            vector<int> prev=nums;\\n            \\n           \\n            for(int i=0;i<n-1;i++)\\n            {\\n                nums[i]=__gcd(nums[i],nums[i+1]);\\n            }\\n            \\n             o=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(nums[i]==1)\\n                {\\n                    o++;\\n                }\\n            }\\n            \\n            \\n            \\n            if(nums==prev)\\n            {\\n                test=false;\\n                break;\\n            }\\n            count++;\\n            if(o>0)\\n            {\\n                break;\\n            }\\n            prev=nums;\\n        }\\n      \\n        int one=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                one++;\\n            }\\n        }\\n        if(one>0)\\n        return (n-1+count);\\n        \\n         return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:   \\n    int minOperations(vector<int>& nums) {\\n        int prime=0;\\n        int n=nums.size();\\n        map<int,int> mpp;\\n        for(int i=0;i<n;i++)\\n        {\\n            mpp[nums[i]]++;\\n        }\\n        if(mpp[1]==n)\\n        {\\n            return 0;\\n        }\\n        if(mpp[1]>0)\\n        {\\n            return (n-mpp[1]);\\n        }\\n        int p=0;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(__gcd(nums[i],nums[i+1])==1)\\n            {   \\n                p++;\\n            }\\n        }\\n        if(p>0)\\n        {\\n            return n;\\n        }\\n        \\n        \\n        \\n        \\n        \\n\\n        bool test=true;\\n        int count=0, o=0;\\n        while(test)\\n        {\\n            vector<int> prev=nums;\\n            \\n           \\n            for(int i=0;i<n-1;i++)\\n            {\\n                nums[i]=__gcd(nums[i],nums[i+1]);\\n            }\\n            \\n             o=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(nums[i]==1)\\n                {\\n                    o++;\\n                }\\n            }\\n            \\n            \\n            \\n            if(nums==prev)\\n            {\\n                test=false;\\n                break;\\n            }\\n            count++;\\n            if(o>0)\\n            {\\n                break;\\n            }\\n            prev=nums;\\n        }\\n      \\n        int one=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                one++;\\n            }\\n        }\\n        if(one>0)\\n        return (n-1+count);\\n        \\n         return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446384,
                "title": "tricky-math-solution-could-not-able-to-solve-in-contest-but-able-to-solve-in-15mins-after-the-conte",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWith my experience I can say that GCD problems are bit complicated but after getting the logic it is pretty straight forward. Try to solve it with cool mind.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn these problem we have 2 scenarious.\\n- Answer is -1\\n    - We should perform gcd for all n elements. If the gcd>1 then we can say that we can\\'t make all elements to 1. so the answer would be -1.\\n- Answer exists\\n    - For each pair, we calculate the greatest common divisor (GCD) of the pair using the __gcd function, which is a built-in function in C++ that calculates the GCD of two integers. It continues to calculate the GCD of the pair with the previous elements until the GCD is equal to 1. When the GCD becomes 1, the function records the length of the subarray between the two elements as the current answer, and then breaks out of the loop.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& v) {\\n        int n=v.size();\\n        int f=0,c=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(v[i]==1)\\n                f=1;\\n            if(v[i]!=1)\\n                c++;\\n        }\\n        if(f==1)\\n            return c;\\n        int ans=500;\\n        for(int i=1;i<n;i++)\\n        {\\n            int j=i-1,g=v[i];\\n            while(j>=0)\\n            {\\n                g=__gcd(g,v[j]);\\n                if(g==1)\\n                {\\n                    ans=min(ans,i-j);\\n                    break;\\n                }\\n                j--;\\n            }\\n        }\\n        if(ans==500)\\n            return -1;\\n        return n+ans-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& v) {\\n        int n=v.size();\\n        int f=0,c=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(v[i]==1)\\n                f=1;\\n            if(v[i]!=1)\\n                c++;\\n        }\\n        if(f==1)\\n            return c;\\n        int ans=500;\\n        for(int i=1;i<n;i++)\\n        {\\n            int j=i-1,g=v[i];\\n            while(j>=0)\\n            {\\n                g=__gcd(g,v[j]);\\n                if(g==1)\\n                {\\n                    ans=min(ans,i-j);\\n                    break;\\n                }\\n                j--;\\n            }\\n        }\\n        if(ans==500)\\n            return -1;\\n        return n+ans-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446378,
                "title": "easy-c-solution-in-three-cases",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**First Case**: If number of ones in array is non-zero than answer will (arr.size()-count of ones).\\n**Second Case**: As length of array is small. Then travel all subarray and find if gcd of that subarray is one. If its gcd is one then you can make any one element of that subarray as one in (subarray.size()-1) steps by taking repetative gcd with  any one single element. And take minimum sized subarray. Now with that element as one you can make other element as one in (array.size()-1) steps. So final answer will be((MinimumSizedSubarray.size()-1)+(array.size()-1)). \\n**Third Case**: if you cannot find any subarray with gcd equals one then return -1;\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n         int n=nums.size(),ans=INT_MAX,cnt=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==1){\\n                cnt++;\\n            }\\n     int gc=0;\\n        for(int j=i;j<n;j++){\\n            gc=__gcd(gc,nums[j]);\\n        \\n            if(gc==1){\\n                ans=min(ans,j-i+1);\\n            }\\n        }\\n        }\\n        if(cnt>0){\\n            return n-cnt;\\n        }\\n        if(ans==INT_MAX){\\n            return -1;\\n        }\\n        long long int res=n+ans-2;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n         int n=nums.size(),ans=INT_MAX,cnt=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==1){\\n                cnt++;\\n            }\\n     int gc=0;\\n        for(int j=i;j<n;j++){\\n            gc=__gcd(gc,nums[j]);\\n        \\n            if(gc==1){\\n                ans=min(ans,j-i+1);\\n            }\\n        }\\n        }\\n        if(cnt>0){\\n            return n-cnt;\\n        }\\n        if(ans==INT_MAX){\\n            return -1;\\n        }\\n        long long int res=n+ans-2;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446339,
                "title": "simple-c-solution-intutive",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        int cnt = count(nums.begin(),nums.end(),1);\\n        if(cnt != 0) return n - cnt;\\n\\n        int res = INT_MAX;\\n        for(int i=0; i<nums.size(); i++){\\n            int x = nums[i];\\n            for(int j= i+1; j<nums.size(); j++){\\n                x = __gcd(x,nums[j]);\\n                if(x == 1){\\n                    res = min(res,(j-i)+(n-1)); // Min steps req to make GCD of this subarray 1 + (n-1) steps to make the remaining elment equals to 1.\\n                }\\n            }\\n        }\\n\\n        return res == INT_MAX ? -1 : res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        int cnt = count(nums.begin(),nums.end(),1);\\n        if(cnt != 0) return n - cnt;\\n\\n        int res = INT_MAX;\\n        for(int i=0; i<nums.size(); i++){\\n            int x = nums[i];\\n            for(int j= i+1; j<nums.size(); j++){\\n                x = __gcd(x,nums[j]);\\n                if(x == 1){\\n                    res = min(res,(j-i)+(n-1)); // Min steps req to make GCD of this subarray 1 + (n-1) steps to make the remaining elment equals to 1.\\n                }\\n            }\\n        }\\n\\n        return res == INT_MAX ? -1 : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446315,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n * n)\\n * Space Complexity: O(1)\\n * where `n` is the length of the vector `nums`\\n */\\nclass Solution {\\n public:\\n  int minOperations(const vector<int> &nums) {\\n    constexpr int one = 1;\\n    const int n = static_cast<int>(nums.size());\\n    int ones = 0;\\n    int min_length = n + 1;\\n    for (int start = 0; start < n; ++start) {\\n      if (nums[start] == one) {\\n        ++ones;\\n      }\\n      \\n      int g = nums[start];\\n      int end = start + 1;\\n      for (; ones == 0 && end < min(start + min_length, n); ++end) {\\n        g = gcd(g, nums[end]);\\n        if (g == 1) {\\n          break;\\n        }\\n      }\\n      if (g == one) {\\n        min_length = end - start + 1;\\n      }\\n    }\\n    \\n    return min_length == n + 1 ? -1 : (min_length - 1) + (n - 1) - ones;\\n  }\\n  \\n private:\\n  int gcd(const int a, const int b) {\\n    if (a == 0) {\\n      return b;\\n    }\\n    return gcd(b % a, a);\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n * n)\\n * Space Complexity: O(1)\\n * where `n` is the length of the vector `nums`\\n */\\nclass Solution {\\n public:\\n  int minOperations(const vector<int> &nums) {\\n    constexpr int one = 1;\\n    const int n = static_cast<int>(nums.size());\\n    int ones = 0;\\n    int min_length = n + 1;\\n    for (int start = 0; start < n; ++start) {\\n      if (nums[start] == one) {\\n        ++ones;\\n      }\\n      \\n      int g = nums[start];\\n      int end = start + 1;\\n      for (; ones == 0 && end < min(start + min_length, n); ++end) {\\n        g = gcd(g, nums[end]);\\n        if (g == 1) {\\n          break;\\n        }\\n      }\\n      if (g == one) {\\n        min_length = end - start + 1;\\n      }\\n    }\\n    \\n    return min_length == n + 1 ? -1 : (min_length - 1) + (n - 1) - ones;\\n  }\\n  \\n private:\\n  int gcd(const int a, const int b) {\\n    if (a == 0) {\\n      return b;\\n    }\\n    return gcd(b % a, a);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446177,
                "title": "best-clean-c-code-greedy",
                "content": "# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n### PLease Upvote if u liked my Solution\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size(),count=0,count_1=0,x=nums[0],mini=n;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==1)\\n                count_1++;\\n            x=__gcd(x,nums[i]);\\n        }\\n        if(count_1 != 0)\\n            return n - count_1;\\n        if(x != 1)\\n            return -1;\\n        for(int i=0;i<n-1;i++){\\n            x=nums[i];\\n            for(int j=i+1;j<n;j++){\\n                x=__gcd(x,nums[j]);\\n                if(x == 1){\\n                    mini = min(mini,j-i-1);\\n                    break;\\n                }\\n            }\\n        }\\n        return n + mini;\\n    }\\n};\\n```\\n![e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png](https://assets.leetcode.com/users/images/05af26e6-16dc-4493-aaf4-0d1cee2faea2_1682228417.2335925.png)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size(),count=0,count_1=0,x=nums[0],mini=n;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==1)\\n                count_1++;\\n            x=__gcd(x,nums[i]);\\n        }\\n        if(count_1 != 0)\\n            return n - count_1;\\n        if(x != 1)\\n            return -1;\\n        for(int i=0;i<n-1;i++){\\n            x=nums[i];\\n            for(int j=i+1;j<n;j++){\\n                x=__gcd(x,nums[j]);\\n                if(x == 1){\\n                    mini = min(mini,j-i-1);\\n                    break;\\n                }\\n            }\\n        }\\n        return n + mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446131,
                "title": "simple-very-easy-normal-brute-force-solution-gcd-c",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n\\n- Space complexity: $$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int minOperations(vector<int>& nums) {\\n        int n=nums.size();\\n        int ones = 0;\\n        int ans=INT_MAX;\\n\\n        for(int i=0; i<n; i++){\\n            if(nums[i]==1) ones++;\\n        }\\n        if(ones>0) return n-ones;\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=i+1; j<n; j++){\\n                nums[i]= __gcd(nums[i], nums[j]);\\n                if(nums[i]==1){\\n                    ans=min(ans,j-i);\\n                    break;\\n                }\\n            }\\n            if(nums[i]!=1) break;\\n        }\\n\\n        if(ans==INT_MAX) return -1;\\n        return n-1+ans;\\n    }\\n};\\n\\n```\\n\\n# Kindly, it you got the code solution, Do UPVOTE!\\n![upvote.png](https://assets.leetcode.com/users/images/83c566a6-16a0-43b4-8296-a2b2c44dd240_1682227798.0569692.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minOperations(vector<int>& nums) {\\n        int n=nums.size();\\n        int ones = 0;\\n        int ans=INT_MAX;\\n\\n        for(int i=0; i<n; i++){\\n            if(nums[i]==1) ones++;\\n        }\\n        if(ones>0) return n-ones;\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=i+1; j<n; j++){\\n                nums[i]= __gcd(nums[i], nums[j]);\\n                if(nums[i]==1){\\n                    ans=min(ans,j-i);\\n                    break;\\n                }\\n            }\\n            if(nums[i]!=1) break;\\n        }\\n\\n        if(ans==INT_MAX) return -1;\\n        return n-1+ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446130,
                "title": "esay-to-understand-beginer-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int res = 1e7;\\n        int c=count(nums.begin(),nums.end(),1);\\n        if(c!=0){\\n            return n-c;\\n        }\\n        for(int i=0;i<n;i++){\\n            int k=nums[i];\\n            for(int j=i+1;j<n;j++){\\n                k=__gcd(k,nums[j]);\\n                if(k==1){\\n                    res=min(res,j-i+(n-1));\\n                    break;\\n                }\\n            }\\n        \\n        }\\n\\nreturn res==1e7?-1:res;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int res = 1e7;\\n        int c=count(nums.begin(),nums.end(),1);\\n        if(c!=0){\\n            return n-c;\\n        }\\n        for(int i=0;i<n;i++){\\n            int k=nums[i];\\n            for(int j=i+1;j<n;j++){\\n                k=__gcd(k,nums[j]);\\n                if(k==1){\\n                    res=min(res,j-i+(n-1));\\n                    break;\\n                }\\n            }\\n        \\n        }\\n\\nreturn res==1e7?-1:res;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446120,
                "title": "java-gcd-euclid-s-algorithm-easy-and-simple-solution",
                "content": "**Time Complexity : - O(n^2)**\\n**Space Complexity : - O(1)**\\n```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int cntOne = 0;\\n        for (int n : nums) if (n == 1) cntOne++;\\n        if (cntOne != 0) return nums.length - cntOne;\\n        int res = Integer.MAX_VALUE;\\n        for (int i = 0; i < nums.length; i++) {\\n            int num = nums[i];\\n            for (int j = i + 1; j < nums.length; j++) {\\n                num = gcd(num, nums[j]);\\n                if (num == 1) {\\n                    res = Math.min(res, (j-i+(nums.length-1)));\\n                    break;\\n                }\\n            }\\n        }\\n        return res == Integer.MAX_VALUE ? -1 : res;\\n    }\\n\\t\\n\\t// Euclidean algorithm to Find GCD of two number \\n    private int gcd(int n1, int n2) {\\n        while (n2 != 0) {\\n            int m = n1 % n2;\\n            n1 = n2;\\n            n2 = m;\\n        }\\n        return n1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int cntOne = 0;\\n        for (int n : nums) if (n == 1) cntOne++;\\n        if (cntOne != 0) return nums.length - cntOne;\\n        int res = Integer.MAX_VALUE;\\n        for (int i = 0; i < nums.length; i++) {\\n            int num = nums[i];\\n            for (int j = i + 1; j < nums.length; j++) {\\n                num = gcd(num, nums[j]);\\n                if (num == 1) {\\n                    res = Math.min(res, (j-i+(nums.length-1)));\\n                    break;\\n                }\\n            }\\n        }\\n        return res == Integer.MAX_VALUE ? -1 : res;\\n    }\\n\\t\\n\\t// Euclidean algorithm to Find GCD of two number \\n    private int gcd(int n1, int n2) {\\n        while (n2 != 0) {\\n            int m = n1 % n2;\\n            n1 = n2;\\n            n2 = m;\\n        }\\n        return n1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446100,
                "title": "easy-to-understand-c-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int countOnes = count(nums.begin(), nums.end(), 1);  \\n        if(countOnes != 0) return n - countOnes;\\n        int res = INT_MAX;     \\n        for(int i = 0; i < n; i++){\\n            int totalGcdValue = nums[i];\\n            for(int j = i + 1; j < n; j++){\\n                totalGcdValue = __gcd(totalGcdValue, nums[j]);\\n                if(totalGcdValue == 1){\\n                    res = min(res, j - i + (n-1)); \\n                    break;\\n                } \\n            }\\n        }\\n        return res == INT_MAX ? -1 : res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int countOnes = count(nums.begin(), nums.end(), 1);  \\n        if(countOnes != 0) return n - countOnes;\\n        int res = INT_MAX;     \\n        for(int i = 0; i < n; i++){\\n            int totalGcdValue = nums[i];\\n            for(int j = i + 1; j < n; j++){\\n                totalGcdValue = __gcd(totalGcdValue, nums[j]);\\n                if(totalGcdValue == 1){\\n                    res = min(res, j - i + (n-1)); \\n                    break;\\n                } \\n            }\\n        }\\n        return res == INT_MAX ? -1 : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446094,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        ones=nums.count(1)\\n        if ones:\\n            return n-ones\\n        diff=inf\\n        for i in range(n):\\n            g=nums[i] \\n\\n            for j in range(i+1,n):\\n                g=gcd(g,nums[j])\\n                if g==1:\\n                    diff=min(diff,j-i)\\n\\n\\n        return -1 if diff==inf else  diff+n-1                     \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        ones=nums.count(1)\\n        if ones:\\n            return n-ones\\n        diff=inf\\n        for i in range(n):\\n            g=nums[i] \\n\\n            for j in range(i+1,n):\\n                g=gcd(g,nums[j])\\n                if g==1:\\n                    diff=min(diff,j-i)\\n\\n\\n        return -1 if diff==inf else  diff+n-1                     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446091,
                "title": "find-the-smallest-subarray-with-gcd-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        \\n        int count = 0;\\n        int gcdd = 1;\\n        int n = nums.size();\\n        int countone = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] == 1){\\n                countone++;\\n            }\\n        }\\n        // find the samllest subarray with gcd = 1\\n        int len = 1e9;\\n        if(countone>0)return  n - countone;\\n        for(int i = 0;i<nums.size();i++){\\n            int val = nums[i];\\n            for(int j = i+1;j<nums.size();j++){\\n                val = __gcd(val,nums[j]);\\n                if(val == 1){\\n                    len = min(len,(j-i));\\n                }\\n            }\\n        }\\n        if(len == 1e9)return -1;\\n        return nums.size() + len -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        \\n        int count = 0;\\n        int gcdd = 1;\\n        int n = nums.size();\\n        int countone = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] == 1){\\n                countone++;\\n            }\\n        }\\n        // find the samllest subarray with gcd = 1\\n        int len = 1e9;\\n        if(countone>0)return  n - countone;\\n        for(int i = 0;i<nums.size();i++){\\n            int val = nums[i];\\n            for(int j = i+1;j<nums.size();j++){\\n                val = __gcd(val,nums[j]);\\n                if(val == 1){\\n                    len = min(len,(j-i));\\n                }\\n            }\\n        }\\n        if(len == 1e9)return -1;\\n        return nums.size() + len -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446081,
                "title": "gcd-java-find-smallest-way-to-compute-first-1",
                "content": "```\\nclass Solution {\\n\\n    int getgcd(int a, int b) {\\n        int soln = 1;\\n\\n        for (int i = 1; i <= a && i <= b; ++i) {\\n            if (a % i == 0 && b % i == 0) soln = i;\\n        }\\n        return soln;\\n    }\\n\\n    public boolean computeGCD(int[] nums, int i, int j) {\\n        int t = nums[i];\\n        for (int itr = i + 1; itr <= j; itr++) {\\n            t = getgcd(t, nums[itr]);\\n            if (t == 1) return true;\\n        }\\n        return false;\\n    }\\n\\n    public int minOperations(int[] nums) {\\n        int onecount = 0;\\n        for (int i : nums) if (i == 1) onecount++;\\n        if (onecount != 0) return nums.length - onecount;\\n        int min = Integer.MAX_VALUE;\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = i + 1; j < nums.length; j++) {\\n                if (computeGCD(nums, i, j)) {\\n                    min = Math.min(min, j - i - 1 + nums.length);\\n                    break;\\n                }\\n            }\\n        }\\n        return min == Integer.MAX_VALUE ? -1 : min;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    int getgcd(int a, int b) {\\n        int soln = 1;\\n\\n        for (int i = 1; i <= a && i <= b; ++i) {\\n            if (a % i == 0 && b % i == 0) soln = i;\\n        }\\n        return soln;\\n    }\\n\\n    public boolean computeGCD(int[] nums, int i, int j) {\\n        int t = nums[i];\\n        for (int itr = i + 1; itr <= j; itr++) {\\n            t = getgcd(t, nums[itr]);\\n            if (t == 1) return true;\\n        }\\n        return false;\\n    }\\n\\n    public int minOperations(int[] nums) {\\n        int onecount = 0;\\n        for (int i : nums) if (i == 1) onecount++;\\n        if (onecount != 0) return nums.length - onecount;\\n        int min = Integer.MAX_VALUE;\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = i + 1; j < nums.length; j++) {\\n                if (computeGCD(nums, i, j)) {\\n                    min = Math.min(min, j - i - 1 + nums.length);\\n                    break;\\n                }\\n            }\\n        }\\n        return min == Integer.MAX_VALUE ? -1 : min;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446017,
                "title": "shortest-sub-array-with-gcd-1",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n ^ 2)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        N = len(nums)\\n\\n        # If there is 1 in the array, return number of non-one directly\\n        ones = nums.count(1)\\n        if ones:\\n            return N - ones\\n        \\n        # Find shortest sub-array with gcd 1\\n        def shortest():\\n            ans = N + 1\\n            for i in range(N):\\n                cur = nums[i]\\n                for j in range(i + 1, N):\\n                    cur = gcd(cur, nums[j])\\n                    if cur == 1:\\n                        ans = min(ans, j - i + 1)\\n            return ans\\n\\n        L = shortest()\\n        return -1 if L == N + 1 else N + L - 2\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        N = len(nums)\\n\\n        # If there is 1 in the array, return number of non-one directly\\n        ones = nums.count(1)\\n        if ones:\\n            return N - ones\\n        \\n        # Find shortest sub-array with gcd 1\\n        def shortest():\\n            ans = N + 1\\n            for i in range(N):\\n                cur = nums[i]\\n                for j in range(i + 1, N):\\n                    cur = gcd(cur, nums[j])\\n                    if cur == 1:\\n                        ans = min(ans, j - i + 1)\\n            return ans\\n\\n        L = shortest()\\n        return -1 if L == N + 1 else N + L - 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446008,
                "title": "gcd",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        \\n        n=len(nums)\\n        ones_count = nums.count(1)\\n\\n        if ones_count: \\n            return len(nums)-ones_count\\n\\n        steps = inf \\n\\n        for i in range(len(nums)): \\n            g = nums[i]\\n            for j in range(i+1, len(nums)):\\n                g = gcd(g, nums[j])\\n                if g == 1: \\n                    steps = min(steps, j-i)\\n\\n        return -1 if steps == inf else steps + n - 1\\n                \\n\\n\\n        \\n        \\n        \\n        \\n        \\n    \\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        \\n        n=len(nums)\\n        ones_count = nums.count(1)\\n\\n        if ones_count: \\n            return len(nums)-ones_count\\n\\n        steps = inf \\n\\n        for i in range(len(nums)): \\n            g = nums[i]\\n            for j in range(i+1, len(nums)):\\n                g = gcd(g, nums[j])\\n                if g == 1: \\n                    steps = min(steps, j-i)\\n\\n        return -1 if steps == inf else steps + n - 1\\n                \\n\\n\\n        \\n        \\n        \\n        \\n        \\n    \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445960,
                "title": "gcd-of-multiple-numbers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo find gcd of multiple numbers\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncall gcd n-1 times to find gcd of n numbers\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nn^3 log(m)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nn\\n\\n# Code\\n```\\nclass Solution:\\n    def gcd(self, a, b):\\n        if b > a:\\n            a, b = b, a\\n        assert a >= b\\n        if b == 0:\\n            return a\\n        return self.gcd(b, a%b)\\n    \\n    def possible(self, stt, end):\\n        if stt == end:\\n            return self.nums[stt] == 1\\n        cur = self.nums[stt]\\n        for i in range(stt+1, end+1):\\n            cur = self.gcd(cur, self.nums[i])\\n        return cur == 1\\n    \\n    def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        self.nums = nums\\n        c1 = 0\\n        for v in nums:\\n            if v == 1:\\n                c1 += 1\\n        if c1 > 0:\\n            return n-c1\\n        for m in range(2, n+1):\\n            for i in range(n-m+1):\\n                if self.possible(i, i+m-1):\\n                    return n-1 + (m-1)\\n        return -1\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def gcd(self, a, b):\\n        if b > a:\\n            a, b = b, a\\n        assert a >= b\\n        if b == 0:\\n            return a\\n        return self.gcd(b, a%b)\\n    \\n    def possible(self, stt, end):\\n        if stt == end:\\n            return self.nums[stt] == 1\\n        cur = self.nums[stt]\\n        for i in range(stt+1, end+1):\\n            cur = self.gcd(cur, self.nums[i])\\n        return cur == 1\\n    \\n    def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        self.nums = nums\\n        c1 = 0\\n        for v in nums:\\n            if v == 1:\\n                c1 += 1\\n        if c1 > 0:\\n            return n-c1\\n        for m in range(2, n+1):\\n            for i in range(n-m+1):\\n                if self.possible(i, i+m-1):\\n                    return n-1 + (m-1)\\n        return -1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445957,
                "title": "gcd-of-multiple-numbers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo find gcd of multiple numbers\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncall gcd n-1 times to find gcd of n numbers\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nn^3 log(m)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nn\\n\\n# Code\\n```\\nclass Solution:\\n    def gcd(self, a, b):\\n        if b > a:\\n            a, b = b, a\\n        assert a >= b\\n        if b == 0:\\n            return a\\n        return self.gcd(b, a%b)\\n    \\n    def possible(self, stt, end):\\n        if stt == end:\\n            return self.nums[stt] == 1\\n        cur = self.nums[stt]\\n        for i in range(stt+1, end+1):\\n            cur = self.gcd(cur, self.nums[i])\\n        return cur == 1\\n    \\n    def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        self.nums = nums\\n        c1 = 0\\n        for v in nums:\\n            if v == 1:\\n                c1 += 1\\n        if c1 > 0:\\n            return n-c1\\n        for m in range(2, n+1):\\n            for i in range(n-m+1):\\n                if self.possible(i, i+m-1):\\n                    return n-1 + (m-1)\\n        return -1\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def gcd(self, a, b):\\n        if b > a:\\n            a, b = b, a\\n        assert a >= b\\n        if b == 0:\\n            return a\\n        return self.gcd(b, a%b)\\n    \\n    def possible(self, stt, end):\\n        if stt == end:\\n            return self.nums[stt] == 1\\n        cur = self.nums[stt]\\n        for i in range(stt+1, end+1):\\n            cur = self.gcd(cur, self.nums[i])\\n        return cur == 1\\n    \\n    def minOperations(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        self.nums = nums\\n        c1 = 0\\n        for v in nums:\\n            if v == 1:\\n                c1 += 1\\n        if c1 > 0:\\n            return n-c1\\n        for m in range(2, n+1):\\n            for i in range(n-m+1):\\n                if self.possible(i, i+m-1):\\n                    return n-1 + (m-1)\\n        return -1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445941,
                "title": "c-java-brute-force-intuitive",
                "content": "## Explanation\\nCount the number of 1\\'s present in the array. If there are any 1\\'s present in the array, we can directly return the count of all elements except 1\\'s, as we can spread the 1\\'s by with the GCD operation. \\n\\nIf no 1\\'s are present , then a brute force approach is to iterate over all elements for each element and find the GCD of a subarray. If it equals to 1, then it means that we can convert it to 1 in `j - i` (length of subarray) steps.\\n\\nFind the minimum length of such subarray and return `n - minLength + 1`. If no subarray with GCD of 1 is found, return -1. \\n\\n## Code\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int ones = 0, n = size(nums);\\n        for(int &val:nums) if(val==1) ones++;\\n        if(ones) return n - ones;\\n        else{\\n            int ans = 1e8;\\n            for(int i = 0; i < n; i++){\\n                int curr = nums[i];\\n                for(int j = i+1; j < n; j++){\\n                    curr = __gcd(curr, nums[j]);\\n                    if(curr == 1) {\\n                        ans = min(ans, j-i);\\n                        break;\\n                    }\\n                }\\n                if(curr != 1) break;\\n            }\\n            return ans==1e8?-1:(n+ans-1);\\n        }\\n        return 0;\\n    }\\n};\\n```\\n```Java []\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int ones = 0, n = nums.length;\\n        for(int val : nums) {\\n            if(val == 1) {\\n                ones++;\\n            }\\n        }\\n        if(ones != 0) {\\n            return n - ones;\\n        }\\n        else {\\n            int ans = 100000000;\\n            for(int i = 0; i < n; i++) {\\n                int curr = nums[i];\\n                for(int j = i + 1; j < n; j++) {\\n                    curr = gcd(curr, nums[j]);\\n                    if(curr == 1) {\\n                        ans = Math.min(ans, j - i);\\n                        break;\\n                    }\\n                }\\n                if(curr != 1) {\\n                    break;\\n                }\\n            }\\n            return ans == 100000000 ? -1 : (n + ans - 1);\\n        }\\n    }\\n\\n    private int gcd(int a, int b) {\\n        if(b == 0) {\\n            return a;\\n        }\\n        return gcd(b, a % b);\\n    }\\n}\\n```\\n\\n## Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Greedy"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int ones = 0, n = size(nums);\\n        for(int &val:nums) if(val==1) ones++;\\n        if(ones) return n - ones;\\n        else{\\n            int ans = 1e8;\\n            for(int i = 0; i < n; i++){\\n                int curr = nums[i];\\n                for(int j = i+1; j < n; j++){\\n                    curr = __gcd(curr, nums[j]);\\n                    if(curr == 1) {\\n                        ans = min(ans, j-i);\\n                        break;\\n                    }\\n                }\\n                if(curr != 1) break;\\n            }\\n            return ans==1e8?-1:(n+ans-1);\\n        }\\n        return 0;\\n    }\\n};\\n```\n```Java []\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int ones = 0, n = nums.length;\\n        for(int val : nums) {\\n            if(val == 1) {\\n                ones++;\\n            }\\n        }\\n        if(ones != 0) {\\n            return n - ones;\\n        }\\n        else {\\n            int ans = 100000000;\\n            for(int i = 0; i < n; i++) {\\n                int curr = nums[i];\\n                for(int j = i + 1; j < n; j++) {\\n                    curr = gcd(curr, nums[j]);\\n                    if(curr == 1) {\\n                        ans = Math.min(ans, j - i);\\n                        break;\\n                    }\\n                }\\n                if(curr != 1) {\\n                    break;\\n                }\\n            }\\n            return ans == 100000000 ? -1 : (n + ans - 1);\\n        }\\n    }\\n\\n    private int gcd(int a, int b) {\\n        if(b == 0) {\\n            return a;\\n        }\\n        return gcd(b, a % b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445937,
                "title": "easiest-c-logic",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int minOperations(vector<int>& nums) {\\n       int nonOnes = 0 ;\\n        for(auto x:nums){\\n            if(x!=1) nonOnes++ ;\\n        }    \\n        \\n        if(nonOnes==0) return 0;\\n        \\n        // atleast 1 is present \\n        if(nonOnes!=nums.size()) return nonOnes ;\\n        \\n        int howFast = 1e9 ;\\n        // how fast can I create a one \\n        for(int i=0; i<nums.size()-1; i++)\\n        {\\n            int step = 1 ;\\n            int gcd=__gcd(nums[i],nums[i+1]) ;\\n            for(int j=i+2; j<nums.size(); j++){\\n                if(gcd==1) break ;\\n                gcd=__gcd(gcd,nums[j]) ;\\n                step++;\\n            }\\n            if(gcd==1){\\n                howFast =  min(howFast,step) ;\\n            }\\n        }\\n        \\n        \\n        if(howFast==1e9) return -1; \\n        \\n        return howFast+nums.size()-1; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minOperations(vector<int>& nums) {\\n       int nonOnes = 0 ;\\n        for(auto x:nums){\\n            if(x!=1) nonOnes++ ;\\n        }    \\n        \\n        if(nonOnes==0) return 0;\\n        \\n        // atleast 1 is present \\n        if(nonOnes!=nums.size()) return nonOnes ;\\n        \\n        int howFast = 1e9 ;\\n        // how fast can I create a one \\n        for(int i=0; i<nums.size()-1; i++)\\n        {\\n            int step = 1 ;\\n            int gcd=__gcd(nums[i],nums[i+1]) ;\\n            for(int j=i+2; j<nums.size(); j++){\\n                if(gcd==1) break ;\\n                gcd=__gcd(gcd,nums[j]) ;\\n                step++;\\n            }\\n            if(gcd==1){\\n                howFast =  min(howFast,step) ;\\n            }\\n        }\\n        \\n        \\n        if(howFast==1e9) return -1; \\n        \\n        return howFast+nums.size()-1; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445932,
                "title": "c-intuitive-simple-approach-explained",
                "content": "# Intuition\\nAs soon as we will have a 1 in the array the whole array can be converted to ones by a single operation for each element.\\n\\n# Approach\\nInitially check if there are any ones in the array. If yes, then simply return the count of non-one values in the array.\\n\\nOtherwise:\\nKeep on checking if all the elements in the array are equal or not and if all elements are equal and not equal to 1 then its impossible to convert the array to all ones.\\n\\nFind the minimum number of operations to convert any element to one. As we are using adjacent elements we can keep on traversing the given array and save the gcd of them in the same array as the previous values don\\'t matter anymore.\\n\\nAs we have the minimum number of operations to convert a single element to one. Now, the minimum number of operations to convert the whole array to ones is the number of non-one values in the array i.e. n - 1.\\n\\n# Complexity\\n- Time complexity: O(M * N) where M denotes number of operations to convert an element to 1 (0 < M < N)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int N = nums.size();\\n\\n        // initial check for ones\\n        int c1 = 0;\\n        for(int i = 0; i < N; i++) {\\n            if(nums[i] == 1)\\n                c1++;\\n        }\\n        if(c1)\\n            return N - c1;\\n        \\n        int n = nums.size();\\n        int ans = 0;\\n        bool found1 = false;\\n        while(!found1 && n > 0) {\\n            // checking if we have a 1 in the modified array\\n            for(int i = 0; i < n; i++) {\\n                if(nums[i] == 1)\\n                    found1 = true;\\n            }\\n            // ans contains the minimum number of operations to get first 1\\n            // this 1 will be used to convert every other element to 1\\n            if(found1)\\n                ans += N - 1;\\n            else {\\n                // searching for first 1\\n                ans++;\\n                int equalC = 0;\\n                for(int i = 0; i < n - 1; i++) {\\n                    if(nums[i] == nums[i + 1])\\n                        equalC++;\\n                }\\n                // if all elements are equal and are not 1\\n                // its impossible to convert the array\\n                if(nums[0] != 1 && equalC + 1 == n)\\n                    return -1;\\n                // next array\\n                for(int i = 0; i < n - 1; i++)\\n                    nums[i] = __gcd(nums[i], nums[i + 1]);\\n                n--;\\n            }\\n        }\\n        if(n == 0)\\n            return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int N = nums.size();\\n\\n        // initial check for ones\\n        int c1 = 0;\\n        for(int i = 0; i < N; i++) {\\n            if(nums[i] == 1)\\n                c1++;\\n        }\\n        if(c1)\\n            return N - c1;\\n        \\n        int n = nums.size();\\n        int ans = 0;\\n        bool found1 = false;\\n        while(!found1 && n > 0) {\\n            // checking if we have a 1 in the modified array\\n            for(int i = 0; i < n; i++) {\\n                if(nums[i] == 1)\\n                    found1 = true;\\n            }\\n            // ans contains the minimum number of operations to get first 1\\n            // this 1 will be used to convert every other element to 1\\n            if(found1)\\n                ans += N - 1;\\n            else {\\n                // searching for first 1\\n                ans++;\\n                int equalC = 0;\\n                for(int i = 0; i < n - 1; i++) {\\n                    if(nums[i] == nums[i + 1])\\n                        equalC++;\\n                }\\n                // if all elements are equal and are not 1\\n                // its impossible to convert the array\\n                if(nums[0] != 1 && equalC + 1 == n)\\n                    return -1;\\n                // next array\\n                for(int i = 0; i < n - 1; i++)\\n                    nums[i] = __gcd(nums[i], nums[i + 1]);\\n                n--;\\n            }\\n        }\\n        if(n == 0)\\n            return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445902,
                "title": "beginner-solution-easy-beats-100",
                "content": "# Complexity\\n- Time complexity:\\nO(n*n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int minOperations(vector<int>& nums) \\n    {\\n        int ans=INT_MAX;\\n        int jat = 0;\\n        for(int i=0; i<nums.size(); i++) \\n        {\\n            if(nums[i] == 1) \\n            {\\n                jat++;\\n            }\\n        }\\n        \\n        if(jat > 0) return nums.size() - jat;\\n        \\n        for(int i=0; i<nums.size(); i++) \\n        {\\n            int num1 = nums[i];\\n            for(int j=i+1; j<nums.size(); j++) \\n            {\\n                num1 = __gcd(num1, nums[j]);\\n                if(num1 == 1) {\\n                    ans = min(ans, j-i);\\n                    break;\\n                }\\n            }\\n        }\\n        if(ans == INT_MAX) return -1;\\n        return nums.size()-1+ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minOperations(vector<int>& nums) \\n    {\\n        int ans=INT_MAX;\\n        int jat = 0;\\n        for(int i=0; i<nums.size(); i++) \\n        {\\n            if(nums[i] == 1) \\n            {\\n                jat++;\\n            }\\n        }\\n        \\n        if(jat > 0) return nums.size() - jat;\\n        \\n        for(int i=0; i<nums.size(); i++) \\n        {\\n            int num1 = nums[i];\\n            for(int j=i+1; j<nums.size(); j++) \\n            {\\n                num1 = __gcd(num1, nums[j]);\\n                if(num1 == 1) {\\n                    ans = min(ans, j-i);\\n                    break;\\n                }\\n            }\\n        }\\n        if(ans == INT_MAX) return -1;\\n        return nums.size()-1+ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445889,
                "title": "javascript-with-explaination",
                "content": "run an iteration though the array and update all gcd value.\\nif it cannot be one then no matter how many time we do gcd the arrray will be the same.\\ndo gcd on all elements and increase operations by 1.\\nif the values changed then run again. if they dont change and dont have a 1 it means its not possible.\\n\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minOperations = function(nums) {\\n        let n=nums.length;\\n    let possible=false;\\n    let onePresent=false;\\n    var ans=0;\\n    var count=0;\\n    for(let i=0;i<nums.length;i++){\\n        if(nums[i]==1)count++;\\n    }\\n    if(count>0)return n-count;\\n    const gcd=(a,b)=>{\\n        while(b!=0){\\n            r=a%b;\\n            a=b;\\n            b=r;\\n        }\\n        return a;\\n    }\\n    oldArray=[...nums];\\n    var changed=true;\\n    while(changed==true){\\n        changed=false;\\n        for(let i=0;i<n-1;i++){\\n       nums[i]=gcd(nums[i],nums[i+1]);    \\n    } \\n         for(let i=0;i<n-1;i++){\\n       if(nums[i]==1){\\n           return ans+nums.length;\\n       }\\n    }\\n        for(let i=0;i<n;i++){\\n            if(nums[i]!=oldArray[i]){\\n                changed=true;\\n                ans++;\\n                break;\\n            }\\n        }\\n        oldArray=[...nums]\\n    }\\n\\n\\n    return -1;  \\n\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minOperations = function(nums) {\\n        let n=nums.length;\\n    let possible=false;\\n    let onePresent=false;\\n    var ans=0;\\n    var count=0;\\n    for(let i=0;i<nums.length;i++){\\n        if(nums[i]==1)count++;\\n    }\\n    if(count>0)return n-count;\\n    const gcd=(a,b)=>{\\n        while(b!=0){\\n            r=a%b;\\n            a=b;\\n            b=r;\\n        }\\n        return a;\\n    }\\n    oldArray=[...nums];\\n    var changed=true;\\n    while(changed==true){\\n        changed=false;\\n        for(let i=0;i<n-1;i++){\\n       nums[i]=gcd(nums[i],nums[i+1]);    \\n    } \\n         for(let i=0;i<n-1;i++){\\n       if(nums[i]==1){\\n           return ans+nums.length;\\n       }\\n    }\\n        for(let i=0;i<n;i++){\\n            if(nums[i]!=oldArray[i]){\\n                changed=true;\\n                ans++;\\n                break;\\n            }\\n        }\\n        oldArray=[...nums]\\n    }\\n\\n\\n    return -1;  \\n\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3445859,
                "title": "c-9-liners-solution",
                "content": "```\\nint minOperations(vector<int>& nums) \\n{\\n\\tint n=nums.size(),c=nums[0],ones=nums[0]==1;\\n\\tfor(int i=1;i<n;i++) c=__gcd(c,nums[i]),ones+=nums[i]==1;\\n\\tif(c!=1) return -1;\\n\\twhile(true)\\n\\t{\\n\\t\\tfor(int i=0;i<n-1;i++)\\n\\t\\t{\\n\\t\\t\\tnums[i]=__gcd(nums[i],nums[i+1]);\\n\\t\\t\\tif(nums[i]==1) return 2*nums.size()-n-ones;\\n\\t\\t}\\n\\t\\tn--;\\n\\t}\\n\\treturn -1;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint minOperations(vector<int>& nums) \\n{\\n\\tint n=nums.size(),c=nums[0],ones=nums[0]==1;\\n\\tfor(int i=1;i<n;i++) c=__gcd(c,nums[i]),ones+=nums[i]==1;\\n\\tif(c!=1) return -1;\\n\\twhile(true)\\n\\t{\\n\\t\\tfor(int i=0;i<n-1;i++)\\n\\t\\t{\\n\\t\\t\\tnums[i]=__gcd(nums[i],nums[i+1]);\\n\\t\\t\\tif(nums[i]==1) return 2*nums.size()-n-ones;\\n\\t\\t}\\n\\t\\tn--;\\n\\t}\\n\\treturn -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3445857,
                "title": "c-simple-easy-intuitive-solution-youtube-solution",
                "content": "Do Checkhttps://youtu.be/mmi8OHGLFyA\\n```\\nclass Solution {\\npublic:\\n    \\n    int minOperations(vector<int>& nums) {\\n        int gcd  = nums[0];\\n        int cnt =0;\\n        int p = gcd;\\n        int f=1;\\n        for(auto c:nums){\\n            gcd = __gcd(c,gcd);\\n            if(c>1) cnt++;\\n            int r = __gcd(p,c);\\n            if( r == 1) { f = 0;}\\n            p=c;\\n        }\\n        if(gcd > 1) return -1;\\n       \\n        if(f == 0)\\n        return cnt;\\n        \\n        \\n        int c = INT_MAX;\\n        for(int i=0;i<nums.size();i++){\\n            gcd = nums[i];\\n            for(int j=i;j<nums.size();j++){\\n                gcd = __gcd(gcd, nums[j]);\\n            \\n            if(gcd == 1){\\n                c=min(c,j-i);\\n            }\\n            }\\n        }\\n        return cnt-1 + c ;\\n       \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minOperations(vector<int>& nums) {\\n        int gcd  = nums[0];\\n        int cnt =0;\\n        int p = gcd;\\n        int f=1;\\n        for(auto c:nums){\\n            gcd = __gcd(c,gcd);\\n            if(c>1) cnt++;\\n            int r = __gcd(p,c);\\n            if( r == 1) { f = 0;}\\n            p=c;\\n        }\\n        if(gcd > 1) return -1;\\n       \\n        if(f == 0)\\n        return cnt;\\n        \\n        \\n        int c = INT_MAX;\\n        for(int i=0;i<nums.size();i++){\\n            gcd = nums[i];\\n            for(int j=i;j<nums.size();j++){\\n                gcd = __gcd(gcd, nums[j]);\\n            \\n            if(gcd == 1){\\n                c=min(c,j-i);\\n            }\\n            }\\n        }\\n        return cnt-1 + c ;\\n       \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445829,
                "title": "python-dp",
                "content": "**Idea:**\\n- The size is small 50 so we can hash all the array and do dp on it.\\n- For each pair in array we do ans = min(ans, 1 + dp(new array with replacement as gcd)) if that replacement not equal value itself\\n- Speed up: if gcd == 1 we return all non 1s\\n\\n\\n```python\\nclass Solution:\\n    def minOperations(self, A: List[int]) -> int:\\n        N = len(A)\\n        @cache\\n        def dp(A):\\n            if sum(A) == N: return 0\\n            A = list(A)\\n            ans = inf\\n            for i in range(N-1):\\n                \\n                c = gcd(A[i],A[i+1])\\n                if c == 1:\\n                    s = 0\\n                    for x in A:\\n                        if x != 1:\\n                            s += 1\\n                    return s\\n                if A[i] != c:\\n                    x = A[i]\\n                    A[i] = c\\n                    ans = min(ans, 1 + dp(tuple(A)))\\n                    A[i] = x\\n                \\n                if A[i+1] != c:\\n                    x = A[i+1]\\n                    A[i+1] = c\\n                    ans = min(ans, 1 + dp(tuple(A)))\\n                    A[i+1] = x\\n            return ans\\n        \\n        ans = dp(tuple(A))\\n        \\n        return  -1  if inf == ans else ans\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def minOperations(self, A: List[int]) -> int:\\n        N = len(A)\\n        @cache\\n        def dp(A):\\n            if sum(A) == N: return 0\\n            A = list(A)\\n            ans = inf\\n            for i in range(N-1):\\n                \\n                c = gcd(A[i],A[i+1])\\n                if c == 1:\\n                    s = 0\\n                    for x in A:\\n                        if x != 1:\\n                            s += 1\\n                    return s\\n                if A[i] != c:\\n                    x = A[i]\\n                    A[i] = c\\n                    ans = min(ans, 1 + dp(tuple(A)))\\n                    A[i] = x\\n                \\n                if A[i+1] != c:\\n                    x = A[i+1]\\n                    A[i+1] = c\\n                    ans = min(ans, 1 + dp(tuple(A)))\\n                    A[i+1] = x\\n            return ans\\n        \\n        ans = dp(tuple(A))\\n        \\n        return  -1  if inf == ans else ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445823,
                "title": "brute-force-o-n-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf there is a one in the array you can spread it to an adjacent indice every iteration in a loop until the whole array is one because the gcd(a, 1) = 1. If there is no one but we knew the smallest window where the gcd(values in window) = 1. then the min operations would be the length of the array  + window - 2. Since no values are one in the array, we must perform an operation on every indice. We must also add the size of the smallest window - 2 because we have to create a one to spread throughout the array first. We subtract two because if 2 adjacent elements in the array has a gcd of one then the min operations is the size of the array (we create a one in the first operation) else its the size of the array + elements in excess of two.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1a) if there are ones in the array returns length of array - number of ones\\n1b) find smallest window to create a gcd of 1 and return length of the array + window - 2\\n# Complexity\\n- Time complexity: O((N^2)*logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int ones = 0;\\n        for (int num : nums)\\n            if (num == 1)\\n                ones++;\\n        if (ones > 0)\\n            return nums.length - ones;\\n        int minLength = Integer.MAX_VALUE;\\n        int n = nums.length;\\n        for (int i = 0; i < n; i++) {\\n            int val = nums[i];\\n            for (int j = i + 1; j < n; j++) {\\n                val = gcd(val, nums[j]);\\n                if (val == 1) {\\n                    if (j - i + 1 < minLength) {\\n                        minLength = j - i + 1;\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        if (minLength == Integer.MAX_VALUE)\\n            return -1;\\n        return n + (minLength - 2);\\n    }\\n    \\n    private int gcd(int a, int b) {\\n        if (b > a)\\n            return gcd(b, a);\\n        else if (b == 0)\\n            return a;\\n        int rem = a % b;\\n        return gcd(b, rem);\\n    }\\n    \\n    \\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int ones = 0;\\n        for (int num : nums)\\n            if (num == 1)\\n                ones++;\\n        if (ones > 0)\\n            return nums.length - ones;\\n        int minLength = Integer.MAX_VALUE;\\n        int n = nums.length;\\n        for (int i = 0; i < n; i++) {\\n            int val = nums[i];\\n            for (int j = i + 1; j < n; j++) {\\n                val = gcd(val, nums[j]);\\n                if (val == 1) {\\n                    if (j - i + 1 < minLength) {\\n                        minLength = j - i + 1;\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        if (minLength == Integer.MAX_VALUE)\\n            return -1;\\n        return n + (minLength - 2);\\n    }\\n    \\n    private int gcd(int a, int b) {\\n        if (b > a)\\n            return gcd(b, a);\\n        else if (b == 0)\\n            return a;\\n        int rem = a % b;\\n        return gcd(b, rem);\\n    }\\n    \\n    \\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445820,
                "title": "java-intuitive-solution",
                "content": "```\\nclass Solution {\\n    int getGcd(int val1, int val2)\\n    {\\n        if (val1 == 0) return val2;\\n        return getGcd(val2 % val1, val1);\\n    }\\n    public int minOperations(int[] arr) {\\n        int onesCount = 0, n = arr.length, min = Integer.MAX_VALUE;;\\n        for (int i = 0; i < n; i++) if (arr[i] == 1) onesCount++;\\n        if (onesCount != 0) return n - onesCount;\\n\\n        for (int i = 0; i < n; i++) {\\n            int gcd = arr[i];\\n            for (int j = i + 1; j < n; j++) {\\n                gcd = getGcd(arr[j], gcd);\\n                if (gcd == 1) {\\n                    min = Math.min(min, j - i);\\n                    break;\\n                }\\n            }\\n        }\\n\\n        if (min == Integer.MAX_VALUE) return -1; \\n        return n + min - 1; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int getGcd(int val1, int val2)\\n    {\\n        if (val1 == 0) return val2;\\n        return getGcd(val2 % val1, val1);\\n    }\\n    public int minOperations(int[] arr) {\\n        int onesCount = 0, n = arr.length, min = Integer.MAX_VALUE;;\\n        for (int i = 0; i < n; i++) if (arr[i] == 1) onesCount++;\\n        if (onesCount != 0) return n - onesCount;\\n\\n        for (int i = 0; i < n; i++) {\\n            int gcd = arr[i];\\n            for (int j = i + 1; j < n; j++) {\\n                gcd = getGcd(arr[j], gcd);\\n                if (gcd == 1) {\\n                    min = Math.min(min, j - i);\\n                    break;\\n                }\\n            }\\n        }\\n\\n        if (min == Integer.MAX_VALUE) return -1; \\n        return n + min - 1; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445785,
                "title": "best-solution-ever-hindi",
                "content": "# Intuition\\nbest solution ever\\n# Approach\\nin hindi\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static int minOperations(int[] nums) {\\n        int n = nums.length;\\n        int coo = 0;\\n        for(int i=0; i<n; i++) {\\n            if(nums[i] == 1) {\\n                coo++;\\n            }\\n        }\\n        \\n        \\n        \\n        \\n        if(coo > 0) {\\n            return n - coo;\\n        }\\n        \\n        \\n        \\n        int ans = Integer.MAX_VALUE;\\n        for(int i=0; i<n; i++) {\\n            int num = nums[i];\\n            for(int j=i+1; j<n; j++) {\\n                num = gcd(num, nums[j]);\\n                if(num == 1) {\\n                    ans = Math.min(ans, j-i);\\n                    break;\\n                }\\n            }\\n            if(num != 1) {\\n                break;\\n            }\\n        }\\n        if(ans == Integer.MAX_VALUE) {\\n            return -1;\\n        }\\n        return n-1+ans;\\n    }\\n    \\n    public static int gcd(int a, int b) {\\n        if(a == 0) {\\n            return b;\\n        }\\n        return gcd(b%a, a);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int minOperations(int[] nums) {\\n        int n = nums.length;\\n        int coo = 0;\\n        for(int i=0; i<n; i++) {\\n            if(nums[i] == 1) {\\n                coo++;\\n            }\\n        }\\n        \\n        \\n        \\n        \\n        if(coo > 0) {\\n            return n - coo;\\n        }\\n        \\n        \\n        \\n        int ans = Integer.MAX_VALUE;\\n        for(int i=0; i<n; i++) {\\n            int num = nums[i];\\n            for(int j=i+1; j<n; j++) {\\n                num = gcd(num, nums[j]);\\n                if(num == 1) {\\n                    ans = Math.min(ans, j-i);\\n                    break;\\n                }\\n            }\\n            if(num != 1) {\\n                break;\\n            }\\n        }\\n        if(ans == Integer.MAX_VALUE) {\\n            return -1;\\n        }\\n        return n-1+ans;\\n    }\\n    \\n    public static int gcd(int a, int b) {\\n        if(a == 0) {\\n            return b;\\n        }\\n        return gcd(b%a, a);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445778,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size() ;\\n        int ones = 0 ;\\n        for(int i = 0; i < n; i++)\\n            if(nums[i] == 1)\\n                ones++ ;\\n        if(ones > 0)\\n            return n - ones ;\\n        \\n        int ret = INT_MAX ;\\n        for(int i = 0; i < n; i++){\\n            vector<int>numT = nums ;\\n            for(int j = i+1; j < n; j++){\\n                numT[j] = gcd(numT[j], numT[j-1]);\\n                if(numT[j] == 1)\\n                    ret = min(ret , j-i + n-1) ;\\n            }\\n        }       \\n        return (ret== INT_MAX) ? -1 : ret  ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size() ;\\n        int ones = 0 ;\\n        for(int i = 0; i < n; i++)\\n            if(nums[i] == 1)\\n                ones++ ;\\n        if(ones > 0)\\n            return n - ones ;\\n        \\n        int ret = INT_MAX ;\\n        for(int i = 0; i < n; i++){\\n            vector<int>numT = nums ;\\n            for(int j = i+1; j < n; j++){\\n                numT[j] = gcd(numT[j], numT[j-1]);\\n                if(numT[j] == 1)\\n                    ret = min(ret , j-i + n-1) ;\\n            }\\n        }       \\n        return (ret== INT_MAX) ? -1 : ret  ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445775,
                "title": "python-o-n-2",
                "content": "# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        if 1 in nums:\\n            return sum(num!=1 for num in nums)\\n        small = inf\\n        g = nums[:]\\n        for di in range(1, len(nums)):\\n            for i in range(len(nums)):\\n                if i + di >= len(nums):\\n                    break\\n                g[i] = gcd(g[i], nums[i+di])\\n                if g[i] == 1:\\n                    return di-1+len(nums)\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        if 1 in nums:\\n            return sum(num!=1 for num in nums)\\n        small = inf\\n        g = nums[:]\\n        for di in range(1, len(nums)):\\n            for i in range(len(nums)):\\n                if i + di >= len(nums):\\n                    break\\n                g[i] = gcd(g[i], nums[i+di])\\n                if g[i] == 1:\\n                    return di-1+len(nums)\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445723,
                "title": "c-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        \\n        int k=0,mini=INT_MAX;\\n        for(int&i:nums){\\n            if(i==1)\\n                k++;\\n        }\\n        if(k!=0){\\n            return nums.size()-k;\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            int p=nums[i];\\n            for(int j=i+1;j<nums.size();j++){\\n                p=gcd(p,nums[j]);\\n                if(p==1){\\n                    mini=min(mini,j-i);\\n                    break;\\n                }\\n            }\\n        }\\n        return mini==INT_MAX?-1:nums.size()+mini-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        \\n        int k=0,mini=INT_MAX;\\n        for(int&i:nums){\\n            if(i==1)\\n                k++;\\n        }\\n        if(k!=0){\\n            return nums.size()-k;\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            int p=nums[i];\\n            for(int j=i+1;j<nums.size();j++){\\n                p=gcd(p,nums[j]);\\n                if(p==1){\\n                    mini=min(mini,j-i);\\n                    break;\\n                }\\n            }\\n        }\\n        return mini==INT_MAX?-1:nums.size()+mini-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445719,
                "title": "no-need-of-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& a) {\\n        int n=a.size();\\n        bool check=false;\\n        int gcd=0,num;\\n        for(int i=0;i<n;i++){\\n            gcd=__gcd(gcd,a[i]);\\n        }\\n        if(gcd!=1) return -1;\\n        //check number of 1\\'s;\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            if(a[i]==1) cnt++;\\n        }\\n        if(cnt) return n-cnt;\\n        else {\\n            for(int i=1;i<n;i++){\\n                for(int j=0;j<n-i;j++){\\n                    gcd=0;\\n                    for(int k=j;k<=j+i;k++){\\n                        // cout<<j<<\" \"<<k<<endl;\\n                        gcd=__gcd(a[k],gcd);\\n                    }\\n                    if(gcd==1){\\n                        // cout<<i<<endl;\\n                        num=i+n-1;\\n                        check=true;\\n                        break;\\n                    }\\n                }\\n                if(check) break;\\n            }\\n        }\\n        return num;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& a) {\\n        int n=a.size();\\n        bool check=false;\\n        int gcd=0,num;\\n        for(int i=0;i<n;i++){\\n            gcd=__gcd(gcd,a[i]);\\n        }\\n        if(gcd!=1) return -1;\\n        //check number of 1\\'s;\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            if(a[i]==1) cnt++;\\n        }\\n        if(cnt) return n-cnt;\\n        else {\\n            for(int i=1;i<n;i++){\\n                for(int j=0;j<n-i;j++){\\n                    gcd=0;\\n                    for(int k=j;k<=j+i;k++){\\n                        // cout<<j<<\" \"<<k<<endl;\\n                        gcd=__gcd(a[k],gcd);\\n                    }\\n                    if(gcd==1){\\n                        // cout<<i<<endl;\\n                        num=i+n-1;\\n                        check=true;\\n                        break;\\n                    }\\n                }\\n                if(check) break;\\n            }\\n        }\\n        return num;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3445700,
                "title": "the-edge-case-that-costed-most-of-us-1-wa-c-intuition-explained",
                "content": "![image.png](https://assets.leetcode.com/users/images/121a8662-6e86-4218-87fd-323f5b913c7c_1682222218.3598685.png)\\n\\nSo, here is the test case that should be given maximum credit for taking the responsibility to decrease the accuracy of the problem to less than 25%.\\n```\\nnums = [1,1]\\n```\\n\\n\\n\\n<!--# Intuition\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!--# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!--- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Approach\\nLooking at the constraints will give a hint that we can loop through the array more than one time. So lets go through all the subarrays and find the size of the subarray with minimum size having GCD as 1.\\nSo to achieve the first 1 in the array will take size of subarray -1 moves. To make all the elements equal to 1 will take more nums.size()-1 moves.\\n\\n**Handling the edge case:** Check if there are already 1s existing in the array. If yes then just return nums.size()-no of ones present in the array. \\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int len=INT_MAX,hcf=nums[0];\\n        int flag=(nums[0]==1?1:0);\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            hcf=__gcd(nums[i],hcf);\\n            if(nums[i]==1)flag++;\\n        }\\n        if(flag>0)\\n            return nums.size()-(flag); \\n        if(hcf!=1)\\n            return -1;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            hcf=nums[i];\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                hcf=__gcd(nums[j],hcf);\\n                if(hcf==1)\\n                {\\n                    len=min(len,j-i);\\n                    break;\\n                }\\n            }\\n        }\\n        if(len==INT_MAX)return -1;\\n        return len+nums.size()-1;\\n    }\\n};\\n```\\n\\n**Please Upvote if u could relate with me or liked the approach**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nnums = [1,1]\\n```\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int len=INT_MAX,hcf=nums[0];\\n        int flag=(nums[0]==1?1:0);\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            hcf=__gcd(nums[i],hcf);\\n            if(nums[i]==1)flag++;\\n        }\\n        if(flag>0)\\n            return nums.size()-(flag); \\n        if(hcf!=1)\\n            return -1;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            hcf=nums[i];\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                hcf=__gcd(nums[j],hcf);\\n                if(hcf==1)\\n                {\\n                    len=min(len,j-i);\\n                    break;\\n                }\\n            }\\n        }\\n        if(len==INT_MAX)return -1;\\n        return len+nums.size()-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445674,
                "title": "c-simple-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int GCD(int a,int b)\\n    {\\n        if(b == 0)\\n            return a;\\n        return GCD(b,a%b);\\n    }\\n    \\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int countone = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i] == 1)\\n                countone++;\\n        }\\n        if(countone > 0)\\n             return n-countone;\\n        \\n        int minop = INT_MAX;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            int gcdres = nums[i];\\n            for(int j=i+1;j<n;j++)\\n            {\\n                gcdres = GCD(nums[j],gcdres);\\n                if(gcdres == 1)\\n                {\\n                    minop = min(minop,j-i+1);\\n                    break;\\n                }\\n            }\\n        }\\n        if(minop == INT_MAX)\\n            return -1;\\n        return n+minop-2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int GCD(int a,int b)\\n    {\\n        if(b == 0)\\n            return a;\\n        return GCD(b,a%b);\\n    }\\n    \\n    int minOperations(vector<int>& nums) {\\n        int n = nums.size();\\n        int countone = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i] == 1)\\n                countone++;\\n        }\\n        if(countone > 0)\\n             return n-countone;\\n        \\n        int minop = INT_MAX;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            int gcdres = nums[i];\\n            for(int j=i+1;j<n;j++)\\n            {\\n                gcdres = GCD(nums[j],gcdres);\\n                if(gcdres == 1)\\n                {\\n                    minop = min(minop,j-i+1);\\n                    break;\\n                }\\n            }\\n        }\\n        if(minop == INT_MAX)\\n            return -1;\\n        return n+minop-2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445673,
                "title": "minimum-size-subarray-with-gcd-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int com=nums[0], oc=0;\\n        // com is the cumulative gcd\\n        //oc means one count\\n        if(nums[0]==1){oc++;}\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i]==1){oc++;}\\n            com=__gcd(com,nums[i]);\\n        }\\n        // if there is some common factor between every element then its impossible to make array 1\\n        if(com!=1){return -1;}\\n        //if there is even a single one in the array then we can convert any element to 1 with a single operation\\n        // so in this case the total operations required = the number of non one elements\\n        if(oc){return nums.size()-oc;}\\n        \\n        // here we try to find the subarray of minimum size whose gcd=1\\n        int mini=INT_MAX;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int com=nums[i];\\n            for(int j=i;j<nums.size();j++)\\n            {\\n                com=__gcd(nums[j],com);\\n                if(com==1){\\n                    mini=min(mini,j-i+1);break;\\n                }\\n            }\\n        }\\n        //mini-2 is the extra operations required to make an element 1 in the array and once we get a single 1 we can convert all elements to 1 each with a single operation\\n        return nums.size()+(mini-2);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n        int com=nums[0], oc=0;\\n        // com is the cumulative gcd\\n        //oc means one count\\n        if(nums[0]==1){oc++;}\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i]==1){oc++;}\\n            com=__gcd(com,nums[i]);\\n        }\\n        // if there is some common factor between every element then its impossible to make array 1\\n        if(com!=1){return -1;}\\n        //if there is even a single one in the array then we can convert any element to 1 with a single operation\\n        // so in this case the total operations required = the number of non one elements\\n        if(oc){return nums.size()-oc;}\\n        \\n        // here we try to find the subarray of minimum size whose gcd=1\\n        int mini=INT_MAX;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int com=nums[i];\\n            for(int j=i;j<nums.size();j++)\\n            {\\n                com=__gcd(nums[j],com);\\n                if(com==1){\\n                    mini=min(mini,j-i+1);break;\\n                }\\n            }\\n        }\\n        //mini-2 is the extra operations required to make an element 1 in the array and once we get a single 1 we can convert all elements to 1 each with a single operation\\n        return nums.size()+(mini-2);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445670,
                "title": "i-will-stop-as-soon-as-i-find-number-1-greedy",
                "content": "I am just trying to find the number 1 because gcd of anynumber with 1 will be 1 and we want to make elements to 1 .\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums,int ans = INT_MAX,int ones = 0) {\\n        for(auto ele:nums)ones+=ele==1;\\n        if(ones > 0)  return (int)nums.size() - ones;\\n        for(int i=0; i<(int)nums.size(); i++) {\\n            auto ele = nums[i];\\n            for(int j=i+1;j<(int)nums.size(); j++) {\\n                ele = gcd(ele, nums[j]);\\n                if(ele == 1) {\\n                    ans = min(ans, j-i);\\n                    break;\\n                }\\n            }\\n            if(!ele)break;\\n        }\\n        return ans == INT_MAX?-1:(int)nums.size() -1+ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums,int ans = INT_MAX,int ones = 0) {\\n        for(auto ele:nums)ones+=ele==1;\\n        if(ones > 0)  return (int)nums.size() - ones;\\n        for(int i=0; i<(int)nums.size(); i++) {\\n            auto ele = nums[i];\\n            for(int j=i+1;j<(int)nums.size(); j++) {\\n                ele = gcd(ele, nums[j]);\\n                if(ele == 1) {\\n                    ans = min(ans, j-i);\\n                    break;\\n                }\\n            }\\n            if(!ele)break;\\n        }\\n        return ans == INT_MAX?-1:(int)nums.size() -1+ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460557,
                "title": "java-simple-solution-o-n-k-gcd",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nObervations  : \\n    1 - If GCD of whole array is not equal to 1 then we cannot convert the array to 1 so return -1;\\n    2 - Find the smallest subarray whose GCD is 1 then use the formula to calculate the final answer.\\n\\n    Formula is designed is based on the conditions - \\n        answer = total no.of elements - 1 + minimum size of the subarray whose gcd = 1\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private int gcd(int a,int b){\\n        if(a == 0){\\n            return b;\\n        }\\n\\n        return gcd(b % a,a);\\n    }\\n    public int minOperations(int[] nums) {\\n        int n = nums.length;\\n        int cnt = 0;\\n        int gcd = 0;\\n        for(int i : nums){\\n            if(i == 1){\\n                cnt++;\\n            }\\n            gcd = gcd(gcd,i);\\n        }\\n\\n        if(gcd != 1){\\n            return -1;\\n        }\\n        if(cnt > 0){\\n            return n - cnt;\\n        }\\n\\n        int ans = Integer.MAX_VALUE;\\n        for(int i = 0;i < n;i++){\\n            int num = nums[i];\\n            for(int j = i + 1;j < n;j++){\\n                num = gcd(num,nums[j]);\\n                if(num == 1){\\n                    ans = Math.min(ans,j - i);\\n                    break;\\n                }\\n            }\\n        }\\n        return n - 1 + ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    private int gcd(int a,int b){\\n        if(a == 0){\\n            return b;\\n        }\\n\\n        return gcd(b % a,a);\\n    }\\n    public int minOperations(int[] nums) {\\n        int n = nums.length;\\n        int cnt = 0;\\n        int gcd = 0;\\n        for(int i : nums){\\n            if(i == 1){\\n                cnt++;\\n            }\\n            gcd = gcd(gcd,i);\\n        }\\n\\n        if(gcd != 1){\\n            return -1;\\n        }\\n        if(cnt > 0){\\n            return n - cnt;\\n        }\\n\\n        int ans = Integer.MAX_VALUE;\\n        for(int i = 0;i < n;i++){\\n            int num = nums[i];\\n            for(int j = i + 1;j < n;j++){\\n                num = gcd(num,nums[j]);\\n                if(num == 1){\\n                    ans = Math.min(ans,j - i);\\n                    break;\\n                }\\n            }\\n        }\\n        return n - 1 + ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1873923,
                "content": [
                    {
                        "username": "rideau",
                        "content": "Does anybody know how solve this in O(1) time? Is this even possible?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Pay no attention to that follow-up. The person who wrote it was drunk."
                    },
                    {
                        "username": "User___",
                        "content": "Did you manage to solve it in $$O(n)$$? Just wondering, since you\\'re asking about $$O(1)$$ (which I feel isn\\'t possible)"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "I think it's quite easy to prove that it impossible to solve this problem in O(1) time complexity.\nImaging you have an array of length N, for which the asnwer is \"-1\" - that is, you cannot make all elements equal to 1 using any number of operations. Now, insert number \"1\" at a random index of the array, and now you can make all other numbers equal to 1. In order to find this \"1\" you need O(N) time complexity."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your reasoning is absolutely correct. As per the problem, you need to inspect each element of the array to determine if the number 1 is present or if a pair of numbers exists such that their greatest common divisor (gcd) is 1. This requires at least linear time, O(N), where N is the length of the array.\\n\\nAs you\\'ve aptly illustrated, the presence of a single 1 in the array changes the entire outcome of the problem. Without examining each element, we cannot determine the presence or absence of such a crucial value. This necessitates iterating through the array at least once, thereby confirming that the problem cannot be solved in constant time, O(1)."
                    },
                    {
                        "username": "SlickGeek",
                        "content": "\"...but could you find an O(1) constant time complexity solution?\" Is it actually possible to solve this problem in constant time? I don\\'t know if there\\'s something I am not seeing or understanding, but I don\\'t think that is possible.\\nThe solution I came up with runs in N^2 and beats 71%."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rideau](/rideau) see [@Sergey TT](/SergeyTT)\\'s respose"
                    },
                    {
                        "username": "rideau",
                        "content": "Any updates? Im also interested "
                    },
                    {
                        "username": "sanjitj7",
                        "content": "EDIT: I have spotted my n00b mistake\n\nI think this test case is incorrect!\n\n>Input: nums = [2,10,6,14]\n>Output: -1\n>Explanation: It can be shown that it is impossible to make all the elements equal to 1\n\n[2,10,6,14]\n[2,10,3,14]  (i = 2)\n[2,10,3,1]   (i = 2)\n[2,10,1,1]\n[2,1,1,1]\n[1,1,1,1]\n\nThis caused a lot of confusion to me."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "oh scheisse, I was taking num/GCD there \\uD83D\\uDE05 "
                    },
                    {
                        "username": "srk696772",
                        "content": "Bro GCD(6,14) == 2 ,  \nnot 3"
                    },
                    {
                        "username": "bekbossyn_kassymkhan",
                        "content": "gcd(6 & 14) = 2 , gcd(10,6)=2 also \n:)"
                    },
                    {
                        "username": "gaurav1903",
                        "content": "What\\'s the O(N) solution??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The O(N) solution leverages the fact that if we can find two numbers in the array whose greatest common divisor (gcd) is 1, then the minimum number of operations required is the size of the array minus 1.\\n\\nTo achieve this in linear time, we can use the Sieve of Eratosthenes, a well-known algorithm for finding all prime numbers up to a given limit. This algorithm can be used to find the smallest prime factor for each number in the array, which is a prerequisite for finding two numbers with gcd 1.\\n\\nHere are the steps of the algorithm:\\n\\n1. Compute the smallest prime factor for each number up to max(nums) using the Sieve of Eratosthenes.\\n2. For each number in nums, if its smallest prime factor divides another number in nums, we can assume that the gcd of these two numbers is 1.\\n3. If we find such a pair, the minimum number of operations required is the size of the array minus 1.\\n4. If no such pair exists, we cannot make all elements equal to 1, so we return -1.\\n\\nNote: As the Sieve of Eratosthenes requires O(N log log N) time complexity, this solution is not strictly linear. However, it is significantly more efficient than an O(N^2) solution when dealing with large inputs.\\n\\nThis solution assumes that the input numbers are not too large (e.g., within the range of an integer). If the numbers can be very large, we need a different approach because the Sieve of Eratosthenes may not be feasible. For example, we could use a probabilistic algorithm to find a pair of numbers with gcd 1, but this would not guarantee a correct answer in all cases.\\n\\nAlso, it\\'s important to note that this approach doesn\\'t give the exact number of operations if no \"1\" is found in the array; it only checks for the possibility of making all elements equal to 1. Calculating the exact number of operations in such a case can be a more complex problem and is likely to require more than linear time."
                    },
                    {
                        "username": "ZX007java",
                        "content": "Good day ! Can anyone give me answer : why set [2, 6, 3, 4] have answer is equal 4, BUT SET [4, 2, 6, 3] have answer is equal 5 ???"
                    },
                    {
                        "username": "bparanj",
                        "content": "This discrepancy arises from the order in which we are allowed to perform the gcd operations on the array.\\n\\nFor the array [2, 6, 3, 4]:\\n\\n1. We can select index 2 (i.e., the number 3) and take the gcd with the number at index 3 (i.e., the number 4), and replace 3 with gcd(3, 4) = 1. Array becomes [2, 6, 1, 4].\\n2. We can then select index 1 (i.e., the number 6) and take the gcd with the number at index 2 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, 1, 1, 4].\\n3. Then, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 4].\\n4. Finally, select index 2 (i.e., the number 1) and take the gcd with the number at index 3 (i.e., the number 4), and replace 4 with gcd(1, 4) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 4.\\n\\nFor the array [4, 2, 6, 3]:\\n\\n1. We can select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array becomes [4, 2, 6, 3].\\n2. Repeat step 1. Array still is [4, 2, 6, 3].\\n3. Repeat step 1 again. Array still is [4, 2, 6, 3].\\n4. Finally, select index 3 (i.e., the number 3) and take the gcd with the number at index 2 (i.e., the number 6), and replace 3 with gcd(3, 6) = 3. Array becomes [4, 2, 6, 1].\\n5. Now, select index 0 (i.e., the number 4) and take the gcd with the number at index 1 (i.e., the number 2), and replace 4 with gcd(4, 2) = 2. Array becomes [2, 2, 6, 1].\\n6. Next, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array still is [2, 2, 6, 1].\\n7. Repeat step 6. Array still is [2, 2, 6, 1].\\n8. Repeat step 6 again. Array still is [2, 2, 6, 1].\\n9. Repeat step 6 once more. Array still is [2, 2, 6, 1].\\n10. Finally, select index 2 (i.e., the number 6) and take the gcd with the number at index 3 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, \\n\\n2, 1, 1].\\n11. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 2), and replace 2 with gcd(2, 2) = 2. Array still is [2, 2, 1, 1].\\n12. Repeat step 11. Array still is [2, 2, 1, 1].\\n13. Repeat step 11 again. Array still is [2, 2, 1, 1].\\n14. Finally, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [2, 1, 1, 1].\\n15. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 15.\\n\\nThis demonstrates how the order of the array can affect the total number of operations required to achieve all elements as 1. The most optimized way to get all elements to 1 can depend on the order of elements in the array."
                    },
                    {
                        "username": "ZX007java",
                        "content": "[@s_m99](/s_m99) THANK YOU !!! CONSECUTIVE !!!"
                    },
                    {
                        "username": "s_m99",
                        "content": "You can only calculate gcd\\'s of 2 **consecutive** numbers and replace either of them. So in set [4,2,6,3] to make 3 into 1 we require two operations instead of one in [2,6,3,4] "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn, that was a great problem but... Medium, really? Am I just getting dumber? \nTook me quite lot of time and tryhard to see the solution.\nAnd that's gotta be the lowest acceptance rate I've seen for a medium problem\n\nAlso, python has a built-in gcd function apparently. Lesson learned; next time, no need to face my anxieties trying to remember my number theory classes to implement the Euclidean algo myself"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "Anyone explain or hint"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "light hint: how many steps would it take to get your first one in the array? And once you have a one, how many more steps do you need to turn everything into a one?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I am not able to understand the question\\nit says \\nselect index i and change num[i] or num[i+1] with their GCD and people have used n^2 loop to check every pair"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the minimum number of operations required to make all elements of an array equal to 1, by replacing either nums[i] or nums[i+1] with their gcd (greatest common divisor).\\n\\nThe problem solution is implemented with an O(n^2) approach, and this is why:\\n\\n1. You iterate over each element in the array (first loop).\\n2. For each element, you check for a contiguous segment in the array where the gcd of the numbers in the segment equals 1 (second loop). If such a segment is found, you store the length of that segment minus 1 (because one element is already 1 and doesn\\'t need any operation).\\n3. The result of the algorithm is the minimum length of these segments (if any) plus the number of elements outside these segments (because each of these will need one operation to become 1, by taking the gcd with 1).\\n\\nThe algorithm needs to check all pairs of elements because the array isn\\'t necessarily sorted, and any pair (i, j) with i < j can potentially form a contiguous segment where the gcd of the numbers is 1. So, an element nums[i] might be replaced by the gcd of nums[i] and nums[j] for some j > i.\\n"
                    },
                    {
                        "username": "User___",
                        "content": "[@cartesPerforees](/cartesPerforees) Is that $$O(n)$$?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you understand the question, it's just the solutions that you don't understand.\nWe check every pair to find the closest elements that could lead to a gcd of 1. Then we propagate the gcd neighbor-by-neighbor"
                    }
                ]
            },
            {
                "id": 1878342,
                "content": [
                    {
                        "username": "rideau",
                        "content": "Does anybody know how solve this in O(1) time? Is this even possible?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Pay no attention to that follow-up. The person who wrote it was drunk."
                    },
                    {
                        "username": "User___",
                        "content": "Did you manage to solve it in $$O(n)$$? Just wondering, since you\\'re asking about $$O(1)$$ (which I feel isn\\'t possible)"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "I think it's quite easy to prove that it impossible to solve this problem in O(1) time complexity.\nImaging you have an array of length N, for which the asnwer is \"-1\" - that is, you cannot make all elements equal to 1 using any number of operations. Now, insert number \"1\" at a random index of the array, and now you can make all other numbers equal to 1. In order to find this \"1\" you need O(N) time complexity."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your reasoning is absolutely correct. As per the problem, you need to inspect each element of the array to determine if the number 1 is present or if a pair of numbers exists such that their greatest common divisor (gcd) is 1. This requires at least linear time, O(N), where N is the length of the array.\\n\\nAs you\\'ve aptly illustrated, the presence of a single 1 in the array changes the entire outcome of the problem. Without examining each element, we cannot determine the presence or absence of such a crucial value. This necessitates iterating through the array at least once, thereby confirming that the problem cannot be solved in constant time, O(1)."
                    },
                    {
                        "username": "SlickGeek",
                        "content": "\"...but could you find an O(1) constant time complexity solution?\" Is it actually possible to solve this problem in constant time? I don\\'t know if there\\'s something I am not seeing or understanding, but I don\\'t think that is possible.\\nThe solution I came up with runs in N^2 and beats 71%."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rideau](/rideau) see [@Sergey TT](/SergeyTT)\\'s respose"
                    },
                    {
                        "username": "rideau",
                        "content": "Any updates? Im also interested "
                    },
                    {
                        "username": "sanjitj7",
                        "content": "EDIT: I have spotted my n00b mistake\n\nI think this test case is incorrect!\n\n>Input: nums = [2,10,6,14]\n>Output: -1\n>Explanation: It can be shown that it is impossible to make all the elements equal to 1\n\n[2,10,6,14]\n[2,10,3,14]  (i = 2)\n[2,10,3,1]   (i = 2)\n[2,10,1,1]\n[2,1,1,1]\n[1,1,1,1]\n\nThis caused a lot of confusion to me."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "oh scheisse, I was taking num/GCD there \\uD83D\\uDE05 "
                    },
                    {
                        "username": "srk696772",
                        "content": "Bro GCD(6,14) == 2 ,  \nnot 3"
                    },
                    {
                        "username": "bekbossyn_kassymkhan",
                        "content": "gcd(6 & 14) = 2 , gcd(10,6)=2 also \n:)"
                    },
                    {
                        "username": "gaurav1903",
                        "content": "What\\'s the O(N) solution??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The O(N) solution leverages the fact that if we can find two numbers in the array whose greatest common divisor (gcd) is 1, then the minimum number of operations required is the size of the array minus 1.\\n\\nTo achieve this in linear time, we can use the Sieve of Eratosthenes, a well-known algorithm for finding all prime numbers up to a given limit. This algorithm can be used to find the smallest prime factor for each number in the array, which is a prerequisite for finding two numbers with gcd 1.\\n\\nHere are the steps of the algorithm:\\n\\n1. Compute the smallest prime factor for each number up to max(nums) using the Sieve of Eratosthenes.\\n2. For each number in nums, if its smallest prime factor divides another number in nums, we can assume that the gcd of these two numbers is 1.\\n3. If we find such a pair, the minimum number of operations required is the size of the array minus 1.\\n4. If no such pair exists, we cannot make all elements equal to 1, so we return -1.\\n\\nNote: As the Sieve of Eratosthenes requires O(N log log N) time complexity, this solution is not strictly linear. However, it is significantly more efficient than an O(N^2) solution when dealing with large inputs.\\n\\nThis solution assumes that the input numbers are not too large (e.g., within the range of an integer). If the numbers can be very large, we need a different approach because the Sieve of Eratosthenes may not be feasible. For example, we could use a probabilistic algorithm to find a pair of numbers with gcd 1, but this would not guarantee a correct answer in all cases.\\n\\nAlso, it\\'s important to note that this approach doesn\\'t give the exact number of operations if no \"1\" is found in the array; it only checks for the possibility of making all elements equal to 1. Calculating the exact number of operations in such a case can be a more complex problem and is likely to require more than linear time."
                    },
                    {
                        "username": "ZX007java",
                        "content": "Good day ! Can anyone give me answer : why set [2, 6, 3, 4] have answer is equal 4, BUT SET [4, 2, 6, 3] have answer is equal 5 ???"
                    },
                    {
                        "username": "bparanj",
                        "content": "This discrepancy arises from the order in which we are allowed to perform the gcd operations on the array.\\n\\nFor the array [2, 6, 3, 4]:\\n\\n1. We can select index 2 (i.e., the number 3) and take the gcd with the number at index 3 (i.e., the number 4), and replace 3 with gcd(3, 4) = 1. Array becomes [2, 6, 1, 4].\\n2. We can then select index 1 (i.e., the number 6) and take the gcd with the number at index 2 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, 1, 1, 4].\\n3. Then, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 4].\\n4. Finally, select index 2 (i.e., the number 1) and take the gcd with the number at index 3 (i.e., the number 4), and replace 4 with gcd(1, 4) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 4.\\n\\nFor the array [4, 2, 6, 3]:\\n\\n1. We can select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array becomes [4, 2, 6, 3].\\n2. Repeat step 1. Array still is [4, 2, 6, 3].\\n3. Repeat step 1 again. Array still is [4, 2, 6, 3].\\n4. Finally, select index 3 (i.e., the number 3) and take the gcd with the number at index 2 (i.e., the number 6), and replace 3 with gcd(3, 6) = 3. Array becomes [4, 2, 6, 1].\\n5. Now, select index 0 (i.e., the number 4) and take the gcd with the number at index 1 (i.e., the number 2), and replace 4 with gcd(4, 2) = 2. Array becomes [2, 2, 6, 1].\\n6. Next, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array still is [2, 2, 6, 1].\\n7. Repeat step 6. Array still is [2, 2, 6, 1].\\n8. Repeat step 6 again. Array still is [2, 2, 6, 1].\\n9. Repeat step 6 once more. Array still is [2, 2, 6, 1].\\n10. Finally, select index 2 (i.e., the number 6) and take the gcd with the number at index 3 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, \\n\\n2, 1, 1].\\n11. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 2), and replace 2 with gcd(2, 2) = 2. Array still is [2, 2, 1, 1].\\n12. Repeat step 11. Array still is [2, 2, 1, 1].\\n13. Repeat step 11 again. Array still is [2, 2, 1, 1].\\n14. Finally, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [2, 1, 1, 1].\\n15. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 15.\\n\\nThis demonstrates how the order of the array can affect the total number of operations required to achieve all elements as 1. The most optimized way to get all elements to 1 can depend on the order of elements in the array."
                    },
                    {
                        "username": "ZX007java",
                        "content": "[@s_m99](/s_m99) THANK YOU !!! CONSECUTIVE !!!"
                    },
                    {
                        "username": "s_m99",
                        "content": "You can only calculate gcd\\'s of 2 **consecutive** numbers and replace either of them. So in set [4,2,6,3] to make 3 into 1 we require two operations instead of one in [2,6,3,4] "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn, that was a great problem but... Medium, really? Am I just getting dumber? \nTook me quite lot of time and tryhard to see the solution.\nAnd that's gotta be the lowest acceptance rate I've seen for a medium problem\n\nAlso, python has a built-in gcd function apparently. Lesson learned; next time, no need to face my anxieties trying to remember my number theory classes to implement the Euclidean algo myself"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "Anyone explain or hint"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "light hint: how many steps would it take to get your first one in the array? And once you have a one, how many more steps do you need to turn everything into a one?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I am not able to understand the question\\nit says \\nselect index i and change num[i] or num[i+1] with their GCD and people have used n^2 loop to check every pair"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the minimum number of operations required to make all elements of an array equal to 1, by replacing either nums[i] or nums[i+1] with their gcd (greatest common divisor).\\n\\nThe problem solution is implemented with an O(n^2) approach, and this is why:\\n\\n1. You iterate over each element in the array (first loop).\\n2. For each element, you check for a contiguous segment in the array where the gcd of the numbers in the segment equals 1 (second loop). If such a segment is found, you store the length of that segment minus 1 (because one element is already 1 and doesn\\'t need any operation).\\n3. The result of the algorithm is the minimum length of these segments (if any) plus the number of elements outside these segments (because each of these will need one operation to become 1, by taking the gcd with 1).\\n\\nThe algorithm needs to check all pairs of elements because the array isn\\'t necessarily sorted, and any pair (i, j) with i < j can potentially form a contiguous segment where the gcd of the numbers is 1. So, an element nums[i] might be replaced by the gcd of nums[i] and nums[j] for some j > i.\\n"
                    },
                    {
                        "username": "User___",
                        "content": "[@cartesPerforees](/cartesPerforees) Is that $$O(n)$$?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you understand the question, it's just the solutions that you don't understand.\nWe check every pair to find the closest elements that could lead to a gcd of 1. Then we propagate the gcd neighbor-by-neighbor"
                    }
                ]
            },
            {
                "id": 1873206,
                "content": [
                    {
                        "username": "rideau",
                        "content": "Does anybody know how solve this in O(1) time? Is this even possible?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Pay no attention to that follow-up. The person who wrote it was drunk."
                    },
                    {
                        "username": "User___",
                        "content": "Did you manage to solve it in $$O(n)$$? Just wondering, since you\\'re asking about $$O(1)$$ (which I feel isn\\'t possible)"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "I think it's quite easy to prove that it impossible to solve this problem in O(1) time complexity.\nImaging you have an array of length N, for which the asnwer is \"-1\" - that is, you cannot make all elements equal to 1 using any number of operations. Now, insert number \"1\" at a random index of the array, and now you can make all other numbers equal to 1. In order to find this \"1\" you need O(N) time complexity."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your reasoning is absolutely correct. As per the problem, you need to inspect each element of the array to determine if the number 1 is present or if a pair of numbers exists such that their greatest common divisor (gcd) is 1. This requires at least linear time, O(N), where N is the length of the array.\\n\\nAs you\\'ve aptly illustrated, the presence of a single 1 in the array changes the entire outcome of the problem. Without examining each element, we cannot determine the presence or absence of such a crucial value. This necessitates iterating through the array at least once, thereby confirming that the problem cannot be solved in constant time, O(1)."
                    },
                    {
                        "username": "SlickGeek",
                        "content": "\"...but could you find an O(1) constant time complexity solution?\" Is it actually possible to solve this problem in constant time? I don\\'t know if there\\'s something I am not seeing or understanding, but I don\\'t think that is possible.\\nThe solution I came up with runs in N^2 and beats 71%."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rideau](/rideau) see [@Sergey TT](/SergeyTT)\\'s respose"
                    },
                    {
                        "username": "rideau",
                        "content": "Any updates? Im also interested "
                    },
                    {
                        "username": "sanjitj7",
                        "content": "EDIT: I have spotted my n00b mistake\n\nI think this test case is incorrect!\n\n>Input: nums = [2,10,6,14]\n>Output: -1\n>Explanation: It can be shown that it is impossible to make all the elements equal to 1\n\n[2,10,6,14]\n[2,10,3,14]  (i = 2)\n[2,10,3,1]   (i = 2)\n[2,10,1,1]\n[2,1,1,1]\n[1,1,1,1]\n\nThis caused a lot of confusion to me."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "oh scheisse, I was taking num/GCD there \\uD83D\\uDE05 "
                    },
                    {
                        "username": "srk696772",
                        "content": "Bro GCD(6,14) == 2 ,  \nnot 3"
                    },
                    {
                        "username": "bekbossyn_kassymkhan",
                        "content": "gcd(6 & 14) = 2 , gcd(10,6)=2 also \n:)"
                    },
                    {
                        "username": "gaurav1903",
                        "content": "What\\'s the O(N) solution??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The O(N) solution leverages the fact that if we can find two numbers in the array whose greatest common divisor (gcd) is 1, then the minimum number of operations required is the size of the array minus 1.\\n\\nTo achieve this in linear time, we can use the Sieve of Eratosthenes, a well-known algorithm for finding all prime numbers up to a given limit. This algorithm can be used to find the smallest prime factor for each number in the array, which is a prerequisite for finding two numbers with gcd 1.\\n\\nHere are the steps of the algorithm:\\n\\n1. Compute the smallest prime factor for each number up to max(nums) using the Sieve of Eratosthenes.\\n2. For each number in nums, if its smallest prime factor divides another number in nums, we can assume that the gcd of these two numbers is 1.\\n3. If we find such a pair, the minimum number of operations required is the size of the array minus 1.\\n4. If no such pair exists, we cannot make all elements equal to 1, so we return -1.\\n\\nNote: As the Sieve of Eratosthenes requires O(N log log N) time complexity, this solution is not strictly linear. However, it is significantly more efficient than an O(N^2) solution when dealing with large inputs.\\n\\nThis solution assumes that the input numbers are not too large (e.g., within the range of an integer). If the numbers can be very large, we need a different approach because the Sieve of Eratosthenes may not be feasible. For example, we could use a probabilistic algorithm to find a pair of numbers with gcd 1, but this would not guarantee a correct answer in all cases.\\n\\nAlso, it\\'s important to note that this approach doesn\\'t give the exact number of operations if no \"1\" is found in the array; it only checks for the possibility of making all elements equal to 1. Calculating the exact number of operations in such a case can be a more complex problem and is likely to require more than linear time."
                    },
                    {
                        "username": "ZX007java",
                        "content": "Good day ! Can anyone give me answer : why set [2, 6, 3, 4] have answer is equal 4, BUT SET [4, 2, 6, 3] have answer is equal 5 ???"
                    },
                    {
                        "username": "bparanj",
                        "content": "This discrepancy arises from the order in which we are allowed to perform the gcd operations on the array.\\n\\nFor the array [2, 6, 3, 4]:\\n\\n1. We can select index 2 (i.e., the number 3) and take the gcd with the number at index 3 (i.e., the number 4), and replace 3 with gcd(3, 4) = 1. Array becomes [2, 6, 1, 4].\\n2. We can then select index 1 (i.e., the number 6) and take the gcd with the number at index 2 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, 1, 1, 4].\\n3. Then, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 4].\\n4. Finally, select index 2 (i.e., the number 1) and take the gcd with the number at index 3 (i.e., the number 4), and replace 4 with gcd(1, 4) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 4.\\n\\nFor the array [4, 2, 6, 3]:\\n\\n1. We can select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array becomes [4, 2, 6, 3].\\n2. Repeat step 1. Array still is [4, 2, 6, 3].\\n3. Repeat step 1 again. Array still is [4, 2, 6, 3].\\n4. Finally, select index 3 (i.e., the number 3) and take the gcd with the number at index 2 (i.e., the number 6), and replace 3 with gcd(3, 6) = 3. Array becomes [4, 2, 6, 1].\\n5. Now, select index 0 (i.e., the number 4) and take the gcd with the number at index 1 (i.e., the number 2), and replace 4 with gcd(4, 2) = 2. Array becomes [2, 2, 6, 1].\\n6. Next, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array still is [2, 2, 6, 1].\\n7. Repeat step 6. Array still is [2, 2, 6, 1].\\n8. Repeat step 6 again. Array still is [2, 2, 6, 1].\\n9. Repeat step 6 once more. Array still is [2, 2, 6, 1].\\n10. Finally, select index 2 (i.e., the number 6) and take the gcd with the number at index 3 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, \\n\\n2, 1, 1].\\n11. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 2), and replace 2 with gcd(2, 2) = 2. Array still is [2, 2, 1, 1].\\n12. Repeat step 11. Array still is [2, 2, 1, 1].\\n13. Repeat step 11 again. Array still is [2, 2, 1, 1].\\n14. Finally, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [2, 1, 1, 1].\\n15. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 15.\\n\\nThis demonstrates how the order of the array can affect the total number of operations required to achieve all elements as 1. The most optimized way to get all elements to 1 can depend on the order of elements in the array."
                    },
                    {
                        "username": "ZX007java",
                        "content": "[@s_m99](/s_m99) THANK YOU !!! CONSECUTIVE !!!"
                    },
                    {
                        "username": "s_m99",
                        "content": "You can only calculate gcd\\'s of 2 **consecutive** numbers and replace either of them. So in set [4,2,6,3] to make 3 into 1 we require two operations instead of one in [2,6,3,4] "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn, that was a great problem but... Medium, really? Am I just getting dumber? \nTook me quite lot of time and tryhard to see the solution.\nAnd that's gotta be the lowest acceptance rate I've seen for a medium problem\n\nAlso, python has a built-in gcd function apparently. Lesson learned; next time, no need to face my anxieties trying to remember my number theory classes to implement the Euclidean algo myself"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "Anyone explain or hint"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "light hint: how many steps would it take to get your first one in the array? And once you have a one, how many more steps do you need to turn everything into a one?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I am not able to understand the question\\nit says \\nselect index i and change num[i] or num[i+1] with their GCD and people have used n^2 loop to check every pair"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the minimum number of operations required to make all elements of an array equal to 1, by replacing either nums[i] or nums[i+1] with their gcd (greatest common divisor).\\n\\nThe problem solution is implemented with an O(n^2) approach, and this is why:\\n\\n1. You iterate over each element in the array (first loop).\\n2. For each element, you check for a contiguous segment in the array where the gcd of the numbers in the segment equals 1 (second loop). If such a segment is found, you store the length of that segment minus 1 (because one element is already 1 and doesn\\'t need any operation).\\n3. The result of the algorithm is the minimum length of these segments (if any) plus the number of elements outside these segments (because each of these will need one operation to become 1, by taking the gcd with 1).\\n\\nThe algorithm needs to check all pairs of elements because the array isn\\'t necessarily sorted, and any pair (i, j) with i < j can potentially form a contiguous segment where the gcd of the numbers is 1. So, an element nums[i] might be replaced by the gcd of nums[i] and nums[j] for some j > i.\\n"
                    },
                    {
                        "username": "User___",
                        "content": "[@cartesPerforees](/cartesPerforees) Is that $$O(n)$$?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you understand the question, it's just the solutions that you don't understand.\nWe check every pair to find the closest elements that could lead to a gcd of 1. Then we propagate the gcd neighbor-by-neighbor"
                    }
                ]
            },
            {
                "id": 1871447,
                "content": [
                    {
                        "username": "rideau",
                        "content": "Does anybody know how solve this in O(1) time? Is this even possible?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Pay no attention to that follow-up. The person who wrote it was drunk."
                    },
                    {
                        "username": "User___",
                        "content": "Did you manage to solve it in $$O(n)$$? Just wondering, since you\\'re asking about $$O(1)$$ (which I feel isn\\'t possible)"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "I think it's quite easy to prove that it impossible to solve this problem in O(1) time complexity.\nImaging you have an array of length N, for which the asnwer is \"-1\" - that is, you cannot make all elements equal to 1 using any number of operations. Now, insert number \"1\" at a random index of the array, and now you can make all other numbers equal to 1. In order to find this \"1\" you need O(N) time complexity."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your reasoning is absolutely correct. As per the problem, you need to inspect each element of the array to determine if the number 1 is present or if a pair of numbers exists such that their greatest common divisor (gcd) is 1. This requires at least linear time, O(N), where N is the length of the array.\\n\\nAs you\\'ve aptly illustrated, the presence of a single 1 in the array changes the entire outcome of the problem. Without examining each element, we cannot determine the presence or absence of such a crucial value. This necessitates iterating through the array at least once, thereby confirming that the problem cannot be solved in constant time, O(1)."
                    },
                    {
                        "username": "SlickGeek",
                        "content": "\"...but could you find an O(1) constant time complexity solution?\" Is it actually possible to solve this problem in constant time? I don\\'t know if there\\'s something I am not seeing or understanding, but I don\\'t think that is possible.\\nThe solution I came up with runs in N^2 and beats 71%."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rideau](/rideau) see [@Sergey TT](/SergeyTT)\\'s respose"
                    },
                    {
                        "username": "rideau",
                        "content": "Any updates? Im also interested "
                    },
                    {
                        "username": "sanjitj7",
                        "content": "EDIT: I have spotted my n00b mistake\n\nI think this test case is incorrect!\n\n>Input: nums = [2,10,6,14]\n>Output: -1\n>Explanation: It can be shown that it is impossible to make all the elements equal to 1\n\n[2,10,6,14]\n[2,10,3,14]  (i = 2)\n[2,10,3,1]   (i = 2)\n[2,10,1,1]\n[2,1,1,1]\n[1,1,1,1]\n\nThis caused a lot of confusion to me."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "oh scheisse, I was taking num/GCD there \\uD83D\\uDE05 "
                    },
                    {
                        "username": "srk696772",
                        "content": "Bro GCD(6,14) == 2 ,  \nnot 3"
                    },
                    {
                        "username": "bekbossyn_kassymkhan",
                        "content": "gcd(6 & 14) = 2 , gcd(10,6)=2 also \n:)"
                    },
                    {
                        "username": "gaurav1903",
                        "content": "What\\'s the O(N) solution??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The O(N) solution leverages the fact that if we can find two numbers in the array whose greatest common divisor (gcd) is 1, then the minimum number of operations required is the size of the array minus 1.\\n\\nTo achieve this in linear time, we can use the Sieve of Eratosthenes, a well-known algorithm for finding all prime numbers up to a given limit. This algorithm can be used to find the smallest prime factor for each number in the array, which is a prerequisite for finding two numbers with gcd 1.\\n\\nHere are the steps of the algorithm:\\n\\n1. Compute the smallest prime factor for each number up to max(nums) using the Sieve of Eratosthenes.\\n2. For each number in nums, if its smallest prime factor divides another number in nums, we can assume that the gcd of these two numbers is 1.\\n3. If we find such a pair, the minimum number of operations required is the size of the array minus 1.\\n4. If no such pair exists, we cannot make all elements equal to 1, so we return -1.\\n\\nNote: As the Sieve of Eratosthenes requires O(N log log N) time complexity, this solution is not strictly linear. However, it is significantly more efficient than an O(N^2) solution when dealing with large inputs.\\n\\nThis solution assumes that the input numbers are not too large (e.g., within the range of an integer). If the numbers can be very large, we need a different approach because the Sieve of Eratosthenes may not be feasible. For example, we could use a probabilistic algorithm to find a pair of numbers with gcd 1, but this would not guarantee a correct answer in all cases.\\n\\nAlso, it\\'s important to note that this approach doesn\\'t give the exact number of operations if no \"1\" is found in the array; it only checks for the possibility of making all elements equal to 1. Calculating the exact number of operations in such a case can be a more complex problem and is likely to require more than linear time."
                    },
                    {
                        "username": "ZX007java",
                        "content": "Good day ! Can anyone give me answer : why set [2, 6, 3, 4] have answer is equal 4, BUT SET [4, 2, 6, 3] have answer is equal 5 ???"
                    },
                    {
                        "username": "bparanj",
                        "content": "This discrepancy arises from the order in which we are allowed to perform the gcd operations on the array.\\n\\nFor the array [2, 6, 3, 4]:\\n\\n1. We can select index 2 (i.e., the number 3) and take the gcd with the number at index 3 (i.e., the number 4), and replace 3 with gcd(3, 4) = 1. Array becomes [2, 6, 1, 4].\\n2. We can then select index 1 (i.e., the number 6) and take the gcd with the number at index 2 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, 1, 1, 4].\\n3. Then, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 4].\\n4. Finally, select index 2 (i.e., the number 1) and take the gcd with the number at index 3 (i.e., the number 4), and replace 4 with gcd(1, 4) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 4.\\n\\nFor the array [4, 2, 6, 3]:\\n\\n1. We can select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array becomes [4, 2, 6, 3].\\n2. Repeat step 1. Array still is [4, 2, 6, 3].\\n3. Repeat step 1 again. Array still is [4, 2, 6, 3].\\n4. Finally, select index 3 (i.e., the number 3) and take the gcd with the number at index 2 (i.e., the number 6), and replace 3 with gcd(3, 6) = 3. Array becomes [4, 2, 6, 1].\\n5. Now, select index 0 (i.e., the number 4) and take the gcd with the number at index 1 (i.e., the number 2), and replace 4 with gcd(4, 2) = 2. Array becomes [2, 2, 6, 1].\\n6. Next, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array still is [2, 2, 6, 1].\\n7. Repeat step 6. Array still is [2, 2, 6, 1].\\n8. Repeat step 6 again. Array still is [2, 2, 6, 1].\\n9. Repeat step 6 once more. Array still is [2, 2, 6, 1].\\n10. Finally, select index 2 (i.e., the number 6) and take the gcd with the number at index 3 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, \\n\\n2, 1, 1].\\n11. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 2), and replace 2 with gcd(2, 2) = 2. Array still is [2, 2, 1, 1].\\n12. Repeat step 11. Array still is [2, 2, 1, 1].\\n13. Repeat step 11 again. Array still is [2, 2, 1, 1].\\n14. Finally, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [2, 1, 1, 1].\\n15. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 15.\\n\\nThis demonstrates how the order of the array can affect the total number of operations required to achieve all elements as 1. The most optimized way to get all elements to 1 can depend on the order of elements in the array."
                    },
                    {
                        "username": "ZX007java",
                        "content": "[@s_m99](/s_m99) THANK YOU !!! CONSECUTIVE !!!"
                    },
                    {
                        "username": "s_m99",
                        "content": "You can only calculate gcd\\'s of 2 **consecutive** numbers and replace either of them. So in set [4,2,6,3] to make 3 into 1 we require two operations instead of one in [2,6,3,4] "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn, that was a great problem but... Medium, really? Am I just getting dumber? \nTook me quite lot of time and tryhard to see the solution.\nAnd that's gotta be the lowest acceptance rate I've seen for a medium problem\n\nAlso, python has a built-in gcd function apparently. Lesson learned; next time, no need to face my anxieties trying to remember my number theory classes to implement the Euclidean algo myself"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "Anyone explain or hint"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "light hint: how many steps would it take to get your first one in the array? And once you have a one, how many more steps do you need to turn everything into a one?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I am not able to understand the question\\nit says \\nselect index i and change num[i] or num[i+1] with their GCD and people have used n^2 loop to check every pair"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the minimum number of operations required to make all elements of an array equal to 1, by replacing either nums[i] or nums[i+1] with their gcd (greatest common divisor).\\n\\nThe problem solution is implemented with an O(n^2) approach, and this is why:\\n\\n1. You iterate over each element in the array (first loop).\\n2. For each element, you check for a contiguous segment in the array where the gcd of the numbers in the segment equals 1 (second loop). If such a segment is found, you store the length of that segment minus 1 (because one element is already 1 and doesn\\'t need any operation).\\n3. The result of the algorithm is the minimum length of these segments (if any) plus the number of elements outside these segments (because each of these will need one operation to become 1, by taking the gcd with 1).\\n\\nThe algorithm needs to check all pairs of elements because the array isn\\'t necessarily sorted, and any pair (i, j) with i < j can potentially form a contiguous segment where the gcd of the numbers is 1. So, an element nums[i] might be replaced by the gcd of nums[i] and nums[j] for some j > i.\\n"
                    },
                    {
                        "username": "User___",
                        "content": "[@cartesPerforees](/cartesPerforees) Is that $$O(n)$$?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you understand the question, it's just the solutions that you don't understand.\nWe check every pair to find the closest elements that could lead to a gcd of 1. Then we propagate the gcd neighbor-by-neighbor"
                    }
                ]
            },
            {
                "id": 1898536,
                "content": [
                    {
                        "username": "rideau",
                        "content": "Does anybody know how solve this in O(1) time? Is this even possible?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Pay no attention to that follow-up. The person who wrote it was drunk."
                    },
                    {
                        "username": "User___",
                        "content": "Did you manage to solve it in $$O(n)$$? Just wondering, since you\\'re asking about $$O(1)$$ (which I feel isn\\'t possible)"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "I think it's quite easy to prove that it impossible to solve this problem in O(1) time complexity.\nImaging you have an array of length N, for which the asnwer is \"-1\" - that is, you cannot make all elements equal to 1 using any number of operations. Now, insert number \"1\" at a random index of the array, and now you can make all other numbers equal to 1. In order to find this \"1\" you need O(N) time complexity."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your reasoning is absolutely correct. As per the problem, you need to inspect each element of the array to determine if the number 1 is present or if a pair of numbers exists such that their greatest common divisor (gcd) is 1. This requires at least linear time, O(N), where N is the length of the array.\\n\\nAs you\\'ve aptly illustrated, the presence of a single 1 in the array changes the entire outcome of the problem. Without examining each element, we cannot determine the presence or absence of such a crucial value. This necessitates iterating through the array at least once, thereby confirming that the problem cannot be solved in constant time, O(1)."
                    },
                    {
                        "username": "SlickGeek",
                        "content": "\"...but could you find an O(1) constant time complexity solution?\" Is it actually possible to solve this problem in constant time? I don\\'t know if there\\'s something I am not seeing or understanding, but I don\\'t think that is possible.\\nThe solution I came up with runs in N^2 and beats 71%."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rideau](/rideau) see [@Sergey TT](/SergeyTT)\\'s respose"
                    },
                    {
                        "username": "rideau",
                        "content": "Any updates? Im also interested "
                    },
                    {
                        "username": "sanjitj7",
                        "content": "EDIT: I have spotted my n00b mistake\n\nI think this test case is incorrect!\n\n>Input: nums = [2,10,6,14]\n>Output: -1\n>Explanation: It can be shown that it is impossible to make all the elements equal to 1\n\n[2,10,6,14]\n[2,10,3,14]  (i = 2)\n[2,10,3,1]   (i = 2)\n[2,10,1,1]\n[2,1,1,1]\n[1,1,1,1]\n\nThis caused a lot of confusion to me."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "oh scheisse, I was taking num/GCD there \\uD83D\\uDE05 "
                    },
                    {
                        "username": "srk696772",
                        "content": "Bro GCD(6,14) == 2 ,  \nnot 3"
                    },
                    {
                        "username": "bekbossyn_kassymkhan",
                        "content": "gcd(6 & 14) = 2 , gcd(10,6)=2 also \n:)"
                    },
                    {
                        "username": "gaurav1903",
                        "content": "What\\'s the O(N) solution??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The O(N) solution leverages the fact that if we can find two numbers in the array whose greatest common divisor (gcd) is 1, then the minimum number of operations required is the size of the array minus 1.\\n\\nTo achieve this in linear time, we can use the Sieve of Eratosthenes, a well-known algorithm for finding all prime numbers up to a given limit. This algorithm can be used to find the smallest prime factor for each number in the array, which is a prerequisite for finding two numbers with gcd 1.\\n\\nHere are the steps of the algorithm:\\n\\n1. Compute the smallest prime factor for each number up to max(nums) using the Sieve of Eratosthenes.\\n2. For each number in nums, if its smallest prime factor divides another number in nums, we can assume that the gcd of these two numbers is 1.\\n3. If we find such a pair, the minimum number of operations required is the size of the array minus 1.\\n4. If no such pair exists, we cannot make all elements equal to 1, so we return -1.\\n\\nNote: As the Sieve of Eratosthenes requires O(N log log N) time complexity, this solution is not strictly linear. However, it is significantly more efficient than an O(N^2) solution when dealing with large inputs.\\n\\nThis solution assumes that the input numbers are not too large (e.g., within the range of an integer). If the numbers can be very large, we need a different approach because the Sieve of Eratosthenes may not be feasible. For example, we could use a probabilistic algorithm to find a pair of numbers with gcd 1, but this would not guarantee a correct answer in all cases.\\n\\nAlso, it\\'s important to note that this approach doesn\\'t give the exact number of operations if no \"1\" is found in the array; it only checks for the possibility of making all elements equal to 1. Calculating the exact number of operations in such a case can be a more complex problem and is likely to require more than linear time."
                    },
                    {
                        "username": "ZX007java",
                        "content": "Good day ! Can anyone give me answer : why set [2, 6, 3, 4] have answer is equal 4, BUT SET [4, 2, 6, 3] have answer is equal 5 ???"
                    },
                    {
                        "username": "bparanj",
                        "content": "This discrepancy arises from the order in which we are allowed to perform the gcd operations on the array.\\n\\nFor the array [2, 6, 3, 4]:\\n\\n1. We can select index 2 (i.e., the number 3) and take the gcd with the number at index 3 (i.e., the number 4), and replace 3 with gcd(3, 4) = 1. Array becomes [2, 6, 1, 4].\\n2. We can then select index 1 (i.e., the number 6) and take the gcd with the number at index 2 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, 1, 1, 4].\\n3. Then, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 4].\\n4. Finally, select index 2 (i.e., the number 1) and take the gcd with the number at index 3 (i.e., the number 4), and replace 4 with gcd(1, 4) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 4.\\n\\nFor the array [4, 2, 6, 3]:\\n\\n1. We can select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array becomes [4, 2, 6, 3].\\n2. Repeat step 1. Array still is [4, 2, 6, 3].\\n3. Repeat step 1 again. Array still is [4, 2, 6, 3].\\n4. Finally, select index 3 (i.e., the number 3) and take the gcd with the number at index 2 (i.e., the number 6), and replace 3 with gcd(3, 6) = 3. Array becomes [4, 2, 6, 1].\\n5. Now, select index 0 (i.e., the number 4) and take the gcd with the number at index 1 (i.e., the number 2), and replace 4 with gcd(4, 2) = 2. Array becomes [2, 2, 6, 1].\\n6. Next, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array still is [2, 2, 6, 1].\\n7. Repeat step 6. Array still is [2, 2, 6, 1].\\n8. Repeat step 6 again. Array still is [2, 2, 6, 1].\\n9. Repeat step 6 once more. Array still is [2, 2, 6, 1].\\n10. Finally, select index 2 (i.e., the number 6) and take the gcd with the number at index 3 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, \\n\\n2, 1, 1].\\n11. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 2), and replace 2 with gcd(2, 2) = 2. Array still is [2, 2, 1, 1].\\n12. Repeat step 11. Array still is [2, 2, 1, 1].\\n13. Repeat step 11 again. Array still is [2, 2, 1, 1].\\n14. Finally, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [2, 1, 1, 1].\\n15. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 15.\\n\\nThis demonstrates how the order of the array can affect the total number of operations required to achieve all elements as 1. The most optimized way to get all elements to 1 can depend on the order of elements in the array."
                    },
                    {
                        "username": "ZX007java",
                        "content": "[@s_m99](/s_m99) THANK YOU !!! CONSECUTIVE !!!"
                    },
                    {
                        "username": "s_m99",
                        "content": "You can only calculate gcd\\'s of 2 **consecutive** numbers and replace either of them. So in set [4,2,6,3] to make 3 into 1 we require two operations instead of one in [2,6,3,4] "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn, that was a great problem but... Medium, really? Am I just getting dumber? \nTook me quite lot of time and tryhard to see the solution.\nAnd that's gotta be the lowest acceptance rate I've seen for a medium problem\n\nAlso, python has a built-in gcd function apparently. Lesson learned; next time, no need to face my anxieties trying to remember my number theory classes to implement the Euclidean algo myself"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "Anyone explain or hint"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "light hint: how many steps would it take to get your first one in the array? And once you have a one, how many more steps do you need to turn everything into a one?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I am not able to understand the question\\nit says \\nselect index i and change num[i] or num[i+1] with their GCD and people have used n^2 loop to check every pair"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the minimum number of operations required to make all elements of an array equal to 1, by replacing either nums[i] or nums[i+1] with their gcd (greatest common divisor).\\n\\nThe problem solution is implemented with an O(n^2) approach, and this is why:\\n\\n1. You iterate over each element in the array (first loop).\\n2. For each element, you check for a contiguous segment in the array where the gcd of the numbers in the segment equals 1 (second loop). If such a segment is found, you store the length of that segment minus 1 (because one element is already 1 and doesn\\'t need any operation).\\n3. The result of the algorithm is the minimum length of these segments (if any) plus the number of elements outside these segments (because each of these will need one operation to become 1, by taking the gcd with 1).\\n\\nThe algorithm needs to check all pairs of elements because the array isn\\'t necessarily sorted, and any pair (i, j) with i < j can potentially form a contiguous segment where the gcd of the numbers is 1. So, an element nums[i] might be replaced by the gcd of nums[i] and nums[j] for some j > i.\\n"
                    },
                    {
                        "username": "User___",
                        "content": "[@cartesPerforees](/cartesPerforees) Is that $$O(n)$$?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you understand the question, it's just the solutions that you don't understand.\nWe check every pair to find the closest elements that could lead to a gcd of 1. Then we propagate the gcd neighbor-by-neighbor"
                    }
                ]
            },
            {
                "id": 1880916,
                "content": [
                    {
                        "username": "rideau",
                        "content": "Does anybody know how solve this in O(1) time? Is this even possible?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Pay no attention to that follow-up. The person who wrote it was drunk."
                    },
                    {
                        "username": "User___",
                        "content": "Did you manage to solve it in $$O(n)$$? Just wondering, since you\\'re asking about $$O(1)$$ (which I feel isn\\'t possible)"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "I think it's quite easy to prove that it impossible to solve this problem in O(1) time complexity.\nImaging you have an array of length N, for which the asnwer is \"-1\" - that is, you cannot make all elements equal to 1 using any number of operations. Now, insert number \"1\" at a random index of the array, and now you can make all other numbers equal to 1. In order to find this \"1\" you need O(N) time complexity."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your reasoning is absolutely correct. As per the problem, you need to inspect each element of the array to determine if the number 1 is present or if a pair of numbers exists such that their greatest common divisor (gcd) is 1. This requires at least linear time, O(N), where N is the length of the array.\\n\\nAs you\\'ve aptly illustrated, the presence of a single 1 in the array changes the entire outcome of the problem. Without examining each element, we cannot determine the presence or absence of such a crucial value. This necessitates iterating through the array at least once, thereby confirming that the problem cannot be solved in constant time, O(1)."
                    },
                    {
                        "username": "SlickGeek",
                        "content": "\"...but could you find an O(1) constant time complexity solution?\" Is it actually possible to solve this problem in constant time? I don\\'t know if there\\'s something I am not seeing or understanding, but I don\\'t think that is possible.\\nThe solution I came up with runs in N^2 and beats 71%."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rideau](/rideau) see [@Sergey TT](/SergeyTT)\\'s respose"
                    },
                    {
                        "username": "rideau",
                        "content": "Any updates? Im also interested "
                    },
                    {
                        "username": "sanjitj7",
                        "content": "EDIT: I have spotted my n00b mistake\n\nI think this test case is incorrect!\n\n>Input: nums = [2,10,6,14]\n>Output: -1\n>Explanation: It can be shown that it is impossible to make all the elements equal to 1\n\n[2,10,6,14]\n[2,10,3,14]  (i = 2)\n[2,10,3,1]   (i = 2)\n[2,10,1,1]\n[2,1,1,1]\n[1,1,1,1]\n\nThis caused a lot of confusion to me."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "oh scheisse, I was taking num/GCD there \\uD83D\\uDE05 "
                    },
                    {
                        "username": "srk696772",
                        "content": "Bro GCD(6,14) == 2 ,  \nnot 3"
                    },
                    {
                        "username": "bekbossyn_kassymkhan",
                        "content": "gcd(6 & 14) = 2 , gcd(10,6)=2 also \n:)"
                    },
                    {
                        "username": "gaurav1903",
                        "content": "What\\'s the O(N) solution??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The O(N) solution leverages the fact that if we can find two numbers in the array whose greatest common divisor (gcd) is 1, then the minimum number of operations required is the size of the array minus 1.\\n\\nTo achieve this in linear time, we can use the Sieve of Eratosthenes, a well-known algorithm for finding all prime numbers up to a given limit. This algorithm can be used to find the smallest prime factor for each number in the array, which is a prerequisite for finding two numbers with gcd 1.\\n\\nHere are the steps of the algorithm:\\n\\n1. Compute the smallest prime factor for each number up to max(nums) using the Sieve of Eratosthenes.\\n2. For each number in nums, if its smallest prime factor divides another number in nums, we can assume that the gcd of these two numbers is 1.\\n3. If we find such a pair, the minimum number of operations required is the size of the array minus 1.\\n4. If no such pair exists, we cannot make all elements equal to 1, so we return -1.\\n\\nNote: As the Sieve of Eratosthenes requires O(N log log N) time complexity, this solution is not strictly linear. However, it is significantly more efficient than an O(N^2) solution when dealing with large inputs.\\n\\nThis solution assumes that the input numbers are not too large (e.g., within the range of an integer). If the numbers can be very large, we need a different approach because the Sieve of Eratosthenes may not be feasible. For example, we could use a probabilistic algorithm to find a pair of numbers with gcd 1, but this would not guarantee a correct answer in all cases.\\n\\nAlso, it\\'s important to note that this approach doesn\\'t give the exact number of operations if no \"1\" is found in the array; it only checks for the possibility of making all elements equal to 1. Calculating the exact number of operations in such a case can be a more complex problem and is likely to require more than linear time."
                    },
                    {
                        "username": "ZX007java",
                        "content": "Good day ! Can anyone give me answer : why set [2, 6, 3, 4] have answer is equal 4, BUT SET [4, 2, 6, 3] have answer is equal 5 ???"
                    },
                    {
                        "username": "bparanj",
                        "content": "This discrepancy arises from the order in which we are allowed to perform the gcd operations on the array.\\n\\nFor the array [2, 6, 3, 4]:\\n\\n1. We can select index 2 (i.e., the number 3) and take the gcd with the number at index 3 (i.e., the number 4), and replace 3 with gcd(3, 4) = 1. Array becomes [2, 6, 1, 4].\\n2. We can then select index 1 (i.e., the number 6) and take the gcd with the number at index 2 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, 1, 1, 4].\\n3. Then, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 4].\\n4. Finally, select index 2 (i.e., the number 1) and take the gcd with the number at index 3 (i.e., the number 4), and replace 4 with gcd(1, 4) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 4.\\n\\nFor the array [4, 2, 6, 3]:\\n\\n1. We can select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array becomes [4, 2, 6, 3].\\n2. Repeat step 1. Array still is [4, 2, 6, 3].\\n3. Repeat step 1 again. Array still is [4, 2, 6, 3].\\n4. Finally, select index 3 (i.e., the number 3) and take the gcd with the number at index 2 (i.e., the number 6), and replace 3 with gcd(3, 6) = 3. Array becomes [4, 2, 6, 1].\\n5. Now, select index 0 (i.e., the number 4) and take the gcd with the number at index 1 (i.e., the number 2), and replace 4 with gcd(4, 2) = 2. Array becomes [2, 2, 6, 1].\\n6. Next, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array still is [2, 2, 6, 1].\\n7. Repeat step 6. Array still is [2, 2, 6, 1].\\n8. Repeat step 6 again. Array still is [2, 2, 6, 1].\\n9. Repeat step 6 once more. Array still is [2, 2, 6, 1].\\n10. Finally, select index 2 (i.e., the number 6) and take the gcd with the number at index 3 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, \\n\\n2, 1, 1].\\n11. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 2), and replace 2 with gcd(2, 2) = 2. Array still is [2, 2, 1, 1].\\n12. Repeat step 11. Array still is [2, 2, 1, 1].\\n13. Repeat step 11 again. Array still is [2, 2, 1, 1].\\n14. Finally, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [2, 1, 1, 1].\\n15. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 15.\\n\\nThis demonstrates how the order of the array can affect the total number of operations required to achieve all elements as 1. The most optimized way to get all elements to 1 can depend on the order of elements in the array."
                    },
                    {
                        "username": "ZX007java",
                        "content": "[@s_m99](/s_m99) THANK YOU !!! CONSECUTIVE !!!"
                    },
                    {
                        "username": "s_m99",
                        "content": "You can only calculate gcd\\'s of 2 **consecutive** numbers and replace either of them. So in set [4,2,6,3] to make 3 into 1 we require two operations instead of one in [2,6,3,4] "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn, that was a great problem but... Medium, really? Am I just getting dumber? \nTook me quite lot of time and tryhard to see the solution.\nAnd that's gotta be the lowest acceptance rate I've seen for a medium problem\n\nAlso, python has a built-in gcd function apparently. Lesson learned; next time, no need to face my anxieties trying to remember my number theory classes to implement the Euclidean algo myself"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "Anyone explain or hint"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "light hint: how many steps would it take to get your first one in the array? And once you have a one, how many more steps do you need to turn everything into a one?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I am not able to understand the question\\nit says \\nselect index i and change num[i] or num[i+1] with their GCD and people have used n^2 loop to check every pair"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the minimum number of operations required to make all elements of an array equal to 1, by replacing either nums[i] or nums[i+1] with their gcd (greatest common divisor).\\n\\nThe problem solution is implemented with an O(n^2) approach, and this is why:\\n\\n1. You iterate over each element in the array (first loop).\\n2. For each element, you check for a contiguous segment in the array where the gcd of the numbers in the segment equals 1 (second loop). If such a segment is found, you store the length of that segment minus 1 (because one element is already 1 and doesn\\'t need any operation).\\n3. The result of the algorithm is the minimum length of these segments (if any) plus the number of elements outside these segments (because each of these will need one operation to become 1, by taking the gcd with 1).\\n\\nThe algorithm needs to check all pairs of elements because the array isn\\'t necessarily sorted, and any pair (i, j) with i < j can potentially form a contiguous segment where the gcd of the numbers is 1. So, an element nums[i] might be replaced by the gcd of nums[i] and nums[j] for some j > i.\\n"
                    },
                    {
                        "username": "User___",
                        "content": "[@cartesPerforees](/cartesPerforees) Is that $$O(n)$$?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you understand the question, it's just the solutions that you don't understand.\nWe check every pair to find the closest elements that could lead to a gcd of 1. Then we propagate the gcd neighbor-by-neighbor"
                    }
                ]
            },
            {
                "id": 1872644,
                "content": [
                    {
                        "username": "rideau",
                        "content": "Does anybody know how solve this in O(1) time? Is this even possible?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Pay no attention to that follow-up. The person who wrote it was drunk."
                    },
                    {
                        "username": "User___",
                        "content": "Did you manage to solve it in $$O(n)$$? Just wondering, since you\\'re asking about $$O(1)$$ (which I feel isn\\'t possible)"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "I think it's quite easy to prove that it impossible to solve this problem in O(1) time complexity.\nImaging you have an array of length N, for which the asnwer is \"-1\" - that is, you cannot make all elements equal to 1 using any number of operations. Now, insert number \"1\" at a random index of the array, and now you can make all other numbers equal to 1. In order to find this \"1\" you need O(N) time complexity."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your reasoning is absolutely correct. As per the problem, you need to inspect each element of the array to determine if the number 1 is present or if a pair of numbers exists such that their greatest common divisor (gcd) is 1. This requires at least linear time, O(N), where N is the length of the array.\\n\\nAs you\\'ve aptly illustrated, the presence of a single 1 in the array changes the entire outcome of the problem. Without examining each element, we cannot determine the presence or absence of such a crucial value. This necessitates iterating through the array at least once, thereby confirming that the problem cannot be solved in constant time, O(1)."
                    },
                    {
                        "username": "SlickGeek",
                        "content": "\"...but could you find an O(1) constant time complexity solution?\" Is it actually possible to solve this problem in constant time? I don\\'t know if there\\'s something I am not seeing or understanding, but I don\\'t think that is possible.\\nThe solution I came up with runs in N^2 and beats 71%."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rideau](/rideau) see [@Sergey TT](/SergeyTT)\\'s respose"
                    },
                    {
                        "username": "rideau",
                        "content": "Any updates? Im also interested "
                    },
                    {
                        "username": "sanjitj7",
                        "content": "EDIT: I have spotted my n00b mistake\n\nI think this test case is incorrect!\n\n>Input: nums = [2,10,6,14]\n>Output: -1\n>Explanation: It can be shown that it is impossible to make all the elements equal to 1\n\n[2,10,6,14]\n[2,10,3,14]  (i = 2)\n[2,10,3,1]   (i = 2)\n[2,10,1,1]\n[2,1,1,1]\n[1,1,1,1]\n\nThis caused a lot of confusion to me."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "oh scheisse, I was taking num/GCD there \\uD83D\\uDE05 "
                    },
                    {
                        "username": "srk696772",
                        "content": "Bro GCD(6,14) == 2 ,  \nnot 3"
                    },
                    {
                        "username": "bekbossyn_kassymkhan",
                        "content": "gcd(6 & 14) = 2 , gcd(10,6)=2 also \n:)"
                    },
                    {
                        "username": "gaurav1903",
                        "content": "What\\'s the O(N) solution??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The O(N) solution leverages the fact that if we can find two numbers in the array whose greatest common divisor (gcd) is 1, then the minimum number of operations required is the size of the array minus 1.\\n\\nTo achieve this in linear time, we can use the Sieve of Eratosthenes, a well-known algorithm for finding all prime numbers up to a given limit. This algorithm can be used to find the smallest prime factor for each number in the array, which is a prerequisite for finding two numbers with gcd 1.\\n\\nHere are the steps of the algorithm:\\n\\n1. Compute the smallest prime factor for each number up to max(nums) using the Sieve of Eratosthenes.\\n2. For each number in nums, if its smallest prime factor divides another number in nums, we can assume that the gcd of these two numbers is 1.\\n3. If we find such a pair, the minimum number of operations required is the size of the array minus 1.\\n4. If no such pair exists, we cannot make all elements equal to 1, so we return -1.\\n\\nNote: As the Sieve of Eratosthenes requires O(N log log N) time complexity, this solution is not strictly linear. However, it is significantly more efficient than an O(N^2) solution when dealing with large inputs.\\n\\nThis solution assumes that the input numbers are not too large (e.g., within the range of an integer). If the numbers can be very large, we need a different approach because the Sieve of Eratosthenes may not be feasible. For example, we could use a probabilistic algorithm to find a pair of numbers with gcd 1, but this would not guarantee a correct answer in all cases.\\n\\nAlso, it\\'s important to note that this approach doesn\\'t give the exact number of operations if no \"1\" is found in the array; it only checks for the possibility of making all elements equal to 1. Calculating the exact number of operations in such a case can be a more complex problem and is likely to require more than linear time."
                    },
                    {
                        "username": "ZX007java",
                        "content": "Good day ! Can anyone give me answer : why set [2, 6, 3, 4] have answer is equal 4, BUT SET [4, 2, 6, 3] have answer is equal 5 ???"
                    },
                    {
                        "username": "bparanj",
                        "content": "This discrepancy arises from the order in which we are allowed to perform the gcd operations on the array.\\n\\nFor the array [2, 6, 3, 4]:\\n\\n1. We can select index 2 (i.e., the number 3) and take the gcd with the number at index 3 (i.e., the number 4), and replace 3 with gcd(3, 4) = 1. Array becomes [2, 6, 1, 4].\\n2. We can then select index 1 (i.e., the number 6) and take the gcd with the number at index 2 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, 1, 1, 4].\\n3. Then, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 4].\\n4. Finally, select index 2 (i.e., the number 1) and take the gcd with the number at index 3 (i.e., the number 4), and replace 4 with gcd(1, 4) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 4.\\n\\nFor the array [4, 2, 6, 3]:\\n\\n1. We can select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array becomes [4, 2, 6, 3].\\n2. Repeat step 1. Array still is [4, 2, 6, 3].\\n3. Repeat step 1 again. Array still is [4, 2, 6, 3].\\n4. Finally, select index 3 (i.e., the number 3) and take the gcd with the number at index 2 (i.e., the number 6), and replace 3 with gcd(3, 6) = 3. Array becomes [4, 2, 6, 1].\\n5. Now, select index 0 (i.e., the number 4) and take the gcd with the number at index 1 (i.e., the number 2), and replace 4 with gcd(4, 2) = 2. Array becomes [2, 2, 6, 1].\\n6. Next, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array still is [2, 2, 6, 1].\\n7. Repeat step 6. Array still is [2, 2, 6, 1].\\n8. Repeat step 6 again. Array still is [2, 2, 6, 1].\\n9. Repeat step 6 once more. Array still is [2, 2, 6, 1].\\n10. Finally, select index 2 (i.e., the number 6) and take the gcd with the number at index 3 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, \\n\\n2, 1, 1].\\n11. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 2), and replace 2 with gcd(2, 2) = 2. Array still is [2, 2, 1, 1].\\n12. Repeat step 11. Array still is [2, 2, 1, 1].\\n13. Repeat step 11 again. Array still is [2, 2, 1, 1].\\n14. Finally, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [2, 1, 1, 1].\\n15. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 15.\\n\\nThis demonstrates how the order of the array can affect the total number of operations required to achieve all elements as 1. The most optimized way to get all elements to 1 can depend on the order of elements in the array."
                    },
                    {
                        "username": "ZX007java",
                        "content": "[@s_m99](/s_m99) THANK YOU !!! CONSECUTIVE !!!"
                    },
                    {
                        "username": "s_m99",
                        "content": "You can only calculate gcd\\'s of 2 **consecutive** numbers and replace either of them. So in set [4,2,6,3] to make 3 into 1 we require two operations instead of one in [2,6,3,4] "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn, that was a great problem but... Medium, really? Am I just getting dumber? \nTook me quite lot of time and tryhard to see the solution.\nAnd that's gotta be the lowest acceptance rate I've seen for a medium problem\n\nAlso, python has a built-in gcd function apparently. Lesson learned; next time, no need to face my anxieties trying to remember my number theory classes to implement the Euclidean algo myself"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "Anyone explain or hint"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "light hint: how many steps would it take to get your first one in the array? And once you have a one, how many more steps do you need to turn everything into a one?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I am not able to understand the question\\nit says \\nselect index i and change num[i] or num[i+1] with their GCD and people have used n^2 loop to check every pair"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the minimum number of operations required to make all elements of an array equal to 1, by replacing either nums[i] or nums[i+1] with their gcd (greatest common divisor).\\n\\nThe problem solution is implemented with an O(n^2) approach, and this is why:\\n\\n1. You iterate over each element in the array (first loop).\\n2. For each element, you check for a contiguous segment in the array where the gcd of the numbers in the segment equals 1 (second loop). If such a segment is found, you store the length of that segment minus 1 (because one element is already 1 and doesn\\'t need any operation).\\n3. The result of the algorithm is the minimum length of these segments (if any) plus the number of elements outside these segments (because each of these will need one operation to become 1, by taking the gcd with 1).\\n\\nThe algorithm needs to check all pairs of elements because the array isn\\'t necessarily sorted, and any pair (i, j) with i < j can potentially form a contiguous segment where the gcd of the numbers is 1. So, an element nums[i] might be replaced by the gcd of nums[i] and nums[j] for some j > i.\\n"
                    },
                    {
                        "username": "User___",
                        "content": "[@cartesPerforees](/cartesPerforees) Is that $$O(n)$$?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you understand the question, it's just the solutions that you don't understand.\nWe check every pair to find the closest elements that could lead to a gcd of 1. Then we propagate the gcd neighbor-by-neighbor"
                    }
                ]
            },
            {
                "id": 1871729,
                "content": [
                    {
                        "username": "rideau",
                        "content": "Does anybody know how solve this in O(1) time? Is this even possible?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Pay no attention to that follow-up. The person who wrote it was drunk."
                    },
                    {
                        "username": "User___",
                        "content": "Did you manage to solve it in $$O(n)$$? Just wondering, since you\\'re asking about $$O(1)$$ (which I feel isn\\'t possible)"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "I think it's quite easy to prove that it impossible to solve this problem in O(1) time complexity.\nImaging you have an array of length N, for which the asnwer is \"-1\" - that is, you cannot make all elements equal to 1 using any number of operations. Now, insert number \"1\" at a random index of the array, and now you can make all other numbers equal to 1. In order to find this \"1\" you need O(N) time complexity."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your reasoning is absolutely correct. As per the problem, you need to inspect each element of the array to determine if the number 1 is present or if a pair of numbers exists such that their greatest common divisor (gcd) is 1. This requires at least linear time, O(N), where N is the length of the array.\\n\\nAs you\\'ve aptly illustrated, the presence of a single 1 in the array changes the entire outcome of the problem. Without examining each element, we cannot determine the presence or absence of such a crucial value. This necessitates iterating through the array at least once, thereby confirming that the problem cannot be solved in constant time, O(1)."
                    },
                    {
                        "username": "SlickGeek",
                        "content": "\"...but could you find an O(1) constant time complexity solution?\" Is it actually possible to solve this problem in constant time? I don\\'t know if there\\'s something I am not seeing or understanding, but I don\\'t think that is possible.\\nThe solution I came up with runs in N^2 and beats 71%."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rideau](/rideau) see [@Sergey TT](/SergeyTT)\\'s respose"
                    },
                    {
                        "username": "rideau",
                        "content": "Any updates? Im also interested "
                    },
                    {
                        "username": "sanjitj7",
                        "content": "EDIT: I have spotted my n00b mistake\n\nI think this test case is incorrect!\n\n>Input: nums = [2,10,6,14]\n>Output: -1\n>Explanation: It can be shown that it is impossible to make all the elements equal to 1\n\n[2,10,6,14]\n[2,10,3,14]  (i = 2)\n[2,10,3,1]   (i = 2)\n[2,10,1,1]\n[2,1,1,1]\n[1,1,1,1]\n\nThis caused a lot of confusion to me."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "oh scheisse, I was taking num/GCD there \\uD83D\\uDE05 "
                    },
                    {
                        "username": "srk696772",
                        "content": "Bro GCD(6,14) == 2 ,  \nnot 3"
                    },
                    {
                        "username": "bekbossyn_kassymkhan",
                        "content": "gcd(6 & 14) = 2 , gcd(10,6)=2 also \n:)"
                    },
                    {
                        "username": "gaurav1903",
                        "content": "What\\'s the O(N) solution??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The O(N) solution leverages the fact that if we can find two numbers in the array whose greatest common divisor (gcd) is 1, then the minimum number of operations required is the size of the array minus 1.\\n\\nTo achieve this in linear time, we can use the Sieve of Eratosthenes, a well-known algorithm for finding all prime numbers up to a given limit. This algorithm can be used to find the smallest prime factor for each number in the array, which is a prerequisite for finding two numbers with gcd 1.\\n\\nHere are the steps of the algorithm:\\n\\n1. Compute the smallest prime factor for each number up to max(nums) using the Sieve of Eratosthenes.\\n2. For each number in nums, if its smallest prime factor divides another number in nums, we can assume that the gcd of these two numbers is 1.\\n3. If we find such a pair, the minimum number of operations required is the size of the array minus 1.\\n4. If no such pair exists, we cannot make all elements equal to 1, so we return -1.\\n\\nNote: As the Sieve of Eratosthenes requires O(N log log N) time complexity, this solution is not strictly linear. However, it is significantly more efficient than an O(N^2) solution when dealing with large inputs.\\n\\nThis solution assumes that the input numbers are not too large (e.g., within the range of an integer). If the numbers can be very large, we need a different approach because the Sieve of Eratosthenes may not be feasible. For example, we could use a probabilistic algorithm to find a pair of numbers with gcd 1, but this would not guarantee a correct answer in all cases.\\n\\nAlso, it\\'s important to note that this approach doesn\\'t give the exact number of operations if no \"1\" is found in the array; it only checks for the possibility of making all elements equal to 1. Calculating the exact number of operations in such a case can be a more complex problem and is likely to require more than linear time."
                    },
                    {
                        "username": "ZX007java",
                        "content": "Good day ! Can anyone give me answer : why set [2, 6, 3, 4] have answer is equal 4, BUT SET [4, 2, 6, 3] have answer is equal 5 ???"
                    },
                    {
                        "username": "bparanj",
                        "content": "This discrepancy arises from the order in which we are allowed to perform the gcd operations on the array.\\n\\nFor the array [2, 6, 3, 4]:\\n\\n1. We can select index 2 (i.e., the number 3) and take the gcd with the number at index 3 (i.e., the number 4), and replace 3 with gcd(3, 4) = 1. Array becomes [2, 6, 1, 4].\\n2. We can then select index 1 (i.e., the number 6) and take the gcd with the number at index 2 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, 1, 1, 4].\\n3. Then, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 4].\\n4. Finally, select index 2 (i.e., the number 1) and take the gcd with the number at index 3 (i.e., the number 4), and replace 4 with gcd(1, 4) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 4.\\n\\nFor the array [4, 2, 6, 3]:\\n\\n1. We can select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array becomes [4, 2, 6, 3].\\n2. Repeat step 1. Array still is [4, 2, 6, 3].\\n3. Repeat step 1 again. Array still is [4, 2, 6, 3].\\n4. Finally, select index 3 (i.e., the number 3) and take the gcd with the number at index 2 (i.e., the number 6), and replace 3 with gcd(3, 6) = 3. Array becomes [4, 2, 6, 1].\\n5. Now, select index 0 (i.e., the number 4) and take the gcd with the number at index 1 (i.e., the number 2), and replace 4 with gcd(4, 2) = 2. Array becomes [2, 2, 6, 1].\\n6. Next, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array still is [2, 2, 6, 1].\\n7. Repeat step 6. Array still is [2, 2, 6, 1].\\n8. Repeat step 6 again. Array still is [2, 2, 6, 1].\\n9. Repeat step 6 once more. Array still is [2, 2, 6, 1].\\n10. Finally, select index 2 (i.e., the number 6) and take the gcd with the number at index 3 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, \\n\\n2, 1, 1].\\n11. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 2), and replace 2 with gcd(2, 2) = 2. Array still is [2, 2, 1, 1].\\n12. Repeat step 11. Array still is [2, 2, 1, 1].\\n13. Repeat step 11 again. Array still is [2, 2, 1, 1].\\n14. Finally, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [2, 1, 1, 1].\\n15. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 15.\\n\\nThis demonstrates how the order of the array can affect the total number of operations required to achieve all elements as 1. The most optimized way to get all elements to 1 can depend on the order of elements in the array."
                    },
                    {
                        "username": "ZX007java",
                        "content": "[@s_m99](/s_m99) THANK YOU !!! CONSECUTIVE !!!"
                    },
                    {
                        "username": "s_m99",
                        "content": "You can only calculate gcd\\'s of 2 **consecutive** numbers and replace either of them. So in set [4,2,6,3] to make 3 into 1 we require two operations instead of one in [2,6,3,4] "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn, that was a great problem but... Medium, really? Am I just getting dumber? \nTook me quite lot of time and tryhard to see the solution.\nAnd that's gotta be the lowest acceptance rate I've seen for a medium problem\n\nAlso, python has a built-in gcd function apparently. Lesson learned; next time, no need to face my anxieties trying to remember my number theory classes to implement the Euclidean algo myself"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "Anyone explain or hint"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "light hint: how many steps would it take to get your first one in the array? And once you have a one, how many more steps do you need to turn everything into a one?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I am not able to understand the question\\nit says \\nselect index i and change num[i] or num[i+1] with their GCD and people have used n^2 loop to check every pair"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the minimum number of operations required to make all elements of an array equal to 1, by replacing either nums[i] or nums[i+1] with their gcd (greatest common divisor).\\n\\nThe problem solution is implemented with an O(n^2) approach, and this is why:\\n\\n1. You iterate over each element in the array (first loop).\\n2. For each element, you check for a contiguous segment in the array where the gcd of the numbers in the segment equals 1 (second loop). If such a segment is found, you store the length of that segment minus 1 (because one element is already 1 and doesn\\'t need any operation).\\n3. The result of the algorithm is the minimum length of these segments (if any) plus the number of elements outside these segments (because each of these will need one operation to become 1, by taking the gcd with 1).\\n\\nThe algorithm needs to check all pairs of elements because the array isn\\'t necessarily sorted, and any pair (i, j) with i < j can potentially form a contiguous segment where the gcd of the numbers is 1. So, an element nums[i] might be replaced by the gcd of nums[i] and nums[j] for some j > i.\\n"
                    },
                    {
                        "username": "User___",
                        "content": "[@cartesPerforees](/cartesPerforees) Is that $$O(n)$$?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you understand the question, it's just the solutions that you don't understand.\nWe check every pair to find the closest elements that could lead to a gcd of 1. Then we propagate the gcd neighbor-by-neighbor"
                    }
                ]
            },
            {
                "id": 1871577,
                "content": [
                    {
                        "username": "rideau",
                        "content": "Does anybody know how solve this in O(1) time? Is this even possible?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Pay no attention to that follow-up. The person who wrote it was drunk."
                    },
                    {
                        "username": "User___",
                        "content": "Did you manage to solve it in $$O(n)$$? Just wondering, since you\\'re asking about $$O(1)$$ (which I feel isn\\'t possible)"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "I think it's quite easy to prove that it impossible to solve this problem in O(1) time complexity.\nImaging you have an array of length N, for which the asnwer is \"-1\" - that is, you cannot make all elements equal to 1 using any number of operations. Now, insert number \"1\" at a random index of the array, and now you can make all other numbers equal to 1. In order to find this \"1\" you need O(N) time complexity."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your reasoning is absolutely correct. As per the problem, you need to inspect each element of the array to determine if the number 1 is present or if a pair of numbers exists such that their greatest common divisor (gcd) is 1. This requires at least linear time, O(N), where N is the length of the array.\\n\\nAs you\\'ve aptly illustrated, the presence of a single 1 in the array changes the entire outcome of the problem. Without examining each element, we cannot determine the presence or absence of such a crucial value. This necessitates iterating through the array at least once, thereby confirming that the problem cannot be solved in constant time, O(1)."
                    },
                    {
                        "username": "SlickGeek",
                        "content": "\"...but could you find an O(1) constant time complexity solution?\" Is it actually possible to solve this problem in constant time? I don\\'t know if there\\'s something I am not seeing or understanding, but I don\\'t think that is possible.\\nThe solution I came up with runs in N^2 and beats 71%."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rideau](/rideau) see [@Sergey TT](/SergeyTT)\\'s respose"
                    },
                    {
                        "username": "rideau",
                        "content": "Any updates? Im also interested "
                    },
                    {
                        "username": "sanjitj7",
                        "content": "EDIT: I have spotted my n00b mistake\n\nI think this test case is incorrect!\n\n>Input: nums = [2,10,6,14]\n>Output: -1\n>Explanation: It can be shown that it is impossible to make all the elements equal to 1\n\n[2,10,6,14]\n[2,10,3,14]  (i = 2)\n[2,10,3,1]   (i = 2)\n[2,10,1,1]\n[2,1,1,1]\n[1,1,1,1]\n\nThis caused a lot of confusion to me."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "oh scheisse, I was taking num/GCD there \\uD83D\\uDE05 "
                    },
                    {
                        "username": "srk696772",
                        "content": "Bro GCD(6,14) == 2 ,  \nnot 3"
                    },
                    {
                        "username": "bekbossyn_kassymkhan",
                        "content": "gcd(6 & 14) = 2 , gcd(10,6)=2 also \n:)"
                    },
                    {
                        "username": "gaurav1903",
                        "content": "What\\'s the O(N) solution??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The O(N) solution leverages the fact that if we can find two numbers in the array whose greatest common divisor (gcd) is 1, then the minimum number of operations required is the size of the array minus 1.\\n\\nTo achieve this in linear time, we can use the Sieve of Eratosthenes, a well-known algorithm for finding all prime numbers up to a given limit. This algorithm can be used to find the smallest prime factor for each number in the array, which is a prerequisite for finding two numbers with gcd 1.\\n\\nHere are the steps of the algorithm:\\n\\n1. Compute the smallest prime factor for each number up to max(nums) using the Sieve of Eratosthenes.\\n2. For each number in nums, if its smallest prime factor divides another number in nums, we can assume that the gcd of these two numbers is 1.\\n3. If we find such a pair, the minimum number of operations required is the size of the array minus 1.\\n4. If no such pair exists, we cannot make all elements equal to 1, so we return -1.\\n\\nNote: As the Sieve of Eratosthenes requires O(N log log N) time complexity, this solution is not strictly linear. However, it is significantly more efficient than an O(N^2) solution when dealing with large inputs.\\n\\nThis solution assumes that the input numbers are not too large (e.g., within the range of an integer). If the numbers can be very large, we need a different approach because the Sieve of Eratosthenes may not be feasible. For example, we could use a probabilistic algorithm to find a pair of numbers with gcd 1, but this would not guarantee a correct answer in all cases.\\n\\nAlso, it\\'s important to note that this approach doesn\\'t give the exact number of operations if no \"1\" is found in the array; it only checks for the possibility of making all elements equal to 1. Calculating the exact number of operations in such a case can be a more complex problem and is likely to require more than linear time."
                    },
                    {
                        "username": "ZX007java",
                        "content": "Good day ! Can anyone give me answer : why set [2, 6, 3, 4] have answer is equal 4, BUT SET [4, 2, 6, 3] have answer is equal 5 ???"
                    },
                    {
                        "username": "bparanj",
                        "content": "This discrepancy arises from the order in which we are allowed to perform the gcd operations on the array.\\n\\nFor the array [2, 6, 3, 4]:\\n\\n1. We can select index 2 (i.e., the number 3) and take the gcd with the number at index 3 (i.e., the number 4), and replace 3 with gcd(3, 4) = 1. Array becomes [2, 6, 1, 4].\\n2. We can then select index 1 (i.e., the number 6) and take the gcd with the number at index 2 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, 1, 1, 4].\\n3. Then, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 4].\\n4. Finally, select index 2 (i.e., the number 1) and take the gcd with the number at index 3 (i.e., the number 4), and replace 4 with gcd(1, 4) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 4.\\n\\nFor the array [4, 2, 6, 3]:\\n\\n1. We can select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array becomes [4, 2, 6, 3].\\n2. Repeat step 1. Array still is [4, 2, 6, 3].\\n3. Repeat step 1 again. Array still is [4, 2, 6, 3].\\n4. Finally, select index 3 (i.e., the number 3) and take the gcd with the number at index 2 (i.e., the number 6), and replace 3 with gcd(3, 6) = 3. Array becomes [4, 2, 6, 1].\\n5. Now, select index 0 (i.e., the number 4) and take the gcd with the number at index 1 (i.e., the number 2), and replace 4 with gcd(4, 2) = 2. Array becomes [2, 2, 6, 1].\\n6. Next, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array still is [2, 2, 6, 1].\\n7. Repeat step 6. Array still is [2, 2, 6, 1].\\n8. Repeat step 6 again. Array still is [2, 2, 6, 1].\\n9. Repeat step 6 once more. Array still is [2, 2, 6, 1].\\n10. Finally, select index 2 (i.e., the number 6) and take the gcd with the number at index 3 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, \\n\\n2, 1, 1].\\n11. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 2), and replace 2 with gcd(2, 2) = 2. Array still is [2, 2, 1, 1].\\n12. Repeat step 11. Array still is [2, 2, 1, 1].\\n13. Repeat step 11 again. Array still is [2, 2, 1, 1].\\n14. Finally, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [2, 1, 1, 1].\\n15. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 15.\\n\\nThis demonstrates how the order of the array can affect the total number of operations required to achieve all elements as 1. The most optimized way to get all elements to 1 can depend on the order of elements in the array."
                    },
                    {
                        "username": "ZX007java",
                        "content": "[@s_m99](/s_m99) THANK YOU !!! CONSECUTIVE !!!"
                    },
                    {
                        "username": "s_m99",
                        "content": "You can only calculate gcd\\'s of 2 **consecutive** numbers and replace either of them. So in set [4,2,6,3] to make 3 into 1 we require two operations instead of one in [2,6,3,4] "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn, that was a great problem but... Medium, really? Am I just getting dumber? \nTook me quite lot of time and tryhard to see the solution.\nAnd that's gotta be the lowest acceptance rate I've seen for a medium problem\n\nAlso, python has a built-in gcd function apparently. Lesson learned; next time, no need to face my anxieties trying to remember my number theory classes to implement the Euclidean algo myself"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "Anyone explain or hint"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "light hint: how many steps would it take to get your first one in the array? And once you have a one, how many more steps do you need to turn everything into a one?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I am not able to understand the question\\nit says \\nselect index i and change num[i] or num[i+1] with their GCD and people have used n^2 loop to check every pair"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the minimum number of operations required to make all elements of an array equal to 1, by replacing either nums[i] or nums[i+1] with their gcd (greatest common divisor).\\n\\nThe problem solution is implemented with an O(n^2) approach, and this is why:\\n\\n1. You iterate over each element in the array (first loop).\\n2. For each element, you check for a contiguous segment in the array where the gcd of the numbers in the segment equals 1 (second loop). If such a segment is found, you store the length of that segment minus 1 (because one element is already 1 and doesn\\'t need any operation).\\n3. The result of the algorithm is the minimum length of these segments (if any) plus the number of elements outside these segments (because each of these will need one operation to become 1, by taking the gcd with 1).\\n\\nThe algorithm needs to check all pairs of elements because the array isn\\'t necessarily sorted, and any pair (i, j) with i < j can potentially form a contiguous segment where the gcd of the numbers is 1. So, an element nums[i] might be replaced by the gcd of nums[i] and nums[j] for some j > i.\\n"
                    },
                    {
                        "username": "User___",
                        "content": "[@cartesPerforees](/cartesPerforees) Is that $$O(n)$$?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you understand the question, it's just the solutions that you don't understand.\nWe check every pair to find the closest elements that could lead to a gcd of 1. Then we propagate the gcd neighbor-by-neighbor"
                    }
                ]
            },
            {
                "id": 1873923,
                "content": [
                    {
                        "username": "rideau",
                        "content": "Does anybody know how solve this in O(1) time? Is this even possible?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Pay no attention to that follow-up. The person who wrote it was drunk."
                    },
                    {
                        "username": "User___",
                        "content": "Did you manage to solve it in $$O(n)$$? Just wondering, since you\\'re asking about $$O(1)$$ (which I feel isn\\'t possible)"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "I think it's quite easy to prove that it impossible to solve this problem in O(1) time complexity.\nImaging you have an array of length N, for which the asnwer is \"-1\" - that is, you cannot make all elements equal to 1 using any number of operations. Now, insert number \"1\" at a random index of the array, and now you can make all other numbers equal to 1. In order to find this \"1\" you need O(N) time complexity."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your reasoning is absolutely correct. As per the problem, you need to inspect each element of the array to determine if the number 1 is present or if a pair of numbers exists such that their greatest common divisor (gcd) is 1. This requires at least linear time, O(N), where N is the length of the array.\\n\\nAs you\\'ve aptly illustrated, the presence of a single 1 in the array changes the entire outcome of the problem. Without examining each element, we cannot determine the presence or absence of such a crucial value. This necessitates iterating through the array at least once, thereby confirming that the problem cannot be solved in constant time, O(1)."
                    },
                    {
                        "username": "SlickGeek",
                        "content": "\"...but could you find an O(1) constant time complexity solution?\" Is it actually possible to solve this problem in constant time? I don\\'t know if there\\'s something I am not seeing or understanding, but I don\\'t think that is possible.\\nThe solution I came up with runs in N^2 and beats 71%."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rideau](/rideau) see [@Sergey TT](/SergeyTT)\\'s respose"
                    },
                    {
                        "username": "rideau",
                        "content": "Any updates? Im also interested "
                    },
                    {
                        "username": "sanjitj7",
                        "content": "EDIT: I have spotted my n00b mistake\n\nI think this test case is incorrect!\n\n>Input: nums = [2,10,6,14]\n>Output: -1\n>Explanation: It can be shown that it is impossible to make all the elements equal to 1\n\n[2,10,6,14]\n[2,10,3,14]  (i = 2)\n[2,10,3,1]   (i = 2)\n[2,10,1,1]\n[2,1,1,1]\n[1,1,1,1]\n\nThis caused a lot of confusion to me."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "oh scheisse, I was taking num/GCD there \\uD83D\\uDE05 "
                    },
                    {
                        "username": "srk696772",
                        "content": "Bro GCD(6,14) == 2 ,  \nnot 3"
                    },
                    {
                        "username": "bekbossyn_kassymkhan",
                        "content": "gcd(6 & 14) = 2 , gcd(10,6)=2 also \n:)"
                    },
                    {
                        "username": "gaurav1903",
                        "content": "What\\'s the O(N) solution??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The O(N) solution leverages the fact that if we can find two numbers in the array whose greatest common divisor (gcd) is 1, then the minimum number of operations required is the size of the array minus 1.\\n\\nTo achieve this in linear time, we can use the Sieve of Eratosthenes, a well-known algorithm for finding all prime numbers up to a given limit. This algorithm can be used to find the smallest prime factor for each number in the array, which is a prerequisite for finding two numbers with gcd 1.\\n\\nHere are the steps of the algorithm:\\n\\n1. Compute the smallest prime factor for each number up to max(nums) using the Sieve of Eratosthenes.\\n2. For each number in nums, if its smallest prime factor divides another number in nums, we can assume that the gcd of these two numbers is 1.\\n3. If we find such a pair, the minimum number of operations required is the size of the array minus 1.\\n4. If no such pair exists, we cannot make all elements equal to 1, so we return -1.\\n\\nNote: As the Sieve of Eratosthenes requires O(N log log N) time complexity, this solution is not strictly linear. However, it is significantly more efficient than an O(N^2) solution when dealing with large inputs.\\n\\nThis solution assumes that the input numbers are not too large (e.g., within the range of an integer). If the numbers can be very large, we need a different approach because the Sieve of Eratosthenes may not be feasible. For example, we could use a probabilistic algorithm to find a pair of numbers with gcd 1, but this would not guarantee a correct answer in all cases.\\n\\nAlso, it\\'s important to note that this approach doesn\\'t give the exact number of operations if no \"1\" is found in the array; it only checks for the possibility of making all elements equal to 1. Calculating the exact number of operations in such a case can be a more complex problem and is likely to require more than linear time."
                    },
                    {
                        "username": "ZX007java",
                        "content": "Good day ! Can anyone give me answer : why set [2, 6, 3, 4] have answer is equal 4, BUT SET [4, 2, 6, 3] have answer is equal 5 ???"
                    },
                    {
                        "username": "bparanj",
                        "content": "This discrepancy arises from the order in which we are allowed to perform the gcd operations on the array.\\n\\nFor the array [2, 6, 3, 4]:\\n\\n1. We can select index 2 (i.e., the number 3) and take the gcd with the number at index 3 (i.e., the number 4), and replace 3 with gcd(3, 4) = 1. Array becomes [2, 6, 1, 4].\\n2. We can then select index 1 (i.e., the number 6) and take the gcd with the number at index 2 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, 1, 1, 4].\\n3. Then, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 4].\\n4. Finally, select index 2 (i.e., the number 1) and take the gcd with the number at index 3 (i.e., the number 4), and replace 4 with gcd(1, 4) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 4.\\n\\nFor the array [4, 2, 6, 3]:\\n\\n1. We can select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array becomes [4, 2, 6, 3].\\n2. Repeat step 1. Array still is [4, 2, 6, 3].\\n3. Repeat step 1 again. Array still is [4, 2, 6, 3].\\n4. Finally, select index 3 (i.e., the number 3) and take the gcd with the number at index 2 (i.e., the number 6), and replace 3 with gcd(3, 6) = 3. Array becomes [4, 2, 6, 1].\\n5. Now, select index 0 (i.e., the number 4) and take the gcd with the number at index 1 (i.e., the number 2), and replace 4 with gcd(4, 2) = 2. Array becomes [2, 2, 6, 1].\\n6. Next, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array still is [2, 2, 6, 1].\\n7. Repeat step 6. Array still is [2, 2, 6, 1].\\n8. Repeat step 6 again. Array still is [2, 2, 6, 1].\\n9. Repeat step 6 once more. Array still is [2, 2, 6, 1].\\n10. Finally, select index 2 (i.e., the number 6) and take the gcd with the number at index 3 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, \\n\\n2, 1, 1].\\n11. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 2), and replace 2 with gcd(2, 2) = 2. Array still is [2, 2, 1, 1].\\n12. Repeat step 11. Array still is [2, 2, 1, 1].\\n13. Repeat step 11 again. Array still is [2, 2, 1, 1].\\n14. Finally, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [2, 1, 1, 1].\\n15. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 15.\\n\\nThis demonstrates how the order of the array can affect the total number of operations required to achieve all elements as 1. The most optimized way to get all elements to 1 can depend on the order of elements in the array."
                    },
                    {
                        "username": "ZX007java",
                        "content": "[@s_m99](/s_m99) THANK YOU !!! CONSECUTIVE !!!"
                    },
                    {
                        "username": "s_m99",
                        "content": "You can only calculate gcd\\'s of 2 **consecutive** numbers and replace either of them. So in set [4,2,6,3] to make 3 into 1 we require two operations instead of one in [2,6,3,4] "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn, that was a great problem but... Medium, really? Am I just getting dumber? \nTook me quite lot of time and tryhard to see the solution.\nAnd that's gotta be the lowest acceptance rate I've seen for a medium problem\n\nAlso, python has a built-in gcd function apparently. Lesson learned; next time, no need to face my anxieties trying to remember my number theory classes to implement the Euclidean algo myself"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "Anyone explain or hint"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "light hint: how many steps would it take to get your first one in the array? And once you have a one, how many more steps do you need to turn everything into a one?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I am not able to understand the question\\nit says \\nselect index i and change num[i] or num[i+1] with their GCD and people have used n^2 loop to check every pair"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the minimum number of operations required to make all elements of an array equal to 1, by replacing either nums[i] or nums[i+1] with their gcd (greatest common divisor).\\n\\nThe problem solution is implemented with an O(n^2) approach, and this is why:\\n\\n1. You iterate over each element in the array (first loop).\\n2. For each element, you check for a contiguous segment in the array where the gcd of the numbers in the segment equals 1 (second loop). If such a segment is found, you store the length of that segment minus 1 (because one element is already 1 and doesn\\'t need any operation).\\n3. The result of the algorithm is the minimum length of these segments (if any) plus the number of elements outside these segments (because each of these will need one operation to become 1, by taking the gcd with 1).\\n\\nThe algorithm needs to check all pairs of elements because the array isn\\'t necessarily sorted, and any pair (i, j) with i < j can potentially form a contiguous segment where the gcd of the numbers is 1. So, an element nums[i] might be replaced by the gcd of nums[i] and nums[j] for some j > i.\\n"
                    },
                    {
                        "username": "User___",
                        "content": "[@cartesPerforees](/cartesPerforees) Is that $$O(n)$$?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you understand the question, it's just the solutions that you don't understand.\nWe check every pair to find the closest elements that could lead to a gcd of 1. Then we propagate the gcd neighbor-by-neighbor"
                    }
                ]
            },
            {
                "id": 1878342,
                "content": [
                    {
                        "username": "rideau",
                        "content": "Does anybody know how solve this in O(1) time? Is this even possible?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Pay no attention to that follow-up. The person who wrote it was drunk."
                    },
                    {
                        "username": "User___",
                        "content": "Did you manage to solve it in $$O(n)$$? Just wondering, since you\\'re asking about $$O(1)$$ (which I feel isn\\'t possible)"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "I think it's quite easy to prove that it impossible to solve this problem in O(1) time complexity.\nImaging you have an array of length N, for which the asnwer is \"-1\" - that is, you cannot make all elements equal to 1 using any number of operations. Now, insert number \"1\" at a random index of the array, and now you can make all other numbers equal to 1. In order to find this \"1\" you need O(N) time complexity."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your reasoning is absolutely correct. As per the problem, you need to inspect each element of the array to determine if the number 1 is present or if a pair of numbers exists such that their greatest common divisor (gcd) is 1. This requires at least linear time, O(N), where N is the length of the array.\\n\\nAs you\\'ve aptly illustrated, the presence of a single 1 in the array changes the entire outcome of the problem. Without examining each element, we cannot determine the presence or absence of such a crucial value. This necessitates iterating through the array at least once, thereby confirming that the problem cannot be solved in constant time, O(1)."
                    },
                    {
                        "username": "SlickGeek",
                        "content": "\"...but could you find an O(1) constant time complexity solution?\" Is it actually possible to solve this problem in constant time? I don\\'t know if there\\'s something I am not seeing or understanding, but I don\\'t think that is possible.\\nThe solution I came up with runs in N^2 and beats 71%."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rideau](/rideau) see [@Sergey TT](/SergeyTT)\\'s respose"
                    },
                    {
                        "username": "rideau",
                        "content": "Any updates? Im also interested "
                    },
                    {
                        "username": "sanjitj7",
                        "content": "EDIT: I have spotted my n00b mistake\n\nI think this test case is incorrect!\n\n>Input: nums = [2,10,6,14]\n>Output: -1\n>Explanation: It can be shown that it is impossible to make all the elements equal to 1\n\n[2,10,6,14]\n[2,10,3,14]  (i = 2)\n[2,10,3,1]   (i = 2)\n[2,10,1,1]\n[2,1,1,1]\n[1,1,1,1]\n\nThis caused a lot of confusion to me."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "oh scheisse, I was taking num/GCD there \\uD83D\\uDE05 "
                    },
                    {
                        "username": "srk696772",
                        "content": "Bro GCD(6,14) == 2 ,  \nnot 3"
                    },
                    {
                        "username": "bekbossyn_kassymkhan",
                        "content": "gcd(6 & 14) = 2 , gcd(10,6)=2 also \n:)"
                    },
                    {
                        "username": "gaurav1903",
                        "content": "What\\'s the O(N) solution??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The O(N) solution leverages the fact that if we can find two numbers in the array whose greatest common divisor (gcd) is 1, then the minimum number of operations required is the size of the array minus 1.\\n\\nTo achieve this in linear time, we can use the Sieve of Eratosthenes, a well-known algorithm for finding all prime numbers up to a given limit. This algorithm can be used to find the smallest prime factor for each number in the array, which is a prerequisite for finding two numbers with gcd 1.\\n\\nHere are the steps of the algorithm:\\n\\n1. Compute the smallest prime factor for each number up to max(nums) using the Sieve of Eratosthenes.\\n2. For each number in nums, if its smallest prime factor divides another number in nums, we can assume that the gcd of these two numbers is 1.\\n3. If we find such a pair, the minimum number of operations required is the size of the array minus 1.\\n4. If no such pair exists, we cannot make all elements equal to 1, so we return -1.\\n\\nNote: As the Sieve of Eratosthenes requires O(N log log N) time complexity, this solution is not strictly linear. However, it is significantly more efficient than an O(N^2) solution when dealing with large inputs.\\n\\nThis solution assumes that the input numbers are not too large (e.g., within the range of an integer). If the numbers can be very large, we need a different approach because the Sieve of Eratosthenes may not be feasible. For example, we could use a probabilistic algorithm to find a pair of numbers with gcd 1, but this would not guarantee a correct answer in all cases.\\n\\nAlso, it\\'s important to note that this approach doesn\\'t give the exact number of operations if no \"1\" is found in the array; it only checks for the possibility of making all elements equal to 1. Calculating the exact number of operations in such a case can be a more complex problem and is likely to require more than linear time."
                    },
                    {
                        "username": "ZX007java",
                        "content": "Good day ! Can anyone give me answer : why set [2, 6, 3, 4] have answer is equal 4, BUT SET [4, 2, 6, 3] have answer is equal 5 ???"
                    },
                    {
                        "username": "bparanj",
                        "content": "This discrepancy arises from the order in which we are allowed to perform the gcd operations on the array.\\n\\nFor the array [2, 6, 3, 4]:\\n\\n1. We can select index 2 (i.e., the number 3) and take the gcd with the number at index 3 (i.e., the number 4), and replace 3 with gcd(3, 4) = 1. Array becomes [2, 6, 1, 4].\\n2. We can then select index 1 (i.e., the number 6) and take the gcd with the number at index 2 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, 1, 1, 4].\\n3. Then, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 4].\\n4. Finally, select index 2 (i.e., the number 1) and take the gcd with the number at index 3 (i.e., the number 4), and replace 4 with gcd(1, 4) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 4.\\n\\nFor the array [4, 2, 6, 3]:\\n\\n1. We can select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array becomes [4, 2, 6, 3].\\n2. Repeat step 1. Array still is [4, 2, 6, 3].\\n3. Repeat step 1 again. Array still is [4, 2, 6, 3].\\n4. Finally, select index 3 (i.e., the number 3) and take the gcd with the number at index 2 (i.e., the number 6), and replace 3 with gcd(3, 6) = 3. Array becomes [4, 2, 6, 1].\\n5. Now, select index 0 (i.e., the number 4) and take the gcd with the number at index 1 (i.e., the number 2), and replace 4 with gcd(4, 2) = 2. Array becomes [2, 2, 6, 1].\\n6. Next, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array still is [2, 2, 6, 1].\\n7. Repeat step 6. Array still is [2, 2, 6, 1].\\n8. Repeat step 6 again. Array still is [2, 2, 6, 1].\\n9. Repeat step 6 once more. Array still is [2, 2, 6, 1].\\n10. Finally, select index 2 (i.e., the number 6) and take the gcd with the number at index 3 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, \\n\\n2, 1, 1].\\n11. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 2), and replace 2 with gcd(2, 2) = 2. Array still is [2, 2, 1, 1].\\n12. Repeat step 11. Array still is [2, 2, 1, 1].\\n13. Repeat step 11 again. Array still is [2, 2, 1, 1].\\n14. Finally, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [2, 1, 1, 1].\\n15. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 15.\\n\\nThis demonstrates how the order of the array can affect the total number of operations required to achieve all elements as 1. The most optimized way to get all elements to 1 can depend on the order of elements in the array."
                    },
                    {
                        "username": "ZX007java",
                        "content": "[@s_m99](/s_m99) THANK YOU !!! CONSECUTIVE !!!"
                    },
                    {
                        "username": "s_m99",
                        "content": "You can only calculate gcd\\'s of 2 **consecutive** numbers and replace either of them. So in set [4,2,6,3] to make 3 into 1 we require two operations instead of one in [2,6,3,4] "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn, that was a great problem but... Medium, really? Am I just getting dumber? \nTook me quite lot of time and tryhard to see the solution.\nAnd that's gotta be the lowest acceptance rate I've seen for a medium problem\n\nAlso, python has a built-in gcd function apparently. Lesson learned; next time, no need to face my anxieties trying to remember my number theory classes to implement the Euclidean algo myself"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "Anyone explain or hint"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "light hint: how many steps would it take to get your first one in the array? And once you have a one, how many more steps do you need to turn everything into a one?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I am not able to understand the question\\nit says \\nselect index i and change num[i] or num[i+1] with their GCD and people have used n^2 loop to check every pair"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the minimum number of operations required to make all elements of an array equal to 1, by replacing either nums[i] or nums[i+1] with their gcd (greatest common divisor).\\n\\nThe problem solution is implemented with an O(n^2) approach, and this is why:\\n\\n1. You iterate over each element in the array (first loop).\\n2. For each element, you check for a contiguous segment in the array where the gcd of the numbers in the segment equals 1 (second loop). If such a segment is found, you store the length of that segment minus 1 (because one element is already 1 and doesn\\'t need any operation).\\n3. The result of the algorithm is the minimum length of these segments (if any) plus the number of elements outside these segments (because each of these will need one operation to become 1, by taking the gcd with 1).\\n\\nThe algorithm needs to check all pairs of elements because the array isn\\'t necessarily sorted, and any pair (i, j) with i < j can potentially form a contiguous segment where the gcd of the numbers is 1. So, an element nums[i] might be replaced by the gcd of nums[i] and nums[j] for some j > i.\\n"
                    },
                    {
                        "username": "User___",
                        "content": "[@cartesPerforees](/cartesPerforees) Is that $$O(n)$$?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you understand the question, it's just the solutions that you don't understand.\nWe check every pair to find the closest elements that could lead to a gcd of 1. Then we propagate the gcd neighbor-by-neighbor"
                    }
                ]
            },
            {
                "id": 1873206,
                "content": [
                    {
                        "username": "rideau",
                        "content": "Does anybody know how solve this in O(1) time? Is this even possible?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Pay no attention to that follow-up. The person who wrote it was drunk."
                    },
                    {
                        "username": "User___",
                        "content": "Did you manage to solve it in $$O(n)$$? Just wondering, since you\\'re asking about $$O(1)$$ (which I feel isn\\'t possible)"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "I think it's quite easy to prove that it impossible to solve this problem in O(1) time complexity.\nImaging you have an array of length N, for which the asnwer is \"-1\" - that is, you cannot make all elements equal to 1 using any number of operations. Now, insert number \"1\" at a random index of the array, and now you can make all other numbers equal to 1. In order to find this \"1\" you need O(N) time complexity."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your reasoning is absolutely correct. As per the problem, you need to inspect each element of the array to determine if the number 1 is present or if a pair of numbers exists such that their greatest common divisor (gcd) is 1. This requires at least linear time, O(N), where N is the length of the array.\\n\\nAs you\\'ve aptly illustrated, the presence of a single 1 in the array changes the entire outcome of the problem. Without examining each element, we cannot determine the presence or absence of such a crucial value. This necessitates iterating through the array at least once, thereby confirming that the problem cannot be solved in constant time, O(1)."
                    },
                    {
                        "username": "SlickGeek",
                        "content": "\"...but could you find an O(1) constant time complexity solution?\" Is it actually possible to solve this problem in constant time? I don\\'t know if there\\'s something I am not seeing or understanding, but I don\\'t think that is possible.\\nThe solution I came up with runs in N^2 and beats 71%."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rideau](/rideau) see [@Sergey TT](/SergeyTT)\\'s respose"
                    },
                    {
                        "username": "rideau",
                        "content": "Any updates? Im also interested "
                    },
                    {
                        "username": "sanjitj7",
                        "content": "EDIT: I have spotted my n00b mistake\n\nI think this test case is incorrect!\n\n>Input: nums = [2,10,6,14]\n>Output: -1\n>Explanation: It can be shown that it is impossible to make all the elements equal to 1\n\n[2,10,6,14]\n[2,10,3,14]  (i = 2)\n[2,10,3,1]   (i = 2)\n[2,10,1,1]\n[2,1,1,1]\n[1,1,1,1]\n\nThis caused a lot of confusion to me."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "oh scheisse, I was taking num/GCD there \\uD83D\\uDE05 "
                    },
                    {
                        "username": "srk696772",
                        "content": "Bro GCD(6,14) == 2 ,  \nnot 3"
                    },
                    {
                        "username": "bekbossyn_kassymkhan",
                        "content": "gcd(6 & 14) = 2 , gcd(10,6)=2 also \n:)"
                    },
                    {
                        "username": "gaurav1903",
                        "content": "What\\'s the O(N) solution??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The O(N) solution leverages the fact that if we can find two numbers in the array whose greatest common divisor (gcd) is 1, then the minimum number of operations required is the size of the array minus 1.\\n\\nTo achieve this in linear time, we can use the Sieve of Eratosthenes, a well-known algorithm for finding all prime numbers up to a given limit. This algorithm can be used to find the smallest prime factor for each number in the array, which is a prerequisite for finding two numbers with gcd 1.\\n\\nHere are the steps of the algorithm:\\n\\n1. Compute the smallest prime factor for each number up to max(nums) using the Sieve of Eratosthenes.\\n2. For each number in nums, if its smallest prime factor divides another number in nums, we can assume that the gcd of these two numbers is 1.\\n3. If we find such a pair, the minimum number of operations required is the size of the array minus 1.\\n4. If no such pair exists, we cannot make all elements equal to 1, so we return -1.\\n\\nNote: As the Sieve of Eratosthenes requires O(N log log N) time complexity, this solution is not strictly linear. However, it is significantly more efficient than an O(N^2) solution when dealing with large inputs.\\n\\nThis solution assumes that the input numbers are not too large (e.g., within the range of an integer). If the numbers can be very large, we need a different approach because the Sieve of Eratosthenes may not be feasible. For example, we could use a probabilistic algorithm to find a pair of numbers with gcd 1, but this would not guarantee a correct answer in all cases.\\n\\nAlso, it\\'s important to note that this approach doesn\\'t give the exact number of operations if no \"1\" is found in the array; it only checks for the possibility of making all elements equal to 1. Calculating the exact number of operations in such a case can be a more complex problem and is likely to require more than linear time."
                    },
                    {
                        "username": "ZX007java",
                        "content": "Good day ! Can anyone give me answer : why set [2, 6, 3, 4] have answer is equal 4, BUT SET [4, 2, 6, 3] have answer is equal 5 ???"
                    },
                    {
                        "username": "bparanj",
                        "content": "This discrepancy arises from the order in which we are allowed to perform the gcd operations on the array.\\n\\nFor the array [2, 6, 3, 4]:\\n\\n1. We can select index 2 (i.e., the number 3) and take the gcd with the number at index 3 (i.e., the number 4), and replace 3 with gcd(3, 4) = 1. Array becomes [2, 6, 1, 4].\\n2. We can then select index 1 (i.e., the number 6) and take the gcd with the number at index 2 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, 1, 1, 4].\\n3. Then, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 4].\\n4. Finally, select index 2 (i.e., the number 1) and take the gcd with the number at index 3 (i.e., the number 4), and replace 4 with gcd(1, 4) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 4.\\n\\nFor the array [4, 2, 6, 3]:\\n\\n1. We can select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array becomes [4, 2, 6, 3].\\n2. Repeat step 1. Array still is [4, 2, 6, 3].\\n3. Repeat step 1 again. Array still is [4, 2, 6, 3].\\n4. Finally, select index 3 (i.e., the number 3) and take the gcd with the number at index 2 (i.e., the number 6), and replace 3 with gcd(3, 6) = 3. Array becomes [4, 2, 6, 1].\\n5. Now, select index 0 (i.e., the number 4) and take the gcd with the number at index 1 (i.e., the number 2), and replace 4 with gcd(4, 2) = 2. Array becomes [2, 2, 6, 1].\\n6. Next, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array still is [2, 2, 6, 1].\\n7. Repeat step 6. Array still is [2, 2, 6, 1].\\n8. Repeat step 6 again. Array still is [2, 2, 6, 1].\\n9. Repeat step 6 once more. Array still is [2, 2, 6, 1].\\n10. Finally, select index 2 (i.e., the number 6) and take the gcd with the number at index 3 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, \\n\\n2, 1, 1].\\n11. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 2), and replace 2 with gcd(2, 2) = 2. Array still is [2, 2, 1, 1].\\n12. Repeat step 11. Array still is [2, 2, 1, 1].\\n13. Repeat step 11 again. Array still is [2, 2, 1, 1].\\n14. Finally, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [2, 1, 1, 1].\\n15. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 15.\\n\\nThis demonstrates how the order of the array can affect the total number of operations required to achieve all elements as 1. The most optimized way to get all elements to 1 can depend on the order of elements in the array."
                    },
                    {
                        "username": "ZX007java",
                        "content": "[@s_m99](/s_m99) THANK YOU !!! CONSECUTIVE !!!"
                    },
                    {
                        "username": "s_m99",
                        "content": "You can only calculate gcd\\'s of 2 **consecutive** numbers and replace either of them. So in set [4,2,6,3] to make 3 into 1 we require two operations instead of one in [2,6,3,4] "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn, that was a great problem but... Medium, really? Am I just getting dumber? \nTook me quite lot of time and tryhard to see the solution.\nAnd that's gotta be the lowest acceptance rate I've seen for a medium problem\n\nAlso, python has a built-in gcd function apparently. Lesson learned; next time, no need to face my anxieties trying to remember my number theory classes to implement the Euclidean algo myself"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "Anyone explain or hint"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "light hint: how many steps would it take to get your first one in the array? And once you have a one, how many more steps do you need to turn everything into a one?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I am not able to understand the question\\nit says \\nselect index i and change num[i] or num[i+1] with their GCD and people have used n^2 loop to check every pair"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the minimum number of operations required to make all elements of an array equal to 1, by replacing either nums[i] or nums[i+1] with their gcd (greatest common divisor).\\n\\nThe problem solution is implemented with an O(n^2) approach, and this is why:\\n\\n1. You iterate over each element in the array (first loop).\\n2. For each element, you check for a contiguous segment in the array where the gcd of the numbers in the segment equals 1 (second loop). If such a segment is found, you store the length of that segment minus 1 (because one element is already 1 and doesn\\'t need any operation).\\n3. The result of the algorithm is the minimum length of these segments (if any) plus the number of elements outside these segments (because each of these will need one operation to become 1, by taking the gcd with 1).\\n\\nThe algorithm needs to check all pairs of elements because the array isn\\'t necessarily sorted, and any pair (i, j) with i < j can potentially form a contiguous segment where the gcd of the numbers is 1. So, an element nums[i] might be replaced by the gcd of nums[i] and nums[j] for some j > i.\\n"
                    },
                    {
                        "username": "User___",
                        "content": "[@cartesPerforees](/cartesPerforees) Is that $$O(n)$$?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you understand the question, it's just the solutions that you don't understand.\nWe check every pair to find the closest elements that could lead to a gcd of 1. Then we propagate the gcd neighbor-by-neighbor"
                    }
                ]
            },
            {
                "id": 1871447,
                "content": [
                    {
                        "username": "rideau",
                        "content": "Does anybody know how solve this in O(1) time? Is this even possible?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Pay no attention to that follow-up. The person who wrote it was drunk."
                    },
                    {
                        "username": "User___",
                        "content": "Did you manage to solve it in $$O(n)$$? Just wondering, since you\\'re asking about $$O(1)$$ (which I feel isn\\'t possible)"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "I think it's quite easy to prove that it impossible to solve this problem in O(1) time complexity.\nImaging you have an array of length N, for which the asnwer is \"-1\" - that is, you cannot make all elements equal to 1 using any number of operations. Now, insert number \"1\" at a random index of the array, and now you can make all other numbers equal to 1. In order to find this \"1\" you need O(N) time complexity."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your reasoning is absolutely correct. As per the problem, you need to inspect each element of the array to determine if the number 1 is present or if a pair of numbers exists such that their greatest common divisor (gcd) is 1. This requires at least linear time, O(N), where N is the length of the array.\\n\\nAs you\\'ve aptly illustrated, the presence of a single 1 in the array changes the entire outcome of the problem. Without examining each element, we cannot determine the presence or absence of such a crucial value. This necessitates iterating through the array at least once, thereby confirming that the problem cannot be solved in constant time, O(1)."
                    },
                    {
                        "username": "SlickGeek",
                        "content": "\"...but could you find an O(1) constant time complexity solution?\" Is it actually possible to solve this problem in constant time? I don\\'t know if there\\'s something I am not seeing or understanding, but I don\\'t think that is possible.\\nThe solution I came up with runs in N^2 and beats 71%."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rideau](/rideau) see [@Sergey TT](/SergeyTT)\\'s respose"
                    },
                    {
                        "username": "rideau",
                        "content": "Any updates? Im also interested "
                    },
                    {
                        "username": "sanjitj7",
                        "content": "EDIT: I have spotted my n00b mistake\n\nI think this test case is incorrect!\n\n>Input: nums = [2,10,6,14]\n>Output: -1\n>Explanation: It can be shown that it is impossible to make all the elements equal to 1\n\n[2,10,6,14]\n[2,10,3,14]  (i = 2)\n[2,10,3,1]   (i = 2)\n[2,10,1,1]\n[2,1,1,1]\n[1,1,1,1]\n\nThis caused a lot of confusion to me."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "oh scheisse, I was taking num/GCD there \\uD83D\\uDE05 "
                    },
                    {
                        "username": "srk696772",
                        "content": "Bro GCD(6,14) == 2 ,  \nnot 3"
                    },
                    {
                        "username": "bekbossyn_kassymkhan",
                        "content": "gcd(6 & 14) = 2 , gcd(10,6)=2 also \n:)"
                    },
                    {
                        "username": "gaurav1903",
                        "content": "What\\'s the O(N) solution??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The O(N) solution leverages the fact that if we can find two numbers in the array whose greatest common divisor (gcd) is 1, then the minimum number of operations required is the size of the array minus 1.\\n\\nTo achieve this in linear time, we can use the Sieve of Eratosthenes, a well-known algorithm for finding all prime numbers up to a given limit. This algorithm can be used to find the smallest prime factor for each number in the array, which is a prerequisite for finding two numbers with gcd 1.\\n\\nHere are the steps of the algorithm:\\n\\n1. Compute the smallest prime factor for each number up to max(nums) using the Sieve of Eratosthenes.\\n2. For each number in nums, if its smallest prime factor divides another number in nums, we can assume that the gcd of these two numbers is 1.\\n3. If we find such a pair, the minimum number of operations required is the size of the array minus 1.\\n4. If no such pair exists, we cannot make all elements equal to 1, so we return -1.\\n\\nNote: As the Sieve of Eratosthenes requires O(N log log N) time complexity, this solution is not strictly linear. However, it is significantly more efficient than an O(N^2) solution when dealing with large inputs.\\n\\nThis solution assumes that the input numbers are not too large (e.g., within the range of an integer). If the numbers can be very large, we need a different approach because the Sieve of Eratosthenes may not be feasible. For example, we could use a probabilistic algorithm to find a pair of numbers with gcd 1, but this would not guarantee a correct answer in all cases.\\n\\nAlso, it\\'s important to note that this approach doesn\\'t give the exact number of operations if no \"1\" is found in the array; it only checks for the possibility of making all elements equal to 1. Calculating the exact number of operations in such a case can be a more complex problem and is likely to require more than linear time."
                    },
                    {
                        "username": "ZX007java",
                        "content": "Good day ! Can anyone give me answer : why set [2, 6, 3, 4] have answer is equal 4, BUT SET [4, 2, 6, 3] have answer is equal 5 ???"
                    },
                    {
                        "username": "bparanj",
                        "content": "This discrepancy arises from the order in which we are allowed to perform the gcd operations on the array.\\n\\nFor the array [2, 6, 3, 4]:\\n\\n1. We can select index 2 (i.e., the number 3) and take the gcd with the number at index 3 (i.e., the number 4), and replace 3 with gcd(3, 4) = 1. Array becomes [2, 6, 1, 4].\\n2. We can then select index 1 (i.e., the number 6) and take the gcd with the number at index 2 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, 1, 1, 4].\\n3. Then, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 4].\\n4. Finally, select index 2 (i.e., the number 1) and take the gcd with the number at index 3 (i.e., the number 4), and replace 4 with gcd(1, 4) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 4.\\n\\nFor the array [4, 2, 6, 3]:\\n\\n1. We can select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array becomes [4, 2, 6, 3].\\n2. Repeat step 1. Array still is [4, 2, 6, 3].\\n3. Repeat step 1 again. Array still is [4, 2, 6, 3].\\n4. Finally, select index 3 (i.e., the number 3) and take the gcd with the number at index 2 (i.e., the number 6), and replace 3 with gcd(3, 6) = 3. Array becomes [4, 2, 6, 1].\\n5. Now, select index 0 (i.e., the number 4) and take the gcd with the number at index 1 (i.e., the number 2), and replace 4 with gcd(4, 2) = 2. Array becomes [2, 2, 6, 1].\\n6. Next, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array still is [2, 2, 6, 1].\\n7. Repeat step 6. Array still is [2, 2, 6, 1].\\n8. Repeat step 6 again. Array still is [2, 2, 6, 1].\\n9. Repeat step 6 once more. Array still is [2, 2, 6, 1].\\n10. Finally, select index 2 (i.e., the number 6) and take the gcd with the number at index 3 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, \\n\\n2, 1, 1].\\n11. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 2), and replace 2 with gcd(2, 2) = 2. Array still is [2, 2, 1, 1].\\n12. Repeat step 11. Array still is [2, 2, 1, 1].\\n13. Repeat step 11 again. Array still is [2, 2, 1, 1].\\n14. Finally, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [2, 1, 1, 1].\\n15. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 15.\\n\\nThis demonstrates how the order of the array can affect the total number of operations required to achieve all elements as 1. The most optimized way to get all elements to 1 can depend on the order of elements in the array."
                    },
                    {
                        "username": "ZX007java",
                        "content": "[@s_m99](/s_m99) THANK YOU !!! CONSECUTIVE !!!"
                    },
                    {
                        "username": "s_m99",
                        "content": "You can only calculate gcd\\'s of 2 **consecutive** numbers and replace either of them. So in set [4,2,6,3] to make 3 into 1 we require two operations instead of one in [2,6,3,4] "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn, that was a great problem but... Medium, really? Am I just getting dumber? \nTook me quite lot of time and tryhard to see the solution.\nAnd that's gotta be the lowest acceptance rate I've seen for a medium problem\n\nAlso, python has a built-in gcd function apparently. Lesson learned; next time, no need to face my anxieties trying to remember my number theory classes to implement the Euclidean algo myself"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "Anyone explain or hint"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "light hint: how many steps would it take to get your first one in the array? And once you have a one, how many more steps do you need to turn everything into a one?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I am not able to understand the question\\nit says \\nselect index i and change num[i] or num[i+1] with their GCD and people have used n^2 loop to check every pair"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the minimum number of operations required to make all elements of an array equal to 1, by replacing either nums[i] or nums[i+1] with their gcd (greatest common divisor).\\n\\nThe problem solution is implemented with an O(n^2) approach, and this is why:\\n\\n1. You iterate over each element in the array (first loop).\\n2. For each element, you check for a contiguous segment in the array where the gcd of the numbers in the segment equals 1 (second loop). If such a segment is found, you store the length of that segment minus 1 (because one element is already 1 and doesn\\'t need any operation).\\n3. The result of the algorithm is the minimum length of these segments (if any) plus the number of elements outside these segments (because each of these will need one operation to become 1, by taking the gcd with 1).\\n\\nThe algorithm needs to check all pairs of elements because the array isn\\'t necessarily sorted, and any pair (i, j) with i < j can potentially form a contiguous segment where the gcd of the numbers is 1. So, an element nums[i] might be replaced by the gcd of nums[i] and nums[j] for some j > i.\\n"
                    },
                    {
                        "username": "User___",
                        "content": "[@cartesPerforees](/cartesPerforees) Is that $$O(n)$$?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you understand the question, it's just the solutions that you don't understand.\nWe check every pair to find the closest elements that could lead to a gcd of 1. Then we propagate the gcd neighbor-by-neighbor"
                    }
                ]
            },
            {
                "id": 1898536,
                "content": [
                    {
                        "username": "rideau",
                        "content": "Does anybody know how solve this in O(1) time? Is this even possible?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Pay no attention to that follow-up. The person who wrote it was drunk."
                    },
                    {
                        "username": "User___",
                        "content": "Did you manage to solve it in $$O(n)$$? Just wondering, since you\\'re asking about $$O(1)$$ (which I feel isn\\'t possible)"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "I think it's quite easy to prove that it impossible to solve this problem in O(1) time complexity.\nImaging you have an array of length N, for which the asnwer is \"-1\" - that is, you cannot make all elements equal to 1 using any number of operations. Now, insert number \"1\" at a random index of the array, and now you can make all other numbers equal to 1. In order to find this \"1\" you need O(N) time complexity."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your reasoning is absolutely correct. As per the problem, you need to inspect each element of the array to determine if the number 1 is present or if a pair of numbers exists such that their greatest common divisor (gcd) is 1. This requires at least linear time, O(N), where N is the length of the array.\\n\\nAs you\\'ve aptly illustrated, the presence of a single 1 in the array changes the entire outcome of the problem. Without examining each element, we cannot determine the presence or absence of such a crucial value. This necessitates iterating through the array at least once, thereby confirming that the problem cannot be solved in constant time, O(1)."
                    },
                    {
                        "username": "SlickGeek",
                        "content": "\"...but could you find an O(1) constant time complexity solution?\" Is it actually possible to solve this problem in constant time? I don\\'t know if there\\'s something I am not seeing or understanding, but I don\\'t think that is possible.\\nThe solution I came up with runs in N^2 and beats 71%."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rideau](/rideau) see [@Sergey TT](/SergeyTT)\\'s respose"
                    },
                    {
                        "username": "rideau",
                        "content": "Any updates? Im also interested "
                    },
                    {
                        "username": "sanjitj7",
                        "content": "EDIT: I have spotted my n00b mistake\n\nI think this test case is incorrect!\n\n>Input: nums = [2,10,6,14]\n>Output: -1\n>Explanation: It can be shown that it is impossible to make all the elements equal to 1\n\n[2,10,6,14]\n[2,10,3,14]  (i = 2)\n[2,10,3,1]   (i = 2)\n[2,10,1,1]\n[2,1,1,1]\n[1,1,1,1]\n\nThis caused a lot of confusion to me."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "oh scheisse, I was taking num/GCD there \\uD83D\\uDE05 "
                    },
                    {
                        "username": "srk696772",
                        "content": "Bro GCD(6,14) == 2 ,  \nnot 3"
                    },
                    {
                        "username": "bekbossyn_kassymkhan",
                        "content": "gcd(6 & 14) = 2 , gcd(10,6)=2 also \n:)"
                    },
                    {
                        "username": "gaurav1903",
                        "content": "What\\'s the O(N) solution??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The O(N) solution leverages the fact that if we can find two numbers in the array whose greatest common divisor (gcd) is 1, then the minimum number of operations required is the size of the array minus 1.\\n\\nTo achieve this in linear time, we can use the Sieve of Eratosthenes, a well-known algorithm for finding all prime numbers up to a given limit. This algorithm can be used to find the smallest prime factor for each number in the array, which is a prerequisite for finding two numbers with gcd 1.\\n\\nHere are the steps of the algorithm:\\n\\n1. Compute the smallest prime factor for each number up to max(nums) using the Sieve of Eratosthenes.\\n2. For each number in nums, if its smallest prime factor divides another number in nums, we can assume that the gcd of these two numbers is 1.\\n3. If we find such a pair, the minimum number of operations required is the size of the array minus 1.\\n4. If no such pair exists, we cannot make all elements equal to 1, so we return -1.\\n\\nNote: As the Sieve of Eratosthenes requires O(N log log N) time complexity, this solution is not strictly linear. However, it is significantly more efficient than an O(N^2) solution when dealing with large inputs.\\n\\nThis solution assumes that the input numbers are not too large (e.g., within the range of an integer). If the numbers can be very large, we need a different approach because the Sieve of Eratosthenes may not be feasible. For example, we could use a probabilistic algorithm to find a pair of numbers with gcd 1, but this would not guarantee a correct answer in all cases.\\n\\nAlso, it\\'s important to note that this approach doesn\\'t give the exact number of operations if no \"1\" is found in the array; it only checks for the possibility of making all elements equal to 1. Calculating the exact number of operations in such a case can be a more complex problem and is likely to require more than linear time."
                    },
                    {
                        "username": "ZX007java",
                        "content": "Good day ! Can anyone give me answer : why set [2, 6, 3, 4] have answer is equal 4, BUT SET [4, 2, 6, 3] have answer is equal 5 ???"
                    },
                    {
                        "username": "bparanj",
                        "content": "This discrepancy arises from the order in which we are allowed to perform the gcd operations on the array.\\n\\nFor the array [2, 6, 3, 4]:\\n\\n1. We can select index 2 (i.e., the number 3) and take the gcd with the number at index 3 (i.e., the number 4), and replace 3 with gcd(3, 4) = 1. Array becomes [2, 6, 1, 4].\\n2. We can then select index 1 (i.e., the number 6) and take the gcd with the number at index 2 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, 1, 1, 4].\\n3. Then, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 4].\\n4. Finally, select index 2 (i.e., the number 1) and take the gcd with the number at index 3 (i.e., the number 4), and replace 4 with gcd(1, 4) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 4.\\n\\nFor the array [4, 2, 6, 3]:\\n\\n1. We can select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array becomes [4, 2, 6, 3].\\n2. Repeat step 1. Array still is [4, 2, 6, 3].\\n3. Repeat step 1 again. Array still is [4, 2, 6, 3].\\n4. Finally, select index 3 (i.e., the number 3) and take the gcd with the number at index 2 (i.e., the number 6), and replace 3 with gcd(3, 6) = 3. Array becomes [4, 2, 6, 1].\\n5. Now, select index 0 (i.e., the number 4) and take the gcd with the number at index 1 (i.e., the number 2), and replace 4 with gcd(4, 2) = 2. Array becomes [2, 2, 6, 1].\\n6. Next, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array still is [2, 2, 6, 1].\\n7. Repeat step 6. Array still is [2, 2, 6, 1].\\n8. Repeat step 6 again. Array still is [2, 2, 6, 1].\\n9. Repeat step 6 once more. Array still is [2, 2, 6, 1].\\n10. Finally, select index 2 (i.e., the number 6) and take the gcd with the number at index 3 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, \\n\\n2, 1, 1].\\n11. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 2), and replace 2 with gcd(2, 2) = 2. Array still is [2, 2, 1, 1].\\n12. Repeat step 11. Array still is [2, 2, 1, 1].\\n13. Repeat step 11 again. Array still is [2, 2, 1, 1].\\n14. Finally, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [2, 1, 1, 1].\\n15. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 15.\\n\\nThis demonstrates how the order of the array can affect the total number of operations required to achieve all elements as 1. The most optimized way to get all elements to 1 can depend on the order of elements in the array."
                    },
                    {
                        "username": "ZX007java",
                        "content": "[@s_m99](/s_m99) THANK YOU !!! CONSECUTIVE !!!"
                    },
                    {
                        "username": "s_m99",
                        "content": "You can only calculate gcd\\'s of 2 **consecutive** numbers and replace either of them. So in set [4,2,6,3] to make 3 into 1 we require two operations instead of one in [2,6,3,4] "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn, that was a great problem but... Medium, really? Am I just getting dumber? \nTook me quite lot of time and tryhard to see the solution.\nAnd that's gotta be the lowest acceptance rate I've seen for a medium problem\n\nAlso, python has a built-in gcd function apparently. Lesson learned; next time, no need to face my anxieties trying to remember my number theory classes to implement the Euclidean algo myself"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "Anyone explain or hint"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "light hint: how many steps would it take to get your first one in the array? And once you have a one, how many more steps do you need to turn everything into a one?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I am not able to understand the question\\nit says \\nselect index i and change num[i] or num[i+1] with their GCD and people have used n^2 loop to check every pair"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the minimum number of operations required to make all elements of an array equal to 1, by replacing either nums[i] or nums[i+1] with their gcd (greatest common divisor).\\n\\nThe problem solution is implemented with an O(n^2) approach, and this is why:\\n\\n1. You iterate over each element in the array (first loop).\\n2. For each element, you check for a contiguous segment in the array where the gcd of the numbers in the segment equals 1 (second loop). If such a segment is found, you store the length of that segment minus 1 (because one element is already 1 and doesn\\'t need any operation).\\n3. The result of the algorithm is the minimum length of these segments (if any) plus the number of elements outside these segments (because each of these will need one operation to become 1, by taking the gcd with 1).\\n\\nThe algorithm needs to check all pairs of elements because the array isn\\'t necessarily sorted, and any pair (i, j) with i < j can potentially form a contiguous segment where the gcd of the numbers is 1. So, an element nums[i] might be replaced by the gcd of nums[i] and nums[j] for some j > i.\\n"
                    },
                    {
                        "username": "User___",
                        "content": "[@cartesPerforees](/cartesPerforees) Is that $$O(n)$$?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you understand the question, it's just the solutions that you don't understand.\nWe check every pair to find the closest elements that could lead to a gcd of 1. Then we propagate the gcd neighbor-by-neighbor"
                    }
                ]
            },
            {
                "id": 1880916,
                "content": [
                    {
                        "username": "rideau",
                        "content": "Does anybody know how solve this in O(1) time? Is this even possible?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Pay no attention to that follow-up. The person who wrote it was drunk."
                    },
                    {
                        "username": "User___",
                        "content": "Did you manage to solve it in $$O(n)$$? Just wondering, since you\\'re asking about $$O(1)$$ (which I feel isn\\'t possible)"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "I think it's quite easy to prove that it impossible to solve this problem in O(1) time complexity.\nImaging you have an array of length N, for which the asnwer is \"-1\" - that is, you cannot make all elements equal to 1 using any number of operations. Now, insert number \"1\" at a random index of the array, and now you can make all other numbers equal to 1. In order to find this \"1\" you need O(N) time complexity."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your reasoning is absolutely correct. As per the problem, you need to inspect each element of the array to determine if the number 1 is present or if a pair of numbers exists such that their greatest common divisor (gcd) is 1. This requires at least linear time, O(N), where N is the length of the array.\\n\\nAs you\\'ve aptly illustrated, the presence of a single 1 in the array changes the entire outcome of the problem. Without examining each element, we cannot determine the presence or absence of such a crucial value. This necessitates iterating through the array at least once, thereby confirming that the problem cannot be solved in constant time, O(1)."
                    },
                    {
                        "username": "SlickGeek",
                        "content": "\"...but could you find an O(1) constant time complexity solution?\" Is it actually possible to solve this problem in constant time? I don\\'t know if there\\'s something I am not seeing or understanding, but I don\\'t think that is possible.\\nThe solution I came up with runs in N^2 and beats 71%."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rideau](/rideau) see [@Sergey TT](/SergeyTT)\\'s respose"
                    },
                    {
                        "username": "rideau",
                        "content": "Any updates? Im also interested "
                    },
                    {
                        "username": "sanjitj7",
                        "content": "EDIT: I have spotted my n00b mistake\n\nI think this test case is incorrect!\n\n>Input: nums = [2,10,6,14]\n>Output: -1\n>Explanation: It can be shown that it is impossible to make all the elements equal to 1\n\n[2,10,6,14]\n[2,10,3,14]  (i = 2)\n[2,10,3,1]   (i = 2)\n[2,10,1,1]\n[2,1,1,1]\n[1,1,1,1]\n\nThis caused a lot of confusion to me."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "oh scheisse, I was taking num/GCD there \\uD83D\\uDE05 "
                    },
                    {
                        "username": "srk696772",
                        "content": "Bro GCD(6,14) == 2 ,  \nnot 3"
                    },
                    {
                        "username": "bekbossyn_kassymkhan",
                        "content": "gcd(6 & 14) = 2 , gcd(10,6)=2 also \n:)"
                    },
                    {
                        "username": "gaurav1903",
                        "content": "What\\'s the O(N) solution??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The O(N) solution leverages the fact that if we can find two numbers in the array whose greatest common divisor (gcd) is 1, then the minimum number of operations required is the size of the array minus 1.\\n\\nTo achieve this in linear time, we can use the Sieve of Eratosthenes, a well-known algorithm for finding all prime numbers up to a given limit. This algorithm can be used to find the smallest prime factor for each number in the array, which is a prerequisite for finding two numbers with gcd 1.\\n\\nHere are the steps of the algorithm:\\n\\n1. Compute the smallest prime factor for each number up to max(nums) using the Sieve of Eratosthenes.\\n2. For each number in nums, if its smallest prime factor divides another number in nums, we can assume that the gcd of these two numbers is 1.\\n3. If we find such a pair, the minimum number of operations required is the size of the array minus 1.\\n4. If no such pair exists, we cannot make all elements equal to 1, so we return -1.\\n\\nNote: As the Sieve of Eratosthenes requires O(N log log N) time complexity, this solution is not strictly linear. However, it is significantly more efficient than an O(N^2) solution when dealing with large inputs.\\n\\nThis solution assumes that the input numbers are not too large (e.g., within the range of an integer). If the numbers can be very large, we need a different approach because the Sieve of Eratosthenes may not be feasible. For example, we could use a probabilistic algorithm to find a pair of numbers with gcd 1, but this would not guarantee a correct answer in all cases.\\n\\nAlso, it\\'s important to note that this approach doesn\\'t give the exact number of operations if no \"1\" is found in the array; it only checks for the possibility of making all elements equal to 1. Calculating the exact number of operations in such a case can be a more complex problem and is likely to require more than linear time."
                    },
                    {
                        "username": "ZX007java",
                        "content": "Good day ! Can anyone give me answer : why set [2, 6, 3, 4] have answer is equal 4, BUT SET [4, 2, 6, 3] have answer is equal 5 ???"
                    },
                    {
                        "username": "bparanj",
                        "content": "This discrepancy arises from the order in which we are allowed to perform the gcd operations on the array.\\n\\nFor the array [2, 6, 3, 4]:\\n\\n1. We can select index 2 (i.e., the number 3) and take the gcd with the number at index 3 (i.e., the number 4), and replace 3 with gcd(3, 4) = 1. Array becomes [2, 6, 1, 4].\\n2. We can then select index 1 (i.e., the number 6) and take the gcd with the number at index 2 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, 1, 1, 4].\\n3. Then, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 4].\\n4. Finally, select index 2 (i.e., the number 1) and take the gcd with the number at index 3 (i.e., the number 4), and replace 4 with gcd(1, 4) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 4.\\n\\nFor the array [4, 2, 6, 3]:\\n\\n1. We can select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array becomes [4, 2, 6, 3].\\n2. Repeat step 1. Array still is [4, 2, 6, 3].\\n3. Repeat step 1 again. Array still is [4, 2, 6, 3].\\n4. Finally, select index 3 (i.e., the number 3) and take the gcd with the number at index 2 (i.e., the number 6), and replace 3 with gcd(3, 6) = 3. Array becomes [4, 2, 6, 1].\\n5. Now, select index 0 (i.e., the number 4) and take the gcd with the number at index 1 (i.e., the number 2), and replace 4 with gcd(4, 2) = 2. Array becomes [2, 2, 6, 1].\\n6. Next, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array still is [2, 2, 6, 1].\\n7. Repeat step 6. Array still is [2, 2, 6, 1].\\n8. Repeat step 6 again. Array still is [2, 2, 6, 1].\\n9. Repeat step 6 once more. Array still is [2, 2, 6, 1].\\n10. Finally, select index 2 (i.e., the number 6) and take the gcd with the number at index 3 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, \\n\\n2, 1, 1].\\n11. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 2), and replace 2 with gcd(2, 2) = 2. Array still is [2, 2, 1, 1].\\n12. Repeat step 11. Array still is [2, 2, 1, 1].\\n13. Repeat step 11 again. Array still is [2, 2, 1, 1].\\n14. Finally, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [2, 1, 1, 1].\\n15. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 15.\\n\\nThis demonstrates how the order of the array can affect the total number of operations required to achieve all elements as 1. The most optimized way to get all elements to 1 can depend on the order of elements in the array."
                    },
                    {
                        "username": "ZX007java",
                        "content": "[@s_m99](/s_m99) THANK YOU !!! CONSECUTIVE !!!"
                    },
                    {
                        "username": "s_m99",
                        "content": "You can only calculate gcd\\'s of 2 **consecutive** numbers and replace either of them. So in set [4,2,6,3] to make 3 into 1 we require two operations instead of one in [2,6,3,4] "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn, that was a great problem but... Medium, really? Am I just getting dumber? \nTook me quite lot of time and tryhard to see the solution.\nAnd that's gotta be the lowest acceptance rate I've seen for a medium problem\n\nAlso, python has a built-in gcd function apparently. Lesson learned; next time, no need to face my anxieties trying to remember my number theory classes to implement the Euclidean algo myself"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "Anyone explain or hint"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "light hint: how many steps would it take to get your first one in the array? And once you have a one, how many more steps do you need to turn everything into a one?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I am not able to understand the question\\nit says \\nselect index i and change num[i] or num[i+1] with their GCD and people have used n^2 loop to check every pair"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the minimum number of operations required to make all elements of an array equal to 1, by replacing either nums[i] or nums[i+1] with their gcd (greatest common divisor).\\n\\nThe problem solution is implemented with an O(n^2) approach, and this is why:\\n\\n1. You iterate over each element in the array (first loop).\\n2. For each element, you check for a contiguous segment in the array where the gcd of the numbers in the segment equals 1 (second loop). If such a segment is found, you store the length of that segment minus 1 (because one element is already 1 and doesn\\'t need any operation).\\n3. The result of the algorithm is the minimum length of these segments (if any) plus the number of elements outside these segments (because each of these will need one operation to become 1, by taking the gcd with 1).\\n\\nThe algorithm needs to check all pairs of elements because the array isn\\'t necessarily sorted, and any pair (i, j) with i < j can potentially form a contiguous segment where the gcd of the numbers is 1. So, an element nums[i] might be replaced by the gcd of nums[i] and nums[j] for some j > i.\\n"
                    },
                    {
                        "username": "User___",
                        "content": "[@cartesPerforees](/cartesPerforees) Is that $$O(n)$$?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you understand the question, it's just the solutions that you don't understand.\nWe check every pair to find the closest elements that could lead to a gcd of 1. Then we propagate the gcd neighbor-by-neighbor"
                    }
                ]
            },
            {
                "id": 1872644,
                "content": [
                    {
                        "username": "rideau",
                        "content": "Does anybody know how solve this in O(1) time? Is this even possible?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Pay no attention to that follow-up. The person who wrote it was drunk."
                    },
                    {
                        "username": "User___",
                        "content": "Did you manage to solve it in $$O(n)$$? Just wondering, since you\\'re asking about $$O(1)$$ (which I feel isn\\'t possible)"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "I think it's quite easy to prove that it impossible to solve this problem in O(1) time complexity.\nImaging you have an array of length N, for which the asnwer is \"-1\" - that is, you cannot make all elements equal to 1 using any number of operations. Now, insert number \"1\" at a random index of the array, and now you can make all other numbers equal to 1. In order to find this \"1\" you need O(N) time complexity."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your reasoning is absolutely correct. As per the problem, you need to inspect each element of the array to determine if the number 1 is present or if a pair of numbers exists such that their greatest common divisor (gcd) is 1. This requires at least linear time, O(N), where N is the length of the array.\\n\\nAs you\\'ve aptly illustrated, the presence of a single 1 in the array changes the entire outcome of the problem. Without examining each element, we cannot determine the presence or absence of such a crucial value. This necessitates iterating through the array at least once, thereby confirming that the problem cannot be solved in constant time, O(1)."
                    },
                    {
                        "username": "SlickGeek",
                        "content": "\"...but could you find an O(1) constant time complexity solution?\" Is it actually possible to solve this problem in constant time? I don\\'t know if there\\'s something I am not seeing or understanding, but I don\\'t think that is possible.\\nThe solution I came up with runs in N^2 and beats 71%."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rideau](/rideau) see [@Sergey TT](/SergeyTT)\\'s respose"
                    },
                    {
                        "username": "rideau",
                        "content": "Any updates? Im also interested "
                    },
                    {
                        "username": "sanjitj7",
                        "content": "EDIT: I have spotted my n00b mistake\n\nI think this test case is incorrect!\n\n>Input: nums = [2,10,6,14]\n>Output: -1\n>Explanation: It can be shown that it is impossible to make all the elements equal to 1\n\n[2,10,6,14]\n[2,10,3,14]  (i = 2)\n[2,10,3,1]   (i = 2)\n[2,10,1,1]\n[2,1,1,1]\n[1,1,1,1]\n\nThis caused a lot of confusion to me."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "oh scheisse, I was taking num/GCD there \\uD83D\\uDE05 "
                    },
                    {
                        "username": "srk696772",
                        "content": "Bro GCD(6,14) == 2 ,  \nnot 3"
                    },
                    {
                        "username": "bekbossyn_kassymkhan",
                        "content": "gcd(6 & 14) = 2 , gcd(10,6)=2 also \n:)"
                    },
                    {
                        "username": "gaurav1903",
                        "content": "What\\'s the O(N) solution??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The O(N) solution leverages the fact that if we can find two numbers in the array whose greatest common divisor (gcd) is 1, then the minimum number of operations required is the size of the array minus 1.\\n\\nTo achieve this in linear time, we can use the Sieve of Eratosthenes, a well-known algorithm for finding all prime numbers up to a given limit. This algorithm can be used to find the smallest prime factor for each number in the array, which is a prerequisite for finding two numbers with gcd 1.\\n\\nHere are the steps of the algorithm:\\n\\n1. Compute the smallest prime factor for each number up to max(nums) using the Sieve of Eratosthenes.\\n2. For each number in nums, if its smallest prime factor divides another number in nums, we can assume that the gcd of these two numbers is 1.\\n3. If we find such a pair, the minimum number of operations required is the size of the array minus 1.\\n4. If no such pair exists, we cannot make all elements equal to 1, so we return -1.\\n\\nNote: As the Sieve of Eratosthenes requires O(N log log N) time complexity, this solution is not strictly linear. However, it is significantly more efficient than an O(N^2) solution when dealing with large inputs.\\n\\nThis solution assumes that the input numbers are not too large (e.g., within the range of an integer). If the numbers can be very large, we need a different approach because the Sieve of Eratosthenes may not be feasible. For example, we could use a probabilistic algorithm to find a pair of numbers with gcd 1, but this would not guarantee a correct answer in all cases.\\n\\nAlso, it\\'s important to note that this approach doesn\\'t give the exact number of operations if no \"1\" is found in the array; it only checks for the possibility of making all elements equal to 1. Calculating the exact number of operations in such a case can be a more complex problem and is likely to require more than linear time."
                    },
                    {
                        "username": "ZX007java",
                        "content": "Good day ! Can anyone give me answer : why set [2, 6, 3, 4] have answer is equal 4, BUT SET [4, 2, 6, 3] have answer is equal 5 ???"
                    },
                    {
                        "username": "bparanj",
                        "content": "This discrepancy arises from the order in which we are allowed to perform the gcd operations on the array.\\n\\nFor the array [2, 6, 3, 4]:\\n\\n1. We can select index 2 (i.e., the number 3) and take the gcd with the number at index 3 (i.e., the number 4), and replace 3 with gcd(3, 4) = 1. Array becomes [2, 6, 1, 4].\\n2. We can then select index 1 (i.e., the number 6) and take the gcd with the number at index 2 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, 1, 1, 4].\\n3. Then, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 4].\\n4. Finally, select index 2 (i.e., the number 1) and take the gcd with the number at index 3 (i.e., the number 4), and replace 4 with gcd(1, 4) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 4.\\n\\nFor the array [4, 2, 6, 3]:\\n\\n1. We can select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array becomes [4, 2, 6, 3].\\n2. Repeat step 1. Array still is [4, 2, 6, 3].\\n3. Repeat step 1 again. Array still is [4, 2, 6, 3].\\n4. Finally, select index 3 (i.e., the number 3) and take the gcd with the number at index 2 (i.e., the number 6), and replace 3 with gcd(3, 6) = 3. Array becomes [4, 2, 6, 1].\\n5. Now, select index 0 (i.e., the number 4) and take the gcd with the number at index 1 (i.e., the number 2), and replace 4 with gcd(4, 2) = 2. Array becomes [2, 2, 6, 1].\\n6. Next, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array still is [2, 2, 6, 1].\\n7. Repeat step 6. Array still is [2, 2, 6, 1].\\n8. Repeat step 6 again. Array still is [2, 2, 6, 1].\\n9. Repeat step 6 once more. Array still is [2, 2, 6, 1].\\n10. Finally, select index 2 (i.e., the number 6) and take the gcd with the number at index 3 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, \\n\\n2, 1, 1].\\n11. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 2), and replace 2 with gcd(2, 2) = 2. Array still is [2, 2, 1, 1].\\n12. Repeat step 11. Array still is [2, 2, 1, 1].\\n13. Repeat step 11 again. Array still is [2, 2, 1, 1].\\n14. Finally, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [2, 1, 1, 1].\\n15. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 15.\\n\\nThis demonstrates how the order of the array can affect the total number of operations required to achieve all elements as 1. The most optimized way to get all elements to 1 can depend on the order of elements in the array."
                    },
                    {
                        "username": "ZX007java",
                        "content": "[@s_m99](/s_m99) THANK YOU !!! CONSECUTIVE !!!"
                    },
                    {
                        "username": "s_m99",
                        "content": "You can only calculate gcd\\'s of 2 **consecutive** numbers and replace either of them. So in set [4,2,6,3] to make 3 into 1 we require two operations instead of one in [2,6,3,4] "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn, that was a great problem but... Medium, really? Am I just getting dumber? \nTook me quite lot of time and tryhard to see the solution.\nAnd that's gotta be the lowest acceptance rate I've seen for a medium problem\n\nAlso, python has a built-in gcd function apparently. Lesson learned; next time, no need to face my anxieties trying to remember my number theory classes to implement the Euclidean algo myself"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "Anyone explain or hint"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "light hint: how many steps would it take to get your first one in the array? And once you have a one, how many more steps do you need to turn everything into a one?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I am not able to understand the question\\nit says \\nselect index i and change num[i] or num[i+1] with their GCD and people have used n^2 loop to check every pair"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the minimum number of operations required to make all elements of an array equal to 1, by replacing either nums[i] or nums[i+1] with their gcd (greatest common divisor).\\n\\nThe problem solution is implemented with an O(n^2) approach, and this is why:\\n\\n1. You iterate over each element in the array (first loop).\\n2. For each element, you check for a contiguous segment in the array where the gcd of the numbers in the segment equals 1 (second loop). If such a segment is found, you store the length of that segment minus 1 (because one element is already 1 and doesn\\'t need any operation).\\n3. The result of the algorithm is the minimum length of these segments (if any) plus the number of elements outside these segments (because each of these will need one operation to become 1, by taking the gcd with 1).\\n\\nThe algorithm needs to check all pairs of elements because the array isn\\'t necessarily sorted, and any pair (i, j) with i < j can potentially form a contiguous segment where the gcd of the numbers is 1. So, an element nums[i] might be replaced by the gcd of nums[i] and nums[j] for some j > i.\\n"
                    },
                    {
                        "username": "User___",
                        "content": "[@cartesPerforees](/cartesPerforees) Is that $$O(n)$$?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you understand the question, it's just the solutions that you don't understand.\nWe check every pair to find the closest elements that could lead to a gcd of 1. Then we propagate the gcd neighbor-by-neighbor"
                    }
                ]
            },
            {
                "id": 1871729,
                "content": [
                    {
                        "username": "rideau",
                        "content": "Does anybody know how solve this in O(1) time? Is this even possible?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Pay no attention to that follow-up. The person who wrote it was drunk."
                    },
                    {
                        "username": "User___",
                        "content": "Did you manage to solve it in $$O(n)$$? Just wondering, since you\\'re asking about $$O(1)$$ (which I feel isn\\'t possible)"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "I think it's quite easy to prove that it impossible to solve this problem in O(1) time complexity.\nImaging you have an array of length N, for which the asnwer is \"-1\" - that is, you cannot make all elements equal to 1 using any number of operations. Now, insert number \"1\" at a random index of the array, and now you can make all other numbers equal to 1. In order to find this \"1\" you need O(N) time complexity."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your reasoning is absolutely correct. As per the problem, you need to inspect each element of the array to determine if the number 1 is present or if a pair of numbers exists such that their greatest common divisor (gcd) is 1. This requires at least linear time, O(N), where N is the length of the array.\\n\\nAs you\\'ve aptly illustrated, the presence of a single 1 in the array changes the entire outcome of the problem. Without examining each element, we cannot determine the presence or absence of such a crucial value. This necessitates iterating through the array at least once, thereby confirming that the problem cannot be solved in constant time, O(1)."
                    },
                    {
                        "username": "SlickGeek",
                        "content": "\"...but could you find an O(1) constant time complexity solution?\" Is it actually possible to solve this problem in constant time? I don\\'t know if there\\'s something I am not seeing or understanding, but I don\\'t think that is possible.\\nThe solution I came up with runs in N^2 and beats 71%."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rideau](/rideau) see [@Sergey TT](/SergeyTT)\\'s respose"
                    },
                    {
                        "username": "rideau",
                        "content": "Any updates? Im also interested "
                    },
                    {
                        "username": "sanjitj7",
                        "content": "EDIT: I have spotted my n00b mistake\n\nI think this test case is incorrect!\n\n>Input: nums = [2,10,6,14]\n>Output: -1\n>Explanation: It can be shown that it is impossible to make all the elements equal to 1\n\n[2,10,6,14]\n[2,10,3,14]  (i = 2)\n[2,10,3,1]   (i = 2)\n[2,10,1,1]\n[2,1,1,1]\n[1,1,1,1]\n\nThis caused a lot of confusion to me."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "oh scheisse, I was taking num/GCD there \\uD83D\\uDE05 "
                    },
                    {
                        "username": "srk696772",
                        "content": "Bro GCD(6,14) == 2 ,  \nnot 3"
                    },
                    {
                        "username": "bekbossyn_kassymkhan",
                        "content": "gcd(6 & 14) = 2 , gcd(10,6)=2 also \n:)"
                    },
                    {
                        "username": "gaurav1903",
                        "content": "What\\'s the O(N) solution??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The O(N) solution leverages the fact that if we can find two numbers in the array whose greatest common divisor (gcd) is 1, then the minimum number of operations required is the size of the array minus 1.\\n\\nTo achieve this in linear time, we can use the Sieve of Eratosthenes, a well-known algorithm for finding all prime numbers up to a given limit. This algorithm can be used to find the smallest prime factor for each number in the array, which is a prerequisite for finding two numbers with gcd 1.\\n\\nHere are the steps of the algorithm:\\n\\n1. Compute the smallest prime factor for each number up to max(nums) using the Sieve of Eratosthenes.\\n2. For each number in nums, if its smallest prime factor divides another number in nums, we can assume that the gcd of these two numbers is 1.\\n3. If we find such a pair, the minimum number of operations required is the size of the array minus 1.\\n4. If no such pair exists, we cannot make all elements equal to 1, so we return -1.\\n\\nNote: As the Sieve of Eratosthenes requires O(N log log N) time complexity, this solution is not strictly linear. However, it is significantly more efficient than an O(N^2) solution when dealing with large inputs.\\n\\nThis solution assumes that the input numbers are not too large (e.g., within the range of an integer). If the numbers can be very large, we need a different approach because the Sieve of Eratosthenes may not be feasible. For example, we could use a probabilistic algorithm to find a pair of numbers with gcd 1, but this would not guarantee a correct answer in all cases.\\n\\nAlso, it\\'s important to note that this approach doesn\\'t give the exact number of operations if no \"1\" is found in the array; it only checks for the possibility of making all elements equal to 1. Calculating the exact number of operations in such a case can be a more complex problem and is likely to require more than linear time."
                    },
                    {
                        "username": "ZX007java",
                        "content": "Good day ! Can anyone give me answer : why set [2, 6, 3, 4] have answer is equal 4, BUT SET [4, 2, 6, 3] have answer is equal 5 ???"
                    },
                    {
                        "username": "bparanj",
                        "content": "This discrepancy arises from the order in which we are allowed to perform the gcd operations on the array.\\n\\nFor the array [2, 6, 3, 4]:\\n\\n1. We can select index 2 (i.e., the number 3) and take the gcd with the number at index 3 (i.e., the number 4), and replace 3 with gcd(3, 4) = 1. Array becomes [2, 6, 1, 4].\\n2. We can then select index 1 (i.e., the number 6) and take the gcd with the number at index 2 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, 1, 1, 4].\\n3. Then, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 4].\\n4. Finally, select index 2 (i.e., the number 1) and take the gcd with the number at index 3 (i.e., the number 4), and replace 4 with gcd(1, 4) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 4.\\n\\nFor the array [4, 2, 6, 3]:\\n\\n1. We can select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array becomes [4, 2, 6, 3].\\n2. Repeat step 1. Array still is [4, 2, 6, 3].\\n3. Repeat step 1 again. Array still is [4, 2, 6, 3].\\n4. Finally, select index 3 (i.e., the number 3) and take the gcd with the number at index 2 (i.e., the number 6), and replace 3 with gcd(3, 6) = 3. Array becomes [4, 2, 6, 1].\\n5. Now, select index 0 (i.e., the number 4) and take the gcd with the number at index 1 (i.e., the number 2), and replace 4 with gcd(4, 2) = 2. Array becomes [2, 2, 6, 1].\\n6. Next, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array still is [2, 2, 6, 1].\\n7. Repeat step 6. Array still is [2, 2, 6, 1].\\n8. Repeat step 6 again. Array still is [2, 2, 6, 1].\\n9. Repeat step 6 once more. Array still is [2, 2, 6, 1].\\n10. Finally, select index 2 (i.e., the number 6) and take the gcd with the number at index 3 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, \\n\\n2, 1, 1].\\n11. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 2), and replace 2 with gcd(2, 2) = 2. Array still is [2, 2, 1, 1].\\n12. Repeat step 11. Array still is [2, 2, 1, 1].\\n13. Repeat step 11 again. Array still is [2, 2, 1, 1].\\n14. Finally, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [2, 1, 1, 1].\\n15. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 15.\\n\\nThis demonstrates how the order of the array can affect the total number of operations required to achieve all elements as 1. The most optimized way to get all elements to 1 can depend on the order of elements in the array."
                    },
                    {
                        "username": "ZX007java",
                        "content": "[@s_m99](/s_m99) THANK YOU !!! CONSECUTIVE !!!"
                    },
                    {
                        "username": "s_m99",
                        "content": "You can only calculate gcd\\'s of 2 **consecutive** numbers and replace either of them. So in set [4,2,6,3] to make 3 into 1 we require two operations instead of one in [2,6,3,4] "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn, that was a great problem but... Medium, really? Am I just getting dumber? \nTook me quite lot of time and tryhard to see the solution.\nAnd that's gotta be the lowest acceptance rate I've seen for a medium problem\n\nAlso, python has a built-in gcd function apparently. Lesson learned; next time, no need to face my anxieties trying to remember my number theory classes to implement the Euclidean algo myself"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "Anyone explain or hint"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "light hint: how many steps would it take to get your first one in the array? And once you have a one, how many more steps do you need to turn everything into a one?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I am not able to understand the question\\nit says \\nselect index i and change num[i] or num[i+1] with their GCD and people have used n^2 loop to check every pair"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the minimum number of operations required to make all elements of an array equal to 1, by replacing either nums[i] or nums[i+1] with their gcd (greatest common divisor).\\n\\nThe problem solution is implemented with an O(n^2) approach, and this is why:\\n\\n1. You iterate over each element in the array (first loop).\\n2. For each element, you check for a contiguous segment in the array where the gcd of the numbers in the segment equals 1 (second loop). If such a segment is found, you store the length of that segment minus 1 (because one element is already 1 and doesn\\'t need any operation).\\n3. The result of the algorithm is the minimum length of these segments (if any) plus the number of elements outside these segments (because each of these will need one operation to become 1, by taking the gcd with 1).\\n\\nThe algorithm needs to check all pairs of elements because the array isn\\'t necessarily sorted, and any pair (i, j) with i < j can potentially form a contiguous segment where the gcd of the numbers is 1. So, an element nums[i] might be replaced by the gcd of nums[i] and nums[j] for some j > i.\\n"
                    },
                    {
                        "username": "User___",
                        "content": "[@cartesPerforees](/cartesPerforees) Is that $$O(n)$$?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you understand the question, it's just the solutions that you don't understand.\nWe check every pair to find the closest elements that could lead to a gcd of 1. Then we propagate the gcd neighbor-by-neighbor"
                    }
                ]
            },
            {
                "id": 1871577,
                "content": [
                    {
                        "username": "rideau",
                        "content": "Does anybody know how solve this in O(1) time? Is this even possible?"
                    },
                    {
                        "username": "brinuke",
                        "content": "Pay no attention to that follow-up. The person who wrote it was drunk."
                    },
                    {
                        "username": "User___",
                        "content": "Did you manage to solve it in $$O(n)$$? Just wondering, since you\\'re asking about $$O(1)$$ (which I feel isn\\'t possible)"
                    },
                    {
                        "username": "SergeyTT",
                        "content": "I think it's quite easy to prove that it impossible to solve this problem in O(1) time complexity.\nImaging you have an array of length N, for which the asnwer is \"-1\" - that is, you cannot make all elements equal to 1 using any number of operations. Now, insert number \"1\" at a random index of the array, and now you can make all other numbers equal to 1. In order to find this \"1\" you need O(N) time complexity."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, your reasoning is absolutely correct. As per the problem, you need to inspect each element of the array to determine if the number 1 is present or if a pair of numbers exists such that their greatest common divisor (gcd) is 1. This requires at least linear time, O(N), where N is the length of the array.\\n\\nAs you\\'ve aptly illustrated, the presence of a single 1 in the array changes the entire outcome of the problem. Without examining each element, we cannot determine the presence or absence of such a crucial value. This necessitates iterating through the array at least once, thereby confirming that the problem cannot be solved in constant time, O(1)."
                    },
                    {
                        "username": "SlickGeek",
                        "content": "\"...but could you find an O(1) constant time complexity solution?\" Is it actually possible to solve this problem in constant time? I don\\'t know if there\\'s something I am not seeing or understanding, but I don\\'t think that is possible.\\nThe solution I came up with runs in N^2 and beats 71%."
                    },
                    {
                        "username": "bparanj",
                        "content": "[@rideau](/rideau) see [@Sergey TT](/SergeyTT)\\'s respose"
                    },
                    {
                        "username": "rideau",
                        "content": "Any updates? Im also interested "
                    },
                    {
                        "username": "sanjitj7",
                        "content": "EDIT: I have spotted my n00b mistake\n\nI think this test case is incorrect!\n\n>Input: nums = [2,10,6,14]\n>Output: -1\n>Explanation: It can be shown that it is impossible to make all the elements equal to 1\n\n[2,10,6,14]\n[2,10,3,14]  (i = 2)\n[2,10,3,1]   (i = 2)\n[2,10,1,1]\n[2,1,1,1]\n[1,1,1,1]\n\nThis caused a lot of confusion to me."
                    },
                    {
                        "username": "sanjitj7",
                        "content": "oh scheisse, I was taking num/GCD there \\uD83D\\uDE05 "
                    },
                    {
                        "username": "srk696772",
                        "content": "Bro GCD(6,14) == 2 ,  \nnot 3"
                    },
                    {
                        "username": "bekbossyn_kassymkhan",
                        "content": "gcd(6 & 14) = 2 , gcd(10,6)=2 also \n:)"
                    },
                    {
                        "username": "gaurav1903",
                        "content": "What\\'s the O(N) solution??"
                    },
                    {
                        "username": "bparanj",
                        "content": "The O(N) solution leverages the fact that if we can find two numbers in the array whose greatest common divisor (gcd) is 1, then the minimum number of operations required is the size of the array minus 1.\\n\\nTo achieve this in linear time, we can use the Sieve of Eratosthenes, a well-known algorithm for finding all prime numbers up to a given limit. This algorithm can be used to find the smallest prime factor for each number in the array, which is a prerequisite for finding two numbers with gcd 1.\\n\\nHere are the steps of the algorithm:\\n\\n1. Compute the smallest prime factor for each number up to max(nums) using the Sieve of Eratosthenes.\\n2. For each number in nums, if its smallest prime factor divides another number in nums, we can assume that the gcd of these two numbers is 1.\\n3. If we find such a pair, the minimum number of operations required is the size of the array minus 1.\\n4. If no such pair exists, we cannot make all elements equal to 1, so we return -1.\\n\\nNote: As the Sieve of Eratosthenes requires O(N log log N) time complexity, this solution is not strictly linear. However, it is significantly more efficient than an O(N^2) solution when dealing with large inputs.\\n\\nThis solution assumes that the input numbers are not too large (e.g., within the range of an integer). If the numbers can be very large, we need a different approach because the Sieve of Eratosthenes may not be feasible. For example, we could use a probabilistic algorithm to find a pair of numbers with gcd 1, but this would not guarantee a correct answer in all cases.\\n\\nAlso, it\\'s important to note that this approach doesn\\'t give the exact number of operations if no \"1\" is found in the array; it only checks for the possibility of making all elements equal to 1. Calculating the exact number of operations in such a case can be a more complex problem and is likely to require more than linear time."
                    },
                    {
                        "username": "ZX007java",
                        "content": "Good day ! Can anyone give me answer : why set [2, 6, 3, 4] have answer is equal 4, BUT SET [4, 2, 6, 3] have answer is equal 5 ???"
                    },
                    {
                        "username": "bparanj",
                        "content": "This discrepancy arises from the order in which we are allowed to perform the gcd operations on the array.\\n\\nFor the array [2, 6, 3, 4]:\\n\\n1. We can select index 2 (i.e., the number 3) and take the gcd with the number at index 3 (i.e., the number 4), and replace 3 with gcd(3, 4) = 1. Array becomes [2, 6, 1, 4].\\n2. We can then select index 1 (i.e., the number 6) and take the gcd with the number at index 2 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, 1, 1, 4].\\n3. Then, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 4].\\n4. Finally, select index 2 (i.e., the number 1) and take the gcd with the number at index 3 (i.e., the number 4), and replace 4 with gcd(1, 4) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 4.\\n\\nFor the array [4, 2, 6, 3]:\\n\\n1. We can select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array becomes [4, 2, 6, 3].\\n2. Repeat step 1. Array still is [4, 2, 6, 3].\\n3. Repeat step 1 again. Array still is [4, 2, 6, 3].\\n4. Finally, select index 3 (i.e., the number 3) and take the gcd with the number at index 2 (i.e., the number 6), and replace 3 with gcd(3, 6) = 3. Array becomes [4, 2, 6, 1].\\n5. Now, select index 0 (i.e., the number 4) and take the gcd with the number at index 1 (i.e., the number 2), and replace 4 with gcd(4, 2) = 2. Array becomes [2, 2, 6, 1].\\n6. Next, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 6), and replace 2 with gcd(2, 6) = 2. Array still is [2, 2, 6, 1].\\n7. Repeat step 6. Array still is [2, 2, 6, 1].\\n8. Repeat step 6 again. Array still is [2, 2, 6, 1].\\n9. Repeat step 6 once more. Array still is [2, 2, 6, 1].\\n10. Finally, select index 2 (i.e., the number 6) and take the gcd with the number at index 3 (i.e., the number 1), and replace 6 with gcd(6, 1) = 1. Array becomes [2, \\n\\n2, 1, 1].\\n11. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 2), and replace 2 with gcd(2, 2) = 2. Array still is [2, 2, 1, 1].\\n12. Repeat step 11. Array still is [2, 2, 1, 1].\\n13. Repeat step 11 again. Array still is [2, 2, 1, 1].\\n14. Finally, select index 1 (i.e., the number 2) and take the gcd with the number at index 2 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [2, 1, 1, 1].\\n15. Now, select index 0 (i.e., the number 2) and take the gcd with the number at index 1 (i.e., the number 1), and replace 2 with gcd(2, 1) = 1. Array becomes [1, 1, 1, 1].\\n\\nTotal operations = 15.\\n\\nThis demonstrates how the order of the array can affect the total number of operations required to achieve all elements as 1. The most optimized way to get all elements to 1 can depend on the order of elements in the array."
                    },
                    {
                        "username": "ZX007java",
                        "content": "[@s_m99](/s_m99) THANK YOU !!! CONSECUTIVE !!!"
                    },
                    {
                        "username": "s_m99",
                        "content": "You can only calculate gcd\\'s of 2 **consecutive** numbers and replace either of them. So in set [4,2,6,3] to make 3 into 1 we require two operations instead of one in [2,6,3,4] "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Damn, that was a great problem but... Medium, really? Am I just getting dumber? \nTook me quite lot of time and tryhard to see the solution.\nAnd that's gotta be the lowest acceptance rate I've seen for a medium problem\n\nAlso, python has a built-in gcd function apparently. Lesson learned; next time, no need to face my anxieties trying to remember my number theory classes to implement the Euclidean algo myself"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "Anyone explain or hint"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "light hint: how many steps would it take to get your first one in the array? And once you have a one, how many more steps do you need to turn everything into a one?"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "I am not able to understand the question\\nit says \\nselect index i and change num[i] or num[i+1] with their GCD and people have used n^2 loop to check every pair"
                    },
                    {
                        "username": "bparanj",
                        "content": "The problem statement asks for the minimum number of operations required to make all elements of an array equal to 1, by replacing either nums[i] or nums[i+1] with their gcd (greatest common divisor).\\n\\nThe problem solution is implemented with an O(n^2) approach, and this is why:\\n\\n1. You iterate over each element in the array (first loop).\\n2. For each element, you check for a contiguous segment in the array where the gcd of the numbers in the segment equals 1 (second loop). If such a segment is found, you store the length of that segment minus 1 (because one element is already 1 and doesn\\'t need any operation).\\n3. The result of the algorithm is the minimum length of these segments (if any) plus the number of elements outside these segments (because each of these will need one operation to become 1, by taking the gcd with 1).\\n\\nThe algorithm needs to check all pairs of elements because the array isn\\'t necessarily sorted, and any pair (i, j) with i < j can potentially form a contiguous segment where the gcd of the numbers is 1. So, an element nums[i] might be replaced by the gcd of nums[i] and nums[j] for some j > i.\\n"
                    },
                    {
                        "username": "User___",
                        "content": "[@cartesPerforees](/cartesPerforees) Is that $$O(n)$$?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I think you understand the question, it's just the solutions that you don't understand.\nWe check every pair to find the closest elements that could lead to a gcd of 1. Then we propagate the gcd neighbor-by-neighbor"
                    }
                ]
            }
        ]
    },
    {
        "title": "Count Artist Occurrences On Spotify Ranking List",
        "question_content": null,
        "solutions": [],
        "discussions": []
    },
    {
        "title": "Sum in a Matrix",
        "question_content": "<p>You are given a <strong>0-indexed</strong> 2D integer array <code>nums</code>. Initially, your score is <code>0</code>. Perform the following operations until the matrix becomes empty:</p>\n\n<ol>\n\t<li>From each row in the matrix, select the largest number and remove it. In the case of a tie, it does not matter which number is chosen.</li>\n\t<li>Identify the highest number amongst all those removed in step 1. Add that number to your <strong>score</strong>.</li>\n</ol>\n\n<p>Return <em>the final <strong>score</strong>.</em></p>\n<p>&nbsp;</p>\n<p><strong>Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [[7,2,1],[6,4,2],[6,5,3],[3,2,1]]\n<strong>Output:</strong> 15\n<strong>Explanation:</strong> In the first operation, we remove 7, 6, 6, and 3. We then add 7 to our score. Next, we remove 2, 4, 5, and 2. We add 5 to our score. Lastly, we remove 1, 2, 3, and 1. We add 3 to our score. Thus, our final score is 7 + 5 + 3 = 15.\n</pre>\n\n<p><strong>Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [[1]]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> We remove 1 and add it to the answer. We return 1.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 300</code></li>\n\t<li><code>1 &lt;= nums[i].length &lt;= 500</code></li>\n\t<li><code>0 &lt;= nums[i][j] &lt;= 10<sup>3</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3520226,
                "title": "very-simple-easy-to-understand-solution",
                "content": "<b> Up vote if you like the solution </b>\\n\\n# Approach\\n1. Sort the matrix on each row.\\n2. Then traverse the matrix column wise and keep adding the max value on each column to ans.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int ans = 0;\\n        for(int i = 0; i < nums.size(); ++i){\\n            sort(nums[i].begin(), nums[i].end());\\n        }\\n        for(int c = 0; c < nums[0].size(); ++c){\\n            int t = 0;\\n            for(int r = 0; r <nums.size(); ++r){\\n                t = max(t, nums[r][c]);\\n            }\\n            ans += t;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n<b> Here is an article of my last interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int ans = 0;\\n        for(int i = 0; i < nums.size(); ++i){\\n            sort(nums[i].begin(), nums[i].end());\\n        }\\n        for(int c = 0; c < nums[0].size(); ++c){\\n            int t = 0;\\n            for(int r = 0; r <nums.size(); ++r){\\n                t = max(t, nums[r][c]);\\n            }\\n            ans += t;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521285,
                "title": "c-don-t-trash-your-cache-fast",
                "content": "# Approach 1: sort and traverse row wise (112ms, 100%?)\\n\\nFor a large matrix traversing it column wise would be really bad for cache locality and work against all CPU memory prefetching. We can avoid this be just keep a vector for the max values in each column and process row by row.\\n\\n```cpp\\n    static int matrixSum(vector<vector<int>>& nums) {\\n        const int cols = size(nums[0]);\\n        vector<int> maxs(cols);\\n        for (vector<int>& row : nums) {\\n            sort(begin(row), end(row));\\n            for (int c = 0; c < cols; ++c)\\n                maxs[c] = max(maxs[c], row[c]);\\n        }\\n        return reduce(begin(maxs), end(maxs));\\n    }\\n```\\n\\n**Complexity Analysis**\\nWith a matrix of $$r$$ rows and $$c$$ columns the\\n\\n* Time complexity is $$O(r * c \\\\log c)$$ as we need to sort each row and sorting is the dominating factor and the\\n\\n* Space complexity is $$O(c)$$ as we need to keep the max for each column.\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an up-vote sparks joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\n    static int matrixSum(vector<vector<int>>& nums) {\\n        const int cols = size(nums[0]);\\n        vector<int> maxs(cols);\\n        for (vector<int>& row : nums) {\\n            sort(begin(row), end(row));\\n            for (int c = 0; c < cols; ++c)\\n                maxs[c] = max(maxs[c], row[c]);\\n        }\\n        return reduce(begin(maxs), end(maxs));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3520728,
                "title": "one-liner",
                "content": "**Python 3**\\n```python\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        return sum(max(col) for col in zip(*[sorted(row) for row in nums]))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        return sum(max(col) for col in zip(*[sorted(row) for row in nums]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520279,
                "title": "java-simple-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n            int ans=0;\\n        for(int []row:nums)\\n        {\\n                Arrays.sort(row);\\n        }\\n            for(int i=0;i<nums[0].length;i++)\\n            {\\n                    int m=0;\\n                    for(int j=0;j<nums.length;j++)\\n                    {\\n                            if(m<nums[j][i])\\n                                    m=nums[j][i];\\n                    }\\n                    ans+=m;\\n            }\\n            return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n            int ans=0;\\n        for(int []row:nums)\\n        {\\n                Arrays.sort(row);\\n        }\\n            for(int i=0;i<nums[0].length;i++)\\n            {\\n                    int m=0;\\n                    for(int j=0;j<nums.length;j++)\\n                    {\\n                            if(m<nums[j][i])\\n                                    m=nums[j][i];\\n                    }\\n                    ans+=m;\\n            }\\n            return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522624,
                "title": "sort-and-count",
                "content": "\\n\\n```py\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        m, n = len(nums), len(nums[0])\\n        res = 0\\n        # sort each row\\n        for num in nums: num.sort()\\n        # for each column, \\n        for j in range(n):\\n            # we look for the highest number\\n            mx = 0\\n            for i in range(m): mx = max(mx, nums[i][j])\\n            # then add that number to the score\\n            res += mx\\n        return res\\n```\\n\\n\\n\\n```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        res = 0\\n        # we first sort the rows, then transpose the input\\n        # in this way, we can just use max to find the higher number\\n        for col in zip(*[sorted(row) for row in nums]):\\n            # [\\n            #     (1, 2, 3, 1), \\n            #     (2, 4, 5, 2), \\n            #     (7, 6, 6, 3)\\n            # ]\\n            res += max(col)\\n        return res\\n```\\n\\n**p.s. Join us on the LeetCode The Hard Way Discord Study Group for timely discussion! Link in bio.**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```py\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        m, n = len(nums), len(nums[0])\\n        res = 0\\n        # sort each row\\n        for num in nums: num.sort()\\n        # for each column, \\n        for j in range(n):\\n            # we look for the highest number\\n            mx = 0\\n            for i in range(m): mx = max(mx, nums[i][j])\\n            # then add that number to the score\\n            res += mx\\n        return res\\n```\n```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        res = 0\\n        # we first sort the rows, then transpose the input\\n        # in this way, we can just use max to find the higher number\\n        for col in zip(*[sorted(row) for row in nums]):\\n            # [\\n            #     (1, 2, 3, 1), \\n            #     (2, 4, 5, 2), \\n            #     (7, 6, 6, 3)\\n            # ]\\n            res += max(col)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520438,
                "title": "simple-c-solution-using-sorting-space-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n*m*log(m))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n     int matrixSum(vector<vector<int>>& nums) {\\n         \\n        int ans = 0;\\n        int row = nums.size();\\n        int col = nums[0].size();\\n         for(int i = 0 ; i < row ; i++)\\n         {\\n            sort(nums[i].begin(),nums[i].end());\\n         }\\n        for(int i = 0 ; i < col ; i++)\\n        {\\n            int max = 0;\\n            for(int j = 0 ; j < row ; j++)\\n            {\\n                if(max < nums[j][i]) max = nums[j][i];\\n            }\\n            ans += max;\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sort",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int matrixSum(vector<vector<int>>& nums) {\\n         \\n        int ans = 0;\\n        int row = nums.size();\\n        int col = nums[0].size();\\n         for(int i = 0 ; i < row ; i++)\\n         {\\n            sort(nums[i].begin(),nums[i].end());\\n         }\\n        for(int i = 0 ; i < col ; i++)\\n        {\\n            int max = 0;\\n            for(int j = 0 ; j < row ; j++)\\n            {\\n                if(max < nums[j][i]) max = nums[j][i];\\n            }\\n            ans += max;\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520878,
                "title": "c-sort-each-find-max-each-columns",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int ans = 0;\\n        int i,j,x,m=nums.size(),n = nums[0].size();\\n        for(auto &i: nums){\\n            sort(i.begin(),i.end());\\n        }\\n        for(j = 0; j < n; j++){\\n            x = 0;\\n            for(i = 0; i < m; i++){\\n                x = max(x,nums[i][j]);\\n            }\\n            ans += x;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sort",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int ans = 0;\\n        int i,j,x,m=nums.size(),n = nums[0].size();\\n        for(auto &i: nums){\\n            sort(i.begin(),i.end());\\n        }\\n        for(j = 0; j < n; j++){\\n            x = 0;\\n            for(i = 0; i < m; i++){\\n                x = max(x,nums[i][j]);\\n            }\\n            ans += x;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520755,
                "title": "full-proper-step-by-step-explanation-simplest-solution",
                "content": "# Intuition\\nThe problem provides a 2D array called `nums`, where each element represents an integer. The goal is to calculate the final score by following these steps until the matrix becomes empty:\\n\\n1. For each row in the matrix, select the largest number and remove it. In case of a tie, it does not matter which number is chosen.\\n2. Identify the highest number among all those removed in step 1.\\n3. Add that highest number to the score.\\n4. Repeat steps 1-3 until the matrix becomes empty.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Initialize a variable `score` to keep track of the total score, and a variable `maxNum` to store the highest number encountered.\\n2. Iterate through the rows of the matrix and find the largest number in each row. You can do this by traversing each row and keeping track of the maximum number found so far.\\n3. After finding the largest number in each row, remove that number from the matrix.\\n4. Update the `maxNum` variable by comparing it with the largest number found in step 2. If the largest number is greater than `maxNum`, update `maxNum` accordingly.\\n5. Add `maxNum` to the `score` variable.\\n6. Repeat steps 2 to 5 until the matrix becomes empty, i.e., all elements are removed.\\n7. Return the final `score`.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int score = 0;\\n\\n        while (!nums.empty()) {\\n            int maxNum = INT_MIN;\\n\\n            for (int i = 0; i < nums.size(); i++) {\\n                if (!nums[i].empty()) {\\n                    int rowMax = *max_element(nums[i].begin(), nums[i].end());\\n                    maxNum = max(maxNum, rowMax);\\n                    nums[i].erase(find(nums[i].begin(), nums[i].end(), rowMax));\\n\\n                    if (nums[i].empty()) {\\n                        nums.erase(nums.begin() + i);\\n                        i--;\\n                    }\\n                }\\n            }\\n\\n            score += maxNum;\\n        }\\n\\n        return score;\\n    }\\n};\\n```\\n![images.jpeg](https://assets.leetcode.com/users/images/fd982757-a62d-4497-92b0-d6afef451dc2_1683998758.3136413.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int score = 0;\\n\\n        while (!nums.empty()) {\\n            int maxNum = INT_MIN;\\n\\n            for (int i = 0; i < nums.size(); i++) {\\n                if (!nums[i].empty()) {\\n                    int rowMax = *max_element(nums[i].begin(), nums[i].end());\\n                    maxNum = max(maxNum, rowMax);\\n                    nums[i].erase(find(nums[i].begin(), nums[i].end(), rowMax));\\n\\n                    if (nums[i].empty()) {\\n                        nums.erase(nums.begin() + i);\\n                        i--;\\n                    }\\n                }\\n            }\\n\\n            score += maxNum;\\n        }\\n\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520395,
                "title": "very-simple-fast-and-easy-solution-in-python3",
                "content": "first sort every row , then find the max element in each column and sum them up ( here , I made a array of max element from every column )\\n```\\nimport numpy as np\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        ans = 0\\n        for i in nums:\\n            i.sort()\\n        arr = np.array(nums)\\n        x = np.amax(arr,axis= 0)\\n        return sum(x)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nimport numpy as np\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        ans = 0\\n        for i in nums:\\n            i.sort()\\n        arr = np.array(nums)\\n        x = np.amax(arr,axis= 0)\\n        return sum(x)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520288,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.length;i++){\\n            Arrays.sort(nums[i]);\\n        }\\n        for(int i=0;i<nums[0].length;i++){\\n            int max=0;\\n            for(int j=0;j<nums.length;j++){\\n                max=Math.max(max,nums[j][i]);\\n            }\\n            ans+=max;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.length;i++){\\n            Arrays.sort(nums[i]);\\n        }\\n        for(int i=0;i<nums[0].length;i++){\\n            int max=0;\\n            for(int j=0;j<nums.length;j++){\\n                max=Math.max(max,nums[j][i]);\\n            }\\n            ans+=max;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520225,
                "title": "python-elegant-short-straightforward-vs-python-magic",
                "content": "# Complexity\\n- Time complexity: $$O(n * m * \\\\log_{2} m)$$\\n- Space complexity: $$O(n * m)$$\\n\\n# Straightforward version\\n\\n```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        rows = [sorted(row) for row in nums]\\n        return sum(max(row[i] for row in rows) for i in range(len(rows[0])))\\n```\\n\\n# Python Built-In Magic)\\n```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        return sum(map(max, zip(*map(sorted, nums))))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        rows = [sorted(row) for row in nums]\\n        return sum(max(row[i] for row in rows) for i in range(len(rows[0])))\\n```\n```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        return sum(map(max, zip(*map(sorted, nums))))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522380,
                "title": "sort-the-rows-100-beats-simple-and-easy-to-understand-c-solution",
                "content": "# Intuition\\nsort the rows of matrix and add the maximum of each column to the result.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int n=nums.size();\\n        int m=nums[0].size();\\n        for(int i=0;i<n;i++)\\n        {\\n            sort(nums[i].begin(),nums[i].end(),greater<int>());\\n        }\\n        int ans=0,temp=0;\\n        for(int i=0;i<m;i++)\\n        {  temp=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                temp=max(temp,nums[j][i]);\\n            }\\n         ans+=temp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int n=nums.size();\\n        int m=nums[0].size();\\n        for(int i=0;i<n;i++)\\n        {\\n            sort(nums[i].begin(),nums[i].end(),greater<int>());\\n        }\\n        int ans=0,temp=0;\\n        for(int i=0;i<m;i++)\\n        {  temp=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                temp=max(temp,nums[j][i]);\\n            }\\n         ans+=temp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520683,
                "title": "very-simple-solution-100-fast-sorting",
                "content": "# Intuition\\n- Sort each row of the matrix in ascending order. This ensures that the largest number in each row is at the end.\\n\\n- Iterate over each column and find the maximum number among all the elements in that column. Since the rows are sorted, the largest number in each column will be at the last index of that column.\\n\\n- Add the maximum number found in step 2 to the score. This represents the highest number among all the numbers removed from the matrix.\\n\\n- Repeat steps 2-3 until all the numbers in the matrix are removed. This means performing steps 2-3 for each column until there are no more numbers left in the matrix.\\n\\n- Return the final score, which represents the sum of the highest numbers from each column.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe approach is to first sort each row to ensure that the largest number is at the end. Then, by iterating over each column, we find the maximum number and add it to the score. This process is repeated until all numbers are removed from the matrix. The final score is returned as the result.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- **Time complexity:** Sorting each row: O(n * m * log(m)), where n is the number of rows and m is the number of columns.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space complexity:** The given solution has a space complexity of O(1) since it does not use any additional data structures\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++)\\n            sort(nums[i].begin(), nums[i].end());\\n    \\n        for(int i=0;i<nums[0].size();i++){\\n            int maxi=0;\\n            for(int j=0;j<nums.size();j++){\\n                maxi=max(nums[j][i],maxi);\\n            }\\n            sum+=maxi;\\n        }\\n        return sum;\\n    }\\n};\\n```\\n\\n# Java\\n```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int sum = 0;\\n        \\n        for (int i = 0; i < nums.length; i++)\\n            Arrays.sort(nums[i]);\\n        \\n        for (int i = 0; i < nums[0].length; i++) {\\n            int maxi = 0;\\n            for (int j = 0; j < nums.length; j++) {\\n                maxi = Math.max(nums[j][i], maxi);\\n            }\\n            sum += maxi;\\n        }\\n        \\n        return sum;\\n    }\\n}\\n\\n```\\n\\n# Python\\n```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        total_sum = 0\\n        \\n        for row in nums:\\n            row.sort()\\n        \\n        for i in range(len(nums[0])):\\n            maxi = 0\\n            for j in range(len(nums)):\\n                maxi = max(nums[j][i], maxi)\\n            total_sum += maxi\\n        \\n        return total_sum\\n\\n\\n```\\n\\n# JavaScript\\n```\\n/**\\n * @param {number[][]} nums\\n * @return {number}\\n */\\nvar matrixSum = function(nums) {\\n    let sum = 0;\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        nums[i].sort((a, b) => a - b);\\n    }\\n    \\n    for (let i = 0; i < nums[0].length; i++) {\\n        let maxi = 0;\\n        for (let j = 0; j < nums.length; j++) {\\n            maxi = Math.max(nums[j][i], maxi);\\n        }\\n        sum += maxi;\\n    }\\n    \\n    return sum;\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++)\\n            sort(nums[i].begin(), nums[i].end());\\n    \\n        for(int i=0;i<nums[0].size();i++){\\n            int maxi=0;\\n            for(int j=0;j<nums.size();j++){\\n                maxi=max(nums[j][i],maxi);\\n            }\\n            sum+=maxi;\\n        }\\n        return sum;\\n    }\\n};\\n```\n```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int sum = 0;\\n        \\n        for (int i = 0; i < nums.length; i++)\\n            Arrays.sort(nums[i]);\\n        \\n        for (int i = 0; i < nums[0].length; i++) {\\n            int maxi = 0;\\n            for (int j = 0; j < nums.length; j++) {\\n                maxi = Math.max(nums[j][i], maxi);\\n            }\\n            sum += maxi;\\n        }\\n        \\n        return sum;\\n    }\\n}\\n\\n```\n```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        total_sum = 0\\n        \\n        for row in nums:\\n            row.sort()\\n        \\n        for i in range(len(nums[0])):\\n            maxi = 0\\n            for j in range(len(nums)):\\n                maxi = max(nums[j][i], maxi)\\n            total_sum += maxi\\n        \\n        return total_sum\\n\\n\\n```\n```\\n/**\\n * @param {number[][]} nums\\n * @return {number}\\n */\\nvar matrixSum = function(nums) {\\n    let sum = 0;\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        nums[i].sort((a, b) => a - b);\\n    }\\n    \\n    for (let i = 0; i < nums[0].length; i++) {\\n        let maxi = 0;\\n        for (let j = 0; j < nums.length; j++) {\\n            maxi = Math.max(nums[j][i], maxi);\\n        }\\n        sum += maxi;\\n    }\\n    \\n    return sum;\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520335,
                "title": "python-1-liner",
                "content": "# **Explanation**\\nSort each row, sum up the max of each column.\\n<br>\\n\\n# **Complexity**\\nTime `O(mnlogn)`\\nSpace `O(mn)`\\n<br>\\n\\n\\n**Python, 1-line**\\n```py\\n    def matrixSum(self, A: List[List[int]]) -> int:\\n        return sum(max(a) for a in zip(sorted(a) for a in A))\\n```\\n\\n**Python, shorter 1-line**\\n```py\\n    def matrixSum(self, A: List[List[int]]) -> int:\\n        return sum(map(max, zip(*map(sorted, A))))\\n```\\n",
                "solutionTags": [],
                "code": "```py\\n    def matrixSum(self, A: List[List[int]]) -> int:\\n        return sum(max(a) for a in zip(sorted(a) for a in A))\\n```\n```py\\n    def matrixSum(self, A: List[List[int]]) -> int:\\n        return sum(map(max, zip(*map(sorted, A))))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3583277,
                "title": "i-hope-this-solution-helps-you-beats-98-5-lines-code",
                "content": "# Intuition\\nThe first thought that comes to mind when solving this problem is to sort each row of the matrix in descending order. This will ensure that the largest numbers in each row are at the top. Next, we can transpose the matrix, which will swap the rows and columns. This will give us a new matrix where each column is a sorted list of the numbers from the original matrix. Finally, we can simply sum the maximum value from each column.\\n\\n# Approach\\nHere is a more detailed explanation of the approach:\\n\\nSort each row of the matrix in descending order.\\nTranspose the matrix.\\nSum the maximum value from each column.\\n# Complexity\\nThe time complexity of this algorithm is O(n^2), where n is the number of rows in the matrix. This is because the first step, sorting each row, takes O(n log n) time. The second step, transposing the matrix, takes O(n^2) time. And the third step, summing the maximum value from each column, takes O(n) time.\\n\\nThe space complexity of this algorithm is O(n^2), where n is the number of rows in the matrix. This is because we need to store the sorted rows of the matrix in memory, which takes O(n^2) space\\n\\n# Code\\n```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        new_nums = []\\n        for row in nums:\\n            new_nums.append(sorted(row,reverse=True))\\n        trans=zip(*new_nums)\\n        s=0\\n        for i in trans:\\n            s+=max(i)\\n        return s\\n```",
                "solutionTags": [
                    "Python3",
                    "Sorting",
                    "Heap (Priority Queue)",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        new_nums = []\\n        for row in nums:\\n            new_nums.append(sorted(row,reverse=True))\\n        trans=zip(*new_nums)\\n        s=0\\n        for i in trans:\\n            s+=max(i)\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525797,
                "title": "java-simple-sort-rows",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1, sort all rows;\\n2, find the largest of each column for each round, then add to result\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(M * N log N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\npublic int matrixSum(int[][] nums) {\\n    int m = nums.length,n = nums[0].length, res = 0;\\n    for (int i = 0; i < m; i++) Arrays.sort(nums[i]);\\n    for (int j = 0; j < n; j++) {\\n        int tmp = 0;\\n        for (int i = 0; i < m; i++) tmp = Math.max(tmp, nums[i][j]);\\n        res += tmp;\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int matrixSum(int[][] nums) {\\n    int m = nums.length,n = nums[0].length, res = 0;\\n    for (int i = 0; i < m; i++) Arrays.sort(nums[i]);\\n    for (int j = 0; j < n; j++) {\\n        int tmp = 0;\\n        for (int i = 0; i < m; i++) tmp = Math.max(tmp, nums[i][j]);\\n        res += tmp;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3520542,
                "title": "c-fully-explained-with-approach-easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\nstep 1: Solve the given 2D vector.\\n        -> your new matrix is: \\n        **1 2 7\\n        2 4 6\\n        3 5 6\\n        1 2 3**\\nStep 2: Take the last element from each row, and find max from these:\\nthus, your last element from col 3 will be: 7, 6, 6, 3\\n\\n-> now max from these is 7 thus we add that to the ans variable, which was initially assigned to 0\\n\\n# Complexity\\n- Time complexity:O(n^2 * log(n))\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   \\n    int matrixSum(vector<vector<int>>& nums) {\\n        int ans = 0;\\n        //nums.size() -> row\\n        //nums[0].size() -> col\\n\\n        //sort the vector\\n        for(int i = 0 ; i < nums.size(); i++){    \\n            sort(nums[i].begin(), nums[i].end());\\n            \\n        }\\n        //logic\\n        for(int i = 0 ; i < nums[0].size(); i++){\\n            \\n            int mx = 0;\\n            \\n            for(int j =0 ; j < nums.size(); j++){\\n                mx = max(mx, nums[j][i]);\\n            }\\n            ans += mx; \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    int matrixSum(vector<vector<int>>& nums) {\\n        int ans = 0;\\n        //nums.size() -> row\\n        //nums[0].size() -> col\\n\\n        //sort the vector\\n        for(int i = 0 ; i < nums.size(); i++){    \\n            sort(nums[i].begin(), nums[i].end());\\n            \\n        }\\n        //logic\\n        for(int i = 0 ; i < nums[0].size(); i++){\\n            \\n            int mx = 0;\\n            \\n            for(int j =0 ; j < nums.size(); j++){\\n                mx = max(mx, nums[j][i]);\\n            }\\n            ans += mx; \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520378,
                "title": "step-by-step-approach-easy-java-solution",
                "content": "# Intuition\\nUse arraylist Data Structure.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1) Make a 2d ArrayList to add all the values from nums array.\\n2) Now, get max element from from each row.\\n```\\nmax = Collections.max(al.get(i));\\n```\\n3) Now add all max values in a ArrayList `arr` and to find max from that `arr`.\\n```\\nint maxe = Collections.max(arr);\\ncount += maxe;\\n```\\n4) return that count.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int n = nums.length, max = Integer.MIN_VALUE, temp = 0, count = 0;\\n        int m = nums[0].length;\\n        List<Integer> arr = new ArrayList<>();\\n        List<List<Integer>> al = new ArrayList<>();\\n        for(int i = 0; i < n; i++){\\n            al.add(new ArrayList<>());\\n        }\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                al.get(i).add(nums[i][j]);\\n            }\\n        }\\n        while(al.get(0).size() != 0){\\n            for(int i = 0; i < n; i++){\\n                max = Collections.max(al.get(i));\\n                arr.add(max);\\n                al.get(i).remove(Integer.valueOf(max));\\n            }\\n            int maxe = Collections.max(arr);\\n            count += maxe;\\n            arr = new ArrayList<>();\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nmax = Collections.max(al.get(i));\\n```\n```\\nint maxe = Collections.max(arr);\\ncount += maxe;\\n```\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int n = nums.length, max = Integer.MIN_VALUE, temp = 0, count = 0;\\n        int m = nums[0].length;\\n        List<Integer> arr = new ArrayList<>();\\n        List<List<Integer>> al = new ArrayList<>();\\n        for(int i = 0; i < n; i++){\\n            al.add(new ArrayList<>());\\n        }\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                al.get(i).add(nums[i][j]);\\n            }\\n        }\\n        while(al.get(0).size() != 0){\\n            for(int i = 0; i < n; i++){\\n                max = Collections.max(al.get(i));\\n                arr.add(max);\\n                al.get(i).remove(Integer.valueOf(max));\\n            }\\n            int maxe = Collections.max(arr);\\n            count += maxe;\\n            arr = new ArrayList<>();\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520320,
                "title": "easy-to-understand-java-solution",
                "content": "# Intuition\\n**First sort the array rowwise then add maximum for each column.**\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int score = 0;\\n        int n = nums.length;\\n        int m = nums[0].length;\\n        for(int[] a :nums)\\n        {\\n            Arrays.sort(a);\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            int max = 0;\\n            for(int j=0;j<n;j++)\\n            {\\n                max = Math.max(max,nums[j][i]);\\n            }\\n            score+=max;\\n        }\\n        return score;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int score = 0;\\n        int n = nums.length;\\n        int m = nums[0].length;\\n        for(int[] a :nums)\\n        {\\n            Arrays.sort(a);\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            int max = 0;\\n            for(int j=0;j<n;j++)\\n            {\\n                max = Math.max(max,nums[j][i]);\\n            }\\n            score+=max;\\n        }\\n        return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520282,
                "title": "java-solution-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int score = 0;\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            Arrays.sort(nums[i]);\\n        }\\n        \\n        for(int col = 0; col < nums[0].length; col++) {\\n            int max = nums[0][col];\\n            for(int row = 0; row < nums.length; row++) {\\n                if(nums[row][col] > max) {\\n                    max = nums[row][col];\\n                }\\n            }\\n            score += max;\\n        }\\n        return score;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int score = 0;\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            Arrays.sort(nums[i]);\\n        }\\n        \\n        for(int col = 0; col < nums[0].length; col++) {\\n            int max = nums[0][col];\\n            for(int row = 0; row < nums.length; row++) {\\n                if(nums[row][col] > max) {\\n                    max = nums[row][col];\\n                }\\n            }\\n            score += max;\\n        }\\n        return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520209,
                "title": "day-408-easy-100-python-java-c-explained",
                "content": "# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\niterates over each column of the matrix and finds the maximum element in that column by iterating over each row. It then removes the maximum element from each row and adds the maximum element found to the sum. This process is repeated for each column, and the final sum is returned.\\n# Complexity\\nThe time complexity of this solution is O(n^2), where n is the number of elements in the matrix, since we need to iterate over each element in the matrix. The space complexity is also O(n^2), since we need to store the matrix in memory.\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```python []\\ndef matrixSum(self, nums: List[List[int]]) -> int:\\n    sum=0\\n    for j in range(len(nums[0])):\\n        gmax=0\\n        for i in range(len(nums)):\\n            gmax=max(gmax,max(nums[i]))\\n            nums[i].remove(max(nums[i]))\\n        sum+=gmax;\\n    return sum   \\n```\\n```c++ []\\n int matrixSum(vector<vector<int>>& nums) {\\n        int sum = 0;\\n        for (int j = 0; j < nums[0].size(); j++) {\\n            int gmax = 0;\\n            for (int i = 0; i < nums.size(); i++) {\\n                gmax = max(gmax, *max_element(nums[i].begin(), nums[i].end()));\\n                nums[i].erase(max_element(nums[i].begin(), nums[i].end()));\\n            }\\n            sum += gmax;\\n        }\\n        return sum;\\n    }\\n```\\n```java []\\npublic int matrixSum(List<List<Integer>> nums) {\\n        int sum = 0;\\n        for (int j = 0; j < nums.get(0).size(); j++) {\\n            int gmax = 0;\\n            for (int i = 0; i < nums.size(); i++) {\\n                gmax = Math.max(gmax, Collections.max(nums.get(i)));\\n                nums.get(i).remove(Collections.max(nums.get(i)));\\n            }\\n            sum += gmax;\\n        }\\n        return sum;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```python []\\ndef matrixSum(self, nums: List[List[int]]) -> int:\\n    sum=0\\n    for j in range(len(nums[0])):\\n        gmax=0\\n        for i in range(len(nums)):\\n            gmax=max(gmax,max(nums[i]))\\n            nums[i].remove(max(nums[i]))\\n        sum+=gmax;\\n    return sum   \\n```\n```c++ []\\n int matrixSum(vector<vector<int>>& nums) {\\n        int sum = 0;\\n        for (int j = 0; j < nums[0].size(); j++) {\\n            int gmax = 0;\\n            for (int i = 0; i < nums.size(); i++) {\\n                gmax = max(gmax, *max_element(nums[i].begin(), nums[i].end()));\\n                nums[i].erase(max_element(nums[i].begin(), nums[i].end()));\\n            }\\n            sum += gmax;\\n        }\\n        return sum;\\n    }\\n```\n```java []\\npublic int matrixSum(List<List<Integer>> nums) {\\n        int sum = 0;\\n        for (int j = 0; j < nums.get(0).size(); j++) {\\n            int gmax = 0;\\n            for (int i = 0; i < nums.size(); i++) {\\n                gmax = Math.max(gmax, Collections.max(nums.get(i)));\\n                nums.get(i).remove(Collections.max(nums.get(i)));\\n            }\\n            sum += gmax;\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3766700,
                "title": "simple-c-approach-best-and-easy-to-understand-for-begginer",
                "content": "# Approach\\nSort the matrix. After sorting all the greatest element will lie to the end of vector[i]. Compare all the last element of the vector[i] and find the largest one and store it in to a vector v. Run a loop while m(length of matrix[0]) > 0 and for each iteration do the same. Return the sum of vector v.\\n\\n# Complexity\\n- Time complexity:\\nO(m*n) where m is the length of vector[0] and n is length of vector<vector<int>>\\n\\n- Space complexity:\\nO(m*n) where m is the length of vector[0] and n is length of vector<vector<int>>\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n\\n        int n = nums.size();\\n        int m = nums[0].size();\\n\\n        //Sorting the Matrix\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<n;i++){\\n            sort(nums[i].begin(),nums[i].end());\\n        }\\n\\n        //Checking whether the matrix is sorted or not\\n        //for(auto x:nums){\\n            //for(auto y:x){\\n            //    cout<<y<<\" \";\\n            //}\\n          //  cout<<endl;\\n        //}\\n\\n        int maxi = -1; //-1 because the value of matrix >= 0. Given in constraint\\n\\n        vector<int> v;\\n\\n        //Running a loop till m is +ve number\\n\\n        while(m > 0){\\n            //Finding the greatest element from each row and \\n            for(int i=0;i<n;i++){\\n                maxi = max(maxi,nums[i][m-1]); \\n            }\\n            //Storing maximum value to the vector v\\n            v.push_back(maxi);\\n            // Reasssigning value of maxi for next iteration.\\n            maxi=-1;          \\n            m--;\\n        }    \\n\\n        int ans=0;\\n        for(auto x:v){\\n            ans +=x;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n\\n        int n = nums.size();\\n        int m = nums[0].size();\\n\\n        //Sorting the Matrix\\n        sort(nums.begin(),nums.end());\\n\\n        for(int i=0;i<n;i++){\\n            sort(nums[i].begin(),nums[i].end());\\n        }\\n\\n        //Checking whether the matrix is sorted or not\\n        //for(auto x:nums){\\n            //for(auto y:x){\\n            //    cout<<y<<\" \";\\n            //}\\n          //  cout<<endl;\\n        //}\\n\\n        int maxi = -1; //-1 because the value of matrix >= 0. Given in constraint\\n\\n        vector<int> v;\\n\\n        //Running a loop till m is +ve number\\n\\n        while(m > 0){\\n            //Finding the greatest element from each row and \\n            for(int i=0;i<n;i++){\\n                maxi = max(maxi,nums[i][m-1]); \\n            }\\n            //Storing maximum value to the vector v\\n            v.push_back(maxi);\\n            // Reasssigning value of maxi for next iteration.\\n            maxi=-1;          \\n            m--;\\n        }    \\n\\n        int ans=0;\\n        for(auto x:v){\\n            ans +=x;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3556439,
                "title": "python-simple-and-clean-beats-99-99",
                "content": "### Please upvote if you find this helpful. \\u270C\\n<img src=\"https://assets.leetcode.com/users/images/b8e25620-d320-420a-ae09-94c7453bd033_1678818986.7001078.jpeg\" alt=\"Cute Robot - Stable diffusion\" width=\"200\"/>\\n\\n*This is an NFT*\\n\\n# Intuition\\nThe problem asks us to repeatedly remove the largest number from each row of the matrix and add the maximum of those numbers to our score. One way to approach this problem is to sort each row of the matrix in descending order so that we can easily access the largest number in each row.\\n\\n# Approach\\n1. Sort each row of the input matrix in descending order.\\n2. Initialize a variable `res` to store the result.\\n3. Iterate through the columns of the matrix:\\n    1. Initialize a variable `curr` to store the maximum value in the current column.\\n    2. Iterate through the rows of the matrix and update `curr` with the maximum value in the current column.\\n    3. Add `curr` to `res`.\\n4. Return `res`.\\n\\n# Complexity\\n- Time complexity: $$O(nm \\\\log m)$$\\nThe time complexity of this solution is dominated by the sorting step, which takes $$O(nm \\\\log m)$$ time, where `n` is the number of rows and `m` is the number of columns in the input matrix.\\n\\n- Space complexity: $$O(1)$$\\nThe space complexity of this solution is constant since we only use a few variables to keep track of intermediate results.\\n\\n# Code\\n```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        for row in nums:\\n            row.sort(reverse=True)\\n        res = 0\\n        n,m = len(nums),len(nums[0])\\n        for i in range(m):\\n            curr = -1\\n            for j in range(n):\\n                curr = max(curr,nums[j][i])\\n            res += curr\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        for row in nums:\\n            row.sort(reverse=True)\\n        res = 0\\n        n,m = len(nums),len(nums[0])\\n        for i in range(m):\\n            curr = -1\\n            for j in range(n):\\n                curr = max(curr,nums[j][i])\\n            res += curr\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549636,
                "title": "c-easy-solution",
                "content": "\\nclass Solution {\\npublic:\\n\\n    int matrixSum(vector<vector<int>>& nums) {\\n\\n        int row = nums.size();\\n        int col = nums[0].size();\\n        int ans =0;\\n \\n        for(int i=0; i<row; i++){\\n            sort(nums[i].begin(),nums[i].end());\\n        }\\n\\n        for(int i=0; i<col; i++){\\n            int maxi = INT_MIN;\\n            for(int j=0; j<row; j++){\\n                maxi = max(maxi,nums[j][i]);             \\n            }\\n            ans+=maxi;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting",
                    "Matrix"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int matrixSum(vector<vector<int>>& nums) {\\n\\n        int row = nums.size();\\n        int col = nums[0].size();\\n        int ans =0;\\n \\n        for(int i=0; i<row; i++){\\n            sort(nums[i].begin(),nums[i].end());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3542731,
                "title": "simple-solution-using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n         int sum=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            Arrays.sort(nums[i]);\\n\\n        }\\n       for(int i=0;i<nums[0].length;i++)\\n       {\\n            int max = 0;\\n            for(int j=0;j<nums.length;j++)\\n            {\\n                max = Math.max(max,nums[j][i]);\\n            }\\n            sum+=max;\\n       }\\n       return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n         int sum=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            Arrays.sort(nums[i]);\\n\\n        }\\n       for(int i=0;i<nums[0].length;i++)\\n       {\\n            int max = 0;\\n            for(int j=0;j<nums.length;j++)\\n            {\\n                max = Math.max(max,nums[j][i]);\\n            }\\n            sum+=max;\\n       }\\n       return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3542480,
                "title": "2679-sum-in-a-matrix-java",
                "content": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        for(int x[]:nums)\\n            Arrays.sort(x);\\n        int ans=0;\\n        for(int i=0;i<nums[0].length;i++)\\n        {\\n            int max=Integer.MIN_VALUE;\\n          for(int j=0;j<nums.length;j++)\\n            {\\n                max=Math.max(nums[j][i],max);\\n            }\\n          ans+=max;\\n        } \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        for(int x[]:nums)\\n            Arrays.sort(x);\\n        int ans=0;\\n        for(int i=0;i<nums[0].length;i++)\\n        {\\n            int max=Integer.MIN_VALUE;\\n          for(int j=0;j<nums.length;j++)\\n            {\\n                max=Math.max(nums[j][i],max);\\n            }\\n          ans+=max;\\n        } \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3539514,
                "title": "o-n-2-log-n-time-o-1-space-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int n = nums.size();\\n        int m = nums[0].size();\\n        for(int i = 0;i < n;i++){\\n            sort(nums[i].begin(),nums[i].end(),greater());\\n        }\\n        int maxi = 0,score = 0;\\n        for(int c = 0;c < m;c++){\\n            maxi = 0;\\n            for(int r = 0;r < n;r++){\\n                maxi = max(maxi,nums[r][c]);\\n                nums[r][c] = 0;\\n            }\\n            score += maxi;\\n        }\\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int n = nums.size();\\n        int m = nums[0].size();\\n        for(int i = 0;i < n;i++){\\n            sort(nums[i].begin(),nums[i].end(),greater());\\n        }\\n        int maxi = 0,score = 0;\\n        for(int c = 0;c < m;c++){\\n            maxi = 0;\\n            for(int r = 0;r < n;r++){\\n                maxi = max(maxi,nums[r][c]);\\n                nums[r][c] = 0;\\n            }\\n            score += maxi;\\n        }\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3523052,
                "title": "c-brute-force-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n^2*logn)$$\\n\\n- Space complexity:$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int ans=0;\\n        for(int i=0; i<nums.size(); i++){    \\n            sort(nums[i].begin(), nums[i].end());\\n        }\\n        for(int i=0; i<nums[0].size(); i++){\\n            int cnt=0;\\n            for(int j=0; j<nums.size(); j++){\\n                cnt=max(cnt, nums[j][i]);\\n            }\\n            ans+=cnt;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int ans=0;\\n        for(int i=0; i<nums.size(); i++){    \\n            sort(nums[i].begin(), nums[i].end());\\n        }\\n        for(int i=0; i<nums[0].size(); i++){\\n            int cnt=0;\\n            for(int j=0; j<nums.size(); j++){\\n                cnt=max(cnt, nums[j][i]);\\n            }\\n            ans+=cnt;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522395,
                "title": "java-solution-using-loops-and-sorting",
                "content": "\\n \\n# Approach\\n1. Sort the `internal 1-D arrays`.\\n2. Then take the `last element` from every row then find the max from there \\n3. Add in score;\\n4. Now take `second last element` from every row then find max from all of these Add in score;\\n5. Do this while first column is not reached;\\n\\n# Complexity\\n- Time complexity:O(n*n(logn))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n         int score=0;\\n        for(int i=0;i<nums.length;i++){\\n            Arrays.sort(nums[i]);\\n        }\\n        for(int j=0;j<nums[0].length;j++)\\n        { int max=nums[0][nums[0].length-j-1];\\n            for(int i=0;i<nums.length;i++) {\\n                if (nums[i][nums[0].length - j - 1] > max) {\\n                    max = nums[i][nums[0].length - j - 1];\\n                }\\n            }\\n                score+=max;\\n\\n            }\\n        return score;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n         int score=0;\\n        for(int i=0;i<nums.length;i++){\\n            Arrays.sort(nums[i]);\\n        }\\n        for(int j=0;j<nums[0].length;j++)\\n        { int max=nums[0][nums[0].length-j-1];\\n            for(int i=0;i<nums.length;i++) {\\n                if (nums[i][nums[0].length - j - 1] > max) {\\n                    max = nums[i][nums[0].length - j - 1];\\n                }\\n            }\\n                score+=max;\\n\\n            }\\n        return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522254,
                "title": "c-brute-force",
                "content": "\\n# Complexity\\n- Time complexity: $$O(m * n * m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n * m)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int n = nums.size(), m = nums[0].size();\\n        vector<vector<int>> vis(n, vector<int>(m));\\n        int max_sum = 0;\\n        for(int t = 0; t < m; t++) {\\n            int ult_max = 0;\\n            for(int i = 0; i < n; i++) {\\n                int maxi = 0, col = 0;\\n                for(int j = 0; j < m; j++) {\\n                    if(nums[i][j] > maxi && vis[i][j] == 0) {\\n                        maxi = nums[i][j];\\n                        col = j;\\n                    }\\n                }\\n                vis[i][col] = 1;\\n                ult_max = max(ult_max, maxi);\\n            }\\n            max_sum += ult_max;\\n        }\\n        return max_sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int n = nums.size(), m = nums[0].size();\\n        vector<vector<int>> vis(n, vector<int>(m));\\n        int max_sum = 0;\\n        for(int t = 0; t < m; t++) {\\n            int ult_max = 0;\\n            for(int i = 0; i < n; i++) {\\n                int maxi = 0, col = 0;\\n                for(int j = 0; j < m; j++) {\\n                    if(nums[i][j] > maxi && vis[i][j] == 0) {\\n                        maxi = nums[i][j];\\n                        col = j;\\n                    }\\n                }\\n                vis[i][col] = 1;\\n                ult_max = max(ult_max, maxi);\\n            }\\n            max_sum += ult_max;\\n        }\\n        return max_sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521981,
                "title": "100-fast-and-memory-efficient-c-solution-sorting",
                "content": "## Complexity\\n- Time complexity: $$O(n*m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n*m)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int score=0; int n= nums.size(); int m= nums[0].size();\\n        for (int i=0; i<n; i++){\\n            sort(nums[i].begin(),nums[i].end());\\n        }\\n        for (int i=0; i<m; i++){\\n            int maxi=0;\\n            for (int j=0; j<n; j++){\\n                maxi= max(maxi,nums[j][i]);\\n            }\\n            score+= maxi;\\n        }\\n        \\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sort",
                    "Sorting",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int score=0; int n= nums.size(); int m= nums[0].size();\\n        for (int i=0; i<n; i++){\\n            sort(nums[i].begin(),nums[i].end());\\n        }\\n        for (int i=0; i<m; i++){\\n            int maxi=0;\\n            for (int j=0; j<n; j++){\\n                maxi= max(maxi,nums[j][i]);\\n            }\\n            score+= maxi;\\n        }\\n        \\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521707,
                "title": "python3-sorting-very-easy-to-understand-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        score=0\\n        \\n        for j in nums:\\n            j.sort()\\n            j.reverse()\\n        for i in range(len(nums[0])):\\n            cur_max=nums[0][i]\\n            for k in range(len(nums)):\\n                cur_max=max(cur_max,nums[k][i])\\n            #print(cur_max)\\n            score+=cur_max\\n        return score\\n            \\n            \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        score=0\\n        \\n        for j in nums:\\n            j.sort()\\n            j.reverse()\\n        for i in range(len(nums[0])):\\n            cur_max=nums[0][i]\\n            for k in range(len(nums)):\\n                cur_max=max(cur_max,nums[k][i])\\n            #print(cur_max)\\n            score+=cur_max\\n        return score\\n            \\n            \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521164,
                "title": "easy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int n = nums.size();\\n        int m = nums[0].size();\\n        for(auto &k : nums){\\n            sort(k.begin(), k.end());\\n        }\\n        int ans = 0;\\n        for(int i = 0; i < m; i++){\\n            int maxm = -1;\\n            for(int j = 0; j < n; j++){\\n                maxm = max(maxm, nums[j][i]);\\n            }\\n            ans += maxm;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int n = nums.size();\\n        int m = nums[0].size();\\n        for(auto &k : nums){\\n            sort(k.begin(), k.end());\\n        }\\n        int ans = 0;\\n        for(int i = 0; i < m; i++){\\n            int maxm = -1;\\n            for(int j = 0; j < n; j++){\\n                maxm = max(maxm, nums[j][i]);\\n            }\\n            ans += maxm;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520927,
                "title": "easy-java-solution-prioritqueue",
                "content": "\\n- Time complexity: O(n*n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n\\n      int count=0;\\n      int ans[]=new int[nums[0].length];\\n      for(int i=0;i<nums.length;i++)\\n      {\\n          PriorityQueue<Integer> q= new PriorityQueue<>();\\n          for(int j=0;j<nums[0].length;j++)\\n          {\\n              q.add(nums[i][j]);\\n          }\\n         \\n         for(int k=0;k<ans.length;k++)\\n         {\\n             int a=q.poll();\\n             if(ans[k]<a)\\n             {\\n                 ans[k]=a;\\n             }\\n         }\\n\\n      }\\n      for(int n:ans) count+=n;  \\n      return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n\\n      int count=0;\\n      int ans[]=new int[nums[0].length];\\n      for(int i=0;i<nums.length;i++)\\n      {\\n          PriorityQueue<Integer> q= new PriorityQueue<>();\\n          for(int j=0;j<nums[0].length;j++)\\n          {\\n              q.add(nums[i][j]);\\n          }\\n         \\n         for(int k=0;k<ans.length;k++)\\n         {\\n             int a=q.poll();\\n             if(ans[k]<a)\\n             {\\n                 ans[k]=a;\\n             }\\n         }\\n\\n      }\\n      for(int n:ans) count+=n;  \\n      return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520856,
                "title": "intuitive-solution",
                "content": "# Intuition\\nRead this line again and again...\\nReally important\\n\"From each row in the matrix, select the largest number and remove it. In the case of a tie, it does not matter which number is chosen.\"\\n\\n# Approach\\nWe sorted the array as we always needed largest element of the row at the first location and we read the question carefully it is written that \"From each row in the matrix, select the largest number and remove it. In the case of a tie, it does not matter which number is chosen.\" ROW so i sorted and then reverse the array so i can have a decreasing sorted array which helped me. \\n# Complexity\\n- Time complexity:\\nO(N^2 log N)\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int max_length=0;\\n        for(int []i:nums) {\\n            max_length = Math.max(i.length, max_length);\\n            Arrays.sort(i);\\n            reverse(i);\\n        }\\n        int score=0;\\n        for(int i=0;i<max_length;i++){\\n            int num=0;\\n            for(int j=0;j<nums.length;j++) {\\n                if (nums[j].length > i) {\\n                    num = Math.max(nums[j][i], num);\\n                }\\n            }\\n            score += num;\\n        }\\n        return score;\\n    }\\n    public static void reverse(int[] arr){\\n        int i=0;\\n        int j=arr.length-1;\\n        while(i<=j){\\n            int temp=arr[i];\\n            arr[i]=arr[j];\\n            arr[j]=temp;\\n            i++;\\n            j--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int max_length=0;\\n        for(int []i:nums) {\\n            max_length = Math.max(i.length, max_length);\\n            Arrays.sort(i);\\n            reverse(i);\\n        }\\n        int score=0;\\n        for(int i=0;i<max_length;i++){\\n            int num=0;\\n            for(int j=0;j<nums.length;j++) {\\n                if (nums[j].length > i) {\\n                    num = Math.max(nums[j][i], num);\\n                }\\n            }\\n            score += num;\\n        }\\n        return score;\\n    }\\n    public static void reverse(int[] arr){\\n        int i=0;\\n        int j=arr.length-1;\\n        while(i<=j){\\n            int temp=arr[i];\\n            arr[i]=arr[j];\\n            arr[j]=temp;\\n            i++;\\n            j--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520838,
                "title": "c-sorting-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n      sort(nums.begin(),nums.end());\\n        vector<vector<int>> n;\\n        for(auto it: nums){\\n            sort(it.begin(),it.end());\\n            vector<int> ds;\\n            for(auto i: it){\\n                ds.push_back(i);\\n            }\\n            n.push_back(ds);\\n        }\\n        int res=0;\\n       for(int i=0;i<nums[0].size();i++){\\n            vector<int> ans;\\n            for(int j=0;j<nums.size();j++){\\n                ans.push_back(n[j][i]);\\n            }\\n            sort(ans.begin(),ans.end());\\n            res+=ans[ans.size()-1];\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n      sort(nums.begin(),nums.end());\\n        vector<vector<int>> n;\\n        for(auto it: nums){\\n            sort(it.begin(),it.end());\\n            vector<int> ds;\\n            for(auto i: it){\\n                ds.push_back(i);\\n            }\\n            n.push_back(ds);\\n        }\\n        int res=0;\\n       for(int i=0;i<nums[0].size();i++){\\n            vector<int> ans;\\n            for(int j=0;j<nums.size();j++){\\n                ans.push_back(n[j][i]);\\n            }\\n            sort(ans.begin(),ans.end());\\n            res+=ans[ans.size()-1];\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520545,
                "title": "python3-solution-one-line",
                "content": "\\n\\n```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        return sum(map(max,zip(*map(sorted,nums))))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        return sum(map(max,zip(*map(sorted,nums))))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520525,
                "title": "well-explained-easy-to-understand-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf we sort all the rows of the matrix then, the last value at the last column of each matrix will be the max value of that row. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Sort Each Row \\n- Traverse from the last column to the first column and find out the find out the max value of that column. Add it to the score.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int m=nums.size();\\n        int n=nums[0].size();\\n        int score=0;\\n        for(int i=0;i<m;i++){\\n            sort(nums[i].begin(),nums[i].end());\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            int maxi=INT_MIN;\\n            for(int j=0;j<m;j++){\\n                if(nums[j][i]>maxi){\\n                    maxi=nums[j][i];\\n                }\\n            }\\n            score+=maxi;\\n        }\\n        return score;\\n    }\\n};\\n```\\n# Please Upvote if it was helpful\\u2B06\\uFE0F",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int m=nums.size();\\n        int n=nums[0].size();\\n        int score=0;\\n        for(int i=0;i<m;i++){\\n            sort(nums[i].begin(),nums[i].end());\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            int maxi=INT_MIN;\\n            for(int j=0;j<m;j++){\\n                if(nums[j][i]>maxi){\\n                    maxi=nums[j][i];\\n                }\\n            }\\n            score+=maxi;\\n        }\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520458,
                "title": "why-we-need-to-sort-easy-explanation",
                "content": "The approach is simple but only thing people are confused is why we have to sort? can\\'t we just iterate through each row for each column.\\n\\nExplanation : \\nThe reason for sorting is because we have to select max value from each row instead of just iterating through each row and column randomly. \\n\\n Suppose we have \\n\\n 7 4 6\\n 3 2 1\\n 9 8 7\\n\\n1st iteration we have to select Max(7,3,9) because these are the largest numbers in each row.\\n2nd iteration we have to select Max(6,2,8) because these are the largest numbers in each row after removing (7,3,9) in first iteration .\\nIf you carefully observe here 6 is located at index - 2 but ( 2 and 8) are located at index 1 so that\\'s why we have to sort them so that all maximum numbers will be together.\\n\\nAfter sorting : \\n4 6 7\\n1 2 3\\n7 8 9 \\n\\nAfter sorting if we observe all Max pairs are together \\nMAX(7,3,9)\\nMAX(6,2,8)\\nMAX(4,1,7)\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n\\n       // We need to sort it first - Explanation is given above\\n       for(int[] i : nums)\\n           Arrays.sort(i);\\n\\n        int total = 0;\\n        for(int col = 0; col < nums[0].length; col++){\\n            int max = Integer.MIN_VALUE;\\n            for(int row = 0; row < nums.length; row++){\\n                max = Math.max(nums[row][col],max);\\n            }\\n            total += max;\\n        }\\n        \\n        return total;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n\\n       // We need to sort it first - Explanation is given above\\n       for(int[] i : nums)\\n           Arrays.sort(i);\\n\\n        int total = 0;\\n        for(int col = 0; col < nums[0].length; col++){\\n            int max = Integer.MIN_VALUE;\\n            for(int row = 0; row < nums.length; row++){\\n                max = Math.max(nums[row][col],max);\\n            }\\n            total += max;\\n        }\\n        \\n        return total;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520440,
                "title": "sort-and-sum",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int ans = 0, n = size(nums), m = size(nums[0]);\\n        for(auto&e: nums){\\n            sort(begin(e),end(e));\\n        }\\n        for(int i=0; i<m; ++i){\\n            int mx = -1e9;\\n            for(int j=0; j<n; ++j){\\n                mx = max(mx,nums[j][i]);\\n            }\\n            ans += mx;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int ans = 0, n = size(nums), m = size(nums[0]);\\n        for(auto&e: nums){\\n            sort(begin(e),end(e));\\n        }\\n        for(int i=0; i<m; ++i){\\n            int mx = -1e9;\\n            for(int j=0; j<n; ++j){\\n                mx = max(mx,nums[j][i]);\\n            }\\n            ans += mx;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520369,
                "title": "c-easy-solution-for-beginner-o-n-2-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:o(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        for(int i=0;i<nums.size();i++){\\n            sort(nums[i].begin(),nums[i].end(),greater<int>());\\n        }\\n        int ans=0;\\n        for(int i=0;i<nums[0].size();i++){\\n            int temp=0;\\n           for(int j=0;j<nums.size();j++){\\n               temp=max(temp,nums[j][i]);\\n           }\\n            ans=ans+temp;\\n        }\\n       return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        for(int i=0;i<nums.size();i++){\\n            sort(nums[i].begin(),nums[i].end(),greater<int>());\\n        }\\n        int ans=0;\\n        for(int i=0;i<nums[0].size();i++){\\n            int temp=0;\\n           for(int j=0;j<nums.size();j++){\\n               temp=max(temp,nums[j][i]);\\n           }\\n            ans=ans+temp;\\n        }\\n       return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520358,
                "title": "super-easy-to-understand-c",
                "content": "\\n**If you like my solution please upvote!**\\n```\\nint matrixSum(vector<vector<int>>& v) {\\n        \\n        int n = v.size();\\n        int m = v[0].size();\\n        int ans = 0;\\n       for(int i =0; i<n; i++)\\n           sort(v[i].begin(), v[i].end());   // Sorting each row\\n       \\n            for(int j =m-1; j>=0; j--) //traversing from the last column\\n            {\\n                int local =-1e9; // stores maximum of each column\\n                 for(int i =0; i<n ; i++)\\n                 {\\n                     local = max(local, v[i][j]);\\n                 }\\n                ans+=local;  //Adding the maximum of each row to answer\\n            }\\n            \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nint matrixSum(vector<vector<int>>& v) {\\n        \\n        int n = v.size();\\n        int m = v[0].size();\\n        int ans = 0;\\n       for(int i =0; i<n; i++)\\n           sort(v[i].begin(), v[i].end());   // Sorting each row\\n       \\n            for(int j =m-1; j>=0; j--) //traversing from the last column\\n            {\\n                int local =-1e9; // stores maximum of each column\\n                 for(int i =0; i<n ; i++)\\n                 {\\n                     local = max(local, v[i][j]);\\n                 }\\n                ans+=local;  //Adding the maximum of each row to answer\\n            }\\n            \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3520346,
                "title": "python-sort",
                "content": "```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        \\n        for row in nums:\\n            row.sort()\\n        ans = 0\\n        for i in range(len(nums[0]) - 1, -1, -1):\\n            current_ans = float(\\'-inf\\')\\n            for j in range(len(nums)):\\n                current_ans = max(current_ans, nums[j][i])\\n            ans += current_ans\\n        return ans\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        \\n        for row in nums:\\n            row.sort()\\n        ans = 0\\n        for i in range(len(nums[0]) - 1, -1, -1):\\n            current_ans = float(\\'-inf\\')\\n            for j in range(len(nums)):\\n                current_ans = max(current_ans, nums[j][i])\\n            ans += current_ans\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520345,
                "title": "very-easy-java-code-with-explaination-for-beginners",
                "content": "# Algorithm Steps\\nAlgorithm for the matrixSum method in the Solution class:\\n\\n1. Create a method called \"matrixSum\" that takes a 2D integer array called \"nums\" as input and returns an integer.\\n2. For each row \"num\" in the \"nums\" array, do the following:\\n   a. Sort the elements in the row using the \"Arrays.sort\" method.\\n3. Initialize an integer variable called \"res\" to 0.\\n4. For each column in the \"nums\" array, do the following:\\n   a. Initialize an integer variable called \"max\" to the minimum value of an integer using the constant \"Integer.MIN_VALUE\".\\n   b. For each row in the \"nums\" array, do the following:\\n      i. Get the element at the current row and column using the index notation \"nums[j][i]\".\\n      ii. If the element is greater than \"max\", set \"max\" to the value of the element.\\n   c. Add the value of \"max\" to the \"res\" variable.\\n5. After processing all the columns in the \"nums\" array, return the value of \"res\" as the sum of the maximum elements in each column.\\n\\nOverall, this algorithm finds the maximum element in each column of a 2D integer array, adds up all the maximum elements, and returns the sum as the result. The algorithm achieves this by sorting each row in the array first, and then iterating through each column and finding the maximum element in that column.\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        for (int[] num : nums) {\\n            Arrays.sort(num);\\n        }\\n        int res = 0;\\n        for(int i = nums[0].length-1; i>=0;i--){\\n            int max = Integer.MIN_VALUE;\\n            for(int j = 0; j<nums.length; j++){\\n                max = Math.max(max,nums[j][i]);\\n            }\\n            res+=max;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        for (int[] num : nums) {\\n            Arrays.sort(num);\\n        }\\n        int res = 0;\\n        for(int i = nums[0].length-1; i>=0;i--){\\n            int max = Integer.MIN_VALUE;\\n            for(int j = 0; j<nums.length; j++){\\n                max = Math.max(max,nums[j][i]);\\n            }\\n            res+=max;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520287,
                "title": "simple-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n       for(int num[]:nums){\\n           Arrays.sort(num);\\n       }\\n      int ans=0;\\n       \\n           for(int i=0;i<nums[0].length;i++){\\n                int max=Integer.MIN_VALUE;\\n               for(int j=0;j<nums.length;j++){\\n                    max=Math.max(max,nums[j][i]) ; \\n               }\\n               ans=ans+max;\\n            \\n          }\\n        return ans;\\n         \\n         }\\n}\\n       // 1 2 7   00    01 \\n       // 2 4 6   10    11\\n       // 3 5 6   20    21\\n       // 1 2 3   30   31\\n    \\n    \\n   \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n       for(int num[]:nums){\\n           Arrays.sort(num);\\n       }\\n      int ans=0;\\n       \\n           for(int i=0;i<nums[0].length;i++){\\n                int max=Integer.MIN_VALUE;\\n               for(int j=0;j<nums.length;j++){\\n                    max=Math.max(max,nums[j][i]) ; \\n               }\\n               ans=ans+max;\\n            \\n          }\\n        return ans;\\n         \\n         }\\n}\\n       // 1 2 7   00    01 \\n       // 2 4 6   10    11\\n       // 3 5 6   20    21\\n       // 1 2 3   30   31\\n    \\n    \\n   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520243,
                "title": "c-easy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int r=nums.size(), c=nums[0].size();\\n        int ans=0;\\n        \\n        for(int i=0;i<r;i++){\\n           sort(nums[i].begin(),nums[i].end());\\n        }\\n        for(int j=0;j<c;j++){\\n            int val=0;\\n            for(int i=0;i<r;i++){\\n                val=max(val,nums[i][j]);\\n            }\\n            ans += val;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int r=nums.size(), c=nums[0].size();\\n        int ans=0;\\n        \\n        for(int i=0;i<r;i++){\\n           sort(nums[i].begin(),nums[i].end());\\n        }\\n        for(int j=0;j<c;j++){\\n            int val=0;\\n            for(int i=0;i<r;i++){\\n                val=max(val,nums[i][j]);\\n            }\\n            ans += val;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520218,
                "title": "c-easy-and-simple-solution",
                "content": "***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int score=0;\\n        \\n        \\n        for(int i=0;i<nums.size();i++){\\n            sort(nums[i].begin(),nums[i].end());\\n        }\\n        for(int i=0;i<nums[0].size();i++){\\n            int maxi=0;\\n            for(int j=0;j<nums.size();j++){\\n                \\n                maxi=max(maxi,nums[j][i]);\\n            }\\n            \\n            score+=maxi;\\n        }\\n        return score;\\n    }\\n};\\n```\\n***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int score=0;\\n        \\n        \\n        for(int i=0;i<nums.size();i++){\\n            sort(nums[i].begin(),nums[i].end());\\n        }\\n        for(int i=0;i<nums[0].size();i++){\\n            int maxi=0;\\n            for(int j=0;j<nums.size();j++){\\n                \\n                maxi=max(maxi,nums[j][i]);\\n            }\\n            \\n            score+=maxi;\\n        }\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4102550,
                "title": "track-the-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n make the map with int and priority_queue \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\npriority_queue for get the maximum always from the each new time .\\n# Complexity\\n- Time complexity:O(n*n*log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        unordered_map<int,priority_queue<int>>mp;\\n        int n=nums.size(),m=nums[0].size();\\n        for(int i=0;i<n;++i)\\n        {\\n            for(auto it:nums[i])\\n            {\\n                mp[i].push(it);\\n            }\\n        }\\n      \\n        int sum=0;\\n        while(m--)\\n        {     \\n            int maxi=INT_MIN;\\n            for(auto  &it:mp)\\n            {\\n                int cur=it.second.top();\\n                it.second.pop();\\n                maxi=max(maxi,cur);\\n            }\\n            sum+=maxi;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        unordered_map<int,priority_queue<int>>mp;\\n        int n=nums.size(),m=nums[0].size();\\n        for(int i=0;i<n;++i)\\n        {\\n            for(auto it:nums[i])\\n            {\\n                mp[i].push(it);\\n            }\\n        }\\n      \\n        int sum=0;\\n        while(m--)\\n        {     \\n            int maxi=INT_MIN;\\n            for(auto  &it:mp)\\n            {\\n                int cur=it.second.top();\\n                it.second.pop();\\n                maxi=max(maxi,cur);\\n            }\\n            sum+=maxi;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4101974,
                "title": "sum-in-a-matrix",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[][] $nums\\n     * @return Integer\\n     */\\n    function matrixSum($nums)\\n    {\\n        $totals = [];\\n        foreach ($nums as $_k => $subnum) {\\n            rsort($subnum);\\n            $i = 0;\\n            while ($i < count($subnum)) {\\n                if (!isset($totals[$i]) || $subnum[$i] >= $totals[$i]) {\\n                    $totals[$i] = $subnum[$i];\\n                }\\n                $i++;\\n            }\\n        }\\n        return array_sum($totals);\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[][] $nums\\n     * @return Integer\\n     */\\n    function matrixSum($nums)\\n    {\\n        $totals = [];\\n        foreach ($nums as $_k => $subnum) {\\n            rsort($subnum);\\n            $i = 0;\\n            while ($i < count($subnum)) {\\n                if (!isset($totals[$i]) || $subnum[$i] >= $totals[$i]) {\\n                    $totals[$i] = $subnum[$i];\\n                }\\n                $i++;\\n            }\\n        }\\n        return array_sum($totals);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4080394,
                "title": "easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int row = nums.size();\\n        int col = nums[0].size();\\n\\n        for(int i=0;i<row;i++) {\\n            sort(nums[i].begin(),nums[i].end(),greater<int>());\\n        }\\n\\n        int score = 0;\\n\\n        for(int i=0;i<col;i++) {\\n            priority_queue<int> maxHeap;\\n\\n            for(int j=0;j<row;j++) {\\n                maxHeap.push(nums[j][i]);\\n            }\\n\\n            int x = maxHeap.top();\\n            score += x;\\n        }\\n\\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int row = nums.size();\\n        int col = nums[0].size();\\n\\n        for(int i=0;i<row;i++) {\\n            sort(nums[i].begin(),nums[i].end(),greater<int>());\\n        }\\n\\n        int score = 0;\\n\\n        for(int i=0;i<col;i++) {\\n            priority_queue<int> maxHeap;\\n\\n            for(int j=0;j<row;j++) {\\n                maxHeap.push(nums[j][i]);\\n            }\\n\\n            int x = maxHeap.top();\\n            score += x;\\n        }\\n\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4076482,
                "title": "using-priority-queue",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        vector<priority_queue<int>> pq;\\n\\n        for(auto it: nums)\\n        {\\n            priority_queue<int> temp;\\n            for(auto ix: it)\\n            {\\n                temp.push(ix);\\n            }\\n            pq.push_back(temp);\\n        }\\n\\n        int ans = 0;\\n        int n = nums[0].size();\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            int mx = INT_MIN;\\n            for(auto &it: pq)\\n            {\\n                int top = it.top();\\n                mx = max(mx, top);\\n                it.pop();\\n            }\\n            ans += mx;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        vector<priority_queue<int>> pq;\\n\\n        for(auto it: nums)\\n        {\\n            priority_queue<int> temp;\\n            for(auto ix: it)\\n            {\\n                temp.push(ix);\\n            }\\n            pq.push_back(temp);\\n        }\\n\\n        int ans = 0;\\n        int n = nums[0].size();\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            int mx = INT_MIN;\\n            for(auto &it: pq)\\n            {\\n                int top = it.top();\\n                mx = max(mx, top);\\n                it.pop();\\n            }\\n            ans += mx;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4068593,
                "title": "sort-and-iterate",
                "content": "# Intuition\\nSort each row\\n# Approach\\nSort each row and perform the operations column by columns. No need to change the actual array in any way. For example, there is no need to find the max cell and set it to zero or something.\\n\\n# Complexity\\n- Time complexity:\\nAssume nums has n rows and m columns THEN: O(n*mlogm + n*m)\\n- Space complexity:\\nO(1), note python sorting (Tim sort) is in place.\\n# Code\\n```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n\\n        # Assume nums has n rows and m columns\\n        # T: O(n*mlogm + n*m) | S: O(1)\\n        def initial(nums):\\n\\n            # sort every row\\n            for row in nums:\\n                row.sort(reverse=True)\\n\\n            # iterate through each column form left to right\\n            res = 0\\n            for col in range(0, len(nums[0])):\\n                \\n                maxVal = -1\\n                for row in range(0, len(nums)):\\n                    targetCell = nums[row][col]\\n                    maxVal = max(maxVal, targetCell)\\n\\n                res += maxVal\\n\\n            return res\\n\\n        return initial(nums)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n\\n        # Assume nums has n rows and m columns\\n        # T: O(n*mlogm + n*m) | S: O(1)\\n        def initial(nums):\\n\\n            # sort every row\\n            for row in nums:\\n                row.sort(reverse=True)\\n\\n            # iterate through each column form left to right\\n            res = 0\\n            for col in range(0, len(nums[0])):\\n                \\n                maxVal = -1\\n                for row in range(0, len(nums)):\\n                    targetCell = nums[row][col]\\n                    maxVal = max(maxVal, targetCell)\\n\\n                res += maxVal\\n\\n            return res\\n\\n        return initial(nums)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4068470,
                "title": "used-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n# Complexity\\n- Time complexity:\\nThe sorting has a time complexity of O(m * log(m)), where \\'m\\' is the length of the subarray.\\nyou have \\'n\\' subarrays (where \\'n\\' is the length of the nums array), the total time complexity for this part is O(n * m * log(m));\\nFinding Maximum Values: iterate over the columns (i.e., the elements in each subarray) and find the maximum value for each column. This part has a time complexity of O(m * n) because you\\'re iterating over all \\'n\\' subarrays and looking at each of their \\'m\\' elements once\\n\\noverall: O(n * m * log(m))\\n\\n- Space complexity:\\nusing some additional memory to keep track of the maximum values for each column. Specifically, we\\'re using an array of length \\'m\\' to store the maximum values.\\nO(m)\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} nums\\n * @return {number}\\n */\\nvar matrixSum = function(nums) {\\n    \\n    if(!Array.isArray(nums) && nums.length === 0 ) return 0;\\n    \\n    let finalscore = 0;\\n\\n    nums.forEach((item) => {\\n        item.sort((a,b) => b - a)\\n    })\\n    for(let i = 0; i < nums[0].length; i++ ){\\n        finalscore += Math.max(...nums.map((item) => item[i]));\\n    }\\n    return finalscore;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} nums\\n * @return {number}\\n */\\nvar matrixSum = function(nums) {\\n    \\n    if(!Array.isArray(nums) && nums.length === 0 ) return 0;\\n    \\n    let finalscore = 0;\\n\\n    nums.forEach((item) => {\\n        item.sort((a,b) => b - a)\\n    })\\n    for(let i = 0; i < nums[0].length; i++ ){\\n        finalscore += Math.max(...nums.map((item) => item[i]));\\n    }\\n    return finalscore;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4064369,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n    int s=0;\\n    for(int i=0;i<nums.length;i++){\\n        Arrays.sort(nums[i]);\\n    }\\n    for(int i=0;i<nums[0].length;i++){\\n        int m=0;\\n        for(int j=0;j<nums.length;j++){\\n            m=Math.max(m,nums[j][i]);\\n        }\\n        s+=m;\\n    }\\n    \\n\\n    return s;\\n    }    \\n    }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n    int s=0;\\n    for(int i=0;i<nums.length;i++){\\n        Arrays.sort(nums[i]);\\n    }\\n    for(int i=0;i<nums[0].length;i++){\\n        int m=0;\\n        for(int j=0;j<nums.length;j++){\\n            m=Math.max(m,nums[j][i]);\\n        }\\n        s+=m;\\n    }\\n    \\n\\n    return s;\\n    }    \\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047126,
                "title": "java-easy-solution-beat-90-10ms-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int sum=0;\\n        for(int [] arr:nums){\\n            Arrays.sort(arr);\\n          \\n        }\\n      \\n        int max=Integer.MIN_VALUE;\\n        int c=nums[0].length-1;\\n        for(int i=c;i>=0;i--){\\n            for(int j=0;j<nums.length;j++){\\n                max=Math.max(max,nums[j][i]);\\n\\n            }\\n            sum+=max;\\n            max=Integer.MIN_VALUE;\\n        }\\n        return sum;\\n     \\n     \\n      \\n    }\\n}\\n\\n \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int sum=0;\\n        for(int [] arr:nums){\\n            Arrays.sort(arr);\\n          \\n        }\\n      \\n        int max=Integer.MIN_VALUE;\\n        int c=nums[0].length-1;\\n        for(int i=c;i>=0;i--){\\n            for(int j=0;j<nums.length;j++){\\n                max=Math.max(max,nums[j][i]);\\n\\n            }\\n            sum+=max;\\n            max=Integer.MIN_VALUE;\\n        }\\n        return sum;\\n     \\n     \\n      \\n    }\\n}\\n\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4046323,
                "title": "simple-logic-just-sort-and-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(R*C)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int r=nums.size();\\n        int c=nums[0].size();\\n        int i,j;\\n        int max=0;\\n        int k;\\n        int m;\\n        for(i=0;i<r;i++){\\n           sort(nums[i].begin(),nums[i].end());\\n        }\\n        \\n       for(i=0;i<c;i++){\\n           m=0;\\n           for(j=0;j<r;j++){\\n               \\n               if(m<nums[j][i]){\\n                   m=nums[j][i];\\n               }\\n           }\\n           max=max+m;\\n       }\\n\\n        return max;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int r=nums.size();\\n        int c=nums[0].size();\\n        int i,j;\\n        int max=0;\\n        int k;\\n        int m;\\n        for(i=0;i<r;i++){\\n           sort(nums[i].begin(),nums[i].end());\\n        }\\n        \\n       for(i=0;i<c;i++){\\n           m=0;\\n           for(j=0;j<r;j++){\\n               \\n               if(m<nums[j][i]){\\n                   m=nums[j][i];\\n               }\\n           }\\n           max=max+m;\\n       }\\n\\n        return max;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040256,
                "title": "simple-solution-with-o-1-space-complexity",
                "content": "# Intuition\\nSort all the rows seperately of the matrix\\n# Approach\\nOnce the rows are sorted then chooose the max from each column and add it to total\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n\\n        int rowSize = nums.size();\\n        int colSize = nums[0].size();\\n\\n        for(int row=0;row<nums.size();row++)\\n        {\\n            sort(nums[row].begin(),nums[row].end());\\n        }\\n        int total =0;\\n        int max =INT_MIN;\\n        for(int col=0;col<colSize;col++)\\n        {\\n            max =INT_MIN;\\n            for(int row=0;row<rowSize;row++)\\n            {\\n                if (nums[row][col] >max )\\n                {\\n                    max = nums[row][col];\\n                }\\n            }\\n            total = total + max;\\n\\n        }\\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n\\n        int rowSize = nums.size();\\n        int colSize = nums[0].size();\\n\\n        for(int row=0;row<nums.size();row++)\\n        {\\n            sort(nums[row].begin(),nums[row].end());\\n        }\\n        int total =0;\\n        int max =INT_MIN;\\n        for(int col=0;col<colSize;col++)\\n        {\\n            max =INT_MIN;\\n            for(int row=0;row<rowSize;row++)\\n            {\\n                if (nums[row][col] >max )\\n                {\\n                    max = nums[row][col];\\n                }\\n            }\\n            total = total + max;\\n\\n        }\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4034494,
                "title": "java-easy-solution-beats-upto-65-good-luck",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        for(int i=0;i<nums.length;i++){\\n            Arrays.sort(nums[i]);\\n        }\\n        int score = 0;\\n        for(int i=0;i<nums[0].length;i++){\\n            int max = Integer.MIN_VALUE;\\n            for(int j=0;j<nums.length;j++){\\n                max = Math.max(max,nums[j][nums[0].length-i-1]);\\n            }\\n            score += max;\\n        }\\n        return score;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        for(int i=0;i<nums.length;i++){\\n            Arrays.sort(nums[i]);\\n        }\\n        int score = 0;\\n        for(int i=0;i<nums[0].length;i++){\\n            int max = Integer.MIN_VALUE;\\n            for(int j=0;j<nums.length;j++){\\n                max = Math.max(max,nums[j][nums[0].length-i-1]);\\n            }\\n            score += max;\\n        }\\n        return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4029492,
                "title": "very-simple-easy-and-concise-c-sol",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        for(int i=0;i<nums.size();i++){\\n            sort(nums[i].begin(),nums[i].end());\\n        }\\n        int score=0;\\n        for(int i=0;i<nums[0].size();i++){\\n            int val=0;\\n            for(int j=0;j<nums.size();j++){\\n                val=max(val,nums[j][i]);\\n            }\\n            score+=val;\\n        }\\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        for(int i=0;i<nums.size();i++){\\n            sort(nums[i].begin(),nums[i].end());\\n        }\\n        int score=0;\\n        for(int i=0;i<nums[0].size();i++){\\n            int val=0;\\n            for(int j=0;j<nums.size();j++){\\n                val=max(val,nums[j][i]);\\n            }\\n            score+=val;\\n        }\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022350,
                "title": "rather-dumb-solution",
                "content": "# Intuition\\nPriority queue, I want to put everything into priority queue.\\n\\n# Approach\\nTurn each row of the matrix into priority queue. Next, for each column, get top of priority queue, keep the local column maximum. At the end of the loop, add the local column maximum to answer.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nFirst loop will take $$O(i*j=N)$$\\n\\nThe second loop is a little bit tricky,\\n\\nIt will iterate through j column, each column has i rows, but since we\\'re using priority queue, the access of largest number is $$O(1)$$, so I think the complexity is still $$O(i*j=N)$$\\n\\nSo overall the complexity is $$O(2N) = O(N)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include<algorithm>\\n\\nclass Solution {\\npublic:\\n    vector<priority_queue<int>> v;\\n    int matrixSum(vector<vector<int>>& nums) {\\n        for(int i = 0; i < nums.size(); i++) {\\n            priority_queue<int> pq;\\n            v.push_back(pq);\\n            for(int j = 0; j < nums[i].size(); j++) v[i].push(nums[i][j]);\\n        }\\n        int ans = 0;\\n        for(int k = 0; k < nums[0].size(); k++) {\\n            int colMax = 0;\\n            for(int i = 0; i < v.size(); i++) {\\n                colMax = max(colMax, v[i].top());\\n                v[i].pop();\\n            }\\n            ans += colMax;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include<algorithm>\\n\\nclass Solution {\\npublic:\\n    vector<priority_queue<int>> v;\\n    int matrixSum(vector<vector<int>>& nums) {\\n        for(int i = 0; i < nums.size(); i++) {\\n            priority_queue<int> pq;\\n            v.push_back(pq);\\n            for(int j = 0; j < nums[i].size(); j++) v[i].push(nums[i][j]);\\n        }\\n        int ans = 0;\\n        for(int k = 0; k < nums[0].size(); k++) {\\n            int colMax = 0;\\n            for(int i = 0; i < v.size(); i++) {\\n                colMax = max(colMax, v[i].top());\\n                v[i].pop();\\n            }\\n            ans += colMax;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4019562,
                "title": "typescript-javascript-solution",
                "content": "```ts\\nfunction matrixSum(nums: number[][]): number {\\n    nums.forEach(arr => arr.sort((a, b) => b - a));\\n    let sum: number = 0;\\n    const length: number = nums[0].length;\\n    for(let i = 0; i < length; i++){\\n        const setNums: Set<number> = new Set();\\n        for(let num of nums) setNums.add(num[i]);\\n        sum += Math.max(...setNums);\\n    }\\n    return sum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```ts\\nfunction matrixSum(nums: number[][]): number {\\n    nums.forEach(arr => arr.sort((a, b) => b - a));\\n    let sum: number = 0;\\n    const length: number = nums[0].length;\\n    for(let i = 0; i < length; i++){\\n        const setNums: Set<number> = new Set();\\n        for(let num of nums) setNums.add(num[i]);\\n        sum += Math.max(...setNums);\\n    }\\n    return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3992170,
                "title": "java-easy-sorting-apporach",
                "content": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int sum=0;\\n         for(int i=0;i<nums.length;i++)\\n             {\\n                 Arrays.sort(nums[i]);\\n             }\\n        for(int i=0;i<nums[0].length;i++){\\n            int max=0;\\n            for(int j=0;j<nums.length;j++)\\n            {\\n                max=Math.max(max,nums[j][i]);\\n            }\\n            sum+=max;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int sum=0;\\n         for(int i=0;i<nums.length;i++)\\n             {\\n                 Arrays.sort(nums[i]);\\n             }\\n        for(int i=0;i<nums[0].length;i++){\\n            int max=0;\\n            for(int j=0;j<nums.length;j++)\\n            {\\n                max=Math.max(max,nums[j][i]);\\n            }\\n            sum+=max;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990067,
                "title": "beginner-friendly-best-java-solution-beats-100-in-runtime-fastest",
                "content": "# Code\\n```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        for(int[] eachRow: nums){\\n            Arrays.sort(eachRow);\\n        }\\n        int rows = nums.length;\\n        int cols = nums[0].length;\\n        return helper_matrixSum(nums, rows, cols);\\n    }\\n\\n    int helper_matrixSum(int[][] nums, int rows, int cols){\\n        int score = 0;\\n        for(int i=0; i<cols; i++){\\n            int maxii = -1;\\n            for(int j=0; j<rows; j++){\\n                maxii = Math.max(maxii, nums[j][i]);\\n            }\\n            score += maxii;\\n        }\\n        return score;\\n    }\\n}\\n        \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        for(int[] eachRow: nums){\\n            Arrays.sort(eachRow);\\n        }\\n        int rows = nums.length;\\n        int cols = nums[0].length;\\n        return helper_matrixSum(nums, rows, cols);\\n    }\\n\\n    int helper_matrixSum(int[][] nums, int rows, int cols){\\n        int score = 0;\\n        for(int i=0; i<cols; i++){\\n            int maxii = -1;\\n            for(int j=0; j<rows; j++){\\n                maxii = Math.max(maxii, nums[j][i]);\\n            }\\n            score += maxii;\\n        }\\n        return score;\\n    }\\n}\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984794,
                "title": "the-easiest-solution-that-beats-90-of-typescript-users-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction matrixSum(nums: number[][]): number {\\n  const arrayLength = nums.length;\\n\\n  for (let i = 0; i < arrayLength; i++) {\\n    nums[i] = nums[i].sort((a, b) => a - b);\\n  }\\n\\n  let sum = 0;\\n\\n  while (nums[arrayLength - 1].length !== 0) {\\n    let max = 0;\\n    for (let i = 0; i < arrayLength; i++) {\\n      const lastElement = nums[i].pop();\\n\\n      if (lastElement > max) max = lastElement;\\n    }\\n\\n    sum += max;\\n  }\\n\\n  return sum;\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction matrixSum(nums: number[][]): number {\\n  const arrayLength = nums.length;\\n\\n  for (let i = 0; i < arrayLength; i++) {\\n    nums[i] = nums[i].sort((a, b) => a - b);\\n  }\\n\\n  let sum = 0;\\n\\n  while (nums[arrayLength - 1].length !== 0) {\\n    let max = 0;\\n    for (let i = 0; i < arrayLength; i++) {\\n      const lastElement = nums[i].pop();\\n\\n      if (lastElement > max) max = lastElement;\\n    }\\n\\n    sum += max;\\n  }\\n\\n  return sum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3981341,
                "title": "sorting-c-jai-shree-ram",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n1)Initialize a variable score to keep track of your total score.\\n\\n2)Loop until the matrix nums is not empty:\\n\\n3)For each row, find the maximum number. Since it doesn\\'t matter which number you choose in case of a tie, you can use any method to find the maximum, such as sorting the row or using a priority queue.\\n4)Remove the maximum number from each row.\\nAfter processing all rows, identify the maximum number among the removed numbers. Add this maximum to your score.\\n\\n5)Repeat steps 2 and 3 until all rows are empty.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe problem revolves around selecting the largest available numbers smartly in order to maximize the final score. By always choosing the maximum in each step, you ensure that you\\'re adding the largest possible numbers to your score. This intuition leads to a simple and efficient solution for the problem.\\n\\n# Complexity\\n- Time complexity:O(n * m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n\\n        int n=nums.size();\\n        int m=nums[0].size();\\n\\n        int maximum=0;\\n        int score=0;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n           sort(nums[i].begin(),nums[i].end());\\n        }\\n\\n        // FIRST COLUMN KO FIX KARDIYA ,ISKE BAAD US COL MEIN MAX ELEMENT NIKALA AUR USKO SCORE MEIN ADD KARDIYA .///   AISA EXACTLY HAR ROW KE LIYE KARO\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n               maximum=max(nums[j][i],maximum);\\n            }\\n            score+=maximum;\\n        }\\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n\\n        int n=nums.size();\\n        int m=nums[0].size();\\n\\n        int maximum=0;\\n        int score=0;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n           sort(nums[i].begin(),nums[i].end());\\n        }\\n\\n        // FIRST COLUMN KO FIX KARDIYA ,ISKE BAAD US COL MEIN MAX ELEMENT NIKALA AUR USKO SCORE MEIN ADD KARDIYA .///   AISA EXACTLY HAR ROW KE LIYE KARO\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n               maximum=max(nums[j][i],maximum);\\n            }\\n            score+=maximum;\\n        }\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980532,
                "title": "shortest-easiest-clean-clear-straight-forward-solution-must-try",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& v) {\\n        vector<int>p;\\n        int sum=0;\\n        x:\\n        for(int i=0;i<v.size();i++){\\n            int k=*max_element(v[i].begin(),v[i].end());\\n            p.push_back(k);\\n            for(int j=0;j<v[i].size();j++)if(v[i][j]==k){v[i].erase(v[i].begin()+j);break;}\\n        }\\n        sum+=*max_element(p.begin(),p.end());\\n        p.clear();\\n        if(v[0].size()!=0)goto x;\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& v) {\\n        vector<int>p;\\n        int sum=0;\\n        x:\\n        for(int i=0;i<v.size();i++){\\n            int k=*max_element(v[i].begin(),v[i].end());\\n            p.push_back(k);\\n            for(int j=0;j<v[i].size();j++)if(v[i][j]==k){v[i].erase(v[i].begin()+j);break;}\\n        }\\n        sum+=*max_element(p.begin(),p.end());\\n        p.clear();\\n        if(v[0].size()!=0)goto x;\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3968984,
                "title": "my-solution-for-2679-sum-in-a-matrix",
                "content": "# Intuition\\nMy first thought is using numpy and hoping for the best)\\n\\n# Approach\\nSort rows for select maximum value for each iteration, find maximum value in each column to select largest value in each iteration and sum the result array.\\n\\n# Code\\n```\\nimport numpy as np\\n\\n\\nclass Solution:\\n    \\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        nums = np.array(nums)\\n        return np.sum(np.max(np.sort(nums, axis=1), axis=0))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport numpy as np\\n\\n\\nclass Solution:\\n    \\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        nums = np.array(nums)\\n        return np.sum(np.max(np.sort(nums, axis=1), axis=0))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3968059,
                "title": "python-simple-sorting-solution",
                "content": "Assume the matrix is nums = [[7,2,1],[6,4,2],[6,5,3],[3,2,1]]\\n\\n\\t7 2 1\\n\\t6 4 2 \\n\\t6 5 3\\n\\t3 2 1\\n\\t\\n\\t\\n Since we want the greatest value in each row in each operation, sorting will make our job easier.\\n \\n\\t If we sort each row in decreasing order, we get - \\n\\t \\n\\t 7 2 1\\n\\t 6 4 2 \\n\\t 6 5 3\\n\\t 3 2 1\\n\\t \\n\\t Now, Let\\'s take each operation and see what will be the greatest value in each row\\n\\t \\n\\t In Operation 1, we remove values 7,6,6 and 3 from each row respectively\\n\\t In Operation 2, we remove values 2,4,5 and 2 from each row respectively\\n\\t In Operation 3, we remove values 1,2,3 and 1 from each row respectively\\n\\t \\n\\t And So, score = max(7,6,6,3) + max(2,4,5,2) + max(1,2,3,1)\\n\\t  => 7 + 5 + 3 => 15\\n\\t  \\nDid you notice something?\\n\\nWhen we sorted the rows in decreasing order, then in each Operation \"i\", we were just removing values from column \"i - 1\"\\n\\nThat is, in Operation 1, we removed all the values from column 0\\nIn operation 2, we removed all the values from column 1\\nAnd In operation 3, we removed all the values from column 2\\n\\nSo basically, we just want the greatest value in each column and add that value to the score. And that\\'s it. There is no need to even remove anything. And that\\'s the whole idea of the below solution.\\n\\n\\n```\\ndef matrixSum(self, nums: List[List[int]]) -> int:\\n        # Score \\n        score = 0\\n        \\n        # Count of rows\\n        m = len(nums)\\n        \\n        # Count of columns\\n        n = len(nums[0])\\n        \\n        # Since we want the largest number in each row in each operation\\n        # We will sort each row in decreasing order\\n        for i in range(m): nums[i].sort(reverse=True)\\n            \\n        # Now that each row is sorted in decreasing order\\n        # It means that in one operation, the greatest values in each row are all aligned in same column\\n        # So we just need to go over all the values in each column and get the greatest out of them\\n        for j in range(n):\\n            \\n            # Greatest value\\n            greatestVal = 0\\n            \\n            for i in range(m):\\n                if nums[i][j] > greatestVal: \\n                    greatestVal = nums[i][j]\\n                    \\n            # Add the greatest value to the score\\n            score += greatestVal\\n            \\n        # Finally, return the score\\n        return score\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\ndef matrixSum(self, nums: List[List[int]]) -> int:\\n        # Score \\n        score = 0\\n        \\n        # Count of rows\\n        m = len(nums)\\n        \\n        # Count of columns\\n        n = len(nums[0])\\n        \\n        # Since we want the largest number in each row in each operation\\n        # We will sort each row in decreasing order\\n        for i in range(m): nums[i].sort(reverse=True)\\n            \\n        # Now that each row is sorted in decreasing order\\n        # It means that in one operation, the greatest values in each row are all aligned in same column\\n        # So we just need to go over all the values in each column and get the greatest out of them\\n        for j in range(n):\\n            \\n            # Greatest value\\n            greatestVal = 0\\n            \\n            for i in range(m):\\n                if nums[i][j] > greatestVal: \\n                    greatestVal = nums[i][j]\\n                    \\n            # Add the greatest value to the score\\n            score += greatestVal\\n            \\n        # Finally, return the score\\n        return score\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3966970,
                "title": "its-for-u-begginer-python",
                "content": "# for begginers easy python solution\\n**less lines of code**\\n* using sorted list\\n* using list comprehensions easily get values from lists in grid\\n```\\nclass Solution(object):\\n    def matrixSum(self, nums):\\n        \"\"\"\\n        :type nums: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        for i in range(len(nums)):\\n            nums[i] = sorted(nums[i],reverse = True)\\n        li = [max([num[i] for num in nums]) for i in range(len(nums[0]))]\\n        sum1 = 0\\n        for num in li:\\n            sum1+=num\\n        return sum1\\n        \\n```\\n# please upvote\\n![image](https://assets.leetcode.com/users/images/74da17c0-1d76-426e-82c8-d577698e0012_1693134024.377868.jpeg)\\n",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "```\\nclass Solution(object):\\n    def matrixSum(self, nums):\\n        \"\"\"\\n        :type nums: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        for i in range(len(nums)):\\n            nums[i] = sorted(nums[i],reverse = True)\\n        li = [max([num[i] for num in nums]) for i in range(len(nums[0]))]\\n        sum1 = 0\\n        for num in li:\\n            sum1+=num\\n        return sum1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963098,
                "title": "c-sorting-o-nlogn-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code sorts each row in ascending order and then iterates through the columns, finding the maximum value in each column and accumulating these maximum values to calculate the total sum. This algorithm efficiently identifies and accumulates the maximum values across columns in a matrix.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Sort each row of the matrix in ascending order.\\n1. Iterate through columns, tracking the maximum value (maxi) encountered in each column.\\n1. Accumulate maxi for each column into the sum.\\n1. Return the calculated sum as the result.\\n# Complexity\\n- Time complexity: O(m * n * log n), where \\'m\\' is the number of rows and \\'n\\' is the number of columns in the matrix.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int maxi = 0, sum = 0;\\n        for(int i=0; i<nums.size(); i++){\\n            sort(nums[i].begin(), nums[i].end());\\n        }\\n        int j=0;\\n        while(j<nums[0].size()){\\n            maxi = 0;\\n            for(int i=0; i<nums.size(); i++){\\n                maxi = max(maxi, nums[i][j]);\\n            }\\n            sum += maxi;\\n            j++;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int maxi = 0, sum = 0;\\n        for(int i=0; i<nums.size(); i++){\\n            sort(nums[i].begin(), nums[i].end());\\n        }\\n        int j=0;\\n        while(j<nums[0].size()){\\n            maxi = 0;\\n            for(int i=0; i<nums.size(); i++){\\n                maxi = max(maxi, nums[i][j]);\\n            }\\n            sum += maxi;\\n            j++;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960016,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        for(int i=0;i<nums.length;i++){\\n            Arrays.sort(nums[i]);\\n        }\\n        int sum =0;\\n        for(int j=nums[0].length-1; j>= 0;j--){\\n            int max = Integer.MIN_VALUE;\\n            for(int i=0;i<nums.length;i++){\\n                int ans = nums[i][j];\\n                max = Math.max(max, ans);\\n            }\\n            sum += max;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        for(int i=0;i<nums.length;i++){\\n            Arrays.sort(nums[i]);\\n        }\\n        int sum =0;\\n        for(int j=nums[0].length-1; j>= 0;j--){\\n            int max = Integer.MIN_VALUE;\\n            for(int i=0;i<nums.length;i++){\\n                int ans = nums[i][j];\\n                max = Math.max(max, ans);\\n            }\\n            sum += max;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947646,
                "title": "c-solution-beats-100-00-sort-rows-and-scan-columns",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint comp(const int * a, const int * b)\\n{\\n    return *a - *b;\\n}\\n\\nint matrixSum(int** nums, int numsSize, int* numsColSize){\\n\\n    int  score      = 0;\\n    int  rows       = numsSize;\\n    int  cols       = *numsColSize;\\n    int  max_val    = INT_MIN;\\n\\n    for (int i = 0; i < rows; i++)\\n    {\\n        /* Iteratve over all rows, sort the list in every row in descending order */\\n        qsort(nums[i], *numsColSize, sizeof(int), comp);\\n    }\\n\\n\\n    for (int i = 0; i < cols; i++)\\n    {\\n        /* Go column by column and find the max value \\n         * amongst all rows. Accumulate that to score */\\n        for (int j = 0; j < rows; j++)\\n        {\\n            max_val = (nums[j][i] > max_val) ? nums[j][i] : max_val;\\n        }\\n\\n        score  += max_val;\\n        max_val = INT_MIN;\\n    }\\n\\n    return score;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint comp(const int * a, const int * b)\\n{\\n    return *a - *b;\\n}\\n\\nint matrixSum(int** nums, int numsSize, int* numsColSize){\\n\\n    int  score      = 0;\\n    int  rows       = numsSize;\\n    int  cols       = *numsColSize;\\n    int  max_val    = INT_MIN;\\n\\n    for (int i = 0; i < rows; i++)\\n    {\\n        /* Iteratve over all rows, sort the list in every row in descending order */\\n        qsort(nums[i], *numsColSize, sizeof(int), comp);\\n    }\\n\\n\\n    for (int i = 0; i < cols; i++)\\n    {\\n        /* Go column by column and find the max value \\n         * amongst all rows. Accumulate that to score */\\n        for (int j = 0; j < rows; j++)\\n        {\\n            max_val = (nums[j][i] > max_val) ? nums[j][i] : max_val;\\n        }\\n\\n        score  += max_val;\\n        max_val = INT_MIN;\\n    }\\n\\n    return score;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3946646,
                "title": "sum-in-a-matrix-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def matrixSum(self, nums):\\n#         print(nums)\\n        for row in nums:\\n            row.sort(reverse=True)\\n            print(row)\\n        res = 0\\n        for i in range(len(nums[0])):\\n            curr = []\\n            for j in range(len(nums)):\\n                curr.append(nums[j][i])\\n                x = max(curr)\\n            res += x\\n        return res\\nobj = Solution()\\nobj.matrixSum([[7,2,1],[6,4,2],[6,5,3],[3,2,1]])\\n# obj.matrixSum([[1]])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSum(self, nums):\\n#         print(nums)\\n        for row in nums:\\n            row.sort(reverse=True)\\n            print(row)\\n        res = 0\\n        for i in range(len(nums[0])):\\n            curr = []\\n            for j in range(len(nums)):\\n                curr.append(nums[j][i])\\n                x = max(curr)\\n            res += x\\n        return res\\nobj = Solution()\\nobj.matrixSum([[7,2,1],[6,4,2],[6,5,3],[3,2,1]])\\n# obj.matrixSum([[1]])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941338,
                "title": "sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int score =0;\\n        int n=nums.length;\\n        int m=nums[0].length;\\n        for(int [] a:nums){\\n            Arrays.sort(a);\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            int max=0;\\n            for(int j=0;j<n;j++){\\n                max=Math.max(max,nums[j][i]);\\n            }\\n            score+=max;\\n        }\\n        return score;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int score =0;\\n        int n=nums.length;\\n        int m=nums[0].length;\\n        for(int [] a:nums){\\n            Arrays.sort(a);\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            int max=0;\\n            for(int j=0;j<n;j++){\\n                max=Math.max(max,nums[j][i]);\\n            }\\n            score+=max;\\n        }\\n        return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939645,
                "title": "beats-99-40-simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int sum = 0;\\n        for(int i = 0 ; i < nums.length ; i++){\\n            Arrays.sort(nums[i]);\\n        }\\n        \\n        \\n        int k = nums[0].length-1;\\n        for(int j = 0 ; j < nums[0].length; j++){\\n            int s = 0;\\n            for(int i = 0 ; i < nums.length ; i++){\\n                s = Math.max(s,nums[i][k]);\\n            }\\n            sum+=s;\\n            k = k-1;\\n\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int sum = 0;\\n        for(int i = 0 ; i < nums.length ; i++){\\n            Arrays.sort(nums[i]);\\n        }\\n        \\n        \\n        int k = nums[0].length-1;\\n        for(int j = 0 ; j < nums[0].length; j++){\\n            int s = 0;\\n            for(int i = 0 ; i < nums.length ; i++){\\n                s = Math.max(s,nums[i][k]);\\n            }\\n            sum+=s;\\n            k = k-1;\\n\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3937786,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Sorting\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Sort all the rows\\n2. calculate the sum of max of each column\\n# Complexity\\n- Time complexity: O(N * N *logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        for i in nums:\\n            i.sort()\\n        su=0\\n        for i in range(len(nums[0])):\\n            mx=0\\n            for j in range(len(nums)):\\n                mx=max(nums[j][i],mx)\\n            su+=mx\\n        return su\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        for i in nums:\\n            i.sort()\\n        su=0\\n        for i in range(len(nums[0])):\\n            mx=0\\n            for j in range(len(nums)):\\n                mx=max(nums[j][i],mx)\\n            su+=mx\\n        return su\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3936312,
                "title": "easy-java-solution-sorting-beats-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] arr) {\\n        int n = arr.length; \\n        int m = arr[0].length;\\n\\n        int ans[][] = new int[n][m];\\n\\n        for(int i=0; i<n; i++){\\n            Arrays.sort(arr[i]);\\n            ans[i] = arr[i];\\n        }\\n\\n        int sum = 0;\\n\\n        for(int j=0; j<m; j++){\\n            int k = 0;\\n            for(int i=0; i<n; i++){\\n                k = Math.max(k,ans[i][j]);\\n            }\\n\\n            sum+=k;\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] arr) {\\n        int n = arr.length; \\n        int m = arr[0].length;\\n\\n        int ans[][] = new int[n][m];\\n\\n        for(int i=0; i<n; i++){\\n            Arrays.sort(arr[i]);\\n            ans[i] = arr[i];\\n        }\\n\\n        int sum = 0;\\n\\n        for(int j=0; j<m; j++){\\n            int k = 0;\\n            for(int i=0; i<n; i++){\\n                k = Math.max(k,ans[i][j]);\\n            }\\n\\n            sum+=k;\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3936169,
                "title": "c-solution-using-sorting-of-each-row",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int ans=0;\\n        int n=nums.size();\\n        int m=nums[0].size();\\n        for(int i=0;i<n;i++)\\n        {\\n            sort(nums[i].begin(),nums[i].end());\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            int maxi=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                maxi=max(maxi,nums[j][i]);\\n            }\\n            ans+=maxi;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int ans=0;\\n        int n=nums.size();\\n        int m=nums[0].size();\\n        for(int i=0;i<n;i++)\\n        {\\n            sort(nums[i].begin(),nums[i].end());\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            int maxi=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                maxi=max(maxi,nums[j][i]);\\n            }\\n            ans+=maxi;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3932370,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int ans=0;\\n        int i,j,x;\\n      // coloumn size\\n        int m=nums.size();\\n      // row size\\n        int n=nums[0].size();\\n        // sorting row elements\\n        for(auto &i : nums)\\n        {\\n            sort(i.begin(),i.end());\\n        }\\n// traversing through the matrix and storing the largest element from each coloumn\\n        for(j=0;j<n;j++ )\\n        {\\n            x=0;\\n            for(int i=0;i<m;i++)\\n            {\\n            x= max(x,nums[i][j]);\\n            }\\n         // x is the largest element from the each column\\n            ans+=x;\\n        }\\n        return ans;\\n    } \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int ans=0;\\n        int i,j,x;\\n      // coloumn size\\n        int m=nums.size();\\n      // row size\\n        int n=nums[0].size();\\n        // sorting row elements\\n        for(auto &i : nums)\\n        {\\n            sort(i.begin(),i.end());\\n        }\\n// traversing through the matrix and storing the largest element from each coloumn\\n        for(j=0;j<n;j++ )\\n        {\\n            x=0;\\n            for(int i=0;i<m;i++)\\n            {\\n            x= max(x,nums[i][j]);\\n            }\\n         // x is the largest element from the each column\\n            ans+=x;\\n        }\\n        return ans;\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3930117,
                "title": "c-easy-to-understand-priority-queue-sorting",
                "content": "# Intuition\\nTaking max from each row - can be done by sorting each row and taking the last element.\\n\\n# Approach\\nSorting each row and taking the last element, that every element is pushed in a max heap, so that at every iteration we can take the top element of the heap, and add to our score.\\n\\n\\n# Complexity\\n- Time complexity: $$O(n*m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n*m)$$ - space of priority queue at every itration\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        \\n        \\n        int n = nums.size();\\n        int m = nums[0].size();\\n        int score = 0 ;\\n\\n        for(int i = 0 ; i<n ; i++){\\n            sort(nums[i].begin() , nums[i].end());\\n        }\\n        \\n            \\n            for(int i = m-1 ; i >=0 ; i--)\\n            {   \\n                priority_queue<int> pq;\\n            \\n                for(int j = 0 ; j<n ; j++){\\n                    cout<<nums[j][i]<<\" \";\\n                    pq.push(nums[j][i]);\\n                }\\n                cout<<endl;\\n            \\n                score = score+pq.top();\\n   \\n            }\\n\\n        return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting",
                    "Heap (Priority Queue)",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        \\n        \\n        int n = nums.size();\\n        int m = nums[0].size();\\n        int score = 0 ;\\n\\n        for(int i = 0 ; i<n ; i++){\\n            sort(nums[i].begin() , nums[i].end());\\n        }\\n        \\n            \\n            for(int i = m-1 ; i >=0 ; i--)\\n            {   \\n                priority_queue<int> pq;\\n            \\n                for(int j = 0 ; j<n ; j++){\\n                    cout<<nums[j][i]<<\" \";\\n                    pq.push(nums[j][i]);\\n                }\\n                cout<<endl;\\n            \\n                score = score+pq.top();\\n   \\n            }\\n\\n        return score;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3929690,
                "title": "2679-sum-in-a-matrix",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int ans=0;\\n        for(int []row:nums)\\n        {\\n            Arrays.sort(row);\\n        }\\n        for(int i=0;i<nums[0].length;i++)\\n        {\\n            int m=0;\\n            for(int j=0;j<nums.length;j++)\\n            {\\n                if(m<nums[j][i])\\n                    m=nums[j][i];\\n            }\\n            ans+=m;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int ans=0;\\n        for(int []row:nums)\\n        {\\n            Arrays.sort(row);\\n        }\\n        for(int i=0;i<nums[0].length;i++)\\n        {\\n            int m=0;\\n            for(int j=0;j<nums.length;j++)\\n            {\\n                if(m<nums[j][i])\\n                    m=nums[j][i];\\n            }\\n            ans+=m;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3925605,
                "title": "java-easy-solution-beats-99-50",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        \\n       int finalscore = 0;\\n\\n       for(int i = 0; i<nums.length; i++){\\n          Arrays.sort(nums[i]);\\n\\n\\n       }\\n\\n       int minr = 0;\\n       int minc = 0;\\n       int maxr = nums.length;\\n       int maxc = nums[0].length;\\n\\n       for(int i = 0; i<nums[0].length; i++){\\n\\n        int max = 0;\\n\\n        for(int j = minr, k=minc; j<maxr; j++ ){\\n                  max = Math.max(max, nums[j][k]);\\n        }\\n       \\n        finalscore +=max;\\n        minc++;\\n        minr = 0;\\n       }\\n       \\n       return finalscore;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        \\n       int finalscore = 0;\\n\\n       for(int i = 0; i<nums.length; i++){\\n          Arrays.sort(nums[i]);\\n\\n\\n       }\\n\\n       int minr = 0;\\n       int minc = 0;\\n       int maxr = nums.length;\\n       int maxc = nums[0].length;\\n\\n       for(int i = 0; i<nums[0].length; i++){\\n\\n        int max = 0;\\n\\n        for(int j = minr, k=minc; j<maxr; j++ ){\\n                  max = Math.max(max, nums[j][k]);\\n        }\\n       \\n        finalscore +=max;\\n        minc++;\\n        minr = 0;\\n       }\\n       \\n       return finalscore;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911580,
                "title": "python-easiest-solution-sorting-the-rows-brets-84",
                "content": "\\n```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        for x in nums:\\n            x.sort()\\n        l=len(nums[0])\\n        temp=0\\n        ans=0\\n        for x in range(l):\\n            for y in nums:\\n                temp=max(temp,y[x])\\n            ans+=temp\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        for x in nums:\\n            x.sort()\\n        l=len(nums[0])\\n        temp=0\\n        ans=0\\n        for x in range(l):\\n            for y in nums:\\n                temp=max(temp,y[x])\\n            ans+=temp\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3904034,
                "title": "simple-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int sum=0;\\n        \\n        \\n        for(int i=0;i<nums.size();i++){\\n            sort(nums[i].begin(),nums[i].end());\\n            }\\n        for(int n=0;n<nums[0].size();n++){\\n            int m=INT_MIN;\\n            for(int i=0;i<nums.size();i++){    \\n                m=max(m,nums[i][n]);\\n            }\\n            sum=sum+m;\\n        \\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int sum=0;\\n        \\n        \\n        for(int i=0;i<nums.size();i++){\\n            sort(nums[i].begin(),nums[i].end());\\n            }\\n        for(int n=0;n<nums[0].size();n++){\\n            int m=INT_MIN;\\n            for(int i=0;i<nums.size();i++){    \\n                m=max(m,nums[i][n]);\\n            }\\n            sum=sum+m;\\n        \\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902815,
                "title": "c-solution",
                "content": "# Intuition\\nSince we have to get the max from each row and then calculate the max from each column and add it the answer(score).\\n\\n# Approach\\nSteps are:\\n1.Therefor we are going to first sort the each row in descending order.\\n2.Then after that we are going to traverse the each column to calculate the max from that column.\\n3.Then we will add that maximum value to answer(score).\\n4.Repeat the above steps.\\n\\n# Complexity\\n- Time complexity:O(n^2)\\n- Since we are traversing in nested loop.\\n\\n- Space complexity:0(1)\\n- Since no extra space is needed.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int n = nums.size();\\n        int m = nums[0].size();\\n        for(auto &it : nums){\\n            sort(it.begin(), it.end(), greater<int>());\\n        }\\n\\n        int ans = 0;\\n        for(int j=0; j<m; j++){\\n            int val = INT_MIN;\\n            for(int i=0; i<n; i++){\\n                val = max(val, nums[i][j]);\\n            }\\n            ans += val;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int n = nums.size();\\n        int m = nums[0].size();\\n        for(auto &it : nums){\\n            sort(it.begin(), it.end(), greater<int>());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3897773,
                "title": "c-too-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& g) {\\n        long long int s=0;\\n        for(auto &i : g)\\n        sort(i.begin(),i.end());\\n        for(int i=0;i<g[0].size();i++)\\n          {\\n              int m=0;\\n              for(int j=0;j<g.size();j++)\\n              m=max(m,g[j][i]);\\n              s+=m;\\n          }\\n          return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& g) {\\n        long long int s=0;\\n        for(auto &i : g)\\n        sort(i.begin(),i.end());\\n        for(int i=0;i<g[0].size();i++)\\n          {\\n              int m=0;\\n              for(int j=0;j<g.size();j++)\\n              m=max(m,g[j][i]);\\n              s+=m;\\n          }\\n          return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3895251,
                "title": "good-question-tricky-but-v-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        for(int i = 0; i<nums.size(); i++){\\n            sort(nums[i].begin(), nums[i].end());\\n            reverse(nums[i].begin(), nums[i].end());\\n            \\n        }\\n        int answer = 0;\\n        int maxI= INT_MIN;\\n        for(int j = 0; j<nums[0].size(); j++){\\n            maxI=INT_MIN;\\n            for(int k = 0; k<nums.size(); k++){\\n                maxI = max(maxI, nums[k][j]);\\n            }\\n            answer += maxI;\\n        }\\n\\n        return answer;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        for(int i = 0; i<nums.size(); i++){\\n            sort(nums[i].begin(), nums[i].end());\\n            reverse(nums[i].begin(), nums[i].end());\\n            \\n        }\\n        int answer = 0;\\n        int maxI= INT_MIN;\\n        for(int j = 0; j<nums[0].size(); j++){\\n            maxI=INT_MIN;\\n            for(int k = 0; k<nums.size(); k++){\\n                maxI = max(maxI, nums[k][j]);\\n            }\\n            answer += maxI;\\n        }\\n\\n        return answer;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3890673,
                "title": "simple-clean-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int r = nums.size();\\n        int c = nums[0].size();\\n        int ans = 0;\\n        int ptr = 0;\\n        int m = 0;\\n        for(int i=0; i<r; i++)\\n        {\\n            sort(nums[i].begin(), nums[i].end(), greater<int>());\\n        }\\n        while(ptr < c)\\n        {\\n            m = 0;\\n            for(int i=0; i<r; i++)\\n            {\\n                m = max(m, nums[i][ptr]);\\n            }\\n            ans += m;\\n            ptr++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int r = nums.size();\\n        int c = nums[0].size();\\n        int ans = 0;\\n        int ptr = 0;\\n        int m = 0;\\n        for(int i=0; i<r; i++)\\n        {\\n            sort(nums[i].begin(), nums[i].end(), greater<int>());\\n        }\\n        while(ptr < c)\\n        {\\n            m = 0;\\n            for(int i=0; i<r; i++)\\n            {\\n                m = max(m, nums[i][ptr]);\\n            }\\n            ans += m;\\n            ptr++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884264,
                "title": "sum-in-a-matrix",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int sum = 0;\\n        int m = nums.length;\\n        int n = nums[0].length;\\n        System.out.println(m+\" \"+n);\\n        for(int i=0;i<n;i++)\\n        {int max1 = 0;\\n        for(int j=0;j<m;j++)\\n        {\\n            int max = 0;\\n            for(int k=0;k<n;k++)\\n            {\\n                max = Math.max(max,nums[j][k]);\\n            }\\n            for(int k=0;k<n;k++)\\n            {\\n                if(nums[j][k]==max)\\n                {nums[j][k]=0;\\n                break;}\\n            }\\n            max1=Math.max(max1,max);\\n        }\\n        sum = sum+max1;}\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int sum = 0;\\n        int m = nums.length;\\n        int n = nums[0].length;\\n        System.out.println(m+\" \"+n);\\n        for(int i=0;i<n;i++)\\n        {int max1 = 0;\\n        for(int j=0;j<m;j++)\\n        {\\n            int max = 0;\\n            for(int k=0;k<n;k++)\\n            {\\n                max = Math.max(max,nums[j][k]);\\n            }\\n            for(int k=0;k<n;k++)\\n            {\\n                if(nums[j][k]==max)\\n                {nums[j][k]=0;\\n                break;}\\n            }\\n            max1=Math.max(max1,max);\\n        }\\n        sum = sum+max1;}\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3871313,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int n=nums.size();\\n        int m=nums[0].size();\\n        for (int i=0;i<n;i++)\\n        {\\n            sort(nums[i].begin(),nums[i].end());\\n        }\\n        int ans=0;\\n        for (int j=0;j<m;j++)\\n        {\\n            int maxi=0;\\n            for (int i=0;i<n;i++)\\n            {\\n              maxi=max(maxi,nums[i][j]);\\n            }\\n            ans+=maxi;\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int n=nums.size();\\n        int m=nums[0].size();\\n        for (int i=0;i<n;i++)\\n        {\\n            sort(nums[i].begin(),nums[i].end());\\n        }\\n        int ans=0;\\n        for (int j=0;j<m;j++)\\n        {\\n            int maxi=0;\\n            for (int i=0;i<n;i++)\\n            {\\n              maxi=max(maxi,nums[i][j]);\\n            }\\n            ans+=maxi;\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3858546,
                "title": "sort-solution-python",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        for i in range(len(nums)):\\n            nums[i].sort(reverse=True)\\n        answer = 0\\n        for i in range(len(nums[0])):\\n            mx = 0\\n            for j in range(len(nums)):\\n                mx = max(mx, nums[j][i])\\n            answer += mx\\n        return answer\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        for i in range(len(nums)):\\n            nums[i].sort(reverse=True)\\n        answer = 0\\n        for i in range(len(nums[0])):\\n            mx = 0\\n            for j in range(len(nums)):\\n                mx = max(mx, nums[j][i])\\n            answer += mx\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3854876,
                "title": "sort",
                "content": "```\\nint matrixSum(vector<vector<int>>& n)\\n{\\n\\tfor(auto & n : n) sort(begin(n), end(n), greater{});\\n\\tint out{};\\n\\tfor(int j{}; j<size(n[0]); ++j)\\n\\t{\\n\\t\\tint M(INT_MIN);\\n\\t\\tfor(int i{}; i<size(n); ++i)\\n\\t\\t\\tM=max(M, n[i][j]);\\n\\t\\tout+=M;\\n\\t}\\n\\treturn out;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint matrixSum(vector<vector<int>>& n)\\n{\\n\\tfor(auto & n : n) sort(begin(n), end(n), greater{});\\n\\tint out{};\\n\\tfor(int j{}; j<size(n[0]); ++j)\\n\\t{\\n\\t\\tint M(INT_MIN);\\n\\t\\tfor(int i{}; i<size(n); ++i)\\n\\t\\t\\tM=max(M, n[i][j]);\\n\\t\\tout+=M;\\n\\t}\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3852036,
                "title": "c-beats-98-14-simple",
                "content": "class Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {  \\n        for(auto &num:nums){\\n            sort(num.begin(),num.end());\\n        }\\n        int sum=0;\\n        for(int i=0;i<nums[0].size();i++){\\n            int max1=INT_MIN;\\n            for(int j=0;j<nums.size();j++){\\n                max1=max(max1,nums[j][i]);\\n            }\\n            sum+=max1;\\n        }\\n        return sum;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {  \\n        for(auto &num:nums){\\n            sort(num.begin(),num.end());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3852009,
                "title": "c-priority-queue",
                "content": "class Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {  \\n        for(auto &num:nums){\\n            sort(num.begin(),num.end());\\n        }\\n        int sum=0;\\n        priority_queue<int> pq;\\n        for(int i=0;i<nums[0].size();i++){\\n            for(auto num:nums){\\n                pq.push(num[i]);\\n            }\\n            sum+=pq.top();\\n            cout<<pq.top()<<endl;\\n\\n            while(!pq.empty()) pq.pop();\\n        }\\n        return sum;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {  \\n        for(auto &num:nums){\\n            sort(num.begin(),num.end());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3850720,
                "title": "python-sort-solution-beats-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition is that we want to first sort each row then loop through this to add the max value at each index.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Sort each row\\n2. Create score var\\n2. For every index in a row, find the max value of each row at that index\\n3. Add those max values to the score var\\n4. Return score\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        for row in nums:\\n            row.sort()\\n        \\n        score = 0\\n        for i in range(len(nums[0])-1,-1,-1):\\n            maximum = -1\\n            for row in nums:\\n                maximum = max(row[i], maximum)\\n            \\n            score+=maximum\\n\\n        return score\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Sort"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        for row in nums:\\n            row.sort()\\n        \\n        score = 0\\n        for i in range(len(nums[0])-1,-1,-1):\\n            maximum = -1\\n            for row in nums:\\n                maximum = max(row[i], maximum)\\n            \\n            score+=maximum\\n\\n        return score\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3844004,
                "title": "python-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        for row in nums:\\n            row.sort(reverse=True)\\n        ans=0\\n        for i in range(len(nums[0])):\\n            arr=[]\\n            for j in range(len(nums)):\\n                heapq.heappush(arr,-nums[j][i])\\n            heapq.heapify(arr)\\n            a=-heapq.heappop(arr)\\n            ans+=a\\n            \\n\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        for row in nums:\\n            row.sort(reverse=True)\\n        ans=0\\n        for i in range(len(nums[0])):\\n            arr=[]\\n            for j in range(len(nums)):\\n                heapq.heappush(arr,-nums[j][i])\\n            heapq.heapify(arr)\\n            a=-heapq.heappop(arr)\\n            ans+=a\\n            \\n\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3842937,
                "title": "easy-to-get-solution-using-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int score=0;\\n        int n=nums.length;\\n        int m=nums[0].length;\\n        for(int[] a :nums) Arrays.sort(a);\\n        \\n        for(int i=0;i<m;i++){\\n            int max=0;\\n            for(int j=0;j<n;j++){\\n                max=Math.max(max,nums[j][i]);\\n            }\\n            score+=max;\\n        }\\n\\n        return score;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int score=0;\\n        int n=nums.length;\\n        int m=nums[0].length;\\n        for(int[] a :nums) Arrays.sort(a);\\n        \\n        for(int i=0;i<m;i++){\\n            int max=0;\\n            for(int j=0;j<n;j++){\\n                max=Math.max(max,nums[j][i]);\\n            }\\n            score+=max;\\n        }\\n\\n        return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3838325,
                "title": "simple-js",
                "content": "\\n```\\n\\nconst matrixSum = function (nums) {\\n  let sum = 0;\\n\\n  nums.forEach(arr => arr.sort((a, b) => b - a));\\n\\n  for (let i = 0; i < nums[0].length; i++) {\\n    const maxVals = [];\\n\\n    for (let j = 0; j < nums.length; j++) {\\n      maxVals.push(nums[j][i]);\\n    }\\n\\n    sum += Math.max(...maxVals);\\n  }\\n\\n  return sum;\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nconst matrixSum = function (nums) {\\n  let sum = 0;\\n\\n  nums.forEach(arr => arr.sort((a, b) => b - a));\\n\\n  for (let i = 0; i < nums[0].length; i++) {\\n    const maxVals = [];\\n\\n    for (let j = 0; j < nums.length; j++) {\\n      maxVals.push(nums[j][i]);\\n    }\\n\\n    sum += Math.max(...maxVals);\\n  }\\n\\n  return sum;\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3825028,
                "title": "intuitive-approach-that-beats-100-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n-> Sort each subarray in reverse order\\n-> Create a for loop that loops until the maxlength of nums-subarray.\\n-> if i is out-of-bounds of num then skip or else normal logic to find maxelem\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: o(mlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n\\n        maxlen = 0\\n\\n        returnsum = 0\\n\\n        for num in nums:\\n            if len(num) > maxlen:\\n                maxlen = len(num)\\n            num.sort(reverse=True)\\n\\n        for i in range(maxlen):\\n\\n            maxelem = float(\\'-inf\\')\\n\\n            for num in nums:\\n                if i >= len(num):\\n                    continue\\n                elif num[i] > maxelem:\\n                    maxelem = num[i]\\n            \\n            returnsum +=maxelem\\n        \\n        return returnsum\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n\\n        maxlen = 0\\n\\n        returnsum = 0\\n\\n        for num in nums:\\n            if len(num) > maxlen:\\n                maxlen = len(num)\\n            num.sort(reverse=True)\\n\\n        for i in range(maxlen):\\n\\n            maxelem = float(\\'-inf\\')\\n\\n            for num in nums:\\n                if i >= len(num):\\n                    continue\\n                elif num[i] > maxelem:\\n                    maxelem = num[i]\\n            \\n            returnsum +=maxelem\\n        \\n        return returnsum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820339,
                "title": "java-easy-beats-90-o-n-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        for(int i[]: nums){\\n            Arrays.sort(i);\\n        }\\n        int ans=0;\\n        for(int i =0; i <nums[0].length; i++){\\n            int max=0;\\n            for(int j =0; j<nums.length; j++){\\n                max=Math.max(nums[j][i],max);\\n            }\\n            ans+=max;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        for(int i[]: nums){\\n            Arrays.sort(i);\\n        }\\n        int ans=0;\\n        for(int i =0; i <nums[0].length; i++){\\n            int max=0;\\n            for(int j =0; j<nums.length; j++){\\n                max=Math.max(nums[j][i],max);\\n            }\\n            ans+=max;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3806394,
                "title": "column-sum-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int ans = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            sort(nums[i].begin(), nums[i].end(), greater<int> ());\\n        }\\n        for(int i = 0; i < nums[0].size(); i++){\\n            int maxi = INT_MIN;\\n            for(int j = 0; j < nums.size(); j++){\\n                maxi = max(maxi, nums[j][i]);\\n            }\\n            ans+= maxi;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int ans = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            sort(nums[i].begin(), nums[i].end(), greater<int> ());\\n        }\\n        for(int i = 0; i < nums[0].size(); i++){\\n            int maxi = INT_MIN;\\n            for(int j = 0; j < nums.size(); j++){\\n                maxi = max(maxi, nums[j][i]);\\n            }\\n            ans+= maxi;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3794858,
                "title": "intuitive-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n# Complexity\\n- Time complexity:\\n<!-- O(mnlogn) for a m x n matrix -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) space\\n\\n# Code\\n```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        \\n        #Brute-Force\\n            #init score\\n            #while nums is not empty\\n                #init final list\\n                #for every row in nums\\n                    #extract max of row\\n                    #add max to score\\n        score = 0\\n        cols = len(nums[0])\\n\\n        for i in range(len(nums)):\\n            nums[i].sort(reverse=True)\\n     \\n        for j in range(cols):\\n            final = 0\\n            for k in nums:\\n                high = k[0]\\n                final = max(final, high)\\n                k.remove(high)\\n            \\n            score += final\\n\\n        return score\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        \\n        #Brute-Force\\n            #init score\\n            #while nums is not empty\\n                #init final list\\n                #for every row in nums\\n                    #extract max of row\\n                    #add max to score\\n        score = 0\\n        cols = len(nums[0])\\n\\n        for i in range(len(nums)):\\n            nums[i].sort(reverse=True)\\n     \\n        for j in range(cols):\\n            final = 0\\n            for k in nums:\\n                high = k[0]\\n                final = max(final, high)\\n                k.remove(high)\\n            \\n            score += final\\n\\n        return score\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3791051,
                "title": "java-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int row = nums.length;\\n        int col = nums[0].length;\\n        List<List<Integer>> l = new ArrayList<>();\\n        int count = 0;\\n        int max = Integer.MIN_VALUE;\\n        int maxIndexX = -1;\\n        int maxIndexY = -1;\\n        int iteration = 0;\\n        while (iteration < col) {\\n            List<Integer> l1 = new ArrayList<>();\\n            for (int i = 0; i < row; i++) {\\n\\n                for (int j = 0; j < col; j++) {\\n                    if (nums[i][j] > max) {\\n                        maxIndexX = i;\\n                        maxIndexY = j;\\n                        max = nums[i][j];\\n                    }\\n                }\\n                l1.add(max);\\n                nums[maxIndexX][maxIndexY] = Integer.MIN_VALUE;\\n                max = Integer.MIN_VALUE;\\n                maxIndexX = -1;\\n                maxIndexY = -1;\\n            }\\n\\n            l.add(l1);\\n            iteration++;\\n        }\\n\\n        for (List<Integer> l1 : l) {\\n            count += l1.stream().sorted(Collections.reverseOrder()).findFirst().get();\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int row = nums.length;\\n        int col = nums[0].length;\\n        List<List<Integer>> l = new ArrayList<>();\\n        int count = 0;\\n        int max = Integer.MIN_VALUE;\\n        int maxIndexX = -1;\\n        int maxIndexY = -1;\\n        int iteration = 0;\\n        while (iteration < col) {\\n            List<Integer> l1 = new ArrayList<>();\\n            for (int i = 0; i < row; i++) {\\n\\n                for (int j = 0; j < col; j++) {\\n                    if (nums[i][j] > max) {\\n                        maxIndexX = i;\\n                        maxIndexY = j;\\n                        max = nums[i][j];\\n                    }\\n                }\\n                l1.add(max);\\n                nums[maxIndexX][maxIndexY] = Integer.MIN_VALUE;\\n                max = Integer.MIN_VALUE;\\n                maxIndexX = -1;\\n                maxIndexY = -1;\\n            }\\n\\n            l.add(l1);\\n            iteration++;\\n        }\\n\\n        for (List<Integer> l1 : l) {\\n            count += l1.stream().sorted(Collections.reverseOrder()).findFirst().get();\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3784036,
                "title": "2-solutions-1-priority-queue-2-soring-o-1-space",
                "content": "# Priority Queue\\n- Time complexity: $$O(n^2logn)$$ \\n\\n- Space complexity: $$O(n^2)$$ \\n\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int n = nums[0].size();\\n        vector<priority_queue<int>> pq;\\n\\n        for(int i=0; i<nums.size(); i++) //....O(n)\\n        {\\n            priority_queue<int> temp;\\n            for(auto it : nums[i])  //.........O(n * n)\\n             temp.push(it);         //.........O(n * n * logn)\\n            pq.push_back(temp);\\n        }\\n\\n    int sum = 0;\\n        while(n--)                            //........O(n)\\n        {\\n            int maxi = INT_MIN;\\n            for(int i=0; i<nums.size(); i++) //........O(n * n)\\n            {\\n             int currMax = pq[i].top(); pq[i].pop(); //...O(n * n * logn)\\n             maxi = max(maxi,currMax);\\n            }\\n            sum += maxi;\\n        }\\n    return sum;\\n    }\\n};\\n```\\n# Sorting + Constant Space\\n- Time complexity: $$O(n^2logn)$$ \\n\\n- Space complexity: $$O(1)$$ \\n\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n     int sum = 0;\\n        for(int i=0; i<nums.size(); i++)     //.....O(n)\\n         sort(nums[i].begin(),nums[i].end()); //....O(n * nlogn)\\n\\n        for(int j=0; j<nums[0].size(); j++) //......O(n)\\n        {\\n            int maxi = INT_MIN;\\n            for(int i=0; i<nums.size(); i++) //......O(n * n)\\n            {\\n             maxi = max(maxi,nums[i][j]);\\n            }\\n            sum += maxi;\\n        }\\n     return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int n = nums[0].size();\\n        vector<priority_queue<int>> pq;\\n\\n        for(int i=0; i<nums.size(); i++) //....O(n)\\n        {\\n            priority_queue<int> temp;\\n            for(auto it : nums[i])  //.........O(n * n)\\n             temp.push(it);         //.........O(n * n * logn)\\n            pq.push_back(temp);\\n        }\\n\\n    int sum = 0;\\n        while(n--)                            //........O(n)\\n        {\\n            int maxi = INT_MIN;\\n            for(int i=0; i<nums.size(); i++) //........O(n * n)\\n            {\\n             int currMax = pq[i].top(); pq[i].pop(); //...O(n * n * logn)\\n             maxi = max(maxi,currMax);\\n            }\\n            sum += maxi;\\n        }\\n    return sum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n     int sum = 0;\\n        for(int i=0; i<nums.size(); i++)     //.....O(n)\\n         sort(nums[i].begin(),nums[i].end()); //....O(n * nlogn)\\n\\n        for(int j=0; j<nums[0].size(); j++) //......O(n)\\n        {\\n            int maxi = INT_MIN;\\n            for(int i=0; i<nums.size(); i++) //......O(n * n)\\n            {\\n             maxi = max(maxi,nums[i][j]);\\n            }\\n            sum += maxi;\\n        }\\n     return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777968,
                "title": "first-sort-each-row-and-then-solve",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int ans = 0;\\n         for(int[] a :nums)\\n        {\\n            Arrays.sort(a);\\n        }\\n        for(int i = 0; i<nums[0].length;i++){\\n            int x = 0;\\n            for(int j = 0 ; j < nums.length ;j++){\\n                x = Math.max(x,nums[j][i]);\\n            }\\n            ans = ans + x;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int ans = 0;\\n         for(int[] a :nums)\\n        {\\n            Arrays.sort(a);\\n        }\\n        for(int i = 0; i<nums[0].length;i++){\\n            int x = 0;\\n            for(int j = 0 ; j < nums.length ;j++){\\n                x = Math.max(x,nums[j][i]);\\n            }\\n            ans = ans + x;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777498,
                "title": "simple-iterative-beginner-friendly-beats-85",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int n=nums.length;\\n        int m=nums[0].length;\\n        int score=0;\\n        for(int[] a:nums){\\n            Arrays.sort(a);\\n        }\\n        int max;\\n        for(int i=0;i<m;i++){\\n            max=0;\\n            for(int j=0;j<n;j++){\\n                if(max<nums[j][i]){\\n                    max=nums[j][i];\\n                }\\n            }\\n            score+=max;\\n        }\\n        return score;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sort",
                    "Matrix",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int n=nums.length;\\n        int m=nums[0].length;\\n        int score=0;\\n        for(int[] a:nums){\\n            Arrays.sort(a);\\n        }\\n        int max;\\n        for(int i=0;i<m;i++){\\n            max=0;\\n            for(int j=0;j<n;j++){\\n                if(max<nums[j][i]){\\n                    max=nums[j][i];\\n                }\\n            }\\n            score+=max;\\n        }\\n        return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773631,
                "title": "sort-rows-93-speed",
                "content": "![image.png](https://assets.leetcode.com/users/images/675be2ed-c21b-4d61-b091-59b16337d403_1689511656.978553.png)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        for i in range(len(nums)):\\n            nums[i].sort()\\n        return sum(max(col) for col in zip(*nums))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        for i in range(len(nums)):\\n            nums[i].sort()\\n        return sum(max(col) for col in zip(*nums))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3764942,
                "title": "dart-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int matrixSum(List<List<int>> nums) {\\n  for(List<int> sublist in nums) {\\n    sublist.sort((a,b) => b.compareTo(a));\\n  }\\n  List<List<int>> output = [];\\n  for(int i = 0; i < nums[0].length; i++) {\\n    List<int> firstNumbers = [];\\n    for(List<int> sublist in nums) {\\n      firstNumbers.add(sublist[i]);\\n    }\\n    output.add(firstNumbers);\\n  }\\n  List<int> maxNumbers = output.map((e) => e.reduce((value, element) => value > element ? value : element)).toList();\\n  int result = maxNumbers.reduce((value, element) => value + element);\\n  return result;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int matrixSum(List<List<int>> nums) {\\n  for(List<int> sublist in nums) {\\n    sublist.sort((a,b) => b.compareTo(a));\\n  }\\n  List<List<int>> output = [];\\n  for(int i = 0; i < nums[0].length; i++) {\\n    List<int> firstNumbers = [];\\n    for(List<int> sublist in nums) {\\n      firstNumbers.add(sublist[i]);\\n    }\\n    output.add(firstNumbers);\\n  }\\n  List<int> maxNumbers = output.map((e) => e.reduce((value, element) => value > element ? value : element)).toList();\\n  int result = maxNumbers.reduce((value, element) => value + element);\\n  return result;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734978,
                "title": "sum-in-a-matrix-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2logn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        vector<priority_queue<int>> arr;\\n        priority_queue<int> pq;\\n        int i, j, sum=0;\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            for(j=0 ; j<nums[i].size() ; j++)\\n            {\\n                pq.push(nums[i][j]);\\n            }\\n            arr.push_back(pq);\\n            pq = priority_queue<int>();\\n        }\\n        while(!arr[0].empty())\\n        {\\n            for(i=0 ; i<arr.size() ; i++)\\n            {\\n                pq.push(arr[i].top());\\n                arr[i].pop();\\n            }\\n            sum += pq.top();\\n            pq = priority_queue<int>();\\n        }\\n        return sum;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/09e11844-d0db-4c82-89c4-38a3a4227feb_1688796804.6589239.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        vector<priority_queue<int>> arr;\\n        priority_queue<int> pq;\\n        int i, j, sum=0;\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            for(j=0 ; j<nums[i].size() ; j++)\\n            {\\n                pq.push(nums[i][j]);\\n            }\\n            arr.push_back(pq);\\n            pq = priority_queue<int>();\\n        }\\n        while(!arr[0].empty())\\n        {\\n            for(i=0 ; i<arr.size() ; i++)\\n            {\\n                pq.push(arr[i].top());\\n                arr[i].pop();\\n            }\\n            sum += pq.top();\\n            pq = priority_queue<int>();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3724727,
                "title": "c-sort-and-traverse",
                "content": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        for(auto&i:nums)sort(begin(i),end(i),greater<>());\\n        int ans=0;\\n        for(int i=0;i<size(nums[0]);++i){\\n            int mx=0;\\n            for(auto&j:nums)mx=max(mx,j[i]);\\n            ans+=mx;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        for(auto&i:nums)sort(begin(i),end(i),greater<>());\\n        int ans=0;\\n        for(int i=0;i<size(nums[0]);++i){\\n            int mx=0;\\n            for(auto&j:nums)mx=max(mx,j[i]);\\n            ans+=mx;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3721064,
                "title": "arra",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n 1. Sort each row of nums\\n 2. take Jth element from each row of array in each iteration\\n\\n\\n# Complexity\\n- Time complexity: O(M*N)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int m = nums[0].size();\\n        int n = nums.size();\\n        int t = m;\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            sort(nums[i].begin(), nums[i].end());\\n        }\\n        for(int j=0;j<m;j++){\\n            int newMax = -1;\\n            for(int i=0;i<n;i++){\\n                newMax = max(newMax, nums[i][j]);\\n            }\\n            ans += newMax;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int m = nums[0].size();\\n        int n = nums.size();\\n        int t = m;\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            sort(nums[i].begin(), nums[i].end());\\n        }\\n        for(int j=0;j<m;j++){\\n            int newMax = -1;\\n            for(int i=0;i<n;i++){\\n                newMax = max(newMax, nums[i][j]);\\n            }\\n            ans += newMax;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714469,
                "title": "innovative-and-easiest-soln-using-arrays-sort",
                "content": "# Approach\\n- We sort the Arrays at each Index of ```nums```.\\n- We Dynamically Sort the ```nums``` using ```sortbyColumn``` function by decreasing value of ```i```, which ensures that the highest numbers of all removing row numbers occurs at ```nums[0][i]```.\\n\\n\\n# Code\\n```\\nclass Solution {\\n\\n    // Sorting of 2D Array by Column\\n    public static void sortbyColumn(int arr[][], int col){\\n      Arrays.sort(arr, (a, b) -> Integer.compare(b[col],a[col]));\\n    }\\n\\n    // Solution\\n    public int matrixSum(int[][] nums) {\\n        for(int i=0; i<nums.length; i++){\\n            Arrays.sort(nums[i]);\\n        }\\n        int finalScore=0;\\n        int i=nums[0].length-1;\\n        while(i>=0){\\n            sortbyColumn(nums,i);\\n            finalScore+=nums[0][i];\\n            i--;\\n        }\\n        return finalScore;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```nums```\n```nums```\n```sortbyColumn```\n```i```\n```nums[0][i]```\n```\\nclass Solution {\\n\\n    // Sorting of 2D Array by Column\\n    public static void sortbyColumn(int arr[][], int col){\\n      Arrays.sort(arr, (a, b) -> Integer.compare(b[col],a[col]));\\n    }\\n\\n    // Solution\\n    public int matrixSum(int[][] nums) {\\n        for(int i=0; i<nums.length; i++){\\n            Arrays.sort(nums[i]);\\n        }\\n        int finalScore=0;\\n        int i=nums[0].length-1;\\n        while(i>=0){\\n            sortbyColumn(nums,i);\\n            finalScore+=nums[0][i];\\n            i--;\\n        }\\n        return finalScore;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714227,
                "title": "basic-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n           int ans = 0;\\n\\n        for(auto &i: nums){\\n            sort(i.begin(),i.end());\\n        }\\n        for(int j = 0; j < nums[i].size(); j++){\\n            x = 0;\\n            for(int i = 0; i < nums.size(); i++){\\n                x = max(x,nums[i][j]);\\n            }\\n            ans += x;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n           int ans = 0;\\n\\n        for(auto &i: nums){\\n            sort(i.begin(),i.end());\\n        }\\n        for(int j = 0; j < nums[i].size(); j++){\\n            x = 0;\\n            for(int i = 0; i < nums.size(); i++){\\n                x = max(x,nums[i][j]);\\n            }\\n            ans += x;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3709635,
                "title": "sort-2d-array-find-largest-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        \\n        int m=nums.size();\\n        int n=nums[0].size();\\n        for(int i=0;i<m;i++) sort(nums[i].begin(),nums[i].end());\\n        int ans=0;\\n        for(int j=0;j<n;j++)\\n        {\\n            int maxi=INT_MIN;\\n            for(int i=0;i<m;i++)\\n            {\\n                maxi=max(maxi,nums[i][j]);\\n            }\\n            ans+=maxi;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        \\n        int m=nums.size();\\n        int n=nums[0].size();\\n        for(int i=0;i<m;i++) sort(nums[i].begin(),nums[i].end());\\n        int ans=0;\\n        for(int j=0;j<n;j++)\\n        {\\n            int maxi=INT_MIN;\\n            for(int i=0;i<m;i++)\\n            {\\n                maxi=max(maxi,nums[i][j]);\\n            }\\n            ans+=maxi;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708522,
                "title": "python3-2-liner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def matrixSum(self, grid: List[List[int]]) -> int:\\n        \\n        for i in range(len(grid)): grid[i].sort(reverse = True)\\n\\n        return sum(max(i)for i in [[grid[j][i] for j in range(len(grid))] for i in range(len(grid[0]))])\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSum(self, grid: List[List[int]]) -> int:\\n        \\n        for i in range(len(grid)): grid[i].sort(reverse = True)\\n\\n        return sum(max(i)for i in [[grid[j][i] for j in range(len(grid))] for i in range(len(grid[0]))])\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703037,
                "title": "c-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n^3)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int sum = 0;\\n        int maxAmongstAll = 0;\\n        for (int i = 0; i < nums[0].size(); i++) {\\n            maxAmongstAll = 0;\\n            for (int j = 0; j < nums.size(); j++) {\\n                vector<int> maxInRow{0, 0};\\n                for (int k = 0; k < nums[j].size(); k++) {\\n                    if (maxInRow[0] < nums[j][k]) {\\n                        maxInRow[0] = nums[j][k];\\n                        maxInRow[1] = k;\\n                    }\\n                }\\n                nums[j][maxInRow[1]] = 0;\\n                if (maxAmongstAll < maxInRow[0]) maxAmongstAll = maxInRow[0];\\n            }\\n            sum += maxAmongstAll;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int sum = 0;\\n        int maxAmongstAll = 0;\\n        for (int i = 0; i < nums[0].size(); i++) {\\n            maxAmongstAll = 0;\\n            for (int j = 0; j < nums.size(); j++) {\\n                vector<int> maxInRow{0, 0};\\n                for (int k = 0; k < nums[j].size(); k++) {\\n                    if (maxInRow[0] < nums[j][k]) {\\n                        maxInRow[0] = nums[j][k];\\n                        maxInRow[1] = k;\\n                    }\\n                }\\n                nums[j][maxInRow[1]] = 0;\\n                if (maxAmongstAll < maxInRow[0]) maxAmongstAll = maxInRow[0];\\n            }\\n            sum += maxAmongstAll;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701690,
                "title": "99-faster-solution-java",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int score = 0;\\n        int max = Integer.MIN_VALUE;\\n\\n        for(int i = 0;i<nums.length;i++){\\n            Arrays.sort(nums[i]);\\n        }\\n\\n        for(int i = nums[0].length-1;i>=0;i--){\\n            max=0;\\n            for(int j = 0;j<nums.length;j++){\\n                max = Math.max(max,nums[j][i]);\\n            }\\n            score+=max;\\n        }\\n        return score;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int score = 0;\\n        int max = Integer.MIN_VALUE;\\n\\n        for(int i = 0;i<nums.length;i++){\\n            Arrays.sort(nums[i]);\\n        }\\n\\n        for(int i = nums[0].length-1;i>=0;i--){\\n            max=0;\\n            for(int j = 0;j<nums.length;j++){\\n                max = Math.max(max,nums[j][i]);\\n            }\\n            score+=max;\\n        }\\n        return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3699493,
                "title": "python-simple-python-solution-using-greedy",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 785 ms, faster than 44.04% of Python3 online submissions for Sum in a Matrix.\\n# Memory Usage: 34.5 MB, less than 61.84% of Python3 online submissions for Sum in a Matrix.\\n\\n\\tclass Solution:\\n\\t\\tdef matrixSum(self, nums: List[List[int]]) -> int:\\n\\n\\t\\t\\tresult = 0\\n\\n\\t\\t\\tfor index in range(len(nums)):\\n\\n\\t\\t\\t\\tnums[index] = sorted(nums[index])[::-1]\\n\\n\\t\\t\\tfor col in range(len(nums[0])):\\n\\n\\t\\t\\t\\tcurrent_max = -1\\n\\n\\t\\t\\t\\tfor row in range(len(nums)):\\n\\n\\t\\t\\t\\t\\tcurrent_max = max(current_max, nums[row][col])\\n\\n\\t\\t\\t\\tresult = result + current_max\\n\\n\\t\\t\\treturn result\\n\\t\\t\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Sorting",
                    "Matrix"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 785 ms, faster than 44.04% of Python3 online submissions for Sum in a Matrix.\\n# Memory Usage: 34.5 MB, less than 61.84% of Python3 online submissions for Sum in a Matrix.\\n\\n\\tclass Solution:\\n\\t\\tdef matrixSum(self, nums: List[List[int]]) -> int:\\n\\n\\t\\t\\tresult = 0\\n\\n\\t\\t\\tfor index in range(len(nums)):\\n\\n\\t\\t\\t\\tnums[index] = sorted(nums[index])[::-1]\\n\\n\\t\\t\\tfor col in range(len(nums[0])):\\n\\n\\t\\t\\t\\tcurrent_max = -1\\n\\n\\t\\t\\t\\tfor row in range(len(nums)):\\n\\n\\t\\t\\t\\t\\tcurrent_max = max(current_max, nums[row][col])\\n\\n\\t\\t\\t\\tresult = result + current_max\\n\\n\\t\\t\\treturn result\\n\\t\\t\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 3699447,
                "title": "easy-explained-approach-for-o-n-m",
                "content": "# Intuition\\nTake array of priority_queues and for no of elements in a col take the top element of all rows and add the maximum of them in answer.\\nthis is repeated for col times.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N*M)\\n\\n- Space complexity:\\nO(N*M)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        vector<priority_queue<int>>arr(nums.size());\\n        for(int i=0;i<nums.size();i++){\\n            for(auto j:nums[i]){\\n                arr[i].push(j);\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<nums[0].size();i++){\\n            int val=0;\\n            for(int j=0;j<nums.size();j++){\\n                val=max(val,arr[j].top());\\n                arr[j].pop();\\n            }\\n            ans+=val;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        vector<priority_queue<int>>arr(nums.size());\\n        for(int i=0;i<nums.size();i++){\\n            for(auto j:nums[i]){\\n                arr[i].push(j);\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<nums[0].size();i++){\\n            int val=0;\\n            for(int j=0;j<nums.size();j++){\\n                val=max(val,arr[j].top());\\n                arr[j].pop();\\n            }\\n            ans+=val;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3694236,
                "title": "beginner-friendly-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) \\n    {\\n        int row=nums.size();\\n        int col=nums[0].size();\\n        int max=INT_MIN;\\n        int sum=0;\\n        for(int i = 0 ; i < row ; i++)\\n         {\\n            sort(nums[i].begin(),nums[i].end());\\n         }\\n        for(int i=0;i<col;i++)\\n        {\\n            int max=INT_MIN;\\n            int val=0;\\n            for(int j=0;j<row;j++)\\n            {\\n                val=nums[j][i];\\n                {\\n                    if(val>max)\\n                    {\\n                        max=val;\\n                    }\\n                }\\n            }\\n            sum+=max;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) \\n    {\\n        int row=nums.size();\\n        int col=nums[0].size();\\n        int max=INT_MIN;\\n        int sum=0;\\n        for(int i = 0 ; i < row ; i++)\\n         {\\n            sort(nums[i].begin(),nums[i].end());\\n         }\\n        for(int i=0;i<col;i++)\\n        {\\n            int max=INT_MIN;\\n            int val=0;\\n            for(int j=0;j<row;j++)\\n            {\\n                val=nums[j][i];\\n                {\\n                    if(val>max)\\n                    {\\n                        max=val;\\n                    }\\n                }\\n            }\\n            sum+=max;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3692989,
                "title": "sorting-approach-java-simple-solution-clean-code",
                "content": "# Complexity\\nLet `n = nums.length`\\n`m = nums[0].length`\\n- Time complexity: $O(n \\\\cdot m \\\\cdot log(m))$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(1)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int n = nums.length;\\n        int m = nums[0].length;\\n        for(int i = 0;i < n;i++){\\n            Arrays.sort(nums[i]);\\n        }\\n        int ans = 0;\\n        for(int j = 0;j < m;j++){\\n            int max = -1;\\n            for(int i = 0;i < n;i++){\\n                max = Math.max(max,nums[i][j]);\\n            }\\n            ans += max;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```java\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int n = nums.length;\\n        int m = nums[0].length;\\n        for(int i = 0;i < n;i++){\\n            Arrays.sort(nums[i]);\\n        }\\n        int ans = 0;\\n        for(int j = 0;j < m;j++){\\n            int max = -1;\\n            for(int i = 0;i < n;i++){\\n                max = Math.max(max,nums[i][j]);\\n            }\\n            ans += max;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691916,
                "title": "java-simple-to-understand",
                "content": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        for (int[] curr : nums) Arrays.sort(curr);\\n        int n = nums[0].length - 1, sum = 0;\\n        while (n >= 0) {\\n            int max = -1;\\n            for (int[] curr : nums) {\\n                max = Math.max(curr[n], max);\\n            }\\n            sum += max;\\n            n--;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        for (int[] curr : nums) Arrays.sort(curr);\\n        int n = nums[0].length - 1, sum = 0;\\n        while (n >= 0) {\\n            int max = -1;\\n            for (int[] curr : nums) {\\n                max = Math.max(curr[n], max);\\n            }\\n            sum += max;\\n            n--;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3676623,
                "title": "priority-queue-step-wise-easy-to-understand",
                "content": "# Intuition\\nWe need to traverse through the sub_arrays in side the main array and find the maximum of those sub_arrays , then from the list of those maximums we want the maximum and store it .\\n\\nWe need to repeat the above iteration for len(sub_array.) The length of sub_arrays has to be equal.\\n\\n# Approach\\nThe first loop takes care of the fact that the process needs to run for the len(sub_array)\\nThe inner for loop is picking up the sub_array and finding out the maximum.\\n\\nNext I have used a Priority queue which will store the maximum(maximum) and by the use of get() function, I get the first value that needs to be added in the total sum.\\n\\n# Complexity\\nSpace = O(n)\\nTime = O(kn)\\n\\nPLEASE UPVOTE IF YOU LIKE THE SOLUTION!!\\n# Code\\n```\\nfrom queue import PriorityQueue\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        sm=0\\n        k=len(nums[0])\\n        while(k>0):\\n            pq=PriorityQueue()\\n            for i in nums:\\n                #pq=PriorityQueue()\\n                i.sort()\\n                val=i[len(i)-1]\\n                i[len(i)-1]=0\\n                pq.put(-1*val)\\n            sm+=(-1*pq.get())\\n            k-=1\\n        print(sm)\\n        return sm\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom queue import PriorityQueue\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        sm=0\\n        k=len(nums[0])\\n        while(k>0):\\n            pq=PriorityQueue()\\n            for i in nums:\\n                #pq=PriorityQueue()\\n                i.sort()\\n                val=i[len(i)-1]\\n                i[len(i)-1]=0\\n                pq.put(-1*val)\\n            sm+=(-1*pq.get())\\n            k-=1\\n        print(sm)\\n        return sm\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3658363,
                "title": "c-solution-explain-with-comments",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int ans = 0;\\n\\n        // sorting every row in decending order\\n        // so that highest value will shift to left side\\n        // then we can easily eliminate highest value\\n\\n        for(auto &val : nums){\\n            sort(val.rbegin(),val.rend());\\n        }\\n\\n        // looping column wise (top to bottom) first to get the highest value and then row wise (left to right).\\n        // add it to ans\\n\\n        for(int i=0;i<nums[0].size();i++){\\n\\n            int toBeAdded = 0;\\n\\n            for(int j=0;j<nums.size();j++){\\n                toBeAdded = max(toBeAdded,nums[j][i]);\\n            }\\n\\n            ans += toBeAdded;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int ans = 0;\\n\\n        // sorting every row in decending order\\n        // so that highest value will shift to left side\\n        // then we can easily eliminate highest value\\n\\n        for(auto &val : nums){\\n            sort(val.rbegin(),val.rend());\\n        }\\n\\n        // looping column wise (top to bottom) first to get the highest value and then row wise (left to right).\\n        // add it to ans\\n\\n        for(int i=0;i<nums[0].size();i++){\\n\\n            int toBeAdded = 0;\\n\\n            for(int j=0;j<nums.size();j++){\\n                toBeAdded = max(toBeAdded,nums[j][i]);\\n            }\\n\\n            ans += toBeAdded;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3657775,
                "title": "using-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        int n=nums.size();\\n        int m=nums[0].size();\\n        priority_queue<int>pq[n];\\n        for(int i=0;i<nums.size();i++){\\n            priority_queue<int>q;\\n            for(int j=0;j<nums[i].size();j++){\\n                q.push(nums[i][j]);\\n            }\\n            pq[i]=q;\\n        }\\n        int ans=0;\\n        for(int i=0;i<m;i++){\\n            int curr_max=0;\\n            for(int j=0;j<n;j++){\\n                curr_max=max(curr_max,pq[j].top());\\n                pq[j].pop();\\n            }\\n            cout<<curr_max<<endl;\\n            ans+=curr_max;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        int n=nums.size();\\n        int m=nums[0].size();\\n        priority_queue<int>pq[n];\\n        for(int i=0;i<nums.size();i++){\\n            priority_queue<int>q;\\n            for(int j=0;j<nums[i].size();j++){\\n                q.push(nums[i][j]);\\n            }\\n            pq[i]=q;\\n        }\\n        int ans=0;\\n        for(int i=0;i<m;i++){\\n            int curr_max=0;\\n            for(int j=0;j<n;j++){\\n                curr_max=max(curr_max,pq[j].top());\\n                pq[j].pop();\\n            }\\n            cout<<curr_max<<endl;\\n            ans+=curr_max;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3655498,
                "title": "easy-c-solution-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++){\\n            sort(nums[i].begin(),nums[i].end());\\n            reverse(nums[i].begin(),nums[i].end());\\n        }\\n        for(int j=0;j<nums[0].size();j++){\\n            int ans=0;\\n            for(int i=0;i<nums.size();i++){\\n                ans=max(ans,nums[i][j]);\\n            }\\n            count+=ans;\\n        }\\n        return count;\\n    }\\n};\\n```\\nPLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F IF YOU LIKE THE SOLUTION !!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++){\\n            sort(nums[i].begin(),nums[i].end());\\n            reverse(nums[i].begin(),nums[i].end());\\n        }\\n        for(int j=0;j<nums[0].size();j++){\\n            int ans=0;\\n            for(int i=0;i<nums.size();i++){\\n                ans=max(ans,nums[i][j]);\\n            }\\n            count+=ans;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3655461,
                "title": "very-easy-solution-beginner-friendly-c-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\njust traversing the matrix and finding the max and adding to the answer after sorting each row of the matrix\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(m*n) + O(n*m*logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int row = 0;\\n\\n        int n = nums.size(); // columns\\n        int m = nums[0].size(); // rows\\n        // cout << n <<\" \"<< m << endl;\\n        int ans = 0;\\n\\n        for(int i=0;i<n;i++){\\n            sort(nums[i].begin(),nums[i].end());\\n        }\\n        \\n        while(row < m){\\n            int currmax = INT_MIN;\\n            for(int col=0;col<n;col++){\\n                currmax = max(currmax,nums[col][row]);\\n            }\\n            cout << currmax << endl;\\n            ans+=currmax;\\n            row++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int row = 0;\\n\\n        int n = nums.size(); // columns\\n        int m = nums[0].size(); // rows\\n        // cout << n <<\" \"<< m << endl;\\n        int ans = 0;\\n\\n        for(int i=0;i<n;i++){\\n            sort(nums[i].begin(),nums[i].end());\\n        }\\n        \\n        while(row < m){\\n            int currmax = INT_MIN;\\n            for(int col=0;col<n;col++){\\n                currmax = max(currmax,nums[col][row]);\\n            }\\n            cout << currmax << endl;\\n            ans+=currmax;\\n            row++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3653498,
                "title": "c-sorting-2-d-vector-best-and-simple-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int m=nums.size();\\n        int n=nums[0].size();\\n        int score=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            sort(nums[i].begin(),nums[i].end());\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            int maximum=INT_MIN;\\n            for(int j=0;j<m;j++)\\n            {\\n               if(nums[j][i]>maximum)\\n               {\\n                   maximum=nums[j][i];\\n               }\\n            }\\n            score+=maximum;\\n        }\\n      return score;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int m=nums.size();\\n        int n=nums[0].size();\\n        int score=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            sort(nums[i].begin(),nums[i].end());\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            int maximum=INT_MIN;\\n            for(int j=0;j<m;j++)\\n            {\\n               if(nums[j][i]>maximum)\\n               {\\n                   maximum=nums[j][i];\\n               }\\n            }\\n            score+=maximum;\\n        }\\n      return score;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647598,
                "title": "java-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int count=0;\\n     for(int i=0;i<nums.length;i++)\\n     {\\n         Arrays.sort(nums[i]);\\n     } \\n     \\n     for(int i=0;i<nums[0].length;i++)\\n     {\\n         int max=0;\\n         for(int j=0;j<nums.length;j++)\\n         {\\n             max=Math.max(max,nums[j][i]);\\n         }\\n         count+=max;\\n     } \\n     return count; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int count=0;\\n     for(int i=0;i<nums.length;i++)\\n     {\\n         Arrays.sort(nums[i]);\\n     } \\n     \\n     for(int i=0;i<nums[0].length;i++)\\n     {\\n         int max=0;\\n         for(int j=0;j<nums.length;j++)\\n         {\\n             max=Math.max(max,nums[j][i]);\\n         }\\n         count+=max;\\n     } \\n     return count; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3646869,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n         for(int i=0;i<nums.length;i++) {\\n            Arrays.sort(nums[i]);\\n        }\\n        int sum=0;\\n        for(int i=0;i<nums[0].length;i++){\\n            int max=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j][i]>max){\\n                    max=nums[j][i];\\n                }\\n            }\\n            sum+=max;\\n        }\\n        return sum;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n         for(int i=0;i<nums.length;i++) {\\n            Arrays.sort(nums[i]);\\n        }\\n        int sum=0;\\n        for(int i=0;i<nums[0].length;i++){\\n            int max=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j][i]>max){\\n                    max=nums[j][i];\\n                }\\n            }\\n            sum+=max;\\n        }\\n        return sum;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3646868,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n         for(int i=0;i<nums.length;i++) {\\n            Arrays.sort(nums[i]);\\n        }\\n        int sum=0;\\n        for(int i=0;i<nums[0].length;i++){\\n            int max=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j][i]>max){\\n                    max=nums[j][i];\\n                }\\n            }\\n            sum+=max;\\n        }\\n        return sum;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n         for(int i=0;i<nums.length;i++) {\\n            Arrays.sort(nums[i]);\\n        }\\n        int sum=0;\\n        for(int i=0;i<nums[0].length;i++){\\n            int max=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j][i]>max){\\n                    max=nums[j][i];\\n                }\\n            }\\n            sum+=max;\\n        }\\n        return sum;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642902,
                "title": "elegant-python-solution-that-beats-92-44",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsort the row first, then select the highest num in each column and add it to the score.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity can be analyzed as follows:\\n\\n1. Sorting each row in the matrix: For each row, the `sort()` function is `O(n log n)`, where `n` is the number of elements in the row. If there are `m` rows in the matrix, the total time complexity for this part is `O(m * n log n)`.\\n2. The `zip(*nums)` operation: This operation transposes the matrix (turns rows into columns and vice versa), which is an `O(m * n)` operation, where `m` is the number of rows and `n` is the number of columns.\\n3. Calculating the maximum of each column and adding it to the score: For each column, the `max()` function is `O(m)`, where `m` is the number of rows. Since this is done for each of the n columns, the total time complexity for this part is `O(m * n)`.\\n\\nSo, the overall time complexity of this code is `O(m * n log n)` for the sorting part plus `O(m * n)` for the transposing and summing part. Therefore, the overall time complexity is `O(m * n log n + m * n)`. If `m` and `n` are roughly equal, this simplifies to `O(n^2 log n)`, where `n` is the number of elements in a row or column.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this function is `O(m * n)`, because the `zip(*nums)` operation creates a new transposed copy of the matrix in memory. This assumes that the sorting is done in-place (which is true for Python\\'s built-in sort() function). If the matrix is very large, this could be a significant amount of space.\\n\\n# Code\\n```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        score = 0\\n\\n        for row in nums:\\n            row.sort(reverse=True)\\n        \\n        for col in zip(*nums):\\n            score += max(col)\\n\\n        return score\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        score = 0\\n\\n        for row in nums:\\n            row.sort(reverse=True)\\n        \\n        for col in zip(*nums):\\n            score += max(col)\\n\\n        return score\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642045,
                "title": "sum-in-a-matrix",
                "content": "```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        maxrow = []\\n        final_score = 0\\n        i = 0\\n        while i < len(nums[0]):\\n            maxrow.clear()\\n            for num in nums:\\n                num.sort(reverse = True)\\n                maxrow.append(num[i])\\n            final_score += max(maxrow)\\n            i += 1\\n        return final_score\\n```\\nAny doubt please ask",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        maxrow = []\\n        final_score = 0\\n        i = 0\\n        while i < len(nums[0]):\\n            maxrow.clear()\\n            for num in nums:\\n                num.sort(reverse = True)\\n                maxrow.append(num[i])\\n            final_score += max(maxrow)\\n            i += 1\\n        return final_score\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3628724,
                "title": "max-heap-java-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) { \\n      int sum=0;\\n      for(int i=0;i<nums.length;i++){\\n        Arrays.sort(nums[i]);\\n      }\\n      for(int i=0;i<nums[0].length;i++){\\n          Queue<Integer> max=new PriorityQueue<>(Collections.reverseOrder());\\n          for(int j=0;j<nums.length;j++){\\n          max.add(nums[j][i]);\\n          }\\n          sum+=max.peek();\\n      }\\n    return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) { \\n      int sum=0;\\n      for(int i=0;i<nums.length;i++){\\n        Arrays.sort(nums[i]);\\n      }\\n      for(int i=0;i<nums[0].length;i++){\\n          Queue<Integer> max=new PriorityQueue<>(Collections.reverseOrder());\\n          for(int j=0;j<nums.length;j++){\\n          max.add(nums[j][i]);\\n          }\\n          sum+=max.peek();\\n      }\\n    return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3610596,
                "title": "sort-then-add-to-score",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MatrixSum(int[][] nums) {\\n       var sum=0;\\n       var x=nums.Length;\\n       var y=nums[0].Length;\\n       for (var i=0;i<x;i++)\\n       Array.Sort(nums[i]);\\n        for(var i=0;i<y;i++)\\n        {\\n            var top=nums[0][i];\\n            for(var j=0;j<x;j++)\\n            {\\n                if(nums[j][i]>top)\\n                top=nums[j][i];\\n\\n            }\\n            sum+=top;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MatrixSum(int[][] nums) {\\n       var sum=0;\\n       var x=nums.Length;\\n       var y=nums[0].Length;\\n       for (var i=0;i<x;i++)\\n       Array.Sort(nums[i]);\\n        for(var i=0;i<y;i++)\\n        {\\n            var top=nums[0][i];\\n            for(var j=0;j<x;j++)\\n            {\\n                if(nums[j][i]>top)\\n                top=nums[j][i];\\n\\n            }\\n            sum+=top;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608050,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n       int x,sum=0;\\n       for(int i=0;i<nums.size();i++){\\n           sort(nums[i].begin(),nums[i].end());\\n       }\\n       int n=nums.size();int m=nums[0].size();\\n       for(int i=0;i<m;i++){\\n           x=0;\\n           for(int j=0;j<n;j++){\\n             x=max(x,nums[j][i]);\\n           }\\n           sum+=x;\\n       }\\n        return sum;\\n          \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n       int x,sum=0;\\n       for(int i=0;i<nums.size();i++){\\n           sort(nums[i].begin(),nums[i].end());\\n       }\\n       int n=nums.size();int m=nums[0].size();\\n       for(int i=0;i<m;i++){\\n           x=0;\\n           for(int j=0;j<n;j++){\\n             x=max(x,nums[j][i]);\\n           }\\n           sum+=x;\\n       }\\n        return sum;\\n          \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606648,
                "title": "java-sort-and-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need pick the max-value from the each row and add it up to our result; those value are not considerd further. So, if the 2D arrays is sorted, we just need to add up the max-value in each column.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. sort the 2D array\\n2. in a loop, we add up the max-value in the column. \\n        !!!Since we are comparing value in column, so the outer loop index will be the #of column, and we comparing them by the #of how many row\\n3. get the max value and add it to the result\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nrow = n; col=m\\nO(n*mlogm)[sort] + O(n*m)[for-loop] -> O(n*mlogm)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(log m) due to the recursive nature of the sorting algorithms used. \\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int result = 0;\\n\\n        for(int[] rows : nums){\\n            Arrays.sort(rows);\\n        }\\n\\n        for(int col=0; col<nums[0].length; ++col){\\n            int val = 0;\\n            for(int row=0; row<nums.length; ++row){\\n                int cur = nums[row][col];\\n                if(cur > val)\\n                    val = cur;\\n            }\\n            result += val;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int result = 0;\\n\\n        for(int[] rows : nums){\\n            Arrays.sort(rows);\\n        }\\n\\n        for(int col=0; col<nums[0].length; ++col){\\n            int val = 0;\\n            for(int row=0; row<nums.length; ++row){\\n                int cur = nums[row][col];\\n                if(cur > val)\\n                    val = cur;\\n            }\\n            result += val;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3604635,
                "title": "sum-in-a-matrix-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO (n*2logn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sort(nums[i].begin(),nums[i].end());\\n        }\\n          for(int j=0;j<nums[0].size();j++){\\n              int maxi=INT_MIN;\\n              for(int i=0;i<nums.size();i++){\\n                   if(maxi<nums[i][j]){\\n                       maxi=nums[i][j];\\n                   }\\n              }\\n              sum+=maxi;\\n          }\\n\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            sort(nums[i].begin(),nums[i].end());\\n        }\\n          for(int j=0;j<nums[0].size();j++){\\n              int maxi=INT_MIN;\\n              for(int i=0;i<nums.size();i++){\\n                   if(maxi<nums[i][j]){\\n                       maxi=nums[i][j];\\n                   }\\n              }\\n              sum+=maxi;\\n          }\\n\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3604561,
                "title": "sum-in-a-matrix",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        sun=[]\\n        sun1=0\\n        x=len(nums[0])\\n        while x>=1:\\n            for i in nums:\\n                a=max(i)\\n                sun.append(a)\\n                nums[nums.index(i)].remove(a)\\n            sun1+=max(sun)\\n            sun.clear()\\n            x-=1\\n        return sun1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        sun=[]\\n        sun1=0\\n        x=len(nums[0])\\n        while x>=1:\\n            for i in nums:\\n                a=max(i)\\n                sun.append(a)\\n                nums[nums.index(i)].remove(a)\\n            sun1+=max(sun)\\n            sun.clear()\\n            x-=1\\n        return sun1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3603629,
                "title": "java-sort-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int m = nums.length; int n = nums[0].length;\\n        for(int []row : nums ){\\n            Arrays.sort(row);\\n        }\\n        int []max = new int[n];\\n\\n        for(int i=0;i<m;i++){\\n            for(int j = 0;j<n;j++){\\n                max[j] = Math.max(max[j],nums[i][j]);\\n            }\\n        }\\n        int sum = 0;\\n        for(int e : max) sum+= e;\\n\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int m = nums.length; int n = nums[0].length;\\n        for(int []row : nums ){\\n            Arrays.sort(row);\\n        }\\n        int []max = new int[n];\\n\\n        for(int i=0;i<m;i++){\\n            for(int j = 0;j<n;j++){\\n                max[j] = Math.max(max[j],nums[i][j]);\\n            }\\n        }\\n        int sum = 0;\\n        for(int e : max) sum+= e;\\n\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3600012,
                "title": "one-line-solution",
                "content": "# Code\\n```\\nobject Solution {\\n  def matrixSum(nums: Array[Array[Int]]): Int = {\\n    nums.map(_.sorted).transpose.map(_.max).sum\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def matrixSum(nums: Array[Array[Int]]): Int = {\\n    nums.map(_.sorted).transpose.map(_.max).sum\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3599444,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n   public int matrixSum(int[][] nums) { \\n        int sum=0;\\n        int n=nums[0].length,m=nums.length;\\n        for(int i=0;i<m;i++)\\n            Arrays.sort(nums[i]);\\n        for(int j=0;j<n;j++){\\n            int t=0;\\n            for(int i=0;i<m;i++)\\n                t=Math.max(t,nums[i][j]);\\n               sum+=t;\\n        }\\n        \\n        return sum;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public int matrixSum(int[][] nums) { \\n        int sum=0;\\n        int n=nums[0].length,m=nums.length;\\n        for(int i=0;i<m;i++)\\n            Arrays.sort(nums[i]);\\n        for(int j=0;j<n;j++){\\n            int t=0;\\n            for(int i=0;i<m;i++)\\n                t=Math.max(t,nums[i][j]);\\n               sum+=t;\\n        }\\n        \\n        return sum;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598615,
                "title": "sum-in-a-matrix",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def matrixSum(self, nums):\\n        col=len(nums[0])\\n        row=len(nums)\\n        sum1=0\\n        for j in range(col):\\n            list1=[]\\n            for i in range(row):    \\n                if(len(nums[i])>0):\\n                    list1.append(max(nums[i]))\\n                nums[i].remove(max(nums[i]))\\n            if(len(list1)>0):\\n                print(list1)\\n                sum1+=max(list1)\\n        return sum1 \\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def matrixSum(self, nums):\\n        col=len(nums[0])\\n        row=len(nums)\\n        sum1=0\\n        for j in range(col):\\n            list1=[]\\n            for i in range(row):    \\n                if(len(nums[i])>0):\\n                    list1.append(max(nums[i]))\\n                nums[i].remove(max(nums[i]))\\n            if(len(list1)>0):\\n                print(list1)\\n                sum1+=max(list1)\\n        return sum1 \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597767,
                "title": "kotlin-sorting-o-m-n-log-n",
                "content": "# Approach\\nSimply sort each row, then iterate down each column\\n\\n# Complexity\\n- Time complexity:\\nIf nums contains m rows of m items\\n$$O(m * n logn)$$ to sort each row, then $$O(m * n)$$ to iterate over each column to find the max. Therefore the limiting factor is the sort and overall complexity is \\n$$O(m * n logn)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    fun matrixSum(nums: Array<IntArray>): Int {\\n        var result = 0\\n\\n        nums.forEach { row ->\\n            row.sortDescending()\\n        }\\n\\n        for (i in 0 until nums[0].size) {\\n            var max = 0\\n\\n            for (j in 0 until nums.size) {\\n                max = maxOf(max, nums[j][i])    \\n            }\\n            result += max\\n        }\\n        \\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun matrixSum(nums: Array<IntArray>): Int {\\n        var result = 0\\n\\n        nums.forEach { row ->\\n            row.sortDescending()\\n        }\\n\\n        for (i in 0 until nums[0].size) {\\n            var max = 0\\n\\n            for (j in 0 until nums.size) {\\n                max = maxOf(max, nums[j][i])    \\n            }\\n            result += max\\n        }\\n        \\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597377,
                "title": "using-vector-of-priority-queue",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing Vector of priority queue\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n**0(NMlogM)**\\ntwo loops n*m and push operation takes log(size of heap)=0(M),\\nso total NM(logm)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**0(NM)** \\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int n=nums.size();\\n        int m=nums[0].size();\\n        vector<priority_queue<int>>vq(n);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                vq[i].push(nums[i][j]);//pushing all row elements ,rowwise\\n            }\\n        }\\n        int score=0,total=0;\\n        for(int j=0;j<m;j++){\\n            score=-1;\\n            for(int i=0;i<n;i++){\\n                int t=vq[i].top(); //taking top element i.e., max elemnt of row\\n                vq[i].pop(); // remove that element\\n                score=max(score,t); //taking highest of all elements of row one by one\\n            }\\n            total+=score; //update total score\\n        }\\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int n=nums.size();\\n        int m=nums[0].size();\\n        vector<priority_queue<int>>vq(n);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                vq[i].push(nums[i][j]);//pushing all row elements ,rowwise\\n            }\\n        }\\n        int score=0,total=0;\\n        for(int j=0;j<m;j++){\\n            score=-1;\\n            for(int i=0;i<n;i++){\\n                int t=vq[i].top(); //taking top element i.e., max elemnt of row\\n                vq[i].pop(); // remove that element\\n                score=max(score,t); //taking highest of all elements of row one by one\\n            }\\n            total+=score; //update total score\\n        }\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594745,
                "title": "simplest-solution-c-99",
                "content": "# Intuition & Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn every iteration, we need to find the highest element among all the rows and add it to the score. In order to achieve that easily, we sort each rows in the matrix and in every iteration we take the highest among the ith element of each row.\\n\\n![Screenshot 2023-06-04 074039.png](https://assets.leetcode.com/users/images/ecc4ef67-44a3-4d34-b934-391ec919daf6_1685844859.9296994.png)\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N*NLogN) - as we sort N arrays\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) - as we do not use any extra memory\\n\\n## Please upvote if you like the simple approach\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MatrixSum(int[][] nums) {\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            Array.Sort(nums[i]);\\n        }\\n\\n        int score = 0;\\n        for (int j = 0; j < nums[0].Length; j++)\\n        {\\n            int max = nums[0][j];\\n            for (int i = 1; i < nums.Length; i++)\\n            {\\n                max = Math.Max(max, nums[i][j]);\\n            }\\n\\n            score += max;\\n        }\\n\\n        return score;\\n    }\\n}\\n```\\n## Please upvote if you like the simple approach\\n![Upvote please - steve.jpg](https://assets.leetcode.com/users/images/e338f844-9b25-4388-a447-044a1f6f6236_1685844958.3806489.jpeg)\\n",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Sorting",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\npublic class Solution {\\n    public int MatrixSum(int[][] nums) {\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            Array.Sort(nums[i]);\\n        }\\n\\n        int score = 0;\\n        for (int j = 0; j < nums[0].Length; j++)\\n        {\\n            int max = nums[0][j];\\n            for (int i = 1; i < nums.Length; i++)\\n            {\\n                max = Math.Max(max, nums[i][j]);\\n            }\\n\\n            score += max;\\n        }\\n\\n        return score;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594594,
                "title": "just-sort-first-pointer-o-n-m",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        res = 0\\n        m = len(nums)\\n        n = len(nums[0])\\n        j = n-1\\n        for i in range(m):\\n            nums[i].sort()\\n        \\n        for _ in range(n):\\n            mx = 0\\n            for i in range(m):\\n                \\n                mx = max(mx, nums[i][j])\\n            j -= 1\\n            res += mx\\n\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n        res = 0\\n        m = len(nums)\\n        n = len(nums[0])\\n        j = n-1\\n        for i in range(m):\\n            nums[i].sort()\\n        \\n        for _ in range(n):\\n            mx = 0\\n            for i in range(m):\\n                \\n                mx = max(mx, nums[i][j])\\n            j -= 1\\n            res += mx\\n\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594570,
                "title": "swift-one-liner",
                "content": "# Complexity\\n- Time complexity: $O(m\\\\cdot n)$\\n- Space complexity: $O(m\\\\cdot n)$\\n\\n## Code\\n```\\nclass Solution {\\n    func matrixSum(_ nums: [[Int]]) -> Int\\n    {\\n        nums[0].indices.reduce(into: (ns: nums.map{ $0.sorted(by: >) }, res: 0))\\n        {   data, j in \\n            data.res += data.ns[  data.ns.indices.max {i1, i2 in data.ns[i1][j] < data.ns[i2][j]}! ] [j]\\n        }.res\\n    }\\n}\\n```\\n## Terse Form\\n```\\n    func matrixSum(_ ns: [[Int]]) -> Int {\\n        ns[0].indices.reduce(into:(ns:ns.map{$0.sorted(by:>)},r:0)){d,j in d.r+=d.ns[d.ns.indices.max{d.ns[$0][j]<d.ns[$1][j]}!][j]}.r\\n    }\\n```",
                "solutionTags": [
                    "Swift",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    func matrixSum(_ nums: [[Int]]) -> Int\\n    {\\n        nums[0].indices.reduce(into: (ns: nums.map{ $0.sorted(by: >) }, res: 0))\\n        {   data, j in \\n            data.res += data.ns[  data.ns.indices.max {i1, i2 in data.ns[i1][j] < data.ns[i2][j]}! ] [j]\\n        }.res\\n    }\\n}\\n```\n```\\n    func matrixSum(_ ns: [[Int]]) -> Int {\\n        ns[0].indices.reduce(into:(ns:ns.map{$0.sorted(by:>)},r:0)){d,j in d.r+=d.ns[d.ns.indices.max{d.ns[$0][j]<d.ns[$1][j]}!][j]}.r\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3593460,
                "title": "easy-solution-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n\\n        temp =0\\n        maxnum = []\\n        while nums[0] != []:\\n            nums2 = []\\n            for j in range(0,len(nums)):\\n                nums2.append(max(nums[j]))\\n                nums[j].remove(max(nums[j]))\\n            maxnum.append(max(nums2))\\n        for i in maxnum:\\n            temp+=i\\n        return temp\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def matrixSum(self, nums: List[List[int]]) -> int:\\n\\n        temp =0\\n        maxnum = []\\n        while nums[0] != []:\\n            nums2 = []\\n            for j in range(0,len(nums)):\\n                nums2.append(max(nums[j]))\\n                nums[j].remove(max(nums[j]))\\n            maxnum.append(max(nums2))\\n        for i in maxnum:\\n            temp+=i\\n        return temp\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3593107,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n^2logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int n=nums.size();\\n        int m=nums[0].size();\\n        int maxglob=INT_MIN;\\n        int score=0;\\n        for(int i=0;i<n;i++){\\n            sort(nums[i].begin(),nums[i].end());\\n        }\\n        for(int j=0;j<m;j++){\\n            int mxcol=INT_MIN;\\n            for(int i=0;i<n;i++){\\n                mxcol=max(mxcol,nums[i][j]);\\n            }\\n            score+=mxcol;\\n        }\\n        return score;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int n=nums.size();\\n        int m=nums[0].size();\\n        int maxglob=INT_MIN;\\n        int score=0;\\n        for(int i=0;i<n;i++){\\n            sort(nums[i].begin(),nums[i].end());\\n        }\\n        for(int j=0;j<m;j++){\\n            int mxcol=INT_MIN;\\n            for(int i=0;i<n;i++){\\n                mxcol=max(mxcol,nums[i][j]);\\n            }\\n            score+=mxcol;\\n        }\\n        return score;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1892461,
                "content": [
                    {
                        "username": "roboto7o32oo3",
                        "content": "This problem should be marked Easy....."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "how is your dp moving??"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "This problem is same as [2500. Delete Greatest Value in Each Row](https://leetcode.com/problems/delete-greatest-value-in-each-row/)"
                    },
                    {
                        "username": "abhijay_123",
                        "content": "Why sort ?\\nand why selecting the largest value in a column fails?"
                    },
                    {
                        "username": "vinnnu",
                        "content": "[@candy45](/candy45) thanks mate "
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "[@arshikamishra](/arshikamishra) Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "[@candy45](/candy45) could you elaborate please"
                    },
                    {
                        "username": "candy45",
                        "content": "consider this case [[7,2,1],[6,1,4],[6,1,2],[3,2,1]] by taking max value in every column we will get answer as 13 but answer is 12"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "Can someone help me with my code?\\nWhy is not working ?\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        for(auto a:nums){\\n            sort(a.begin(),a.end());\\n        }\\n        int sum=0;\\n        for(int i=0;i<nums[0].size();i++){\\n            int maxi=0;\\n            for(int j=0;j<nums.size();j++){\\n                maxi=max(nums[j][i],maxi);\\n            }\\n            sum+=maxi;\\n        }\\n        return sum;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "avinash3300",
                        "content": "you want to write in for loop\\nfor(auto &a : nums){\\n            sort(a.begin(),a.end());\\n        }\\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@BadalArya](/BadalArya)  thanks bro \\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@Ankur_0152](/Ankur_0152)  Thanks bro\\n"
                    },
                    {
                        "username": "Ankur_0152",
                        "content": "either use \n        for(auto &a:nums)\n            sort(a.begin(),a.end());\nor \n       for(int i=0;i<nums.size();i++)\n           sort(nums[i].begin(),nums[i].end());\n        "
                    },
                    {
                        "username": "BadalArya",
                        "content": "for(auto &a : nums)\\n\\nYou need to use for each loop with address or it won\\'t sort the array"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "even i come up with the same sol, i don't understand sorting of rows req. did they ask in question ? "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n- Initialize the score to 0 and a variable called total to 0.\\n- While total is less than the total number of elements in the matrix:\\n- Create a priority queue to store the largest numbers from each row.\\n- For each row in the matrix, find the largest number that hasn\\'t been removed yet (i.e., its value is not -1), and add it to the priority queue.\\n- Remove the largest number from the priority queue and add it to the score.\\n- Mark the location of the removed number in the matrix by setting its value to -1.\\n- Increment the total variable to keep track of how many elements have been removed.\\n- Return the final score."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link :-)***\\nhttps://leetcode.com/problems/sum-in-a-matrix/solutions/3524127/easiest-solution-priorityqueue/"
                    },
                    {
                        "username": "Balwierz",
                        "content": "Identical to https://leetcode.com/problems/delete-greatest-value-in-each-row/"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Why does this code pass only 116/1057 test cases \\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int score =0;\\n        priority_queue<int> pq;\\n        for(int j=0;j<nums[0].size();j++){\\n            for(int i=0;i<nums.size();i++){\\n                pq.push(nums[i][j]);\\n            }\\n            score += pq.top();\\n            while(!pq.empty()){\\n                pq.pop();\\n            }\\n        }\\n        return score;\\n    }\\n};"
                    },
                    {
                        "username": "Nazar2020",
                        "content": "Matrix row can be sorted asc or desc, it doesn\\'t matter"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "for me wheneve I try to iterate rows and column runtime error for no reason like even I used n = nums.size() and m = nums[0].size() still it says runtime but while 14 and 13 numbers it works what is wrong"
                    },
                    {
                        "username": "hacker363",
                        "content": "```class Solution:\n    def matrixSum(self, nums: List[List[int]]) -> int:\n        i = 0\n        ans = 0\n        while i<len(nums[0]):\n            l = sorted(nums, key=lambda x :x[i])[::-1]\n            ans+=l[0][i]\n            i+=1\n        return ans\n```\n\nCan anyone please tell me why my code only passes 116 testcases rather than all....\nPlease address the mistake I have made.\nif it finds helpful please upvote\n"
                    }
                ]
            },
            {
                "id": 1892785,
                "content": [
                    {
                        "username": "roboto7o32oo3",
                        "content": "This problem should be marked Easy....."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "how is your dp moving??"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "This problem is same as [2500. Delete Greatest Value in Each Row](https://leetcode.com/problems/delete-greatest-value-in-each-row/)"
                    },
                    {
                        "username": "abhijay_123",
                        "content": "Why sort ?\\nand why selecting the largest value in a column fails?"
                    },
                    {
                        "username": "vinnnu",
                        "content": "[@candy45](/candy45) thanks mate "
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "[@arshikamishra](/arshikamishra) Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "[@candy45](/candy45) could you elaborate please"
                    },
                    {
                        "username": "candy45",
                        "content": "consider this case [[7,2,1],[6,1,4],[6,1,2],[3,2,1]] by taking max value in every column we will get answer as 13 but answer is 12"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "Can someone help me with my code?\\nWhy is not working ?\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        for(auto a:nums){\\n            sort(a.begin(),a.end());\\n        }\\n        int sum=0;\\n        for(int i=0;i<nums[0].size();i++){\\n            int maxi=0;\\n            for(int j=0;j<nums.size();j++){\\n                maxi=max(nums[j][i],maxi);\\n            }\\n            sum+=maxi;\\n        }\\n        return sum;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "avinash3300",
                        "content": "you want to write in for loop\\nfor(auto &a : nums){\\n            sort(a.begin(),a.end());\\n        }\\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@BadalArya](/BadalArya)  thanks bro \\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@Ankur_0152](/Ankur_0152)  Thanks bro\\n"
                    },
                    {
                        "username": "Ankur_0152",
                        "content": "either use \n        for(auto &a:nums)\n            sort(a.begin(),a.end());\nor \n       for(int i=0;i<nums.size();i++)\n           sort(nums[i].begin(),nums[i].end());\n        "
                    },
                    {
                        "username": "BadalArya",
                        "content": "for(auto &a : nums)\\n\\nYou need to use for each loop with address or it won\\'t sort the array"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "even i come up with the same sol, i don't understand sorting of rows req. did they ask in question ? "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n- Initialize the score to 0 and a variable called total to 0.\\n- While total is less than the total number of elements in the matrix:\\n- Create a priority queue to store the largest numbers from each row.\\n- For each row in the matrix, find the largest number that hasn\\'t been removed yet (i.e., its value is not -1), and add it to the priority queue.\\n- Remove the largest number from the priority queue and add it to the score.\\n- Mark the location of the removed number in the matrix by setting its value to -1.\\n- Increment the total variable to keep track of how many elements have been removed.\\n- Return the final score."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link :-)***\\nhttps://leetcode.com/problems/sum-in-a-matrix/solutions/3524127/easiest-solution-priorityqueue/"
                    },
                    {
                        "username": "Balwierz",
                        "content": "Identical to https://leetcode.com/problems/delete-greatest-value-in-each-row/"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Why does this code pass only 116/1057 test cases \\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int score =0;\\n        priority_queue<int> pq;\\n        for(int j=0;j<nums[0].size();j++){\\n            for(int i=0;i<nums.size();i++){\\n                pq.push(nums[i][j]);\\n            }\\n            score += pq.top();\\n            while(!pq.empty()){\\n                pq.pop();\\n            }\\n        }\\n        return score;\\n    }\\n};"
                    },
                    {
                        "username": "Nazar2020",
                        "content": "Matrix row can be sorted asc or desc, it doesn\\'t matter"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "for me wheneve I try to iterate rows and column runtime error for no reason like even I used n = nums.size() and m = nums[0].size() still it says runtime but while 14 and 13 numbers it works what is wrong"
                    },
                    {
                        "username": "hacker363",
                        "content": "```class Solution:\n    def matrixSum(self, nums: List[List[int]]) -> int:\n        i = 0\n        ans = 0\n        while i<len(nums[0]):\n            l = sorted(nums, key=lambda x :x[i])[::-1]\n            ans+=l[0][i]\n            i+=1\n        return ans\n```\n\nCan anyone please tell me why my code only passes 116 testcases rather than all....\nPlease address the mistake I have made.\nif it finds helpful please upvote\n"
                    }
                ]
            },
            {
                "id": 1892799,
                "content": [
                    {
                        "username": "roboto7o32oo3",
                        "content": "This problem should be marked Easy....."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "how is your dp moving??"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "This problem is same as [2500. Delete Greatest Value in Each Row](https://leetcode.com/problems/delete-greatest-value-in-each-row/)"
                    },
                    {
                        "username": "abhijay_123",
                        "content": "Why sort ?\\nand why selecting the largest value in a column fails?"
                    },
                    {
                        "username": "vinnnu",
                        "content": "[@candy45](/candy45) thanks mate "
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "[@arshikamishra](/arshikamishra) Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "[@candy45](/candy45) could you elaborate please"
                    },
                    {
                        "username": "candy45",
                        "content": "consider this case [[7,2,1],[6,1,4],[6,1,2],[3,2,1]] by taking max value in every column we will get answer as 13 but answer is 12"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "Can someone help me with my code?\\nWhy is not working ?\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        for(auto a:nums){\\n            sort(a.begin(),a.end());\\n        }\\n        int sum=0;\\n        for(int i=0;i<nums[0].size();i++){\\n            int maxi=0;\\n            for(int j=0;j<nums.size();j++){\\n                maxi=max(nums[j][i],maxi);\\n            }\\n            sum+=maxi;\\n        }\\n        return sum;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "avinash3300",
                        "content": "you want to write in for loop\\nfor(auto &a : nums){\\n            sort(a.begin(),a.end());\\n        }\\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@BadalArya](/BadalArya)  thanks bro \\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@Ankur_0152](/Ankur_0152)  Thanks bro\\n"
                    },
                    {
                        "username": "Ankur_0152",
                        "content": "either use \n        for(auto &a:nums)\n            sort(a.begin(),a.end());\nor \n       for(int i=0;i<nums.size();i++)\n           sort(nums[i].begin(),nums[i].end());\n        "
                    },
                    {
                        "username": "BadalArya",
                        "content": "for(auto &a : nums)\\n\\nYou need to use for each loop with address or it won\\'t sort the array"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "even i come up with the same sol, i don't understand sorting of rows req. did they ask in question ? "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n- Initialize the score to 0 and a variable called total to 0.\\n- While total is less than the total number of elements in the matrix:\\n- Create a priority queue to store the largest numbers from each row.\\n- For each row in the matrix, find the largest number that hasn\\'t been removed yet (i.e., its value is not -1), and add it to the priority queue.\\n- Remove the largest number from the priority queue and add it to the score.\\n- Mark the location of the removed number in the matrix by setting its value to -1.\\n- Increment the total variable to keep track of how many elements have been removed.\\n- Return the final score."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link :-)***\\nhttps://leetcode.com/problems/sum-in-a-matrix/solutions/3524127/easiest-solution-priorityqueue/"
                    },
                    {
                        "username": "Balwierz",
                        "content": "Identical to https://leetcode.com/problems/delete-greatest-value-in-each-row/"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Why does this code pass only 116/1057 test cases \\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int score =0;\\n        priority_queue<int> pq;\\n        for(int j=0;j<nums[0].size();j++){\\n            for(int i=0;i<nums.size();i++){\\n                pq.push(nums[i][j]);\\n            }\\n            score += pq.top();\\n            while(!pq.empty()){\\n                pq.pop();\\n            }\\n        }\\n        return score;\\n    }\\n};"
                    },
                    {
                        "username": "Nazar2020",
                        "content": "Matrix row can be sorted asc or desc, it doesn\\'t matter"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "for me wheneve I try to iterate rows and column runtime error for no reason like even I used n = nums.size() and m = nums[0].size() still it says runtime but while 14 and 13 numbers it works what is wrong"
                    },
                    {
                        "username": "hacker363",
                        "content": "```class Solution:\n    def matrixSum(self, nums: List[List[int]]) -> int:\n        i = 0\n        ans = 0\n        while i<len(nums[0]):\n            l = sorted(nums, key=lambda x :x[i])[::-1]\n            ans+=l[0][i]\n            i+=1\n        return ans\n```\n\nCan anyone please tell me why my code only passes 116 testcases rather than all....\nPlease address the mistake I have made.\nif it finds helpful please upvote\n"
                    }
                ]
            },
            {
                "id": 1892459,
                "content": [
                    {
                        "username": "roboto7o32oo3",
                        "content": "This problem should be marked Easy....."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "how is your dp moving??"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "This problem is same as [2500. Delete Greatest Value in Each Row](https://leetcode.com/problems/delete-greatest-value-in-each-row/)"
                    },
                    {
                        "username": "abhijay_123",
                        "content": "Why sort ?\\nand why selecting the largest value in a column fails?"
                    },
                    {
                        "username": "vinnnu",
                        "content": "[@candy45](/candy45) thanks mate "
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "[@arshikamishra](/arshikamishra) Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "[@candy45](/candy45) could you elaborate please"
                    },
                    {
                        "username": "candy45",
                        "content": "consider this case [[7,2,1],[6,1,4],[6,1,2],[3,2,1]] by taking max value in every column we will get answer as 13 but answer is 12"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "Can someone help me with my code?\\nWhy is not working ?\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        for(auto a:nums){\\n            sort(a.begin(),a.end());\\n        }\\n        int sum=0;\\n        for(int i=0;i<nums[0].size();i++){\\n            int maxi=0;\\n            for(int j=0;j<nums.size();j++){\\n                maxi=max(nums[j][i],maxi);\\n            }\\n            sum+=maxi;\\n        }\\n        return sum;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "avinash3300",
                        "content": "you want to write in for loop\\nfor(auto &a : nums){\\n            sort(a.begin(),a.end());\\n        }\\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@BadalArya](/BadalArya)  thanks bro \\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@Ankur_0152](/Ankur_0152)  Thanks bro\\n"
                    },
                    {
                        "username": "Ankur_0152",
                        "content": "either use \n        for(auto &a:nums)\n            sort(a.begin(),a.end());\nor \n       for(int i=0;i<nums.size();i++)\n           sort(nums[i].begin(),nums[i].end());\n        "
                    },
                    {
                        "username": "BadalArya",
                        "content": "for(auto &a : nums)\\n\\nYou need to use for each loop with address or it won\\'t sort the array"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "even i come up with the same sol, i don't understand sorting of rows req. did they ask in question ? "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n- Initialize the score to 0 and a variable called total to 0.\\n- While total is less than the total number of elements in the matrix:\\n- Create a priority queue to store the largest numbers from each row.\\n- For each row in the matrix, find the largest number that hasn\\'t been removed yet (i.e., its value is not -1), and add it to the priority queue.\\n- Remove the largest number from the priority queue and add it to the score.\\n- Mark the location of the removed number in the matrix by setting its value to -1.\\n- Increment the total variable to keep track of how many elements have been removed.\\n- Return the final score."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link :-)***\\nhttps://leetcode.com/problems/sum-in-a-matrix/solutions/3524127/easiest-solution-priorityqueue/"
                    },
                    {
                        "username": "Balwierz",
                        "content": "Identical to https://leetcode.com/problems/delete-greatest-value-in-each-row/"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Why does this code pass only 116/1057 test cases \\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int score =0;\\n        priority_queue<int> pq;\\n        for(int j=0;j<nums[0].size();j++){\\n            for(int i=0;i<nums.size();i++){\\n                pq.push(nums[i][j]);\\n            }\\n            score += pq.top();\\n            while(!pq.empty()){\\n                pq.pop();\\n            }\\n        }\\n        return score;\\n    }\\n};"
                    },
                    {
                        "username": "Nazar2020",
                        "content": "Matrix row can be sorted asc or desc, it doesn\\'t matter"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "for me wheneve I try to iterate rows and column runtime error for no reason like even I used n = nums.size() and m = nums[0].size() still it says runtime but while 14 and 13 numbers it works what is wrong"
                    },
                    {
                        "username": "hacker363",
                        "content": "```class Solution:\n    def matrixSum(self, nums: List[List[int]]) -> int:\n        i = 0\n        ans = 0\n        while i<len(nums[0]):\n            l = sorted(nums, key=lambda x :x[i])[::-1]\n            ans+=l[0][i]\n            i+=1\n        return ans\n```\n\nCan anyone please tell me why my code only passes 116 testcases rather than all....\nPlease address the mistake I have made.\nif it finds helpful please upvote\n"
                    }
                ]
            },
            {
                "id": 1893910,
                "content": [
                    {
                        "username": "roboto7o32oo3",
                        "content": "This problem should be marked Easy....."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "how is your dp moving??"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "This problem is same as [2500. Delete Greatest Value in Each Row](https://leetcode.com/problems/delete-greatest-value-in-each-row/)"
                    },
                    {
                        "username": "abhijay_123",
                        "content": "Why sort ?\\nand why selecting the largest value in a column fails?"
                    },
                    {
                        "username": "vinnnu",
                        "content": "[@candy45](/candy45) thanks mate "
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "[@arshikamishra](/arshikamishra) Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "[@candy45](/candy45) could you elaborate please"
                    },
                    {
                        "username": "candy45",
                        "content": "consider this case [[7,2,1],[6,1,4],[6,1,2],[3,2,1]] by taking max value in every column we will get answer as 13 but answer is 12"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "Can someone help me with my code?\\nWhy is not working ?\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        for(auto a:nums){\\n            sort(a.begin(),a.end());\\n        }\\n        int sum=0;\\n        for(int i=0;i<nums[0].size();i++){\\n            int maxi=0;\\n            for(int j=0;j<nums.size();j++){\\n                maxi=max(nums[j][i],maxi);\\n            }\\n            sum+=maxi;\\n        }\\n        return sum;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "avinash3300",
                        "content": "you want to write in for loop\\nfor(auto &a : nums){\\n            sort(a.begin(),a.end());\\n        }\\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@BadalArya](/BadalArya)  thanks bro \\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@Ankur_0152](/Ankur_0152)  Thanks bro\\n"
                    },
                    {
                        "username": "Ankur_0152",
                        "content": "either use \n        for(auto &a:nums)\n            sort(a.begin(),a.end());\nor \n       for(int i=0;i<nums.size();i++)\n           sort(nums[i].begin(),nums[i].end());\n        "
                    },
                    {
                        "username": "BadalArya",
                        "content": "for(auto &a : nums)\\n\\nYou need to use for each loop with address or it won\\'t sort the array"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "even i come up with the same sol, i don't understand sorting of rows req. did they ask in question ? "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n- Initialize the score to 0 and a variable called total to 0.\\n- While total is less than the total number of elements in the matrix:\\n- Create a priority queue to store the largest numbers from each row.\\n- For each row in the matrix, find the largest number that hasn\\'t been removed yet (i.e., its value is not -1), and add it to the priority queue.\\n- Remove the largest number from the priority queue and add it to the score.\\n- Mark the location of the removed number in the matrix by setting its value to -1.\\n- Increment the total variable to keep track of how many elements have been removed.\\n- Return the final score."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link :-)***\\nhttps://leetcode.com/problems/sum-in-a-matrix/solutions/3524127/easiest-solution-priorityqueue/"
                    },
                    {
                        "username": "Balwierz",
                        "content": "Identical to https://leetcode.com/problems/delete-greatest-value-in-each-row/"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Why does this code pass only 116/1057 test cases \\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int score =0;\\n        priority_queue<int> pq;\\n        for(int j=0;j<nums[0].size();j++){\\n            for(int i=0;i<nums.size();i++){\\n                pq.push(nums[i][j]);\\n            }\\n            score += pq.top();\\n            while(!pq.empty()){\\n                pq.pop();\\n            }\\n        }\\n        return score;\\n    }\\n};"
                    },
                    {
                        "username": "Nazar2020",
                        "content": "Matrix row can be sorted asc or desc, it doesn\\'t matter"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "for me wheneve I try to iterate rows and column runtime error for no reason like even I used n = nums.size() and m = nums[0].size() still it says runtime but while 14 and 13 numbers it works what is wrong"
                    },
                    {
                        "username": "hacker363",
                        "content": "```class Solution:\n    def matrixSum(self, nums: List[List[int]]) -> int:\n        i = 0\n        ans = 0\n        while i<len(nums[0]):\n            l = sorted(nums, key=lambda x :x[i])[::-1]\n            ans+=l[0][i]\n            i+=1\n        return ans\n```\n\nCan anyone please tell me why my code only passes 116 testcases rather than all....\nPlease address the mistake I have made.\nif it finds helpful please upvote\n"
                    }
                ]
            },
            {
                "id": 1893821,
                "content": [
                    {
                        "username": "roboto7o32oo3",
                        "content": "This problem should be marked Easy....."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "how is your dp moving??"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "This problem is same as [2500. Delete Greatest Value in Each Row](https://leetcode.com/problems/delete-greatest-value-in-each-row/)"
                    },
                    {
                        "username": "abhijay_123",
                        "content": "Why sort ?\\nand why selecting the largest value in a column fails?"
                    },
                    {
                        "username": "vinnnu",
                        "content": "[@candy45](/candy45) thanks mate "
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "[@arshikamishra](/arshikamishra) Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "[@candy45](/candy45) could you elaborate please"
                    },
                    {
                        "username": "candy45",
                        "content": "consider this case [[7,2,1],[6,1,4],[6,1,2],[3,2,1]] by taking max value in every column we will get answer as 13 but answer is 12"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "Can someone help me with my code?\\nWhy is not working ?\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        for(auto a:nums){\\n            sort(a.begin(),a.end());\\n        }\\n        int sum=0;\\n        for(int i=0;i<nums[0].size();i++){\\n            int maxi=0;\\n            for(int j=0;j<nums.size();j++){\\n                maxi=max(nums[j][i],maxi);\\n            }\\n            sum+=maxi;\\n        }\\n        return sum;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "avinash3300",
                        "content": "you want to write in for loop\\nfor(auto &a : nums){\\n            sort(a.begin(),a.end());\\n        }\\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@BadalArya](/BadalArya)  thanks bro \\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@Ankur_0152](/Ankur_0152)  Thanks bro\\n"
                    },
                    {
                        "username": "Ankur_0152",
                        "content": "either use \n        for(auto &a:nums)\n            sort(a.begin(),a.end());\nor \n       for(int i=0;i<nums.size();i++)\n           sort(nums[i].begin(),nums[i].end());\n        "
                    },
                    {
                        "username": "BadalArya",
                        "content": "for(auto &a : nums)\\n\\nYou need to use for each loop with address or it won\\'t sort the array"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "even i come up with the same sol, i don't understand sorting of rows req. did they ask in question ? "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n- Initialize the score to 0 and a variable called total to 0.\\n- While total is less than the total number of elements in the matrix:\\n- Create a priority queue to store the largest numbers from each row.\\n- For each row in the matrix, find the largest number that hasn\\'t been removed yet (i.e., its value is not -1), and add it to the priority queue.\\n- Remove the largest number from the priority queue and add it to the score.\\n- Mark the location of the removed number in the matrix by setting its value to -1.\\n- Increment the total variable to keep track of how many elements have been removed.\\n- Return the final score."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link :-)***\\nhttps://leetcode.com/problems/sum-in-a-matrix/solutions/3524127/easiest-solution-priorityqueue/"
                    },
                    {
                        "username": "Balwierz",
                        "content": "Identical to https://leetcode.com/problems/delete-greatest-value-in-each-row/"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Why does this code pass only 116/1057 test cases \\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int score =0;\\n        priority_queue<int> pq;\\n        for(int j=0;j<nums[0].size();j++){\\n            for(int i=0;i<nums.size();i++){\\n                pq.push(nums[i][j]);\\n            }\\n            score += pq.top();\\n            while(!pq.empty()){\\n                pq.pop();\\n            }\\n        }\\n        return score;\\n    }\\n};"
                    },
                    {
                        "username": "Nazar2020",
                        "content": "Matrix row can be sorted asc or desc, it doesn\\'t matter"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "for me wheneve I try to iterate rows and column runtime error for no reason like even I used n = nums.size() and m = nums[0].size() still it says runtime but while 14 and 13 numbers it works what is wrong"
                    },
                    {
                        "username": "hacker363",
                        "content": "```class Solution:\n    def matrixSum(self, nums: List[List[int]]) -> int:\n        i = 0\n        ans = 0\n        while i<len(nums[0]):\n            l = sorted(nums, key=lambda x :x[i])[::-1]\n            ans+=l[0][i]\n            i+=1\n        return ans\n```\n\nCan anyone please tell me why my code only passes 116 testcases rather than all....\nPlease address the mistake I have made.\nif it finds helpful please upvote\n"
                    }
                ]
            },
            {
                "id": 2046752,
                "content": [
                    {
                        "username": "roboto7o32oo3",
                        "content": "This problem should be marked Easy....."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "how is your dp moving??"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "This problem is same as [2500. Delete Greatest Value in Each Row](https://leetcode.com/problems/delete-greatest-value-in-each-row/)"
                    },
                    {
                        "username": "abhijay_123",
                        "content": "Why sort ?\\nand why selecting the largest value in a column fails?"
                    },
                    {
                        "username": "vinnnu",
                        "content": "[@candy45](/candy45) thanks mate "
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "[@arshikamishra](/arshikamishra) Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "[@candy45](/candy45) could you elaborate please"
                    },
                    {
                        "username": "candy45",
                        "content": "consider this case [[7,2,1],[6,1,4],[6,1,2],[3,2,1]] by taking max value in every column we will get answer as 13 but answer is 12"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "Can someone help me with my code?\\nWhy is not working ?\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        for(auto a:nums){\\n            sort(a.begin(),a.end());\\n        }\\n        int sum=0;\\n        for(int i=0;i<nums[0].size();i++){\\n            int maxi=0;\\n            for(int j=0;j<nums.size();j++){\\n                maxi=max(nums[j][i],maxi);\\n            }\\n            sum+=maxi;\\n        }\\n        return sum;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "avinash3300",
                        "content": "you want to write in for loop\\nfor(auto &a : nums){\\n            sort(a.begin(),a.end());\\n        }\\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@BadalArya](/BadalArya)  thanks bro \\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@Ankur_0152](/Ankur_0152)  Thanks bro\\n"
                    },
                    {
                        "username": "Ankur_0152",
                        "content": "either use \n        for(auto &a:nums)\n            sort(a.begin(),a.end());\nor \n       for(int i=0;i<nums.size();i++)\n           sort(nums[i].begin(),nums[i].end());\n        "
                    },
                    {
                        "username": "BadalArya",
                        "content": "for(auto &a : nums)\\n\\nYou need to use for each loop with address or it won\\'t sort the array"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "even i come up with the same sol, i don't understand sorting of rows req. did they ask in question ? "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n- Initialize the score to 0 and a variable called total to 0.\\n- While total is less than the total number of elements in the matrix:\\n- Create a priority queue to store the largest numbers from each row.\\n- For each row in the matrix, find the largest number that hasn\\'t been removed yet (i.e., its value is not -1), and add it to the priority queue.\\n- Remove the largest number from the priority queue and add it to the score.\\n- Mark the location of the removed number in the matrix by setting its value to -1.\\n- Increment the total variable to keep track of how many elements have been removed.\\n- Return the final score."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link :-)***\\nhttps://leetcode.com/problems/sum-in-a-matrix/solutions/3524127/easiest-solution-priorityqueue/"
                    },
                    {
                        "username": "Balwierz",
                        "content": "Identical to https://leetcode.com/problems/delete-greatest-value-in-each-row/"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Why does this code pass only 116/1057 test cases \\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int score =0;\\n        priority_queue<int> pq;\\n        for(int j=0;j<nums[0].size();j++){\\n            for(int i=0;i<nums.size();i++){\\n                pq.push(nums[i][j]);\\n            }\\n            score += pq.top();\\n            while(!pq.empty()){\\n                pq.pop();\\n            }\\n        }\\n        return score;\\n    }\\n};"
                    },
                    {
                        "username": "Nazar2020",
                        "content": "Matrix row can be sorted asc or desc, it doesn\\'t matter"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "for me wheneve I try to iterate rows and column runtime error for no reason like even I used n = nums.size() and m = nums[0].size() still it says runtime but while 14 and 13 numbers it works what is wrong"
                    },
                    {
                        "username": "hacker363",
                        "content": "```class Solution:\n    def matrixSum(self, nums: List[List[int]]) -> int:\n        i = 0\n        ans = 0\n        while i<len(nums[0]):\n            l = sorted(nums, key=lambda x :x[i])[::-1]\n            ans+=l[0][i]\n            i+=1\n        return ans\n```\n\nCan anyone please tell me why my code only passes 116 testcases rather than all....\nPlease address the mistake I have made.\nif it finds helpful please upvote\n"
                    }
                ]
            },
            {
                "id": 2037216,
                "content": [
                    {
                        "username": "roboto7o32oo3",
                        "content": "This problem should be marked Easy....."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "how is your dp moving??"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "This problem is same as [2500. Delete Greatest Value in Each Row](https://leetcode.com/problems/delete-greatest-value-in-each-row/)"
                    },
                    {
                        "username": "abhijay_123",
                        "content": "Why sort ?\\nand why selecting the largest value in a column fails?"
                    },
                    {
                        "username": "vinnnu",
                        "content": "[@candy45](/candy45) thanks mate "
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "[@arshikamishra](/arshikamishra) Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "[@candy45](/candy45) could you elaborate please"
                    },
                    {
                        "username": "candy45",
                        "content": "consider this case [[7,2,1],[6,1,4],[6,1,2],[3,2,1]] by taking max value in every column we will get answer as 13 but answer is 12"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "Can someone help me with my code?\\nWhy is not working ?\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        for(auto a:nums){\\n            sort(a.begin(),a.end());\\n        }\\n        int sum=0;\\n        for(int i=0;i<nums[0].size();i++){\\n            int maxi=0;\\n            for(int j=0;j<nums.size();j++){\\n                maxi=max(nums[j][i],maxi);\\n            }\\n            sum+=maxi;\\n        }\\n        return sum;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "avinash3300",
                        "content": "you want to write in for loop\\nfor(auto &a : nums){\\n            sort(a.begin(),a.end());\\n        }\\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@BadalArya](/BadalArya)  thanks bro \\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@Ankur_0152](/Ankur_0152)  Thanks bro\\n"
                    },
                    {
                        "username": "Ankur_0152",
                        "content": "either use \n        for(auto &a:nums)\n            sort(a.begin(),a.end());\nor \n       for(int i=0;i<nums.size();i++)\n           sort(nums[i].begin(),nums[i].end());\n        "
                    },
                    {
                        "username": "BadalArya",
                        "content": "for(auto &a : nums)\\n\\nYou need to use for each loop with address or it won\\'t sort the array"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "even i come up with the same sol, i don't understand sorting of rows req. did they ask in question ? "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n- Initialize the score to 0 and a variable called total to 0.\\n- While total is less than the total number of elements in the matrix:\\n- Create a priority queue to store the largest numbers from each row.\\n- For each row in the matrix, find the largest number that hasn\\'t been removed yet (i.e., its value is not -1), and add it to the priority queue.\\n- Remove the largest number from the priority queue and add it to the score.\\n- Mark the location of the removed number in the matrix by setting its value to -1.\\n- Increment the total variable to keep track of how many elements have been removed.\\n- Return the final score."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link :-)***\\nhttps://leetcode.com/problems/sum-in-a-matrix/solutions/3524127/easiest-solution-priorityqueue/"
                    },
                    {
                        "username": "Balwierz",
                        "content": "Identical to https://leetcode.com/problems/delete-greatest-value-in-each-row/"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Why does this code pass only 116/1057 test cases \\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int score =0;\\n        priority_queue<int> pq;\\n        for(int j=0;j<nums[0].size();j++){\\n            for(int i=0;i<nums.size();i++){\\n                pq.push(nums[i][j]);\\n            }\\n            score += pq.top();\\n            while(!pq.empty()){\\n                pq.pop();\\n            }\\n        }\\n        return score;\\n    }\\n};"
                    },
                    {
                        "username": "Nazar2020",
                        "content": "Matrix row can be sorted asc or desc, it doesn\\'t matter"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "for me wheneve I try to iterate rows and column runtime error for no reason like even I used n = nums.size() and m = nums[0].size() still it says runtime but while 14 and 13 numbers it works what is wrong"
                    },
                    {
                        "username": "hacker363",
                        "content": "```class Solution:\n    def matrixSum(self, nums: List[List[int]]) -> int:\n        i = 0\n        ans = 0\n        while i<len(nums[0]):\n            l = sorted(nums, key=lambda x :x[i])[::-1]\n            ans+=l[0][i]\n            i+=1\n        return ans\n```\n\nCan anyone please tell me why my code only passes 116 testcases rather than all....\nPlease address the mistake I have made.\nif it finds helpful please upvote\n"
                    }
                ]
            },
            {
                "id": 1990741,
                "content": [
                    {
                        "username": "roboto7o32oo3",
                        "content": "This problem should be marked Easy....."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "how is your dp moving??"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "This problem is same as [2500. Delete Greatest Value in Each Row](https://leetcode.com/problems/delete-greatest-value-in-each-row/)"
                    },
                    {
                        "username": "abhijay_123",
                        "content": "Why sort ?\\nand why selecting the largest value in a column fails?"
                    },
                    {
                        "username": "vinnnu",
                        "content": "[@candy45](/candy45) thanks mate "
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "[@arshikamishra](/arshikamishra) Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "[@candy45](/candy45) could you elaborate please"
                    },
                    {
                        "username": "candy45",
                        "content": "consider this case [[7,2,1],[6,1,4],[6,1,2],[3,2,1]] by taking max value in every column we will get answer as 13 but answer is 12"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "Can someone help me with my code?\\nWhy is not working ?\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        for(auto a:nums){\\n            sort(a.begin(),a.end());\\n        }\\n        int sum=0;\\n        for(int i=0;i<nums[0].size();i++){\\n            int maxi=0;\\n            for(int j=0;j<nums.size();j++){\\n                maxi=max(nums[j][i],maxi);\\n            }\\n            sum+=maxi;\\n        }\\n        return sum;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "avinash3300",
                        "content": "you want to write in for loop\\nfor(auto &a : nums){\\n            sort(a.begin(),a.end());\\n        }\\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@BadalArya](/BadalArya)  thanks bro \\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@Ankur_0152](/Ankur_0152)  Thanks bro\\n"
                    },
                    {
                        "username": "Ankur_0152",
                        "content": "either use \n        for(auto &a:nums)\n            sort(a.begin(),a.end());\nor \n       for(int i=0;i<nums.size();i++)\n           sort(nums[i].begin(),nums[i].end());\n        "
                    },
                    {
                        "username": "BadalArya",
                        "content": "for(auto &a : nums)\\n\\nYou need to use for each loop with address or it won\\'t sort the array"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "even i come up with the same sol, i don't understand sorting of rows req. did they ask in question ? "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n- Initialize the score to 0 and a variable called total to 0.\\n- While total is less than the total number of elements in the matrix:\\n- Create a priority queue to store the largest numbers from each row.\\n- For each row in the matrix, find the largest number that hasn\\'t been removed yet (i.e., its value is not -1), and add it to the priority queue.\\n- Remove the largest number from the priority queue and add it to the score.\\n- Mark the location of the removed number in the matrix by setting its value to -1.\\n- Increment the total variable to keep track of how many elements have been removed.\\n- Return the final score."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link :-)***\\nhttps://leetcode.com/problems/sum-in-a-matrix/solutions/3524127/easiest-solution-priorityqueue/"
                    },
                    {
                        "username": "Balwierz",
                        "content": "Identical to https://leetcode.com/problems/delete-greatest-value-in-each-row/"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Why does this code pass only 116/1057 test cases \\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int score =0;\\n        priority_queue<int> pq;\\n        for(int j=0;j<nums[0].size();j++){\\n            for(int i=0;i<nums.size();i++){\\n                pq.push(nums[i][j]);\\n            }\\n            score += pq.top();\\n            while(!pq.empty()){\\n                pq.pop();\\n            }\\n        }\\n        return score;\\n    }\\n};"
                    },
                    {
                        "username": "Nazar2020",
                        "content": "Matrix row can be sorted asc or desc, it doesn\\'t matter"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "for me wheneve I try to iterate rows and column runtime error for no reason like even I used n = nums.size() and m = nums[0].size() still it says runtime but while 14 and 13 numbers it works what is wrong"
                    },
                    {
                        "username": "hacker363",
                        "content": "```class Solution:\n    def matrixSum(self, nums: List[List[int]]) -> int:\n        i = 0\n        ans = 0\n        while i<len(nums[0]):\n            l = sorted(nums, key=lambda x :x[i])[::-1]\n            ans+=l[0][i]\n            i+=1\n        return ans\n```\n\nCan anyone please tell me why my code only passes 116 testcases rather than all....\nPlease address the mistake I have made.\nif it finds helpful please upvote\n"
                    }
                ]
            },
            {
                "id": 1989259,
                "content": [
                    {
                        "username": "roboto7o32oo3",
                        "content": "This problem should be marked Easy....."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "how is your dp moving??"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "This problem is same as [2500. Delete Greatest Value in Each Row](https://leetcode.com/problems/delete-greatest-value-in-each-row/)"
                    },
                    {
                        "username": "abhijay_123",
                        "content": "Why sort ?\\nand why selecting the largest value in a column fails?"
                    },
                    {
                        "username": "vinnnu",
                        "content": "[@candy45](/candy45) thanks mate "
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "[@arshikamishra](/arshikamishra) Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "[@candy45](/candy45) could you elaborate please"
                    },
                    {
                        "username": "candy45",
                        "content": "consider this case [[7,2,1],[6,1,4],[6,1,2],[3,2,1]] by taking max value in every column we will get answer as 13 but answer is 12"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "Can someone help me with my code?\\nWhy is not working ?\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        for(auto a:nums){\\n            sort(a.begin(),a.end());\\n        }\\n        int sum=0;\\n        for(int i=0;i<nums[0].size();i++){\\n            int maxi=0;\\n            for(int j=0;j<nums.size();j++){\\n                maxi=max(nums[j][i],maxi);\\n            }\\n            sum+=maxi;\\n        }\\n        return sum;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "avinash3300",
                        "content": "you want to write in for loop\\nfor(auto &a : nums){\\n            sort(a.begin(),a.end());\\n        }\\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@BadalArya](/BadalArya)  thanks bro \\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@Ankur_0152](/Ankur_0152)  Thanks bro\\n"
                    },
                    {
                        "username": "Ankur_0152",
                        "content": "either use \n        for(auto &a:nums)\n            sort(a.begin(),a.end());\nor \n       for(int i=0;i<nums.size();i++)\n           sort(nums[i].begin(),nums[i].end());\n        "
                    },
                    {
                        "username": "BadalArya",
                        "content": "for(auto &a : nums)\\n\\nYou need to use for each loop with address or it won\\'t sort the array"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "even i come up with the same sol, i don't understand sorting of rows req. did they ask in question ? "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n- Initialize the score to 0 and a variable called total to 0.\\n- While total is less than the total number of elements in the matrix:\\n- Create a priority queue to store the largest numbers from each row.\\n- For each row in the matrix, find the largest number that hasn\\'t been removed yet (i.e., its value is not -1), and add it to the priority queue.\\n- Remove the largest number from the priority queue and add it to the score.\\n- Mark the location of the removed number in the matrix by setting its value to -1.\\n- Increment the total variable to keep track of how many elements have been removed.\\n- Return the final score."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link :-)***\\nhttps://leetcode.com/problems/sum-in-a-matrix/solutions/3524127/easiest-solution-priorityqueue/"
                    },
                    {
                        "username": "Balwierz",
                        "content": "Identical to https://leetcode.com/problems/delete-greatest-value-in-each-row/"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Why does this code pass only 116/1057 test cases \\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int score =0;\\n        priority_queue<int> pq;\\n        for(int j=0;j<nums[0].size();j++){\\n            for(int i=0;i<nums.size();i++){\\n                pq.push(nums[i][j]);\\n            }\\n            score += pq.top();\\n            while(!pq.empty()){\\n                pq.pop();\\n            }\\n        }\\n        return score;\\n    }\\n};"
                    },
                    {
                        "username": "Nazar2020",
                        "content": "Matrix row can be sorted asc or desc, it doesn\\'t matter"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "for me wheneve I try to iterate rows and column runtime error for no reason like even I used n = nums.size() and m = nums[0].size() still it says runtime but while 14 and 13 numbers it works what is wrong"
                    },
                    {
                        "username": "hacker363",
                        "content": "```class Solution:\n    def matrixSum(self, nums: List[List[int]]) -> int:\n        i = 0\n        ans = 0\n        while i<len(nums[0]):\n            l = sorted(nums, key=lambda x :x[i])[::-1]\n            ans+=l[0][i]\n            i+=1\n        return ans\n```\n\nCan anyone please tell me why my code only passes 116 testcases rather than all....\nPlease address the mistake I have made.\nif it finds helpful please upvote\n"
                    }
                ]
            },
            {
                "id": 1892461,
                "content": [
                    {
                        "username": "roboto7o32oo3",
                        "content": "This problem should be marked Easy....."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "how is your dp moving??"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "This problem is same as [2500. Delete Greatest Value in Each Row](https://leetcode.com/problems/delete-greatest-value-in-each-row/)"
                    },
                    {
                        "username": "abhijay_123",
                        "content": "Why sort ?\\nand why selecting the largest value in a column fails?"
                    },
                    {
                        "username": "vinnnu",
                        "content": "[@candy45](/candy45) thanks mate "
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "[@arshikamishra](/arshikamishra) Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "[@candy45](/candy45) could you elaborate please"
                    },
                    {
                        "username": "candy45",
                        "content": "consider this case [[7,2,1],[6,1,4],[6,1,2],[3,2,1]] by taking max value in every column we will get answer as 13 but answer is 12"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "Can someone help me with my code?\\nWhy is not working ?\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        for(auto a:nums){\\n            sort(a.begin(),a.end());\\n        }\\n        int sum=0;\\n        for(int i=0;i<nums[0].size();i++){\\n            int maxi=0;\\n            for(int j=0;j<nums.size();j++){\\n                maxi=max(nums[j][i],maxi);\\n            }\\n            sum+=maxi;\\n        }\\n        return sum;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "avinash3300",
                        "content": "you want to write in for loop\\nfor(auto &a : nums){\\n            sort(a.begin(),a.end());\\n        }\\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@BadalArya](/BadalArya)  thanks bro \\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@Ankur_0152](/Ankur_0152)  Thanks bro\\n"
                    },
                    {
                        "username": "Ankur_0152",
                        "content": "either use \n        for(auto &a:nums)\n            sort(a.begin(),a.end());\nor \n       for(int i=0;i<nums.size();i++)\n           sort(nums[i].begin(),nums[i].end());\n        "
                    },
                    {
                        "username": "BadalArya",
                        "content": "for(auto &a : nums)\\n\\nYou need to use for each loop with address or it won\\'t sort the array"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "even i come up with the same sol, i don't understand sorting of rows req. did they ask in question ? "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n- Initialize the score to 0 and a variable called total to 0.\\n- While total is less than the total number of elements in the matrix:\\n- Create a priority queue to store the largest numbers from each row.\\n- For each row in the matrix, find the largest number that hasn\\'t been removed yet (i.e., its value is not -1), and add it to the priority queue.\\n- Remove the largest number from the priority queue and add it to the score.\\n- Mark the location of the removed number in the matrix by setting its value to -1.\\n- Increment the total variable to keep track of how many elements have been removed.\\n- Return the final score."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link :-)***\\nhttps://leetcode.com/problems/sum-in-a-matrix/solutions/3524127/easiest-solution-priorityqueue/"
                    },
                    {
                        "username": "Balwierz",
                        "content": "Identical to https://leetcode.com/problems/delete-greatest-value-in-each-row/"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Why does this code pass only 116/1057 test cases \\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int score =0;\\n        priority_queue<int> pq;\\n        for(int j=0;j<nums[0].size();j++){\\n            for(int i=0;i<nums.size();i++){\\n                pq.push(nums[i][j]);\\n            }\\n            score += pq.top();\\n            while(!pq.empty()){\\n                pq.pop();\\n            }\\n        }\\n        return score;\\n    }\\n};"
                    },
                    {
                        "username": "Nazar2020",
                        "content": "Matrix row can be sorted asc or desc, it doesn\\'t matter"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "for me wheneve I try to iterate rows and column runtime error for no reason like even I used n = nums.size() and m = nums[0].size() still it says runtime but while 14 and 13 numbers it works what is wrong"
                    },
                    {
                        "username": "hacker363",
                        "content": "```class Solution:\n    def matrixSum(self, nums: List[List[int]]) -> int:\n        i = 0\n        ans = 0\n        while i<len(nums[0]):\n            l = sorted(nums, key=lambda x :x[i])[::-1]\n            ans+=l[0][i]\n            i+=1\n        return ans\n```\n\nCan anyone please tell me why my code only passes 116 testcases rather than all....\nPlease address the mistake I have made.\nif it finds helpful please upvote\n"
                    }
                ]
            },
            {
                "id": 1892785,
                "content": [
                    {
                        "username": "roboto7o32oo3",
                        "content": "This problem should be marked Easy....."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "how is your dp moving??"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "This problem is same as [2500. Delete Greatest Value in Each Row](https://leetcode.com/problems/delete-greatest-value-in-each-row/)"
                    },
                    {
                        "username": "abhijay_123",
                        "content": "Why sort ?\\nand why selecting the largest value in a column fails?"
                    },
                    {
                        "username": "vinnnu",
                        "content": "[@candy45](/candy45) thanks mate "
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "[@arshikamishra](/arshikamishra) Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "[@candy45](/candy45) could you elaborate please"
                    },
                    {
                        "username": "candy45",
                        "content": "consider this case [[7,2,1],[6,1,4],[6,1,2],[3,2,1]] by taking max value in every column we will get answer as 13 but answer is 12"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "Can someone help me with my code?\\nWhy is not working ?\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        for(auto a:nums){\\n            sort(a.begin(),a.end());\\n        }\\n        int sum=0;\\n        for(int i=0;i<nums[0].size();i++){\\n            int maxi=0;\\n            for(int j=0;j<nums.size();j++){\\n                maxi=max(nums[j][i],maxi);\\n            }\\n            sum+=maxi;\\n        }\\n        return sum;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "avinash3300",
                        "content": "you want to write in for loop\\nfor(auto &a : nums){\\n            sort(a.begin(),a.end());\\n        }\\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@BadalArya](/BadalArya)  thanks bro \\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@Ankur_0152](/Ankur_0152)  Thanks bro\\n"
                    },
                    {
                        "username": "Ankur_0152",
                        "content": "either use \n        for(auto &a:nums)\n            sort(a.begin(),a.end());\nor \n       for(int i=0;i<nums.size();i++)\n           sort(nums[i].begin(),nums[i].end());\n        "
                    },
                    {
                        "username": "BadalArya",
                        "content": "for(auto &a : nums)\\n\\nYou need to use for each loop with address or it won\\'t sort the array"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "even i come up with the same sol, i don't understand sorting of rows req. did they ask in question ? "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n- Initialize the score to 0 and a variable called total to 0.\\n- While total is less than the total number of elements in the matrix:\\n- Create a priority queue to store the largest numbers from each row.\\n- For each row in the matrix, find the largest number that hasn\\'t been removed yet (i.e., its value is not -1), and add it to the priority queue.\\n- Remove the largest number from the priority queue and add it to the score.\\n- Mark the location of the removed number in the matrix by setting its value to -1.\\n- Increment the total variable to keep track of how many elements have been removed.\\n- Return the final score."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link :-)***\\nhttps://leetcode.com/problems/sum-in-a-matrix/solutions/3524127/easiest-solution-priorityqueue/"
                    },
                    {
                        "username": "Balwierz",
                        "content": "Identical to https://leetcode.com/problems/delete-greatest-value-in-each-row/"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Why does this code pass only 116/1057 test cases \\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int score =0;\\n        priority_queue<int> pq;\\n        for(int j=0;j<nums[0].size();j++){\\n            for(int i=0;i<nums.size();i++){\\n                pq.push(nums[i][j]);\\n            }\\n            score += pq.top();\\n            while(!pq.empty()){\\n                pq.pop();\\n            }\\n        }\\n        return score;\\n    }\\n};"
                    },
                    {
                        "username": "Nazar2020",
                        "content": "Matrix row can be sorted asc or desc, it doesn\\'t matter"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "for me wheneve I try to iterate rows and column runtime error for no reason like even I used n = nums.size() and m = nums[0].size() still it says runtime but while 14 and 13 numbers it works what is wrong"
                    },
                    {
                        "username": "hacker363",
                        "content": "```class Solution:\n    def matrixSum(self, nums: List[List[int]]) -> int:\n        i = 0\n        ans = 0\n        while i<len(nums[0]):\n            l = sorted(nums, key=lambda x :x[i])[::-1]\n            ans+=l[0][i]\n            i+=1\n        return ans\n```\n\nCan anyone please tell me why my code only passes 116 testcases rather than all....\nPlease address the mistake I have made.\nif it finds helpful please upvote\n"
                    }
                ]
            },
            {
                "id": 1892799,
                "content": [
                    {
                        "username": "roboto7o32oo3",
                        "content": "This problem should be marked Easy....."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "how is your dp moving??"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "This problem is same as [2500. Delete Greatest Value in Each Row](https://leetcode.com/problems/delete-greatest-value-in-each-row/)"
                    },
                    {
                        "username": "abhijay_123",
                        "content": "Why sort ?\\nand why selecting the largest value in a column fails?"
                    },
                    {
                        "username": "vinnnu",
                        "content": "[@candy45](/candy45) thanks mate "
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "[@arshikamishra](/arshikamishra) Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "[@candy45](/candy45) could you elaborate please"
                    },
                    {
                        "username": "candy45",
                        "content": "consider this case [[7,2,1],[6,1,4],[6,1,2],[3,2,1]] by taking max value in every column we will get answer as 13 but answer is 12"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "Can someone help me with my code?\\nWhy is not working ?\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        for(auto a:nums){\\n            sort(a.begin(),a.end());\\n        }\\n        int sum=0;\\n        for(int i=0;i<nums[0].size();i++){\\n            int maxi=0;\\n            for(int j=0;j<nums.size();j++){\\n                maxi=max(nums[j][i],maxi);\\n            }\\n            sum+=maxi;\\n        }\\n        return sum;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "avinash3300",
                        "content": "you want to write in for loop\\nfor(auto &a : nums){\\n            sort(a.begin(),a.end());\\n        }\\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@BadalArya](/BadalArya)  thanks bro \\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@Ankur_0152](/Ankur_0152)  Thanks bro\\n"
                    },
                    {
                        "username": "Ankur_0152",
                        "content": "either use \n        for(auto &a:nums)\n            sort(a.begin(),a.end());\nor \n       for(int i=0;i<nums.size();i++)\n           sort(nums[i].begin(),nums[i].end());\n        "
                    },
                    {
                        "username": "BadalArya",
                        "content": "for(auto &a : nums)\\n\\nYou need to use for each loop with address or it won\\'t sort the array"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "even i come up with the same sol, i don't understand sorting of rows req. did they ask in question ? "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n- Initialize the score to 0 and a variable called total to 0.\\n- While total is less than the total number of elements in the matrix:\\n- Create a priority queue to store the largest numbers from each row.\\n- For each row in the matrix, find the largest number that hasn\\'t been removed yet (i.e., its value is not -1), and add it to the priority queue.\\n- Remove the largest number from the priority queue and add it to the score.\\n- Mark the location of the removed number in the matrix by setting its value to -1.\\n- Increment the total variable to keep track of how many elements have been removed.\\n- Return the final score."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link :-)***\\nhttps://leetcode.com/problems/sum-in-a-matrix/solutions/3524127/easiest-solution-priorityqueue/"
                    },
                    {
                        "username": "Balwierz",
                        "content": "Identical to https://leetcode.com/problems/delete-greatest-value-in-each-row/"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Why does this code pass only 116/1057 test cases \\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int score =0;\\n        priority_queue<int> pq;\\n        for(int j=0;j<nums[0].size();j++){\\n            for(int i=0;i<nums.size();i++){\\n                pq.push(nums[i][j]);\\n            }\\n            score += pq.top();\\n            while(!pq.empty()){\\n                pq.pop();\\n            }\\n        }\\n        return score;\\n    }\\n};"
                    },
                    {
                        "username": "Nazar2020",
                        "content": "Matrix row can be sorted asc or desc, it doesn\\'t matter"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "for me wheneve I try to iterate rows and column runtime error for no reason like even I used n = nums.size() and m = nums[0].size() still it says runtime but while 14 and 13 numbers it works what is wrong"
                    },
                    {
                        "username": "hacker363",
                        "content": "```class Solution:\n    def matrixSum(self, nums: List[List[int]]) -> int:\n        i = 0\n        ans = 0\n        while i<len(nums[0]):\n            l = sorted(nums, key=lambda x :x[i])[::-1]\n            ans+=l[0][i]\n            i+=1\n        return ans\n```\n\nCan anyone please tell me why my code only passes 116 testcases rather than all....\nPlease address the mistake I have made.\nif it finds helpful please upvote\n"
                    }
                ]
            },
            {
                "id": 1892459,
                "content": [
                    {
                        "username": "roboto7o32oo3",
                        "content": "This problem should be marked Easy....."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "how is your dp moving??"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "This problem is same as [2500. Delete Greatest Value in Each Row](https://leetcode.com/problems/delete-greatest-value-in-each-row/)"
                    },
                    {
                        "username": "abhijay_123",
                        "content": "Why sort ?\\nand why selecting the largest value in a column fails?"
                    },
                    {
                        "username": "vinnnu",
                        "content": "[@candy45](/candy45) thanks mate "
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "[@arshikamishra](/arshikamishra) Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "[@candy45](/candy45) could you elaborate please"
                    },
                    {
                        "username": "candy45",
                        "content": "consider this case [[7,2,1],[6,1,4],[6,1,2],[3,2,1]] by taking max value in every column we will get answer as 13 but answer is 12"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "Can someone help me with my code?\\nWhy is not working ?\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        for(auto a:nums){\\n            sort(a.begin(),a.end());\\n        }\\n        int sum=0;\\n        for(int i=0;i<nums[0].size();i++){\\n            int maxi=0;\\n            for(int j=0;j<nums.size();j++){\\n                maxi=max(nums[j][i],maxi);\\n            }\\n            sum+=maxi;\\n        }\\n        return sum;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "avinash3300",
                        "content": "you want to write in for loop\\nfor(auto &a : nums){\\n            sort(a.begin(),a.end());\\n        }\\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@BadalArya](/BadalArya)  thanks bro \\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@Ankur_0152](/Ankur_0152)  Thanks bro\\n"
                    },
                    {
                        "username": "Ankur_0152",
                        "content": "either use \n        for(auto &a:nums)\n            sort(a.begin(),a.end());\nor \n       for(int i=0;i<nums.size();i++)\n           sort(nums[i].begin(),nums[i].end());\n        "
                    },
                    {
                        "username": "BadalArya",
                        "content": "for(auto &a : nums)\\n\\nYou need to use for each loop with address or it won\\'t sort the array"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "even i come up with the same sol, i don't understand sorting of rows req. did they ask in question ? "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n- Initialize the score to 0 and a variable called total to 0.\\n- While total is less than the total number of elements in the matrix:\\n- Create a priority queue to store the largest numbers from each row.\\n- For each row in the matrix, find the largest number that hasn\\'t been removed yet (i.e., its value is not -1), and add it to the priority queue.\\n- Remove the largest number from the priority queue and add it to the score.\\n- Mark the location of the removed number in the matrix by setting its value to -1.\\n- Increment the total variable to keep track of how many elements have been removed.\\n- Return the final score."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link :-)***\\nhttps://leetcode.com/problems/sum-in-a-matrix/solutions/3524127/easiest-solution-priorityqueue/"
                    },
                    {
                        "username": "Balwierz",
                        "content": "Identical to https://leetcode.com/problems/delete-greatest-value-in-each-row/"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Why does this code pass only 116/1057 test cases \\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int score =0;\\n        priority_queue<int> pq;\\n        for(int j=0;j<nums[0].size();j++){\\n            for(int i=0;i<nums.size();i++){\\n                pq.push(nums[i][j]);\\n            }\\n            score += pq.top();\\n            while(!pq.empty()){\\n                pq.pop();\\n            }\\n        }\\n        return score;\\n    }\\n};"
                    },
                    {
                        "username": "Nazar2020",
                        "content": "Matrix row can be sorted asc or desc, it doesn\\'t matter"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "for me wheneve I try to iterate rows and column runtime error for no reason like even I used n = nums.size() and m = nums[0].size() still it says runtime but while 14 and 13 numbers it works what is wrong"
                    },
                    {
                        "username": "hacker363",
                        "content": "```class Solution:\n    def matrixSum(self, nums: List[List[int]]) -> int:\n        i = 0\n        ans = 0\n        while i<len(nums[0]):\n            l = sorted(nums, key=lambda x :x[i])[::-1]\n            ans+=l[0][i]\n            i+=1\n        return ans\n```\n\nCan anyone please tell me why my code only passes 116 testcases rather than all....\nPlease address the mistake I have made.\nif it finds helpful please upvote\n"
                    }
                ]
            },
            {
                "id": 1893910,
                "content": [
                    {
                        "username": "roboto7o32oo3",
                        "content": "This problem should be marked Easy....."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "how is your dp moving??"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "This problem is same as [2500. Delete Greatest Value in Each Row](https://leetcode.com/problems/delete-greatest-value-in-each-row/)"
                    },
                    {
                        "username": "abhijay_123",
                        "content": "Why sort ?\\nand why selecting the largest value in a column fails?"
                    },
                    {
                        "username": "vinnnu",
                        "content": "[@candy45](/candy45) thanks mate "
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "[@arshikamishra](/arshikamishra) Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "[@candy45](/candy45) could you elaborate please"
                    },
                    {
                        "username": "candy45",
                        "content": "consider this case [[7,2,1],[6,1,4],[6,1,2],[3,2,1]] by taking max value in every column we will get answer as 13 but answer is 12"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "Can someone help me with my code?\\nWhy is not working ?\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        for(auto a:nums){\\n            sort(a.begin(),a.end());\\n        }\\n        int sum=0;\\n        for(int i=0;i<nums[0].size();i++){\\n            int maxi=0;\\n            for(int j=0;j<nums.size();j++){\\n                maxi=max(nums[j][i],maxi);\\n            }\\n            sum+=maxi;\\n        }\\n        return sum;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "avinash3300",
                        "content": "you want to write in for loop\\nfor(auto &a : nums){\\n            sort(a.begin(),a.end());\\n        }\\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@BadalArya](/BadalArya)  thanks bro \\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@Ankur_0152](/Ankur_0152)  Thanks bro\\n"
                    },
                    {
                        "username": "Ankur_0152",
                        "content": "either use \n        for(auto &a:nums)\n            sort(a.begin(),a.end());\nor \n       for(int i=0;i<nums.size();i++)\n           sort(nums[i].begin(),nums[i].end());\n        "
                    },
                    {
                        "username": "BadalArya",
                        "content": "for(auto &a : nums)\\n\\nYou need to use for each loop with address or it won\\'t sort the array"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "even i come up with the same sol, i don't understand sorting of rows req. did they ask in question ? "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n- Initialize the score to 0 and a variable called total to 0.\\n- While total is less than the total number of elements in the matrix:\\n- Create a priority queue to store the largest numbers from each row.\\n- For each row in the matrix, find the largest number that hasn\\'t been removed yet (i.e., its value is not -1), and add it to the priority queue.\\n- Remove the largest number from the priority queue and add it to the score.\\n- Mark the location of the removed number in the matrix by setting its value to -1.\\n- Increment the total variable to keep track of how many elements have been removed.\\n- Return the final score."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link :-)***\\nhttps://leetcode.com/problems/sum-in-a-matrix/solutions/3524127/easiest-solution-priorityqueue/"
                    },
                    {
                        "username": "Balwierz",
                        "content": "Identical to https://leetcode.com/problems/delete-greatest-value-in-each-row/"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Why does this code pass only 116/1057 test cases \\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int score =0;\\n        priority_queue<int> pq;\\n        for(int j=0;j<nums[0].size();j++){\\n            for(int i=0;i<nums.size();i++){\\n                pq.push(nums[i][j]);\\n            }\\n            score += pq.top();\\n            while(!pq.empty()){\\n                pq.pop();\\n            }\\n        }\\n        return score;\\n    }\\n};"
                    },
                    {
                        "username": "Nazar2020",
                        "content": "Matrix row can be sorted asc or desc, it doesn\\'t matter"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "for me wheneve I try to iterate rows and column runtime error for no reason like even I used n = nums.size() and m = nums[0].size() still it says runtime but while 14 and 13 numbers it works what is wrong"
                    },
                    {
                        "username": "hacker363",
                        "content": "```class Solution:\n    def matrixSum(self, nums: List[List[int]]) -> int:\n        i = 0\n        ans = 0\n        while i<len(nums[0]):\n            l = sorted(nums, key=lambda x :x[i])[::-1]\n            ans+=l[0][i]\n            i+=1\n        return ans\n```\n\nCan anyone please tell me why my code only passes 116 testcases rather than all....\nPlease address the mistake I have made.\nif it finds helpful please upvote\n"
                    }
                ]
            },
            {
                "id": 1893821,
                "content": [
                    {
                        "username": "roboto7o32oo3",
                        "content": "This problem should be marked Easy....."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "how is your dp moving??"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "This problem is same as [2500. Delete Greatest Value in Each Row](https://leetcode.com/problems/delete-greatest-value-in-each-row/)"
                    },
                    {
                        "username": "abhijay_123",
                        "content": "Why sort ?\\nand why selecting the largest value in a column fails?"
                    },
                    {
                        "username": "vinnnu",
                        "content": "[@candy45](/candy45) thanks mate "
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "[@arshikamishra](/arshikamishra) Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "[@candy45](/candy45) could you elaborate please"
                    },
                    {
                        "username": "candy45",
                        "content": "consider this case [[7,2,1],[6,1,4],[6,1,2],[3,2,1]] by taking max value in every column we will get answer as 13 but answer is 12"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "Can someone help me with my code?\\nWhy is not working ?\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        for(auto a:nums){\\n            sort(a.begin(),a.end());\\n        }\\n        int sum=0;\\n        for(int i=0;i<nums[0].size();i++){\\n            int maxi=0;\\n            for(int j=0;j<nums.size();j++){\\n                maxi=max(nums[j][i],maxi);\\n            }\\n            sum+=maxi;\\n        }\\n        return sum;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "avinash3300",
                        "content": "you want to write in for loop\\nfor(auto &a : nums){\\n            sort(a.begin(),a.end());\\n        }\\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@BadalArya](/BadalArya)  thanks bro \\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@Ankur_0152](/Ankur_0152)  Thanks bro\\n"
                    },
                    {
                        "username": "Ankur_0152",
                        "content": "either use \n        for(auto &a:nums)\n            sort(a.begin(),a.end());\nor \n       for(int i=0;i<nums.size();i++)\n           sort(nums[i].begin(),nums[i].end());\n        "
                    },
                    {
                        "username": "BadalArya",
                        "content": "for(auto &a : nums)\\n\\nYou need to use for each loop with address or it won\\'t sort the array"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "even i come up with the same sol, i don't understand sorting of rows req. did they ask in question ? "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n- Initialize the score to 0 and a variable called total to 0.\\n- While total is less than the total number of elements in the matrix:\\n- Create a priority queue to store the largest numbers from each row.\\n- For each row in the matrix, find the largest number that hasn\\'t been removed yet (i.e., its value is not -1), and add it to the priority queue.\\n- Remove the largest number from the priority queue and add it to the score.\\n- Mark the location of the removed number in the matrix by setting its value to -1.\\n- Increment the total variable to keep track of how many elements have been removed.\\n- Return the final score."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link :-)***\\nhttps://leetcode.com/problems/sum-in-a-matrix/solutions/3524127/easiest-solution-priorityqueue/"
                    },
                    {
                        "username": "Balwierz",
                        "content": "Identical to https://leetcode.com/problems/delete-greatest-value-in-each-row/"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Why does this code pass only 116/1057 test cases \\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int score =0;\\n        priority_queue<int> pq;\\n        for(int j=0;j<nums[0].size();j++){\\n            for(int i=0;i<nums.size();i++){\\n                pq.push(nums[i][j]);\\n            }\\n            score += pq.top();\\n            while(!pq.empty()){\\n                pq.pop();\\n            }\\n        }\\n        return score;\\n    }\\n};"
                    },
                    {
                        "username": "Nazar2020",
                        "content": "Matrix row can be sorted asc or desc, it doesn\\'t matter"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "for me wheneve I try to iterate rows and column runtime error for no reason like even I used n = nums.size() and m = nums[0].size() still it says runtime but while 14 and 13 numbers it works what is wrong"
                    },
                    {
                        "username": "hacker363",
                        "content": "```class Solution:\n    def matrixSum(self, nums: List[List[int]]) -> int:\n        i = 0\n        ans = 0\n        while i<len(nums[0]):\n            l = sorted(nums, key=lambda x :x[i])[::-1]\n            ans+=l[0][i]\n            i+=1\n        return ans\n```\n\nCan anyone please tell me why my code only passes 116 testcases rather than all....\nPlease address the mistake I have made.\nif it finds helpful please upvote\n"
                    }
                ]
            },
            {
                "id": 2046752,
                "content": [
                    {
                        "username": "roboto7o32oo3",
                        "content": "This problem should be marked Easy....."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "how is your dp moving??"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "This problem is same as [2500. Delete Greatest Value in Each Row](https://leetcode.com/problems/delete-greatest-value-in-each-row/)"
                    },
                    {
                        "username": "abhijay_123",
                        "content": "Why sort ?\\nand why selecting the largest value in a column fails?"
                    },
                    {
                        "username": "vinnnu",
                        "content": "[@candy45](/candy45) thanks mate "
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "[@arshikamishra](/arshikamishra) Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "[@candy45](/candy45) could you elaborate please"
                    },
                    {
                        "username": "candy45",
                        "content": "consider this case [[7,2,1],[6,1,4],[6,1,2],[3,2,1]] by taking max value in every column we will get answer as 13 but answer is 12"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "Can someone help me with my code?\\nWhy is not working ?\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        for(auto a:nums){\\n            sort(a.begin(),a.end());\\n        }\\n        int sum=0;\\n        for(int i=0;i<nums[0].size();i++){\\n            int maxi=0;\\n            for(int j=0;j<nums.size();j++){\\n                maxi=max(nums[j][i],maxi);\\n            }\\n            sum+=maxi;\\n        }\\n        return sum;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "avinash3300",
                        "content": "you want to write in for loop\\nfor(auto &a : nums){\\n            sort(a.begin(),a.end());\\n        }\\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@BadalArya](/BadalArya)  thanks bro \\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@Ankur_0152](/Ankur_0152)  Thanks bro\\n"
                    },
                    {
                        "username": "Ankur_0152",
                        "content": "either use \n        for(auto &a:nums)\n            sort(a.begin(),a.end());\nor \n       for(int i=0;i<nums.size();i++)\n           sort(nums[i].begin(),nums[i].end());\n        "
                    },
                    {
                        "username": "BadalArya",
                        "content": "for(auto &a : nums)\\n\\nYou need to use for each loop with address or it won\\'t sort the array"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "even i come up with the same sol, i don't understand sorting of rows req. did they ask in question ? "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n- Initialize the score to 0 and a variable called total to 0.\\n- While total is less than the total number of elements in the matrix:\\n- Create a priority queue to store the largest numbers from each row.\\n- For each row in the matrix, find the largest number that hasn\\'t been removed yet (i.e., its value is not -1), and add it to the priority queue.\\n- Remove the largest number from the priority queue and add it to the score.\\n- Mark the location of the removed number in the matrix by setting its value to -1.\\n- Increment the total variable to keep track of how many elements have been removed.\\n- Return the final score."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link :-)***\\nhttps://leetcode.com/problems/sum-in-a-matrix/solutions/3524127/easiest-solution-priorityqueue/"
                    },
                    {
                        "username": "Balwierz",
                        "content": "Identical to https://leetcode.com/problems/delete-greatest-value-in-each-row/"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Why does this code pass only 116/1057 test cases \\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int score =0;\\n        priority_queue<int> pq;\\n        for(int j=0;j<nums[0].size();j++){\\n            for(int i=0;i<nums.size();i++){\\n                pq.push(nums[i][j]);\\n            }\\n            score += pq.top();\\n            while(!pq.empty()){\\n                pq.pop();\\n            }\\n        }\\n        return score;\\n    }\\n};"
                    },
                    {
                        "username": "Nazar2020",
                        "content": "Matrix row can be sorted asc or desc, it doesn\\'t matter"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "for me wheneve I try to iterate rows and column runtime error for no reason like even I used n = nums.size() and m = nums[0].size() still it says runtime but while 14 and 13 numbers it works what is wrong"
                    },
                    {
                        "username": "hacker363",
                        "content": "```class Solution:\n    def matrixSum(self, nums: List[List[int]]) -> int:\n        i = 0\n        ans = 0\n        while i<len(nums[0]):\n            l = sorted(nums, key=lambda x :x[i])[::-1]\n            ans+=l[0][i]\n            i+=1\n        return ans\n```\n\nCan anyone please tell me why my code only passes 116 testcases rather than all....\nPlease address the mistake I have made.\nif it finds helpful please upvote\n"
                    }
                ]
            },
            {
                "id": 2037216,
                "content": [
                    {
                        "username": "roboto7o32oo3",
                        "content": "This problem should be marked Easy....."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "how is your dp moving??"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "This problem is same as [2500. Delete Greatest Value in Each Row](https://leetcode.com/problems/delete-greatest-value-in-each-row/)"
                    },
                    {
                        "username": "abhijay_123",
                        "content": "Why sort ?\\nand why selecting the largest value in a column fails?"
                    },
                    {
                        "username": "vinnnu",
                        "content": "[@candy45](/candy45) thanks mate "
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "[@arshikamishra](/arshikamishra) Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "[@candy45](/candy45) could you elaborate please"
                    },
                    {
                        "username": "candy45",
                        "content": "consider this case [[7,2,1],[6,1,4],[6,1,2],[3,2,1]] by taking max value in every column we will get answer as 13 but answer is 12"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "Can someone help me with my code?\\nWhy is not working ?\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        for(auto a:nums){\\n            sort(a.begin(),a.end());\\n        }\\n        int sum=0;\\n        for(int i=0;i<nums[0].size();i++){\\n            int maxi=0;\\n            for(int j=0;j<nums.size();j++){\\n                maxi=max(nums[j][i],maxi);\\n            }\\n            sum+=maxi;\\n        }\\n        return sum;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "avinash3300",
                        "content": "you want to write in for loop\\nfor(auto &a : nums){\\n            sort(a.begin(),a.end());\\n        }\\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@BadalArya](/BadalArya)  thanks bro \\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@Ankur_0152](/Ankur_0152)  Thanks bro\\n"
                    },
                    {
                        "username": "Ankur_0152",
                        "content": "either use \n        for(auto &a:nums)\n            sort(a.begin(),a.end());\nor \n       for(int i=0;i<nums.size();i++)\n           sort(nums[i].begin(),nums[i].end());\n        "
                    },
                    {
                        "username": "BadalArya",
                        "content": "for(auto &a : nums)\\n\\nYou need to use for each loop with address or it won\\'t sort the array"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "even i come up with the same sol, i don't understand sorting of rows req. did they ask in question ? "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n- Initialize the score to 0 and a variable called total to 0.\\n- While total is less than the total number of elements in the matrix:\\n- Create a priority queue to store the largest numbers from each row.\\n- For each row in the matrix, find the largest number that hasn\\'t been removed yet (i.e., its value is not -1), and add it to the priority queue.\\n- Remove the largest number from the priority queue and add it to the score.\\n- Mark the location of the removed number in the matrix by setting its value to -1.\\n- Increment the total variable to keep track of how many elements have been removed.\\n- Return the final score."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link :-)***\\nhttps://leetcode.com/problems/sum-in-a-matrix/solutions/3524127/easiest-solution-priorityqueue/"
                    },
                    {
                        "username": "Balwierz",
                        "content": "Identical to https://leetcode.com/problems/delete-greatest-value-in-each-row/"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Why does this code pass only 116/1057 test cases \\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int score =0;\\n        priority_queue<int> pq;\\n        for(int j=0;j<nums[0].size();j++){\\n            for(int i=0;i<nums.size();i++){\\n                pq.push(nums[i][j]);\\n            }\\n            score += pq.top();\\n            while(!pq.empty()){\\n                pq.pop();\\n            }\\n        }\\n        return score;\\n    }\\n};"
                    },
                    {
                        "username": "Nazar2020",
                        "content": "Matrix row can be sorted asc or desc, it doesn\\'t matter"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "for me wheneve I try to iterate rows and column runtime error for no reason like even I used n = nums.size() and m = nums[0].size() still it says runtime but while 14 and 13 numbers it works what is wrong"
                    },
                    {
                        "username": "hacker363",
                        "content": "```class Solution:\n    def matrixSum(self, nums: List[List[int]]) -> int:\n        i = 0\n        ans = 0\n        while i<len(nums[0]):\n            l = sorted(nums, key=lambda x :x[i])[::-1]\n            ans+=l[0][i]\n            i+=1\n        return ans\n```\n\nCan anyone please tell me why my code only passes 116 testcases rather than all....\nPlease address the mistake I have made.\nif it finds helpful please upvote\n"
                    }
                ]
            },
            {
                "id": 1990741,
                "content": [
                    {
                        "username": "roboto7o32oo3",
                        "content": "This problem should be marked Easy....."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "how is your dp moving??"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "This problem is same as [2500. Delete Greatest Value in Each Row](https://leetcode.com/problems/delete-greatest-value-in-each-row/)"
                    },
                    {
                        "username": "abhijay_123",
                        "content": "Why sort ?\\nand why selecting the largest value in a column fails?"
                    },
                    {
                        "username": "vinnnu",
                        "content": "[@candy45](/candy45) thanks mate "
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "[@arshikamishra](/arshikamishra) Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "[@candy45](/candy45) could you elaborate please"
                    },
                    {
                        "username": "candy45",
                        "content": "consider this case [[7,2,1],[6,1,4],[6,1,2],[3,2,1]] by taking max value in every column we will get answer as 13 but answer is 12"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "Can someone help me with my code?\\nWhy is not working ?\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        for(auto a:nums){\\n            sort(a.begin(),a.end());\\n        }\\n        int sum=0;\\n        for(int i=0;i<nums[0].size();i++){\\n            int maxi=0;\\n            for(int j=0;j<nums.size();j++){\\n                maxi=max(nums[j][i],maxi);\\n            }\\n            sum+=maxi;\\n        }\\n        return sum;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "avinash3300",
                        "content": "you want to write in for loop\\nfor(auto &a : nums){\\n            sort(a.begin(),a.end());\\n        }\\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@BadalArya](/BadalArya)  thanks bro \\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@Ankur_0152](/Ankur_0152)  Thanks bro\\n"
                    },
                    {
                        "username": "Ankur_0152",
                        "content": "either use \n        for(auto &a:nums)\n            sort(a.begin(),a.end());\nor \n       for(int i=0;i<nums.size();i++)\n           sort(nums[i].begin(),nums[i].end());\n        "
                    },
                    {
                        "username": "BadalArya",
                        "content": "for(auto &a : nums)\\n\\nYou need to use for each loop with address or it won\\'t sort the array"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "even i come up with the same sol, i don't understand sorting of rows req. did they ask in question ? "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n- Initialize the score to 0 and a variable called total to 0.\\n- While total is less than the total number of elements in the matrix:\\n- Create a priority queue to store the largest numbers from each row.\\n- For each row in the matrix, find the largest number that hasn\\'t been removed yet (i.e., its value is not -1), and add it to the priority queue.\\n- Remove the largest number from the priority queue and add it to the score.\\n- Mark the location of the removed number in the matrix by setting its value to -1.\\n- Increment the total variable to keep track of how many elements have been removed.\\n- Return the final score."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link :-)***\\nhttps://leetcode.com/problems/sum-in-a-matrix/solutions/3524127/easiest-solution-priorityqueue/"
                    },
                    {
                        "username": "Balwierz",
                        "content": "Identical to https://leetcode.com/problems/delete-greatest-value-in-each-row/"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Why does this code pass only 116/1057 test cases \\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int score =0;\\n        priority_queue<int> pq;\\n        for(int j=0;j<nums[0].size();j++){\\n            for(int i=0;i<nums.size();i++){\\n                pq.push(nums[i][j]);\\n            }\\n            score += pq.top();\\n            while(!pq.empty()){\\n                pq.pop();\\n            }\\n        }\\n        return score;\\n    }\\n};"
                    },
                    {
                        "username": "Nazar2020",
                        "content": "Matrix row can be sorted asc or desc, it doesn\\'t matter"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "for me wheneve I try to iterate rows and column runtime error for no reason like even I used n = nums.size() and m = nums[0].size() still it says runtime but while 14 and 13 numbers it works what is wrong"
                    },
                    {
                        "username": "hacker363",
                        "content": "```class Solution:\n    def matrixSum(self, nums: List[List[int]]) -> int:\n        i = 0\n        ans = 0\n        while i<len(nums[0]):\n            l = sorted(nums, key=lambda x :x[i])[::-1]\n            ans+=l[0][i]\n            i+=1\n        return ans\n```\n\nCan anyone please tell me why my code only passes 116 testcases rather than all....\nPlease address the mistake I have made.\nif it finds helpful please upvote\n"
                    }
                ]
            },
            {
                "id": 1989259,
                "content": [
                    {
                        "username": "roboto7o32oo3",
                        "content": "This problem should be marked Easy....."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "how is your dp moving??"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "This problem is same as [2500. Delete Greatest Value in Each Row](https://leetcode.com/problems/delete-greatest-value-in-each-row/)"
                    },
                    {
                        "username": "abhijay_123",
                        "content": "Why sort ?\\nand why selecting the largest value in a column fails?"
                    },
                    {
                        "username": "vinnnu",
                        "content": "[@candy45](/candy45) thanks mate "
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "[@arshikamishra](/arshikamishra) Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "HarshitRaj_14",
                        "content": "Because in every iteration we have to remove the maximum element from each row. \\nIt is not mandatory that the maximum element will always be at column number i so we sort every row in order to make sure that the maximum number is at ith column.\\nThe question has specifically asked us to - From each row in the matrix, select the largest number and remove it. So first sort it rowwise to get the largest element first.\\n \\nPlease upvote if you understood"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "[@candy45](/candy45) could you elaborate please"
                    },
                    {
                        "username": "candy45",
                        "content": "consider this case [[7,2,1],[6,1,4],[6,1,2],[3,2,1]] by taking max value in every column we will get answer as 13 but answer is 12"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "Can someone help me with my code?\\nWhy is not working ?\\n```\\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        for(auto a:nums){\\n            sort(a.begin(),a.end());\\n        }\\n        int sum=0;\\n        for(int i=0;i<nums[0].size();i++){\\n            int maxi=0;\\n            for(int j=0;j<nums.size();j++){\\n                maxi=max(nums[j][i],maxi);\\n            }\\n            sum+=maxi;\\n        }\\n        return sum;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "avinash3300",
                        "content": "you want to write in for loop\\nfor(auto &a : nums){\\n            sort(a.begin(),a.end());\\n        }\\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@BadalArya](/BadalArya)  thanks bro \\n"
                    },
                    {
                        "username": "inderjeet09",
                        "content": "[@Ankur_0152](/Ankur_0152)  Thanks bro\\n"
                    },
                    {
                        "username": "Ankur_0152",
                        "content": "either use \n        for(auto &a:nums)\n            sort(a.begin(),a.end());\nor \n       for(int i=0;i<nums.size();i++)\n           sort(nums[i].begin(),nums[i].end());\n        "
                    },
                    {
                        "username": "BadalArya",
                        "content": "for(auto &a : nums)\\n\\nYou need to use for each loop with address or it won\\'t sort the array"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "even i come up with the same sol, i don't understand sorting of rows req. did they ask in question ? "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is an Approach :-)**\\n- Initialize the score to 0 and a variable called total to 0.\\n- While total is less than the total number of elements in the matrix:\\n- Create a priority queue to store the largest numbers from each row.\\n- For each row in the matrix, find the largest number that hasn\\'t been removed yet (i.e., its value is not -1), and add it to the priority queue.\\n- Remove the largest number from the priority queue and add it to the score.\\n- Mark the location of the removed number in the matrix by setting its value to -1.\\n- Increment the total variable to keep track of how many elements have been removed.\\n- Return the final score."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Code Link :-)***\\nhttps://leetcode.com/problems/sum-in-a-matrix/solutions/3524127/easiest-solution-priorityqueue/"
                    },
                    {
                        "username": "Balwierz",
                        "content": "Identical to https://leetcode.com/problems/delete-greatest-value-in-each-row/"
                    },
                    {
                        "username": "rtanishka",
                        "content": "Why does this code pass only 116/1057 test cases \\nclass Solution {\\npublic:\\n    int matrixSum(vector<vector<int>>& nums) {\\n        int score =0;\\n        priority_queue<int> pq;\\n        for(int j=0;j<nums[0].size();j++){\\n            for(int i=0;i<nums.size();i++){\\n                pq.push(nums[i][j]);\\n            }\\n            score += pq.top();\\n            while(!pq.empty()){\\n                pq.pop();\\n            }\\n        }\\n        return score;\\n    }\\n};"
                    },
                    {
                        "username": "Nazar2020",
                        "content": "Matrix row can be sorted asc or desc, it doesn\\'t matter"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "for me wheneve I try to iterate rows and column runtime error for no reason like even I used n = nums.size() and m = nums[0].size() still it says runtime but while 14 and 13 numbers it works what is wrong"
                    },
                    {
                        "username": "hacker363",
                        "content": "```class Solution:\n    def matrixSum(self, nums: List[List[int]]) -> int:\n        i = 0\n        ans = 0\n        while i<len(nums[0]):\n            l = sorted(nums, key=lambda x :x[i])[::-1]\n            ans+=l[0][i]\n            i+=1\n        return ans\n```\n\nCan anyone please tell me why my code only passes 116 testcases rather than all....\nPlease address the mistake I have made.\nif it finds helpful please upvote\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum String Length After Removing Substrings",
        "question_content": "<p>You are given a string <code>s</code> consisting only of <strong>uppercase</strong> English letters.</p>\n\n<p>You can apply some operations to this string where, in one operation, you can remove <strong>any</strong> occurrence of one of the substrings <code>&quot;AB&quot;</code> or <code>&quot;CD&quot;</code> from <code>s</code>.</p>\n\n<p>Return <em>the <strong>minimum</strong> possible length of the resulting string that you can obtain</em>.</p>\n\n<p><strong>Note</strong> that the string concatenates after removing the substring and could produce new <code>&quot;AB&quot;</code> or <code>&quot;CD&quot;</code> substrings.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;ABFCACDB&quot;\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> We can do the following operations:\n- Remove the substring &quot;<u>AB</u>FCACDB&quot;, so s = &quot;FCACDB&quot;.\n- Remove the substring &quot;FCA<u>CD</u>B&quot;, so s = &quot;FCAB&quot;.\n- Remove the substring &quot;FC<u>AB</u>&quot;, so s = &quot;FC&quot;.\nSo the resulting length of the string is 2.\nIt can be shown that it is the minimum length that we can obtain.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;ACBBD&quot;\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> We cannot do any operations on the string so the length remains the same.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 100</code></li>\n\t<li><code>s</code>&nbsp;consists only of uppercase English letters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 3546881,
                "title": "stack-very-simple-and-easy-to-understand-solution",
                "content": "<b> Up vote if it helps </b>\\n# Approach\\nWe just need to take a stack and push the elements to it.\\nwhile doing so check if the top element is complement of \\'B\\' that is \\'A\\' or not and similarly for \\'D\\' the top element is \\'C\\' or not. If this condition satisfy then simply pop element from stack.\\n\\n# Code\\n```\\nint minLength(string s) {\\n    stack<int> stk;\\n    for(auto c: s){\\n        if(c == \\'B\\' && stk.size() && stk.top() == \\'A\\') stk.pop();\\n        else if(c == \\'D\\' && stk.size() && stk.top() == \\'C\\') stk.pop();\\n        else stk.push(c);\\n    }\\n    return stk.size();\\n}\\n```\\n\\n<b>Here is an article of my last interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint minLength(string s) {\\n    stack<int> stk;\\n    for(auto c: s){\\n        if(c == \\'B\\' && stk.size() && stk.top() == \\'A\\') stk.pop();\\n        else if(c == \\'D\\' && stk.size() && stk.top() == \\'C\\') stk.pop();\\n        else stk.push(c);\\n    }\\n    return stk.size();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3546874,
                "title": "very-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse Stack.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse stack. For every element in string just check if stack top is matched to current character of string or not. If yes, then remove the elemet from stack, else push the character to the stack.\\nAt Last return stack size.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Please Upvote if you like it. \\u2714\\u2714\\n\\n# Code\\n```\\nclass Solution {\\n    public int minLength(String s) {\\n        Stack<Character> st = new Stack<>();\\n        int n = s.length();\\n        st.push(s.charAt(0));\\n        for(int i=1;i<n;i++)\\n        {\\n            if(!st.isEmpty()&&((s.charAt(i)==\\'B\\'&&st.peek()==\\'A\\')||(s.charAt(i)==\\'D\\'&&st.peek()==\\'C\\')))\\n            {\\n                st.pop();\\n            }\\n            else\\n                st.push(s.charAt(i));\\n        }\\n        return st.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minLength(String s) {\\n        Stack<Character> st = new Stack<>();\\n        int n = s.length();\\n        st.push(s.charAt(0));\\n        for(int i=1;i<n;i++)\\n        {\\n            if(!st.isEmpty()&&((s.charAt(i)==\\'B\\'&&st.peek()==\\'A\\')||(s.charAt(i)==\\'D\\'&&st.peek()==\\'C\\')))\\n            {\\n                st.pop();\\n            }\\n            else\\n                st.push(s.charAt(i));\\n        }\\n        return st.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549237,
                "title": "python-elegant-short-o-n-stack",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minLength(self, s: str) -> int:\\n        stack = []\\n\\n        for c in s:\\n            if stack and stack[-1] + c in (\\'AB\\', \\'CD\\'):\\n                stack.pop()\\n            else:\\n                stack.append(c)\\n\\n        return len(stack)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def minLength(self, s: str) -> int:\\n        stack = []\\n\\n        for c in s:\\n            if stack and stack[-1] + c in (\\'AB\\', \\'CD\\'):\\n                stack.pop()\\n            else:\\n                stack.append(c)\\n\\n        return len(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546752,
                "title": "c-solution-100-fast-o-n-tc-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe idea is to utilize a stack to simulate the removal of specific character pairs (\\'A\\' and \\'B\\', \\'C\\' and \\'D\\') from the input string. The final size of the stack corresponds to the minimum length of the string after performing the given operations\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe code iterates through each character in the input string s, which has a length of n.\\nFor each character, the code performs constant-time operations such as checking conditions, pushing onto or popping from the stack, and accessing the top of the stack\\nAs a result, the time complexity of the code can be approximated as **O(n)**, where n is the length of the input string.\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nExternal Stack Space  **O(N)**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        stack<char>st;\\n        for(auto x:s)\\n        {\\n            if(!st.empty() and ((x==\\'B\\' and st.top()==\\'A\\') || (x==\\'D\\' and  st.top()==\\'C\\')))\\n                st.pop();\\n            else\\n                 st.push(x);           \\n        }\\n         return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        stack<char>st;\\n        for(auto x:s)\\n        {\\n            if(!st.empty() and ((x==\\'B\\' and st.top()==\\'A\\') || (x==\\'D\\' and  st.top()==\\'C\\')))\\n                st.pop();\\n            else\\n                 st.push(x);           \\n        }\\n         return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547527,
                "title": "diagram-image-explaination-c-best-not-stack-well-explained",
                "content": "# Diagram\\n<!-- Describe your first thoughts on how to solve this problem. -->start\\n![code2flow_Gk6T30.png](https://assets.leetcode.com/users/images/cf6de703-6606-4ca3-be9e-adb172febd7f_1684650669.774286.png)\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe function removes all occurrences of the substrings \"AB\" and \"CD\" from the input string s using a while loop that continues until neither \"AB\" nor \"CD\" is found in s.\\n\\nInside the loop, the code checks if s contains \"AB\" or \"CD\" using the find() function. If either is found, it uses the erase() function to remove it from s.\\n\\nFinally, the length of the modified string s is returned.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n O(n^2),\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        string t1=\"AB\",t2=\"CD\";\\n        while(s.find(t1)!=string::npos||s.find(t2)!=string::npos)\\n        {\\n            if(s.find(t1)!=string::npos)\\n            {\\n                int o1=s.find(t1);\\n                s.erase(o1,2);\\n            }\\n            if(s.find(t2)!=string::npos)\\n            {\\n                int o2=s.find(t2);\\n                s.erase(o2,2);\\n            }\\n        \\n        }return s.length();\\n        \\n        \\n        \\n    }\\n};\\n```\\n![7abc56.jpg](https://assets.leetcode.com/users/images/124047a2-b9d1-49c8-a6cd-b6978298218f_1684650483.8916683.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        string t1=\"AB\",t2=\"CD\";\\n        while(s.find(t1)!=string::npos||s.find(t2)!=string::npos)\\n        {\\n            if(s.find(t1)!=string::npos)\\n            {\\n                int o1=s.find(t1);\\n                s.erase(o1,2);\\n            }\\n            if(s.find(t2)!=string::npos)\\n            {\\n                int o2=s.find(t2);\\n                s.erase(o2,2);\\n            }\\n        \\n        }return s.length();\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546997,
                "title": "beats-100-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minLength = function(s) {\\n    \\n    \\n    \\n        while( s.includes(\"AB\") || s.includes(\"CD\"))\\n            {\\n                if(s.includes(\"AB\"))\\n                s = s.replace(\"AB\",\"\")\\n\\n                if(s.includes(\"CD\"))\\n                s = s.replace(\"CD\", \\'\\')\\n            }\\n\\n        return s.length;\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minLength = function(s) {\\n    \\n    \\n    \\n        while( s.includes(\"AB\") || s.includes(\"CD\"))\\n            {\\n                if(s.includes(\"AB\"))\\n                s = s.replace(\"AB\",\"\")\\n\\n                if(s.includes(\"CD\"))\\n                s = s.replace(\"CD\", \\'\\')\\n            }\\n\\n        return s.length;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3546718,
                "title": "c-solution-using-stack",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n         stack<char> stack;\\n        for (char c : s) {\\n            if (!stack.empty() && stack.top() == \\'A\\' && c == \\'B\\') {\\n                stack.pop();\\n            } else if (!stack.empty() && stack.top() == \\'C\\' && c == \\'D\\') {\\n                stack.pop();\\n            } else {\\n                stack.push(c);\\n            }\\n        }\\n        return stack.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n         stack<char> stack;\\n        for (char c : s) {\\n            if (!stack.empty() && stack.top() == \\'A\\' && c == \\'B\\') {\\n                stack.pop();\\n            } else if (!stack.empty() && stack.top() == \\'C\\' && c == \\'D\\') {\\n                stack.pop();\\n            } else {\\n                stack.push(c);\\n            }\\n        }\\n        return stack.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3553067,
                "title": "python-3-4-lines-w-explanation-t-m-46-ms-16-mb",
                "content": "Here\\'s the plan:\\n\\nWe replace any instance of`\\'AB\\'`or`\\'CD\\'` with the null string. Doing so may produce more such strings, so we repeat this step until no replacements take place in a particular step. We determine that final step by monitoring`len(s)`. We return`len(s)`.\\n```\\nclass Solution:\\n    def minLength(self, s: str) -> int:\\n\\n        prev = len(s)+1\\n\\n        while len(s) < prev: s, prev = s.replace(\\'AB\\', \\'\\' ).replace(\\'CD\\', \\'\\'), len(s)\\n        \\n        return prev\\n```\\n[https://leetcode.com/problems/minimum-string-length-after-removing-substrings/submissions/954590578/](http://)\\n\\n\\nI could be wrong, but I think that time complexity is worst-case *O*(*N*^2) and space complexity is *O*(*N*), where *N* ~`len(s)`.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minLength(self, s: str) -> int:\\n\\n        prev = len(s)+1\\n\\n        while len(s) < prev: s, prev = s.replace(\\'AB\\', \\'\\' ).replace(\\'CD\\', \\'\\'), len(s)\\n        \\n        return prev\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547087,
                "title": "replace-with-empty",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minLength(self, s: str) -> int:\\n        while \"AB\" in s or \"CD\" in s:\\n            if \"AB\" in s:\\n                s = s.replace(\"AB\",\"\")\\n            elif \"CD\" in s:\\n                s = s.replace(\"CD\",\"\")\\n        return len(s)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minLength(self, s: str) -> int:\\n        while \"AB\" in s or \"CD\" in s:\\n            if \"AB\" in s:\\n                s = s.replace(\"AB\",\"\")\\n            elif \"CD\" in s:\\n                s = s.replace(\"CD\",\"\")\\n        return len(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547004,
                "title": "stack-c-easy-to-understand",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n//<!-- UPVOTE IF THIS CODE IS HELP FULL FOR YOU\\n// IF ANY SUGGETION YOU CAN COMMENT HERE.-->\\nclass Solution {\\npublic:\\n    int minLength(string str) {\\n        int ans = str.length();\\n        vector<char> s;\\n        for(auto &i: str){\\n            if(i==\\'A\\'||i==\\'C\\'){\\n                s.push_back(i);\\n            }else if(i==\\'B\\' && !s.empty()){\\n                if(s.back()==\\'A\\'){\\n                    s.pop_back();\\n                    ans -= 2;\\n                }else{\\n                    s.clear();\\n                }\\n            }else if(i==\\'D\\' && !s.empty()){\\n                if(s.back()==\\'C\\'){\\n                    s.pop_back();\\n                    ans -= 2;\\n                }else{\\n                    s.clear();\\n                }\\n            }else{\\n                s.clear();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\n//<!-- UPVOTE IF THIS CODE IS HELP FULL FOR YOU\\n// IF ANY SUGGETION YOU CAN COMMENT HERE.-->\\nclass Solution {\\npublic:\\n    int minLength(string str) {\\n        int ans = str.length();\\n        vector<char> s;\\n        for(auto &i: str){\\n            if(i==\\'A\\'||i==\\'C\\'){\\n                s.push_back(i);\\n            }else if(i==\\'B\\' && !s.empty()){\\n                if(s.back()==\\'A\\'){\\n                    s.pop_back();\\n                    ans -= 2;\\n                }else{\\n                    s.clear();\\n                }\\n            }else if(i==\\'D\\' && !s.empty()){\\n                if(s.back()==\\'C\\'){\\n                    s.pop_back();\\n                    ans -= 2;\\n                }else{\\n                    s.clear();\\n                }\\n            }else{\\n                s.clear();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546856,
                "title": "stack-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        string a;\\n        for(char c : s) {\\n            if(a.size()  && ((a.back() == \\'A\\' && c == \\'B\\') || (a.back() == \\'C\\' && c == \\'D\\')) )  a.pop_back();  \\n            else a.push_back(c);\\n        }\\n        return a.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        string a;\\n        for(char c : s) {\\n            if(a.size()  && ((a.back() == \\'A\\' && c == \\'B\\') || (a.back() == \\'C\\' && c == \\'D\\')) )  a.pop_back();  \\n            else a.push_back(c);\\n        }\\n        return a.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546730,
                "title": "short-clean-simple-java-solution",
                "content": "\\n```java []\\nclass Solution {\\n    public int minLength(String s) {\\n        Stack st = new Stack();\\n        for(char c: s.toCharArray()){\\n            if(!st.isEmpty() && (((char)st.peek() == \\'A\\' && c == \\'B\\') || ((char)st.peek() == \\'C\\' && c == \\'D\\'))) st.pop();\\n            else    st.push(c);\\n        }\\n        return st.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int minLength(String s) {\\n        Stack st = new Stack();\\n        for(char c: s.toCharArray()){\\n            if(!st.isEmpty() && (((char)st.peek() == \\'A\\' && c == \\'B\\') || ((char)st.peek() == \\'C\\' && c == \\'D\\'))) st.pop();\\n            else    st.push(c);\\n        }\\n        return st.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546719,
                "title": "day-416-one-pass-0ms-100-python-java-c-explained",
                "content": "# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe intuition behind the solution is to use a sliding window to scan the string and remove any consecutive pairs of characters that are equal to \"AB\" or \"CD\". The window starts at the beginning of the string and moves one character at a time to the right. When the window encounters a pair of characters that are equal to \"AB\" or \"CD\", the pair is removed from the string and the window is moved one character to the right. This process is repeated until the window reaches the end of the string. The length of the string after all pairs of characters have been removed is the minimum length of the string.\\n\\nThe approach is as follows:\\n\\nCreate a StringBuilder object to store the string.\\nInitialize a variable, i, to 0.\\nWhile i is less than the length of the string minus 1:\\nIf the characters at the current index and the next index are equal to \"AB\" or \"CD\":\\nRemove the characters at the current index and the next index from the string.\\nSet i to the maximum of 0 and i minus 1.\\nElse:\\nIncrement i by 1.\\nReturn the length of the string.\\nHere is a point-wise explanation of the approach:\\n\\nA StringBuilder object is created to store the string so that the characters can be easily manipulated.\\nA variable, i, is initialized to 0 to keep track of the current index in the string.\\nThe loop iterates until i reaches the length of the string minus 1.\\nInside the loop, the characters at the current index and the next index are checked to see if they are equal to \"AB\" or \"CD\".\\nIf the characters are equal to \"AB\" or \"CD\", then the characters are removed from the string and i is set to the maximum of 0 and i minus 1.\\nOtherwise, i is incremented by 1.\\nThe length of the string after all pairs of characters have been removed is returned.\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# JAVA \\n```\\nclass Solution {\\n    public int minLength(String s) {\\n        StringBuilder sb = new StringBuilder(s);\\n        int i=0;\\n        while(i<sb.length()-1){\\n            if(sb.charAt(i)==\\'A\\'&&sb.charAt(i+1)==\\'B\\'){\\n                sb.delete(i,i+2);\\n                i=Math.max(0,i-1);\\n            }\\n            else if (sb.charAt(i)==\\'C\\'&&sb.charAt(i+1)==\\'D\\'){\\n                sb.delete(i,i+2);\\n                i=Math.max(0,i-1);\\n            }else{\\n                i++;\\n            }\\n        }return sb.length();\\n        \\n    }\\n}\\n```\\n\\n# PY\\n\\n```\\n    def minLength(self, s: str) -> int:\\n        sb = list(s)\\n        i = 0\\n        while i < len(sb) - 1:\\n            if sb[i] == \\'A\\' and sb[i+1] == \\'B\\':\\n                del sb[i:i+2]\\n                i = max(0, i-1)\\n            elif sb[i] == \\'C\\' and sb[i+1] == \\'D\\':\\n                del sb[i:i+2]\\n                i = max(0, i-1)\\n            else:\\n                i += 1\\n        return len(sb)\\n```\\n\\n\\n# C++\\n\\n```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        string p;\\n        for (char c : s) {\\n            if ((c == \\'B\\' && !p.empty() && p.back() == \\'A\\') || (c == \\'D\\' && !p.empty() && p.back() == \\'C\\')) {\\n                p.pop_back();\\n            } else {\\n                p.push_back(c);\\n            }\\n        }\\n        return p.length();\\n    }\\n};\\n```\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n\\u2B06 \\u2B06 \\u2B06 \\u2B06 \\u2B06 \\u2B06 \\u2B06 \\u2B06 \\u2B06",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int minLength(String s) {\\n        StringBuilder sb = new StringBuilder(s);\\n        int i=0;\\n        while(i<sb.length()-1){\\n            if(sb.charAt(i)==\\'A\\'&&sb.charAt(i+1)==\\'B\\'){\\n                sb.delete(i,i+2);\\n                i=Math.max(0,i-1);\\n            }\\n            else if (sb.charAt(i)==\\'C\\'&&sb.charAt(i+1)==\\'D\\'){\\n                sb.delete(i,i+2);\\n                i=Math.max(0,i-1);\\n            }else{\\n                i++;\\n            }\\n        }return sb.length();\\n        \\n    }\\n}\\n```\n```\\n    def minLength(self, s: str) -> int:\\n        sb = list(s)\\n        i = 0\\n        while i < len(sb) - 1:\\n            if sb[i] == \\'A\\' and sb[i+1] == \\'B\\':\\n                del sb[i:i+2]\\n                i = max(0, i-1)\\n            elif sb[i] == \\'C\\' and sb[i+1] == \\'D\\':\\n                del sb[i:i+2]\\n                i = max(0, i-1)\\n            else:\\n                i += 1\\n        return len(sb)\\n```\n```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        string p;\\n        for (char c : s) {\\n            if ((c == \\'B\\' && !p.empty() && p.back() == \\'A\\') || (c == \\'D\\' && !p.empty() && p.back() == \\'C\\')) {\\n                p.pop_back();\\n            } else {\\n                p.push_back(c);\\n            }\\n        }\\n        return p.length();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547171,
                "title": "minimum-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minLength(self, s: str) -> int:\\n        \\n        \\n        for i in range(len(s)):\\n            if(\\'AB\\' in s):\\n                s=s.replace(\\'AB\\',\\'\\')\\n            if(\\'CD\\' in s):\\n                s=s.replace(\\'CD\\',\\'\\')\\n        return len(s)\\n        \\n        \\n        \\n        \\n        \\n       \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minLength(self, s: str) -> int:\\n        \\n        \\n        for i in range(len(s)):\\n            if(\\'AB\\' in s):\\n                s=s.replace(\\'AB\\',\\'\\')\\n            if(\\'CD\\' in s):\\n                s=s.replace(\\'CD\\',\\'\\')\\n        return len(s)\\n        \\n        \\n        \\n        \\n        \\n       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546840,
                "title": "simple-approach",
                "content": "\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int minLength(string str) {\\n        int sindex = str.find(\"CD\");\\n        int findex = str.find(\"AB\");\\n        \\n        if (sindex == -1 && findex == -1) {\\n            return str.length();\\n        }\\n        \\n        if (sindex == -1 || (findex != -1 && findex < sindex)) {\\n            str = str.substr(0, findex) + str.substr(findex + 2);\\n        } else {\\n            str = str.substr(0, sindex) + str.substr(sindex + 2);\\n        }\\n        \\n        return minLength(str);\\n    }\\n};\\n\\n```\\nIF YOU LIKE THE SOLUTION PLEASE DO UPVOTE .\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int minLength(string str) {\\n        int sindex = str.find(\"CD\");\\n        int findex = str.find(\"AB\");\\n        \\n        if (sindex == -1 && findex == -1) {\\n            return str.length();\\n        }\\n        \\n        if (sindex == -1 || (findex != -1 && findex < sindex)) {\\n            str = str.substr(0, findex) + str.substr(findex + 2);\\n        } else {\\n            str = str.substr(0, sindex) + str.substr(sindex + 2);\\n        }\\n        \\n        return minLength(str);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546712,
                "title": "use-stack-and-pop-if-b-or-d",
                "content": "```\\nclass Solution:\\n    def minLength(self, s: str) -> int:\\n        stack = []\\n        for c in s:\\n            if c == \"B\":\\n                if len(stack) > 0 and stack[-1] == \"A\":\\n                    stack.pop()\\n                else:\\n                    stack.append(c)\\n            elif c == \"D\":\\n                if len(stack) > 0 and stack[-1] == \"C\":\\n                    stack.pop()\\n                else:\\n                    stack.append(c)\\n            else:\\n                stack.append(c)\\n        return len(stack)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minLength(self, s: str) -> int:\\n        stack = []\\n        for c in s:\\n            if c == \"B\":\\n                if len(stack) > 0 and stack[-1] == \"A\":\\n                    stack.pop()\\n                else:\\n                    stack.append(c)\\n            elif c == \"D\":\\n                if len(stack) > 0 and stack[-1] == \"C\":\\n                    stack.pop()\\n                else:\\n                    stack.append(c)\\n            else:\\n                stack.append(c)\\n        return len(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977841,
                "title": "beats-92-easy-java-solution-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minLength(String s) {\\n        Stack<Character> st=new Stack();\\n        st.push(s.charAt(0));\\n        for(int i=1;i<s.length();i++){\\n            if(!st.isEmpty() &&((s.charAt(i)==\\'B\\' && st.peek()==\\'A\\') || s.charAt(i)==\\'D\\' && st.peek()==\\'C\\'))\\n            {\\n                st.pop();\\n            }\\n            else\\n            {\\n                st.push(s.charAt(i));\\n            }\\n        }\\n        return st.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int minLength(String s) {\\n        Stack<Character> st=new Stack();\\n        st.push(s.charAt(0));\\n        for(int i=1;i<s.length();i++){\\n            if(!st.isEmpty() &&((s.charAt(i)==\\'B\\' && st.peek()==\\'A\\') || s.charAt(i)==\\'D\\' && st.peek()==\\'C\\'))\\n            {\\n                st.pop();\\n            }\\n            else\\n            {\\n                st.push(s.charAt(i));\\n            }\\n        }\\n        return st.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3830759,
                "title": "easy-solution-in-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing string as a stack \\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        string temp =\"\";\\n        for(int i = 0;i<s.length(); i++)\\n        {\\n            if(temp.size() == 0)\\n            {\\n                temp += s[i];\\n            }\\n            else if(s[i] == \\'B\\' && temp.back() == \\'A\\' || s[i] == \\'D\\' && temp.back() == \\'C\\')\\n            {\\n                temp.pop_back();\\n            }\\n            else\\n            {\\n                temp += s[i];                \\n            }\\n        }\\n        return temp.length();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        string temp =\"\";\\n        for(int i = 0;i<s.length(); i++)\\n        {\\n            if(temp.size() == 0)\\n            {\\n                temp += s[i];\\n            }\\n            else if(s[i] == \\'B\\' && temp.back() == \\'A\\' || s[i] == \\'D\\' && temp.back() == \\'C\\')\\n            {\\n                temp.pop_back();\\n            }\\n            else\\n            {\\n                temp += s[i];                \\n            }\\n        }\\n        return temp.length();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3763035,
                "title": "simple-and-short-python-sol-stack",
                "content": "# Code\\n```\\nclass Solution:\\n    def minLength(self, s: str) -> int:\\n        stack = []\\n        for i in s:\\n            if len(stack) > 0 and ((stack[-1] == \\'A\\' and i == \\'B\\') or (stack[-1] == \\'C\\' and i == \\'D\\')):\\n                stack.pop()\\n            else:\\n                stack.append(i)\\n        return len(stack)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minLength(self, s: str) -> int:\\n        stack = []\\n        for i in s:\\n            if len(stack) > 0 and ((stack[-1] == \\'A\\' and i == \\'B\\') or (stack[-1] == \\'C\\' and i == \\'D\\')):\\n                stack.pop()\\n            else:\\n                stack.append(i)\\n        return len(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642113,
                "title": "easy-peasy-stack-implementation-beginner-friendly",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        int n=s.size();\\n        stack<char> stk;\\n        stk.push(\\'#\\');\\n        for(int i=0; i<n; i++){\\n            stk.push(s[i]);\\n\\n            if(stk.top()==\\'B\\'){\\n                stk.pop();\\n                if(stk.top()==\\'A\\') stk.pop();\\n                else stk.push(\\'B\\');\\n            }\\n\\n            else if(stk.top()==\\'D\\'){\\n                stk.pop();\\n                if(stk.top()==\\'C\\') stk.pop();\\n                else stk.push(\\'D\\');\\n            }\\n        }\\n        return stk.size()-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        int n=s.size();\\n        stack<char> stk;\\n        stk.push(\\'#\\');\\n        for(int i=0; i<n; i++){\\n            stk.push(s[i]);\\n\\n            if(stk.top()==\\'B\\'){\\n                stk.pop();\\n                if(stk.top()==\\'A\\') stk.pop();\\n                else stk.push(\\'B\\');\\n            }\\n\\n            else if(stk.top()==\\'D\\'){\\n                stk.pop();\\n                if(stk.top()==\\'C\\') stk.pop();\\n                else stk.push(\\'D\\');\\n            }\\n        }\\n        return stk.size()-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3575533,
                "title": "easy-java-solution-beats-100-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStack simulates removing \"AB\" and \"CD\" substrings iteratively.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Create a stack to store the characters.\\n- Iterate through the string by converting it to a character array.\\n- For each character c in the string:\\n  - If the stack is not empty and the current character c forms a substring with the top of the stack, i.e., \"AB\" or \"CD\", remove the top of the stack.\\n   - Otherwise, push the character c onto the stack.\\n- After iterating through all characters, return the size of the stack, which represents the minimum possible length of the resulting string.\\n# Complexity\\n- Time complexity: **O(n)**\\nn is the length of the input string. This is because we iterate through the string once, performing constant-time operations for each character.\\n\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(n)**\\nn is the length of the input string. In the worst case, if there are no consecutive \"AB\" or \"CD\" substrings to be removed, the stack can contain all the characters from the input string.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minLength(String s) {\\n        Stack<Character> st = new Stack<Character>();\\n\\n        for(Character c: s.toCharArray()){\\n            if( !st.isEmpty() && \\n            ((st.peek() == \\'A\\' && c == \\'B\\') || (st.peek() == \\'C\\' && c == \\'D\\')))\\n                st.pop();\\n            else\\n                st.push(c);\\n        }\\n        return st.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int minLength(String s) {\\n        Stack<Character> st = new Stack<Character>();\\n\\n        for(Character c: s.toCharArray()){\\n            if( !st.isEmpty() && \\n            ((st.peek() == \\'A\\' && c == \\'B\\') || (st.peek() == \\'C\\' && c == \\'D\\')))\\n                st.pop();\\n            else\\n                st.push(c);\\n        }\\n        return st.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3566181,
                "title": "python-solution-with-stack",
                "content": "\\n\\n# Code\\n```python\\nclass Solution:\\n    def minLength(self, s: str) -> int:\\n        stack = []\\n        for c in s:\\n            if not stack:\\n                stack.append(c)\\n            else:\\n                if stack and c == \"D\" and stack[-1] == \"C\":\\n                    stack.pop()\\n                elif stack and c == \"B\" and stack[-1] == \"A\":\\n                    stack.pop()\\n                else:\\n                    stack.append(c)\\n        return len(stack)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def minLength(self, s: str) -> int:\\n        stack = []\\n        for c in s:\\n            if not stack:\\n                stack.append(c)\\n            else:\\n                if stack and c == \"D\" and stack[-1] == \"C\":\\n                    stack.pop()\\n                elif stack and c == \"B\" and stack[-1] == \"A\":\\n                    stack.pop()\\n                else:\\n                    stack.append(c)\\n        return len(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3559887,
                "title": "two-pointers",
                "content": "**C++**\\n```cpp\\nint minLength(string s) {\\n    int j = 0;\\n    for (int i = 0; i < s.size(); ++i) {\\n        s[j] = s[i];\\n        j += j > 0 && (s[j - 1] == \\'A\\' || s[j - 1] == \\'C\\') && s[j - 1] == s[j] - 1 ? -1 : 1;\\n    }\\n    return j;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint minLength(string s) {\\n    int j = 0;\\n    for (int i = 0; i < s.size(); ++i) {\\n        s[j] = s[i];\\n        j += j > 0 && (s[j - 1] == \\'A\\' || s[j - 1] == \\'C\\') && s[j - 1] == s[j] - 1 ? -1 : 1;\\n    }\\n    return j;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3550188,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def minLength(self, s: str) -> int:\\n        ans=[]\\n        for char in s:\\n            if ans and (ans[-1]==\\'A\\' and char==\\'B\\' or ans[-1]==\\'C\\' and char==\\'D\\'):\\n                ans.pop()\\n\\n            else:\\n                ans.append(char)\\n\\n        return len(ans)                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minLength(self, s: str) -> int:\\n        ans=[]\\n        for char in s:\\n            if ans and (ans[-1]==\\'A\\' and char==\\'B\\' or ans[-1]==\\'C\\' and char==\\'D\\'):\\n                ans.pop()\\n\\n            else:\\n                ans.append(char)\\n\\n        return len(ans)                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547442,
                "title": "simple-understandable-solution",
                "content": "<!--  -->\\nUpvote if it helps !!\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nif AB or CD exists then update the string by removing those elements from the string using erase() function.\\nRun the loop untill you wont find any \\'AB\\' or \\'CD\\' \\n\\nFor those who dont know how erase(i,x) function works....\\nwe input 2 parameters in it :\\n1.i from where we want to erase the characters\\n2.x upto how many characters (from i) we want erase\\n\\nE.g: str=\"leetcode\"\\n\\nstr.erase(1,3)\\n\\nthen str updates as \"lcode\"\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRun a while loop to make sure you eliminate all the \\'AB\\' and \\'CD\\'\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        int count=1;\\n        while(count!=0){\\n            count=0;\\n            for(int i=0;i<s.length()-1;i++){\\n                if(s.length()==2){                  //Edge case condition\\n                    if(s[i]==\\'A\\'&&s[i+1]==\\'B\\'){\\n                        return 0;\\n                    \\n                    }\\n                    if(s[i]==\\'C\\'&&s[i+1]==\\'D\\'){\\n                        return 0;\\n                    }\\n                    \\n                }\\n                if(s[i]==\\'A\\'&&s[i+1]==\\'B\\'){         //Normal time condition\\n                    count++;\\n                    s.erase(i,2);\\n                    break;\\n                    \\n                }\\n                if(s[i]==\\'C\\'&&s[i+1]==\\'D\\'){\\n                    count++;\\n                    s.erase(i,2);\\n                    break;\\n                }\\n                \\n                \\n            }\\n            \\n        }\\n        \\n        return s.length();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        int count=1;\\n        while(count!=0){\\n            count=0;\\n            for(int i=0;i<s.length()-1;i++){\\n                if(s.length()==2){                  //Edge case condition\\n                    if(s[i]==\\'A\\'&&s[i+1]==\\'B\\'){\\n                        return 0;\\n                    \\n                    }\\n                    if(s[i]==\\'C\\'&&s[i+1]==\\'D\\'){\\n                        return 0;\\n                    }\\n                    \\n                }\\n                if(s[i]==\\'A\\'&&s[i+1]==\\'B\\'){         //Normal time condition\\n                    count++;\\n                    s.erase(i,2);\\n                    break;\\n                    \\n                }\\n                if(s[i]==\\'C\\'&&s[i+1]==\\'D\\'){\\n                    count++;\\n                    s.erase(i,2);\\n                    break;\\n                }\\n                \\n                \\n            }\\n            \\n        }\\n        \\n        return s.length();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547208,
                "title": "c-python-brute-force",
                "content": "# C++\\n```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        while(s.find(\"AB\") != -1 || s.find(\"CD\") != -1) {\\n            if(s.find(\"AB\") != -1) s.erase(s.find(\"AB\"), 2);\\n            if(s.find(\"CD\")!= -1) s.erase(s.find(\"CD\"), 2);\\n        }\\n        return s.size();                                  \\n    }\\n};\\n```\\n\\n# Python / Python3\\n```\\nclass Solution:\\n    def minLength(self, s: str) -> int:\\n        ans = s\\n        while(\"AB\" in ans or \"CD\" in ans):\\n            if(\"AB\" in ans):\\n                ind = ans.index(\"AB\")\\n                ans = ans[:ind] + ans[ind+2:]\\n            if(\"CD\" in ans):\\n                ind = ans.index(\"CD\")\\n                ans = ans[:ind] + ans[ind+2:]\\n        return len(ans)\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        while(s.find(\"AB\") != -1 || s.find(\"CD\") != -1) {\\n            if(s.find(\"AB\") != -1) s.erase(s.find(\"AB\"), 2);\\n            if(s.find(\"CD\")!= -1) s.erase(s.find(\"CD\"), 2);\\n        }\\n        return s.size();                                  \\n    }\\n};\\n```\n```\\nclass Solution:\\n    def minLength(self, s: str) -> int:\\n        ans = s\\n        while(\"AB\" in ans or \"CD\" in ans):\\n            if(\"AB\" in ans):\\n                ind = ans.index(\"AB\")\\n                ans = ans[:ind] + ans[ind+2:]\\n            if(\"CD\" in ans):\\n                ind = ans.index(\"CD\")\\n                ans = ans[:ind] + ans[ind+2:]\\n        return len(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547006,
                "title": "very-simple-python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def minLength(self, s: str) -> int:\\n        i = 1\\n        while i < len(s):\\n            if s[i-1] == \"A\":\\n                if s[i] == \"B\":\\n                    s = s[:i-1] + s[i+1:]\\n                    i = 0\\n            \\n            elif s[i-1] == \"C\":\\n                if s[i] == \"D\":\\n                    s = s[:i-1] + s[i+1:]\\n                    i = 0\\n            i += 1\\n        return len(s)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minLength(self, s: str) -> int:\\n        i = 1\\n        while i < len(s):\\n            if s[i-1] == \"A\":\\n                if s[i] == \"B\":\\n                    s = s[:i-1] + s[i+1:]\\n                    i = 0\\n            \\n            elif s[i-1] == \"C\":\\n                if s[i] == \"D\":\\n                    s = s[:i-1] + s[i+1:]\\n                    i = 0\\n            i += 1\\n        return len(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546954,
                "title": "easiest-java-solution-no-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minLength(String s) {\\n     while (s.contains(\"AB\") || s.contains(\"CD\")) {\\n            s = s.replaceAll(\"AB\", \"\").replaceAll(\"CD\", \"\");\\n        }\\n        return s.length();\\n    }\\n}\\n```\\n`**UPVOTE PLEASE**``\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minLength(String s) {\\n     while (s.contains(\"AB\") || s.contains(\"CD\")) {\\n            s = s.replaceAll(\"AB\", \"\").replaceAll(\"CD\", \"\");\\n        }\\n        return s.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546778,
                "title": "javascript-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minLength = function(s) {\\n    const st = [];\\n    for (const c of s) {\\n        if (st.length\\n            && (c === \\'B\\' && st[st.length - 1] === \\'A\\'\\n            || c === \\'D\\' && st[st.length - 1] === \\'C\\')\\n        ) {\\n            st.pop();\\n        } else {\\n            st.push(c);\\n        }\\n    }\\n    return st.length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minLength = function(s) {\\n    const st = [];\\n    for (const c of s) {\\n        if (st.length\\n            && (c === \\'B\\' && st[st.length - 1] === \\'A\\'\\n            || c === \\'D\\' && st[st.length - 1] === \\'C\\')\\n        ) {\\n            st.pop();\\n        } else {\\n            st.push(c);\\n        }\\n    }\\n    return st.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3546721,
                "title": "java-easy-solution-8-lines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int minLength(String s) {\\n    while (s.indexOf(\"AB\") >= 0 || s.indexOf(\"CD\") >= 0) {\\n      var a = s.indexOf(\"AB\");\\n      var b = s.indexOf(\"CD\");\\n      \\n      if (a >= 0)\\n        s = s.substring(0, a) + s.substring(a+2, s.length());\\n      else\\n        s = s.substring(0, b) + s.substring(b+2, s.length());\\n    }\\n    return s.length();\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int minLength(String s) {\\n    while (s.indexOf(\"AB\") >= 0 || s.indexOf(\"CD\") >= 0) {\\n      var a = s.indexOf(\"AB\");\\n      var b = s.indexOf(\"CD\");\\n      \\n      if (a >= 0)\\n        s = s.substring(0, a) + s.substring(a+2, s.length());\\n      else\\n        s = s.substring(0, b) + s.substring(b+2, s.length());\\n    }\\n    return s.length();\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4032737,
                "title": "using-stack-by-checking-2-elements-on-top-of-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        stack<char> stt;\\n        stt.push(\\'-\\');\\n        for(int i=0;i<s.size();i++){\\n            int curr=s[i];\\n            stt.push(curr);\\n            if(stt.top()==\\'B\\'){\\n                stt.pop();\\n                if(stt.top()==\\'A\\'){\\n                    stt.pop();\\n                }else{\\n                    stt.push(\\'B\\');\\n                }\\n            }\\n            else if(stt.top()==\\'D\\'){\\n                stt.pop();\\n                if(stt.top()==\\'C\\'){\\n                    stt.pop();\\n                }else{\\n                    stt.push(\\'D\\');\\n                }\\n            }\\n        }\\n        return stt.size()-1;\\n    }\\n};\\n\\n//watched soltions\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        stack<char> stt;\\n        stt.push(\\'-\\');\\n        for(int i=0;i<s.size();i++){\\n            int curr=s[i];\\n            stt.push(curr);\\n            if(stt.top()==\\'B\\'){\\n                stt.pop();\\n                if(stt.top()==\\'A\\'){\\n                    stt.pop();\\n                }else{\\n                    stt.push(\\'B\\');\\n                }\\n            }\\n            else if(stt.top()==\\'D\\'){\\n                stt.pop();\\n                if(stt.top()==\\'C\\'){\\n                    stt.pop();\\n                }else{\\n                    stt.push(\\'D\\');\\n                }\\n            }\\n        }\\n        return stt.size()-1;\\n    }\\n};\\n\\n//watched soltions\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3950755,
                "title": "easy-solution-using-only-stack-o-n",
                "content": "# Approach\\nYou should use a stack for this task. Just in the loop check your last element in stack + s[i] to \\'AB\\' and \\'CD\\' and if it is true just remove from stak element or push the element and in the end you\\'ll see the length of stack\\n\\ns[0] = \\'**A**BFCACDB\\' stack = [\\'A\\'];\\ns[1] = \\'A**B**FCACDB\\' stack.pop() => [];\\ns[2] = \\'AB**F**CACDB\\' stack = [\\'F\\'];\\ns[3] = \\'ABF**C**ACDB\\' stack = [\\'F\\', \\'C\\'];\\ns[4] = \\'ABFC**A**CDB\\' stack = [\\'F\\', \\'C\\', \\'A\\'];\\ns[5] = \\'ABFCA**C**DB\\' stack = [\\'F\\', \\'C\\', \\'A\\', \\'C\\'];\\ns[6] = \\'ABFCAC**D**B\\' stack.pop() => [\\'F\\', \\'C\\', \\'A\\'];\\ns[7] = \\'ABFCACD**B**\\' stack.pop() => [\\'F\\', \\'C\\'];\\n\\nstack.length => 2\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction minLength(s: string): number {\\n    const stack: string[] = [];\\n\\n    for (let i = 0; i < s.length; i++) {\\n        if (stack[stack.length - 1] + s[i] !== \\'AB\\' && stack[stack.length - 1] + s[i] !== \\'CD\\') {\\n            stack.push(s[i]);\\n        } else {\\n            stack.pop();\\n        }\\n    }\\n\\n    return stack.length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Stack"
                ],
                "code": "```\\nfunction minLength(s: string): number {\\n    const stack: string[] = [];\\n\\n    for (let i = 0; i < s.length; i++) {\\n        if (stack[stack.length - 1] + s[i] !== \\'AB\\' && stack[stack.length - 1] + s[i] !== \\'CD\\') {\\n            stack.push(s[i]);\\n        } else {\\n            stack.pop();\\n        }\\n    }\\n\\n    return stack.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3749985,
                "title": "easiest-approach-just-5-lines-of-code-java",
                "content": "# Code\\n```\\nclass Solution{\\n    public int minLength(String s){\\n        Stack<Character> st = new Stack<>();\\n        for(int i=0; i<s.length(); i++){\\n            if(!st.isEmpty() && st.peek()==\\'A\\' && s.charAt(i)==\\'B\\') st.pop();\\n            else if(!st.isEmpty() && st.peek()==\\'C\\' && s.charAt(i)==\\'D\\') st.pop();\\n            else st.push(s.charAt(i));\\n        }\\n        return st.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution{\\n    public int minLength(String s){\\n        Stack<Character> st = new Stack<>();\\n        for(int i=0; i<s.length(); i++){\\n            if(!st.isEmpty() && st.peek()==\\'A\\' && s.charAt(i)==\\'B\\') st.pop();\\n            else if(!st.isEmpty() && st.peek()==\\'C\\' && s.charAt(i)==\\'D\\') st.pop();\\n            else st.push(s.charAt(i));\\n        }\\n        return st.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580897,
                "title": "minimum-string-length-after-removing-substrings-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*m)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        int i=0, n;\\n        while(true)\\n        {\\n            n = s.length();\\n            for(i=0 ; i<s.length()-1 ; i++)\\n            {\\n                if((s[i]==\\'A\\' && s[i+1]==\\'B\\') || (s[i]==\\'C\\' && s[i+1]==\\'D\\'))\\n                {\\n                    s.erase(s.begin()+i);\\n                    s.erase(s.begin()+i);\\n                    break;\\n                }\\n            }\\n            if(s.length()==0)\\n                return 0;\\n            if(n==s.length())\\n                break;\\n        }\\n        return n;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/579ae989-a1a0-44cf-ab17-a0608c828907_1685509077.1589718.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        int i=0, n;\\n        while(true)\\n        {\\n            n = s.length();\\n            for(i=0 ; i<s.length()-1 ; i++)\\n            {\\n                if((s[i]==\\'A\\' && s[i+1]==\\'B\\') || (s[i]==\\'C\\' && s[i+1]==\\'D\\'))\\n                {\\n                    s.erase(s.begin()+i);\\n                    s.erase(s.begin()+i);\\n                    break;\\n                }\\n            }\\n            if(s.length()==0)\\n                return 0;\\n            if(n==s.length())\\n                break;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569491,
                "title": "java-sol-bruteforce-stack-implementation-o-n-o-1-time-space-complexity",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity(Brute Force)\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n- N is length of given String.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Complexity(Stack)\\n- Time complexity:O(N)\\nN is length of given String.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# #1Code (Brute Force Approach)\\n```\\nclass Solution {\\n    public int minLength(String s) {\\n        if(s.length()==1){\\n            return 1;\\n        }\\n        List<Character> li=new ArrayList<Character>();\\n\\n        for(int i=0;i<s.length();i++){\\n            li.add(s.charAt(i));\\n        }\\n        boolean flag=true;\\n        while(flag ){\\n            flag=false;\\n            for(int i=0;i<li.size()-1;i++){\\n            if(li.get(i)==\\'A\\' && li.get(i+1)==\\'B\\'){\\n                li.remove(i);\\n                li.remove(i);\\n                System.out.print(\"ab\");\\n                flag=true;\\n            }\\n            else if(li.get(i)==\\'C\\' && li.get(i+1)==\\'D\\'){\\n                li.remove(i);\\n                li.remove(i);\\n                flag=true;\\n            }\\n        }\\n    }\\n        return li.size();\\n    }\\n}\\n```\\n# #2Code (Stack Implementation)\\n```\\nclass Solution {\\n    public int minLength(String s) {\\n        if(s.length()==1){\\n            return 1;\\n        }\\n        Stack st=new Stack();\\n        for(int i=0;i<s.length();i++){\\n            char c= s.charAt(i);\\n            if(st.isEmpty()==false && (((char)st.peek()==\\'A\\'&& c==\\'B\\') || ((char)st.peek()==\\'C\\' && c==\\'D\\')) ){\\n                st.pop();\\n            }\\n            else{\\n                st.push(c);\\n            }\\n        }\\n        return st.size();\\n    }\\n}\\n```\\n# An Upvote will be encouraging \\uD83D\\uDC4D",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minLength(String s) {\\n        if(s.length()==1){\\n            return 1;\\n        }\\n        List<Character> li=new ArrayList<Character>();\\n\\n        for(int i=0;i<s.length();i++){\\n            li.add(s.charAt(i));\\n        }\\n        boolean flag=true;\\n        while(flag ){\\n            flag=false;\\n            for(int i=0;i<li.size()-1;i++){\\n            if(li.get(i)==\\'A\\' && li.get(i+1)==\\'B\\'){\\n                li.remove(i);\\n                li.remove(i);\\n                System.out.print(\"ab\");\\n                flag=true;\\n            }\\n            else if(li.get(i)==\\'C\\' && li.get(i+1)==\\'D\\'){\\n                li.remove(i);\\n                li.remove(i);\\n                flag=true;\\n            }\\n        }\\n    }\\n        return li.size();\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minLength(String s) {\\n        if(s.length()==1){\\n            return 1;\\n        }\\n        Stack st=new Stack();\\n        for(int i=0;i<s.length();i++){\\n            char c= s.charAt(i);\\n            if(st.isEmpty()==false && (((char)st.peek()==\\'A\\'&& c==\\'B\\') || ((char)st.peek()==\\'C\\' && c==\\'D\\')) ){\\n                st.pop();\\n            }\\n            else{\\n                st.push(c);\\n            }\\n        }\\n        return st.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3563076,
                "title": "go-solution-100",
                "content": "# Intuition\\nUse a stack to keep track of previous letter - if we find AB/CD, the top of the stack keeps track of the letter before AB/CD, therefore we can match the next character to that letter.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nfunc minLength(s string) int {\\n    stack := []byte{}\\n    for i:=0; i<len(s); i++ {\\n        if len(stack) > 0 && ((stack[len(stack)-1] == \\'A\\' && s[i] == \\'B\\') || (stack[len(stack)-1] == \\'C\\' && s[i] == \\'D\\')) {\\n            stack = stack[:len(stack)-1]\\n        } else {\\n            stack = append(stack, s[i])\\n        }\\n    }\\n    return len(stack)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minLength(s string) int {\\n    stack := []byte{}\\n    for i:=0; i<len(s); i++ {\\n        if len(stack) > 0 && ((stack[len(stack)-1] == \\'A\\' && s[i] == \\'B\\') || (stack[len(stack)-1] == \\'C\\' && s[i] == \\'D\\')) {\\n            stack = stack[:len(stack)-1]\\n        } else {\\n            stack = append(stack, s[i])\\n        }\\n    }\\n    return len(stack)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3553057,
                "title": "simpleapproach-using-stack-o-n",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Initialise a stack `stack<char> st` and push the first character element of the string in the stack and now check the condition wether `AB` or `CD` is present in the string or not.\\n- If `st.top()==\\'A\\'` and ith string element is `B` then `st.pop()`.\\n- If `st.top()==\\'C\\'` and ith string element is `D` then `st.pop()`.\\n- Otherwise push the element in the stack.\\n- return stack size.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        if(s.size()==1) return 1;\\n        stack<char> st;\\n        st.push(s[0]);\\n        for(int i=1;i<s.size();i++){\\n            if(!st.empty() && ((st.top()==\\'A\\' && s[i]==\\'B\\') || (st.top()==\\'C\\' && s[i]==\\'D\\'))) st.pop();\\n            else st.push(s[i]);\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        if(s.size()==1) return 1;\\n        stack<char> st;\\n        st.push(s[0]);\\n        for(int i=1;i<s.size();i++){\\n            if(!st.empty() && ((st.top()==\\'A\\' && s[i]==\\'B\\') || (st.top()==\\'C\\' && s[i]==\\'D\\'))) st.pop();\\n            else st.push(s[i]);\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3551142,
                "title": "stack-solution",
                "content": "```\\nclass Solution {\\n    func minLength(_ s: String) -> Int {\\n        var stack = [Character]()\\n        let arr = Array(s)\\n        for c in arr {\\n            if !stack.isEmpty {\\n                let top = stack.last!\\n                if (top == \"A\" && c == \"B\") || (top == \"C\" && c == \"D\") {\\n                    _ = stack.removeLast()\\n                } else {\\n                    stack.append(c)\\n                }\\n            } else {\\n                stack.append(c)\\n            }\\n        }\\n        return stack.count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    func minLength(_ s: String) -> Int {\\n        var stack = [Character]()\\n        let arr = Array(s)\\n        for c in arr {\\n            if !stack.isEmpty {\\n                let top = stack.last!\\n                if (top == \"A\" && c == \"B\") || (top == \"C\" && c == \"D\") {\\n                    _ = stack.removeLast()\\n                } else {\\n                    stack.append(c)\\n                }\\n            } else {\\n                stack.append(c)\\n            }\\n        }\\n        return stack.count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3548152,
                "title": "easy-python-solution-using-replace",
                "content": "```\\nclass Solution:\\n    def minLength(self, s: str) -> int:\\n        while \\'AB\\' in s or \\'CD\\' in s:\\n            if \\'AB\\' in s:\\n                s=s.replace(\\'AB\\',\\'\\')\\n            elif \\'CD\\' in s:\\n                s=s.replace(\\'CD\\',\\'\\')\\n        return len(s)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def minLength(self, s: str) -> int:\\n        while \\'AB\\' in s or \\'CD\\' in s:\\n            if \\'AB\\' in s:\\n                s=s.replace(\\'AB\\',\\'\\')\\n            elif \\'CD\\' in s:\\n                s=s.replace(\\'CD\\',\\'\\')\\n        return len(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3548101,
                "title": "cpp-solution-with-stack",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        stack<char>st;\\n        int i=0,n=s.size();\\n        while(i<n){\\n            if(st.size()==0)st.push(s[i]);\\n            else{\\n                if(s[i]==\\'B\\' and st.top()==\\'A\\')st.pop();\\n                else if(s[i]==\\'D\\' and st.top()==\\'C\\')st.pop();\\n                else st.push(s[i]);\\n            }\\n            \\n            i++;\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        stack<char>st;\\n        int i=0,n=s.size();\\n        while(i<n){\\n            if(st.size()==0)st.push(s[i]);\\n            else{\\n                if(s[i]==\\'B\\' and st.top()==\\'A\\')st.pop();\\n                else if(s[i]==\\'D\\' and st.top()==\\'C\\')st.pop();\\n                else st.push(s[i]);\\n            }\\n            \\n            i++;\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547803,
                "title": "c-beats-100-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Stack\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Initialize a stack to store the characters of the resulting string.\\n- Iterate through each character c in the given string s.\\n- If the stack is empty, push the current character onto the stack.\\n- If the current character is \\'B\\':\\n      (+)Check if the top of the stack is \\'A\\' and the stack is not empty. If so, it means we have encountered the substring \"AB\", and we can remove it by popping \\'A\\' from the stack.\\n      (+)If the above condition is not met, push the current character onto the stack.\\n- If the current character is \\'D\\':\\n      (+) Check if the top of the stack is \\'C\\' and the stack is not empty. If so, it means we have encountered the substring \"CD\", and we can remove it by popping \\'C\\' from the stack.\\n      (+)If the above condition is not met, push the current character onto the stack.\\n\\n- If the current character is neither \\'B\\' nor \\'D\\', push it onto the stack.\\n\\n- After iterating through all the characters in s, the stack will contain the characters of the resulting string.\\n\\n- Return the size of the stack, which represents the minimum possible length of the resulting string.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minLength(string s) \\n    {\\n        int n = s.size();\\n        stack <char> st;\\n        \\n        for(int i = 0; i < n; i++)\\n        {   \\n            if(st.empty())\\n                st.push(s[i]);\\n            \\n            else if(s[i] == \\'B\\')\\n            {\\n                if(st.top() == \\'A\\' && !st.empty())\\n                    st.pop();\\n                else\\n                    st.push(s[i]);\\n            }\\n            \\n            else if(s[i] == \\'D\\')\\n            {\\n                if(st.top() == \\'C\\' && !st.empty())\\n                    st.pop();\\n                else\\n                    st.push(s[i]);\\n            }\\n            \\n            else\\n                st.push(s[i]);\\n        }\\n        \\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minLength(string s) \\n    {\\n        int n = s.size();\\n        stack <char> st;\\n        \\n        for(int i = 0; i < n; i++)\\n        {   \\n            if(st.empty())\\n                st.push(s[i]);\\n            \\n            else if(s[i] == \\'B\\')\\n            {\\n                if(st.top() == \\'A\\' && !st.empty())\\n                    st.pop();\\n                else\\n                    st.push(s[i]);\\n            }\\n            \\n            else if(s[i] == \\'D\\')\\n            {\\n                if(st.top() == \\'C\\' && !st.empty())\\n                    st.pop();\\n                else\\n                    st.push(s[i]);\\n            }\\n            \\n            else\\n                st.push(s[i]);\\n        }\\n        \\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547701,
                "title": "python3-replace",
                "content": "Just replace the present combinations of letters while they are in the string.\\n```\\nclass Solution:\\n    def minLength(self, s: str) -> int:\\n        while \\'AB\\' in s or \\'CD\\' in s:\\n            s = s.replace(\\'AB\\', \\'\\').replace(\\'CD\\', \\'\\')\\n            \\n        return len(s)\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minLength(self, s: str) -> int:\\n        while \\'AB\\' in s or \\'CD\\' in s:\\n            s = s.replace(\\'AB\\', \\'\\').replace(\\'CD\\', \\'\\')\\n            \\n        return len(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547422,
                "title": "simple-stack-c-beats-100",
                "content": "# Intuition\\nSeems like a stack problem.\\n\\n# Approach\\nUse stack to keep track of current element and the last element pushed in stack.\\n\\nIf the last char pushed was `\\'A\\'` and current char is `\\'B\\'` it means that an occurence of string \"AB\" is found.\\nSimilary, if the last char pushed was \\'C\\' and current char is `\\'D\\'` it means that an occurence of string \"CD\" is found.\\n\\nIn both of these cases we pop the top element and and we don\\'t need to push the cuurent element ad we to delete occurence of string `\"AB\"`\\nand string `\"CD\"`.\\n\\nAt the end our stack won\\'t an occurence of string `\"AB\"`\\nor string `\"CD\"`.\\nHence we can return its length as answer.\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int minLength(string &s) \\n    {\\n        stack<char>st;\\n        for(char &c:s)\\n        {\\n            if(st.empty())st.push(c);\\n            else\\n            {\\n                if(c == \\'B\\' and st.top() == \\'A\\')st.pop();\\n                else if(c == \\'D\\' and st.top() == \\'C\\')st.pop();\\n                else st.push(c);\\n            }\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int minLength(string &s) \\n    {\\n        stack<char>st;\\n        for(char &c:s)\\n        {\\n            if(st.empty())st.push(c);\\n            else\\n            {\\n                if(c == \\'B\\' and st.top() == \\'A\\')st.pop();\\n                else if(c == \\'D\\' and st.top() == \\'C\\')st.pop();\\n                else st.push(c);\\n            }\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547315,
                "title": "easy-solution-using-replace-function-in-python",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def minLength(self, s: str) -> int:\\n        i=0\\n    # for i in range(len(s)):\\n        while i<len(s):\\n            if(s[i:i+2]==\\'AB\\' or s[i:i+2]==\\'CD\\'):\\n                s=s.replace(s[i:i+2],\"\")\\n                i=0\\n            else:\\n                i+=1\\n        \\n        return len(s)\\n    \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minLength(self, s: str) -> int:\\n        i=0\\n    # for i in range(len(s)):\\n        while i<len(s):\\n            if(s[i:i+2]==\\'AB\\' or s[i:i+2]==\\'CD\\'):\\n                s=s.replace(s[i:i+2],\"\")\\n                i=0\\n            else:\\n                i+=1\\n        \\n        return len(s)\\n    \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547094,
                "title": "easy-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   \\n    int minLength(string s) {\\n\\n         int size = 0;\\n         int i = 0;\\n\\n        while(size != s.size()) {\\n                  string temp = \"\";\\n                  int i = 0;\\n                 \\n                 while(i < s.size()){    \\n                   if((s[i] == \\'A\\' &&s[i+1] == \\'B\\') || (s[i] == \\'C\\' && s[i+1] == \\'D\\')) i += 2; \\n                   else temp +=s[i++];\\n              }\\n\\n            size = s.size();\\n            swap(s,temp);\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    int minLength(string s) {\\n\\n         int size = 0;\\n         int i = 0;\\n\\n        while(size != s.size()) {\\n                  string temp = \"\";\\n                  int i = 0;\\n                 \\n                 while(i < s.size()){    \\n                   if((s[i] == \\'A\\' &&s[i+1] == \\'B\\') || (s[i] == \\'C\\' && s[i+1] == \\'D\\')) i += 2; \\n                   else temp +=s[i++];\\n              }\\n\\n            size = s.size();\\n            swap(s,temp);\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547034,
                "title": "simple-stack-solution-easy-to-understand",
                "content": "# Intuition\\nIf we have A and then B occurs, we have to discard A and B.\\nSimilarly, if we have C and D occurs, we have to discard C and D.\\n\\n# Approach\\nStack is the key for such type of problems.\\n- **(Case 1)** If the top of the stack is \\'A\\' and the current element is \\'B\\'. Pop the stack in the operation. Thus it will exclude \\'A\\' and \\'B\\'. Else, push the current element in the stack.\\n- **(Case 2)** Similarly, If the top of the stack is \\'C\\' and the current element is \\'D\\'. Pop the stack in the operation. Thus it will exclude \\'C\\' and \\'D\\'. Else push the current element in the stack.\\n- **(Case 3)** Otherwise, just push the character in the stack and thus including it.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        stack<char> st;\\n        for(int i=0;i<s.size();i++){\\n            if(st.size() && st.top()==\\'A\\'){\\n                if(s[i]==\\'B\\') st.pop();  //CASE 1\\n                else st.push(s[i]);    \\n            }\\n            else if(st.size() && st.top()==\\'C\\'){\\n                if(s[i]==\\'D\\') st.pop();  //CASE 2\\n                else st.push(s[i]);\\n            }\\n            else st.push(s[i]);  //CASE 3\\n        }\\n        return st.size();\\n    }\\n};\\n```\\n**Please upvote if it helped. Happy Coding!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        stack<char> st;\\n        for(int i=0;i<s.size();i++){\\n            if(st.size() && st.top()==\\'A\\'){\\n                if(s[i]==\\'B\\') st.pop();  //CASE 1\\n                else st.push(s[i]);    \\n            }\\n            else if(st.size() && st.top()==\\'C\\'){\\n                if(s[i]==\\'D\\') st.pop();  //CASE 2\\n                else st.push(s[i]);\\n            }\\n            else st.push(s[i]);  //CASE 3\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547005,
                "title": "c-stack-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        stack<char>st;\\n        for(int i=0; i<s.size(); i++){\\n            if(st.empty()){\\n                st.push(s[i]);\\n            }\\n            else{\\n                if(!st.empty() && st.top()==\\'A\\' && s[i]==\\'B\\'){\\n                    st.pop();\\n                }\\n                else if(!st.empty() && st.top()==\\'C\\' && s[i]==\\'D\\'){\\n                    st.pop();\\n                }\\n                else{\\n                    st.push(s[i]);\\n                }\\n            }\\n        }\\n        string ans=\"\";\\n        while(!st.empty()){\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        stack<char>st;\\n        for(int i=0; i<s.size(); i++){\\n            if(st.empty()){\\n                st.push(s[i]);\\n            }\\n            else{\\n                if(!st.empty() && st.top()==\\'A\\' && s[i]==\\'B\\'){\\n                    st.pop();\\n                }\\n                else if(!st.empty() && st.top()==\\'C\\' && s[i]==\\'D\\'){\\n                    st.pop();\\n                }\\n                else{\\n                    st.push(s[i]);\\n                }\\n            }\\n        }\\n        string ans=\"\";\\n        while(!st.empty()){\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546988,
                "title": "simple-java-solution-stringbuilder",
                "content": "**Approach:**\\nWe simply iterate over the StringBuilder until it contains \"AB\" or \"CD\" and then inside the loop we use of indexOf() to calculate the index of \"AB\" and \"CD\" and then delete their occurences using delete() method from Stringbuilder and atlast return the size of StringBuilder after removing each occurences of \"AB\" and \"CD\".\\n\\n```class Solution {\\n    public int minLength(String s) {\\n        StringBuilder sb = new StringBuilder(s);\\n        while (sb.toString().contains(\"AB\") || sb.toString().contains(\"CD\")) {\\n            int i = sb.indexOf(\"AB\");\\n            if (i != -1)\\n                sb.delete(i, i + 2);\\n            int j = sb.indexOf(\"CD\");\\n            if (j != -1)\\n                sb.delete(j, j + 2);\\n        }\\n        return sb.length();\\n    }\\n}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minLength(String s) {\\n        StringBuilder sb = new StringBuilder(s);\\n        while (sb.toString().contains(\"AB\") || sb.toString().contains(\"CD\")) {\\n            int i = sb.indexOf(\"AB\");\\n            if (i != -1)\\n                sb.delete(i, i + 2);\\n            int j = sb.indexOf(\"CD\");\\n            if (j != -1)\\n                sb.delete(j, j + 2);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3546945,
                "title": "easiest-stack-based-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        int n=s.length();\\n        stack<char>st;\\n        st.push(s[0]);\\n        for(int i=1; i<n; i++)\\n        {\\n            char z;\\n            if(!st.empty())\\n             z=st.top();\\n            \\n            if(!st.empty()and z==\\'A\\' && s[i]==\\'B\\')\\n            {\\n                st.pop();\\n             \\n            }\\n            else if(!st.empty() and z==\\'C\\' && s[i]==\\'D\\')\\n            {\\n                st.pop();\\n            }\\n            else\\n            {\\n                st.push(s[i]);\\n            }\\n        }\\n        int t=st.size();\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        int n=s.length();\\n        stack<char>st;\\n        st.push(s[0]);\\n        for(int i=1; i<n; i++)\\n        {\\n            char z;\\n            if(!st.empty())\\n             z=st.top();\\n            \\n            if(!st.empty()and z==\\'A\\' && s[i]==\\'B\\')\\n            {\\n                st.pop();\\n             \\n            }\\n            else if(!st.empty() and z==\\'C\\' && s[i]==\\'D\\')\\n            {\\n                st.pop();\\n            }\\n            else\\n            {\\n                st.push(s[i]);\\n            }\\n        }\\n        int t=st.size();\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546944,
                "title": "easy-and-simple-to-understand-solution-python",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def minLength(self, s: str) -> int:\\n        is_AB = False\\n        is_CD = False\\n        while True :\\n            if \"AB\" in s :\\n                s = s.replace(\"AB\",\"\")\\n                is_AB = True\\n            else :\\n                is_AB = False\\n                \\n            if \"CD\" in s :\\n                s = s.replace(\"CD\",\"\")\\n                is_CD = True\\n            else :\\n                is_CD = False\\n            \\n            if not is_AB and not is_CD :\\n                return len(s)\\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minLength(self, s: str) -> int:\\n        is_AB = False\\n        is_CD = False\\n        while True :\\n            if \"AB\" in s :\\n                s = s.replace(\"AB\",\"\")\\n                is_AB = True\\n            else :\\n                is_AB = False\\n                \\n            if \"CD\" in s :\\n                s = s.replace(\"CD\",\"\")\\n                is_CD = True\\n            else :\\n                is_CD = False\\n            \\n            if not is_AB and not is_CD :\\n                return len(s)\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546943,
                "title": "java-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minLength(String s) {\\n        StringBuilder sb = new StringBuilder(s);\\n        boolean occur = true;\\n        \\n        while(occur){\\n            occur = false;\\n            \\n            int index_ab = sb.indexOf(\"AB\");\\n            if(index_ab>=0){\\n                sb.delete(index_ab,index_ab+2);\\n                occur = true;\\n            }\\n            \\n            int index_cd = sb.indexOf(\"CD\");\\n            if(index_cd>=0){\\n                sb.delete(index_cd,index_cd+2);\\n                occur = true;\\n            }\\n            \\n        }\\n        \\n        return sb.length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minLength(String s) {\\n        StringBuilder sb = new StringBuilder(s);\\n        boolean occur = true;\\n        \\n        while(occur){\\n            occur = false;\\n            \\n            int index_ab = sb.indexOf(\"AB\");\\n            if(index_ab>=0){\\n                sb.delete(index_ab,index_ab+2);\\n                occur = true;\\n            }\\n            \\n            int index_cd = sb.indexOf(\"CD\");\\n            if(index_cd>=0){\\n                sb.delete(index_cd,index_cd+2);\\n                occur = true;\\n            }\\n            \\n        }\\n        \\n        return sb.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546811,
                "title": "very-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n    \\n        int n=s.size();\\n        int cnt=0;\\n       \\n        \\n    for(int j=0;j<100;j++){\\n        int i=0;\\n        while(i<s.size()){\\n            if(i!=n-1)if((s[i]==\\'A\\' && s[i+1]==\\'B\\') || (s[i]==\\'C\\' && s[i+1]==\\'D\\')){\\n                s.erase(i,2);\\n                cnt+=2;\\n                i--;\\n            }\\n           i++;\\n        }\\n    }   \\n        return s.size();\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n    \\n        int n=s.size();\\n        int cnt=0;\\n       \\n        \\n    for(int j=0;j<100;j++){\\n        int i=0;\\n        while(i<s.size()){\\n            if(i!=n-1)if((s[i]==\\'A\\' && s[i+1]==\\'B\\') || (s[i]==\\'C\\' && s[i+1]==\\'D\\')){\\n                s.erase(i,2);\\n                cnt+=2;\\n                i--;\\n            }\\n           i++;\\n        }\\n    }   \\n        return s.size();\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546808,
                "title": "easy-java-solution",
                "content": "\\n- Time complexity:\\n- Space complexity:\\n\\n```\\nclass Solution {\\n    public int minLength(String s) {\\n     \\n     StringBuilder s1=new StringBuilder(s);\\n     while(true)   \\n     {\\n         boolean checker=true;\\n         for(int i=0;i<s1.length()-1;i++)\\n         {\\n             char a=s1.charAt(i);\\n             char b=s1.charAt(i+1);\\n             if((a==\\'A\\' && b==\\'B\\')||(a==\\'C\\' && b==\\'D\\')){ \\n                 s1.deleteCharAt(i);\\n                 s1.deleteCharAt(i);\\n                 checker=false;\\n             }\\n         }\\n         if(checker) break;\\n     }\\n     return s1.length();   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minLength(String s) {\\n     \\n     StringBuilder s1=new StringBuilder(s);\\n     while(true)   \\n     {\\n         boolean checker=true;\\n         for(int i=0;i<s1.length()-1;i++)\\n         {\\n             char a=s1.charAt(i);\\n             char b=s1.charAt(i+1);\\n             if((a==\\'A\\' && b==\\'B\\')||(a==\\'C\\' && b==\\'D\\')){ \\n                 s1.deleteCharAt(i);\\n                 s1.deleteCharAt(i);\\n                 checker=false;\\n             }\\n         }\\n         if(checker) break;\\n     }\\n     return s1.length();   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546788,
                "title": "c-simplest-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        int x = s.size();\\n        stack<char>st;\\n        st.push(s[0]);\\n        for(int i=1;i<x;i++){ \\n            if(!st.empty() and st.top()==\\'A\\' and s[i]==\\'B\\'){\\n                    st.pop();\\n             }\\n            else if(!st.empty() and st.top()==\\'C\\' and s[i]==\\'D\\'){\\n                    st.pop();\\n             }\\n            else{\\n                st.push(s[i]);\\n            }\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        int x = s.size();\\n        stack<char>st;\\n        st.push(s[0]);\\n        for(int i=1;i<x;i++){ \\n            if(!st.empty() and st.top()==\\'A\\' and s[i]==\\'B\\'){\\n                    st.pop();\\n             }\\n            else if(!st.empty() and st.top()==\\'C\\' and s[i]==\\'D\\'){\\n                    st.pop();\\n             }\\n            else{\\n                st.push(s[i]);\\n            }\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546770,
                "title": "stack-c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        stack<char>st;\\n        for(auto it:s)\\n        {\\n            if(st.size())\\n            {\\n                if(st.top()==\\'A\\'&&it==\\'B\\')\\n                    st.pop();\\n                \\n                else if(st.top()==\\'C\\'&&it==\\'D\\')\\n                    st.pop();\\n                else st.push(it);\\n            }\\n            else st.push(it);\\n        }\\n        \\n    \\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        stack<char>st;\\n        for(auto it:s)\\n        {\\n            if(st.size())\\n            {\\n                if(st.top()==\\'A\\'&&it==\\'B\\')\\n                    st.pop();\\n                \\n                else if(st.top()==\\'C\\'&&it==\\'D\\')\\n                    st.pop();\\n                else st.push(it);\\n            }\\n            else st.push(it);\\n        }\\n        \\n    \\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546761,
                "title": "similar-to-valid-parenthesis-easy-stack-operation",
                "content": "# Intuition\\nUSe stack\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        \\n        stack<char> st;\\n    for (char c : s) {\\n        if (!st.empty() && ((st.top() == \\'A\\' && c == \\'B\\') || (st.top() == \\'C\\' && c == \\'D\\'))) {\\n            st.pop();\\n        } else {\\n            st.push(c);\\n        }\\n    }\\n    return st.size();\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        \\n        stack<char> st;\\n    for (char c : s) {\\n        if (!st.empty() && ((st.top() == \\'A\\' && c == \\'B\\') || (st.top() == \\'C\\' && c == \\'D\\'))) {\\n            st.pop();\\n        } else {\\n            st.push(c);\\n        }\\n    }\\n    return st.size();\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546738,
                "title": "java-o-1-space",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minLength(String s) {\\n        while(s.contains(\"AB\") || s.contains(\"CD\")) {\\n            if(s.contains(\"AB\")) {\\n                int index = s.indexOf(\"AB\");\\n                s = s.substring(0, index) + s.substring(index + 2);\\n            } else {\\n                int index2 = s.indexOf(\"CD\");\\n                s = s.substring(0, index2) + s.substring(index2 + 2);\\n            }\\n        }\\n        return s.length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minLength(String s) {\\n        while(s.contains(\"AB\") || s.contains(\"CD\")) {\\n            if(s.contains(\"AB\")) {\\n                int index = s.indexOf(\"AB\");\\n                s = s.substring(0, index) + s.substring(index + 2);\\n            } else {\\n                int index2 = s.indexOf(\"CD\");\\n                s = s.substring(0, index2) + s.substring(index2 + 2);\\n            }\\n        }\\n        return s.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4100726,
                "title": "what-is-the-time-complexity-for-this",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minLength(self, s: str) -> int:\\n        while not (s.replace(\"AB\", \"\") == s) or not (s.replace(\"CD\", \"\") == s):\\n            s = s.replace(\"AB\", \"\")\\n            s = s.replace(\"CD\", \"\")\\n        return len(s)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minLength(self, s: str) -> int:\\n        while not (s.replace(\"AB\", \"\") == s) or not (s.replace(\"CD\", \"\") == s):\\n            s = s.replace(\"AB\", \"\")\\n            s = s.replace(\"CD\", \"\")\\n        return len(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4089699,
                "title": "cpp-easy-solution-stack-2ms-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        stack<char>st;\\n        int i = 0,n = s.size();\\n        while(i<n){\\n            if(st.size()==0)\\n            st.push(s[i]);\\n            else{\\n                if((s[i]==\\'B\\' && st.top()==\\'A\\')||(s[i]==\\'D\\' && st.top()==\\'C\\')){\\n                st.pop();\\n            }\\n            else{\\n                st.push(s[i]);\\n            }}\\n            i++;\\n        }\\n        return st.size();\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        stack<char>st;\\n        int i = 0,n = s.size();\\n        while(i<n){\\n            if(st.size()==0)\\n            st.push(s[i]);\\n            else{\\n                if((s[i]==\\'B\\' && st.top()==\\'A\\')||(s[i]==\\'D\\' && st.top()==\\'C\\')){\\n                st.pop();\\n            }\\n            else{\\n                st.push(s[i]);\\n            }}\\n            i++;\\n        }\\n        return st.size();\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4085361,
                "title": "java-solution-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minLength(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(stack.size()!=0 && s.charAt(i)==\\'B\\' && stack.peek()==\\'A\\')\\n            {\\n                stack.pop();\\n            }\\n            else if(stack.size()!=0 && s.charAt(i)==\\'D\\' && stack.peek()==\\'C\\')\\n            {\\n                stack.pop();\\n            }\\n            else{\\n                stack.push(s.charAt(i));\\n            }\\n        }\\n        return stack.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minLength(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(stack.size()!=0 && s.charAt(i)==\\'B\\' && stack.peek()==\\'A\\')\\n            {\\n                stack.pop();\\n            }\\n            else if(stack.size()!=0 && s.charAt(i)==\\'D\\' && stack.peek()==\\'C\\')\\n            {\\n                stack.pop();\\n            }\\n            else{\\n                stack.push(s.charAt(i));\\n            }\\n        }\\n        return stack.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4080461,
                "title": "easy-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minLength(String s) {\\n        if(!s.contains(\"AB\") && !s.contains(\"CD\"))\\n        return s.length();\\n\\n    \\n        s = s.replace(\"AB\",\"\");\\n        s = s.replace(\"CD\",\"\");\\n        return minLength(s);\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minLength(String s) {\\n        if(!s.contains(\"AB\") && !s.contains(\"CD\"))\\n        return s.length();\\n\\n    \\n        s = s.replace(\"AB\",\"\");\\n        s = s.replace(\"CD\",\"\");\\n        return minLength(s);\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078421,
                "title": "simple-c-solution-stack-approach-beats-100",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Stack Approach: The code uses a stack data structure to process the characters in the input string s. It aims to remove pairs of characters \"AB\" or \"CD\" from the string by maintaining a stack of characters and checking if the current character forms a valid pair with the character at the top of the stack.\\n\\n- Iteration through the String: The code iterates through each character c in the input string from left to right.\\n\\n- Stack Operations:\\n  - If the stack is not empty (!st.empty()) and the current character c forms a valid pair with the character at the top of the stack (either \\'A\\' and \\'B\\' or \\'C\\' and \\'D\\'), it pops the top character from the stack. This simulates the removal of the pair from the string.\\n  \\n  - If the current character c does not form a valid pair with the character at the top of the stack, it pushes the current character onto the stack. This means the character cannot be removed as part of a valid pair.\\n  \\n  - Result Calculation: After processing all characters in the input string, the size of the stack represents the minimum length of the resulting string because it contains the characters that couldn\\'t be removed.\\n\\n# Complexity\\n- Time complexity:\\n\\nThe code iterates through each character in the input string once, performing stack operations (push and pop) for each character. The time complexity is **O(n)**, where n is the length of the input string s.\\n- Space complexity:\\n\\nThe space complexity depends on the size of the stack, which can be at most the length of the input string s in the worst case. Therefore, the space complexity is **O(n)**.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        stack<char> st;\\n        for(char c : s){\\n            if(!st.empty()&&((c==\\'B\\'&&st.top()==\\'A\\')||(c==\\'D\\'&&st.top()==\\'C\\'))) st.pop();\\n            else st.push(c);\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        stack<char> st;\\n        for(char c : s){\\n            if(!st.empty()&&((c==\\'B\\'&&st.top()==\\'A\\')||(c==\\'D\\'&&st.top()==\\'C\\'))) st.pop();\\n            else st.push(c);\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069562,
                "title": "vey-easy-simple-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minLength(self, s: str) -> int:\\n        c=0\\n        while True:\\n            if \"AB\" in s:\\n                s=s.replace(\"AB\",\"\")\\n            elif \"CD\" in s:\\n                s=s.replace(\"CD\",\"\")\\n            else:\\n                break\\n        return (len(s))\\n        \\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minLength(self, s: str) -> int:\\n        c=0\\n        while True:\\n            if \"AB\" in s:\\n                s=s.replace(\"AB\",\"\")\\n            elif \"CD\" in s:\\n                s=s.replace(\"CD\",\"\")\\n            else:\\n                break\\n        return (len(s))\\n        \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4068599,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minLength(String s) {\\n        // && (s.indexOf(\"AB\") != -1 || s.indexOf(\"CD\") != -1)\\n        StringBuilder sb = new StringBuilder(s); \\n        while(s.length() >0 ){\\n            int a = sb.indexOf(\"AB\"), b = sb.indexOf(\"CD\");\\n            if(a != -1) sb.delete(a, a+2);\\n            else if(b != -1) sb.delete(b, b+2);\\n            else return sb.length();\\n        }\\n        return sb.length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int minLength(String s) {\\n        // && (s.indexOf(\"AB\") != -1 || s.indexOf(\"CD\") != -1)\\n        StringBuilder sb = new StringBuilder(s); \\n        while(s.length() >0 ){\\n            int a = sb.indexOf(\"AB\"), b = sb.indexOf(\"CD\");\\n            if(a != -1) sb.delete(a, a+2);\\n            else if(b != -1) sb.delete(b, b+2);\\n            else return sb.length();\\n        }\\n        return sb.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4057904,
                "title": "java",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int minLength(String s) {\\n        \\n        while (s.contains(\"AB\") || s.contains(\"CD\")) {\\n            int foundAB = s.indexOf(\"AB\");\\n            int foundCD = s.indexOf(\"CD\");\\n\\n            if (foundAB != -1)\\n                s = removeSubString(s, foundAB);\\n\\n            else if (foundCD != -1)\\n                s = removeSubString(s, foundCD);\\n        }\\n\\n        return s.length();\\n    }\\n\\n    private String removeSubString(String s, int index) {\\n        StringBuilder build = new StringBuilder();\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (i != index && i != index + 1)\\n                build.append(s.charAt(i));\\n        }\\n\\n        return build.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minLength(String s) {\\n        \\n        while (s.contains(\"AB\") || s.contains(\"CD\")) {\\n            int foundAB = s.indexOf(\"AB\");\\n            int foundCD = s.indexOf(\"CD\");\\n\\n            if (foundAB != -1)\\n                s = removeSubString(s, foundAB);\\n\\n            else if (foundCD != -1)\\n                s = removeSubString(s, foundCD);\\n        }\\n\\n        return s.length();\\n    }\\n\\n    private String removeSubString(String s, int index) {\\n        StringBuilder build = new StringBuilder();\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (i != index && i != index + 1)\\n                build.append(s.charAt(i));\\n        }\\n\\n        return build.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056865,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minLength(String s) {\\n        \\n        if(s.contains(\"AB\")){\\n           s = s.replace(\"AB\", \"\");\\n           return minLength(s);\\n           \\n        }else if(s.contains(\"CD\")){\\n           s = s.replace(\"CD\", \"\");\\n           return minLength(s);\\n        }else{\\n            return s.length();\\n        }\\n\\n    \\n\\n    }\\n\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minLength(String s) {\\n        \\n        if(s.contains(\"AB\")){\\n           s = s.replace(\"AB\", \"\");\\n           return minLength(s);\\n           \\n        }else if(s.contains(\"CD\")){\\n           s = s.replace(\"CD\", \"\");\\n           return minLength(s);\\n        }else{\\n            return s.length();\\n        }\\n\\n    \\n\\n    }\\n\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056250,
                "title": "java-3-lines-replaceall",
                "content": "# Intuition\\ncomplexity will be bad, actually, not sure how to calculate it. So if anyone can help.\\n\\nAt least the code is extremely simple.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minLength(String s) {\\n        while(s.contains(\"AB\") || s.contains(\"CD\")) \\n            s = s.replaceAll(\"AB\", \"\").replaceAll(\"CD\", \"\");\\n        return s.length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minLength(String s) {\\n        while(s.contains(\"AB\") || s.contains(\"CD\")) \\n            s = s.replaceAll(\"AB\", \"\").replaceAll(\"CD\", \"\");\\n        return s.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4054512,
                "title": "minimum-string-length-after-removing-substrings-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n![Screenshot (25).png](https://assets.leetcode.com/users/images/83ef8687-8821-4694-91bb-94e513bcdf2d_1694931671.632099.png)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n  \\n    public int minLength(String s) {\\n    while(s.indexOf(\"AB\")>=0 || s.indexOf(\"CD\")>=0){\\n           s=  s.replaceAll(\"AB\",\"\");\\n          s= s.replaceAll(\"CD\",\"\");\\n          System. out. println(s);\\n       }\\n    \\n![Screenshot (25).png](https://assets.leetcode.com/users/images/d804489b-d95e-4e2e-bf89-92e677a947eb_1694931647.7204294.png)\\n        return s.length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n  \\n    public int minLength(String s) {\\n    while(s.indexOf(\"AB\")>=0 || s.indexOf(\"CD\")>=0){\\n           s=  s.replaceAll(\"AB\",\"\");\\n          s= s.replaceAll(\"CD\",\"\");\\n          System. out. println(s);\\n       }\\n    \\n![Screenshot (25).png](https://assets.leetcode.com/users/images/d804489b-d95e-4e2e-bf89-92e677a947eb_1694931647.7204294.png)\\n        return s.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047825,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minLength(String s) {\\n        while(s.indexOf(\"AB\")>=0 || s.indexOf(\"CD\")>=0){\\n            var a=s.indexOf(\"AB\");\\n            var b=s.indexOf(\"CD\");\\n\\n            if(a>=0){\\n                s=s.substring(0,a)+s.substring(a+2,s.length());\\n            }else{\\n                s=s.substring(0,b)+s.substring(b+2,s.length());\\n            }\\n\\n        }\\n        return s.length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minLength(String s) {\\n        while(s.indexOf(\"AB\")>=0 || s.indexOf(\"CD\")>=0){\\n            var a=s.indexOf(\"AB\");\\n            var b=s.indexOf(\"CD\");\\n\\n            if(a>=0){\\n                s=s.substring(0,a)+s.substring(a+2,s.length());\\n            }else{\\n                s=s.substring(0,b)+s.substring(b+2,s.length());\\n            }\\n\\n        }\\n        return s.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047059,
                "title": "java-solution-easy-approach-4-line-code",
                "content": "# Intuition\\nWe want to find the minimum length of the string by removing adjacent pairs \"AB\" and \"CD\" until no more such pairs can be removed.\\n\\n# Approach\\n1. We use a do-while loop to repeatedly remove \"AB\" and \"CD\" pairs from the string until the length of the string no longer changes. \\n2. We keep track of the length before each iteration and compare it to the length after the iteration. \\n3. If they are the same, it means no more pairs can be removed, so we exit the loop.\\n\\n# Complexity\\n- ##### Time complexity: \\n    O(n^2) in the worst case, where n is the length of the string. This is because the `replace` method has a time complexity of O(n) and in the worst case, you may have to perform it multiple times.\\n- ##### Space complexity: \\n    O(n), as the space required for the new string is proportional to the length of the original string.\\n\\n# Code\\n```\\nclass Solution {\\n    public int minLength(String s) \\n    {\\n        int len;\\n        do\\n        {\\n            len=s.length();\\n            s=s.replace(\"AB\",\"\").replace(\"CD\",\"\");\\n        }\\n        while(len!=s.length());\\n        return s.length();    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minLength(String s) \\n    {\\n        int len;\\n        do\\n        {\\n            len=s.length();\\n            s=s.replace(\"AB\",\"\").replace(\"CD\",\"\");\\n        }\\n        while(len!=s.length());\\n        return s.length();    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4032165,
                "title": "php-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param String $s\\n     * @return Integer\\n     */\\n    function minLength($s) {\\n\\n        /* if ($found = strpos($s, \\'AB\\')) {\\n            $s = substr_replace($s, \\'AB\\', $found, strlen(\\'AB\\'));\\n        }\\n        elseif ($found = strpos($s, \\'CD\\')) {\\n            $s = substr_replace($s, \\'CD\\', $found, strlen(\\'CD\\'));\\n        } */\\n\\n        while(str_contains($s, \\'AB\\') || str_contains($s, \\'CD\\')) {\\n            \\n            $s = str_replace(\\'AB\\', \\'\\', $s);\\n            $s = str_replace(\\'CD\\', \\'\\', $s);\\n        }\\n\\n        return strlen($s);\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param String $s\\n     * @return Integer\\n     */\\n    function minLength($s) {\\n\\n        /* if ($found = strpos($s, \\'AB\\')) {\\n            $s = substr_replace($s, \\'AB\\', $found, strlen(\\'AB\\'));\\n        }\\n        elseif ($found = strpos($s, \\'CD\\')) {\\n            $s = substr_replace($s, \\'CD\\', $found, strlen(\\'CD\\'));\\n        } */\\n\\n        while(str_contains($s, \\'AB\\') || str_contains($s, \\'CD\\')) {\\n            \\n            $s = str_replace(\\'AB\\', \\'\\', $s);\\n            $s = str_replace(\\'CD\\', \\'\\', $s);\\n        }\\n\\n        return strlen($s);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4027520,
                "title": "php-simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param String $s\\n     * @return Integer\\n     */\\n    function minLength($s) {\\n        while(str_contains($s, \\'AB\\') || str_contains($s, \\'CD\\')) {\\n            $s = str_replace(\\'AB\\', \\'\\', $s);\\n            $s = str_replace(\\'CD\\', \\'\\', $s);\\n        }\\n\\n        return strlen($s);\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param String $s\\n     * @return Integer\\n     */\\n    function minLength($s) {\\n        while(str_contains($s, \\'AB\\') || str_contains($s, \\'CD\\')) {\\n            $s = str_replace(\\'AB\\', \\'\\', $s);\\n            $s = str_replace(\\'CD\\', \\'\\', $s);\\n        }\\n\\n        return strlen($s);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023019,
                "title": "easy-ts-js-regex-solution",
                "content": "```ts\\nfunction minLength(s: string): number {\\n    while(/AB|CD/.test(s)){\\n        s = s.replace(/AB|CD/, \\'\\');\\n    }\\n    return s.length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```ts\\nfunction minLength(s: string): number {\\n    while(/AB|CD/.test(s)){\\n        s = s.replace(/AB|CD/, \\'\\');\\n    }\\n    return s.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4015630,
                "title": "shortest-code-in-c",
                "content": "# Approach\\nThe code uses a stack to identify and remove adjacent \\'AB\\' or \\'CD\\' pairs from the input string while preserving the order of other characters, then returns the count of remaining characters.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        stack<char> st;\\n\\n        for(char c : s) {\\n            if(!st.empty() && (st.top() == \\'A\\' && c == \\'B\\' || st.top() == \\'C\\' && c == \\'D\\')) {\\n                st.pop();\\n            }\\n            else st.push(c);\\n        }\\n\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        stack<char> st;\\n\\n        for(char c : s) {\\n            if(!st.empty() && (st.top() == \\'A\\' && c == \\'B\\' || st.top() == \\'C\\' && c == \\'D\\')) {\\n                st.pop();\\n            }\\n            else st.push(c);\\n        }\\n\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4013042,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static int minLength(String s) {\\n\\n        while (s.contains(\"AB\") || s.contains(\"CD\")) {\\n            String a = s.replaceAll(\"AB\", \"\").replaceAll(\"CD\", \"\");\\n            s = a;\\n        }\\n        return s.length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int minLength(String s) {\\n\\n        while (s.contains(\"AB\") || s.contains(\"CD\")) {\\n            String a = s.replaceAll(\"AB\", \"\").replaceAll(\"CD\", \"\");\\n            s = a;\\n        }\\n        return s.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4009960,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public static int minLength(String s) {\\n\\n\\n    String b = \"\";\\n\\n     while (s.contains(\"AB\") || s.contains(\"CD\")){\\n         String a = s.replaceAll(\"AB\",\"\");\\n         b = a.replaceAll(\"CD\", \"\");\\n         s = b;\\n     }\\n\\n     return s.length();\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n public static int minLength(String s) {\\n\\n\\n    String b = \"\";\\n\\n     while (s.contains(\"AB\") || s.contains(\"CD\")){\\n         String a = s.replaceAll(\"AB\",\"\");\\n         b = a.replaceAll(\"CD\", \"\");\\n         s = b;\\n     }\\n\\n     return s.length();\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4009377,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        int del=0;\\n        stack<char>a;\\n        for(int i=0;i<s.size();i++){\\n          if(!a.empty()){\\n            if(s[i]==\\'B\\' && a.top()==\\'A\\' || s[i]==\\'D\\' && a.top()==\\'C\\'){\\n              del++;\\n              a.pop();\\n              continue;\\n            }\\n          }\\n          a.push(s[i]);\\n        }\\n        return s.size()-del*2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        int del=0;\\n        stack<char>a;\\n        for(int i=0;i<s.size();i++){\\n          if(!a.empty()){\\n            if(s[i]==\\'B\\' && a.top()==\\'A\\' || s[i]==\\'D\\' && a.top()==\\'C\\'){\\n              del++;\\n              a.pop();\\n              continue;\\n            }\\n          }\\n          a.push(s[i]);\\n        }\\n        return s.size()-del*2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4007546,
                "title": "minimum-string-length-after-removing-substrings",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int minLength(String s) {\\n        while(s.contains(\"AB\") || s.contains(\"CD\")){\\n            s=s.replaceAll(\"AB\",\"\").replaceAll(\"CD\",\"\");\\n        }\\n        return s.length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minLength(String s) {\\n        while(s.contains(\"AB\") || s.contains(\"CD\")){\\n            s=s.replaceAll(\"AB\",\"\").replaceAll(\"CD\",\"\");\\n        }\\n        return s.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006182,
                "title": "simple-php-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param String $s\\n     * @return Integer\\n     */\\n    function minLength($s) {\\n        $stack = [$s[0]];\\n        $length = strlen($s);\\n        for ($i = 1; $i < $length; $i++) {\\n            $prevChar = end($stack);\\n            $currChar = $s[$i];\\n            if (\\n                ($prevChar === \\'A\\' && $currChar === \\'B\\')\\n                || ($prevChar === \\'C\\' && $currChar === \\'D\\')\\n            ) {\\n                array_pop($stack);\\n            } else {\\n                $stack[] = $currChar;\\n            }\\n        }\\n        return count($stack);\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param String $s\\n     * @return Integer\\n     */\\n    function minLength($s) {\\n        $stack = [$s[0]];\\n        $length = strlen($s);\\n        for ($i = 1; $i < $length; $i++) {\\n            $prevChar = end($stack);\\n            $currChar = $s[$i];\\n            if (\\n                ($prevChar === \\'A\\' && $currChar === \\'B\\')\\n                || ($prevChar === \\'C\\' && $currChar === \\'D\\')\\n            ) {\\n                array_pop($stack);\\n            } else {\\n                $stack[] = $currChar;\\n            }\\n        }\\n        return count($stack);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4004159,
                "title": "python-solution-using-stack-beats-68-60",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStack\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minLength(self, s: str) -> int:\\n        stack=[]\\n        i=0\\n        # while i<len(s):\\n        for i in range(len(s)):\\n            if len(stack)==0:\\n                stack.append(s[i])\\n            elif stack[-1]==\"A\" and s[i]==\"B\":\\n                stack.pop()\\n            elif stack[-1]==\"C\" and s[i]==\"D\":\\n                stack.pop()\\n            else:\\n                stack.append(s[i])\\n        \\n        return len(stack)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minLength(self, s: str) -> int:\\n        stack=[]\\n        i=0\\n        # while i<len(s):\\n        for i in range(len(s)):\\n            if len(stack)==0:\\n                stack.append(s[i])\\n            elif stack[-1]==\"A\" and s[i]==\"B\":\\n                stack.pop()\\n            elif stack[-1]==\"C\" and s[i]==\"D\":\\n                stack.pop()\\n            else:\\n                stack.append(s[i])\\n        \\n        return len(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001400,
                "title": "python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def minLength(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        stack = []\\n        for letter in s:\\n            if len(stack) > 0:\\n                match = stack[-1] + letter\\n                if match == \"AB\" or match == \"CD\":\\n                    stack.pop()\\n                else:\\n                    stack.append(letter)\\n            else:\\n                stack.append(letter)\\n        return len(stack)\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minLength(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        stack = []\\n        for letter in s:\\n            if len(stack) > 0:\\n                match = stack[-1] + letter\\n                if match == \"AB\" or match == \"CD\":\\n                    stack.pop()\\n                else:\\n                    stack.append(letter)\\n            else:\\n                stack.append(letter)\\n        return len(stack)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3996523,
                "title": "simple-c-solution-using-stack",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        stack<char> temp;\\n        \\n        \\n        for (char c: s) {  \\n            if (!temp.empty()) {\\n                char top = temp.top();\\n                \\n                if ((c == \\'B\\' && top == \\'A\\') || (c == \\'D\\' && top == \\'C\\')) {\\n                    temp.pop();\\n                } else {\\n                    temp.push(c);\\n                }\\n            } else {\\n                temp.push(c);\\n            }\\n        }\\n        \\n        return temp.size();\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        stack<char> temp;\\n        \\n        \\n        for (char c: s) {  \\n            if (!temp.empty()) {\\n                char top = temp.top();\\n                \\n                if ((c == \\'B\\' && top == \\'A\\') || (c == \\'D\\' && top == \\'C\\')) {\\n                    temp.pop();\\n                } else {\\n                    temp.push(c);\\n                }\\n            } else {\\n                temp.push(c);\\n            }\\n        }\\n        \\n        return temp.size();\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3993811,
                "title": "100-easy-to-understand-solution-stack-approach",
                "content": "# Complexity\\n- Time complexity: **O(1)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        stack<char>st;\\n        for(int i = 0;i<s.size();i++){\\n            if(st.empty())\\n                st.push(s[i]);\\n            else if((st.top()==\\'A\\' and s[i]==\\'B\\') or (st.top()==\\'C\\' and s[i]==\\'D\\'))\\n                st.pop();\\n            else\\n                st.push(s[i]);\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        stack<char>st;\\n        for(int i = 0;i<s.size();i++){\\n            if(st.empty())\\n                st.push(s[i]);\\n            else if((st.top()==\\'A\\' and s[i]==\\'B\\') or (st.top()==\\'C\\' and s[i]==\\'D\\'))\\n                st.pop();\\n            else\\n                st.push(s[i]);\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3989479,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n\\n        string t = \"\";\\n        t += s[0];\\n\\n        for(int i=1; i<s.size(); i++) {\\n            if(t.size() && ( t.back() == \\'A\\' && s[i] == \\'B\\' ||  t.back() == \\'C\\' && s[i] == \\'D\\' )){\\n                t.pop_back();\\n            }\\n            else{\\n                t.push_back(s[i]);\\n            }\\n        }\\n\\n        return t.size();\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n\\n        string t = \"\";\\n        t += s[0];\\n\\n        for(int i=1; i<s.size(); i++) {\\n            if(t.size() && ( t.back() == \\'A\\' && s[i] == \\'B\\' ||  t.back() == \\'C\\' && s[i] == \\'D\\' )){\\n                t.pop_back();\\n            }\\n            else{\\n                t.push_back(s[i]);\\n            }\\n        }\\n\\n        return t.size();\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3987237,
                "title": "beats-easy-beginner-friendly-solution-simple-and-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minLength(String s) {\\n        int k=-1;\\n        StringBuilder sb=new StringBuilder(s);\\n        do{\\n            k=contains(sb);\\n            if(k==-1){\\n                return sb.length();\\n            }\\n            sb.delete(k,k+2);\\n\\n        }while(true);\\n    }\\n    public int contains(StringBuilder s){\\n        for(int i=0;i<s.length()-1;i++){\\n            if(s.substring(i,i+2).equals(\"AB\") || s.substring(i,i+2).equals(\"CD\")){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minLength(String s) {\\n        int k=-1;\\n        StringBuilder sb=new StringBuilder(s);\\n        do{\\n            k=contains(sb);\\n            if(k==-1){\\n                return sb.length();\\n            }\\n            sb.delete(k,k+2);\\n\\n        }while(true);\\n    }\\n    public int contains(StringBuilder s){\\n        for(int i=0;i<s.length()-1;i++){\\n            if(s.substring(i,i+2).equals(\"AB\") || s.substring(i,i+2).equals(\"CD\")){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984417,
                "title": "brute-force-approach-is-explained-in-detail-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code uses a while loop to repeatedly scan the string s and remove occurrences of \"AB\" or \"CD\" until no such pairs are left. It keeps doing this until the variable found becomes 0, indicating that no more pairs can be removed. The final length of the string is returned as the result.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.Initialize a variable found to 1. This variable will be used to determine if any pairs \"AB\" or \"CD\" are found in the current iteration.\\n2.Enter a while loop that continues as long as found is non-zero.\\n3.Inside the loop, reset found to 0.\\n4.Create an empty string str to build the modified string.\\n5.Iterate through the characters of the input string s using a for loop.\\nIf the current character and the next character form a pair \"AB\" or \"CD,\" skip the current and next characters (i.e., increment i by 2), and set found to 1 to indicate that a pair was found.\\nOtherwise, append the current character to the str string.\\n6.After processing the entire input string, update s to be equal to the modified string str.\\n7.Repeat steps 2-6 until no more pairs \"AB\" or \"CD\" are found.\\n8.Return the length of the final string s.\\n# Complexity\\n- Time complexity: O(n^2) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n1.The time complexity of this code depends on the length of the input string s and the number of iterations required to remove all \"AB\" or \"CD\" pairs. In the worst case, where no such pairs exist, the code iterates through the entire string once, resulting in a time complexity of O(N), where N is the length of the input string.\\n2.However, in the average case, where there are many such pairs to remove, the number of iterations can be higher, and the time complexity can be worse. The worst-case scenario would be if the string alternates between \"AB\" and \"CD\" pairs, in which case the time complexity could be closer to O(N^2).\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe code uses a constant amount of extra space, mainly for the str string, which stores the modified string at each iteration. Therefore, the space complexity is O(N), where N is the length of the input string s, as the space used for the str string grows linearly with the length of s.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        \\n        int found = 1;\\n        while(found){\\n\\n            found = 0;\\n            string str = \"\";\\n            for(int i = 0; i < s.length(); ++i){\\n\\n                if(i + 1 == s.length()){\\n                    str += s[i];\\n                }else if((s[i] == \\'A\\' && s[i + 1] == \\'B\\') || (s[i] == \\'C\\' && s[i + 1] == \\'D\\')){\\n                    found = 1;\\n                    i++;\\n                }else{\\n                    str += s[i];\\n                }\\n            }\\n\\n            s = str;\\n        }\\n\\n        return s.length();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "String",
                    "Stack",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        \\n        int found = 1;\\n        while(found){\\n\\n            found = 0;\\n            string str = \"\";\\n            for(int i = 0; i < s.length(); ++i){\\n\\n                if(i + 1 == s.length()){\\n                    str += s[i];\\n                }else if((s[i] == \\'A\\' && s[i + 1] == \\'B\\') || (s[i] == \\'C\\' && s[i + 1] == \\'D\\')){\\n                    found = 1;\\n                    i++;\\n                }else{\\n                    str += s[i];\\n                }\\n            }\\n\\n            s = str;\\n        }\\n\\n        return s.length();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3982121,
                "title": "easy-c-implementation",
                "content": "# Intuition\\nUsing the inbuilt string libraries in c++\\n\\n# Approach\\nFirst we set a while loop that keeps on iterating until all instances of the substring are eliminated.\\n\\nThen we check whether the substrings exist in the existing string and if found, we retrieve the position of the substring.\\n\\nWe then replace the substring with space.\\n\\nIf no instances of the substring is found, we break the loop.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n#include <string>\\n\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        int position = 0;\\n    while(true){\\n        if(s.find(\"AB\") != string::npos){\\n            position = s.find(\"AB\");\\n            s.replace(position, 2, \"\");\\n        }\\n        else if(s.find(\"CD\") != string::npos){\\n            position = s.find(\"CD\");\\n            s.replace(position, 2, \"\");\\n        }\\n        else{\\n            break;\\n        }\\n    }\\n        \\n        return s.length();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <string>\\n\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        int position = 0;\\n    while(true){\\n        if(s.find(\"AB\") != string::npos){\\n            position = s.find(\"AB\");\\n            s.replace(position, 2, \"\");\\n        }\\n        else if(s.find(\"CD\") != string::npos){\\n            position = s.find(\"CD\");\\n            s.replace(position, 2, \"\");\\n        }\\n        else{\\n            break;\\n        }\\n    }\\n        \\n        return s.length();\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3981501,
                "title": "beats-92-81-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int minLength(string input) {\\n\\tstack<char> s;\\n\\tfor (int i = 0; i < input.size(); i++)\\n\\t{\\n\\t\\t\\n\\t\\tif (!s.empty() && ((input[i] ==\\'B\\'&& s.top()==\\'A\\')|| (input[i] == \\'D\\' && s.top() == \\'C\\')))\\n\\t\\t\\ts.pop();\\n\\t\\telse\\n\\t\\t\\ts.push(input[i]);\\n\\t}\\n\\treturn s.size();\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int minLength(string input) {\\n\\tstack<char> s;\\n\\tfor (int i = 0; i < input.size(); i++)\\n\\t{\\n\\t\\t\\n\\t\\tif (!s.empty() && ((input[i] ==\\'B\\'&& s.top()==\\'A\\')|| (input[i] == \\'D\\' && s.top() == \\'C\\')))\\n\\t\\t\\ts.pop();\\n\\t\\telse\\n\\t\\t\\ts.push(input[i]);\\n\\t}\\n\\treturn s.size();\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981427,
                "title": "js-solution-using-stack",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minLength = function(s) {\\n\\n    let arr = []\\n\\n\\n    for (let i = 0; i < s.length; i++) {\\n        let curr = s[i]\\n        let prev = arr.at(-1)\\n\\n        if ((curr === \\'B\\' && prev === \\'A\\') || (curr === \\'D\\' && prev === \\'C\\')) {\\n            arr.pop()\\n        } else {\\n            arr.push(s[i])\\n        }\\n    }\\n\\n    return arr.join(\\'\\').length\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minLength = function(s) {\\n\\n    let arr = []\\n\\n\\n    for (let i = 0; i < s.length; i++) {\\n        let curr = s[i]\\n        let prev = arr.at(-1)\\n\\n        if ((curr === \\'B\\' && prev === \\'A\\') || (curr === \\'D\\' && prev === \\'C\\')) {\\n            arr.pop()\\n        } else {\\n            arr.push(s[i])\\n        }\\n    }\\n\\n    return arr.join(\\'\\').length\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3973593,
                "title": "stack-solution-using-java-in-o-n-time-with-o-n-space",
                "content": "# Intuition\\n  The idea is very simple , to understand the idea in a better way let\\'s take an example of small string :\\n\\nSuppose the string is : **\"AB\"**\\n* We have insert \\'A\\' in the stack.\\n* Now when we comes to B then we will check whether the top of the stack has A or not if it has A then simply I can pop() the element which is at top of the stack because top of the stack is gonna keep the track of it\\'s previous value and if the current character is \\'B\\' and top of the stack is \\'A\\' then we don\\'t have to include these two characters into our consideration so we will simply pop() the character from stack.\\n* Same procedure goes with **\"CD\"** , push C in the stack and when we reach to D then we will check whether the top of the stack contains C or not if yes then we will simply pop() the top element from the stack otherwise we will add the character.\\n* At the end as we are popping the characters from the stack which can form **\"AB\" and \"CD\"** as a substring so now our Stack contains the required characters which doesn\\'t contain \"AB\" and \"CD\" as substring so **we can simply return it\\'s size which will be our required answer.**\\n\\n## Reason why I use HashMap here : \\n\\nSimple thing man !! To avoid unnecessary conditions , If I didn\\'t use map over here than I have to check in the else part if (ch==\\'B\\' && stack.peek()==\\'A\\')||(ch==\\'D\\' && stack.peek()==\\'C\\') so I just map \\'B\\' with \\'A\\' and \\'D\\' with \\'C\\'.\\n# Approach\\n  Stack based approach !!\\n\\n# Complexity\\n- Time complexity:\\n  O(n)\\n\\n- Space complexity:\\n  O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minLength(String s) {\\n        \\n        Stack<Character>stack = new Stack<>();\\n        Map<Character,Character>mp = new HashMap<>();\\n        mp.put(\\'B\\',\\'A\\');\\n        mp.put(\\'D\\',\\'C\\');\\n\\n        for(char ch:s.toCharArray()){\\n            if(ch!=\\'B\\' && ch!=\\'D\\') stack.push(ch);\\n            else{\\n                if(!stack.isEmpty() && stack.peek()==mp.get(ch)) stack.pop();\\n                else stack.push(ch);\\n            }\\n        }\\n\\n        return stack.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int minLength(String s) {\\n        \\n        Stack<Character>stack = new Stack<>();\\n        Map<Character,Character>mp = new HashMap<>();\\n        mp.put(\\'B\\',\\'A\\');\\n        mp.put(\\'D\\',\\'C\\');\\n\\n        for(char ch:s.toCharArray()){\\n            if(ch!=\\'B\\' && ch!=\\'D\\') stack.push(ch);\\n            else{\\n                if(!stack.isEmpty() && stack.peek()==mp.get(ch)) stack.pop();\\n                else stack.push(ch);\\n            }\\n        }\\n\\n        return stack.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969411,
                "title": "simple-swift-solution-beats-100",
                "content": "# Approach\\nIterate character array based on stack approach\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    func minLength(_ s: String) -> Int {\\n        guard s.count > 0 else { return 0 }\\n\\n        var result = [Character]()\\n        \\n        for char in s {\\n            if let last = result.last, ((last == \"A\" && char == \"B\") || (last == \"C\" && char == \"D\")) {\\n                result.removeLast()\\n            }else{\\n                result.append(char)\\n            }\\n        }\\n        \\n        return result.count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minLength(_ s: String) -> Int {\\n        guard s.count > 0 else { return 0 }\\n\\n        var result = [Character]()\\n        \\n        for char in s {\\n            if let last = result.last, ((last == \"A\" && char == \"B\") || (last == \"C\" && char == \"D\")) {\\n                result.removeLast()\\n            }else{\\n                result.append(char)\\n            }\\n        }\\n        \\n        return result.count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952610,
                "title": "java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int minLength(String s) {\\n        int prevSize = 0;\\n        int currentSize = s.length();\\n        String tmp = s;\\n        \\n        while(currentSize != prevSize) {\\n            prevSize = currentSize;\\n            tmp = tmp.replaceAll(\"(AB)|(CD)\", \"\");\\n            currentSize = tmp.length();\\n        }\\n\\n        return currentSize;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minLength(String s) {\\n        int prevSize = 0;\\n        int currentSize = s.length();\\n        String tmp = s;\\n        \\n        while(currentSize != prevSize) {\\n            prevSize = currentSize;\\n            tmp = tmp.replaceAll(\"(AB)|(CD)\", \"\");\\n            currentSize = tmp.length();\\n        }\\n\\n        return currentSize;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947237,
                "title": "minimum-string-length-after-removing-substrings",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- employs a stack to track characters while processing the string. It pops elements when they form specific pairs (\\'A\\' and \\'B\\' or \\'C\\' and \\'D\\') and pushes the rest onto the stack.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Brute Force Approach:\\nThe brute force approach employs a stack to track characters while processing the string. It pops elements when they form specific pairs (\\'A\\' and \\'B\\' or \\'C\\' and \\'D\\') and pushes the rest onto the stack. This results in O(n) time complexity to process each character and O(n) space complexity for the stack.\\n\\n- Optimized Approach:\\nThe optimized approach, similar to the brute force, processes the string while using a stack to track characters. It employs a switch statement for more organized handling of specific cases. This approach maintains O(n) time complexity for processing and O(n) space complexity for the stack.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        stack<char> st; // Create a stack to keep track of characters\\n\\n        for (auto c : s) {\\n            if (!st.empty() && ((c == \\'B\\' && st.top() == \\'A\\') || (c == \\'D\\' && st.top() == \\'C\\'))) {\\n                // If the stack is not empty and the current character forms a valid pair\\n                // (\\'A\\' and \\'B\\') or (\\'C\\' and \\'D\\') with the top character, pop the top character.\\n                st.pop();\\n            } else {\\n                st.push(c); // Push the current character onto the stack.\\n            }\\n        }\\n\\n        return st.size(); // Return the remaining characters count in the stack.\\n    }\\n};\\n//                     Using SWITCH with STACK\\n// class Solution {\\n// public:\\n//     int minLength(string s) {\\n//         stack<char> st; // Create a stack to keep track of characters\\n\\n//         for (auto c : s) {\\n//             if (!st.empty()) {\\n//                 switch (c) {\\n//                     case \\'B\\':\\n//                         if (st.top() == \\'A\\')\\n//                             st.pop();\\n//                         else\\n//                             st.push(c);\\n//                         break;\\n//                     case \\'D\\':\\n//                         if (st.top() == \\'C\\')\\n//                             st.pop();\\n//                         else\\n//                             st.push(c);\\n//                         break;\\n//                     default:\\n//                         st.push(c);\\n//                         break;\\n//                 }\\n//             } else {\\n//                 st.push(c);\\n//             }\\n//         }\\n\\n//         return st.size(); // Return the remaining characters count in the stack.\\n//     }\\n// };\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        stack<char> st; // Create a stack to keep track of characters\\n\\n        for (auto c : s) {\\n            if (!st.empty() && ((c == \\'B\\' && st.top() == \\'A\\') || (c == \\'D\\' && st.top() == \\'C\\'))) {\\n                // If the stack is not empty and the current character forms a valid pair\\n                // (\\'A\\' and \\'B\\') or (\\'C\\' and \\'D\\') with the top character, pop the top character.\\n                st.pop();\\n            } else {\\n                st.push(c); // Push the current character onto the stack.\\n            }\\n        }\\n\\n        return st.size(); // Return the remaining characters count in the stack.\\n    }\\n};\\n//                     Using SWITCH with STACK\\n// class Solution {\\n// public:\\n//     int minLength(string s) {\\n//         stack<char> st; // Create a stack to keep track of characters\\n\\n//         for (auto c : s) {\\n//             if (!st.empty()) {\\n//                 switch (c) {\\n//                     case \\'B\\':\\n//                         if (st.top() == \\'A\\')\\n//                             st.pop();\\n//                         else\\n//                             st.push(c);\\n//                         break;\\n//                     case \\'D\\':\\n//                         if (st.top() == \\'C\\')\\n//                             st.pop();\\n//                         else\\n//                             st.push(c);\\n//                         break;\\n//                     default:\\n//                         st.push(c);\\n//                         break;\\n//                 }\\n//             } else {\\n//                 st.push(c);\\n//             }\\n//         }\\n\\n//         return st.size(); // Return the remaining characters count in the stack.\\n//     }\\n// };\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3946917,
                "title": "java-solution",
                "content": "# Intuition\\nThe intuition behind the given algorithm is to use a stack to simulate the process of eliminating certain pairs of characters from the input string. The pairs to be eliminated are \\'AB\\' and \\'CD\\'. Here\\'s the intuition broken down step by step:\\n\\n# Approach\\n1.Create an empty stack s1 to hold characters that haven\\'t been matched and removed yet.\\n2.Iterate through each character ch in the input string s:\\na. If the stack is not empty and the current character ch is \\'B\\' and the top character of the stack is \\'A\\', then pop \\'A\\' from the stack.\\nb. Else if the stack is not empty and the current character ch is \\'D\\' and the top character of the stack is \\'C\\', then pop \\'C\\' from the stack.\\nc. Otherwise, push the current character ch onto the stack.\\n3.After processing all characters in the input string, the stack s1 will contain characters that remain after removing all possible pairs.\\n4.Count the number of characters left in the stack by popping elements until the stack is empty and incrementing the count for each pop.\\n5.Return the count, which represents the minimum length of the string after removing the specified pairs of characters\\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minLength(String s) {\\n        Stack<Character> s1=new Stack<>();\\n        for(int j=0;j<s.length();j++){\\n            char ch=s.charAt(j);\\n            if(!s1.isEmpty() && ch==\\'B\\' && s1.peek()==\\'A\\'){\\n                s1.pop();\\n            }\\n            else if(!s1.isEmpty() && ch==\\'D\\' && s1.peek()==\\'C\\'){\\n                s1.pop();\\n            }\\n            else{\\n                s1.push(ch);\\n            }\\n            \\n        }\\n        int count=0;\\n        while(!s1.isEmpty()){\\n            s1.pop();\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minLength(String s) {\\n        Stack<Character> s1=new Stack<>();\\n        for(int j=0;j<s.length();j++){\\n            char ch=s.charAt(j);\\n            if(!s1.isEmpty() && ch==\\'B\\' && s1.peek()==\\'A\\'){\\n                s1.pop();\\n            }\\n            else if(!s1.isEmpty() && ch==\\'D\\' && s1.peek()==\\'C\\'){\\n                s1.pop();\\n            }\\n            else{\\n                s1.push(ch);\\n            }\\n            \\n        }\\n        int count=0;\\n        while(!s1.isEmpty()){\\n            s1.pop();\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3940841,
                "title": "beginner-friendly-java-solution-with-added-comments",
                "content": "> # Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minLength(String s) {\\n        Stack<Character>st = new Stack<>();\\n        // In case if the string length is less than 2 , just return 1 as the required substring is of length 2\\n        if(s.length()<2) return 1;\\n        // add all the characters to stack\\n        for(char c : s.toCharArray()){\\n        // Iterate through the stack and search for the given substring, if found pop the character     \\n            if(st.size()>0 && c==\\'B\\' && st.peek()==\\'A\\'){\\n                st.pop();\\n            }else if(st.size()>0 && c==\\'D\\' && st.peek()==\\'C\\'){\\n         // Push the character if its not the required substring       \\n                st.pop();\\n            }else{\\n                st.push(c);\\n            }\\n        }return st.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int minLength(String s) {\\n        Stack<Character>st = new Stack<>();\\n        // In case if the string length is less than 2 , just return 1 as the required substring is of length 2\\n        if(s.length()<2) return 1;\\n        // add all the characters to stack\\n        for(char c : s.toCharArray()){\\n        // Iterate through the stack and search for the given substring, if found pop the character     \\n            if(st.size()>0 && c==\\'B\\' && st.peek()==\\'A\\'){\\n                st.pop();\\n            }else if(st.size()>0 && c==\\'D\\' && st.peek()==\\'C\\'){\\n         // Push the character if its not the required substring       \\n                st.pop();\\n            }else{\\n                st.push(c);\\n            }\\n        }return st.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3935321,
                "title": "recursion",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def minLength(self, s: str) -> int:\\n        if \"AB\" not in s and \"CD\" not in s:\\n            return len(s)\\n        return self.minLength(s.replace(\"AB\", \"\").replace(\"CD\", \"\"))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minLength(self, s: str) -> int:\\n        if \"AB\" not in s and \"CD\" not in s:\\n            return len(s)\\n        return self.minLength(s.replace(\"AB\", \"\").replace(\"CD\", \"\"))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3932211,
                "title": "easy-and-clear-code-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- iterate while find function return string::npos which indicate that string doesn\\'t contain any one of two substrings either `\"AB\"` or `\"CD\"`\\n- using erase to time or one tome but don\\'t remove i+1 because you will delet wrong char  \\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n         while(s.find(\"AB\")!=string::npos||s.find(\"CD\")!=string::npos){\\n             for(int i=0;i<s.length()-1;){\\n                 if(s[i]==\\'A\\'&&s[i+1]==\\'B\\'||s[i]==\\'C\\'&&s[i+1]==\\'D\\'){\\n                    s.erase(s.begin()+i);\\n                    s.erase(s.begin()+i);\\n                    break;\\n                   }\\n                   else \\n                     i++;\\n             }\\n         }\\n    return s.length();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n         while(s.find(\"AB\")!=string::npos||s.find(\"CD\")!=string::npos){\\n             for(int i=0;i<s.length()-1;){\\n                 if(s[i]==\\'A\\'&&s[i+1]==\\'B\\'||s[i]==\\'C\\'&&s[i+1]==\\'D\\'){\\n                    s.erase(s.begin()+i);\\n                    s.erase(s.begin()+i);\\n                    break;\\n                   }\\n                   else \\n                     i++;\\n             }\\n         }\\n    return s.length();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3931479,
                "title": "simple-elixir-solution",
                "content": "```\\ndefmodule Solution do\\n  @spec min_length(s :: String.t) :: integer\\n\\n\\n  def last_call(n) do\\n     n\\n  end\\n\\n\\n  def min_length(s) do\\n    cond do\\n      String.contains?(s,\"AB\") ->  min_length(String.replace(s,\"AB\",\"\"))\\n      String.contains?(s,\"CD\") ->  min_length(String.replace(s,\"CD\",\"\"))\\n      not String.contains?(s,\"AB\") and not String.contains?(s,\"CD\") -> last_call(String.length(s)) \\n\\n    end\\n  end\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndefmodule Solution do\\n  @spec min_length(s :: String.t) :: integer\\n\\n\\n  def last_call(n) do\\n     n\\n  end\\n\\n\\n  def min_length(s) do\\n    cond do\\n      String.contains?(s,\"AB\") ->  min_length(String.replace(s,\"AB\",\"\"))\\n      String.contains?(s,\"CD\") ->  min_length(String.replace(s,\"CD\",\"\"))\\n      not String.contains?(s,\"AB\") and not String.contains?(s,\"CD\") -> last_call(String.length(s)) \\n\\n    end\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3931239,
                "title": "c-easiest-and-smallest-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        stack<char> st;\\n        for(int i=0;i<s.size();i++){\\n        if(!st.empty() && ((st.top()==\\'A\\' && s[i]==\\'B\\')||(st.top()==\\'C\\' && s[i]==\\'D\\')))\\n            st.pop();\\n        else \\n            st.push(s[i]);\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        stack<char> st;\\n        for(int i=0;i<s.size();i++){\\n        if(!st.empty() && ((st.top()==\\'A\\' && s[i]==\\'B\\')||(st.top()==\\'C\\' && s[i]==\\'D\\')))\\n            st.pop();\\n        else \\n            st.push(s[i]);\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3927118,
                "title": "rust-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn min_length(s: String) -> i32 {\\n        let mut s = s.chars().collect::<Vec<_>>();\\n        loop {\\n            let mut changed = false;\\n            let mut stack = vec![];\\n            for &ch in &s {\\n                match ch {\\n                    \\'B\\' => {\\n                        if stack.len() > 0 && *stack.last().unwrap() == \\'A\\' {\\n                            changed = true;\\n                            stack.pop();\\n                        } else {\\n                            stack.push(ch);\\n                        }\\n                    }\\n                    \\'D\\' => {\\n                        if stack.len() > 0 && *stack.last().unwrap() == \\'C\\' {\\n                            changed = true;\\n                            stack.pop();\\n                        } else {\\n                            stack.push(ch);\\n                        }\\n                    }\\n                    _ => {\\n                        stack.push(ch);\\n                    },\\n                }\\n            }\\n            s = stack;\\n            if !changed {\\n                break;\\n            }\\n        }\\n        s.len() as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_length(s: String) -> i32 {\\n        let mut s = s.chars().collect::<Vec<_>>();\\n        loop {\\n            let mut changed = false;\\n            let mut stack = vec![];\\n            for &ch in &s {\\n                match ch {\\n                    \\'B\\' => {\\n                        if stack.len() > 0 && *stack.last().unwrap() == \\'A\\' {\\n                            changed = true;\\n                            stack.pop();\\n                        } else {\\n                            stack.push(ch);\\n                        }\\n                    }\\n                    \\'D\\' => {\\n                        if stack.len() > 0 && *stack.last().unwrap() == \\'C\\' {\\n                            changed = true;\\n                            stack.pop();\\n                        } else {\\n                            stack.push(ch);\\n                        }\\n                    }\\n                    _ => {\\n                        stack.push(ch);\\n                    },\\n                }\\n            }\\n            s = stack;\\n            if !changed {\\n                break;\\n            }\\n        }\\n        s.len() as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3922705,
                "title": "python-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def minLength(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        while \"AB\" in s or \"CD\"in s:\\n            s = s.replace(\"CD\", \"\").replace(\"AB\", \"\")\\n        return len(s)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minLength(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        while \"AB\" in s or \"CD\"in s:\\n            s = s.replace(\"CD\", \"\").replace(\"AB\", \"\")\\n        return len(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921901,
                "title": "java-stack-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minLength(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        char[] chars = s.toCharArray();\\n\\n        for(char c : chars){\\n            if(stack.size() == 0)\\n              stack.push(c);\\n            else if(c == \\'B\\' && stack.peek() == \\'A\\' || c == \\'D\\' && stack.peek() == \\'C\\')\\n               stack.pop();\\n            else \\n               stack.push(c);\\n\\n        }\\n        return stack.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minLength(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        char[] chars = s.toCharArray();\\n\\n        for(char c : chars){\\n            if(stack.size() == 0)\\n              stack.push(c);\\n            else if(c == \\'B\\' && stack.peek() == \\'A\\' || c == \\'D\\' && stack.peek() == \\'C\\')\\n               stack.pop();\\n            else \\n               stack.push(c);\\n\\n        }\\n        return stack.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3919802,
                "title": "100-faster-best-solution-no-stack-o-1-space-solution",
                "content": "**Do Upvote it\\'s the best solution for this Problem. \\uD83D\\uDE0A**\\n\\nWe can use the two pointers pattern to construct the resulting string in one pass. i indicates the current pointer in the input string, and p - the insertion point in the result string. \\nIf the current character in the input string \"conflicts\" with the last character of the result string - we decrease p. Otherwise, we copy the current character to the input string and increase p.\\n\\n**Note that we can use the same input string to hold the output - because p will never go ahead of i. In the end, we return the portion of the string till the insertion point p.**\\n\\n\\n```\\nint minLength(string s,int p=0) {\\n        if(s.size()==1)\\n            return 1;\\n        for (int i = 0; i < s.size(); ++i) {\\n            if (p > 0 && ((s[i]==\\'B\\' && s[p-1]==\\'A\\') || (s[i]==\\'D\\' && s[p-1]==\\'C\\')))\\n                --p;\\n            else\\n                s[p++] = s[i];\\n        }\\n        return p;\\n    }\\n\\t\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "**Do Upvote it\\'s the best solution for this Problem. \\uD83D\\uDE0A**\\n\\nWe can use the two pointers pattern to construct the resulting string in one pass. i indicates the current pointer in the input string, and p - the insertion point in the result string. \\nIf the current character in the input string \"conflicts\" with the last character of the result string - we decrease p. Otherwise, we copy the current character to the input string and increase p.\\n\\n**Note that we can use the same input string to hold the output - because p will never go ahead of i. In the end, we return the portion of the string till the insertion point p.**\\n\\n\\n```\\nint minLength(string s,int p=0) {\\n        if(s.size()==1)\\n            return 1;\\n        for (int i = 0; i < s.size(); ++i) {\\n            if (p > 0 && ((s[i]==\\'B\\' && s[p-1]==\\'A\\') || (s[i]==\\'D\\' && s[p-1]==\\'C\\')))\\n                --p;\\n            else\\n                s[p++] = s[i];\\n        }\\n        return p;\\n    }\\n\\t\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3918752,
                "title": "it-s-simple-solution-let-s-check",
                "content": "Hope that it could be helpful for beginner!\\nThanks for reading :)\\n\\n# Code\\n```\\nclass Solution:\\n    def minLength(self, s: str) -> int:\\n        while True:\\n            if \\'AB\\' in s:\\n                s = s.split(\\'AB\\')\\n                s = \\'\\'.join(s)\\n            elif \\'CD\\' in s:\\n                s = s.split(\\'CD\\')\\n                s = \\'\\'.join(s)\\n            else:\\n                break\\n        return len(s)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minLength(self, s: str) -> int:\\n        while True:\\n            if \\'AB\\' in s:\\n                s = s.split(\\'AB\\')\\n                s = \\'\\'.join(s)\\n            elif \\'CD\\' in s:\\n                s = s.split(\\'CD\\')\\n                s = \\'\\'.join(s)\\n            else:\\n                break\\n        return len(s)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917530,
                "title": "three-lines-using-while-loop-and-spliting",
                "content": "# Code\\n```\\nclass Solution:\\n    def minLength(self, s: str) -> int:\\n        while \\'AB\\' in s or \\'CD\\'in s:\\n            s = \\'\\'.join(s.split(\\'AB\\'))\\n            s = \\'\\'.join(s.split(\\'CD\\'))\\n        return len(s)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minLength(self, s: str) -> int:\\n        while \\'AB\\' in s or \\'CD\\'in s:\\n            s = \\'\\'.join(s.split(\\'AB\\'))\\n            s = \\'\\'.join(s.split(\\'CD\\'))\\n        return len(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3915426,
                "title": "java-replaceall-regex",
                "content": "# Intuition\\nUse regular expressions to remove and iterate over target string\\n\\n# Approach\\nRemove substrings while this substring still exists on our target\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minLength(String s) {\\n        do {\\n\\t\\t\\ts = s.replaceAll(\"(AB|CD)\", \"\");\\n\\t\\t} while(s.matches(\".*(AB|CD).*\"));\\n\\t\\treturn s.length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minLength(String s) {\\n        do {\\n\\t\\t\\ts = s.replaceAll(\"(AB|CD)\", \"\");\\n\\t\\t} while(s.matches(\".*(AB|CD).*\"));\\n\\t\\treturn s.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3910417,
                "title": "recursion-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minLength(String s) {\\n        if(!s.contains(\"AB\") && !s.contains(\"CD\"))\\n        {\\n            return s.length();\\n        }\\n        if(s.contains(\"AB\"))\\n        {\\n            String new_str=s.replace(\"AB\",\"\");\\n            s=new_str;\\n        }\\n        if(s.contains(\"CD\"))\\n        {\\n            String new_str=s.replace(\"CD\",\"\");\\n            s=new_str;\\n        }\\n        return minLength(s);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minLength(String s) {\\n        if(!s.contains(\"AB\") && !s.contains(\"CD\"))\\n        {\\n            return s.length();\\n        }\\n        if(s.contains(\"AB\"))\\n        {\\n            String new_str=s.replace(\"AB\",\"\");\\n            s=new_str;\\n        }\\n        if(s.contains(\"CD\"))\\n        {\\n            String new_str=s.replace(\"CD\",\"\");\\n            s=new_str;\\n        }\\n        return minLength(s);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3909462,
                "title": "time-o-n-space-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minLength(self, s: str) -> int:\\n\\n\\n        a = []\\n\\n        for i in s:\\n\\n            a.append(i)\\n\\n            while len(a) >= 2 and (a[-2] == \\'A\\' and a[-1] == \\'B\\' or a[-2] == \\'C\\' and a[-1] == \\'D\\'):\\n                a.pop()\\n                a.pop()\\n        return (len(a))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minLength(self, s: str) -> int:\\n\\n\\n        a = []\\n\\n        for i in s:\\n\\n            a.append(i)\\n\\n            while len(a) >= 2 and (a[-2] == \\'A\\' and a[-1] == \\'B\\' or a[-2] == \\'C\\' and a[-1] == \\'D\\'):\\n                a.pop()\\n                a.pop()\\n        return (len(a))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3896381,
                "title": "beginner-s-friendly-easy-c-solution-stack",
                "content": "\\n# Approach\\nVery Easy Question if we solve it by using stack.\\n\\n**Step 1:** Iterate the string using a simple For loop.\\n\\n**Step 2:** There would be three nested if else case.                    \\n1. If the current char is neither B nor D then push the char into stack.\\n2.  If the current element is B or D then check what is in the top of the stack. Whether it is A or C. If A is in the Top of stack and current element is B then Pop the top of the stack element. And same for C.\\n3. Else push the char. Because the current would be in top of any other char which is neither A or C. Thus it will not make a pair of AB or CD.\\n\\n\\n**Note:** Ultimately we have to eliminate the pair, which is AB or CD.\\n\\n**Step 3:** Count the no of element that is remaining in the stack.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        stack<char> st;\\n        for(int i=0;i<s.size();i++){\\n            char ch=s[i];\\n            if(ch!=\\'B\\' && ch!=\\'D\\'){\\n                st.push(ch);\\n            }\\n\\n            else if(!st.empty() && ((ch==\\'B\\' && st.top()==\\'A\\')||(ch==\\'D\\' && st.top()==\\'C\\'))){\\n                st.pop();\\n            }\\n            \\n            else{\\n                st.push(ch);\\n            }\\n\\n        }\\n        int c=0;\\n        while(!st.empty()){\\n            c++;\\n            st.pop();\\n        }\\n        return c;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        stack<char> st;\\n        for(int i=0;i<s.size();i++){\\n            char ch=s[i];\\n            if(ch!=\\'B\\' && ch!=\\'D\\'){\\n                st.push(ch);\\n            }\\n\\n            else if(!st.empty() && ((ch==\\'B\\' && st.top()==\\'A\\')||(ch==\\'D\\' && st.top()==\\'C\\'))){\\n                st.pop();\\n            }\\n            \\n            else{\\n                st.push(ch);\\n            }\\n\\n        }\\n        int c=0;\\n        while(!st.empty()){\\n            c++;\\n            st.pop();\\n        }\\n        return c;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894999,
                "title": "using-stack-simple-opation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        \\n        stack<char>st;\\n        for(int i=0;i<s.length();i++){\\n            if(!st.empty() && st.top()==\\'A\\' && s[i]==\\'B\\'){\\n                \\n                     st.pop();\\n              \\n               \\n            }\\n            else if(!st.empty() && st.top()==\\'C\\' && s[i]==\\'D\\'){\\n                \\n                     st.pop();\\n                \\n            }\\n            else{\\n                st.push(s[i]);\\n            }\\n        }\\n\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        \\n        stack<char>st;\\n        for(int i=0;i<s.length();i++){\\n            if(!st.empty() && st.top()==\\'A\\' && s[i]==\\'B\\'){\\n                \\n                     st.pop();\\n              \\n               \\n            }\\n            else if(!st.empty() && st.top()==\\'C\\' && s[i]==\\'D\\'){\\n                \\n                     st.pop();\\n                \\n            }\\n            else{\\n                st.push(s[i]);\\n            }\\n        }\\n\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886365,
                "title": "simple-java-solution-beginner-friendly",
                "content": "\\n# Code\\n```\\nclass Solution \\n{\\n    public int minLength(String s) \\n    {\\n        Stack<Character> st = new Stack<>();\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            char ch = s.charAt(i);\\n            if(ch == \\'B\\' && !st.isEmpty() && st.peek() == \\'A\\')\\n            {\\n                st.pop();\\n            }\\n            else if(ch == \\'D\\' && !st.isEmpty() && st.peek() == \\'C\\')\\n            {\\n                st.pop();\\n            }\\n            else st.push(ch);\\n        }\\n        return st.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int minLength(String s) \\n    {\\n        Stack<Character> st = new Stack<>();\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            char ch = s.charAt(i);\\n            if(ch == \\'B\\' && !st.isEmpty() && st.peek() == \\'A\\')\\n            {\\n                st.pop();\\n            }\\n            else if(ch == \\'D\\' && !st.isEmpty() && st.peek() == \\'C\\')\\n            {\\n                st.pop();\\n            }\\n            else st.push(ch);\\n        }\\n        return st.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885368,
                "title": "very-easy-and-understandable",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n  Beats 80.10%\\n\\n- Space complexity:\\n  Beats 93.37%\\n\\n# Code\\n```\\nclass Solution(object):\\n    def minLength(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n\\n        while \"AB\" in s or \"CD\" in s:\\n            s = s.replace(\"AB\",\"\").replace(\"CD\",\"\")\\n        return len(s)    \\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minLength(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n\\n        while \"AB\" in s or \"CD\" in s:\\n            s = s.replace(\"AB\",\"\").replace(\"CD\",\"\")\\n        return len(s)    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3883821,
                "title": "python-easy-clean-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minLength(self, s: str) -> int:\\n        stack = []\\n        for i in s:\\n            if stack and (stack[-1] == \\'A\\' and i == \\'B\\' or stack[-1] == \\'C\\' and i == \\'D\\'):\\n                stack.pop()\\n            else:\\n                stack.append(i)\\n        return len(stack)\\n\\n```\\n![catty.png](https://assets.leetcode.com/users/images/0648e782-4cd3-4dc7-9701-1e1c865bb9a2_1691532718.7534997.png)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minLength(self, s: str) -> int:\\n        stack = []\\n        for i in s:\\n            if stack and (stack[-1] == \\'A\\' and i == \\'B\\' or stack[-1] == \\'C\\' and i == \\'D\\'):\\n                stack.pop()\\n            else:\\n                stack.append(i)\\n        return len(stack)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3881705,
                "title": "c-two-solutions-a-in-place-b-stack",
                "content": "# Intuition\\nEither search for in-place, or filter when copying.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n#if 0\\n    int minLength(string s) {\\n        std::string_view ab {\"AB\"}, cd {\"CD\"};\\n        bool iteration_required {true};\\n        while (iteration_required) {\\n            iteration_required = false;\\n            if (auto ab_found = s.find(ab); ab_found != s.npos) {\\n                iteration_required = true;\\n                s.erase(ab_found, 2);\\n            }\\n            if (auto cd_found = s.find(cd); cd_found != s.npos) {\\n                iteration_required = true;\\n                s.erase(cd_found, 2);\\n            }\\n        }\\n        return s.size();\\n    }\\n#endif\\n\\n#if 1\\n    int minLength(string s) {\\n        std::string stack;\\n        stack.reserve(s.size());\\n\\n        for (auto c: s) {\\n            if (!stack.empty()) {\\n                if (c == \\'B\\' && stack.back() == \\'A\\') {\\n                    stack.pop_back();\\n                    continue;\\n                }\\n                if (c == \\'D\\' && stack.back() == \\'C\\') {\\n                    stack.pop_back();\\n                    continue;\\n                }\\n                stack += c;\\n            }\\n            else {\\n                stack += c;\\n            }\\n        }\\n        return stack.size();\\n    }\\n\\n#endif\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n#if 0\\n    int minLength(string s) {\\n        std::string_view ab {\"AB\"}, cd {\"CD\"};\\n        bool iteration_required {true};\\n        while (iteration_required) {\\n            iteration_required = false;\\n            if (auto ab_found = s.find(ab); ab_found != s.npos) {\\n                iteration_required = true;\\n                s.erase(ab_found, 2);\\n            }\\n            if (auto cd_found = s.find(cd); cd_found != s.npos) {\\n                iteration_required = true;\\n                s.erase(cd_found, 2);\\n            }\\n        }\\n        return s.size();\\n    }\\n#endif\\n\\n#if 1\\n    int minLength(string s) {\\n        std::string stack;\\n        stack.reserve(s.size());\\n\\n        for (auto c: s) {\\n            if (!stack.empty()) {\\n                if (c == \\'B\\' && stack.back() == \\'A\\') {\\n                    stack.pop_back();\\n                    continue;\\n                }\\n                if (c == \\'D\\' && stack.back() == \\'C\\') {\\n                    stack.pop_back();\\n                    continue;\\n                }\\n                stack += c;\\n            }\\n            else {\\n                stack += c;\\n            }\\n        }\\n        return stack.size();\\n    }\\n\\n#endif\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3880538,
                "title": "simple-while-loop-with-str-replace",
                "content": "## Code\\n![image.png](https://assets.leetcode.com/users/images/a7b0fc6f-38c4-4aae-96ea-0e3ffc3620d4_1691479109.9937618.png)\\n\\n```\\nclass Solution:\\n    def minLength(self, s: str) -> int:\\n        while True:\\n            prev = len(s)\\n            s = s.replace(\"AB\", \"\").replace(\"CD\", \"\")\\n            if prev == len(s):\\n                break\\n        return len(s)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minLength(self, s: str) -> int:\\n        while True:\\n            prev = len(s)\\n            s = s.replace(\"AB\", \"\").replace(\"CD\", \"\")\\n            if prev == len(s):\\n                break\\n        return len(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3877222,
                "title": "easy-java-solution-beats-97",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public int minLength(String s) \\n    {\\n        StringBuilder sb=new StringBuilder(s);\\n        int i=0;\\n       \\n       while(i<sb.length()-1)\\n       {\\n           if(sb.charAt(i)==\\'A\\' && sb.charAt(i+1)==\\'B\\')\\n           {\\n               sb.delete(i,i+2);\\n               i=Math.max(0,i-1);//reseting i value\\n           }\\n      \\n          else if(sb.charAt(i)==\\'C\\' && sb.charAt(i+1)==\\'D\\')\\n          {\\n               sb.delete(i,i+2);\\n               i=Math.max(0,i-1);\\n           }\\n           else\\n            i++;\\n       }\\n\\n       return sb.length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int minLength(String s) \\n    {\\n        StringBuilder sb=new StringBuilder(s);\\n        int i=0;\\n       \\n       while(i<sb.length()-1)\\n       {\\n           if(sb.charAt(i)==\\'A\\' && sb.charAt(i+1)==\\'B\\')\\n           {\\n               sb.delete(i,i+2);\\n               i=Math.max(0,i-1);//reseting i value\\n           }\\n      \\n          else if(sb.charAt(i)==\\'C\\' && sb.charAt(i+1)==\\'D\\')\\n          {\\n               sb.delete(i,i+2);\\n               i=Math.max(0,i-1);\\n           }\\n           else\\n            i++;\\n       }\\n\\n       return sb.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3868920,
                "title": "easy-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minLength(String s) {\\n        Stack<String>st=new Stack<>();\\n        for(int i=0;i<s.length();i++){\\n            char ch=s.charAt(i);\\n            if(st.isEmpty()){\\n                st.push(\"\"+ch);\\n            }\\n            else if ((st.peek() + (\"\" + ch)).equals(\"AB\") || (st.peek() + (\"\" + ch)).equals(\"CD\")) {\\n    // Code to be executed when the condition is true\\n    st.pop();\\n}\\n            else{\\n                st.push(\"\"+ch);\\n            }\\n        }\\n        return st.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minLength(String s) {\\n        Stack<String>st=new Stack<>();\\n        for(int i=0;i<s.length();i++){\\n            char ch=s.charAt(i);\\n            if(st.isEmpty()){\\n                st.push(\"\"+ch);\\n            }\\n            else if ((st.peek() + (\"\" + ch)).equals(\"AB\") || (st.peek() + (\"\" + ch)).equals(\"CD\")) {\\n    // Code to be executed when the condition is true\\n    st.pop();\\n}\\n            else{\\n                st.push(\"\"+ch);\\n            }\\n        }\\n        return st.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3863729,
                "title": "java-2ms-beats-99-86",
                "content": "# Intuition & Approach\\n- stack\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// 2ms Beats 99.86%\\n\\nclass Solution {\\n    public int minLength(String s) {\\n\\n        Deque<Character> stack = new LinkedList<>();\\n\\n        stack.push(s.charAt(0));\\n\\n        for (int i = 1; i < s.length(); ++i) {\\n\\n            char curChar = s.charAt(i);\\n            char prevChar = stack.isEmpty() ? \\'_\\' : stack.peek();\\n\\n            if (curChar == \\'B\\' && prevChar == \\'A\\') {\\n                stack.pop();\\n                continue;\\n            }\\n\\n            if (curChar == \\'D\\' && prevChar == \\'C\\') {\\n                stack.pop();\\n                continue;\\n            }\\n\\n            stack.push(curChar);\\n        }\\n\\n        return stack.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// 2ms Beats 99.86%\\n\\nclass Solution {\\n    public int minLength(String s) {\\n\\n        Deque<Character> stack = new LinkedList<>();\\n\\n        stack.push(s.charAt(0));\\n\\n        for (int i = 1; i < s.length(); ++i) {\\n\\n            char curChar = s.charAt(i);\\n            char prevChar = stack.isEmpty() ? \\'_\\' : stack.peek();\\n\\n            if (curChar == \\'B\\' && prevChar == \\'A\\') {\\n                stack.pop();\\n                continue;\\n            }\\n\\n            if (curChar == \\'D\\' && prevChar == \\'C\\') {\\n                stack.pop();\\n                continue;\\n            }\\n\\n            stack.push(curChar);\\n        }\\n\\n        return stack.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3856278,
                "title": "using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minLength(String s) {\\n        Stack<Character> st = new Stack<>();\\n        int n = s.length();\\n        st.push(s.charAt(0));\\n        for(int i=1;i<n;i++)\\n        {\\n            if(!st.isEmpty()&&((s.charAt(i)==\\'B\\'&&st.peek()==\\'A\\')||(s.charAt(i)==\\'D\\'&&st.peek()==\\'C\\')))\\n            {\\n                st.pop();\\n            }\\n            else\\n                st.push(s.charAt(i));\\n        }\\n        return st.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minLength(String s) {\\n        Stack<Character> st = new Stack<>();\\n        int n = s.length();\\n        st.push(s.charAt(0));\\n        for(int i=1;i<n;i++)\\n        {\\n            if(!st.isEmpty()&&((s.charAt(i)==\\'B\\'&&st.peek()==\\'A\\')||(s.charAt(i)==\\'D\\'&&st.peek()==\\'C\\')))\\n            {\\n                st.pop();\\n            }\\n            else\\n                st.push(s.charAt(i));\\n        }\\n        return st.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3846485,
                "title": "intuitive-solution-using-stringbuilder",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minLength(String s) {\\n        StringBuilder sb = new StringBuilder(s);\\n\\n        \\n            for(int i=0;i<sb.length()-1;i++)\\n            {\\n                if(sb.charAt(i)==\\'A\\' && sb.charAt(i+1)==\\'B\\')\\n                {\\n                    sb.delete(i,i+2);\\n                    i=-1;\\n                }\\n                else if(sb.charAt(i)==\\'C\\' && sb.charAt(i+1)==\\'D\\')\\n                {\\n                    sb.delete(i,i+2);\\n                    i=-1;\\n                }\\n                \\n            }\\n            System.out.println(sb);\\n\\n            return sb.length();\\n\\n\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minLength(String s) {\\n        StringBuilder sb = new StringBuilder(s);\\n\\n        \\n            for(int i=0;i<sb.length()-1;i++)\\n            {\\n                if(sb.charAt(i)==\\'A\\' && sb.charAt(i+1)==\\'B\\')\\n                {\\n                    sb.delete(i,i+2);\\n                    i=-1;\\n                }\\n                else if(sb.charAt(i)==\\'C\\' && sb.charAt(i+1)==\\'D\\')\\n                {\\n                    sb.delete(i,i+2);\\n                    i=-1;\\n                }\\n                \\n            }\\n            System.out.println(sb);\\n\\n            return sb.length();\\n\\n\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3843164,
                "title": "code-soloution-99-99-beats",
                "content": "# Code\\n```\\nclass Solution:\\n    def minLength(self, s: str) -> int:\\n        stack = []\\n        for i in s:\\n            if len(stack) > 0 and ((stack[-1] == \\'A\\' and i == \\'B\\') or (stack[-1] == \\'C\\' and i == \\'D\\')):\\n                stack.pop()\\n            else:\\n                stack.append(i)\\n        return len(stack)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minLength(self, s: str) -> int:\\n        stack = []\\n        for i in s:\\n            if len(stack) > 0 and ((stack[-1] == \\'A\\' and i == \\'B\\') or (stack[-1] == \\'C\\' and i == \\'D\\')):\\n                stack.pop()\\n            else:\\n                stack.append(i)\\n        return len(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841483,
                "title": "java-stringbuilder",
                "content": "\\tclass Solution {\\n\\t\\tpublic int minLength(String s) {\\n\\t\\t\\tStringBuilder sb = new StringBuilder();\\n\\n\\t\\t\\tfor(int i=0; i<s.length(); i++){\\n\\t\\t\\t\\tif(sb.length()>0 && sb.charAt(sb.length()-1) == \\'A\\' && s.charAt(i) == \\'B\\'){\\n\\t\\t\\t\\t\\tsb.deleteCharAt(sb.length()-1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(sb.length()>0 && sb.charAt(sb.length()-1) == \\'C\\' && s.charAt(i) == \\'D\\'){\\n\\t\\t\\t\\t\\tsb.deleteCharAt(sb.length()-1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tsb.append(s.charAt(i));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn sb.length();\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "class Solution {\\n\\t\\tpublic int minLength(String s) {\\n\\t\\t\\tStringBuilder sb = new StringBuilder();\\n\\n\\t\\t\\tfor(int i=0; i<s.length(); i++){\\n\\t\\t\\t\\tif(sb.length()>0 && sb.charAt(sb.length()-1) == \\'A\\' && s.charAt(i) == \\'B\\'){\\n\\t\\t\\t\\t\\tsb.deleteCharAt(sb.length()-1);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3840064,
                "title": "python-sol",
                "content": "# Code\\n```\\nclass Solution:\\n    def minLength(self, s: str) -> int:\\n        stack=[]\\n        for i in s:\\n            if not stack:\\n                stack.append(i)\\n            else:\\n                if (stack[-1]==\\'A\\' and i==\\'B\\') or (stack[-1]==\\'C\\' and i==\\'D\\'):\\n                    stack.pop()\\n                else:\\n                    stack.append(i)\\n        return len(stack)\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def minLength(self, s: str) -> int:\\n        stack=[]\\n        for i in s:\\n            if not stack:\\n                stack.append(i)\\n            else:\\n                if (stack[-1]==\\'A\\' and i==\\'B\\') or (stack[-1]==\\'C\\' and i==\\'D\\'):\\n                    stack.pop()\\n                else:\\n                    stack.append(i)\\n        return len(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835421,
                "title": "4-ms-95-easy-java-code-stack-explained",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) Push all non B and D charcters on stack\\n2) If B or D appears check if the top of stack is A or C respectively\\n   If it is then DON\\'T push anything on stack but instead POP it\\nNOTE : dont perform on an empty stack\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minLength(String s) {\\n        Stack<Character> st = new Stack<>();\\n\\n        for(int i=0; i<s.length(); i++){\\n            char c = s.charAt(i);\\n            if(st.size()!=0){ \\n\\n                if(c == \\'B\\' && st.peek() == \\'A\\'){\\n                    st.pop();\\n                    continue;\\n                }\\n\\n                else if(c == \\'D\\' && st.peek() == \\'C\\'){\\n                    st.pop();\\n                    continue;\\n                }\\n            }\\n            st.push(c);\\n        }\\n\\n        return st.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minLength(String s) {\\n        Stack<Character> st = new Stack<>();\\n\\n        for(int i=0; i<s.length(); i++){\\n            char c = s.charAt(i);\\n            if(st.size()!=0){ \\n\\n                if(c == \\'B\\' && st.peek() == \\'A\\'){\\n                    st.pop();\\n                    continue;\\n                }\\n\\n                else if(c == \\'D\\' && st.peek() == \\'C\\'){\\n                    st.pop();\\n                    continue;\\n                }\\n            }\\n            st.push(c);\\n        }\\n\\n        return st.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826757,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minLength(String s) {\\n          while (true){\\n             int k = 0;\\n             for (int i = 0; i < s.length()-1; i++) {\\n                 if(s.charAt(i) == \\'A\\' &&s.charAt(i+1)==\\'B\\'){\\n                     s = s.substring(0,i)+s.substring(i+2,s.length());\\n                     k = 1;\\n                     continue;\\n                 }\\n                 if(s.charAt(i) == \\'C\\' &&s.charAt(i+1)==\\'D\\'){\\n                     s = s.substring(0,i)+s.substring(i+2,s.length());\\n                     k = 1;\\n                     continue;\\n                 }\\n             }\\n             if(k == 0)break;\\n\\n\\n         }\\n         return s.length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minLength(String s) {\\n          while (true){\\n             int k = 0;\\n             for (int i = 0; i < s.length()-1; i++) {\\n                 if(s.charAt(i) == \\'A\\' &&s.charAt(i+1)==\\'B\\'){\\n                     s = s.substring(0,i)+s.substring(i+2,s.length());\\n                     k = 1;\\n                     continue;\\n                 }\\n                 if(s.charAt(i) == \\'C\\' &&s.charAt(i+1)==\\'D\\'){\\n                     s = s.substring(0,i)+s.substring(i+2,s.length());\\n                     k = 1;\\n                     continue;\\n                 }\\n             }\\n             if(k == 0)break;\\n\\n\\n         }\\n         return s.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826619,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param String $s\\n     * @return Integer\\n     */\\n    function minLength($s) {\\n        $ab = false;\\n        $cd = false;\\n        while(true){\\n            if(substr_count($s, \\'AB\\')){\\n                $s = str_replace(\\'AB\\', \\'\\', $s);\\n                $ab = true;\\n            }else{\\n                $ab = false;\\n            }\\n            if(substr_count($s, \\'CD\\')){\\n                $s = str_replace(\\'CD\\', \\'\\', $s);\\n                $cd = true;\\n            }else{\\n                $cd = false;\\n            }\\n            if( $ab==false && $cd==false ){\\n                return strlen($s);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param String $s\\n     * @return Integer\\n     */\\n    function minLength($s) {\\n        $ab = false;\\n        $cd = false;\\n        while(true){\\n            if(substr_count($s, \\'AB\\')){\\n                $s = str_replace(\\'AB\\', \\'\\', $s);\\n                $ab = true;\\n            }else{\\n                $ab = false;\\n            }\\n            if(substr_count($s, \\'CD\\')){\\n                $s = str_replace(\\'CD\\', \\'\\', $s);\\n                $cd = true;\\n            }else{\\n                $cd = false;\\n            }\\n            if( $ab==false && $cd==false ){\\n                return strlen($s);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3813552,
                "title": "c-stack-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minLength(string s) \\n    {\\n      stack<char>st;\\n      for(int i=0;i<s.size();i++)\\n      {\\n          if(s[i]==\\'B\\'&& !st.empty() && st.top()==\\'A\\')\\n          st.pop();\\n          else if(s[i]==\\'D\\' && !st.empty() && st.top()==\\'C\\')\\n          st.pop();\\n          else\\n          st.push(s[i]);\\n      }\\n      return st.size();    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minLength(string s) \\n    {\\n      stack<char>st;\\n      for(int i=0;i<s.size();i++)\\n      {\\n          if(s[i]==\\'B\\'&& !st.empty() && st.top()==\\'A\\')\\n          st.pop();\\n          else if(s[i]==\\'D\\' && !st.empty() && st.top()==\\'C\\')\\n          st.pop();\\n          else\\n          st.push(s[i]);\\n      }\\n      return st.size();    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3811008,
                "title": "stack-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int minLength(String s) {\\n        Deque<Character> stack = new LinkedList<>();\\n            for (int i = 0; i < s.length(); i++) {\\n                if (stack.isEmpty()) {\\n                    stack.addLast(s.charAt(i));\\n                } else if (s.charAt(i) == \\'B\\' && stack.peekLast() == \\'A\\') {\\n                    stack.pollLast();\\n                } else if (s.charAt(i) == \\'D\\' && stack.peekLast() == \\'C\\') {\\n                    stack.pollLast();\\n                } else {\\n                    stack.addLast(s.charAt(i));\\n                }\\n            }\\n            return stack.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minLength(String s) {\\n        Deque<Character> stack = new LinkedList<>();\\n            for (int i = 0; i < s.length(); i++) {\\n                if (stack.isEmpty()) {\\n                    stack.addLast(s.charAt(i));\\n                } else if (s.charAt(i) == \\'B\\' && stack.peekLast() == \\'A\\') {\\n                    stack.pollLast();\\n                } else if (s.charAt(i) == \\'D\\' && stack.peekLast() == \\'C\\') {\\n                    stack.pollLast();\\n                } else {\\n                    stack.addLast(s.charAt(i));\\n                }\\n            }\\n            return stack.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3810546,
                "title": "easiest-way",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minLength(self, s: str) -> int:\\n        k=0\\n        while k<len(s):\\n            if \\'AB\\' in s:\\n                s=s.replace(\\'AB\\',\\'\\')\\n                k=0\\n            elif \\'CD\\' in s:\\n                s=s.replace(\\'CD\\',\\'\\')\\n                k=0\\n            else:            \\n                k+=1 \\n        return len(s)\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Stack",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def minLength(self, s: str) -> int:\\n        k=0\\n        while k<len(s):\\n            if \\'AB\\' in s:\\n                s=s.replace(\\'AB\\',\\'\\')\\n                k=0\\n            elif \\'CD\\' in s:\\n                s=s.replace(\\'CD\\',\\'\\')\\n                k=0\\n            else:            \\n                k+=1 \\n        return len(s)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3809824,
                "title": "beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minLength(String s) {\\n        Stack<Character>stack=new Stack<>();\\n        for(int i=0;i<s.length();i++){\\n            if((stack.size()>0)&&((stack.peek()==\\'A\\' && s.charAt(i)==\\'B\\')||\\n            (stack.peek()==\\'C\\' && s.charAt(i)==\\'D\\'))){\\n                stack.pop();\\n            }\\n            else{\\n                stack.push(s.charAt(i));\\n            }\\n        }\\n        System.out.println(stack);\\n        return stack.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minLength(String s) {\\n        Stack<Character>stack=new Stack<>();\\n        for(int i=0;i<s.length();i++){\\n            if((stack.size()>0)&&((stack.peek()==\\'A\\' && s.charAt(i)==\\'B\\')||\\n            (stack.peek()==\\'C\\' && s.charAt(i)==\\'D\\'))){\\n                stack.pop();\\n            }\\n            else{\\n                stack.push(s.charAt(i));\\n            }\\n        }\\n        System.out.println(stack);\\n        return stack.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808731,
                "title": "c-solution",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int minLength(const string& s) \\n    {\\n        std::stack<char> st;\\n        for (const char& c : s)\\n        {\\n            if (c == \\'B\\')\\n            {\\n                if (!st.empty() && st.top() == \\'A\\')\\n                {\\n                    st.pop();\\n                    continue;\\n                }\\n            }\\n\\n            if (c == \\'D\\')\\n            {\\n                if (!st.empty() && st.top() == \\'C\\')\\n                {\\n                    st.pop();\\n                    continue;\\n                }\\n            }\\n            \\n            st.push(c);\\n        }\\n\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int minLength(const string& s) \\n    {\\n        std::stack<char> st;\\n        for (const char& c : s)\\n        {\\n            if (c == \\'B\\')\\n            {\\n                if (!st.empty() && st.top() == \\'A\\')\\n                {\\n                    st.pop();\\n                    continue;\\n                }\\n            }\\n\\n            if (c == \\'D\\')\\n            {\\n                if (!st.empty() && st.top() == \\'C\\')\\n                {\\n                    st.pop();\\n                    continue;\\n                }\\n            }\\n            \\n            st.push(c);\\n        }\\n\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3807905,
                "title": "minimum-string-length-after-removing-substrings",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n- Initialize an empty stack to keep track of characters.\\n- Iterate through each character in the input string.\\n- If the current character can be canceled out with the previous character (e.g., \\'AB\\' or \\'CD\\'), remove the previous character from the stack. Otherwise, add the current character to the stack.\\n- After iterating through all characters, return the length of the stack, which represents the minimum length of the remaining string.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minLength = function (s) {\\n    let stack = [];\\n    for (i = 0; i < s.length; i++) {\\n        if (s[i] == \\'B\\') {\\n            if (stack[stack.length - 1] == \\'A\\') {\\n                stack.pop();\\n            }\\n            else {\\n                stack.push(s[i])\\n            }\\n        }\\n        else if (s[i] == \\'D\\') {\\n            if (stack[stack.length - 1] == \\'C\\') {\\n                stack.pop();\\n            }\\n            else {\\n                stack.push(s[i])\\n            }\\n        }\\n        else {\\n            stack.push(s[i])\\n        }\\n    }\\n    return stack.length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "String",
                    "Stack",
                    "Simulation"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minLength = function (s) {\\n    let stack = [];\\n    for (i = 0; i < s.length; i++) {\\n        if (s[i] == \\'B\\') {\\n            if (stack[stack.length - 1] == \\'A\\') {\\n                stack.pop();\\n            }\\n            else {\\n                stack.push(s[i])\\n            }\\n        }\\n        else if (s[i] == \\'D\\') {\\n            if (stack[stack.length - 1] == \\'C\\') {\\n                stack.pop();\\n            }\\n            else {\\n                stack.push(s[i])\\n            }\\n        }\\n        else {\\n            stack.push(s[i])\\n        }\\n    }\\n    return stack.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3805434,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minLength(String s) {\\n        Stack<Character> stack=new Stack<>();\\n        for(int i=0;i<s.length();i++){\\n            char ch=s.charAt(i);\\n            if(stack.isEmpty()){\\n                stack.push(ch);\\n            }\\n            else if(stack.peek()==\\'A\\'&&ch==\\'B\\'){\\n                stack.pop();\\n            }\\n            else if(stack.peek()==\\'C\\'&&ch==\\'D\\'){\\n                stack.pop();\\n            }\\n            else{\\n                stack.push(ch);\\n            }\\n        }\\n        return stack.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minLength(String s) {\\n        Stack<Character> stack=new Stack<>();\\n        for(int i=0;i<s.length();i++){\\n            char ch=s.charAt(i);\\n            if(stack.isEmpty()){\\n                stack.push(ch);\\n            }\\n            else if(stack.peek()==\\'A\\'&&ch==\\'B\\'){\\n                stack.pop();\\n            }\\n            else if(stack.peek()==\\'C\\'&&ch==\\'D\\'){\\n                stack.pop();\\n            }\\n            else{\\n                stack.push(ch);\\n            }\\n        }\\n        return stack.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801627,
                "title": "veryeasy-jebasraja",
                "content": "# Intuition:karunya university::accenture\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minLength(String s) \\n    {\\n\\n      boolean flag=true;\\n\\nString first=\"AB\";\\nString second=\"CD\";\\n\\nif (s.length()<2) \\n{\\n   return s.length();   \\n}\\n\\nwhile (flag==true) \\n{\\n    \\n   for (int i = 0; i < s.length()-1; i++) \\n   {   \\n      String croppedString=\"\";\\n      //System.out.println(Character.toString(s.charAt(i))+\"\"+Character.toString(s.charAt(i+1))); \\n      \\n      if ((s.charAt(i)+\"\"+s.charAt(i+1)).equals(\"AB\") || (s.charAt(i)+\"\"+s.charAt(i+1)).equals(\"CD\"))  \\n     {        \\n         //System.out.println(\"before removeing-->\"+s);\\n         //System.out.println(\"index-->\"+i);  \\n         \\n         croppedString=s.substring(0, i)+s.substring(i+2);\\n         //System.out.println(\"croppedString-->\"+croppedString);\\n         s=\"\";\\n         s=croppedString;\\n         i=-1;       \\n      }\\n            \\n   } \\n   \\n   flag=false;\\n}\\n\\n//System.out.println(s.length());\\n\\nreturn s.length();\\n\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minLength(String s) \\n    {\\n\\n      boolean flag=true;\\n\\nString first=\"AB\";\\nString second=\"CD\";\\n\\nif (s.length()<2) \\n{\\n   return s.length();   \\n}\\n\\nwhile (flag==true) \\n{\\n    \\n   for (int i = 0; i < s.length()-1; i++) \\n   {   \\n      String croppedString=\"\";\\n      //System.out.println(Character.toString(s.charAt(i))+\"\"+Character.toString(s.charAt(i+1))); \\n      \\n      if ((s.charAt(i)+\"\"+s.charAt(i+1)).equals(\"AB\") || (s.charAt(i)+\"\"+s.charAt(i+1)).equals(\"CD\"))  \\n     {        \\n         //System.out.println(\"before removeing-->\"+s);\\n         //System.out.println(\"index-->\"+i);  \\n         \\n         croppedString=s.substring(0, i)+s.substring(i+2);\\n         //System.out.println(\"croppedString-->\"+croppedString);\\n         s=\"\";\\n         s=croppedString;\\n         i=-1;       \\n      }\\n            \\n   } \\n   \\n   flag=false;\\n}\\n\\n//System.out.println(s.length());\\n\\nreturn s.length();\\n\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788910,
                "title": "easy-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minLength(String s) {\\n        boolean change = true;\\n        while(change){\\n            change = false;\\n            for(int i = 0; i < s.length() - 1; i++){\\n                if(s.substring(i,i + 2).equals(\"AB\") || s.substring(i, i + 2).equals(\"CD\")){\\n                    s = s.substring(0,i) + s.substring(i+2, s.length());\\n                    change = change || true;\\n                }\\n                else change = change || false;\\n                //System.out.println(s);\\n            }\\n            //System.out.println(change);\\n        }\\n        return s.length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minLength(String s) {\\n        boolean change = true;\\n        while(change){\\n            change = false;\\n            for(int i = 0; i < s.length() - 1; i++){\\n                if(s.substring(i,i + 2).equals(\"AB\") || s.substring(i, i + 2).equals(\"CD\")){\\n                    s = s.substring(0,i) + s.substring(i+2, s.length());\\n                    change = change || true;\\n                }\\n                else change = change || false;\\n                //System.out.println(s);\\n            }\\n            //System.out.println(change);\\n        }\\n        return s.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3783332,
                "title": "easy-solution-javascript-while-loop-variable-length",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minLength = function(s) {\\n    var n=0\\n    while(n< s.length+100){\\n        s= String(s).replace(\"AB\" ,\"\")\\n        s= String(s).replace(\"CD\" ,\"\")\\n        n++\\n    }\\n    return s.length\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minLength = function(s) {\\n    var n=0\\n    while(n< s.length+100){\\n        s= String(s).replace(\"AB\" ,\"\")\\n        s= String(s).replace(\"CD\" ,\"\")\\n        n++\\n    }\\n    return s.length\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3782784,
                "title": "easy-c-solution-intuitive-approach",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->This has simple approach that if the top element of stack is A and current element in string is B , then we pop A , similarly for C and D. and at the end count the number of elements in stack.\\n\\n# Complexity\\n- Time complexity:  O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        stack<int>st;\\n        st.push(-1);\\n\\n        for(int i = 0; i<s.length();i++){\\n            if(st.top() != -1 && (st.top() == \\'A\\' && s[i] ==\\'B\\') || \\n            (st.top() == \\'C\\' && s[i] ==\\'D\\')){\\n                st.pop();\\n            }\\n            else st.push(s[i]);\\n        }\\n        \\n        return st.size()-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        stack<int>st;\\n        st.push(-1);\\n\\n        for(int i = 0; i<s.length();i++){\\n            if(st.top() != -1 && (st.top() == \\'A\\' && s[i] ==\\'B\\') || \\n            (st.top() == \\'C\\' && s[i] ==\\'D\\')){\\n                st.pop();\\n            }\\n            else st.push(s[i]);\\n        }\\n        \\n        return st.size()-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3778806,
                "title": "easy-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        stack<char> st;\\n        st.push(s[0]);\\n        int i = 1;\\n        while(i<s.size()){\\n            if(st.empty()){\\n                st.push(s[i]);\\n                i++;\\n                continue;\\n            }\\n            if(s[i] == \\'B\\' and st.top() == \\'A\\'){\\n                st.pop();\\n            }\\n            else if(s[i] == \\'D\\' and st.top() == \\'C\\'){\\n                st.pop();\\n            }\\n            else{\\n                st.push(s[i]);\\n            }\\n            i++;\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        stack<char> st;\\n        st.push(s[0]);\\n        int i = 1;\\n        while(i<s.size()){\\n            if(st.empty()){\\n                st.push(s[i]);\\n                i++;\\n                continue;\\n            }\\n            if(s[i] == \\'B\\' and st.top() == \\'A\\'){\\n                st.pop();\\n            }\\n            else if(s[i] == \\'D\\' and st.top() == \\'C\\'){\\n                st.pop();\\n            }\\n            else{\\n                st.push(s[i]);\\n            }\\n            i++;\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3776932,
                "title": "easy-understanding",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minLength(string s) \\n    {\\n        int n = s.length();\\n        if(n==1 || n==0)return n;\\n        stack<char>st;\\n        for(int i=n-1 ; i>=0 ; i--)\\n        {\\n            char ch = s[i];\\n\\n            if(!st.empty())\\n            {\\n                char top = st.top();\\n                if((ch == \\'A\\' && top == \\'B\\') || (ch ==  \\'C\\' && top == \\'D\\')) \\n                {\\n                    st.pop();\\n                }\\n                else\\n                {\\n                    st.push(ch);\\n                }\\n            }\\n            else\\n            {\\n                st.push(ch);\\n            }\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minLength(string s) \\n    {\\n        int n = s.length();\\n        if(n==1 || n==0)return n;\\n        stack<char>st;\\n        for(int i=n-1 ; i>=0 ; i--)\\n        {\\n            char ch = s[i];\\n\\n            if(!st.empty())\\n            {\\n                char top = st.top();\\n                if((ch == \\'A\\' && top == \\'B\\') || (ch ==  \\'C\\' && top == \\'D\\')) \\n                {\\n                    st.pop();\\n                }\\n                else\\n                {\\n                    st.push(ch);\\n                }\\n            }\\n            else\\n            {\\n                st.push(ch);\\n            }\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3771059,
                "title": "simple-javascript-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minLength = function(s) {\\n    \\n    while(s.includes(\\'AB\\') || s.includes(\\'CD\\')){\\n        s = s.replace(\\'AB\\', \\'\\')\\n        s = s.replace(\\'CD\\', \\'\\')\\n    }\\n    return s.length\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minLength = function(s) {\\n    \\n    while(s.includes(\\'AB\\') || s.includes(\\'CD\\')){\\n        s = s.replace(\\'AB\\', \\'\\')\\n        s = s.replace(\\'CD\\', \\'\\')\\n    }\\n    return s.length\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3769924,
                "title": "minimum-string-length-after-removing-substrings",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minLength(String s) {\\n        if(s.contains(\"AB\")==false&&s.contains(\"CD\")==false)\\n        return s.length();\\n        char[] ch = s.toCharArray();\\n        ArrayList<Character> ch1= new ArrayList<Character>();\\n        for(int i=0;i<ch.length;i++)\\n        {\\n            ch1.add(ch[i]);\\n        }\\n        int j=1;\\n        while(j<ch1.size())\\n        {\\n            if(ch1.get(j-1)==\\'A\\'&&ch1.get(j)==\\'B\\')\\n            {\\n                ch1.remove(j);\\n                ch1.remove(j-1);\\n                j=0;\\n            }\\n            else if(ch1.get(j-1)==\\'C\\'&&ch1.get(j)==\\'D\\')\\n            {\\n                ch1.remove(j);\\n                ch1.remove(j-1);\\n                j=0;\\n            }\\n            j++;\\n        }\\n        for(int i=0;i<ch1.size();i++)\\n        {\\n            System.out.print(ch1.get(i)+\" \");\\n        }\\n        return ch1.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minLength(String s) {\\n        if(s.contains(\"AB\")==false&&s.contains(\"CD\")==false)\\n        return s.length();\\n        char[] ch = s.toCharArray();\\n        ArrayList<Character> ch1= new ArrayList<Character>();\\n        for(int i=0;i<ch.length;i++)\\n        {\\n            ch1.add(ch[i]);\\n        }\\n        int j=1;\\n        while(j<ch1.size())\\n        {\\n            if(ch1.get(j-1)==\\'A\\'&&ch1.get(j)==\\'B\\')\\n            {\\n                ch1.remove(j);\\n                ch1.remove(j-1);\\n                j=0;\\n            }\\n            else if(ch1.get(j-1)==\\'C\\'&&ch1.get(j)==\\'D\\')\\n            {\\n                ch1.remove(j);\\n                ch1.remove(j-1);\\n                j=0;\\n            }\\n            j++;\\n        }\\n        for(int i=0;i<ch1.size();i++)\\n        {\\n            System.out.print(ch1.get(i)+\" \");\\n        }\\n        return ch1.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3767238,
                "title": "easy-solution-with-inbuild-functions",
                "content": "EASY SOLUTION WITH INBUILD FUNCTIONS.\\n\\n# Code\\n```\\nclass Solution {\\n    public int minLength(String s) {\\n        while(s.contains(\"AB\")||s.contains(\"CD\")){\\n           if(s.contains(\"AB\"))\\n           s=s.replace(\"AB\",\"\");\\n           else\\n           s=s.replace(\"CD\",\"\");\\n        }\\n        return s.length();\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int minLength(String s) {\\n        while(s.contains(\"AB\")||s.contains(\"CD\")){\\n           if(s.contains(\"AB\"))\\n           s=s.replace(\"AB\",\"\");\\n           else\\n           s=s.replace(\"CD\",\"\");\\n        }\\n        return s.length();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766294,
                "title": "python3-beats-96-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nKeep replacing letters combos to empty space. Then check if new pairs can be found \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minLength(self, s: str) -> int:\\n        while True:\\n            tmp = s\\n            s = s.replace(\\'AB\\',\\'\\').replace(\\'CD\\',\\'\\')\\n            if s.find(\\'AB\\')>0:\\n                continue\\n            if tmp==s:\\n                break\\n        return len(s)\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minLength(self, s: str) -> int:\\n        while True:\\n            tmp = s\\n            s = s.replace(\\'AB\\',\\'\\').replace(\\'CD\\',\\'\\')\\n            if s.find(\\'AB\\')>0:\\n                continue\\n            if tmp==s:\\n                break\\n        return len(s)\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3765429,
                "title": "python3-using-recursion-very-simple-beats-95-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe can have a stack storing elements and modify them and have a check if no such sequence remains by recursion\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe have a stack storing all characters and upon B upon A in stack or D upon C in stack pop it .\\n    then we send it back again in recursion till there are no changes made by comparing string length and stack length where we return by `join` function\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N) worst case O(2*N) which is same as O(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def minLength(self, s: str) -> int:\\n        l=len(s)\\n        stack=[]\\n        for i in s:\\n            if not stack:\\n                stack.append(i)\\n                continue\\n            if i==\\'B\\' and stack[-1]==\\'A\\':\\n                stack.pop()\\n            elif i==\\'D\\' and stack[-1]==\\'C\\':\\n                stack.pop()\\n            else:\\n                stack.append(i)\\n        if l==len(stack):\\n            return l\\n        return self.minLength(\\'\\'.join(stack))\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minLength(self, s: str) -> int:\\n        l=len(s)\\n        stack=[]\\n        for i in s:\\n            if not stack:\\n                stack.append(i)\\n                continue\\n            if i==\\'B\\' and stack[-1]==\\'A\\':\\n                stack.pop()\\n            elif i==\\'D\\' and stack[-1]==\\'C\\':\\n                stack.pop()\\n            else:\\n                stack.append(i)\\n        if l==len(stack):\\n            return l\\n        return self.minLength(\\'\\'.join(stack))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3763849,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        int i=0;\\n        int size = s.length();\\n        while (i < size-1){\\n            if ((s[i]==\\'A\\' && s[i+1]==\\'B\\') || (s[i]==\\'C\\' && s[i+1]==\\'D\\')){\\n                s.erase(s.begin()+i);\\n                s.erase(s.begin()+i);\\n                size -= 2;\\n                if (i>0){\\n                    i--;\\n                }\\n            }\\n            else{\\n                i++;\\n            }\\n        }   \\n        return s.length();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        int i=0;\\n        int size = s.length();\\n        while (i < size-1){\\n            if ((s[i]==\\'A\\' && s[i+1]==\\'B\\') || (s[i]==\\'C\\' && s[i+1]==\\'D\\')){\\n                s.erase(s.begin()+i);\\n                s.erase(s.begin()+i);\\n                size -= 2;\\n                if (i>0){\\n                    i--;\\n                }\\n            }\\n            else{\\n                i++;\\n            }\\n        }   \\n        return s.length();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3756288,
                "title": "javascript-94-94-faster-simplest-solution-with-explanation-o-n-stack-beg-to-adv",
                "content": "![image.png](https://assets.leetcode.com/users/images/a22820e2-8a9b-4500-b052-2d313877b9f0_1689185839.935389.png)\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minLength = function(s) {\\n  let stack = []; // Taking a stack.\\n\\n  for(let str of s){ // Loop for traversing the string.\\n    if(stack.length && ((str==\\'B\\' && stack[stack.length-1]==\\'A\\') || (str==\\'D\\' && stack[stack.length-1]==\\'C\\'))) stack.pop(); \\n    // If we have something in stack, and the last element is amongst A or C, and if str(current element) is B or D, then we take out the last element from the stack.\\n    else stack.push(str); // If we dont have any element in the stack or if last element is not A or C and str(current element) is not B or D, then we will push the str(current element) in the stack.\\n  }    \\n  return stack.length; // Returing the length of resulting stack.\\n};\\n```\\n\\n## Found helpful, Do upvote !!",
                "solutionTags": [
                    "JavaScript",
                    "Stack"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minLength = function(s) {\\n  let stack = []; // Taking a stack.\\n\\n  for(let str of s){ // Loop for traversing the string.\\n    if(stack.length && ((str==\\'B\\' && stack[stack.length-1]==\\'A\\') || (str==\\'D\\' && stack[stack.length-1]==\\'C\\'))) stack.pop(); \\n    // If we have something in stack, and the last element is amongst A or C, and if str(current element) is B or D, then we take out the last element from the stack.\\n    else stack.push(str); // If we dont have any element in the stack or if last element is not A or C and str(current element) is not B or D, then we will push the str(current element) in the stack.\\n  }    \\n  return stack.length; // Returing the length of resulting stack.\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3742734,
                "title": "python-easiest-approach-with-time-faster-than-96-79",
                "content": "# Intuition\\nWe use the while loop until there is no \"AB\" or \"CD\" substring in the given string s.\\n\\n# Approach\\nIn each iteration of the while loop, we check for the presence of \"AB\" and \"CD\" in the string \\'s\\' using the in operator, which has a time complexity of O(n) in the worst case. So lets say if either \"AB\" or \"CD\" is found, we search for the index of the substring using the index method, which also has a time complexity of O(n) in the worst case.\\n\\n# Complexity\\n- Time complexity: O(n<sup>2</sup>)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minLength(self, s: str) -> int:\\n\\n        while \"AB\" in s or \"CD\" in s:\\n            if \"AB\" in s:\\n                inda = s.index(\"AB\")\\n                s = s[:inda] + s[inda + 2:]\\n            elif \"CD\" in s:\\n                indc = s.index(\"CD\")\\n                s = s[:indc] + s[indc + 2:]\\n\\n        return len(s)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minLength(self, s: str) -> int:\\n\\n        while \"AB\" in s or \"CD\" in s:\\n            if \"AB\" in s:\\n                inda = s.index(\"AB\")\\n                s = s[:inda] + s[inda + 2:]\\n            elif \"CD\" in s:\\n                indc = s.index(\"CD\")\\n                s = s[:indc] + s[indc + 2:]\\n\\n        return len(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741742,
                "title": "very-very-easy-solution-simple-to-understand-100-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static int minLength(String s) {\\n      \\n    while(s.contains(\"AB\")||s.contains(\"CD\")){\\n        if(s.contains(\"AB\")){\\n            s = s.replace(\"AB\",\"\");\\n        }\\n        if(s.contains(\"CD\")){\\n            s = s.replace(\"CD\",\"\");\\n         System.out.println(\"CD \"+s+\"$\");\\n        }\\n    }\\n        return s.length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int minLength(String s) {\\n      \\n    while(s.contains(\"AB\")||s.contains(\"CD\")){\\n        if(s.contains(\"AB\")){\\n            s = s.replace(\"AB\",\"\");\\n        }\\n        if(s.contains(\"CD\")){\\n            s = s.replace(\"CD\",\"\");\\n         System.out.println(\"CD \"+s+\"$\");\\n        }\\n    }\\n        return s.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740319,
                "title": "c-must-watch-this",
                "content": "```\\nclass Solution {\\npublic:\\n    int minLength(string s){\\n        stack<char>st;\\n        for(int i=0; i<s.size(); i++){\\n            if(!st.empty()){\\n                if(st.top()==\\'A\\' && s[i]==\\'B\\'){\\n                    st.pop();\\n                }\\n                else if(st.top()==\\'C\\' && s[i]==\\'D\\'){\\n                    st.pop();\\n                }\\n                else{\\n                    st.push(s[i]);\\n                }\\n            }\\n            else{\\n                st.push(s[i]);\\n            }\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minLength(string s){\\n        stack<char>st;\\n        for(int i=0; i<s.size(); i++){\\n            if(!st.empty()){\\n                if(st.top()==\\'A\\' && s[i]==\\'B\\'){\\n                    st.pop();\\n                }\\n                else if(st.top()==\\'C\\' && s[i]==\\'D\\'){\\n                    st.pop();\\n                }\\n                else{\\n                    st.push(s[i]);\\n                }\\n            }\\n            else{\\n                st.push(s[i]);\\n            }\\n        }\\n        return st.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736819,
                "title": "golang-replace-solution",
                "content": "# Intuition\\n1 <= s.length <= 100\\nSo strings.Replace or strings.ReplaceAll is enough :)\\n\\n# Code\\n```go\\nfunc minLength(s string) int {\\n    prevSize := len(s)\\n    for {\\n        s = strings.Replace(s, \"AB\", \"\", -1)\\n        s = strings.Replace(s, \"CD\", \"\", -1)\\n        if len(s) == prevSize {\\n            return len(s)\\n        }\\n        prevSize = len(s)\\n    } \\n    return 0\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc minLength(s string) int {\\n    prevSize := len(s)\\n    for {\\n        s = strings.Replace(s, \"AB\", \"\", -1)\\n        s = strings.Replace(s, \"CD\", \"\", -1)\\n        if len(s) == prevSize {\\n            return len(s)\\n        }\\n        prevSize = len(s)\\n    } \\n    return 0\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1956017,
                "content": [
                    {
                        "username": "strangepk07",
                        "content": "Is the stack approach the optimal solution?"
                    },
                    {
                        "username": "strangepk07",
                        "content": "[@bparanj](/bparanj) Got it, thank you so much "
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, the stack approach is optimal for this problem. It works in a single pass over the string (O(n) time complexity, where n is the length of the string), and it doesn\\'t require any extra space other than the stack (which in the worst case scenario is O(n), if all characters are different from \\'B\\' and \\'D\\', or if \\'B\\' and \\'D\\' always appear without a preceding \\'A\\' or \\'C\\').\\n\\nThe reason why it\\'s optimal is that it efficiently identifies and removes the \\'AB\\' and \\'CD\\' substrings as it encounters them. By using a stack, it ensures that it\\'s always dealing with the most recent characters, which enables it to handle cases where removing one substring creates a new one. So, this method not only determines whether a substring can be removed, but also carries out the removal in the same pass.\\n\\nIf we tried to solve this problem with other methods like repeatedly scanning the string for substrings or using dynamic programming, we would likely end up with a solution that is more complex and less efficient."
                    },
                    {
                        "username": "sourendulodh",
                        "content": "Use brutal force thats it ."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Why this code not working\\n\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        int f=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            f=0;\\n            if(s.at(i)==\\'A\\' && s.at(i+1)==\\'B\\' || s.at(i)==\\'C\\' && s.at(i+1)==\\'D\\')\\n             {\\n              s.erase(i,i+1);\\n              i=-1;\\n              \\n              }\\n\\n        }\\n             return s.length();\\n    }\\n};"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Just add a loop till string contains AB or CD keywords. if true then replace those keywords with empty string.\\nfinally return length of string\\n  "
                    },
                    {
                        "username": "jevin_makwana",
                        "content": "for input \"BJKDKABJ\" ans is 6, How? \\nI\\'m expecting 4 as JK and AB will be removed. What thing I\\'m missing here?"
                    },
                    {
                        "username": "Worpakat",
                        "content": "I did same as you, I assume we tought both of us \"I should remove any consecutive 2 chars.\" "
                    },
                    {
                        "username": "aksh-99",
                        "content": "you need to find only CD and AB substr from s nd only need to delete to this not JK or any other consecutive num"
                    },
                    {
                        "username": "Augus7",
                        "content": "why would JK be removed? you are only suppose to remove AB and CD"
                    },
                    {
                        "username": "chandrabhan_bahetwar",
                        "content": "class Solution {\\npublic:\\n    int minLength(string s) {\\n        for (int i = 1; i < s.size(); i++)\\n        {\\n            while ((s.size() > i) and ((s[i - 1] == \\'A\\' and s[i] == \\'B\\') or (s[i - 1] == \\'C\\' and s[i] == \\'D\\')))\\n            {\\n\\n                s.erase(s.begin() + (i-1));\\n                s.erase(s.begin() + (i-1));\\n                \\n                if(i > 1)\\n                    i = i - 1;\\n            }\\n        }\\n        return s.size();\\n    }\\n};"
                    },
                    {
                        "username": "Movsar",
                        "content": "How could you solve this question if you don't understand simple **DISCUSSION RULES**? **Downvote, pls**"
                    }
                ]
            },
            {
                "id": 2066141,
                "content": [
                    {
                        "username": "strangepk07",
                        "content": "Is the stack approach the optimal solution?"
                    },
                    {
                        "username": "strangepk07",
                        "content": "[@bparanj](/bparanj) Got it, thank you so much "
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, the stack approach is optimal for this problem. It works in a single pass over the string (O(n) time complexity, where n is the length of the string), and it doesn\\'t require any extra space other than the stack (which in the worst case scenario is O(n), if all characters are different from \\'B\\' and \\'D\\', or if \\'B\\' and \\'D\\' always appear without a preceding \\'A\\' or \\'C\\').\\n\\nThe reason why it\\'s optimal is that it efficiently identifies and removes the \\'AB\\' and \\'CD\\' substrings as it encounters them. By using a stack, it ensures that it\\'s always dealing with the most recent characters, which enables it to handle cases where removing one substring creates a new one. So, this method not only determines whether a substring can be removed, but also carries out the removal in the same pass.\\n\\nIf we tried to solve this problem with other methods like repeatedly scanning the string for substrings or using dynamic programming, we would likely end up with a solution that is more complex and less efficient."
                    },
                    {
                        "username": "sourendulodh",
                        "content": "Use brutal force thats it ."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Why this code not working\\n\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        int f=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            f=0;\\n            if(s.at(i)==\\'A\\' && s.at(i+1)==\\'B\\' || s.at(i)==\\'C\\' && s.at(i+1)==\\'D\\')\\n             {\\n              s.erase(i,i+1);\\n              i=-1;\\n              \\n              }\\n\\n        }\\n             return s.length();\\n    }\\n};"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Just add a loop till string contains AB or CD keywords. if true then replace those keywords with empty string.\\nfinally return length of string\\n  "
                    },
                    {
                        "username": "jevin_makwana",
                        "content": "for input \"BJKDKABJ\" ans is 6, How? \\nI\\'m expecting 4 as JK and AB will be removed. What thing I\\'m missing here?"
                    },
                    {
                        "username": "Worpakat",
                        "content": "I did same as you, I assume we tought both of us \"I should remove any consecutive 2 chars.\" "
                    },
                    {
                        "username": "aksh-99",
                        "content": "you need to find only CD and AB substr from s nd only need to delete to this not JK or any other consecutive num"
                    },
                    {
                        "username": "Augus7",
                        "content": "why would JK be removed? you are only suppose to remove AB and CD"
                    },
                    {
                        "username": "chandrabhan_bahetwar",
                        "content": "class Solution {\\npublic:\\n    int minLength(string s) {\\n        for (int i = 1; i < s.size(); i++)\\n        {\\n            while ((s.size() > i) and ((s[i - 1] == \\'A\\' and s[i] == \\'B\\') or (s[i - 1] == \\'C\\' and s[i] == \\'D\\')))\\n            {\\n\\n                s.erase(s.begin() + (i-1));\\n                s.erase(s.begin() + (i-1));\\n                \\n                if(i > 1)\\n                    i = i - 1;\\n            }\\n        }\\n        return s.size();\\n    }\\n};"
                    },
                    {
                        "username": "Movsar",
                        "content": "How could you solve this question if you don't understand simple **DISCUSSION RULES**? **Downvote, pls**"
                    }
                ]
            },
            {
                "id": 2020383,
                "content": [
                    {
                        "username": "strangepk07",
                        "content": "Is the stack approach the optimal solution?"
                    },
                    {
                        "username": "strangepk07",
                        "content": "[@bparanj](/bparanj) Got it, thank you so much "
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, the stack approach is optimal for this problem. It works in a single pass over the string (O(n) time complexity, where n is the length of the string), and it doesn\\'t require any extra space other than the stack (which in the worst case scenario is O(n), if all characters are different from \\'B\\' and \\'D\\', or if \\'B\\' and \\'D\\' always appear without a preceding \\'A\\' or \\'C\\').\\n\\nThe reason why it\\'s optimal is that it efficiently identifies and removes the \\'AB\\' and \\'CD\\' substrings as it encounters them. By using a stack, it ensures that it\\'s always dealing with the most recent characters, which enables it to handle cases where removing one substring creates a new one. So, this method not only determines whether a substring can be removed, but also carries out the removal in the same pass.\\n\\nIf we tried to solve this problem with other methods like repeatedly scanning the string for substrings or using dynamic programming, we would likely end up with a solution that is more complex and less efficient."
                    },
                    {
                        "username": "sourendulodh",
                        "content": "Use brutal force thats it ."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Why this code not working\\n\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        int f=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            f=0;\\n            if(s.at(i)==\\'A\\' && s.at(i+1)==\\'B\\' || s.at(i)==\\'C\\' && s.at(i+1)==\\'D\\')\\n             {\\n              s.erase(i,i+1);\\n              i=-1;\\n              \\n              }\\n\\n        }\\n             return s.length();\\n    }\\n};"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Just add a loop till string contains AB or CD keywords. if true then replace those keywords with empty string.\\nfinally return length of string\\n  "
                    },
                    {
                        "username": "jevin_makwana",
                        "content": "for input \"BJKDKABJ\" ans is 6, How? \\nI\\'m expecting 4 as JK and AB will be removed. What thing I\\'m missing here?"
                    },
                    {
                        "username": "Worpakat",
                        "content": "I did same as you, I assume we tought both of us \"I should remove any consecutive 2 chars.\" "
                    },
                    {
                        "username": "aksh-99",
                        "content": "you need to find only CD and AB substr from s nd only need to delete to this not JK or any other consecutive num"
                    },
                    {
                        "username": "Augus7",
                        "content": "why would JK be removed? you are only suppose to remove AB and CD"
                    },
                    {
                        "username": "chandrabhan_bahetwar",
                        "content": "class Solution {\\npublic:\\n    int minLength(string s) {\\n        for (int i = 1; i < s.size(); i++)\\n        {\\n            while ((s.size() > i) and ((s[i - 1] == \\'A\\' and s[i] == \\'B\\') or (s[i - 1] == \\'C\\' and s[i] == \\'D\\')))\\n            {\\n\\n                s.erase(s.begin() + (i-1));\\n                s.erase(s.begin() + (i-1));\\n                \\n                if(i > 1)\\n                    i = i - 1;\\n            }\\n        }\\n        return s.size();\\n    }\\n};"
                    },
                    {
                        "username": "Movsar",
                        "content": "How could you solve this question if you don't understand simple **DISCUSSION RULES**? **Downvote, pls**"
                    }
                ]
            },
            {
                "id": 1938457,
                "content": [
                    {
                        "username": "strangepk07",
                        "content": "Is the stack approach the optimal solution?"
                    },
                    {
                        "username": "strangepk07",
                        "content": "[@bparanj](/bparanj) Got it, thank you so much "
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, the stack approach is optimal for this problem. It works in a single pass over the string (O(n) time complexity, where n is the length of the string), and it doesn\\'t require any extra space other than the stack (which in the worst case scenario is O(n), if all characters are different from \\'B\\' and \\'D\\', or if \\'B\\' and \\'D\\' always appear without a preceding \\'A\\' or \\'C\\').\\n\\nThe reason why it\\'s optimal is that it efficiently identifies and removes the \\'AB\\' and \\'CD\\' substrings as it encounters them. By using a stack, it ensures that it\\'s always dealing with the most recent characters, which enables it to handle cases where removing one substring creates a new one. So, this method not only determines whether a substring can be removed, but also carries out the removal in the same pass.\\n\\nIf we tried to solve this problem with other methods like repeatedly scanning the string for substrings or using dynamic programming, we would likely end up with a solution that is more complex and less efficient."
                    },
                    {
                        "username": "sourendulodh",
                        "content": "Use brutal force thats it ."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Why this code not working\\n\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        int f=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            f=0;\\n            if(s.at(i)==\\'A\\' && s.at(i+1)==\\'B\\' || s.at(i)==\\'C\\' && s.at(i+1)==\\'D\\')\\n             {\\n              s.erase(i,i+1);\\n              i=-1;\\n              \\n              }\\n\\n        }\\n             return s.length();\\n    }\\n};"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Just add a loop till string contains AB or CD keywords. if true then replace those keywords with empty string.\\nfinally return length of string\\n  "
                    },
                    {
                        "username": "jevin_makwana",
                        "content": "for input \"BJKDKABJ\" ans is 6, How? \\nI\\'m expecting 4 as JK and AB will be removed. What thing I\\'m missing here?"
                    },
                    {
                        "username": "Worpakat",
                        "content": "I did same as you, I assume we tought both of us \"I should remove any consecutive 2 chars.\" "
                    },
                    {
                        "username": "aksh-99",
                        "content": "you need to find only CD and AB substr from s nd only need to delete to this not JK or any other consecutive num"
                    },
                    {
                        "username": "Augus7",
                        "content": "why would JK be removed? you are only suppose to remove AB and CD"
                    },
                    {
                        "username": "chandrabhan_bahetwar",
                        "content": "class Solution {\\npublic:\\n    int minLength(string s) {\\n        for (int i = 1; i < s.size(); i++)\\n        {\\n            while ((s.size() > i) and ((s[i - 1] == \\'A\\' and s[i] == \\'B\\') or (s[i - 1] == \\'C\\' and s[i] == \\'D\\')))\\n            {\\n\\n                s.erase(s.begin() + (i-1));\\n                s.erase(s.begin() + (i-1));\\n                \\n                if(i > 1)\\n                    i = i - 1;\\n            }\\n        }\\n        return s.size();\\n    }\\n};"
                    },
                    {
                        "username": "Movsar",
                        "content": "How could you solve this question if you don't understand simple **DISCUSSION RULES**? **Downvote, pls**"
                    }
                ]
            },
            {
                "id": 1900722,
                "content": [
                    {
                        "username": "strangepk07",
                        "content": "Is the stack approach the optimal solution?"
                    },
                    {
                        "username": "strangepk07",
                        "content": "[@bparanj](/bparanj) Got it, thank you so much "
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, the stack approach is optimal for this problem. It works in a single pass over the string (O(n) time complexity, where n is the length of the string), and it doesn\\'t require any extra space other than the stack (which in the worst case scenario is O(n), if all characters are different from \\'B\\' and \\'D\\', or if \\'B\\' and \\'D\\' always appear without a preceding \\'A\\' or \\'C\\').\\n\\nThe reason why it\\'s optimal is that it efficiently identifies and removes the \\'AB\\' and \\'CD\\' substrings as it encounters them. By using a stack, it ensures that it\\'s always dealing with the most recent characters, which enables it to handle cases where removing one substring creates a new one. So, this method not only determines whether a substring can be removed, but also carries out the removal in the same pass.\\n\\nIf we tried to solve this problem with other methods like repeatedly scanning the string for substrings or using dynamic programming, we would likely end up with a solution that is more complex and less efficient."
                    },
                    {
                        "username": "sourendulodh",
                        "content": "Use brutal force thats it ."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Why this code not working\\n\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        int f=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            f=0;\\n            if(s.at(i)==\\'A\\' && s.at(i+1)==\\'B\\' || s.at(i)==\\'C\\' && s.at(i+1)==\\'D\\')\\n             {\\n              s.erase(i,i+1);\\n              i=-1;\\n              \\n              }\\n\\n        }\\n             return s.length();\\n    }\\n};"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Just add a loop till string contains AB or CD keywords. if true then replace those keywords with empty string.\\nfinally return length of string\\n  "
                    },
                    {
                        "username": "jevin_makwana",
                        "content": "for input \"BJKDKABJ\" ans is 6, How? \\nI\\'m expecting 4 as JK and AB will be removed. What thing I\\'m missing here?"
                    },
                    {
                        "username": "Worpakat",
                        "content": "I did same as you, I assume we tought both of us \"I should remove any consecutive 2 chars.\" "
                    },
                    {
                        "username": "aksh-99",
                        "content": "you need to find only CD and AB substr from s nd only need to delete to this not JK or any other consecutive num"
                    },
                    {
                        "username": "Augus7",
                        "content": "why would JK be removed? you are only suppose to remove AB and CD"
                    },
                    {
                        "username": "chandrabhan_bahetwar",
                        "content": "class Solution {\\npublic:\\n    int minLength(string s) {\\n        for (int i = 1; i < s.size(); i++)\\n        {\\n            while ((s.size() > i) and ((s[i - 1] == \\'A\\' and s[i] == \\'B\\') or (s[i - 1] == \\'C\\' and s[i] == \\'D\\')))\\n            {\\n\\n                s.erase(s.begin() + (i-1));\\n                s.erase(s.begin() + (i-1));\\n                \\n                if(i > 1)\\n                    i = i - 1;\\n            }\\n        }\\n        return s.size();\\n    }\\n};"
                    },
                    {
                        "username": "Movsar",
                        "content": "How could you solve this question if you don't understand simple **DISCUSSION RULES**? **Downvote, pls**"
                    }
                ]
            },
            {
                "id": 1900953,
                "content": [
                    {
                        "username": "strangepk07",
                        "content": "Is the stack approach the optimal solution?"
                    },
                    {
                        "username": "strangepk07",
                        "content": "[@bparanj](/bparanj) Got it, thank you so much "
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, the stack approach is optimal for this problem. It works in a single pass over the string (O(n) time complexity, where n is the length of the string), and it doesn\\'t require any extra space other than the stack (which in the worst case scenario is O(n), if all characters are different from \\'B\\' and \\'D\\', or if \\'B\\' and \\'D\\' always appear without a preceding \\'A\\' or \\'C\\').\\n\\nThe reason why it\\'s optimal is that it efficiently identifies and removes the \\'AB\\' and \\'CD\\' substrings as it encounters them. By using a stack, it ensures that it\\'s always dealing with the most recent characters, which enables it to handle cases where removing one substring creates a new one. So, this method not only determines whether a substring can be removed, but also carries out the removal in the same pass.\\n\\nIf we tried to solve this problem with other methods like repeatedly scanning the string for substrings or using dynamic programming, we would likely end up with a solution that is more complex and less efficient."
                    },
                    {
                        "username": "sourendulodh",
                        "content": "Use brutal force thats it ."
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Why this code not working\\n\\nclass Solution {\\npublic:\\n    int minLength(string s) {\\n        int f=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            f=0;\\n            if(s.at(i)==\\'A\\' && s.at(i+1)==\\'B\\' || s.at(i)==\\'C\\' && s.at(i+1)==\\'D\\')\\n             {\\n              s.erase(i,i+1);\\n              i=-1;\\n              \\n              }\\n\\n        }\\n             return s.length();\\n    }\\n};"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "Just add a loop till string contains AB or CD keywords. if true then replace those keywords with empty string.\\nfinally return length of string\\n  "
                    },
                    {
                        "username": "jevin_makwana",
                        "content": "for input \"BJKDKABJ\" ans is 6, How? \\nI\\'m expecting 4 as JK and AB will be removed. What thing I\\'m missing here?"
                    },
                    {
                        "username": "Worpakat",
                        "content": "I did same as you, I assume we tought both of us \"I should remove any consecutive 2 chars.\" "
                    },
                    {
                        "username": "aksh-99",
                        "content": "you need to find only CD and AB substr from s nd only need to delete to this not JK or any other consecutive num"
                    },
                    {
                        "username": "Augus7",
                        "content": "why would JK be removed? you are only suppose to remove AB and CD"
                    },
                    {
                        "username": "chandrabhan_bahetwar",
                        "content": "class Solution {\\npublic:\\n    int minLength(string s) {\\n        for (int i = 1; i < s.size(); i++)\\n        {\\n            while ((s.size() > i) and ((s[i - 1] == \\'A\\' and s[i] == \\'B\\') or (s[i - 1] == \\'C\\' and s[i] == \\'D\\')))\\n            {\\n\\n                s.erase(s.begin() + (i-1));\\n                s.erase(s.begin() + (i-1));\\n                \\n                if(i > 1)\\n                    i = i - 1;\\n            }\\n        }\\n        return s.size();\\n    }\\n};"
                    },
                    {
                        "username": "Movsar",
                        "content": "How could you solve this question if you don't understand simple **DISCUSSION RULES**? **Downvote, pls**"
                    }
                ]
            }
        ]
    },
    {
        "title": "Buy Two Chocolates",
        "question_content": "<p>You are given an integer array <code>prices</code> representing the prices of various chocolates in a store. You are also given a single integer <code>money</code>, which represents your initial amount of money.</p>\n\n<p>You must buy <strong>exactly</strong> two chocolates in such a way that you still have some <strong>non-negative</strong> leftover money. You would like to minimize the sum of the prices of the two chocolates you buy.</p>\n\n<p>Return <em>the amount of money you will have leftover after buying the two chocolates</em>. If there is no way for you to buy two chocolates without ending up in debt, return <code>money</code>. Note that the leftover must be non-negative.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> prices = [1,2,2], money = 3\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> Purchase the chocolates priced at 1 and 2 units respectively. You will have 3 - 3 = 0 units of money afterwards. Thus, we return 0.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> prices = [3,2,3], money = 3\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> You cannot buy 2 chocolates without going in debt, so we return 3.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= prices.length &lt;= 50</code></li>\n\t<li><code>1 &lt;= prices[i] &lt;= 100</code></li>\n\t<li><code>1 &lt;= money &lt;= 100</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3568593,
                "title": "sum-of-smallest-two-element-very-simple-easy-to-understand-solution",
                "content": "Find the smallest two element and add them.\\nIf the sum is less then money then return (money - sum)\\nelse return money\\n\\n# Code\\nApproach 1 : sorting apprach - O(NlogN)\\n```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        sort(prices.begin(), prices.end());\\n        int sum = prices[0] + prices[1];\\n        return (sum > money)?money: (money - sum);\\n    }\\n};\\n```\\n\\nApproach 2 : finding smallest two element - O(N)\\n```\\nint buyChoco(vector<int>& prices, int money) {\\n    int s1 = INT_MAX, s2 = INT_MAX;\\n    for(auto p: prices){\\n        if(s1 > p) { s2 = s1; s1 = p; }\\n        else if(s2 >= p) { s2 = p; }\\n    }\\n    if(s1 + s2 <= money ) return money - (s1 + s2);\\n    return money;\\n}\\n```\\n\\n<b> Here is an article of my last interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        sort(prices.begin(), prices.end());\\n        int sum = prices[0] + prices[1];\\n        return (sum > money)?money: (money - sum);\\n    }\\n};\\n```\n```\\nint buyChoco(vector<int>& prices, int money) {\\n    int s1 = INT_MAX, s2 = INT_MAX;\\n    for(auto p: prices){\\n        if(s1 > p) { s2 = s1; s1 = p; }\\n        else if(s2 >= p) { s2 = p; }\\n    }\\n    if(s1 + s2 <= money ) return money - (s1 + s2);\\n    return money;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568642,
                "title": "nth-element",
                "content": "**C++**\\n```cpp\\nint buyChoco(vector<int>& p, int money) {\\n    nth_element(begin(p), begin(p) + 2, end(p));\\n    return money < p[0] + p[1] ? money : money - p[0] - p[1];\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint buyChoco(vector<int>& p, int money) {\\n    nth_element(begin(p), begin(p) + 2, end(p));\\n    return money < p[0] + p[1] ? money : money - p[0] - p[1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3568568,
                "title": "python-elegant-short-first-second-minimum-o-n",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def buyChoco(self, prices: List[int], money: int) -> int:\\n        first_min = second_min = maxsize\\n\\n        for p in prices:\\n            if p < first_min:\\n                second_min, first_min = first_min, p\\n            elif p < second_min:\\n                second_min = p\\n\\n        min_price = first_min + second_min\\n        return money - min_price if min_price <= money else money\\n```\\n\\n# Important\\nIf you like this solution remember to **upvote it** to let me know.\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def buyChoco(self, prices: List[int], money: int) -> int:\\n        first_min = second_min = maxsize\\n\\n        for p in prices:\\n            if p < first_min:\\n                second_min, first_min = first_min, p\\n            elif p < second_min:\\n                second_min = p\\n\\n        min_price = first_min + second_min\\n        return money - min_price if min_price <= money else money\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568553,
                "title": "short-simple-clean-java-solution",
                "content": "\\n```java []\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        Arrays.sort(prices);\\n        return (prices[0]+prices[1]) > money ? money : money-(prices[0]+prices[1]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        Arrays.sort(prices);\\n        return (prices[0]+prices[1]) > money ? money : money-(prices[0]+prices[1]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568972,
                "title": "python-sort-or-without-sort-o-n",
                "content": "\\n**Solution with sorting**\\n```\\nclass Solution:\\n    def buyChoco(self, prices: List[int], money: int) -> int:\\n        # Sort the prices array in ascending order\\n        prices.sort()\\n\\n        # Calculate the remaining money after buying the two cheapest chocolates\\n        remaining_money = money - prices[0] - prices[1]\\n\\n        # Check if the remaining money is non-negative\\n        if remaining_money >= 0:\\n            return remaining_money\\n        else:\\n            # If it\\'s not possible to buy two chocolates without going into debt,\\n            # return the initial money\\n            return money\\n\\n```\\n**Explanation**:\\n1. We start by sorting the `prices` array in ascending order. This allows us to easily find the two cheapest chocolates.\\n\\n2. We calculate the remaining money after buying the two cheapest chocolates by subtracting the prices of these chocolates from the initial `money`. The two cheapest chocolates are located at indices 0 and 1 in the sorted array, `prices[0]` and `prices[1]`, respectively.\\n\\n3. If the remaining money (`res`) is greater than or equal to 0, it means we have non-negative leftover money. In this case, we return `res` as the amount of money leftover after buying the chocolates.\\n\\n4. If the remaining money is negative, it means it\\'s not possible to buy two chocolates without going into debt. In this case, we return the initial `money` as it represents the amount of money we started with.\\n\\nThe sorting operation ensures that the two cheapest chocolates are considered for purchase, as they will be at the beginning of the sorted array. By taking the difference between the initial `money` and the prices of the two cheapest chocolates, we find the remaining money. If it\\'s non-negative, we return it as the leftover money. Otherwise, we return the initial `money`.\\n\\nThe time complexity of this solution is O(n log n), where n is the length of the `prices` array, due to the sorting operation. The space complexity is O(1) since the algorithm uses a constant amount of extra space to store the result.\\n\\n**Solution without sorting**\\n\\n```\\nclass Solution:\\n    def buyChoco(self, prices: List[int], money: int) -> int:\\n        min_price = float(\\'inf\\')\\n        second_min_price = float(\\'inf\\')\\n\\n        for price in prices:\\n            if price < min_price:\\n                second_min_price = min_price\\n                min_price = price\\n            elif price < second_min_price:\\n                second_min_price = price\\n\\n        remaining_money = money - min_price - second_min_price\\n        return remaining_money if remaining_money >= 0 else money\\n\\n```\\n\\n**Explanation:**\\n\\n1. Initialize two variables, `min_price` and `second_min_price`, with values greater than the maximum possible price. For example, we can set them to infinity or a very large number.\\n\\n2. Iterate through the `prices` array.\\n   - If the current price is less than `min_price`, update both `min_price` and `second_min_price` accordingly.\\n   - Otherwise, if the current price is less than `second_min_price`, update only `second_min_price`.\\n\\n3. Calculate the remaining money after buying the two chocolates. This can be done by subtracting the sum of `min_price` and `second_min_price` from the initial `money`.\\n\\n4. Return the remaining money if it is non-negative. Otherwise, return the initial `money`.",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def buyChoco(self, prices: List[int], money: int) -> int:\\n        # Sort the prices array in ascending order\\n        prices.sort()\\n\\n        # Calculate the remaining money after buying the two cheapest chocolates\\n        remaining_money = money - prices[0] - prices[1]\\n\\n        # Check if the remaining money is non-negative\\n        if remaining_money >= 0:\\n            return remaining_money\\n        else:\\n            # If it\\'s not possible to buy two chocolates without going into debt,\\n            # return the initial money\\n            return money\\n\\n```\n```\\nclass Solution:\\n    def buyChoco(self, prices: List[int], money: int) -> int:\\n        min_price = float(\\'inf\\')\\n        second_min_price = float(\\'inf\\')\\n\\n        for price in prices:\\n            if price < min_price:\\n                second_min_price = min_price\\n                min_price = price\\n            elif price < second_min_price:\\n                second_min_price = price\\n\\n        remaining_money = money - min_price - second_min_price\\n        return remaining_money if remaining_money >= 0 else money\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568916,
                "title": "c-maths",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        int x = INT_MAX,y = INT_MAX;\\n        for(auto &i: prices){\\n            if(x>i){\\n                y = x;\\n                x = i;\\n            }else if(y>i){\\n                y = i;\\n            }\\n        }\\n        if(x+y>money)return money;\\n        return money-x-y;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        int x = INT_MAX,y = INT_MAX;\\n        for(auto &i: prices){\\n            if(x>i){\\n                y = x;\\n                x = i;\\n            }else if(y>i){\\n                y = i;\\n            }\\n        }\\n        if(x+y>money)return money;\\n        return money-x-y;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568842,
                "title": "c-java-o-n-find-smallest-two-elements",
                "content": "Find the smallest (`min`) and the second smallest (`secondMin`) values in the prices, then deduct them from the money.\\n\\nC++:\\n```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        int min = 101, secondMin = 101;\\n        for (int p : prices) {\\n            if (p <= min) {\\n                secondMin = min;\\n                min = p;\\n            } else if (p < secondMin) {\\n                secondMin = p;\\n            }\\n        }\\n        return money - min - secondMin < 0 ? money : money - min - secondMin;\\n    }\\n};\\n```\\n\\nJava:\\n```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        int min = 101, secondMin = 101;\\n        for (int p : prices) {\\n            if (p <= min) {\\n                secondMin = min;\\n                min = p;\\n            } else if (p < secondMin) {\\n                secondMin = p;\\n            }\\n        }\\n        return money - min - secondMin < 0 ? money : money - min - secondMin;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        int min = 101, secondMin = 101;\\n        for (int p : prices) {\\n            if (p <= min) {\\n                secondMin = min;\\n                min = p;\\n            } else if (p < secondMin) {\\n                secondMin = p;\\n            }\\n        }\\n        return money - min - secondMin < 0 ? money : money - min - secondMin;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        int min = 101, secondMin = 101;\\n        for (int p : prices) {\\n            if (p <= min) {\\n                secondMin = min;\\n                min = p;\\n            } else if (p < secondMin) {\\n                secondMin = p;\\n            }\\n        }\\n        return money - min - secondMin < 0 ? money : money - min - secondMin;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568550,
                "title": "easiest-c-solution-image-explanation",
                "content": "**Important[![image](https://assets.leetcode.com/users/images/56357616-1bb0-424a-860f-af7c94b70139_1685205192.2741218.png):\\n](http://)** You may watch biggest sliding window playlist using  just a single and easy template with proper explanation.Just click my profile icon you will find a youtube link there. \\nThankyou\\n\\n![image](https://assets.leetcode.com/users/images/fa64ef68-1bf7-4787-afae-5ad6a02ffb91_1685203288.65488.png)\\n\\n```\\n int buyChoco(vector<int>& prices, int money) {\\n        \\n      sort(prices.begin(),prices.end());\\n      int minimum_sum=prices[0]+prices[1];\\n        \\n      if(minimum_sum>money) return money;    // you have take exactly two choco but if its more than money we will not purchase any choco\\n      else return money-minimum_sum;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n int buyChoco(vector<int>& prices, int money) {\\n        \\n      sort(prices.begin(),prices.end());\\n      int minimum_sum=prices[0]+prices[1];\\n        \\n      if(minimum_sum>money) return money;    // you have take exactly two choco but if its more than money we will not purchase any choco\\n      else return money-minimum_sum;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3569899,
                "title": "python-3-3-lines-w-heap-t-m-76-36",
                "content": "```\\nclass Solution:\\n    def buyChoco(self, prices: List[int], money: int) -> int:\\n\\n        heapify(prices)\\n        sm = heappop(prices)+heappop(prices)\\n        return money - sm if sm <= money else money\\n```\\n[https://leetcode.com/problems/buy-two-chocolates/submissions/958639608/](http://)\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1) in which *N* ~`len(prices)`.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def buyChoco(self, prices: List[int], money: int) -> int:\\n\\n        heapify(prices)\\n        sm = heappop(prices)+heappop(prices)\\n        return money - sm if sm <= money else money\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569084,
                "title": "python3-heap",
                "content": "Subtract twice from **money** the price of the two cheapest chocolates sequentially using **heappop()**. Then compare received ans with zero, as we are asked in the description.\\n\\n```\\nclass Solution:\\n    def buyChoco(self, prices: List[int], money: int) -> int:\\n        heapify(prices)\\n        \\n        ans = money - heappop(prices) - heappop(prices)\\n        \\n        return ans if ans >= 0 else money\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def buyChoco(self, prices: List[int], money: int) -> int:\\n        heapify(prices)\\n        \\n        ans = money - heappop(prices) - heappop(prices)\\n        \\n        return ans if ans >= 0 else money\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568915,
                "title": "shortest-code",
                "content": "\\n# Complexity\\n- Time complexity: n logn \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        sort(prices.begin(), prices.end());\\n        if(money-prices[0]-prices[1]<0) return money;\\n        return money-prices[0]-prices[1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        sort(prices.begin(), prices.end());\\n        if(money-prices[0]-prices[1]<0) return money;\\n        return money-prices[0]-prices[1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568705,
                "title": "very-easy-to-understand-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen we sort the vector the first two elements are the price of two cheapest chocolate available.\\nIf we have less money than that we can\\'t buy.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\npublic:\\n    int buyChoco(vector<int>& prices, int money) \\n    {\\n        \\n        sort(prices.begin(),prices.end());\\n        int sum = prices[0] + prices[1];\\n        if(sum<=money)\\n        {\\n            return (money - sum);\\n        }\\n        else \\n            return money;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    \\npublic:\\n    int buyChoco(vector<int>& prices, int money) \\n    {\\n        \\n        sort(prices.begin(),prices.end());\\n        int sum = prices[0] + prices[1];\\n        if(sum<=money)\\n        {\\n            return (money - sum);\\n        }\\n        else \\n            return money;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570582,
                "title": "o-n-2-o-nlog-n-o-n-optimization-code",
                "content": "\\n\\n# 1. Brute Force Code\\n### Approach\\nJust using nested forloops for generating all the possible ways of buying the chocolates and finding the min valid buying possible.\\n### Complexity\\n- Time complexity: O(n^2)\\n\\n- Space complexity: O(1)\\n\\n```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        int minMoney = Integer.MAX_VALUE, n = prices.length;\\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n;j++){\\n                int price = prices[i] + prices[j];\\n                if(price <= money){\\n                    minMoney = Math.min(minMoney,price);\\n                }\\n            }\\n        }\\n        if(minMoney <= money){\\n            return money - minMoney;\\n        }\\n        return money;\\n    }\\n}\\n\\n// Brute Force \\n// Time Complexity : O(n^2)\\n// Space Complexity : O(1)\\n```\\n\\n\\n\\n# 2. O(nlog(n)) Optimized Code\\n### Approach\\nSorting array and then using the forst two elements as the minimum prices.\\n### Complexity\\n- Time complexity: O(nlog(n))\\n\\n- Space complexity: O(1)\\n\\n```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        Arrays.sort(prices);\\n        int price1 = prices[0], price2 = prices[1], total = price1+price2;\\n        if(total <= money) return money-total;\\n        return money;\\n    }\\n}\\n\\n// Brute Force \\n// Time Complexity : O(nlog(n))\\n// Space Complexity : O(1)\\n```\\n\\n# 3. O(n) Optimized Code With Flaw\\n### Approach\\nHere we are finding the minimum and second minimum elements of the array in O(n) complexity.\\nBut the flaw lies in using two for loops that then we use 2 different for loops to find min and second min then we can not assure that the two minimum are distinct, hence we will have to write an algo which finds min and second min using single for loop. \\n\\n### Complexity\\n- Time complexity: O(n + n)\\n\\n- Space complexity: O(1)\\n\\n```\\nclass Solution {\\n    \\n    // Standard Algorithm To Calculate 2 smallest elements present in the array. \\n    private static int[] findSmallestTwo(int[] arr){\\n        int smallest = Integer.MAX_VALUE, secondSmallest = Integer.MAX_VALUE;\\n        for(int i=0;i<arr.length;i++){if(arr[i]<smallest) smallest=arr[i];}\\n        for(int j=0;j<arr.length;j++){if(arr[j]<secondSmallest && arr[j]>smallest) secondSmallest=arr[j];}\\n        return new int[]{smallest, secondSmallest};\\n    }\\n    \\n    public int buyChoco(int[] prices, int money) {\\n        int[] minPrices = findSmallestTwo(prices);\\n        int total = minPrices[0] + minPrices[1];\\n        if(total<=money) return money-total;\\n        return money;\\n    }\\n}\\n\\n// Optimized Code - Wrong Answer \\n// Time Complexity : O(n + n)\\n// Space Complexity : O(1)\\n```\\n\\n# 4. O(n) Most Optimized Accepted Code \\n### Approach\\nHere we are using only single for loop to find min and second min in the given array.\\n\\n### Complexity\\n- Time complexity: O(n + n)\\n\\n- Space complexity: O(1)\\n\\n```\\nclass Solution {\\n    \\n    // Standard Algorithm To Calculate 2 smallest elements present in the array. \\n    private static int[] findSmallestTwo(int[] arr){\\n        int smallest = Integer.MAX_VALUE, secondSmallest = Integer.MAX_VALUE;\\n        for(int num : arr){\\n            if(num <= smallest){\\n                secondSmallest = smallest;\\n                smallest = num;\\n            }else if(num < secondSmallest){\\n                secondSmallest = num;\\n            }\\n        }\\n        return new int[]{smallest, secondSmallest};\\n    }\\n    \\n    public int buyChoco(int[] prices, int money) {\\n        int[] minPrices = findSmallestTwo(prices);\\n        int total = minPrices[0] + minPrices[1];\\n        if(total<=money) return money-total;\\n        return money;\\n    }\\n}\\n\\n// Optimized Code - Accepted \\n// Time Complexity : O(n + n)\\n// Space Complexity : O(1)\\n```\\n\\n# *Learning outcome is how to find min and second_min element of a given array in O(n) time complexity, here are the standard algorithm for the same*\\n\\n- Algorithm 1 - Preffered \\n\\n```\\n// Standard Algorithm To Calculate 2 smallest elements present in the array. \\n    private static int[] findSmallestTwo(int[] arr){\\n        int smallest = Integer.MAX_VALUE, secondSmallest = Integer.MAX_VALUE;\\n        for(int num : arr){\\n            if(num <= smallest){\\n                secondSmallest = smallest;\\n                smallest = num;\\n            }else if(num < secondSmallest){\\n                secondSmallest = num;\\n            }\\n        }\\n        return new int[]{smallest, secondSmallest};\\n    }\\n```\\n- Algorithm 2\\n```\\n// Standard Algorithm To Calculate 2 smallest elements present in the array. \\n    private static int[] findSmallestTwo(int[] arr){\\n        int smallest = Integer.MAX_VALUE, secondSmallest = Integer.MAX_VALUE;\\n        for(int i=0;i<arr.length;i++){if(arr[i]<smallest) smallest=arr[i];}\\n        for(int j=0;j<arr.length;j++){if(arr[j]<secondSmallest && arr[j]>smallest) secondSmallest=arr[j];}\\n        return new int[]{smallest, secondSmallest};\\n    }\\n```\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        int minMoney = Integer.MAX_VALUE, n = prices.length;\\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n;j++){\\n                int price = prices[i] + prices[j];\\n                if(price <= money){\\n                    minMoney = Math.min(minMoney,price);\\n                }\\n            }\\n        }\\n        if(minMoney <= money){\\n            return money - minMoney;\\n        }\\n        return money;\\n    }\\n}\\n\\n// Brute Force \\n// Time Complexity : O(n^2)\\n// Space Complexity : O(1)\\n```\n```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        Arrays.sort(prices);\\n        int price1 = prices[0], price2 = prices[1], total = price1+price2;\\n        if(total <= money) return money-total;\\n        return money;\\n    }\\n}\\n\\n// Brute Force \\n// Time Complexity : O(nlog(n))\\n// Space Complexity : O(1)\\n```\n```\\nclass Solution {\\n    \\n    // Standard Algorithm To Calculate 2 smallest elements present in the array. \\n    private static int[] findSmallestTwo(int[] arr){\\n        int smallest = Integer.MAX_VALUE, secondSmallest = Integer.MAX_VALUE;\\n        for(int i=0;i<arr.length;i++){if(arr[i]<smallest) smallest=arr[i];}\\n        for(int j=0;j<arr.length;j++){if(arr[j]<secondSmallest && arr[j]>smallest) secondSmallest=arr[j];}\\n        return new int[]{smallest, secondSmallest};\\n    }\\n    \\n    public int buyChoco(int[] prices, int money) {\\n        int[] minPrices = findSmallestTwo(prices);\\n        int total = minPrices[0] + minPrices[1];\\n        if(total<=money) return money-total;\\n        return money;\\n    }\\n}\\n\\n// Optimized Code - Wrong Answer \\n// Time Complexity : O(n + n)\\n// Space Complexity : O(1)\\n```\n```\\nclass Solution {\\n    \\n    // Standard Algorithm To Calculate 2 smallest elements present in the array. \\n    private static int[] findSmallestTwo(int[] arr){\\n        int smallest = Integer.MAX_VALUE, secondSmallest = Integer.MAX_VALUE;\\n        for(int num : arr){\\n            if(num <= smallest){\\n                secondSmallest = smallest;\\n                smallest = num;\\n            }else if(num < secondSmallest){\\n                secondSmallest = num;\\n            }\\n        }\\n        return new int[]{smallest, secondSmallest};\\n    }\\n    \\n    public int buyChoco(int[] prices, int money) {\\n        int[] minPrices = findSmallestTwo(prices);\\n        int total = minPrices[0] + minPrices[1];\\n        if(total<=money) return money-total;\\n        return money;\\n    }\\n}\\n\\n// Optimized Code - Accepted \\n// Time Complexity : O(n + n)\\n// Space Complexity : O(1)\\n```\n```\\n// Standard Algorithm To Calculate 2 smallest elements present in the array. \\n    private static int[] findSmallestTwo(int[] arr){\\n        int smallest = Integer.MAX_VALUE, secondSmallest = Integer.MAX_VALUE;\\n        for(int num : arr){\\n            if(num <= smallest){\\n                secondSmallest = smallest;\\n                smallest = num;\\n            }else if(num < secondSmallest){\\n                secondSmallest = num;\\n            }\\n        }\\n        return new int[]{smallest, secondSmallest};\\n    }\\n```\n```\\n// Standard Algorithm To Calculate 2 smallest elements present in the array. \\n    private static int[] findSmallestTwo(int[] arr){\\n        int smallest = Integer.MAX_VALUE, secondSmallest = Integer.MAX_VALUE;\\n        for(int i=0;i<arr.length;i++){if(arr[i]<smallest) smallest=arr[i];}\\n        for(int j=0;j<arr.length;j++){if(arr[j]<secondSmallest && arr[j]>smallest) secondSmallest=arr[j];}\\n        return new int[]{smallest, secondSmallest};\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569004,
                "title": "easy-beginner-friendly-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        sort(prices.begin(),prices.end());\\n         if(money-(prices[0]+prices[1])>=0)\\n            {\\n                return money-(prices[0]+prices[1]);\\n            }\\n        \\n        return money;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        sort(prices.begin(),prices.end());\\n         if(money-(prices[0]+prices[1])>=0)\\n            {\\n                return money-(prices[0]+prices[1]);\\n            }\\n        \\n        return money;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3802295,
                "title": "easy-and-simple-java-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst sort the given prices array.Then compare the prices of first two elements with money and then return the result accordingly.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n log n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        Arrays.sort(prices);\\n        if(prices[0]+prices[1] > money){\\n            return money;\\n        }\\n        else{\\n            return money - prices[0] - prices[1];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        Arrays.sort(prices);\\n        if(prices[0]+prices[1] > money){\\n            return money;\\n        }\\n        else{\\n            return money - prices[0] - prices[1];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688197,
                "title": "c-simple-straight-forward-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        sort(prices.begin(),prices.end());\\n        int s = prices[0] + prices[1];\\n        if(s > money)\\n            return money;\\n        else if(s == money)\\n            return 0;\\n        else\\n            return (money - s);\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/39451a8b-4887-46f6-9b8f-b994e2e40253_1687453528.6643982.jpeg)\\n\\n**please upvote!! if you like.**\\ncomment below\\uD83D\\uDC47",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        sort(prices.begin(),prices.end());\\n        int s = prices[0] + prices[1];\\n        if(s > money)\\n            return money;\\n        else if(s == money)\\n            return 0;\\n        else\\n            return (money - s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624592,
                "title": "array-sorting-java-solution",
                "content": "This is my simple Java solution \\n\\n# Code\\n```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        Arrays.sort(prices);\\n        int amount = money - (prices[0] + prices[1]);\\n        \\n        return amount < 0 ? money : amount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        Arrays.sort(prices);\\n        int amount = money - (prices[0] + prices[1]);\\n        \\n        return amount < 0 ? money : amount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569041,
                "title": "c-python-easy-o-n-solution",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        int min1 = INT_MAX, min2 = INT_MAX;\\n        for(auto i : prices) {\\n            if(i < min1) {\\n                min2 = min1;\\n                min1 = i;\\n            }\\n            else if(i < min2) min2 = i;\\n        }\\n        if(min1 + min2 <= money) return money - (min1 + min2);\\n        return money;\\n    }\\n};\\n```\\n\\n# Python / Python3\\n```\\nclass Solution:\\n    def buyChoco(self, prices: List[int], money: int) -> int:\\n        min1 = min2 = 101\\n        for i in prices:\\n            if i < min1:\\n                min2 = min1\\n                min1 = i\\n            elif i < min2:\\n                min2 = i\\n        if min1 + min2 <= money:\\n            return money - (min1 + min2)\\n        return money\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        int min1 = INT_MAX, min2 = INT_MAX;\\n        for(auto i : prices) {\\n            if(i < min1) {\\n                min2 = min1;\\n                min1 = i;\\n            }\\n            else if(i < min2) min2 = i;\\n        }\\n        if(min1 + min2 <= money) return money - (min1 + min2);\\n        return money;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def buyChoco(self, prices: List[int], money: int) -> int:\\n        min1 = min2 = 101\\n        for i in prices:\\n            if i < min1:\\n                min2 = min1\\n                min1 = i\\n            elif i < min2:\\n                min2 = i\\n        if min1 + min2 <= money:\\n            return money - (min1 + min2)\\n        return money\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568888,
                "title": "c-4-line-code-easy-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        // Sorting the prices in ascending order\\n        sort(prices.begin(), prices.end());\\n\\n        // Calculating the sum of the two lowest prices\\n        int chk = prices[0] + prices[1];\\n\\n        // Checking if there\\'s enough money to buy the chocolates\\n        if (money >= chk)\\n            return money - chk; // Returning the remaining money after buying the chocolates\\n        \\n        return money; // Returning the original amount of money if it\\'s not enough to buy the chocolates\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        // Sorting the prices in ascending order\\n        sort(prices.begin(), prices.end());\\n\\n        // Calculating the sum of the two lowest prices\\n        int chk = prices[0] + prices[1];\\n\\n        // Checking if there\\'s enough money to buy the chocolates\\n        if (money >= chk)\\n            return money - chk; // Returning the remaining money after buying the chocolates\\n        \\n        return money; // Returning the original amount of money if it\\'s not enough to buy the chocolates\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568551,
                "title": "two-lines-c-add-index-0-and-1-only",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n\\n    // Sort the prices in non-decreasing order\\n    sort(prices.begin(), prices.end());\\n   \\n    return (( money -(prices[0] + prices[1])) >= 0) ? ( money -(prices[0] + prices[1])) : money;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n\\n    // Sort the prices in non-decreasing order\\n    sort(prices.begin(), prices.end());\\n   \\n    return (( money -(prices[0] + prices[1])) >= 0) ? ( money -(prices[0] + prices[1])) : money;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568538,
                "title": "best-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        sort(prices.begin(),prices.end());\\n        int a = prices[0]+prices[1];\\n        if(a<=money){\\n            return money-a;\\n        }\\n        else\\n            return money;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        sort(prices.begin(),prices.end());\\n        int a = prices[0]+prices[1];\\n        if(a<=money){\\n            return money-a;\\n        }\\n        else\\n            return money;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3824956,
                "title": "1-liner-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        sort(prices.begin(),prices.end());\\n        if(money-prices[0]-prices[1]>=0)\\n        return money-prices[0]-prices[1];\\n        else \\n        return money;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        sort(prices.begin(),prices.end());\\n        if(money-prices[0]-prices[1]>=0)\\n        return money-prices[0]-prices[1];\\n        else \\n        return money;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3802271,
                "title": "easy-c-solution",
                "content": "# Approach\\nSort the array and compare money with the first 2 elements...\\n# Complexity\\n- Time complexity:\\nO(nlog n)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        sort(prices.begin(),prices.end());\\n        if(money < prices[0] + prices[1]) return money;\\n        return (money - prices[0] - prices[1]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        sort(prices.begin(),prices.end());\\n        if(money < prices[0] + prices[1]) return money;\\n        return (money - prices[0] - prices[1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3783806,
                "title": "java-easy-solution-using-sorting",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n      Arrays.sort(prices);\\n      return prices[0] + prices[1] > money ? money : money - (prices[0] + prices[1]);  \\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n      Arrays.sort(prices);\\n      return prices[0] + prices[1] > money ? money : money - (prices[0] + prices[1]);  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735121,
                "title": "simple-typescript-solution",
                "content": "# Code\\n```ts\\nfunction buyChoco(prices: number[], money: number): number {\\n    prices.sort((a, b) => a - b)\\n    const totalPrice = prices[0] + prices[1]\\n    if (totalPrice > money) return money\\n    return money - totalPrice\\n};\\n```\\n\\n# Thank you\\nUpvote if you like \\u2B06\\uFE0F\\nIf you have any questions, please let me know in the comment section.",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```ts\\nfunction buyChoco(prices: number[], money: number): number {\\n    prices.sort((a, b) => a - b)\\n    const totalPrice = prices[0] + prices[1]\\n    if (totalPrice > money) return money\\n    return money - totalPrice\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3667901,
                "title": "sum-of-smallest-and-second-smallest-numbers-o-n",
                "content": "**Just find the smallest and second smallest numbers and add them. after that check the given condition :) **\\n```\\nint buyChoco(vector<int>& prices, int money) {\\n        int smallest = INT_MAX, second_smallest = 0;\\n        for(int i=0; i<prices.size(); i++){\\n            if(smallest > prices[i]){\\n                second_smallest = smallest;\\n                smallest = prices[i];\\n            }\\n            else if(second_smallest > prices[i] || second_smallest == INT_MAX){\\n                 second_smallest = prices[i];\\n            }\\n        }\\n        if(smallest + second_smallest <= money)\\n            return (money - (smallest + second_smallest));\\n        return money;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "**Just find the smallest and second smallest numbers and add them. after that check the given condition :) **\\n```\\nint buyChoco(vector<int>& prices, int money) {\\n        int smallest = INT_MAX, second_smallest = 0;\\n        for(int i=0; i<prices.size(); i++){\\n            if(smallest > prices[i]){\\n                second_smallest = smallest;\\n                smallest = prices[i];\\n            }\\n            else if(second_smallest > prices[i] || second_smallest == INT_MAX){\\n                 second_smallest = prices[i];\\n            }\\n        }\\n        if(smallest + second_smallest <= money)\\n            return (money - (smallest + second_smallest));\\n        return money;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3641995,
                "title": "easy-2-lines-code-using-sorting-with-o-nlogn-tc",
                "content": "# Intuition\\nMy first thought about this problem was if we want to buy exactly two chocos at minimal cost, we need to sort the prices of chocos in ascending order and hence I thought of this approach.\\n# Approach \\n- Simply just sort the prices array.\\n- check whether the money is greater than the prices of 0th and 1st index chocos combined.\\n- If yes we can buy the choc and return the leftover money.\\n- If no we can directly return the money.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        sort(prices.begin(),prices.end()); // sorting using inbuilt function\\n    if(money<prices[0]+prices[1]) return money; // here we cant buy 2 chocos\\n    return money-prices[0]-prices[1]; // just subtracting the money and returning the leftover money.\\n    }\\n};\\n```\\n# Please do upvote if you liked my approach.",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        sort(prices.begin(),prices.end()); // sorting using inbuilt function\\n    if(money<prices[0]+prices[1]) return money; // here we cant buy 2 chocos\\n    return money-prices[0]-prices[1]; // just subtracting the money and returning the leftover money.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3640040,
                "title": "python3-beats-94-85",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def buyChoco(self, prices: List[int], money: int) -> int:\\n        prices.sort()\\n        if prices[1]+prices[0]<=money:\\n            return money-(prices[1]+prices[0])\\n        return money\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def buyChoco(self, prices: List[int], money: int) -> int:\\n        prices.sort()\\n        if prices[1]+prices[0]<=money:\\n            return money-(prices[1]+prices[0])\\n        return money\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595091,
                "title": "easy-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int buyChoco(vector<int>& prices, int money) \\n    {\\n        sort(prices.begin(),prices.end());\\n        int leftover=money-prices[0]-prices[1];\\n        if(leftover>=0) return leftover;\\n        return money;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int buyChoco(vector<int>& prices, int money) \\n    {\\n        sort(prices.begin(),prices.end());\\n        int leftover=money-prices[0]-prices[1];\\n        if(leftover>=0) return leftover;\\n        return money;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3576170,
                "title": "beats-100-code-explained-in-detail",
                "content": "# *About the problem*\\nWe need to find buy two such chocolates so that the least amount of money can be spent.\\n\\n---\\n\\n\\n# *Approach*\\n1. Sort the array (so now we get the least costly ones as our starting elements)\\n2. The first two elements in the sorted element can be bought for the least amount of money.\\n3. Hence, we subtract the amount of the first two elements in the sorted array from the money we have to find the least amount that can be spent.\\n\\n---\\n\\n# *Code*\\n```\\n/**\\n * @param {number[]} prices\\n * @param {number} money\\n * @return {number}\\n */\\nvar buyChoco = function(prices, money) {\\n    const sortPrices = prices.sort((a,b)=>a-b)//first sort the prices\\n    const ans = money-sortPrices[0]-sortPrices[1]//since first and second ele in the array will be the least costly ones we buy that and subtract it from the money we have to find the leftover money\\n    return ans >= 0 ? ans : money  //if leftover money is positive then print it else print money.\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sort"
                ],
                "code": "```\\n/**\\n * @param {number[]} prices\\n * @param {number} money\\n * @return {number}\\n */\\nvar buyChoco = function(prices, money) {\\n    const sortPrices = prices.sort((a,b)=>a-b)//first sort the prices\\n    const ans = money-sortPrices[0]-sortPrices[1]//since first and second ele in the array will be the least costly ones we buy that and subtract it from the money we have to find the leftover money\\n    return ans >= 0 ? ans : money  //if leftover money is positive then print it else print money.\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3572304,
                "title": "c-sorting-to-linear-time-solutions-12ms-46-6mb",
                "content": "One of the easiest problems in a while, let\\'s go eviscerating it a bit more than a trivial solution, that we will do first sorting `prices` to get the lowes two values first (I guess one even more basic solution would be to brute-force our way through, checking all the possible pairs, but I doubt anybody with a working, non panicked brain would do that in an engineering interview).\\n\\nOnce we get the two lower values, we can sum them in `res` and then apply the simple rules to `return` either the money left (if we can purchase the pair) or the initial one (if we cannot purchase it).\\n\\n# Complexity\\n- Time complexity: $$O(n log(n))$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        // preparing prices\\n        sort(begin(prices), end(prices));\\n        // support variables\\n        int res = prices[0] + prices[1];\\n        return res > money ? money : money - res;\\n    }\\n};\\n```\\n\\nCan we do better? Well, sure: we might use a priority queue (`pq`) to store only the two smaller values:\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ (more precisely, `n log(2)`, but we remove the constant factor)\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        // support variables\\n        int res = 0;\\n        priority_queue<int> pq;\\n        // preparing prices\\n        for (int p: prices) {\\n            pq.push(p);\\n            if (pq.size() > 2) pq.pop();\\n        }\\n        // getting the top two values\\n        while (pq.size()) {\\n            res += pq.top();\\n            pq.pop();\\n        }\\n        return res > money ? money : money - res;\\n    }\\n};\\n```\\n\\nCan we do even better?\\n\\nSure, storing the values we want to have in `smaller` and `smallest`. And this one went waaay faster (like 3X) than the rest!\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        // support variables\\n        int res, smaller = INT_MAX, smallest = INT_MAX;\\n        // parsing prices\\n        for (int p: prices) {\\n            if (p < smallest) smaller = smallest, smallest = p;\\n            else if (p < smaller) smaller = p;\\n        }\\n        res = smaller + smallest;\\n        return res > money ? money : money - res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort",
                    "Heap (Priority Queue)",
                    "Bucket Sort"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        // preparing prices\\n        sort(begin(prices), end(prices));\\n        // support variables\\n        int res = prices[0] + prices[1];\\n        return res > money ? money : money - res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        // support variables\\n        int res = 0;\\n        priority_queue<int> pq;\\n        // preparing prices\\n        for (int p: prices) {\\n            pq.push(p);\\n            if (pq.size() > 2) pq.pop();\\n        }\\n        // getting the top two values\\n        while (pq.size()) {\\n            res += pq.top();\\n            pq.pop();\\n        }\\n        return res > money ? money : money - res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        // support variables\\n        int res, smaller = INT_MAX, smallest = INT_MAX;\\n        // parsing prices\\n        for (int p: prices) {\\n            if (p < smallest) smaller = smallest, smallest = p;\\n            else if (p < smaller) smaller = p;\\n        }\\n        res = smaller + smallest;\\n        return res > money ? money : money - res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571237,
                "title": "java-o-n-time-complexity-simple-and-easy-understandable-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe problem are simple :- you just need to find the smallest two integer from you array;\\nand chech if the sum of two smallest integer is greater than your given money, means you don\\'t have enough money to buy tow chocolates then simple return the original money.\\n\\n***Please Check the Java Code, You will able to better understand*** \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N) (Best, Wors and Average all)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        int s1 = 101;\\n        int s2 = 101;\\n        for (int i : prices) {\\n            if (s1 > i) {\\n                s2 = s1;\\n                s1 = i;\\n            } else if (s2 >= i){\\n                s2 = i;\\n            }\\n        }\\n        return (s1+s2 <= money) ? money - (s1 + s2) : money;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        int s1 = 101;\\n        int s2 = 101;\\n        for (int i : prices) {\\n            if (s1 > i) {\\n                s2 = s1;\\n                s1 = i;\\n            } else if (s2 >= i){\\n                s2 = i;\\n            }\\n        }\\n        return (s1+s2 <= money) ? money - (s1 + s2) : money;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570053,
                "title": "easiest-solution",
                "content": "# Complexity\\n- Time complexity : $$O(N logN)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        sort(prices.begin(),prices.end());\\n        if(prices[0]+prices[1] > money) return money;\\n        return money-prices[0]-prices[1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        sort(prices.begin(),prices.end());\\n        if(prices[0]+prices[1] > money) return money;\\n        return money-prices[0]-prices[1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569323,
                "title": "go-o-n-time-o-1-space",
                "content": "Find the two smallest numbers.\\n\\n```\\nfunc buyChoco(prices []int, money int) int {\\n    min, min2 := math.MaxInt, math.MaxInt\\n    for _, p := range prices {\\n        if p < min {\\n            min, min2 = p, min\\n        } else if p < min2 {\\n            min2 = p\\n        }\\n    }\\n    leftover := money - min - min2\\n    if leftover < 0 {\\n        return money\\n    }\\n    return leftover\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc buyChoco(prices []int, money int) int {\\n    min, min2 := math.MaxInt, math.MaxInt\\n    for _, p := range prices {\\n        if p < min {\\n            min, min2 = p, min\\n        } else if p < min2 {\\n            min2 = p\\n        }\\n    }\\n    leftover := money - min - min2\\n    if leftover < 0 {\\n        return money\\n    }\\n    return leftover\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3569025,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def buyChoco(self, prices: List[int], money: int) -> int:\\n        ans=money-sum(sorted(prices)[:2])\\n        if ans>=0:\\n            return ans\\n\\n        return money    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def buyChoco(self, prices: List[int], money: int) -> int:\\n        ans=money-sum(sorted(prices)[:2])\\n        if ans>=0:\\n            return ans\\n\\n        return money    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568855,
                "title": "o-n-time-short-code-100-fast-c-js-java-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this approach is to find the minimum-priced chocolate and then find the second minimum sum of two chocolate prices by iterating through the array. By comparing the minimum sum with the initial money, the solution determines if it is possible to buy two chocolates without going into debt. The leftover money is then calculated accordingly.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Find the minimum-priced chocolate (mini) and its index (index) in the given array prices.\\n- Initialize a variable mini2 to store the minimum sum of two chocolate prices, set it to the maximum integer value.\\n- Iterate through the array prices, excluding the chocolate at the index found in step 1.\\n- Calculate the sum of the minimum-priced chocolate (mini) and the current chocolate\\'s price (p[i]).\\n- Update mini2 with the minimum sum encountered so far.\\n- Check if mini2 is less than or equal to the initial money:\\n- If true, return the difference between the initial money and mini2 as the leftover money.\\n- If false, return the original money value.\\n\\n# Complexity\\n- Time complexity:\\nAs we are only travesing the vector, so linear time O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& p, int money) {\\n        int mini=101,mini2=INT_MAX,index=0;\\n        for(int i=0;i<p.size();i++)\\n            if(mini>p[i]){\\n                index=i;\\n                mini=p[i];\\n            }\\n\\n        for(int i=0;i<p.size();i++){\\n            if(i!=index){\\n                mini2=min(mini2,mini+p[i]);\\n            }\\n        }\\n        return (mini2<=money?money-mini2:money);\\n    }\\n};\\n```\\n\\n# Java\\n```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        int mini = 101, mini2 = Integer.MAX_VALUE, index = 0;\\n\\n        for (int i = 0; i < prices.length; i++) {\\n            if (mini > prices[i]) {\\n                index = i;\\n                mini = prices[i];\\n            }\\n        }\\n\\n        for (int i = 0; i < prices.length; i++) {\\n            if (i != index) {\\n                mini2 = Math.min(mini2, mini + prices[i]);\\n            }\\n        }\\n        return (mini2 <= money ? money - mini2 : money);\\n    }\\n}\\n\\n```\\n\\n# JavaScript\\n```\\n/**\\n * @param {number[]} prices\\n * @param {number} money\\n * @return {number}\\n */\\nvar buyChoco = function(prices, money) {\\n    let mini = 101;\\n    let mini2 = Infinity;\\n    let index = 0;\\n\\n    for (let i = 0; i < prices.length; i++) {\\n        if (mini > prices[i]) {\\n            index = i;\\n            mini = prices[i];\\n        }\\n    }\\n    \\n    for (let i = 0; i < prices.length; i++) {\\n        if (i !== index) {\\n            mini2 = Math.min(mini2, mini + prices[i]);\\n        }\\n    }\\n    \\n    return (mini2 <= money ? money - mini2 : money);\\n};\\n\\n```\\n\\n# Python3\\n```\\nclass Solution:\\n    def buyChoco(self, prices: List[int], money: int) -> int:\\n        mini = 101\\n        mini2 = float(\\'inf\\')\\n        index = 0\\n        \\n        for i in range(len(prices)):\\n            if mini > prices[i]:\\n                index = i\\n                mini = prices[i]\\n        \\n       \\n        for i in range(len(prices)):\\n            if i != index:\\n                mini2 = min(mini2, mini + prices[i])\\n        \\n        \\n        return money - mini2 if mini2 <= money else money\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& p, int money) {\\n        int mini=101,mini2=INT_MAX,index=0;\\n        for(int i=0;i<p.size();i++)\\n            if(mini>p[i]){\\n                index=i;\\n                mini=p[i];\\n            }\\n\\n        for(int i=0;i<p.size();i++){\\n            if(i!=index){\\n                mini2=min(mini2,mini+p[i]);\\n            }\\n        }\\n        return (mini2<=money?money-mini2:money);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        int mini = 101, mini2 = Integer.MAX_VALUE, index = 0;\\n\\n        for (int i = 0; i < prices.length; i++) {\\n            if (mini > prices[i]) {\\n                index = i;\\n                mini = prices[i];\\n            }\\n        }\\n\\n        for (int i = 0; i < prices.length; i++) {\\n            if (i != index) {\\n                mini2 = Math.min(mini2, mini + prices[i]);\\n            }\\n        }\\n        return (mini2 <= money ? money - mini2 : money);\\n    }\\n}\\n\\n```\n```\\n/**\\n * @param {number[]} prices\\n * @param {number} money\\n * @return {number}\\n */\\nvar buyChoco = function(prices, money) {\\n    let mini = 101;\\n    let mini2 = Infinity;\\n    let index = 0;\\n\\n    for (let i = 0; i < prices.length; i++) {\\n        if (mini > prices[i]) {\\n            index = i;\\n            mini = prices[i];\\n        }\\n    }\\n    \\n    for (let i = 0; i < prices.length; i++) {\\n        if (i !== index) {\\n            mini2 = Math.min(mini2, mini + prices[i]);\\n        }\\n    }\\n    \\n    return (mini2 <= money ? money - mini2 : money);\\n};\\n\\n```\n```\\nclass Solution:\\n    def buyChoco(self, prices: List[int], money: int) -> int:\\n        mini = 101\\n        mini2 = float(\\'inf\\')\\n        index = 0\\n        \\n        for i in range(len(prices)):\\n            if mini > prices[i]:\\n                index = i\\n                mini = prices[i]\\n        \\n       \\n        for i in range(len(prices)):\\n            if i != index:\\n                mini2 = min(mini2, mini + prices[i])\\n        \\n        \\n        return money - mini2 if mini2 <= money else money\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568773,
                "title": "easy-4-line-beginner-friendly-code-explained-c",
                "content": "# Intuition\\nTo have maximum money left after buying the two chocolates, we need to find the two chocolate with minimum cost.\\n\\n# Approach\\nSort the vector and the intital two values are the least priced chocolates\\n>**if** there sum is bigger than money then its not possible to buy, therefore return money (as stated in question)\\n>**else** return the money after subtracting the cost of two min chocolates\\n\\n# Complexity\\n- Time complexity: O(n*logn)\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        sort(prices.begin(), prices.end());\\n        if((prices[0] + prices[1]) <= money)\\n            return (money -(prices[0] + prices[1]));\\n        return money;\\n    }\\n};\\n```\\n# UPVOTE\\u2B06\\uFE0F if you liked the explanation",
                "solutionTags": [
                    "C++",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        sort(prices.begin(), prices.end());\\n        if((prices[0] + prices[1]) <= money)\\n            return (money -(prices[0] + prices[1]));\\n        return money;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568714,
                "title": "c-solution-easy-to-understand-line-by-line-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the code is to sort the prices in ascending order and then select the two lowest-priced chocolates. By doing so, we ensure that we minimize the sum of the prices of the two chocolates.\\n\\nThe code first sorts the prices using the sort function, which rearranges the elements in non-decreasing order. After sorting, the two lowest prices will be at the beginning of the array.\\n\\nThe code then calculates the leftover money by subtracting the sum of the two lowest prices from the initial amount of money. If the leftover money is non-negative, it is returned as the result. Otherwise, if the sum of the two lowest prices exceeds the initial amount of money, the function returns the initial amount of money itself.\\n\\nOverall, the approach aims to find the two lowest-priced chocolates and check if they can be purchased within the given amount of money. If they can, the leftover money is returned; otherwise, the initial amount of money is returned.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach used in the code is quite straightforward:\\n\\nSort the prices in non-decreasing order.\\nCalculate the sum of the two lowest-priced chocolates.\\nCheck if the sum is less than or equal to the initial amount of money.\\nIf it is, subtract the sum from the initial amount of money and return the result as the leftover money.\\nIf it is not, return the initial amount of money as there is no way to buy two chocolates without going into debt.\\nThe code takes advantage of the fact that sorting the prices allows us to easily identify the two lowest-priced chocolates. By comparing the sum of these two prices with the initial amount of money, we can determine if it is possible to make the purchase without going into debt.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this approach is determined by the sorting step, which has a time complexity of O(n log n) in the average case, where n is the number of elements in the prices array. The subsequent calculations are constant time operations.\\n\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the code is O(1) as it does not require any additional space that grows with the input size.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        // Sort the prices in non-decreasing order\\n        sort(prices.begin(),prices.end());\\n        \\n        // Calculate the sum of the two lowest-priced chocolates\\n        int submisson = prices[0] + prices[1];\\n        \\n        // Check if the sum is less than or equal to the initial amount of money\\n        if (submisson <= money) {\\n            // If it is, subtract the sum from the initial amount of money and return the result as the leftover money\\n            return money - submisson;\\n        } else {\\n            // If the sum exceeds the initial amount of money, return the initial amount of money itself\\n            return money;\\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        // Sort the prices in non-decreasing order\\n        sort(prices.begin(),prices.end());\\n        \\n        // Calculate the sum of the two lowest-priced chocolates\\n        int submisson = prices[0] + prices[1];\\n        \\n        // Check if the sum is less than or equal to the initial amount of money\\n        if (submisson <= money) {\\n            // If it is, subtract the sum from the initial amount of money and return the result as the leftover money\\n            return money - submisson;\\n        } else {\\n            // If the sum exceeds the initial amount of money, return the initial amount of money itself\\n            return money;\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568695,
                "title": "priorityqueue-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n    \\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for(int n : prices){\\n            pq.add(n);\\n        }\\n        int leftover=money;\\n        while(!pq.isEmpty()){\\n             if (pq.size() < 2) {\\n                break;\\n            }\\n            int a = pq.poll();\\n            int b = pq.poll();\\n            \\n            if((a+b)<=money){\\n                leftover = money-(a+b);\\n                break;\\n            }\\n            \\n        }\\n        \\n        return leftover;\\n    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n    \\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for(int n : prices){\\n            pq.add(n);\\n        }\\n        int leftover=money;\\n        while(!pq.isEmpty()){\\n             if (pq.size() < 2) {\\n                break;\\n            }\\n            int a = pq.poll();\\n            int b = pq.poll();\\n            \\n            if((a+b)<=money){\\n                leftover = money-(a+b);\\n                break;\\n            }\\n            \\n        }\\n        \\n        return leftover;\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568691,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        sort(prices.begin(),prices.end());\\n        int a=prices[0]+prices[1];\\n        if(a<=money)    return money-a;\\n        return money;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        sort(prices.begin(),prices.end());\\n        int a=prices[0]+prices[1];\\n        if(a<=money)    return money-a;\\n        return money;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568653,
                "title": "easy-to-understand-beginers-freindly-c",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\nIn summary, this code sorts the prices in non-decreasing order, calculates the sum of the two lowest prices, and checks if there is enough money to buy those chocolates. If there is enough money, it returns the leftover amount; otherwise, it returns the initial amount of money.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& v, int m) {\\n        sort(v.begin(),v.end());\\n        int s = v[0] + v[1];\\n        if(m - s < 0) return m;\\n        else return m - s;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& v, int m) {\\n        sort(v.begin(),v.end());\\n        int s = v[0] + v[1];\\n        if(m - s < 0) return m;\\n        else return m - s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4102824,
                "title": "ez",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n10\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n3 72\\n# Code\\n```\\nfunc buyChoco(prices []int, money int) int {\\n   sort.Ints(prices)\\n       if money>=prices[0]+prices[1] {\\n            money-=prices[0]+prices[1]\\n  }\\n  \\n  return money\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc buyChoco(prices []int, money int) int {\\n   sort.Ints(prices)\\n       if money>=prices[0]+prices[1] {\\n            money-=prices[0]+prices[1]\\n  }\\n  \\n  return money\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4100939,
                "title": "simple-and-easy-to-understand-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        if(prices.length==0 || prices.length==1) {\\n            return money;\\n        }\\n        Arrays.sort(prices);\\n        int cost = prices[0]+prices[1];\\n        if(cost>money) {\\n            return money;\\n        } \\n        return money - cost;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        if(prices.length==0 || prices.length==1) {\\n            return money;\\n        }\\n        Arrays.sort(prices);\\n        int cost = prices[0]+prices[1];\\n        if(cost>money) {\\n            return money;\\n        } \\n        return money - cost;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4099727,
                "title": "beat-90-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\na<b the two choco you want to buy.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money){\\n        int a=200,b=200;\\n        for(auto i:prices){\\n            b=min(b,i);\\n            if(b<a) swap(a,b);\\n        }\\n        return ((a+b)>money)? money:money-(a+b);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money){\\n        int a=200,b=200;\\n        for(auto i:prices){\\n            b=min(b,i);\\n            if(b<a) swap(a,b);\\n        }\\n        return ((a+b)>money)? money:money-(a+b);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4096955,
                "title": "beginner-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint buyChoco(int* prices, int pricesSize, int money)\\n{\\n\\tint i;\\n\\tint a;\\n\\tint c;\\n\\tint fakemoney[9999];\\n\\tint lastmoney;\\n\\n\\n\\tc = 0;\\n\\tlastmoney = money;\\n\\tfor (i = 0;i < pricesSize; i++)\\n\\t{\\n\\t\\t\\n\\t\\tfor (a = 0; a < pricesSize; a++)\\n\\t\\t{\\n\\t\\t\\t\\n\\t\\t\\tif ((money - (prices[i] + prices[a])) >= 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (a != i)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfakemoney[c] = money - (prices[i] + prices[a]);\\n\\t\\t\\t\\t\\tlastmoney = 0;\\n\\t\\t\\t\\t\\tc++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfakemoney[c] = \\'\\\\0\\';\\n\\tfor (a = 0; a < c; a++)\\n\\t{\\n\\t\\tif (lastmoney < fakemoney[a + 1])\\n\\t\\t\\tlastmoney = fakemoney[a+1];\\n\\t}\\n\\treturn (lastmoney);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint buyChoco(int* prices, int pricesSize, int money)\\n{\\n\\tint i;\\n\\tint a;\\n\\tint c;\\n\\tint fakemoney[9999];\\n\\tint lastmoney;\\n\\n\\n\\tc = 0;\\n\\tlastmoney = money;\\n\\tfor (i = 0;i < pricesSize; i++)\\n\\t{\\n\\t\\t\\n\\t\\tfor (a = 0; a < pricesSize; a++)\\n\\t\\t{\\n\\t\\t\\t\\n\\t\\t\\tif ((money - (prices[i] + prices[a])) >= 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (a != i)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tfakemoney[c] = money - (prices[i] + prices[a]);\\n\\t\\t\\t\\t\\tlastmoney = 0;\\n\\t\\t\\t\\t\\tc++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfakemoney[c] = \\'\\\\0\\';\\n\\tfor (a = 0; a < c; a++)\\n\\t{\\n\\t\\tif (lastmoney < fakemoney[a + 1])\\n\\t\\t\\tlastmoney = fakemoney[a+1];\\n\\t}\\n\\treturn (lastmoney);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4086985,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} prices\\n * @param {number} money\\n * @return {number}\\n */\\nvar buyChoco = function(prices, money) {\\n    prices = prices.sort((a,b)=> a - b);\\n    let bal = money - (prices[0] + prices[1]);\\n    return bal >=0 ? bal : money  \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} prices\\n * @param {number} money\\n * @return {number}\\n */\\nvar buyChoco = function(prices, money) {\\n    prices = prices.sort((a,b)=> a - b);\\n    let bal = money - (prices[0] + prices[1]);\\n    return bal >=0 ? bal : money  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4086349,
                "title": "easy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def buyChoco(self, prices: List[int], money: int) -> int:\\n        prices = sorted(prices)\\n        best = prices[0]+prices[1]\\n        if best > money:\\n            return money\\n        return money - best\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def buyChoco(self, prices: List[int], money: int) -> int:\\n        prices = sorted(prices)\\n        best = prices[0]+prices[1]\\n        if best > money:\\n            return money\\n        return money - best\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4084675,
                "title": "scala-o-n-log-n",
                "content": "# Complexity\\n- Time complexity:\\n $$O(n*log(n))$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nobject Solution {\\n    def buyChoco(prices: Array[Int], money: Int): Int = {\\n      val price = prices.sorted.take(2).reduceLeft(_ + _)\\n\\n      if( price <= money) money - price\\n      else money\\n        \\n\\n    }\\n\\n\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def buyChoco(prices: Array[Int], money: Int): Int = {\\n      val price = prices.sorted.take(2).reduceLeft(_ + _)\\n\\n      if( price <= money) money - price\\n      else money\\n        \\n\\n    }\\n\\n\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4081224,
                "title": "beginner-friendly-beats-97",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def buyChoco(self, prices: List[int], money: int) -> int:\\n        prices.sort()\\n        \\n        if prices[0]+prices[1]<=money:\\n            return money-(prices[0]+prices[1])\\n        return money            \\n    \\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def buyChoco(self, prices: List[int], money: int) -> int:\\n        prices.sort()\\n        \\n        if prices[0]+prices[1]<=money:\\n            return money-(prices[0]+prices[1])\\n        return money            \\n    \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4075002,
                "title": "elegant-java-sorting-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        \\n        Arrays.sort(prices);\\n        int sum = prices[0]+prices[1];\\n        return money-sum>=0?money-sum:money;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        \\n        Arrays.sort(prices);\\n        int sum = prices[0]+prices[1];\\n        return money-sum>=0?money-sum:money;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074816,
                "title": "java-easy-sorting-2-lines-of-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        Arrays.sort(prices);\\n        if((money - prices[0] - prices[1]) < 0) return money;\\n        return money - prices[0] - prices[1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        Arrays.sort(prices);\\n        if((money - prices[0] - prices[1]) < 0) return money;\\n        return money - prices[0] - prices[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072016,
                "title": "brute-force-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar buyChoco = function(prices, money) {\\n    prices=prices.sort((a,b)=>a-b);\\n    for(let i=0;i<prices.length;i++){\\n        for(let j=i+1;j<prices.length;j++){\\n            const temp=prices[i]+prices[j];\\n            if(temp<=money)\\n            return money-temp;\\n        }\\n    }\\n    return money;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar buyChoco = function(prices, money) {\\n    prices=prices.sort((a,b)=>a-b);\\n    for(let i=0;i<prices.length;i++){\\n        for(let j=i+1;j<prices.length;j++){\\n            const temp=prices[i]+prices[j];\\n            if(temp<=money)\\n            return money-temp;\\n        }\\n    }\\n    return money;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4071645,
                "title": "top-1-by-07chrono-c-o-ms-beats-1oo-the-best-answer-click-to-see-now",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        int tmp;\\n        sort(prices.begin(), prices.end());\\n        tmp = prices[0] + prices[1];\\n        if(tmp <= money)\\n            money -= tmp;\\n        return money;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        int tmp;\\n        sort(prices.begin(), prices.end());\\n        tmp = prices[0] + prices[1];\\n        if(tmp <= money)\\n            money -= tmp;\\n        return money;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4067178,
                "title": "two-chocolates",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        int min=Integer.MAX_VALUE;\\n        int index=0;\\n        for(int i=0;i<prices.length;i++){\\n             if(min>prices[i]){\\n                 index=i;\\n                 min=prices[i];\\n             }\\n        }\\n        int min2=Integer.MAX_VALUE;\\n        for(int i=0;i<prices.length;i++){\\n            if(i!=index&&min2>=min&&min2>prices[i]){\\n                min2=prices[i];\\n            }\\n        }\\n        if(money>=min+min2)\\n        return money-(min+min2);\\n    return money;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        int min=Integer.MAX_VALUE;\\n        int index=0;\\n        for(int i=0;i<prices.length;i++){\\n             if(min>prices[i]){\\n                 index=i;\\n                 min=prices[i];\\n             }\\n        }\\n        int min2=Integer.MAX_VALUE;\\n        for(int i=0;i<prices.length;i++){\\n            if(i!=index&&min2>=min&&min2>prices[i]){\\n                min2=prices[i];\\n            }\\n        }\\n        if(money>=min+min2)\\n        return money-(min+min2);\\n    return money;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4062182,
                "title": "too-easy-to-be-solved",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def buyChoco(self, prices: List[int], money: int) -> int:\\n        prices.sort()\\n        if money>=(prices[0]+prices[1]):\\n            return (money-(prices[0]+prices[1]))\\n        else:\\n            return money\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def buyChoco(self, prices: List[int], money: int) -> int:\\n        prices.sort()\\n        if money>=(prices[0]+prices[1]):\\n            return (money-(prices[0]+prices[1]))\\n        else:\\n            return money\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056292,
                "title": "c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        sort(prices.begin(),prices.end());\\n        int sum=prices[0]+prices[1];\\n        if(money>=sum)\\n        return money-sum;\\n        return money;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        sort(prices.begin(),prices.end());\\n        int sum=prices[0]+prices[1];\\n        if(money>=sum)\\n        return money-sum;\\n        return money;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4052858,
                "title": "sort-array",
                "content": "# Code\\n```\\nclass Solution {\\n    \\n    // TC: O(nlogn)\\n    // SC: O(1)\\n    public int buyChoco(int[] prices, int money) {\\n        Arrays.sort(prices);\\n        return (money-prices[0]-prices[1]>=0) ? (money-prices[0]-prices[1]) : money;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    \\n    // TC: O(nlogn)\\n    // SC: O(1)\\n    public int buyChoco(int[] prices, int money) {\\n        Arrays.sort(prices);\\n        return (money-prices[0]-prices[1]>=0) ? (money-prices[0]-prices[1]) : money;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4052751,
                "title": "python-with-sort",
                "content": "# Complexity\\n- Time complexity:\\n**O(n * log(n))**\\n\\n- Space complexity:\\n**O(1)**\\n\\n# Code\\n```\\nclass Solution:\\n    def buyChoco(self, prices: List[int], money: int) -> int:\\n        prices.sort()\\n        if prices[0] + prices[1] <= money:\\n            return(money - (prices[0] + prices[1]))\\n        else:\\n            return(money)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def buyChoco(self, prices: List[int], money: int) -> int:\\n        prices.sort()\\n        if prices[0] + prices[1] <= money:\\n            return(money - (prices[0] + prices[1]))\\n        else:\\n            return(money)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4050032,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def buyChoco(self, prices: List[int], money: int) -> int:\\n        prices.sort()\\n        if prices[0]+prices[1]<=money: return money-(prices[0]+prices[1])\\n        return money\\n```\\n***Hope it helps...!!*** \\uD83D\\uDE07\\u270C\\uFE0F",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def buyChoco(self, prices: List[int], money: int) -> int:\\n        prices.sort()\\n        if prices[0]+prices[1]<=money: return money-(prices[0]+prices[1])\\n        return money\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044471,
                "title": "javascript-solution-3line",
                "content": "\\n# Code\\n```\\nvar buyChoco = function(prices, money) {\\n    prices.sort((a,b)=>a-b)\\n    let res = money-(prices[0] + prices[1])\\n    return res >=0 ? res : money \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar buyChoco = function(prices, money) {\\n    prices.sort((a,b)=>a-b)\\n    let res = money-(prices[0] + prices[1])\\n    return res >=0 ? res : money \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4042117,
                "title": "simple-c-solution-time-complexity-o-n-log-n-2-lines-of-code",
                "content": "\\n# Complexity\\n- Time complexity: O(n log(n))\\n```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        sort(prices.begin(),prices.end());\\n        return ((money-(prices[0]+prices[1]))>=0) ? (money-(prices[0]+prices[1])):money;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        sort(prices.begin(),prices.end());\\n        return ((money-(prices[0]+prices[1]))>=0) ? (money-(prices[0]+prices[1])):money;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038872,
                "title": "java-simple-code-sort-sum-index-0-index-1",
                "content": "# Intuition\\nsort Array and sum index 0 and index 1 value\\nthen compare sum with money\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    Runtime\\n    2 ms\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        int sum=0;\\n        Arrays.sort(prices);\\n        for(int i=0;i<2;i++){\\n            sum=sum+prices[i];\\n        }\\n        if(sum<=money)\\n        return money-sum;\\n        else return money;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        int sum=0;\\n        Arrays.sort(prices);\\n        for(int i=0;i<2;i++){\\n            sum=sum+prices[i];\\n        }\\n        if(sum<=money)\\n        return money-sum;\\n        else return money;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038344,
                "title": "2706-buy-two-chocolates",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def buyChoco(self, prices: List[int], money: int) -> int:\\n        prices.sort()\\n        cheap=(prices[0]+prices[1])\\n        if money>=cheap:\\n            return money-cheap\\n        else:\\n            return money\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def buyChoco(self, prices: List[int], money: int) -> int:\\n        prices.sort()\\n        cheap=(prices[0]+prices[1])\\n        if money>=cheap:\\n            return money-cheap\\n        else:\\n            return money\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037228,
                "title": "js-solution-beats-80",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nQuite simple, just sort the array (to minimise the total spend) then calculate what you\\'ve spent once we get two candies\\n\\n# Code\\n```\\n/**\\n * @param {number[]} prices\\n * @param {number} money\\n * @return {number}\\n */\\nvar buyChoco = function(prices, money) {\\n    prices = prices.sort((a,b) => a-b)\\n    let bought = 0\\n    let spent = 0\\n    for(let i = 0; i < prices.length; i++){\\n        spent += prices[i]\\n        bought++\\n        if(bought === 2){\\n            if(spent > money)\\n                return money\\n            else\\n                return money - spent\\n        }\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * @param {number[]} prices\\n * @param {number} money\\n * @return {number}\\n */\\nvar buyChoco = function(prices, money) {\\n    prices = prices.sort((a,b) => a-b)\\n    let bought = 0\\n    let spent = 0\\n    for(let i = 0; i < prices.length; i++){\\n        spent += prices[i]\\n        bought++\\n        if(bought === 2){\\n            if(spent > money)\\n                return money\\n            else\\n                return money - spent\\n        }\\n    }\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4030388,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n log n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        Arrays.sort(prices);\\n        if(prices[0] + prices[1] <= money){\\n            return money - (prices[0] + prices[1]);\\n        }\\n        return money;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        Arrays.sort(prices);\\n        if(prices[0] + prices[1] <= money){\\n            return money - (prices[0] + prices[1]);\\n        }\\n        return money;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4029900,
                "title": "easy-and-understandable-solution-for-beginners",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    func buyChoco(_ prices: [Int], _ money: Int) -> Int {\\n        let sortedPrices = prices.sorted()\\n        let sumOfFirstTwoPrices = sortedPrices[0]+sortedPrices[1]\\n        if sumOfFirstTwoPrices > money {\\n            return money\\n        } else {\\n            return money - sumOfFirstTwoPrices\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func buyChoco(_ prices: [Int], _ money: Int) -> Int {\\n        let sortedPrices = prices.sorted()\\n        let sumOfFirstTwoPrices = sortedPrices[0]+sortedPrices[1]\\n        if sumOfFirstTwoPrices > money {\\n            return money\\n        } else {\\n            return money - sumOfFirstTwoPrices\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4029339,
                "title": "runtime-beats-100-memory-beats-75-two-pointer-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        int left = 0;\\n        int right = prices.length - 1;\\n        int spent = Integer.MAX_VALUE;\\n\\n        while (left < right) {\\n            if (prices[left] + prices[right] <= money) {\\n                spent = Math.min(spent, prices[left] + prices[right]);\\n            }\\n\\n            if (prices[left] < prices[right]) {\\n                right--;\\n            } else {\\n                left++;\\n            }\\n        }\\n\\n        if (spent == Integer.MAX_VALUE) {\\n            return money;\\n        }\\n        return money - spent;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        int left = 0;\\n        int right = prices.length - 1;\\n        int spent = Integer.MAX_VALUE;\\n\\n        while (left < right) {\\n            if (prices[left] + prices[right] <= money) {\\n                spent = Math.min(spent, prices[left] + prices[right]);\\n            }\\n\\n            if (prices[left] < prices[right]) {\\n                right--;\\n            } else {\\n                left++;\\n            }\\n        }\\n\\n        if (spent == Integer.MAX_VALUE) {\\n            return money;\\n        }\\n        return money - spent;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4025333,
                "title": "simple-solution-using-while-loop-and-2-pointers-o-n-solution-beginner-friendly",
                "content": "# Intuition\\n>\\n\\n# Approach\\n<>\\n> sorting first two element using pointer method and while loop \\n# Complexity\\n- Time complexity:\\n<O(n)>\\n\\n- Space complexity:\\n<O(1)>\\n\\n# Code\\n```\\nclass Solution:\\n    def buyChoco(self, prices: List[int], money: int) -> int:\\n        i = 1\\n        j = 0\\n        k = 2\\n        while k < len(prices):\\n            if prices[j] > prices[k]:\\n                if prices[i]>prices[j]:\\n                    prices[j],prices[i],prices[k]=prices[k],prices[j],prices[i]\\n                else:\\n                    prices[j],prices[k] = prices[k],prices[j]    \\n            elif prices[i]>prices[k]:\\n                prices[i],prices[k]=prices[k],prices[i]\\n            k+=1\\n        return g if (g := money-(prices[i]+prices[j])) >= 0 else money\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def buyChoco(self, prices: List[int], money: int) -> int:\\n        i = 1\\n        j = 0\\n        k = 2\\n        while k < len(prices):\\n            if prices[j] > prices[k]:\\n                if prices[i]>prices[j]:\\n                    prices[j],prices[i],prices[k]=prices[k],prices[j],prices[i]\\n                else:\\n                    prices[j],prices[k] = prices[k],prices[j]    \\n            elif prices[i]>prices[k]:\\n                prices[i],prices[k]=prices[k],prices[i]\\n            k+=1\\n        return g if (g := money-(prices[i]+prices[j])) >= 0 else money\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022625,
                "title": "simple-beginner-s-friendly",
                "content": "# Intuition\\n*Find the sum of two choclates  and then find the difference with the money*\\n\\n# Approach\\n*Sort the list then find the sum price of first two chocolate if it is less or equal to money return the left money if greater return money*\\n\\n# Complexity\\n- Time complexity:$$O(1)$$ \\n\\n- Space complexity:\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        sort(prices.begin(),prices.end()); //sort the elements\\n        int sum=0;\\n            sum=prices[0]+prices[1]; //checking sum of first and second chocolate\\n         if(sum<=money)\\n            return money-sum;  //finding difference\\n        return money;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        sort(prices.begin(),prices.end()); //sort the elements\\n        int sum=0;\\n            sum=prices[0]+prices[1]; //checking sum of first and second chocolate\\n         if(sum<=money)\\n            return money-sum;  //finding difference\\n        return money;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022624,
                "title": "simple-beginner-s-friendly",
                "content": "# Intuition\\n*Find the sum of two choclates  and then find the difference with the money*\\n\\n# Approach\\n*Sort the list then find the sum price of first two chocolate if it is less or equal to money return the left money if greater return money*\\n\\n# Complexity\\n- Time complexity:$$O(1)$$ \\n\\n- Space complexity:\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        sort(prices.begin(),prices.end()); //sort the elements\\n        int sum=0;\\n            sum=prices[0]+prices[1]; //checking sum of first and second chocolate\\n         if(sum<=money)\\n            return money-sum;  //finding difference\\n        return money;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        sort(prices.begin(),prices.end()); //sort the elements\\n        int sum=0;\\n            sum=prices[0]+prices[1]; //checking sum of first and second chocolate\\n         if(sum<=money)\\n            return money-sum;  //finding difference\\n        return money;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4021894,
                "title": "simple-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        Arrays.sort(prices);\\n\\n        int sum=prices[0]+prices[1];\\n        if(sum<=money){\\n            return money-sum;\\n        }\\n        return money;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        Arrays.sort(prices);\\n\\n        int sum=prices[0]+prices[1];\\n        if(sum<=money){\\n            return money-sum;\\n        }\\n        return money;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4008481,
                "title": "short-solution-o-n-c-good-code-zesos",
                "content": "# Intuition\\nRAM RAM bhaiyo\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        sort(prices.begin(),prices.end());\\n        int sum = prices[1] + prices[0];\\n        if(sum > money) return money;\\n        return money - sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        sort(prices.begin(),prices.end());\\n        int sum = prices[1] + prices[0];\\n        if(sum > money) return money;\\n        return money - sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4004320,
                "title": "best-and-easiest-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        int ans = money;\\n        sort(prices.begin(),prices.end());\\n        int sum = prices[0];\\n        for(int i=1;i<prices.size();i++){\\n            sum+=prices[i];\\n            if(sum<=money){\\n                ans = money - sum;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        int ans = money;\\n        sort(prices.begin(),prices.end());\\n        int sum = prices[0];\\n        for(int i=1;i<prices.size();i++){\\n            sum+=prices[i];\\n            if(sum<=money){\\n                ans = money - sum;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4002547,
                "title": "2-line-code-very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n         sort(prices.begin(), prices.end());\\n   \\n    return (( money -(prices[0] + prices[1])) >= 0) ? ( money -(prices[0] + prices[1])) : money;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n         sort(prices.begin(), prices.end());\\n   \\n    return (( money -(prices[0] + prices[1])) >= 0) ? ( money -(prices[0] + prices[1])) : money;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001399,
                "title": "java-with-priorityqueue",
                "content": "```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        \\n        for(int price:prices) {\\n            pq.add(price);\\n        }\\n        \\n        int a = pq.poll();\\n        int b = pq.poll();\\n        \\n        if(money-a-b >= 0) {\\n            return money - a - b;\\n        }\\n        return money;   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        \\n        for(int price:prices) {\\n            pq.add(price);\\n        }\\n        \\n        int a = pq.poll();\\n        int b = pq.poll();\\n        \\n        if(money-a-b >= 0) {\\n            return money - a - b;\\n        }\\n        return money;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998118,
                "title": "2706-buy-two-chocolates",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<O(n logn)-->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        int sum;\\n        int x;\\n        sort(prices.begin(),prices.end());\\n        \\n            sum = prices[0]+prices[1];\\n            x = abs(money-sum);\\n            if(x==0){\\n                return 0;\\n\\n            }\\n            else if(money>sum){\\n                return x;\\n            }\\n            else{\\n                return money;\\n            }\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        int sum;\\n        int x;\\n        sort(prices.begin(),prices.end());\\n        \\n            sum = prices[0]+prices[1];\\n            x = abs(money-sum);\\n            if(x==0){\\n                return 0;\\n\\n            }\\n            else if(money>sum){\\n                return x;\\n            }\\n            else{\\n                return money;\\n            }\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3995865,
                "title": "o-n-simple-to-understand-solution",
                "content": "# Intuition\\nGet the two minimum elements in the array and if there sum is more than money.\\n# Approach\\nGet the two minimum elements in the array and if there sum is more than money. If the sum is less or equal to money then return the difference or return the money. \\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        int min=INT_MAX;\\n        int secMin=INT_MAX;\\n        int idx=0;\\n\\n        while(idx < prices.size())\\n        {\\n            if (min > prices[idx])\\n            {\\n                secMin = min;                \\n                min = prices[idx]; \\n            } \\n            else if ( secMin > prices[idx])\\n            {\\n                secMin = prices[idx];\\n            }\\n\\n            idx++;\\n        }\\n\\n        int diff = min + secMin;\\n        if (diff > money)\\n            return money;\\n\\n        return money-diff; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        int min=INT_MAX;\\n        int secMin=INT_MAX;\\n        int idx=0;\\n\\n        while(idx < prices.size())\\n        {\\n            if (min > prices[idx])\\n            {\\n                secMin = min;                \\n                min = prices[idx]; \\n            } \\n            else if ( secMin > prices[idx])\\n            {\\n                secMin = prices[idx];\\n            }\\n\\n            idx++;\\n        }\\n\\n        int diff = min + secMin;\\n        if (diff > money)\\n            return money;\\n\\n        return money-diff; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3986303,
                "title": "simple-for-loop-beats-100-runtime-and-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        int smallest = prices[0];\\n        int smaller = prices[1];\\n\\n        if(smaller < smallest){\\n            smallest = prices[1];\\n            smaller = prices[0];\\n        }\\n\\n        for(int i = 2; i < prices.length; i++){\\n            if(prices[i] < smaller){\\n                if(prices[i] < smallest){\\n                    smaller = smallest;\\n                    smallest = prices[i];\\n                }\\n                else{\\n                    smaller = prices[i];\\n                }\\n            }\\n        }\\n\\n        int after = money - (smaller + smallest);\\n        if(after < 0){\\n            return money;\\n        }\\n        else{\\n            return after;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        int smallest = prices[0];\\n        int smaller = prices[1];\\n\\n        if(smaller < smallest){\\n            smallest = prices[1];\\n            smaller = prices[0];\\n        }\\n\\n        for(int i = 2; i < prices.length; i++){\\n            if(prices[i] < smaller){\\n                if(prices[i] < smallest){\\n                    smaller = smallest;\\n                    smallest = prices[i];\\n                }\\n                else{\\n                    smaller = prices[i];\\n                }\\n            }\\n        }\\n\\n        int after = money - (smaller + smallest);\\n        if(after < 0){\\n            return money;\\n        }\\n        else{\\n            return after;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985768,
                "title": "nasted-for-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n. $$O(n^2)$$ \\n\\n- Space complexity:\\n $$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        int currentMinimum = -1;\\n        // for each element\\n        for(int i = 0; i < prices.length; i++) {\\n            // check all the others\\n            for(int j = i + 1; j < prices.length; j++) {\\n                if((money - (prices[i] + prices[j]) >= 0) && (money - (prices[i] + prices[j]) > currentMinimum)) {\\n                    System.out.println((money - (prices[i] + prices[j]) + \" ; \" + currentMinimum));\\n                    currentMinimum = (money - (prices[i] + prices[j]));\\n                }\\n            }\\n        }\\n        if(currentMinimum == -1) return money;\\n        return currentMinimum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        int currentMinimum = -1;\\n        // for each element\\n        for(int i = 0; i < prices.length; i++) {\\n            // check all the others\\n            for(int j = i + 1; j < prices.length; j++) {\\n                if((money - (prices[i] + prices[j]) >= 0) && (money - (prices[i] + prices[j]) > currentMinimum)) {\\n                    System.out.println((money - (prices[i] + prices[j]) + \" ; \" + currentMinimum));\\n                    currentMinimum = (money - (prices[i] + prices[j]));\\n                }\\n            }\\n        }\\n        if(currentMinimum == -1) return money;\\n        return currentMinimum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984937,
                "title": "beginner-friendly-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n       \\n       int initial=money;\\n       //Algorithm for buying two chcocolates\\n       Arrays.sort(prices);\\n       for(int i=0;i<2;i++){\\n           money=money-prices[i];\\n\\n       }\\n       if(money<0)\\n       return initial;\\n       else\\n       return money;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n       \\n       int initial=money;\\n       //Algorithm for buying two chcocolates\\n       Arrays.sort(prices);\\n       for(int i=0;i<2;i++){\\n           money=money-prices[i];\\n\\n       }\\n       if(money<0)\\n       return initial;\\n       else\\n       return money;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3983411,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public int buyChoco(int[] prices, int money) \\n    {\\n        Arrays.sort(prices);\\n        int s = prices[0] + prices[1];\\n        if(money-s>=0)\\n        return money-s;\\n        else\\n        return money;   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int buyChoco(int[] prices, int money) \\n    {\\n        Arrays.sort(prices);\\n        int s = prices[0] + prices[1];\\n        if(money-s>=0)\\n        return money-s;\\n        else\\n        return money;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977693,
                "title": "mastering-problem-a-short-and-elegant-approach-first-second-minimum-o-n",
                "content": "# Intuition\\nTo minimize the sum of prices of the two chocolates and have some non-negative leftover money, we can follow a simple approach. We can sort the prices array in ascending order and then iterate through it to find the pair of chocolates with the minimum sum of prices that we can afford.\\n\\n# Approach\\nSort the prices array in ascending order.\\n\\nInitialize two variables, left and right, both set to 0. These variables will represent the indices of the chocolates we are going to buy.\\n\\nUse a while loop to find a pair of chocolates with the minimum sum of prices that we can afford. The loop continues as long as left is less than right and the sum of prices at left and right is greater than money.\\n\\nIf the sum of prices at left and right is less than or equal to money, we can buy these chocolates. Return money - (prices[left] + prices[right]) as the leftover money.\\n\\nIf the loop completes without finding a valid pair of chocolates, return money as we can\\'t buy two chocolates without going into debt.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def buyChoco(self, prices: List[int], money: int) -> int:\\n        first_min = second_min = maxsize\\n\\n        for p in prices:\\n            if p < first_min:\\n                second_min, first_min = first_min, p\\n            elif p < second_min:\\n                second_min = p\\n\\n        min_price = first_min + second_min\\n        return money - min_price if min_price <= money else money\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def buyChoco(self, prices: List[int], money: int) -> int:\\n        first_min = second_min = maxsize\\n\\n        for p in prices:\\n            if p < first_min:\\n                second_min, first_min = first_min, p\\n            elif p < second_min:\\n                second_min = p\\n\\n        min_price = first_min + second_min\\n        return money - min_price if min_price <= money else money\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3972925,
                "title": "o-n-beats-100",
                "content": "![Screenshot 2023-08-28 at 11.09.28 PM.png](https://assets.leetcode.com/users/images/ccc01d91-ca70-4e40-90d7-b2c1279765ea_1693244488.8229656.png)\\n\\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& p, int m) {\\n        int a=INT_MAX;\\n        int b=INT_MAX;\\n        for(int i=0;i<p.size();i++){\\n            if(p[i]<a){\\n                b=a;\\n                a=p[i];\\n            }\\n            else if(p[i]<b) b=p[i];\\n        }\\n        \\n        if(a+b>m) return m;\\n        return m-a-b;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& p, int m) {\\n        int a=INT_MAX;\\n        int b=INT_MAX;\\n        for(int i=0;i<p.size();i++){\\n            if(p[i]<a){\\n                b=a;\\n                a=p[i];\\n            }\\n            else if(p[i]<b) b=p[i];\\n        }\\n        \\n        if(a+b>m) return m;\\n        return m-a-b;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3965826,
                "title": "easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        int left=Integer.MIN_VALUE;\\n        for(int i=0;i<prices.length;i++)\\n        {\\n            for(int j=0;j<prices.length;j++)\\n            {\\n\\n            if(i!=j && prices[i]+prices[j] <=money)\\n            {\\n                left=Math.max(left,(money-(prices[i]+prices[j])));\\n            }\\n\\n            }\\n        }\\n        if(left==-2147483648)\\n        {\\n            return money;\\n        }\\n        return left;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        int left=Integer.MIN_VALUE;\\n        for(int i=0;i<prices.length;i++)\\n        {\\n            for(int j=0;j<prices.length;j++)\\n            {\\n\\n            if(i!=j && prices[i]+prices[j] <=money)\\n            {\\n                left=Math.max(left,(money-(prices[i]+prices[j])));\\n            }\\n\\n            }\\n        }\\n        if(left==-2147483648)\\n        {\\n            return money;\\n        }\\n        return left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3962528,
                "title": "python-sort-boolean",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def buyChoco(self, prices, money):\\n        \"\"\"\\n        :type prices: List[int]\\n        :type money: int\\n        :rtype: int\\n        \"\"\"\\n        p = sorted(prices)\\n        return [money - (p[0] + p[1]), money][money < p[0] + p[1]]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def buyChoco(self, prices, money):\\n        \"\"\"\\n        :type prices: List[int]\\n        :type money: int\\n        :rtype: int\\n        \"\"\"\\n        p = sorted(prices)\\n        return [money - (p[0] + p[1]), money][money < p[0] + p[1]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3959848,
                "title": "o-n-short-sol-with-explanation",
                "content": "\\tclass Solution {\\n\\t\\tpublic int buyChoco(int[] prices, int money) {\\n\\t\\t\\tint min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE;\\n\\n\\t\\t   for(int i = 0; i < prices.length; i++) {\\n\\t\\t\\t\\tif (prices[i] <= min1) { // if its smallest then update both, min2 with prevoius min1 and min1 with new smallest\\n\\t\\t\\t\\t\\tmin2 = min1;\\n\\t\\t\\t\\t\\tmin1 = prices[i];\\n\\t\\t\\t\\t} else if (prices[i] < min2) {  // else update min2 only\\n\\t\\t\\t\\t\\tmin2 = prices[i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t// condition of the question and answer\\n\\t\\t\\tif(min1 + min2 > money) return money;\\n\\t\\t\\treturn money - (min1 + min2);\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "class Solution {\\n\\t\\tpublic int buyChoco(int[] prices, int money) {\\n\\t\\t\\tint min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE;\\n\\n\\t\\t   for(int i = 0; i < prices.length; i++) {\\n\\t\\t\\t\\tif (prices[i] <= min1) { // if its smallest then update both, min2 with prevoius min1 and min1 with new smallest\\n\\t\\t\\t\\t\\tmin2 = min1;\\n\\t\\t\\t\\t\\tmin1 = prices[i];\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3959805,
                "title": "sort-and-substract",
                "content": "\\tclass Solution {\\n\\t\\tpublic int buyChoco(int[] prices, int money) {\\n\\t\\t\\tArrays.sort(prices);\\n\\t\\t\\tif(prices[0] + prices[1] > money) return money;\\n\\n\\t\\t\\treturn (money - (prices[0] + prices[1]));\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "class Solution {\\n\\t\\tpublic int buyChoco(int[] prices, int money) {\\n\\t\\t\\tArrays.sort(prices);\\n\\t\\t\\tif(prices[0] + prices[1] > money) return money;\\n\\n\\t\\t\\treturn (money - (prices[0] + prices[1]));\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3958908,
                "title": "easy-to-understand-solution-in-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- nlog(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n      if(prices.size()<2)\\n      {\\n          return 0;\\n      }  \\n      sort(prices.begin(),prices.end());\\n      int ans=prices[0]+prices[1];\\n      if(money<ans)\\n      {\\n          return money;\\n      }\\n      return money-ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n      if(prices.size()<2)\\n      {\\n          return 0;\\n      }  \\n      sort(prices.begin(),prices.end());\\n      int ans=prices[0]+prices[1];\\n      if(money<ans)\\n      {\\n          return money;\\n      }\\n      return money-ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956259,
                "title": "easy-solution-using-java-beats-100-0ms",
                "content": "\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        int small = Integer.MAX_VALUE;\\n        int sSmall = Integer.MAX_VALUE;\\n        for(int i:prices){\\n            if(i < small){\\n                sSmall = small;\\n                small = i;\\n            }\\n            else if(i < sSmall){\\n                sSmall = i;\\n            }\\n        }\\n        int n = money - (small + sSmall);\\n        return n >= 0 ? n : money; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        int small = Integer.MAX_VALUE;\\n        int sSmall = Integer.MAX_VALUE;\\n        for(int i:prices){\\n            if(i < small){\\n                sSmall = small;\\n                small = i;\\n            }\\n            else if(i < sSmall){\\n                sSmall = i;\\n            }\\n        }\\n        int n = money - (small + sSmall);\\n        return n >= 0 ? n : money; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954826,
                "title": "easy-fully-c-implementation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        sort(prices.begin(),prices.end());\\n        int sum = prices[0] + prices[1];\\n        if(sum > money){\\n            return money;\\n        }\\n        return money-sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        sort(prices.begin(),prices.end());\\n        int sum = prices[0] + prices[1];\\n        if(sum > money){\\n            return money;\\n        }\\n        return money-sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954273,
                "title": "very-easy-c-code",
                "content": "\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        int count=0;\\n        int money1=money;\\n        sort(prices.begin(),prices.end());\\n        for(int i=0;i<prices.size();i++){\\n            if(count==2){\\n                break;\\n            }\\n            if(prices[i]<=money){\\n                count++;\\n                money=money-prices[i];\\n            }\\n        }\\n        if(count==2 && money>=0){\\n            return money;\\n        }\\n        return money1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        int count=0;\\n        int money1=money;\\n        sort(prices.begin(),prices.end());\\n        for(int i=0;i<prices.size();i++){\\n            if(count==2){\\n                break;\\n            }\\n            if(prices[i]<=money){\\n                count++;\\n                money=money-prices[i];\\n            }\\n        }\\n        if(count==2 && money>=0){\\n            return money;\\n        }\\n        return money1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3950948,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        Arrays.sort(prices);\\n        int val = prices[0] + prices[1];\\n        if(val <= money)\\n            return money - val;\\n        return money;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        Arrays.sort(prices);\\n        int val = prices[0] + prices[1];\\n        if(val <= money)\\n            return money - val;\\n        return money;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3949033,
                "title": "python-2-pointers-o-n-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def buyChoco(self, prices: List[int], money: int) -> int:\\n        first, second = prices[0], prices[1]\\n        for i in range(2, len(prices)):\\n            if first > prices[i]: \\n                if second > first: \\n                    first, second = prices[i], first\\n                else:\\n                    first = prices[i]\\n            elif second > prices[i]: second = prices[i]\\n        return g if (g := money-(first+second)) >= 0 else money \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def buyChoco(self, prices: List[int], money: int) -> int:\\n        first, second = prices[0], prices[1]\\n        for i in range(2, len(prices)):\\n            if first > prices[i]: \\n                if second > first: \\n                    first, second = prices[i], first\\n                else:\\n                    first = prices[i]\\n            elif second > prices[i]: second = prices[i]\\n        return g if (g := money-(first+second)) >= 0 else money \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948619,
                "title": "python3-layman-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def buyChoco(self, prices: List[int], money: int) -> int:\\n        prices.sort()\\n        sum1= sum(prices[:2])\\n        ans= money- sum1\\n        if ans>=0:\\n            return ans\\n        return money\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def buyChoco(self, prices: List[int], money: int) -> int:\\n        prices.sort()\\n        sum1= sum(prices[:2])\\n        ans= money- sum1\\n        if ans>=0:\\n            return ans\\n        return money\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938043,
                "title": "beats-easy-beginner-friendly-solution-simple-and-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int buyChoco(int[] p, int m) {\\n        Arrays.sort(p);\\n        if(p[0]+p[1]<=m){\\n            return m-p[0]-p[1];\\n        }\\n        return m;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int buyChoco(int[] p, int m) {\\n        Arrays.sort(p);\\n        if(p[0]+p[1]<=m){\\n            return m-p[0]-p[1];\\n        }\\n        return m;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3937787,
                "title": "buy-two-chocolates-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        int max=Integer.MIN_VALUE;\\n        for(int i=0;i<prices.length;i++)\\n        {\\n            for(int j=i+1;j<prices.length;j++)\\n            {\\n                if(prices[i]+prices[j]<=money && (money-(prices[i]+prices[j]))>max )\\n                max=money-(prices[i]+prices[j]);\\n            }\\n        }\\n            if(max==Integer.MIN_VALUE)\\n            return money;\\n            else \\n            return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        int max=Integer.MIN_VALUE;\\n        for(int i=0;i<prices.length;i++)\\n        {\\n            for(int j=i+1;j<prices.length;j++)\\n            {\\n                if(prices[i]+prices[j]<=money && (money-(prices[i]+prices[j]))>max )\\n                max=money-(prices[i]+prices[j]);\\n            }\\n        }\\n            if(max==Integer.MIN_VALUE)\\n            return money;\\n            else \\n            return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3935561,
                "title": "2ms-beats-93-75-of-users-with-java-two-line-code",
                "content": "# Intuition\\nThe code is trying to help you buy two chocolates while spending as little money as possible without going into debt. It does this by sorting the prices of chocolates and then checking if you have enough money to buy the two cheapest chocolates.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1- First, it sorts the prices of chocolates in ascending order, so the cheapest chocolates are at the beginning of the array.\\n\\n2- Then, it checks if the sum of the prices of the two cheapest chocolates (prices[0] and prices[1]) is less than or equal to your initial money.\\n\\n3- If you have enough money to buy these two chocolates, it subtracts the cost of these chocolates from your initial money and returns the remaining money.\\n\\n4- If you don\\'t have enough money to buy these two chocolates without going into debt, it simply returns your initial money.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: The time complexity is very simple here. Sorting the prices takes O(n log n) time, where \\'n\\' is the number of chocolates. Checking the sum of the two cheapest chocolates takes constant time. So, the overall time complexity is \"O(n log n)\" because sorting dominates the time complexity.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:The code uses very little extra space. It sorts the \\'prices\\' array in place, so it doesn\\'t require much extra memory. Therefore, the space complexity is \"O(1)\".\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n    Arrays.sort(prices);\\n      return prices[0] + prices[1] <= money ? money - (prices[0] + prices[1]) : money;  \\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n    Arrays.sort(prices);\\n      return prices[0] + prices[1] <= money ? money - (prices[0] + prices[1]) : money;  \\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928696,
                "title": "easy-solution-100-fast-memo-find-2-cheapest-candy-in-1-for-loop",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        int min1=Integer.MAX_VALUE;\\n        int min2=Integer.MAX_VALUE;\\n        for(int i=0;i<prices.length;i++){\\n            if(prices[i]<min1){\\n                min2=min1;\\n                min1=prices[i];\\n            }\\n            else if(prices[i]<min2){\\n                min2=prices[i];\\n            }\\n        }\\n        if(min1+min2 > money){\\n            return money;\\n        }\\n        return money-min1-min2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        int min1=Integer.MAX_VALUE;\\n        int min2=Integer.MAX_VALUE;\\n        for(int i=0;i<prices.length;i++){\\n            if(prices[i]<min1){\\n                min2=min1;\\n                min1=prices[i];\\n            }\\n            else if(prices[i]<min2){\\n                min2=prices[i];\\n            }\\n        }\\n        if(min1+min2 > money){\\n            return money;\\n        }\\n        return money-min1-min2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928589,
                "title": "buy-two-chocolates",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        Arrays.sort(prices);\\n        int sum = prices[0] + prices[1];\\n        if(sum > money)return money;\\n        else if(sum == money ) return 0;\\n\\n\\nint left =0;\\n        if(money >= sum){\\nleft = money - sum ;\\n       \\n        } else{\\n            left = sum - money;\\n        }\\n        return left;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        Arrays.sort(prices);\\n        int sum = prices[0] + prices[1];\\n        if(sum > money)return money;\\n        else if(sum == money ) return 0;\\n\\n\\nint left =0;\\n        if(money >= sum){\\nleft = money - sum ;\\n       \\n        } else{\\n            left = sum - money;\\n        }\\n        return left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3927970,
                "title": "two-lines-c-add-index-0-and-1-only",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFind the smallest two element and add them.\\nIf the sum is less then money then return (money - sum)\\nelse return money\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n       sort(prices.begin(),prices.end());\\n\\n       if(prices[0]+prices[1]<=money){\\n           return money-(prices[0]+prices[1]);\\n       }\\n      \\n           return money;\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n       sort(prices.begin(),prices.end());\\n\\n       if(prices[0]+prices[1]<=money){\\n           return money-(prices[0]+prices[1]);\\n       }\\n      \\n           return money;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3927915,
                "title": "solve-easily-using-python",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAt first we should sort the array. Thus we get the minimum cost chocolates at the 0th and 1st element.Now if the total cost of the the 1st two element is lower or equal to money then return the money left aftwer buying the chocolates otherwise return the value of money. \\n\\n# Code\\n```\\nclass Solution:\\n    def buyChoco(self, prices: List[int], money: int) -> int:\\n        prices.sort()\\n        ans=money-sum(prices[:2])\\n        if ans>=0:\\n            return ans\\n        return money    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def buyChoco(self, prices: List[int], money: int) -> int:\\n        prices.sort()\\n        ans=money-sum(prices[:2])\\n        if ans>=0:\\n            return ans\\n        return money    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917513,
                "title": "easy-intuitive-solution-with-explanation-in-java",
                "content": "# Code\\n```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        Arrays.sort(prices);\\n        int budget = money - prices[0] - prices[1];\\n        if(budget>=0) return budget;\\n        else return money;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        Arrays.sort(prices);\\n        int budget = money - prices[0] - prices[1];\\n        if(budget>=0) return budget;\\n        else return money;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911266,
                "title": "easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        Arrays.sort(prices);\\n        int temp = money,count=0;\\n        for(int i=0; i<prices.length; i++)\\n        {\\n            if(count != 2)\\n            {\\n                if(money >= prices[i])\\n                {\\n                     money = money - prices[i];\\n                     count++;\\n                }\\n            }\\n        }\\n        if(count == 2)\\n        {\\n            return money;\\n        }else\\n        {\\n            return temp;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        Arrays.sort(prices);\\n        int temp = money,count=0;\\n        for(int i=0; i<prices.length; i++)\\n        {\\n            if(count != 2)\\n            {\\n                if(money >= prices[i])\\n                {\\n                     money = money - prices[i];\\n                     count++;\\n                }\\n            }\\n        }\\n        if(count == 2)\\n        {\\n            return money;\\n        }else\\n        {\\n            return temp;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3909603,
                "title": "solving-with-js-methods",
                "content": "\\n# Approach\\nUsing Math method (Math.min).\\nHere Iam using spread operator inside Math.min(),so I can get smallest element from the array.Then Iam finding its index and removing that element using splice() method.Then again iam finding the smallest element with Math.min() and spread operator ,like how I did earlier.Then I am taking the sum of smallest and second smallest element. If the sum is greater than money ,then I return money.Otherwise I return the value which sum is substracted from money.\\n\\n\\n# Code\\n```\\nfunction buyChoco(prices: number[], money: number): number {\\n    let min:number = Math.min(...prices)\\n    prices.splice(prices.indexOf(min),1)\\n    let sMin:number = Math.min(...prices)\\n    if((min + sMin) > money ) return money\\n    return money - (min + sMin)\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction buyChoco(prices: number[], money: number): number {\\n    let min:number = Math.min(...prices)\\n    prices.splice(prices.indexOf(min),1)\\n    let sMin:number = Math.min(...prices)\\n    if((min + sMin) > money ) return money\\n    return money - (min + sMin)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3907425,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} prices\\n * @param {number} money\\n * @return {number}\\n */\\nvar buyChoco = function(prices, money) {\\n    let sortPrices = prices.sort((a,b) => a-b)\\n    let remainMoney = money - (sortPrices[0]+sortPrices[1])\\n    return remainMoney >= 0 ? remainMoney : money\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} prices\\n * @param {number} money\\n * @return {number}\\n */\\nvar buyChoco = function(prices, money) {\\n    let sortPrices = prices.sort((a,b) => a-b)\\n    let remainMoney = money - (sortPrices[0]+sortPrices[1])\\n    return remainMoney >= 0 ? remainMoney : money\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3907412,
                "title": "dart-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int buyChoco(List<int> prices, int money) {\\n      List<int> result = [];\\n      for(int i=0; i<prices.length; i++){\\n          for(int j=0; j<prices.length; j++){\\n              if(i!=j){\\n                  if(prices[i]+prices[j] <= money){\\n                    result.add(prices[i]+prices[j]);\\n                }\\n              }\\n          }\\n      }\\n      print(result);\\n          if(result.isEmpty){\\n              return money;\\n          }else{\\n              result.sort();\\n          }\\n      return money-result.first;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int buyChoco(List<int> prices, int money) {\\n      List<int> result = [];\\n      for(int i=0; i<prices.length; i++){\\n          for(int j=0; j<prices.length; j++){\\n              if(i!=j){\\n                  if(prices[i]+prices[j] <= money){\\n                    result.add(prices[i]+prices[j]);\\n                }\\n              }\\n          }\\n      }\\n      print(result);\\n          if(result.isEmpty){\\n              return money;\\n          }else{\\n              result.sort();\\n          }\\n      return money-result.first;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3907105,
                "title": "go-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc buyChoco(prices []int, money int) int {\\n    for i:=0;i<len(prices)-1;i++{\\n        for j:=i+1;j<len(prices);j++{\\n            if prices[j]<prices[i]{\\n                prices[i],prices[j]=prices[j],prices[i]\\n            }\\n        }\\n    }\\n\\n\\n    if prices[0]+prices[1] <= money{\\n        return money - (prices[0]+prices[1])\\n    } else{\\n        return money\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc buyChoco(prices []int, money int) int {\\n    for i:=0;i<len(prices)-1;i++{\\n        for j:=i+1;j<len(prices);j++{\\n            if prices[j]<prices[i]{\\n                prices[i],prices[j]=prices[j],prices[i]\\n            }\\n        }\\n    }\\n\\n\\n    if prices[0]+prices[1] <= money{\\n        return money - (prices[0]+prices[1])\\n    } else{\\n        return money\\n    }\\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3907013,
                "title": "simple-javascript-code-o-n-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} prices\\n * @param {number} money\\n * @return {number}\\n */\\nvar buyChoco = function(prices, money) {\\n let length=prices.length\\n    for (let i=0;i<length-1;i++){\\n    let min=i\\n    for(let j=i+1;j<length;j++){\\n        if(prices[j]<prices[min]){\\n             min=j\\n        }\\n    }\\n    [prices[i],prices[min]]=[prices[min],prices[i]]\\n}\\nif(prices[0]+prices[1]<=money){\\n    return (money-(prices[0]+prices[1]))\\n}else{\\n    return (money) \\n}\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} prices\\n * @param {number} money\\n * @return {number}\\n */\\nvar buyChoco = function(prices, money) {\\n let length=prices.length\\n    for (let i=0;i<length-1;i++){\\n    let min=i\\n    for(let j=i+1;j<length;j++){\\n        if(prices[j]<prices[min]){\\n             min=j\\n        }\\n    }\\n    [prices[i],prices[min]]=[prices[min],prices[i]]\\n}\\nif(prices[0]+prices[1]<=money){\\n    return (money-(prices[0]+prices[1]))\\n}else{\\n    return (money) \\n}\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3906963,
                "title": "easy-to-understand-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int buyChoco(List<int> prices, int money) {\\n    prices.sort();\\n    if(prices[0]+prices[1] <= money){\\n      return money-prices[0]-prices[1];\\n    }else{\\n      return money;\\n    }\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int buyChoco(List<int> prices, int money) {\\n    prices.sort();\\n    if(prices[0]+prices[1] <= money){\\n      return money-prices[0]-prices[1];\\n    }else{\\n      return money;\\n    }\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3906962,
                "title": "runtime-1-ms-beats-100-java-users-memory-43-2-mb",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        if (prices == null || prices.length < 2) {\\n            return money;\\n        }\\n\\n        int min1 = Integer.MAX_VALUE;\\n        int min2 = Integer.MAX_VALUE;\\n\\n        for (int price : prices) {\\n            if (price <= min1) {\\n                min2 = min1;\\n                min1 = price;\\n            } else if (price < min2) {\\n                min2 = price;\\n            }\\n        }\\n\\n        int totalCost = min1 + min2;\\n\\n        if (money >= totalCost) {\\n            return money - totalCost;\\n        } else {\\n            return money;\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        if (prices == null || prices.length < 2) {\\n            return money;\\n        }\\n\\n        int min1 = Integer.MAX_VALUE;\\n        int min2 = Integer.MAX_VALUE;\\n\\n        for (int price : prices) {\\n            if (price <= min1) {\\n                min2 = min1;\\n                min1 = price;\\n            } else if (price < min2) {\\n                min2 = price;\\n            }\\n        }\\n\\n        int totalCost = min1 + min2;\\n\\n        if (money >= totalCost) {\\n            return money - totalCost;\\n        } else {\\n            return money;\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3906956,
                "title": "in-java-script-with-very-simple-logic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} prices\\n * @param {number} money\\n * @return {number}\\n */\\nvar buyChoco = function(prices, money) {\\n   prices.sort((a, b) => a - b)\\n   let sum =prices[0]+prices[1]\\n    if(sum<=money){\\n        \\n         return money-sum\\n    }\\n    return money\\n    \\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} prices\\n * @param {number} money\\n * @return {number}\\n */\\nvar buyChoco = function(prices, money) {\\n   prices.sort((a, b) => a - b)\\n   let sum =prices[0]+prices[1]\\n    if(sum<=money){\\n        \\n         return money-sum\\n    }\\n    return money\\n    \\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3906888,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int buyChoco(List<int> prices, int money) {\\n      int balance=money;\\n      int n=0;\\n      List<int> listpr=prices;\\n      listpr.sort();\\nfor(int i=0;i<listpr.length;i++){\\n    if(listpr[i]<=balance){\\n    balance=balance-listpr[i];\\n    n++;\\n    print(balance);\\n    if(n==2){\\n        break;\\n    }\\n    }}\\n    if(n!=2){\\n        balance=money;\\n    }\\nreturn balance;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int buyChoco(List<int> prices, int money) {\\n      int balance=money;\\n      int n=0;\\n      List<int> listpr=prices;\\n      listpr.sort();\\nfor(int i=0;i<listpr.length;i++){\\n    if(listpr[i]<=balance){\\n    balance=balance-listpr[i];\\n    n++;\\n    print(balance);\\n    if(n==2){\\n        break;\\n    }\\n    }}\\n    if(n!=2){\\n        balance=money;\\n    }\\nreturn balance;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3906875,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} prices\\n * @param {number} money\\n * @return {number}\\n */\\nvar buyChoco = function(prices, money) {\\n     let cho = prices.sort((a,b)=>a-b)\\n     let sum = cho[0] + cho[1]\\n     if(money - sum >= 0){\\n          return money - sum\\n     }\\n     return money\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} prices\\n * @param {number} money\\n * @return {number}\\n */\\nvar buyChoco = function(prices, money) {\\n     let cho = prices.sort((a,b)=>a-b)\\n     let sum = cho[0] + cho[1]\\n     if(money - sum >= 0){\\n          return money - sum\\n     }\\n     return money\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3906793,
                "title": "python-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def buyChoco(self, prices, money):\\n        if len(prices)>=2:\\n            choco = sorted(prices)\\n            buy=choco[0]+choco[1]\\n            if buy <= money :\\n                return (money-buy)\\n            else:\\n                return money\\n        else:\\n            return money\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def buyChoco(self, prices, money):\\n        if len(prices)>=2:\\n            choco = sorted(prices)\\n            buy=choco[0]+choco[1]\\n            if buy <= money :\\n                return (money-buy)\\n            else:\\n                return money\\n        else:\\n            return money\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3906789,
                "title": "go-easy",
                "content": "\\n\\n# Code\\n```\\nfunc buyChoco(prices []int, money int) int {\\n    count:=0\\n\\tsort.Ints(prices)\\n    temp:=money\\n    for i:=0;i<len(prices);i++{\\n        if prices[i]<=temp && count < 2 {\\n            temp-=prices[i]\\n            fmt.Println(prices[i])\\n            count++\\n        }\\n    }\\n    if count==2{\\n        return temp\\n    }\\n    return money\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc buyChoco(prices []int, money int) int {\\n    count:=0\\n\\tsort.Ints(prices)\\n    temp:=money\\n    for i:=0;i<len(prices);i++{\\n        if prices[i]<=temp && count < 2 {\\n            temp-=prices[i]\\n            fmt.Println(prices[i])\\n            count++\\n        }\\n    }\\n    if count==2{\\n        return temp\\n    }\\n    return money\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3905699,
                "title": "beats-97-easy-java-solution-simple-explanation-tc-o-n-log-n",
                "content": "# Intuition\\nThe intuition behind this code is to sort the array of chocolate prices in ascending order. This allows us to consider the lowest-priced chocolates first, making it easier to optimize our purchase while staying within the given budget.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe code starts by sorting the array of chocolate prices using Arrays.sort(arr).\\nIt then checks whether the sum of the prices of the two cheapest chocolates (arr[0] and arr[1]) is less than or equal to the available money.\\nIf the sum of the two cheapest chocolates is within budget, it means we can buy these two chocolates, leaving us with some remaining money. The remaining money is calculated as the difference between the total money and the sum of the two cheapest chocolates.\\nIf the sum of the two cheapest chocolates exceeds the budget, we can\\'t buy any chocolates, so we return the original money amount.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity :\\n- time complexity: O(n log n)\\n- The time complexity is dominated by the sorting operation, which takes O(n log n) time complexity due to using a sorting algorithm. The subsequent comparisons and calculations take constant time, so the overall time complexity remains O(n log n).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n- The sorting operation usually takes O(n) additional space for temporary storage, but since this space is not directly proportional to the input size in the same way as other data structures, the space complexity is considered as O(1).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int buyChoco(int[] arr, int money) {\\n      Arrays.sort(arr);\\n      if(arr[0]+arr[1]<=money) return (money-(arr[0]+arr[1]));\\n      else\\n         return money;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int buyChoco(int[] arr, int money) {\\n      Arrays.sort(arr);\\n      if(arr[0]+arr[1]<=money) return (money-(arr[0]+arr[1]));\\n      else\\n         return money;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3904946,
                "title": "simple-dart-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    int buyChoco(List<int> prices, int money) {\\n\\n prices.sort();\\n\\n int amount= money-( prices[0]+prices[1]);\\n\\n\\n return amount<0 ? money : amount;\\n       \\n}\\n}\\n\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n    int buyChoco(List<int> prices, int money) {\\n\\n prices.sort();\\n\\n int amount= money-( prices[0]+prices[1]);\\n\\n\\n return amount<0 ? money : amount;\\n       \\n}\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902822,
                "title": "easy-c-solution",
                "content": "# Approach\\nAfter sorting `prices` array `prices[0]` and `prices[i]` will be the chocolates whose total sum is least in the  prices array\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        sort(prices.begin(), prices.end());\\n        if(prices[0]+prices[1] > money)\\n            return money;\\n        return money - (prices[0]+prices[1]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        sort(prices.begin(), prices.end());\\n        if(prices[0]+prices[1] > money)\\n            return money;\\n        return money - (prices[0]+prices[1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3901207,
                "title": "java-o-n-time-o-1-space-short-no-sorting",
                "content": "# Code\\n```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        int min1 = 101;\\n        int min2 = 101;\\n        for (int p : prices) {\\n            min2 = Math.min(min2, Math.max(min1, p));\\n            min1 = Math.min(min1, p);\\n        }\\n\\n        int res = money - min1 - min2;\\n        return (res < 0) ? money : res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        int min1 = 101;\\n        int min2 = 101;\\n        for (int p : prices) {\\n            min2 = Math.min(min2, Math.max(min1, p));\\n            min1 = Math.min(min1, p);\\n        }\\n\\n        int res = money - min1 - min2;\\n        return (res < 0) ? money : res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3898238,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        Arrays.sort(prices);\\n        int amount = money - (prices[0] + prices[1]);\\n        return amount < 0 ? money : amount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        Arrays.sort(prices);\\n        int amount = money - (prices[0] + prices[1]);\\n        return amount < 0 ? money : amount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3898168,
                "title": "one-loop-c",
                "content": "# Time complexity:\\n$$O(n log n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int buyChoco(vector<int> &prices, int money)\\n  {\\n    int i;\\n    int sum;\\n\\n    sort(prices.begin(), prices.end());\\n\\n    for (i = 0; i < prices.size() - 1; i++)\\n    {\\n      sum = prices[i] + prices[i + 1];\\n      if (sum <= money && sum > 0)\\n        return (money - sum);\\n    }\\n\\n    return (money);\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int buyChoco(vector<int> &prices, int money)\\n  {\\n    int i;\\n    int sum;\\n\\n    sort(prices.begin(), prices.end());\\n\\n    for (i = 0; i < prices.size() - 1; i++)\\n    {\\n      sum = prices[i] + prices[i + 1];\\n      if (sum <= money && sum > 0)\\n        return (money - sum);\\n    }\\n\\n    return (money);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894942,
                "title": "o-n-no-need-to-sort-simplified-heap-approach-ms-beats-100-of-rust",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nYou need to find the sum of the min two prices. Obviously you can use a sort algorithm and just take the first two, but then thought you didn\\'t need to sort the whole array, you just need something like a two element heap, which here could just be an array that you keep shifting.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nKeep track of cheapest two, starting at max value.\\niterate through each price, then if less than the cheapest (index 0) shift the last cheapest along one. else if cheaper than the second cheapest just replace that.\\n\\n# Complexity\\n- Time complexity: 0(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn buy_choco(prices: Vec<i32>, money: i32) -> i32 {\\n        let mut cheapest_two: [i32; 2] = [100, 100];\\n        for &price in &prices {\\n            if price < cheapest_two[0] {\\n                cheapest_two[1] = cheapest_two[0];\\n                cheapest_two[0] = price;\\n            }\\n            else if price < cheapest_two[1] {\\n                cheapest_two[1] = price;\\n            }\\n        }\\n        let total = cheapest_two[0] + cheapest_two[1];\\n        if  total > money {\\n            return money;\\n        }\\n        return money - total;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn buy_choco(prices: Vec<i32>, money: i32) -> i32 {\\n        let mut cheapest_two: [i32; 2] = [100, 100];\\n        for &price in &prices {\\n            if price < cheapest_two[0] {\\n                cheapest_two[1] = cheapest_two[0];\\n                cheapest_two[0] = price;\\n            }\\n            else if price < cheapest_two[1] {\\n                cheapest_two[1] = price;\\n            }\\n        }\\n        let total = cheapest_two[0] + cheapest_two[1];\\n        if  total > money {\\n            return money;\\n        }\\n        return money - total;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3886656,
                "title": "simple-solution-o-n-go-100-beats",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nfunc buyChoco(prices []int, money int) int {\\n\\tfirst, second := math.MaxInt, math.MaxInt\\n\\n    for _, price := range prices {\\n        if price < first {\\n            if first < second {\\n                second = first\\n            }\\n\\n            first = price\\n        }else if price < second{\\n            second = price\\n        }\\n    }\\n    \\n    if first + second <= money {\\n        return money - first - second\\n    }\\n\\n    return money\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc buyChoco(prices []int, money int) int {\\n\\tfirst, second := math.MaxInt, math.MaxInt\\n\\n    for _, price := range prices {\\n        if price < first {\\n            if first < second {\\n                second = first\\n            }\\n\\n            first = price\\n        }else if price < second{\\n            second = price\\n        }\\n    }\\n    \\n    if first + second <= money {\\n        return money - first - second\\n    }\\n\\n    return money\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3883536,
                "title": "python3-2-lines-of-code-using-heapq-nsmallest",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse [heapq.nsmallest](https://docs.python.org/3/library/heapq.html#heapq.nsmallest) to find the two lowest prices and add them up. This is the minimum amount we can spend on buying two chocolates. \\n\\nIf we have at least that much money, buy the chocolates and return what\\'s left. Otherwise, return the original amount.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom heapq import nsmallest\\n\\nclass Solution:\\n    def buyChoco(self, prices: List[int], money: int) -> int:\\n        # Find the two cheapest chocolates and add them up\\n        cheapest2 = sum(nsmallest(2, prices))\\n        # Return remainder if we have enough money\\n        # Otherwise, return the original sum\\n        return money - cheapest2 * (money >= cheapest2)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom heapq import nsmallest\\n\\nclass Solution:\\n    def buyChoco(self, prices: List[int], money: int) -> int:\\n        # Find the two cheapest chocolates and add them up\\n        cheapest2 = sum(nsmallest(2, prices))\\n        # Return remainder if we have enough money\\n        # Otherwise, return the original sum\\n        return money - cheapest2 * (money >= cheapest2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3881269,
                "title": "using-insertion-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n    insertionsort(prices);\\n        int c=prices[0]+prices[1];\\n        if(c<=money)\\n        {\\n            return money-c;\\n        }\\n        return money;\\n    }\\n    public int[] insertionsort(int[] a)\\n    {\\n        int v;\\n        int j;\\n       for(int i=1; i<=a.length-1; i++)\\n       {\\n           v=a[i];\\n            j=i;\\n           while(j>=1&&a[j-1] > v)\\n           {\\n               a[j]=a[j-1];\\n               j--;\\n           }\\n           a[j]=v;\\n       }\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n    insertionsort(prices);\\n        int c=prices[0]+prices[1];\\n        if(c<=money)\\n        {\\n            return money-c;\\n        }\\n        return money;\\n    }\\n    public int[] insertionsort(int[] a)\\n    {\\n        int v;\\n        int j;\\n       for(int i=1; i<=a.length-1; i++)\\n       {\\n           v=a[i];\\n            j=i;\\n           while(j>=1&&a[j-1] > v)\\n           {\\n               a[j]=a[j-1];\\n               j--;\\n           }\\n           a[j]=v;\\n       }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3880396,
                "title": "c-easy-solution-buy-two-chocolates",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        sort(prices.begin(), prices.end());\\n        int sum=money-(prices[0]+prices[1]);\\n       for(int i=0; i<prices.size(); i++){\\n           if(sum>=0){\\n               return sum;\\n           }\\n           \\n       }\\n       return money;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        sort(prices.begin(), prices.end());\\n        int sum=money-(prices[0]+prices[1]);\\n       for(int i=0; i<prices.size(); i++){\\n           if(sum>=0){\\n               return sum;\\n           }\\n           \\n       }\\n       return money;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3875090,
                "title": "simple-one-line-solution-using-sorting-java-python-c-js-c-same-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to find minimum sum of two values in the price and not greater than the money value.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst we sort the array using inbuilt function.\\nIf sum of first two values is less than or equal, solution will be money - sum of first two values in prices \\n# Complexity\\n- Time complexity: Based on Inbuilt Sort Funtion( Incase of Java O(nlogn))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: Based on Inbuilt Sort Funtion( Incase of Java O(1))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        Arrays.sort(prices);\\n        int n = prices[0]+prices[1];\\n        if(n>money)\\n        return money;\\n        else\\n        return money-n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        Arrays.sort(prices);\\n        int n = prices[0]+prices[1];\\n        if(n>money)\\n        return money;\\n        else\\n        return money-n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3871901,
                "title": "buy-two-chocolates",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        Arrays.sort(prices);\\n        int sum = money;\\n        for(int i=0;i<2;i++)\\n        {\\n            sum = sum-prices[i];\\n        }\\n        if(sum>=0)\\n        return sum;\\n        else \\n        return money;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        Arrays.sort(prices);\\n        int sum = money;\\n        for(int i=0;i<2;i++)\\n        {\\n            sum = sum-prices[i];\\n        }\\n        if(sum>=0)\\n        return sum;\\n        else \\n        return money;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3869826,
                "title": "c-solution",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int buyChoco(vector<int>& prices, int money) \\n    {\\n        int origin = money;\\n\\n        std::sort(prices.begin(), prices.end());\\n        money -= prices[0];\\n        money -= prices[1];\\n\\n        return (money >= 0) ? money : origin;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int buyChoco(vector<int>& prices, int money) \\n    {\\n        int origin = money;\\n\\n        std::sort(prices.begin(), prices.end());\\n        money -= prices[0];\\n        money -= prices[1];\\n\\n        return (money >= 0) ? money : origin;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3867690,
                "title": "if-else-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        sort(prices.begin(),prices.end());\\n        for(int i=0;i<prices.size()-1;i++)\\n        {\\n            if((prices[i]+prices[i+1])<=money)return money-(prices[i]+prices[i+1]); \\n        }\\n        return money;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        sort(prices.begin(),prices.end());\\n        for(int i=0;i<prices.size()-1;i++)\\n        {\\n            if((prices[i]+prices[i+1])<=money)return money-(prices[i]+prices[i+1]); \\n        }\\n        return money;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865773,
                "title": "simplepythoncode3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def buyChoco(self, prices: List[int], money: int) -> int:\\n        prices.sort()\\n        for i in range(len(prices)):\\n            x=prices[i:2+i]\\n            if len(x)==2:\\n                if sum(x)<=money:\\n                    z=money-sum(x)\\n                    return z\\n                else:\\n                    return money\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def buyChoco(self, prices: List[int], money: int) -> int:\\n        prices.sort()\\n        for i in range(len(prices)):\\n            x=prices[i:2+i]\\n            if len(x)==2:\\n                if sum(x)<=money:\\n                    z=money-sum(x)\\n                    return z\\n                else:\\n                    return money\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865238,
                "title": "easy-java-solution-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        Arrays.sort(prices);\\n        for(int i=0;i<prices.length;i++){\\n            if(prices[i]+prices[i+1]<=money) return money-(prices[i]+prices[i+1]);\\n            else return money;\\n        }\\n        return money;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        Arrays.sort(prices);\\n        for(int i=0;i<prices.length;i++){\\n            if(prices[i]+prices[i+1]<=money) return money-(prices[i]+prices[i+1]);\\n            else return money;\\n        }\\n        return money;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865022,
                "title": "simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        Arrays.sort(prices);\\n        if(prices[0]+prices[1]==money){\\n            return 0;\\n        }\\n        if(prices[0]+prices[1]>money){\\n            return money;\\n        }\\n        return money-prices[0]-prices[1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        Arrays.sort(prices);\\n        if(prices[0]+prices[1]==money){\\n            return 0;\\n        }\\n        if(prices[0]+prices[1]>money){\\n            return money;\\n        }\\n        return money-prices[0]-prices[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3863358,
                "title": "java-1ms-beats-100",
                "content": "# Intuition & Approach\\n- first used a `PriorityQueue` to find least prices (3ms beats 63%)\\n- then used two ints with some `if/then/else` (1ms beats 100%)\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\n// PriorityQueue: 3ms Beats 63.14%\\n// two ints: 1ms beats 100%\\n\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n\\n        int price0 = 100;\\n        int price1 = 100;\\n        for (int p : prices) {\\n            if (p <= price0) {\\n                price1 = price0;\\n                price0 = p;\\n            } else if (p < price1) {\\n                price1 = p;\\n            }\\n        }\\n\\n        int moneyLeft = money - price0 - price1;\\n        if (moneyLeft < 0) {\\n            return money;\\n        } else {\\n            return moneyLeft;\\n        }\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// PriorityQueue: 3ms Beats 63.14%\\n// two ints: 1ms beats 100%\\n\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n\\n        int price0 = 100;\\n        int price1 = 100;\\n        for (int p : prices) {\\n            if (p <= price0) {\\n                price1 = price0;\\n                price0 = p;\\n            } else if (p < price1) {\\n                price1 = p;\\n            }\\n        }\\n\\n        int moneyLeft = money - price0 - price1;\\n        if (moneyLeft < 0) {\\n            return money;\\n        } else {\\n            return moneyLeft;\\n        }\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862510,
                "title": "easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        int min=0;\\n        Arrays.sort(prices);\\n        if(prices[0]+prices[1]<=money){\\n            return money-(prices[0]+prices[1]);\\n        }\\n        return money;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        int min=0;\\n        Arrays.sort(prices);\\n        if(prices[0]+prices[1]<=money){\\n            return money-(prices[0]+prices[1]);\\n        }\\n        return money;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862076,
                "title": "java-fastest-solution",
                "content": "# Complexity\\n- Time complexity: *O(n)*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: *O(n)*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        int min = Integer.MAX_VALUE, min2 = min;\\n        int n = prices.length;\\n        \\n        for(int i = 0; i < n; i++){\\n            if(min >= prices[i]){\\n                min2 = min;\\n                min = prices[i];\\n            } else if(min2 >= prices[i]){\\n                min2 = prices[i];\\n            }\\n        }\\n\\n        if(min + min2 > money) return money;\\n        return money - min - min2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        int min = Integer.MAX_VALUE, min2 = min;\\n        int n = prices.length;\\n        \\n        for(int i = 0; i < n; i++){\\n            if(min >= prices[i]){\\n                min2 = min;\\n                min = prices[i];\\n            } else if(min2 >= prices[i]){\\n                min2 = prices[i];\\n            }\\n        }\\n\\n        if(min + min2 > money) return money;\\n        return money - min - min2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861861,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func buyChoco(_ prices: [Int], _ money: Int) -> Int {\\n        let prices = prices.sorted()\\n        let left = money - prices[0] - prices[1]\\n        return left >= 0 ? left : money\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func buyChoco(_ prices: [Int], _ money: Int) -> Int {\\n        let prices = prices.sorted()\\n        let left = money - prices[0] - prices[1]\\n        return left >= 0 ? left : money\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860310,
                "title": "eas",
                "content": "\\n```\\nclass Solution:\\n    def buyChoco(self, prices: List[int], money: int) -> int:\\n        prices.sort()\\n        cost = 0\\n        try:\\n            cost = prices[0] + prices[1]\\n        except:\\n            None\\n        if cost > money:\\n            return money\\n        else:\\n            return money-cost\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def buyChoco(self, prices: List[int], money: int) -> int:\\n        prices.sort()\\n        cost = 0\\n        try:\\n            cost = prices[0] + prices[1]\\n        except:\\n            None\\n        if cost > money:\\n            return money\\n        else:\\n            return money-cost\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860255,
                "title": "a-simple-traverse-beats-99-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def buyChoco(self, prices: List[int], money: int) -> int:\\n        import sys\\n        n1=n2=sys.maxsize\\n\\n        for i in range(len(prices)):\\n\\n            if prices[i] <n1:\\n                n2=n1\\n                n1=prices[i]\\n\\n            elif prices[i] <n2:\\n                n2=prices[i]\\n\\n        if n1+n2>money:\\n            return money\\n        \\n        return money - (n1+n2)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def buyChoco(self, prices: List[int], money: int) -> int:\\n        import sys\\n        n1=n2=sys.maxsize\\n\\n        for i in range(len(prices)):\\n\\n            if prices[i] <n1:\\n                n2=n1\\n                n1=prices[i]\\n\\n            elif prices[i] <n2:\\n                n2=prices[i]\\n\\n        if n1+n2>money:\\n            return money\\n        \\n        return money - (n1+n2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3854035,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsorting\\n# Complexity\\n- Time complexity: O(nLogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        sort(prices.begin(),prices.end());\\n\\n        int ans=prices[0]+prices[1];\\n        if(money-ans>=0)return money-ans;\\n        else return money;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        sort(prices.begin(),prices.end());\\n\\n        int ans=prices[0]+prices[1];\\n        if(money-ans>=0)return money-ans;\\n        else return money;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853280,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsort array.and then check if first and second greater or less and than appliying condition in that\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        Arrays.sort(prices);\\n        if(prices[0]+prices[1]<=money){\\n            return money-(prices[0]+prices[1]);\\n        }\\n          return money;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        Arrays.sort(prices);\\n        if(prices[0]+prices[1]<=money){\\n            return money-(prices[0]+prices[1]);\\n        }\\n          return money;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3852883,
                "title": "beat-python-99-78",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def buyChoco(self, prices: List[int], money: int) -> int:\\n        prices.sort()\\n        m = min(prices)\\n        prices.remove(m)\\n        for i in prices:\\n            if m+i <= money:\\n                return money - (m + i)\\n        return money\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def buyChoco(self, prices: List[int], money: int) -> int:\\n        prices.sort()\\n        m = min(prices)\\n        prices.remove(m)\\n        for i in prices:\\n            if m+i <= money:\\n                return money - (m + i)\\n        return money\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3848969,
                "title": "python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def buyChoco(self, prices: List[int], money: int) -> int:\\n        prices.sort()\\n        m = money\\n\\n        money -= prices[0]\\n        money -= prices[1]\\n\\n        if money >= 0:\\n            return money\\n        else:\\n            return m\\n    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def buyChoco(self, prices: List[int], money: int) -> int:\\n        prices.sort()\\n        m = money\\n\\n        money -= prices[0]\\n        money -= prices[1]\\n\\n        if money >= 0:\\n            return money\\n        else:\\n            return m\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3848795,
                "title": "easy-c-solution-using-ternary-operator",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        sort(prices.begin(), prices.end());\\n        return (prices[0] + prices[1]) > money ? money :  money-(prices[0] + prices[1]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        sort(prices.begin(), prices.end());\\n        return (prices[0] + prices[1]) > money ? money :  money-(prices[0] + prices[1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3847297,
                "title": "python-simple-python-solution-sorting",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 70 ms, faster than 87.84% of Python3 online submissions for Buy Two Chocolates.\\n# Memory Usage: 16.3 MB, less than 74.99% of Python3 online submissions for Buy Two Chocolates.\\n\\n\\tclass Solution:\\n\\t\\tdef buyChoco(self, prices: List[int], money: int) -> int:\\n\\n\\t\\t\\tprices = sorted(prices)\\n\\n\\t\\t\\tfor index in range(len(prices)-1):\\n\\n\\t\\t\\t\\ttwo_chocolates_price = prices[index] + prices[index + 1]\\n\\n\\t\\t\\t\\tif two_chocolates_price <= money:\\n\\n\\t\\t\\t\\t\\tmoney = money - two_chocolates_price\\n\\n\\t\\t\\t\\t\\treturn money\\n\\n\\t\\t\\treturn money\\n\\t\\t\\t\\n\\tTime complexity: O(nlogn)\\n\\tSpace Complexity: O(1)\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Sorting"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 70 ms, faster than 87.84% of Python3 online submissions for Buy Two Chocolates.\\n# Memory Usage: 16.3 MB, less than 74.99% of Python3 online submissions for Buy Two Chocolates.\\n\\n\\tclass Solution:\\n\\t\\tdef buyChoco(self, prices: List[int], money: int) -> int:\\n\\n\\t\\t\\tprices = sorted(prices)\\n\\n\\t\\t\\tfor index in range(len(prices)-1):\\n\\n\\t\\t\\t\\ttwo_chocolates_price = prices[index] + prices[index + 1]\\n\\n\\t\\t\\t\\tif two_chocolates_price <= money:\\n\\n\\t\\t\\t\\t\\tmoney = money - two_chocolates_price\\n\\n\\t\\t\\t\\t\\treturn money\\n\\n\\t\\t\\treturn money\\n\\t\\t\\t\\n\\tTime complexity: O(nlogn)\\n\\tSpace Complexity: O(1)\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 3844097,
                "title": "java-best-solution-beats-100-easiest-method-1-ms",
                "content": "********Bold********# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        int sum=prices[0]+prices[1];\\n        for(int i =0;i<prices.length-1;i++){\\n        for(int j=i+1;j<prices.length;j++){\\n            int x=prices[i]+prices[j];\\n            if(sum>=x){\\n                sum=x;\\n            }\\n        }\\n        }\\n        int left = money-sum;\\n        if(left>=0){\\n            return left;\\n        }\\n        return money;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int buyChoco(int[] prices, int money) {\\n        int sum=prices[0]+prices[1];\\n        for(int i =0;i<prices.length-1;i++){\\n        for(int j=i+1;j<prices.length;j++){\\n            int x=prices[i]+prices[j];\\n            if(sum>=x){\\n                sum=x;\\n            }\\n        }\\n        }\\n        int left = money-sum;\\n        if(left>=0){\\n            return left;\\n        }\\n        return money;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3844017,
                "title": "two-chocolates-two-solutions-js-o-n",
                "content": "1. Sort prices array - O (n log (n))\\n```\\n/**\\n * @param {number[]} prices\\n * @param {number} money\\n * @return {number}\\n */\\nvar buyChoco = function(prices, money) {\\n    prices.sort((a, b) => a - b)\\n\\n    a = prices[0], b = prices[1]\\n\\n    return a + b > money ? money : money - a - b\\n};\\n```\\n2. Iterate over all values in an array - O (n)\\n```\\n/**\\n * @param {number[]} prices\\n * @param {number} money\\n * @return {number}\\n */\\nvar buyChoco = function(prices, money) {\\n    a = 100\\n    b = 100\\n    \\n    for (price of prices) {\\n        if (price < a) {\\n            b = a\\n            a = price\\n        } else if (price < b) {\\n            b = price\\n        }\\n    }\\n\\n    return a + b > money ? money : money - a - b\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} prices\\n * @param {number} money\\n * @return {number}\\n */\\nvar buyChoco = function(prices, money) {\\n    prices.sort((a, b) => a - b)\\n\\n    a = prices[0], b = prices[1]\\n\\n    return a + b > money ? money : money - a - b\\n};\\n```\n```\\n/**\\n * @param {number[]} prices\\n * @param {number} money\\n * @return {number}\\n */\\nvar buyChoco = function(prices, money) {\\n    a = 100\\n    b = 100\\n    \\n    for (price of prices) {\\n        if (price < a) {\\n            b = a\\n            a = price\\n        } else if (price < b) {\\n            b = price\\n        }\\n    }\\n\\n    return a + b > money ? money : money - a - b\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3843137,
                "title": "easy-and-simple-to-understand-c-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe are given an integer array named \"prices\" representing the price of chocolates at various stores. We are also given an integer \"money\", which represents the amount of money we have with ourselves. We can buy exactly two chocolates having the least price only if the amount of money we have is greater than the sum of the price of both chocolates. If the money, we have with us is in less amount than the price of both chocolates, we need to return the value of \"money\" as it is.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\u25AA Firstly, I sorted the array in increasing order so that the first and second indexes hold the least price of chocolates.\\n\\n\\n\\u25AA After adding up the costs of both chocolates and deducting them from the value of \"money\" given, I used an if condition to determine whether the result was greater than or equal to zero. If true, then we need to return the resultant value obtained.\\n\\n\\n\\u25AA If the result obtained is less than zero, I returned \"money\" as it is in the output.\\n\\n\\n\\nThis approach worked for all the test cases and beats 99.96% of users with C++ in run time. \\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        sort(prices.begin(),prices.end());\\n        if(money-(prices[0]+prices[1])>=0)\\n        {\\n            return money-(prices[0]+prices[1]);\\n        }\\n        return money;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        sort(prices.begin(),prices.end());\\n        if(money-(prices[0]+prices[1])>=0)\\n        {\\n            return money-(prices[0]+prices[1]);\\n        }\\n        return money;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840325,
                "title": "js-solution-beats-99-6",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} prices\\n * @param {number} money\\n * @return {number}\\n */\\nvar buyChoco = function(prices, money) {\\n    let smallest = Infinity;\\n    let secondSmallest = Infinity;\\n\\n    for(let i=0;i<prices.length;i++) {\\n        if(prices[i] < smallest) {\\n            secondSmallest = smallest;\\n            smallest = prices[i];\\n        } else if (prices[i] >= smallest && prices[i] < secondSmallest)\\n            secondSmallest = prices[i];\\n    }\\n\\n    return money >= smallest + secondSmallest ? money - (smallest + secondSmallest) : money; \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} prices\\n * @param {number} money\\n * @return {number}\\n */\\nvar buyChoco = function(prices, money) {\\n    let smallest = Infinity;\\n    let secondSmallest = Infinity;\\n\\n    for(let i=0;i<prices.length;i++) {\\n        if(prices[i] < smallest) {\\n            secondSmallest = smallest;\\n            smallest = prices[i];\\n        } else if (prices[i] >= smallest && prices[i] < secondSmallest)\\n            secondSmallest = prices[i];\\n    }\\n\\n    return money >= smallest + secondSmallest ? money - (smallest + secondSmallest) : money; \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3833479,
                "title": "c-efficient-solution-99-8-faster-simple-intuition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        sort(prices.begin(),prices.end());\\n        return prices[0]+prices[1]>money?money:money-(prices[0]+prices[1]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int buyChoco(vector<int>& prices, int money) {\\n        sort(prices.begin(),prices.end());\\n        return prices[0]+prices[1]>money?money:money-(prices[0]+prices[1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1912204,
                "content": [
                    {
                        "username": "NishiTiwari5195",
                        "content": "Sort the prices using STL function.\\nCalculate the sum of the two lowest-priced chocolates.\\nCheck if the sum is less than or equal to the initial amount of money.\\nIf yes, subtract the sum from the initial amount of money and return the result as the remaining money.\\nIf not, return the initial amount of money as there is no possible way to buy 2 choco without going into debt."
                    },
                    {
                        "username": "swecpp",
                        "content": "Why acceptance rate is so low?"
                    },
                    {
                        "username": "kerku",
                        "content": "I\\'m wondering, why 50 is an expected output for TC #1939\\n`prices = [74,31,38,24,25,24,5]`\\n`money = 79`\\n`Expected 50`\\n\\nShouldn\\'t prices 74 + 5 = 79 --> - money (79) = 0 be considered as expected result?\\n\\n"
                    },
                    {
                        "username": "stanleywkman",
                        "content": "As mentioned in the description, you can just buy chocolates with lowest prices. So the price will be 5 + 24 and you will have 79 - 29 = 50 left."
                    },
                    {
                        "username": "soumyoji_saha",
                        "content": "https://leetcode.com/problems/buy-two-chocolates/submissions/992629966/"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "This is very basic problem just sort the array and then  iterate loop 0 and 1 index if the sum is equal and less then money then return money - (prices[0] + prices[1]);\\nsolution is here\\nhttps://leetcode.com/problems/buy-two-chocolates/solutions/3603238/the-simple-and-easy-to-understand-solution/"
                    }
                ]
            },
            {
                "id": 2070793,
                "content": [
                    {
                        "username": "NishiTiwari5195",
                        "content": "Sort the prices using STL function.\\nCalculate the sum of the two lowest-priced chocolates.\\nCheck if the sum is less than or equal to the initial amount of money.\\nIf yes, subtract the sum from the initial amount of money and return the result as the remaining money.\\nIf not, return the initial amount of money as there is no possible way to buy 2 choco without going into debt."
                    },
                    {
                        "username": "swecpp",
                        "content": "Why acceptance rate is so low?"
                    },
                    {
                        "username": "kerku",
                        "content": "I\\'m wondering, why 50 is an expected output for TC #1939\\n`prices = [74,31,38,24,25,24,5]`\\n`money = 79`\\n`Expected 50`\\n\\nShouldn\\'t prices 74 + 5 = 79 --> - money (79) = 0 be considered as expected result?\\n\\n"
                    },
                    {
                        "username": "stanleywkman",
                        "content": "As mentioned in the description, you can just buy chocolates with lowest prices. So the price will be 5 + 24 and you will have 79 - 29 = 50 left."
                    },
                    {
                        "username": "soumyoji_saha",
                        "content": "https://leetcode.com/problems/buy-two-chocolates/submissions/992629966/"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "This is very basic problem just sort the array and then  iterate loop 0 and 1 index if the sum is equal and less then money then return money - (prices[0] + prices[1]);\\nsolution is here\\nhttps://leetcode.com/problems/buy-two-chocolates/solutions/3603238/the-simple-and-easy-to-understand-solution/"
                    }
                ]
            },
            {
                "id": 1977245,
                "content": [
                    {
                        "username": "NishiTiwari5195",
                        "content": "Sort the prices using STL function.\\nCalculate the sum of the two lowest-priced chocolates.\\nCheck if the sum is less than or equal to the initial amount of money.\\nIf yes, subtract the sum from the initial amount of money and return the result as the remaining money.\\nIf not, return the initial amount of money as there is no possible way to buy 2 choco without going into debt."
                    },
                    {
                        "username": "swecpp",
                        "content": "Why acceptance rate is so low?"
                    },
                    {
                        "username": "kerku",
                        "content": "I\\'m wondering, why 50 is an expected output for TC #1939\\n`prices = [74,31,38,24,25,24,5]`\\n`money = 79`\\n`Expected 50`\\n\\nShouldn\\'t prices 74 + 5 = 79 --> - money (79) = 0 be considered as expected result?\\n\\n"
                    },
                    {
                        "username": "stanleywkman",
                        "content": "As mentioned in the description, you can just buy chocolates with lowest prices. So the price will be 5 + 24 and you will have 79 - 29 = 50 left."
                    },
                    {
                        "username": "soumyoji_saha",
                        "content": "https://leetcode.com/problems/buy-two-chocolates/submissions/992629966/"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "This is very basic problem just sort the array and then  iterate loop 0 and 1 index if the sum is equal and less then money then return money - (prices[0] + prices[1]);\\nsolution is here\\nhttps://leetcode.com/problems/buy-two-chocolates/solutions/3603238/the-simple-and-easy-to-understand-solution/"
                    }
                ]
            },
            {
                "id": 1966937,
                "content": [
                    {
                        "username": "NishiTiwari5195",
                        "content": "Sort the prices using STL function.\\nCalculate the sum of the two lowest-priced chocolates.\\nCheck if the sum is less than or equal to the initial amount of money.\\nIf yes, subtract the sum from the initial amount of money and return the result as the remaining money.\\nIf not, return the initial amount of money as there is no possible way to buy 2 choco without going into debt."
                    },
                    {
                        "username": "swecpp",
                        "content": "Why acceptance rate is so low?"
                    },
                    {
                        "username": "kerku",
                        "content": "I\\'m wondering, why 50 is an expected output for TC #1939\\n`prices = [74,31,38,24,25,24,5]`\\n`money = 79`\\n`Expected 50`\\n\\nShouldn\\'t prices 74 + 5 = 79 --> - money (79) = 0 be considered as expected result?\\n\\n"
                    },
                    {
                        "username": "stanleywkman",
                        "content": "As mentioned in the description, you can just buy chocolates with lowest prices. So the price will be 5 + 24 and you will have 79 - 29 = 50 left."
                    },
                    {
                        "username": "soumyoji_saha",
                        "content": "https://leetcode.com/problems/buy-two-chocolates/submissions/992629966/"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "This is very basic problem just sort the array and then  iterate loop 0 and 1 index if the sum is equal and less then money then return money - (prices[0] + prices[1]);\\nsolution is here\\nhttps://leetcode.com/problems/buy-two-chocolates/solutions/3603238/the-simple-and-easy-to-understand-solution/"
                    }
                ]
            },
            {
                "id": 1918534,
                "content": [
                    {
                        "username": "NishiTiwari5195",
                        "content": "Sort the prices using STL function.\\nCalculate the sum of the two lowest-priced chocolates.\\nCheck if the sum is less than or equal to the initial amount of money.\\nIf yes, subtract the sum from the initial amount of money and return the result as the remaining money.\\nIf not, return the initial amount of money as there is no possible way to buy 2 choco without going into debt."
                    },
                    {
                        "username": "swecpp",
                        "content": "Why acceptance rate is so low?"
                    },
                    {
                        "username": "kerku",
                        "content": "I\\'m wondering, why 50 is an expected output for TC #1939\\n`prices = [74,31,38,24,25,24,5]`\\n`money = 79`\\n`Expected 50`\\n\\nShouldn\\'t prices 74 + 5 = 79 --> - money (79) = 0 be considered as expected result?\\n\\n"
                    },
                    {
                        "username": "stanleywkman",
                        "content": "As mentioned in the description, you can just buy chocolates with lowest prices. So the price will be 5 + 24 and you will have 79 - 29 = 50 left."
                    },
                    {
                        "username": "soumyoji_saha",
                        "content": "https://leetcode.com/problems/buy-two-chocolates/submissions/992629966/"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "This is very basic problem just sort the array and then  iterate loop 0 and 1 index if the sum is equal and less then money then return money - (prices[0] + prices[1]);\\nsolution is here\\nhttps://leetcode.com/problems/buy-two-chocolates/solutions/3603238/the-simple-and-easy-to-understand-solution/"
                    }
                ]
            }
        ]
    },
    {
        "title": "Add Two Promises",
        "question_content": "Given two promises <code>promise1</code> and <code>promise2</code>, return a new promise. <code>promise1</code> and <code>promise2</code>&nbsp;will both resolve with a number. The returned promise should resolve with the sum of the two numbers.\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \npromise1 = new Promise(resolve =&gt; setTimeout(() =&gt; resolve(2), 20)), \npromise2 = new Promise(resolve =&gt; setTimeout(() =&gt; resolve(5), 60))\n<strong>Output:</strong> 7\n<strong>Explanation:</strong> The two input promises resolve with the values of 2 and 5 respectively. The returned promise should resolve with a value of 2 + 5 = 7. The time the returned promise resolves is not judged for this problem.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> \npromise1 = new Promise(resolve =&gt; setTimeout(() =&gt; resolve(10), 50)), \npromise2 = new Promise(resolve =&gt; setTimeout(() =&gt; resolve(-12), 30))\n<strong>Output:</strong> -2\n<strong>Explanation:</strong> The two input promises resolve with the values of 10 and -12 respectively. The returned promise should resolve with a value of 10 + -12 = -2.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>promise1</code> and <code>promise2</code> are&nbsp;promises that resolve&nbsp;with a number</li>\n</ul>\n",
        "solutions": [
            {
                "id": 3698863,
                "title": "easy-solution-2723-add-two-promises-level-up-your-js-skills",
                "content": "# Intuition:\\nThe goal of the task is to create a new promise that resolves with the sum of the values from two given promises.\\n# Approach:\\nUse `Promise.all()` method along with `await` to wait for both promises to resolve. Once they resolve, their values are retrieved and stored in the variables `value1` and `value2`. Finally, a new promise is returned with the sum of `value1` and `value2`.\\n# Complexity:\\n- Time complexity: \\nThe time complexity is determined by the longest running promise since the `Promise.all()` method waits for both promises to resolve concurrently. Therefore, the time complexity can be considered as O(max(promise1 time, promise2 time)).\\n\\n- Space complexity:\\n The space complexity is constant, as the code does not create any additional data structures or use additional memory that scales with the input size.\\nTherefore, the space complexity can be considered as O(1).\\n\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n\\n# Code\\n``` JS []\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n  // Wait for both promises to resolve and retrieve their values\\n  const [value1, value2] = await Promise.all([promise1, promise2]);\\n\\n  // Return a new promise that resolves with the sum of the values\\n  return value1 + value2;\\n};\\n\\n// // Example usage:\\n// var promise1 = new Promise(resolve => setTimeout(() => resolve(2), 20));\\n// var promise2 = new Promise(resolve => setTimeout(() => resolve(5), 60));\\n\\n// addTwoPromises(promise1, promise2)\\n//   .then(console.log); // Output: 7\\n```\\n\\n\\n<img src=\"https://media.giphy.com/media/Xd6WrGsyh1su7X0ZGF/giphy.gif\" width=\"40\">\\n\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D \\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n``` JS []\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n  // Wait for both promises to resolve and retrieve their values\\n  const [value1, value2] = await Promise.all([promise1, promise2]);\\n\\n  // Return a new promise that resolves with the sum of the values\\n  return value1 + value2;\\n};\\n\\n// // Example usage:\\n// var promise1 = new Promise(resolve => setTimeout(() => resolve(2), 20));\\n// var promise2 = new Promise(resolve => setTimeout(() => resolve(5), 60));\\n\\n// addTwoPromises(promise1, promise2)\\n//   .then(console.log); // Output: 7\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3657642,
                "title": "full-explanation-unlike-any-others",
                "content": "# Intuition\\nAn easy problem with a deep important concept behind , Let\\'s Break it down below : \\n- We have promise 1  and promise 2 \\n- They\\'re both inside an async function\\n- They both return some values\\n# **Goal : Return a new promise that calculates the sum of the two values returned by the two promises**\\n\\n# Pre-requistes :\\nAssuming you\\'re solving in the Javascript problem section , I assume you already have certain knwoledge of Javascript concepts . \\nWhat you need to know/ require (Aka Pre-requistes) for this Problem are the following :\\n- Familarity with ES6 methods such as **reduce method** in our case .\\n- Have an understanding of Asynchronous Proggramming in Javascript\\n- Familiar with Promise.all method in Javascript\\n- Familiar with arrow functions\\n\\n*If you already know these then Congrats you require basic knowledge required to solve this problem*\\n\\n# Approach\\nLet\\'s Start :) \\n- Step 1 we create a new promise using Promise.all\\n# **What\\'s the Promise.all method ?**\\nGreat question , what promise.all basically does is that it takes a certain number of promises and returns only one promise.\\nHere\\'s it\\'s syntax :\\nPromise.all(array) .\\nThat\\'s weird why do we have an array? \\nPromise.all literally takes an array as it\\'s parameters look at our code example below \\n```\\nPromise.all([promise1,promise2])\\n```\\nAs you can notice we have now an array of two promises and it\\'s passed down to our Promise.all which takes in an Array , be warry it always takes in an array . Then , returns a single promise.\\n\\nFor Further explanation , check out this link :)\\n\\n[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all]()\\n\\n- Step 2 : we use the .then method .\\nIn simple terms , .then method returns our resolved value in this case the resolved value from Promise.all (Basic Asynchronous knwoledge )\\n\\n- Step 3 : ofcourse the .then takes a callback function in this case it would be called value as shown below\\n ```\\n .then(value => DOSMTHG... )\\n```\\n# **Note :** VALUE IS A AN ARRAY BUT WHY ?\\nSimply because Promise.all took in an array of the 2 promises , it then returns an array. (check the  link above )\\n\\n- Step 4 : We have finished the async logic now it\\'s time for the logic of our problem .\\n### Let\\'s think together : \\n###### I have an array that has two values let\\'s say [2,3] . I want to return the sum of those two values . **HOW CAN I DO THAT?**\\n**We have several approahes , you may loop over the array maybe but hummm that kinda makes the code look bigger. \\nOr you can use eval method that evaluates the values o=in the array and concat them with a join(\\'+\\' ) . But not everyone knows the eval method and it\\'s not really the best Practice  :( .**\\n# LET\\'S HAVE A LOOK AT HOW DID I SOLVE IT :\\nI simply used the .reduce method. \\n- The reduce method takes an array as one of it\\'s parameters.\\n- It performs a reduction operation on the elements in the array\\n- Here\\'s it\\'s syntax in action :\\n```\\nvalue.reduce((acc,val) => acc+val,0)\\n```\\n- acc is the accumalator it\\'s value is 0\\n- The operation between them is Sum , which in our Case what we need\\nIf you\\'re not really familiar with reduce method I urge you to check this link below\\n[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce]()\\n\\n# AND THAT\\'S IT , IF YOU HAVE ANY QUESTIONS FEEL FREE TO ASK ME BELOW AND IF YOU\\'D LIKE ANY OTHER POST EXPLAINING THOSE ASYNC CONCEPTS IN DETAIL COMMENT OUT BELOW . \\nHAPPY HACKING :) \\n\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nconst addTwoPromises = async function(promise1, promise2) {\\n return Promise.all([promise1,promise2])\\n .then(value => value.reduce((acc,val) => acc+val,0))\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nPromise.all([promise1,promise2])\\n```\n```\\n .then(value => DOSMTHG... )\\n```\n```\\nvalue.reduce((acc,val) => acc+val,0)\\n```\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nconst addTwoPromises = async function(promise1, promise2) {\\n return Promise.all([promise1,promise2])\\n .then(value => value.reduce((acc,val) => acc+val,0))\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3609188,
                "title": "js-one-line-2-awaits",
                "content": "# Intuition\\nasync function alows await, so just sum 2 awaits\\n\\n\\n# Code\\n```\\nconst addTwoPromises = async (p1, p2) => await p1 + await p2;\\n```\\n\\nOne line version with Promise.all:\\n\\n```\\nconst addTwoPromises = async (...a) => new Promise(res => Promise.all([...a]).then(r => res(r.reduce((p, a) => p + a, 0))));\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst addTwoPromises = async (p1, p2) => await p1 + await p2;\\n```\n```\\nconst addTwoPromises = async (...a) => new Promise(res => Promise.all([...a]).then(r => res(r.reduce((p, a) => p + a, 0))));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3607783,
                "title": "use-promise-all",
                "content": "# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n  return Promise.all([promise1, promise2]).then((values) => {\\n    const sum = values.reduce((acc, curr) => acc + curr, 0);\\n    return sum;\\n  });\\n    \\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n  return Promise.all([promise1, promise2]).then((values) => {\\n    const sum = values.reduce((acc, curr) => acc + curr, 0);\\n    return sum;\\n  });\\n    \\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3608545,
                "title": "solution-without-promise-all-and-without-await",
                "content": "First resolve promise1 and then promise2:\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return new Promise(resolve => \\n        promise1.then(x => promise2.then(y => resolve(x + y))));\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return new Promise(resolve => \\n        promise1.then(x => promise2.then(y => resolve(x + y))));\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3985016,
                "title": "add-two-promises",
                "content": "# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function (promise1, promise2) {\\n    return new Promise(function (resolve, reject) {\\n        promise1.then(function (result1) {\\n            promise2.then(function (result2) {\\n                resolve(result1 + result2);\\n            }).catch(function (error) {\\n                reject(error);\\n            });\\n        }).catch(function (error) {\\n            reject(error);\\n        });\\n    });\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function (promise1, promise2) {\\n    return new Promise(function (resolve, reject) {\\n        promise1.then(function (result1) {\\n            promise2.then(function (result2) {\\n                resolve(result1 + result2);\\n            }).catch(function (error) {\\n                reject(error);\\n            });\\n        }).catch(function (error) {\\n            reject(error);\\n        });\\n    });\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3906386,
                "title": "easy-javascript-3-different-approaches-one-line-solution",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing Promise.all\\n*We are directy using promise.all to wait for both the promises to complete.\\n\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n     return Promise.all([promise1, promise2]).then(([value1, value2]) => value1 + value2);\\n\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing Promise and await\\n* First weusing await to resolve both the promises and store the resolve results in the val1 and val2.\\n* then we are returning new promise and doinf the required calculation.\\n\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n\\n    const [val1, val2] = await Promise.all([promise1,promise2]);\\n\\n  \\treturn new Promise((resolve) => resolve(val1 + val2))\\n\\n\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* here we are directly using await for both the promises to resolve and returning its sum value.\\n\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    \\n     return await promise1 + await promise2;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n     return Promise.all([promise1, promise2]).then(([value1, value2]) => value1 + value2);\\n\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n\\n    const [val1, val2] = await Promise.all([promise1,promise2]);\\n\\n  \\treturn new Promise((resolve) => resolve(val1 + val2))\\n\\n\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    \\n     return await promise1 + await promise2;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3608922,
                "title": "promise-then-returns-a-new-promise",
                "content": "# Intuition\\nSince promise.then() returns a new Promise, you don\\'t have to create a new Promise altogether. \\n\\n```\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return promise1.then((val) => promise2.then((val2) => val + val2))\\n            .catch((e) => console.log(e));\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return promise1.then((val) => promise2.then((val2) => val + val2))\\n            .catch((e) => console.log(e));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3608385,
                "title": "easy-solution-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n  const integers = await Promise.all([promise1, promise2]);\\n  let sum = 0;\\n\\n  for (const curr of integers) {\\n    sum += curr;\\n  }\\n\\n  return sum;   \\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n  const integers = await Promise.all([promise1, promise2]);\\n  let sum = 0;\\n\\n  for (const curr of integers) {\\n    sum += curr;\\n  }\\n\\n  return sum;   \\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3797364,
                "title": "play-with-promise-all-mixing-then-and-await-go-solo-with-then",
                "content": "\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    // method1\\n    // return   promise1.then((val1)=>{\\n    //     return promise2.then((val2)=>{\\n    //         return val1+val2\\n    //     })\\n    // })\\n    // method2\\n    // const [res1,res2] = await Promise.all([promise1,promise2])\\n    // return res1 + res2 ;\\n    // method3\\n  return await Promise.all([promise1,promise2]).then(\\n  value => {\\n    return value[0] + value[1];\\n  }\\n);\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    // method1\\n    // return   promise1.then((val1)=>{\\n    //     return promise2.then((val2)=>{\\n    //         return val1+val2\\n    //     })\\n    // })\\n    // method2\\n    // const [res1,res2] = await Promise.all([promise1,promise2])\\n    // return res1 + res2 ;\\n    // method3\\n  return await Promise.all([promise1,promise2]).then(\\n  value => {\\n    return value[0] + value[1];\\n  }\\n);\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3641138,
                "title": "ts-promise-all-like-wrapper-46ms-43-1mb",
                "content": "This problem is basically a light version of [execute asynchronous functions in parallel](https://leetcode.com/problems/execute-asynchronous-functions-in-parallel/) ([cracked here](https://leetcode.com/problems/execute-asynchronous-functions-in-parallel/solutions/3619595/ts-return-a-promise-wrapper-72ms-43mb/)).\\n\\nIn a similar fashion, we are going to `return` a `Promise` wrapper that will:\\n* declare two support variables:\\n    * `cnt` that keeps the count of how many promises need to still be resolved;\\n    * `res` stores our final result, initially set to `0`;\\n* declare a helper resolve function for the two basic promises, `handler`, that will take a value `n` and:\\n    * increase `res` by `n`;\\n    * decrease `cnt` by `1`\\n    * if both promises were resolved (ie: `cnt === 0`), it will call `resolve` with `res`;\\n* call both `p1` and `p2` passing `handler` as its `resolve` function (for the sake of this problem, no rejection needs to be considered - but do so in interview and of course production code!).\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```ts\\nasync function addTwoPromises(p1: Promise<number>, p2: Promise<number>): Promise<number> {\\n    return new Promise((resolve) => {\\n        let cnt = 2, res = 0;\\n        const handler = (n: number) => {\\n            // updating tot and cnt\\n            res += n, cnt--;\\n            // calling resolve when both are done\\n            if (!cnt) resolve(res);\\n        }\\n        // running p1 and p2 with handler\\n        p1.then(handler);\\n        p2.then(handler);\\n    });\\n};\\n```\\n\\n#Brag\\n![image.png](https://assets.leetcode.com/users/images/8d266164-af74-4b75-af90-5590f68ee430_1686825301.5434332.png)\\n",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```ts\\nasync function addTwoPromises(p1: Promise<number>, p2: Promise<number>): Promise<number> {\\n    return new Promise((resolve) => {\\n        let cnt = 2, res = 0;\\n        const handler = (n: number) => {\\n            // updating tot and cnt\\n            res += n, cnt--;\\n            // calling resolve when both are done\\n            if (!cnt) resolve(res);\\n        }\\n        // running p1 and p2 with handler\\n        p1.then(handler);\\n        p2.then(handler);\\n    });\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3615280,
                "title": "easy-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    let i = await promise1;\\n    let j = await promise2;\\n\\n    return i + j;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    let i = await promise1;\\n    let j = await promise2;\\n\\n    return i + j;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3611782,
                "title": "javascirpt-easy-solution-async-await",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    let sum = 0;\\n    sum += await promise1;\\n    sum += await promise2;\\n    return Promise.resolve(sum);\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    let sum = 0;\\n    sum += await promise1;\\n    sum += await promise2;\\n    return Promise.resolve(sum);\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3609005,
                "title": "simple-solution-promise-all",
                "content": "# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    const [res1, res2] = await Promise.all([promise1, promise2]);\\n    return res1 + res2;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    const [res1, res2] = await Promise.all([promise1, promise2]);\\n    return res1 + res2;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3608632,
                "title": "one-liner-with-weird-sum-calculation",
                "content": "# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return Promise.all([promise1, promise2])\\n        .then(results => eval(results.join(\\'+\\')))\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return Promise.all([promise1, promise2])\\n        .then(results => eval(results.join(\\'+\\')))\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3842240,
                "title": "javascript",
                "content": "# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n  // Wait for both promises to resolve and retrieve their values\\n  const [value1, value2] = await Promise.all([promise1, promise2]);\\n\\n  // Return a new promise that resolves with the sum of the values\\n  return value1 + value2;\\n};\\n\\n// // Example usage:\\n// var promise1 = new Promise(resolve => setTimeout(() => resolve(2), 20));\\n// var promise2 = new Promise(resolve => setTimeout(() => resolve(5), 60));\\n\\n// addTwoPromises(promise1, promise2)\\n//   .then(console.log); // Output: 7\\n/*Use Promise.all() method along with await to wait for both promises to resolve. Once they resolve, their values are retrieved and stored in the variables value1 and value2. Finally, a new promise is returned with the sum of value1 and value2.*/\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n  // Wait for both promises to resolve and retrieve their values\\n  const [value1, value2] = await Promise.all([promise1, promise2]);\\n\\n  // Return a new promise that resolves with the sum of the values\\n  return value1 + value2;\\n};\\n\\n// // Example usage:\\n// var promise1 = new Promise(resolve => setTimeout(() => resolve(2), 20));\\n// var promise2 = new Promise(resolve => setTimeout(() => resolve(5), 60));\\n\\n// addTwoPromises(promise1, promise2)\\n//   .then(console.log); // Output: 7\\n/*Use Promise.all() method along with await to wait for both promises to resolve. Once they resolve, their values are retrieved and stored in the variables value1 and value2. Finally, a new promise is returned with the sum of value1 and value2.*/\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3746628,
                "title": "simple-solution",
                "content": "\\n\\n# Lazy Approach\\n\\n# Code\\n```\\nasync function addTwoPromises(promise1: Promise<number>, promise2: Promise<number>): Promise<number> {\\n let result: number = 0;\\n  result += (await promise1).valueOf();\\n  result += (await promise2).valueOf();\\n\\n  return result;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nasync function addTwoPromises(promise1: Promise<number>, promise2: Promise<number>): Promise<number> {\\n let result: number = 0;\\n  result += (await promise1).valueOf();\\n  result += (await promise2).valueOf();\\n\\n  return result;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3638863,
                "title": "typescript-one-liner",
                "content": "# Code\\n```\\nasync function addTwoPromises(promise1: Promise<number>, promise2: Promise<number>): Promise<number> {\\n    return await promise1 + await promise2\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nasync function addTwoPromises(promise1: Promise<number>, promise2: Promise<number>): Promise<number> {\\n    return await promise1 + await promise2\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3614714,
                "title": "single-line-solution",
                "content": "# Code\\n```\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return await promise1 + await promise2\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return await promise1 + await promise2\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4097079,
                "title": "simple-solution-in-js-ts",
                "content": "# Code\\n```\\ntype P = Promise<number>\\n\\nasync function addTwoPromises(promise1: P, promise2: P): P {\\n\\tlet x = 0;\\n\\tlet y = 0;\\n\\n\\tx = await promise1.then((value) => value);\\n\\n\\ty = await promise2.then((value) => value);\\n\\n\\treturn new Promise((res) => {\\n\\t\\tres(x + y)\\n\\t})\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype P = Promise<number>\\n\\nasync function addTwoPromises(promise1: P, promise2: P): P {\\n\\tlet x = 0;\\n\\tlet y = 0;\\n\\n\\tx = await promise1.then((value) => value);\\n\\n\\ty = await promise2.then((value) => value);\\n\\n\\treturn new Promise((res) => {\\n\\t\\tres(x + y)\\n\\t})\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4096246,
                "title": "ez-oneliner-for-beginner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n\\n    return await promise1 + await promise2\\n\\n    //let num1 = await promise1;\\n    //let num2 = await promise2;\\n    //return new Promise((resolve, reject) => {\\n        //resolve(num1 + num2);\\n    //});\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n\\n    return await promise1 + await promise2\\n\\n    //let num1 = await promise1;\\n    //let num2 = await promise2;\\n    //return new Promise((resolve, reject) => {\\n        //resolve(num1 + num2);\\n    //});\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4095705,
                "title": "1-linear-javascript-using-await",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return await promise1 + await promise2\\n    \\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return await promise1 + await promise2\\n    \\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4094628,
                "title": "simple-solution-one-line",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return await promise1 + await promise2\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return await promise1 + await promise2\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4094388,
                "title": "add-two-promises-using-js-with-constant-time-complexity",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n$$Big-O = O(1) - Constant$$\\n# Code\\n```\\nvar addTwoPromises = async function (promise1, promise2) {\\n  const res = await promise1 + await promise2;\\n  return  res;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar addTwoPromises = async function (promise1, promise2) {\\n  const res = await promise1 + await promise2;\\n  return  res;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4084358,
                "title": "add-two-promises-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function (promise1, promise2) {\\n\\n  let val1 = await promise1;\\n  let val2 = await promise2;\\n  let sum = new Promise((resolve) => {\\n    resolve(val1 + val2);\\n  });\\n\\n  return await sum;\\n};\\n\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function (promise1, promise2) {\\n\\n  let val1 = await promise1;\\n  let val2 = await promise2;\\n  let sum = new Promise((resolve) => {\\n    resolve(val1 + val2);\\n  });\\n\\n  return await sum;\\n};\\n\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4078405,
                "title": "add-two-promises-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\npromise by promise\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return await Promise.all([promise1, promise2]).then(\\n            ([val1, val2])=>{ return val1 + val2} )\\n};\\naddTwoPromises(promise1, promise2).then((sum) => console.log(sum));\\n\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return await Promise.all([promise1, promise2]).then(\\n            ([val1, val2])=>{ return val1 + val2} )\\n};\\naddTwoPromises(promise1, promise2).then((sum) => console.log(sum));\\n\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4075642,
                "title": "efficiently-adding-two-promises-using-javascript-a-concurrent-approach",
                "content": "## Approach 1: Using `await` and `Promise.all()`\\n\\n### Intuition\\nWe want to add two values that are resolved from promises. To do this efficiently, we can use `Promise.all()` to concurrently wait for both promises to resolve and then add their results.\\n\\n### Approach\\n1. We use `await` to wait for the promises `promise1` and `promise2` to resolve.\\n2. We use `Promise.all([promise1, promise2])` to concurrently await both promises and get an array of their resolved values.\\n3. We destructure the results into `result1` and `result2`.\\n4. We return the sum of `result1` and `result2`.\\n\\n### Complexity\\n- Time complexity: O(1) (Concurrent waiting for promises)\\n- Space complexity: O(1) (No additional data structures used)\\n\\n```javascript\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    const [result1, result2] = await Promise.all([promise1, promise2]);\\n    return result1 + result2;\\n};\\n```\\n## Approach 2: Using `.then()` Method\\n\\n### Intuition\\nWe aim to add the resolved values of two promises. In this approach, we\\'ll use the `.then()` method to handle the results of `Promise.all()`.\\n\\n### Approach\\n1. We use `Promise.all([promise1, promise2])` to concurrently await both promises.\\n2. We use the `.then()` method to handle the results when they are ready.\\n3. In the `.then()` callback, we destructure the results into result1 and result2.\\n4. We return the sum of `result1` and `result2`.\\n### Complexity\\nTime complexity: $$O(1)$$ (Concurrent waiting for promises)\\nSpace complexity:$$O(1)$$  (No additional data structures used)\\n```javascript\\n\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = function(promise1, promise2) {\\n  return Promise.all([promise1, promise2]).then(([result1, result2]) => {\\n    return result1 + result2;\\n  });\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    const [result1, result2] = await Promise.all([promise1, promise2]);\\n    return result1 + result2;\\n};\\n```\n```javascript\\n\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = function(promise1, promise2) {\\n  return Promise.all([promise1, promise2]).then(([result1, result2]) => {\\n    return result1 + result2;\\n  });\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4074925,
                "title": "so-easy-in-just-one-line-check-it-out",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return new Promise(async (resolve, reject) => resolve(await promise1 + await promise2))\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return new Promise(async (resolve, reject) => resolve(await promise1 + await promise2))\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4072488,
                "title": "javascript-code-beats-93-runtime-and-86-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n  return Promise.all([promise1, promise2])\\n    .then(([result1, result2]) => result1 + result2);  \\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n  return Promise.all([promise1, promise2])\\n    .then(([result1, result2]) => result1 + result2);  \\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4066212,
                "title": "fastest-solution-using-promise-all",
                "content": "# Approach\\nSince there are two promises, it is better to use `Promise.all()` to resolve them simultaneously, which will make the code execution complete faster than resolving them one by one.\\n\\n# Code\\n```\\ntype P = Promise<number>\\n\\nasync function addTwoPromises(promise1: P, promise2: P): P {\\n    return Promise.all([promise1, promise2]).then((vals) => {\\n        return vals.reduce((acc, cur) => acc + cur)\\n    })\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype P = Promise<number>\\n\\nasync function addTwoPromises(promise1: P, promise2: P): P {\\n    return Promise.all([promise1, promise2]).then((vals) => {\\n        return vals.reduce((acc, cur) => acc + cur)\\n    })\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4061360,
                "title": "most-simple-one-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n   return new Promise(async(resolve)=> resolve(await promise1 + await promise2))\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n   return new Promise(async(resolve)=> resolve(await promise1 + await promise2))\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4057170,
                "title": "proper-explanation-on-how-promise-all-works-not-a-one-liner",
                "content": "# Promise.all() \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- It takes an array of promises and returns a promise as an output if all the promises in the array are resolved \\n- Otherwise, it rejects with the 1st promise that was rejected as the reason. \\n\\n#### What happens when the array is empty?\\n```\\ni.e  Promise.all([]) \\n```\\nThe promise is immediately fulfilled, instead of going to the microtask queue. \\n\\n#### What happens when the array is not composed of promises? \\n```\\ni.e  Promise.all([1, 2, 3]) \\n```\\nThe promise is asynchronously fulfilled. i.e it goes through the entire process of being added to the microtask queue. \\n\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function (promise1, promise2) {\\n  const res = Promise.all([promise1, promise2]).then(values => {\\n\\n    // Could\\'ve not used reduce since we know that there are only 2 promises. \\n    // But handling just in case if we have more than 2. \\n    return values.reduce((acc, curr) => {\\n      return acc + curr;\\n    }, 0);\\n  });\\n\\n  return res;\\n};\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\ni.e  Promise.all([]) \\n```\n```\\ni.e  Promise.all([1, 2, 3]) \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4053491,
                "title": "why-y-all-awaiting",
                "content": "# Intuition\\nWell, why should I await and be slow?\\n\\n# Approach\\nDon\\'t await then I guess\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nasync function addTwoPromises(promise1, promise2) {\\n    return new Promise((resolve) => {\\n        Promise.all([promise1, promise2]).then((values) => {\\n            resolve(values[0] + values[1])\\n        })\\n    })\\n\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nasync function addTwoPromises(promise1, promise2) {\\n    return new Promise((resolve) => {\\n        Promise.all([promise1, promise2]).then((values) => {\\n            resolve(values[0] + values[1])\\n        })\\n    })\\n\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4052897,
                "title": "add-two-promises",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n     let [_num1,_num2]=await Promise.all([promise1,promise2])\\n     return _num1+_num2\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n     let [_num1,_num2]=await Promise.all([promise1,promise2])\\n     return _num1+_num2\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4052688,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\n \\nvar addTwoPromises = async function(promise1, promise2) {\\n   try{\\n\\n       const result1 = await promise1\\n       const result2 = await promise2\\n\\n       const sum = result1 + result2\\n\\n       // Return the result as a resolved promise\\n        return Promise.resolve(sum);\\n\\n   }catch(error){\\n       // Handle any errors that may occur during promise resolution\\n        return Promise.reject(error);\\n   }\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\n \\nvar addTwoPromises = async function(promise1, promise2) {\\n   try{\\n\\n       const result1 = await promise1\\n       const result2 = await promise2\\n\\n       const sum = result1 + result2\\n\\n       // Return the result as a resolved promise\\n        return Promise.resolve(sum);\\n\\n   }catch(error){\\n       // Handle any errors that may occur during promise resolution\\n        return Promise.reject(error);\\n   }\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4051359,
                "title": "solution-in-2-strings",
                "content": "\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\nlet result = await Promise.all([promise1,promise2]).then(value => value.reduce((acc,cur)=>{\\n        return acc+cur}\\n    ))\\n   \\n    return result\\n    }\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\nlet result = await Promise.all([promise1,promise2]).then(value => value.reduce((acc,cur)=>{\\n        return acc+cur}\\n    ))\\n   \\n    return result\\n    }\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4048284,
                "title": "solution-with-await-promise-all",
                "content": "\\n![Screenshot_2.png](https://assets.leetcode.com/users/images/c624ad3e-d261-4629-be71-ec7f2b25a1e1_1694790707.4973521.png)\\n\\n![Screenshot_4.png](https://assets.leetcode.com/users/images/49586a40-cb38-4910-a882-b0069fed9157_1694790774.3906393.png)\\n\\n\\n\\n\\n# Code\\n```\\ntype P = Promise<number>\\n\\nasync function addTwoPromises(promise1: P, promise2: P): P {\\n    const promises = await Promise.all([promise1, promise2]);\\n    return promises[0] + promises[1]\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype P = Promise<number>\\n\\nasync function addTwoPromises(promise1: P, promise2: P): P {\\n    const promises = await Promise.all([promise1, promise2]);\\n    return promises[0] + promises[1]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4047099,
                "title": "1-line-in-javascript-beats-99-43-submission",
                "content": "\\n# Code\\n```\\nasync function  addTwoPromises(promise1: Promise<number>, promise2: Promise<number>): Promise<number> {\\n  return await promise1 + await promise2;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nasync function  addTwoPromises(promise1: Promise<number>, promise2: Promise<number>): Promise<number> {\\n  return await promise1 + await promise2;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4045405,
                "title": "typescript-promise-all-array-reduce",
                "content": "# Approach\\nUtilize `Promise.all` and `array.reduce` for a succinct and efficient solution.\\n\\n`Promise.all` takes an array of promises and waits for all of them to resolve or reject, then returns an array of the values from the fullfilled promises.\\n\\nThen we can utilize the `array.reduce` method to get the sum of all the values. The reduce method takes two arguments: `accumulator` and `currentValue`. The accumulator argument is the result of the previous call to our reduce function (i.e. our sum) and the currentValue argument is the value of the current element.\\n\\n# Code\\n```\\nasync function addTwoPromises(promise1: Promise<number>, promise2: Promise<number>): Promise<number> {\\n    return await Promise.all([promise1, promise2]).then((data) => {\\n        return data.reduce((acc, curr) => acc + curr);\\n    });\\n};\\n```\\n\\n# Alternative Solution\\nNow you could also just do the following\\n```\\nasync function addTwoPromises(promise1: Promise<number>, promise2: Promise<number>): Promise<number> {\\n    return await Promise.all([promise1, promise2]).then((data) => {\\n        return data[0] + data[1];\\n    });\\n};\\n```\\nBut what happens if in the future you need to add 3 promises? Or 5? This could get messy, and result in you needing to refactor your solution. By using `array.reduce` you are prepared to handle any amount of promises :)",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nasync function addTwoPromises(promise1: Promise<number>, promise2: Promise<number>): Promise<number> {\\n    return await Promise.all([promise1, promise2]).then((data) => {\\n        return data.reduce((acc, curr) => acc + curr);\\n    });\\n};\\n```\n```\\nasync function addTwoPromises(promise1: Promise<number>, promise2: Promise<number>): Promise<number> {\\n    return await Promise.all([promise1, promise2]).then((data) => {\\n        return data[0] + data[1];\\n    });\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4041277,
                "title": "javascript-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    let [val1, val2] = await Promise.all([promise1, promise2]);\\n    return val1 + val2\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    let [val1, val2] = await Promise.all([promise1, promise2]);\\n    return val1 + val2\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4040364,
                "title": "add-two-promises-typescript",
                "content": "```\\nasync function addTwoPromises(promise1: Promise<number>, promise2: Promise<number>): Promise<number> {\\n    const [n1, n2] = await Promise.all([promise1, promise2]);\\n    return n1 + n2;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nasync function addTwoPromises(promise1: Promise<number>, promise2: Promise<number>): Promise<number> {\\n    const [n1, n2] = await Promise.all([promise1, promise2]);\\n    return n1 + n2;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4036724,
                "title": "one-line-easy-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nresolve both the promises and return the result\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe have to await because of the setTimeout function. \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n\\n resolve both promises and add the numbers\\n return a new promise with the new sum\\n */\\nvar addTwoPromises = async function (promise1, promise2) {\\n\\n    return await Promise.resolve(promise1) + await Promise.resolve(promise2)\\n    // let sum = await Promise.resolve(promise1)\\n    // sum += await Promise.resolve(promise2)\\n\\n    // return sum\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n\\n resolve both promises and add the numbers\\n return a new promise with the new sum\\n */\\nvar addTwoPromises = async function (promise1, promise2) {\\n\\n    return await Promise.resolve(promise1) + await Promise.resolve(promise2)\\n    // let sum = await Promise.resolve(promise1)\\n    // sum += await Promise.resolve(promise2)\\n\\n    // return sum\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4034491,
                "title": "javascript-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    const [a, b] = await Promise.all([promise1, promise2]);\\n    return a + b;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    const [a, b] = await Promise.all([promise1, promise2]);\\n    return a + b;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4034275,
                "title": "explained-in-simple-terms",
                "content": "here simply we can store value of promise1 and promise2 in a variable and return it.\\nnote:\\n- await: we need to use await keyword bcoz javascript excecution doestnt wait for anyone but in first promise is fetching value. async will stop the execution of that function until we get the value.\\n- at the end we need to return promise so cant simply return sum we need to make it promise .\\npromise.resolve is used to make any value promise\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    var sum = 0;\\n    sum += await promise1;\\n    sum += await promise2;\\n    return Promise.resolve(sum);\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    var sum = 0;\\n    sum += await promise1;\\n    sum += await promise2;\\n    return Promise.resolve(sum);\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4030773,
                "title": "neat-short-solution-with-explanation",
                "content": "# Explanation\\nSince `promise1` and `promise2` returns a promise and the function is wrapped with `async`, simply use `await` to get the result of both the promises and return the sum.\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    const result1 = await promise1;\\n    const result2 = await promise2;\\n    return result1 + result2;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    const result1 = await promise1;\\n    const result2 = await promise2;\\n    return result1 + result2;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4030254,
                "title": "await-promise-all",
                "content": "\\n```\\nasync function addTwoPromises(promise1: Promise<number>, promise2: Promise<number>): Promise<number> {\\n     return await Promise.all([promise1, promise2]).then((values) => values[0] + values[1])\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nasync function addTwoPromises(promise1: Promise<number>, promise2: Promise<number>): Promise<number> {\\n     return await Promise.all([promise1, promise2]).then((values) => values[0] + values[1])\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4029779,
                "title": "typescript-promise-all",
                "content": "\\n\\n# Code\\n```\\nasync function addTwoPromises(promise1: Promise<number>, promise2: Promise<number>): Promise<number> {\\n    const[a,b]: [number,number] = await Promise.all([promise1,promise2])\\n    return a+b\\n};",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "\\n\\n# Code\\n```\\nasync function addTwoPromises(promise1: Promise<number>, promise2: Promise<number>): Promise<number> {\\n    const[a,b]: [number,number] = await Promise.all([promise1,promise2])\\n    return a+b\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 4028523,
                "title": "2723-add-two-promises-1-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFunction is declared using arrow function syntax, The resolved values are then combined using the reduce() method to calculate the sum.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async (promise1, promise2) => (await Promise.all([promise1, promise2])).reduce((acc, val) => acc + val);\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async (promise1, promise2) => (await Promise.all([promise1, promise2])).reduce((acc, val) => acc + val);\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4028402,
                "title": "a",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\nlet promise3 = [a,b] = await Promise.all([promise1, promise2])\\nreturn a + b\\n}\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\nlet promise3 = [a,b] = await Promise.all([promise1, promise2])\\nreturn a + b\\n}\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4028324,
                "title": "beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\n /*\\nvar addTwoPromises = async function(promise1, promise2) {\\n  return await Promise.all([promise1, promise2]).then(\\n     ([val1, val2]) => val1 + val2\\n  )\\n};\\n*/\\nvar addTwoPromises = async function(promise1, promise2) {\\n    \\n     return await promise1 + await promise2;\\n};\\n\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\n /*\\nvar addTwoPromises = async function(promise1, promise2) {\\n  return await Promise.all([promise1, promise2]).then(\\n     ([val1, val2]) => val1 + val2\\n  )\\n};\\n*/\\nvar addTwoPromises = async function(promise1, promise2) {\\n    \\n     return await promise1 + await promise2;\\n};\\n\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4026987,
                "title": "oneliner",
                "content": "```\\nvar addTwoPromises = async (a, b) => await a + await b\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar addTwoPromises = async (a, b) => await a + await b\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4025942,
                "title": "ts-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nconst addTwoPromises = async (promise1: Promise<number>, promise2: Promise<number>): Promise<number> => Promise.all([promise1, promise2])\\n    .then(([result1, result2]) => {\\n        return Promise.resolve(result1 + result2);\\n    });\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nconst addTwoPromises = async (promise1: Promise<number>, promise2: Promise<number>): Promise<number> => Promise.all([promise1, promise2])\\n    .then(([result1, result2]) => {\\n        return Promise.resolve(result1 + result2);\\n    });\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4025485,
                "title": "easy-javascript-solutions-js",
                "content": "# Easy JavaScript Solutions || JS || \\u270C\\u270C\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n  return Promise.all([promise1, promise2])\\n    .then((values) => {\\n      const sum = values.reduce((acc, currentValue) => acc + currentValue, 0);\\n      return sum;\\n    });  \\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n  return Promise.all([promise1, promise2])\\n    .then((values) => {\\n      const sum = values.reduce((acc, currentValue) => acc + currentValue, 0);\\n      return sum;\\n    });  \\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4018419,
                "title": "promises-beginner-friendly-easy-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return Promise.all([promise1, promise2])\\n        .then((values) => {\\n            const [result1, result2] = values;\\n            return result1 + result2;\\n        });\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return Promise.all([promise1, promise2])\\n        .then((values) => {\\n            const [result1, result2] = values;\\n            return result1 + result2;\\n        });\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4015664,
                "title": "add-two-promises-with-ukrainian-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\u041C\\u0435\\u0442\\u0430 \\u043F\\u043E\\u043B\\u044F\\u0433\\u0430\\u0454 \\u0443 \\u0441\\u0442\\u0432\\u043E\\u0440\\u0435\\u043D\\u043D\\u0456 \\u043D\\u043E\\u0432\\u043E\\u0433\\u043E \\u043F\\u0440\\u043E\\u043C\\u0456\\u0441\\u0443, \\u044F\\u043A\\u0438\\u0439 \\u043F\\u043E\\u0432\\u0435\\u0440\\u043D\\u0435 \\u0441\\u0443\\u043C\\u0443 \\u0434\\u0432\\u043E\\u0445 \\u0456\\u043D\\u0448\\u0438\\u0445 \\u043F\\u0440\\u043E\\u043C\\u0456\\u0441\\u0456\\u0432.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\u0414\\u043B\\u044F \\u0434\\u043E\\u0441\\u044F\\u0433\\u043D\\u0435\\u043D\\u043D\\u044F \\u0446\\u0456\\u0454\\u0457 \\u043C\\u0435\\u0442\\u0438 \\u043C\\u0438 \\u0432\\u0438\\u043A\\u043E\\u0440\\u0438\\u0441\\u0442\\u043E\\u0432\\u0443\\u0454\\u043C\\u043E \\u043C\\u0435\\u0442\\u043E\\u0434 Promise.all() \\u0440\\u0430\\u0437\\u043E\\u043C \\u0456\\u0437 await, \\u0449\\u043E\\u0431 \\u0434\\u043E\\u0447\\u0435\\u043A\\u0430\\u0442\\u0438\\u0441\\u044F \\u0432\\u0438\\u0440\\u0456\\u0448\\u0435\\u043D\\u043D\\u044F \\u043E\\u0431\\u043E\\u0445 \\u043F\\u0440\\u043E\\u043C\\u0456\\u0441\\u0456\\u0432. \\u041F\\u0456\\u0441\\u043B\\u044F \\u0442\\u043E\\u0433\\u043E, \\u044F\\u043A \\u0432\\u043E\\u043D\\u0438 \\u0432\\u0438\\u0440\\u0456\\u0448\\u0443\\u044E\\u0442\\u044C\\u0441\\u044F, \\u0457\\u0445 \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u043D\\u044F \\u0432\\u0438\\u0442\\u044F\\u0433\\u0443\\u044E\\u0442\\u044C\\u0441\\u044F \\u0456 \\u0437\\u0431\\u0435\\u0440\\u0456\\u0433\\u0430\\u044E\\u0442\\u044C\\u0441\\u044F \\u0443 \\u0437\\u043C\\u0456\\u043D\\u043D\\u0438\\u0445 `value1` \\u0456 `value2`. \\u041F\\u043E\\u0442\\u0456\\u043C \\u043C\\u0438 \\u043F\\u043E\\u0432\\u0435\\u0440\\u0442\\u0430\\u0454\\u043C\\u043E \\u043D\\u043E\\u0432\\u0438\\u0439 \\u043F\\u0440\\u043E\\u043C\\u0456\\u0441, \\u044F\\u043A\\u0438\\u0439 \\u043F\\u0440\\u0435\\u0434\\u0441\\u0442\\u0430\\u0432\\u043B\\u044F\\u0454 \\u0441\\u043E\\u0431\\u043E\\u044E \\u0441\\u0443\\u043C\\u0443 \\u0446\\u0438\\u0445 \\u0434\\u0432\\u043E\\u0445 \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u044C.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\u0427\\u0430\\u0441\\u043E\\u0432\\u0430 \\u0441\\u043A\\u043B\\u0430\\u0434\\u043D\\u0456\\u0441\\u0442\\u044C \\u0432\\u0438\\u0437\\u043D\\u0430\\u0447\\u0430\\u0454\\u0442\\u044C\\u0441\\u044F \\u043D\\u0430\\u0439\\u0431\\u0456\\u043B\\u044C\\u0448 \\u0442\\u0440\\u0438\\u0432\\u0430\\u043B\\u0438\\u043C \\u043F\\u0440\\u043E\\u043C\\u0456\\u0441\\u043E\\u043C, \\u043E\\u0441\\u043A\\u0456\\u043B\\u044C\\u043A\\u0438 \\u043C\\u0435\\u0442\\u043E\\u0434 Promise.all() \\u043E\\u0447\\u0456\\u043A\\u0443\\u0454 \\u043E\\u0434\\u043D\\u043E\\u0447\\u0430\\u0441\\u043D\\u043E\\u0433\\u043E \\u0432\\u0438\\u0440\\u0456\\u0448\\u0435\\u043D\\u043D\\u044F \\u043E\\u0431\\u043E\\u0445 \\u043F\\u0440\\u043E\\u043C\\u0456\\u0441\\u0456\\u0432. \\u0422\\u043E\\u043C\\u0443 \\u0447\\u0430\\u0441\\u043E\\u0432\\u0430 \\u0441\\u043A\\u043B\\u0430\\u0434\\u043D\\u0456\\u0441\\u0442\\u044C \\u043C\\u043E\\u0436\\u0435 \\u0431\\u0443\\u0442\\u0438 \\u043E\\u0446\\u0456\\u043D\\u0435\\u043D\\u0430 \\u044F\\u043A O(max(\\u0447\\u0430\\u0441 \\u0432\\u0438\\u0440\\u0456\\u0448\\u0435\\u043D\\u043D\\u044F promise1, \\u0447\\u0430\\u0441 \\u0432\\u0438\\u0440\\u0456\\u0448\\u0435\\u043D\\u043D\\u044F promise2)).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\u041F\\u0440\\u043E\\u0441\\u0442\\u043E\\u0440\\u043E\\u0432\\u0430 \\u0441\\u043A\\u043B\\u0430\\u0434\\u043D\\u0456\\u0441\\u0442\\u044C \\u0454 \\u0441\\u0442\\u0430\\u043B\\u0438\\u043C \\u0437\\u043D\\u0430\\u0447\\u0435\\u043D\\u043D\\u044F\\u043C, \\u043E\\u0441\\u043A\\u0456\\u043B\\u044C\\u043A\\u0438 \\u043A\\u043E\\u0434 \\u043D\\u0435 \\u0441\\u0442\\u0432\\u043E\\u0440\\u044E\\u0454 \\u0434\\u043E\\u0434\\u0430\\u0442\\u043A\\u043E\\u0432\\u0438\\u0445 \\u0441\\u0442\\u0440\\u0443\\u043A\\u0442\\u0443\\u0440 \\u0434\\u0430\\u043D\\u0438\\u0445 \\u0430\\u0431\\u043E \\u043D\\u0435 \\u0432\\u0438\\u043A\\u043E\\u0440\\u0438\\u0441\\u0442\\u043E\\u0432\\u0443\\u0454 \\u0434\\u043E\\u0434\\u0430\\u0442\\u043A\\u043E\\u0432\\u0443 \\u043F\\u0430\\u043C\\'\\u044F\\u0442\\u044C, \\u044F\\u043A\\u0430 \\u0431 \\u0437\\u0430\\u043B\\u0435\\u0436\\u0430\\u043B\\u0430 \\u0432\\u0456\\u0434 \\u0440\\u043E\\u0437\\u043C\\u0456\\u0440\\u0443 \\u0432\\u0445\\u0456\\u0434\\u043D\\u0438\\u0445 \\u0434\\u0430\\u043D\\u0438\\u0445. \\u0422\\u043E\\u043C\\u0443 \\u043F\\u0440\\u043E\\u0441\\u0442\\u043E\\u0440\\u043E\\u0432\\u0430 \\u0441\\u043A\\u043B\\u0430\\u0434\\u043D\\u0456\\u0441\\u0442\\u044C \\u043C\\u043E\\u0436\\u0435 \\u0431\\u0443\\u0442\\u0438 \\u043E\\u0446\\u0456\\u043D\\u0435\\u043D\\u0430 \\u044F\\u043A O(1).\\n\\n# Code\\n```\\nasync function addTwoPromises(promise1: Promise<number>, promise2: Promise<number>): Promise<number> {\\n    const [value1, value2] = await Promise.all([promise1, promise2])\\n    return value1 + value1\\n};\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nasync function addTwoPromises(promise1: Promise<number>, promise2: Promise<number>): Promise<number> {\\n    const [value1, value2] = await Promise.all([promise1, promise2])\\n    return value1 + value1\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4014009,
                "title": "just-one-stream-without-blocking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return Promise\\n            .all([promise1, promise2])\\n                .then((arr) => arr.reduce((acc, cur) => acc + cur, 0))\\n           \\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return Promise\\n            .all([promise1, promise2])\\n                .then((arr) => arr.reduce((acc, cur) => acc + cur, 0))\\n           \\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4012268,
                "title": "simple-solution-using-promise-all",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    // let p1 = await promise1;\\n    // let p2 = await promise2;\\n\\n    // using promise.all()\\n    let [p1 ,p2] = await Promise.all([promise1,promise2])\\n    return p1+p2\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    // let p1 = await promise1;\\n    // let p2 = await promise2;\\n\\n    // using promise.all()\\n    let [p1 ,p2] = await Promise.all([promise1,promise2])\\n    return p1+p2\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4011085,
                "title": "javascript",
                "content": "*Italic*# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2)\\n {\\n    return   promise1.then((val1)=>\\n        {\\n\\n            return promise2.then((val2)=>\\n            {\\n\\n                return val1+val2\\n            })\\n        })\\n    \\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2)\\n {\\n    return   promise1.then((val1)=>\\n        {\\n\\n            return promise2.then((val2)=>\\n            {\\n\\n                return val1+val2\\n            })\\n        })\\n    \\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4010176,
                "title": "best-of-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    const [value1, value2] = await Promise.all([promise1, promise2]);\\n    return value1 + value2;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    const [value1, value2] = await Promise.all([promise1, promise2]);\\n    return value1 + value2;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4003618,
                "title": "one-liner-simple-solution",
                "content": "# Intuition\\n![2_promise.png](https://assets.leetcode.com/users/images/eaeebd88-c5b8-4004-9438-a880c93e7443_1693885543.3134801.png)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async (promise1, promise2) => await promise1 + await promise2;\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async (promise1, promise2) => await promise1 + await promise2;\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4002237,
                "title": "easy-and-simple-approach-using-await",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    let a = await promise1;\\n    let b = await promise2;\\n    return a+b;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    let a = await promise1;\\n    let b = await promise2;\\n    return a+b;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3999956,
                "title": "promise-summation-leveraging-async-await",
                "content": "# Intuition\\nGiven two promises promise1 and promise2, both of which will resolve with a number, the task is to return a new promise that resolves with the sum of the two numbers.\\n\\n# Approach\\nMy solution is implemented as an asynchronous function addTwoPromises that takes two promises promise1 and promise2 as input. I use await to handle the resolution of these promises and store their values in num1 and num2 respectively. Finally, I return the sum of num1 and num2.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of my solution is O(1), as it performs a fixed number of asynchronous operations regardless of the input values.\\n\\n\\n- Space complexity:\\nThe space complexity of my solution is O(1), as it only uses a constant amount of memory to store num1 and num2.\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nlet addTwoPromises = async function (promise1, promise2) {\\n    let num1, num2\\n    await promise1.then((res) => { num1 = res })\\n    await promise2.then((res) => { num2 = res })\\n    return num1 + num2\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nlet addTwoPromises = async function (promise1, promise2) {\\n    let num1, num2\\n    await promise1.then((res) => { num1 = res })\\n    await promise2.then((res) => { num2 = res })\\n    return num1 + num2\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3996844,
                "title": "get-promise-value-using-await",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n\\n    try{\\n      const promise1Val = await promise1;\\n      const promiseval2 = await promise2;\\n      return promise1Val + promiseval2;\\n    }catch(err){\\n\\n    }\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n\\n    try{\\n      const promise1Val = await promise1;\\n      const promiseval2 = await promise2;\\n      return promise1Val + promiseval2;\\n    }catch(err){\\n\\n    }\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3994723,
                "title": "typescript-solution",
                "content": "```\\nasync function addTwoPromises(promise1: Promise<number>, promise2: Promise<number>): Promise<number> {\\n    const result = await promise1 + await promise2;\\n    return result;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nasync function addTwoPromises(promise1: Promise<number>, promise2: Promise<number>): Promise<number> {\\n    const result = await promise1 + await promise2;\\n    return result;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3987878,
                "title": "a-simple-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async (promise1, promise2) => await promise1 + await promise2\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async (promise1, promise2) => await promise1 + await promise2\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3984648,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nasync function addTwoPromises(promise1: Promise<number>, promise2: Promise<number>): Promise<number> {\\n    return Promise.all([promise1, promise2]).then(([a, b]) => a + b);\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nasync function addTwoPromises(promise1: Promise<number>, promise2: Promise<number>): Promise<number> {\\n    return Promise.all([promise1, promise2]).then(([a, b]) => a + b);\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3982974,
                "title": "solution-with-promise-all",
                "content": "`Promise.all` is a static method of the Promise class that accepts and array of promiese as input, waits for all the promises to finish, and then returns the result of all the promises as an array.\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nconst addTwoPromises = async (promise1, promise2) => {\\n  return Promise.all([promise1, promise2]).then((values) => {\\n    let total = 0;\\n    values.forEach((value) => total += value);\\n    return total;\\n  })\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nconst addTwoPromises = async (promise1, promise2) => {\\n  return Promise.all([promise1, promise2]).then((values) => {\\n    let total = 0;\\n    values.forEach((value) => total += value);\\n    return total;\\n  })\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3978658,
                "title": "promise-all-and-then-add-result-0-and-result-1",
                "content": "# Intuition\\nAfter research, I found Promise.all to be a good way of handling multiple promises while returning its own promise.\\n\\n# Approach\\nSince we already know how many problems we are dealing with, we can just add the first and second indexes of the array.\\nIn real programming, if you don\\'t know the length of an array, reduce etc would be better, but if you can guarantee the length of the array, this solution is fine.\\n\\n# Complexity\\n- Time complexity:\\n55ms\\n\\n- Space complexity:\\n41.3MB\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    \\n    return Promise.all([promise1, promise2]).then((vals)=> {\\n        return vals[0] + vals[1]\\n    })\\n\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    \\n    return Promise.all([promise1, promise2]).then((vals)=> {\\n        return vals[0] + vals[1]\\n    })\\n\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3978647,
                "title": "js-ts-single-line-solution",
                "content": "# Code\\n```\\nasync function addTwoPromises(promise1: Promise<number> , promise2: Promise<number> ): Promise<number> {\\n    return (await Promise.all([promise1, promise2])).reduce((acc, settledValue) => acc + settledValue)\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nasync function addTwoPromises(promise1: Promise<number> , promise2: Promise<number> ): Promise<number> {\\n    return (await Promise.all([promise1, promise2])).reduce((acc, settledValue) => acc + settledValue)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3977289,
                "title": "beginner-friendly-simple-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    try{\\n        return await promise1 + await promise2;\\n    } catch(error){\\n        throw error;\\n    }\\n    \\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    try{\\n        return await promise1 + await promise2;\\n    } catch(error){\\n        throw error;\\n    }\\n    \\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3974088,
                "title": "one-liner",
                "content": "# Intuition\\n\\nSimple one-liner.\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nconst addTwoPromises = async (promise1, promise2) => (await Promise.all([promise1, promise2])).reduce((a, b) => a + b);\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nconst addTwoPromises = async (promise1, promise2) => (await Promise.all([promise1, promise2])).reduce((a, b) => a + b);\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3965471,
                "title": "promise-all",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    const [val1 , val2] = await Promise.all([promise1,promise2]);\\n    return val1+ val2;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    const [val1 , val2] = await Promise.all([promise1,promise2]);\\n    return val1+ val2;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3964148,
                "title": "one-line-solution-even-without-async-await-promise-all",
                "content": "# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = function(promise1, promise2) {\\n    return new Promise((resolve, reject) => {\\n        promise1.then((res1) => promise2.then((res2) => resolve(res1 + res2)))\\n    });\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = function(promise1, promise2) {\\n    return new Promise((resolve, reject) => {\\n        promise1.then((res1) => promise2.then((res2) => resolve(res1 + res2)))\\n    });\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3962727,
                "title": "using-promise-all",
                "content": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nconst addTwoPromises = async function(promise1, promise2) {\\n    const allResolved = await Promise.all([promise1, promise2])\\n    const sum = allResolved.reduce((acc, curr) => curr + acc, 0)\\n    return sum\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nconst addTwoPromises = async function(promise1, promise2) {\\n    const allResolved = await Promise.all([promise1, promise2])\\n    const sum = allResolved.reduce((acc, curr) => curr + acc, 0)\\n    return sum\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3962162,
                "title": "simple-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return Promise.all([promise1, promise2])\\n        .then(values => values[0] + values[1]);\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return Promise.all([promise1, promise2])\\n        .then(values => values[0] + values[1]);\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3957667,
                "title": "very-easy-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    const result = await Promise.all([promise1 , promise2])\\n    return result.reduce((a,b)=>a+b,0)\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    const result = await Promise.all([promise1 , promise2])\\n    return result.reduce((a,b)=>a+b,0)\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3955310,
                "title": "js-simple-2-lines-solution-without-built-in-functions",
                "content": "\\n\\n# Code\\n```\\n\\nvar addTwoPromises = async function(promise1, promise2) {\\n    let result = await promise1;\\n    return result + await promise2;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar addTwoPromises = async function(promise1, promise2) {\\n    let result = await promise1;\\n    return result + await promise2;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3952501,
                "title": "my-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    const a = await promise1\\n    const b = await promise2\\n    const sum = a+b\\n    return Promise.resolve(sum)\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    const a = await promise1\\n    const b = await promise2\\n    const sum = a+b\\n    return Promise.resolve(sum)\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3952292,
                "title": "javascript-easy-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    const result = await promise1;\\n    const result2 = await promise2;\\n\\n    const sum = result + result2\\n    return sum\\n    \\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    const result = await promise1;\\n    const result2 = await promise2;\\n\\n    const sum = result + result2\\n    return sum\\n    \\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3949848,
                "title": "javascript-oneliner-o-1",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return await promise1 +await promise2\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return await promise1 +await promise2\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3949208,
                "title": "easy-way-to-solve-promise-all",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n\\n    const [value1, value2] = await Promise.all([promise1, promise2]);\\n    \\n    return value1 + value2;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n\\n    const [value1, value2] = await Promise.all([promise1, promise2]);\\n    \\n    return value1 + value2;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3948713,
                "title": "simple-js-solution-just-await-te-promise",
                "content": "```\\nvar addTwoPromises = async function(promise1, promise2) {\\n    var val1 , val2;\\n    await promise1.then( (val) => val1 = val)\\n    await promise2.then( (val) => val2 = val)\\n    return val1 + val2;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar addTwoPromises = async function(promise1, promise2) {\\n    var val1 , val2;\\n    await promise1.then( (val) => val1 = val)\\n    await promise2.then( (val) => val2 = val)\\n    return val1 + val2;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3947988,
                "title": "easy-explanation-of-await-and-promise-all",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n   // Juat take a variable and use Promise.all will take all \\n          promise at once\\n    // await keyword will wait till both promise are fullfilled\\n\\n    var [res1, res2] = await Promise.all([promise1,promise2])\\n    return res1 + res2\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n   // Juat take a variable and use Promise.all will take all \\n          promise at once\\n    // await keyword will wait till both promise are fullfilled\\n\\n    var [res1, res2] = await Promise.all([promise1,promise2])\\n    return res1 + res2\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3942244,
                "title": "for-those-who-were-confused-just-like-me",
                "content": "the problem is clearly saying that we have to return a promise.But if I return a number then it also got accepted.I am not sure how in background leetcode is checking the answer for this problem.But the following solution is giving me mental satisfaction.\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    const a = await promise1 + await promise2;\\n    const ansPromise = new Promise(function(re){\\n        re(a);\\n    });\\n    return ansPromise;\\n    \\n};\\n\\n/**\\n\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    const a = await promise1 + await promise2;\\n    const ansPromise = new Promise(function(re){\\n        re(a);\\n    });\\n    return ansPromise;\\n    \\n};\\n\\n/**\\n\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3940682,
                "title": "simple-solution-using-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Simple take two promises and await promises and return sum of this promises.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    const ans = await promise1 + await promise2;\\n    return ans;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    const ans = await promise1 + await promise2;\\n    return ans;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3938296,
                "title": "typescript-shortest-solution",
                "content": "# Code\\n```\\nfunction addTwoPromises(promise1: Promise<number>, promise2: Promise<number>): Promise<number> {\\nreturn Promise.all( [ promise1, promise2 ] ).then( ( [ a, b ] ) => a + b )\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction addTwoPromises(promise1: Promise<number>, promise2: Promise<number>): Promise<number> {\\nreturn Promise.all( [ promise1, promise2 ] ).then( ( [ a, b ] ) => a + b )\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3935779,
                "title": "add-two-promises",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return Promise.all([promise1,promise2]).then(result=>{\\n        return result[0]+result[1];\\n    }\\n    )\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return Promise.all([promise1,promise2]).then(result=>{\\n        return result[0]+result[1];\\n    }\\n    )\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3935025,
                "title": "easy-solution-2-lines",
                "content": "# Approach\\n\\nApproach to solving this problem is to use Promise.all to wait for both promise1 and promise2 to resolve simultaneously once both promises have resolved we can extract their values and calculate their sum, sum is returned as a new promise\\n\\n \\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    const [value1, value2] = await Promise.all([promise1, promise2]);\\n    return value1 + value2;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    const [value1, value2] = await Promise.all([promise1, promise2]);\\n    return value1 + value2;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3934942,
                "title": "simple-async-and-await",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return await(promise1)+await(promise2)\\n    \\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return await(promise1)+await(promise2)\\n    \\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3932585,
                "title": "js-solution-using-promise-all",
                "content": "# Code\\n```\\nvar addTwoPromises = async function(promise1, promise2) {\\n    const [val1, val2] = await Promise.all([promise1, promise2])\\n    return val1 + val2\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar addTwoPromises = async function(promise1, promise2) {\\n    const [val1, val2] = await Promise.all([promise1, promise2])\\n    return val1 + val2\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3930443,
                "title": "javascript-solutions",
                "content": "# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\n\\n//First solution\\nvar addTwoPromises = async function (promise1, promise2) {\\n  const resPromise1 = await promise1\\n  const resPromise2 = await promise2\\n\\n  return new Promise((resolve) => resolve(resPromise1+ resPromise2))\\n}\\n\\n//Second solution\\nvar addTwoPromises = async function (promise1, promise2) {\\n  const [res1, res2] = await Promise.all([promise1, promise2]);\\n  \\n  return res1 + res2\\n}\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\n\\n//First solution\\nvar addTwoPromises = async function (promise1, promise2) {\\n  const resPromise1 = await promise1\\n  const resPromise2 = await promise2\\n\\n  return new Promise((resolve) => resolve(resPromise1+ resPromise2))\\n}\\n\\n//Second solution\\nvar addTwoPromises = async function (promise1, promise2) {\\n  const [res1, res2] = await Promise.all([promise1, promise2]);\\n  \\n  return res1 + res2\\n}\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3930378,
                "title": "js-solution-with-explanation",
                "content": "# Approach\\n1. We use promise.all to get all the promises and it takes an array of promises as an input and create a new promise\\n2. we start resolving the promise, since the input of promises was array it returns an array of resolved promises.\\n3. We use reduce method on the value (which is an array)\\n4. the function inside reduce takes total value and current value as argument.\\n5. Now the function will add our current val from value to acc and acc+val, 0, 0 here means the initial value.\\n\\n# Complexity\\n- Time complexity:\\n  O(1)\\n\\n- Space complexity:\\n  O(1)\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nconst addTwoPromises = async function(promise1, promise2){\\n   return Promise.all([promise1, promise2])\\n    .then(value => value.reduce((acc,val) => acc+val,0))\\n}\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nconst addTwoPromises = async function(promise1, promise2){\\n   return Promise.all([promise1, promise2])\\n    .then(value => value.reduce((acc,val) => acc+val,0))\\n}\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3929060,
                "title": "efficiently-adding-results-of-two-promises-using-promise-all-and-async-await",
                "content": "# Intuition\\nI wanted to create a function that efficiently adds the results of two promises. I knew that `Promise.all` can wait for both promises to resolve and thought about using it to simplify the addition process.\\n\\n# Approach\\nI wrote an arrow function `addTwoPromises` that takes two promises as input. Inside the function, I used `await` with `Promise.all` to wait for both promises to resolve simultaneously. Then, using destructuring, I obtained the resolved values and directly returned their sum.\\n\\n# Complexity\\n- Time complexity:\\n  The time complexity is determined by the resolution time of the input promises and the addition operation. Since the promises resolve concurrently, the overall time is roughly the time it takes for the slower of the two promises to resolve.\\n\\n- Space complexity:\\n  The space complexity is mainly influenced by the memory used for the resolved values of the promises and any internal memory required by the Promise implementation. This function\\'s space complexity remains relatively low, primarily depending on the size of the resolved values.\\n\\n\\n# Code\\n```\\nasync function addTwoPromises(promise1: Promise<number>, promise2: Promise<number>): Promise<number> {\\n\\tconst results = await Promise.all([promise1, promise2]);\\n    return results.reduce((acc, val) => acc + val, 0);\\n};\\n```\\n```\\nasync function addTwoPromises(promise1: Promise<number>, promise2: Promise<number>): Promise<number> {\\n\\treturn await Promise.all([promise1, promise2]).then(([a,b]) => a + b);\\n};\\n```\\n```\\nconst addTwoPromises = async(promise1: Promise<number>, promise2: Promise<number>): Promise<number> => \\n\\t await Promise.all([promise1, promise2]).then(([a,b]) => a + b);\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nasync function addTwoPromises(promise1: Promise<number>, promise2: Promise<number>): Promise<number> {\\n\\tconst results = await Promise.all([promise1, promise2]);\\n    return results.reduce((acc, val) => acc + val, 0);\\n};\\n```\n```\\nasync function addTwoPromises(promise1: Promise<number>, promise2: Promise<number>): Promise<number> {\\n\\treturn await Promise.all([promise1, promise2]).then(([a,b]) => a + b);\\n};\\n```\n```\\nconst addTwoPromises = async(promise1: Promise<number>, promise2: Promise<number>): Promise<number> => \\n\\t await Promise.all([promise1, promise2]).then(([a,b]) => a + b);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3927866,
                "title": "soln-in-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nconst addTwoPromises = async function(promise1, promise2) {\\n    return new Promise((resolve, reject) => {\\n       promise1.then((data) => {\\n           return data;\\n       }).then((response) => {\\n            promise2.then((data) => {\\n               resolve(data + response)\\n            })\\n       })\\n    })\\n};\\n\\nconsole.log(addTwoPromises);\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst addTwoPromises = async function(promise1, promise2) {\\n    return new Promise((resolve, reject) => {\\n       promise1.then((data) => {\\n           return data;\\n       }).then((response) => {\\n            promise2.then((data) => {\\n               resolve(data + response)\\n            })\\n       })\\n    })\\n};\\n\\nconsole.log(addTwoPromises);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3927148,
                "title": "return-promise-from-multiple-promises",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return Promise.all([promise1,promise2]).then(values=>{\\n        return values[0]+values[1]\\n    })\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return Promise.all([promise1,promise2]).then(values=>{\\n        return values[0]+values[1]\\n    })\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3926996,
                "title": "one-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    // const p1 = await promise1;\\n    // const p2 = await promise2;\\n    return await promise1 + await promise2;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    // const p1 = await promise1;\\n    // const p2 = await promise2;\\n    return await promise1 + await promise2;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3925042,
                "title": "javascript-runtime-beats-87-40-memory-beats-84-89",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return Promise.all([promise1,promise2]).then(values=>values[0]+values[1])\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return Promise.all([promise1,promise2]).then(values=>values[0]+values[1])\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3924576,
                "title": "one-liner-without-promise-all-without-then-5-words-only",
                "content": "# Code\\n```\\nasync function addTwoPromises(promise1: Promise<number>, promise2: Promise<number>): Promise<number> {\\n    return await promise1 + await promise2;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nasync function addTwoPromises(promise1: Promise<number>, promise2: Promise<number>): Promise<number> {\\n    return await promise1 + await promise2;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3921534,
                "title": "javascript-promise-all-reduce",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function (promise1, promise2) {\\n    return Promise.all([promise1, promise2])\\n        .then(value => value.reduce((acc, val) => acc + val, 0))\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function (promise1, promise2) {\\n    return Promise.all([promise1, promise2])\\n        .then(value => value.reduce((acc, val) => acc + val, 0))\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3921380,
                "title": "one-liner-solution-promise-all",
                "content": "# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return Promise.all([promise1, promise2]).then((val) => val.reduce((a, b) => a + b))\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return Promise.all([promise1, promise2]).then((val) => val.reduce((a, b) => a + b))\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3916785,
                "title": "easy-javascript-solution-beginner-friendly",
                "content": "> Vote Up if you like it\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    let a=await promise1\\n    let b=await promise2\\n    return new Promise((resolve)=>{\\n        resolve(a+b)\\n    })\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    let a=await promise1\\n    let b=await promise2\\n    return new Promise((resolve)=>{\\n        resolve(a+b)\\n    })\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3909114,
                "title": "javascript-solution-await-approach",
                "content": "```javascript\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    const a = await promise1;\\n    const b = await promise2;\\n    return a + b;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    const a = await promise1;\\n    const b = await promise2;\\n    return a + b;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3899719,
                "title": "time-required-48ms-beats-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBasically , javascript is synchronous(top down approach) in nature ,we use promise to perform asynchronous(wait for response) operation.\\nPromise is basically a JavaScript object which is responsible for handling all the asynchronous operations or activities like fetching data from the API and so on.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI have used 2 variable to store result returned from promise function ,which will return after awaiting after promise is resloved\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\n\\nvar addTwoPromises = async function(promise1, promise2) {\\n    result1 = await promise1\\n    result2 = await promise2\\n    return result1+result2\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\n\\nvar addTwoPromises = async function(promise1, promise2) {\\n    result1 = await promise1\\n    result2 = await promise2\\n    return result1+result2\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3898164,
                "title": "javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\nconst resolvePromise1 =await promise1; \\nconst resolvePromise2 =await promise2;\\n return new Promise((resolve)=>{\\n    resolve(resolvePromise1+resolvePromise2)\\n                           });;\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\nconst resolvePromise1 =await promise1; \\nconst resolvePromise2 =await promise2;\\n return new Promise((resolve)=>{\\n    resolve(resolvePromise1+resolvePromise2)\\n                           });;\\n};\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3891812,
                "title": "js-solution-runtime-61-ms-beats-75-74",
                "content": "# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nasync function addTwoPromises(promise1, promise2){\\n    return (await promise1) + (await promise2);\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nasync function addTwoPromises(promise1, promise2){\\n    return (await promise1) + (await promise2);\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3891396,
                "title": "best-solution-in-one-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n   return await Promise.all([promise1, promise2]).then(\\n    ([val1, val2]) => val1 + val2\\n  );\\n    \\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n   return await Promise.all([promise1, promise2]).then(\\n    ([val1, val2]) => val1 + val2\\n  );\\n    \\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3889695,
                "title": "very-short-one-liner-with-await",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI will just resolve one then resolve the other, and add the two together.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI remembered the `await` keyword so i used it to make this one-liner.\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return await promise1 + await promise2;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return await promise1 + await promise2;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3887941,
                "title": "js-code-very-simple-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNever thought this code works.\\n\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return await promise1 + await promise2;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return await promise1 + await promise2;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3885987,
                "title": "simple-solution-with-an-explanation",
                "content": "# explanation \\nOne possible way to solve this problem is to use the Promise.all method, which takes an array of promises and returns a new promise that resolves with an array of the resolved values of the input promises. Then, we can use the reduce method on the array to sum up the values and return the result.\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async (promise1, promise2) => {\\n    // Use Promise.all to get an array of resolved values from promise1 and promise2\\n  return Promise.all([promise1, promise2])\\n    .then(values => {\\n      // Use reduce to sum up the values in the array\\n      return values.reduce((a, b) => a + b, 0);\\n    });\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4 value1\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async (promise1, promise2) => {\\n    // Use Promise.all to get an array of resolved values from promise1 and promise2\\n  return Promise.all([promise1, promise2])\\n    .then(values => {\\n      // Use reduce to sum up the values in the array\\n      return values.reduce((a, b) => a + b, 0);\\n    });\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4 value1\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3876214,
                "title": "accepted-javascript",
                "content": "```\\nvar addTwoPromises = async function(promise1, promise2) {\\n    let p1 = await promise1;\\n    let p2 = await promise2;\\n    return p1 + p2;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar addTwoPromises = async function(promise1, promise2) {\\n    let p1 = await promise1;\\n    let p2 = await promise2;\\n    return p1 + p2;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3872987,
                "title": "easy-1-liner-without-promise-all-or-then-or-a-sum-variable",
                "content": "```\\n    Add the promises after awaiting for them.\\n```\\n\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return await promise1 + await promise2;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n    Add the promises after awaiting for them.\\n```\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return await promise1 + await promise2;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3872745,
                "title": "takes-a-memory-but-a-simple-code-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 6ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 42.52mb\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    let sum = 0;\\n    sum = sum + await (promise1.valueOf());\\n    sum = sum + await (promise2.valueOf());\\n    return sum.valueOf();\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    let sum = 0;\\n    sum = sum + await (promise1.valueOf());\\n    sum = sum + await (promise2.valueOf());\\n    return sum.valueOf();\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3870348,
                "title": "without-promise-all-can-also-solve",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function (promise1, promise2) {\\n    let sum = 0;\\n    sum += await (promise1.valueOf());\\n    sum += await (promise2.valueOf());\\n    return sum.valueOf();\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function (promise1, promise2) {\\n    let sum = 0;\\n    sum += await (promise1.valueOf());\\n    sum += await (promise2.valueOf());\\n    return sum.valueOf();\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3864902,
                "title": "handle-any-number-of-promise-parameters",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNeed to return a Promise, not a scalar value, which I initially overlooked.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHandling 2 promises works, but when it\\'s just as easy to handle any number of promises, let\\'s do that.\\n\\nExtensible code is always better.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\n\\n/**\\n * Runtime      Details\\n * 55ms         Beats 93.81% of users with JavaScript\\n */\\n\\n// Consume ANY number of parameters (via ...rest):\\n// i.e. convert all parameters passed into an array called `promises`:\\nvar addPromises = function(...promises)\\n    {\\n    // Pass array of all parameters given and use .reduce to iterate all:\\n    return Promise.all(promises).then( (values) =>\\n        values.reduce( (acc,val) => (acc + val))\\n        )\\n    };\\n\\n// This is even better than .apply():\\nconst addTwoPromises = addPromises;\\n// const addTwoPromises = (...args) => (addPromises.apply(null, args));\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\n\\n/**\\n * Runtime      Details\\n * 55ms         Beats 93.81% of users with JavaScript\\n */\\n\\n// Consume ANY number of parameters (via ...rest):\\n// i.e. convert all parameters passed into an array called `promises`:\\nvar addPromises = function(...promises)\\n    {\\n    // Pass array of all parameters given and use .reduce to iterate all:\\n    return Promise.all(promises).then( (values) =>\\n        values.reduce( (acc,val) => (acc + val))\\n        )\\n    };\\n\\n// This is even better than .apply():\\nconst addTwoPromises = addPromises;\\n// const addTwoPromises = (...args) => (addPromises.apply(null, args));\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3863093,
                "title": "1-line-beat-98-42-best-solution-with-minimal-code",
                "content": "# Intuition\\nThese approach emphasizes achieving **performance with minimal code**.\\n\\n1. Use of **Promise.all()** to increase the performance and handles the asynchronicity without the need for an async function..\\n2. Use of **Arrow funcitons** to minimize the code.\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = (promise1, promise2) => \\n    Promise.all([promise1, promise2]).then(([a, b]) => a + b);\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```\\n\\nPlease **Upvote** if you find helpful.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = (promise1, promise2) => \\n    Promise.all([promise1, promise2]).then(([a, b]) => a + b);\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3862327,
                "title": "javascript-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n      const [value1, value2] = await Promise.all([promise1, promise2]);\\n      return value1 + value2;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n      const [value1, value2] = await Promise.all([promise1, promise2]);\\n      return value1 + value2;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3862197,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe initial thoughts behind solving this problem involve combining the results of two promises and returning their sum. The task is to asynchronously handle promises and perform addition on their resolved values. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach to solving this problem is to utilize the Promise.all() method to concurrently await the resolution of two promises, promise1 and promise2. Once both promises are resolved, their values are stored in the value1 and value2 variables. Then, these values are added together, and the result is returned as a new promise.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this solution is determined by the time it takes to await the resolution of the two promises using Promise.all(), which is proportional to the longest time among the two promises. Therefore, the time complexity can be expressed as O(1), as it does not grow with the input size.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is constant as well. The variables value1 and value2 each store a single resolved promise value, and no additional data structures are used. Hence, the space complexity is O(1).\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    const [value1,value2] = await Promise.all([promise1, promise2]);\\n    return value1 + value2;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    const [value1,value2] = await Promise.all([promise1, promise2]);\\n    return value1 + value2;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3850701,
                "title": "simple-solution-which-beats-98-solutions-in-memory-time",
                "content": "# Intuition\\n Just wait for the promise to get resolve by using await keyword.\\n\\n# Approach\\n create sum variable & just wait for both the promise to resolve one by one & store those value to the sum variable.\\n\\n# Complexity\\n- Time complexity:\\n beats more than 98% solution.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n     let sum = 0;\\n     sum += await promise1;\\n     sum += await promise2;\\n     return sum;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n     let sum = 0;\\n     sum += await promise1;\\n     sum += await promise2;\\n     return sum;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3847924,
                "title": "solution-using-then-call-in-javascript",
                "content": "# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return new Promise(resolve => {\\n        let answer = 0;\\n        promise1.then((val1) => {\\n            answer += val1;\\n            promise2.then((val2) => {\\n                answer +=val2;\\n                resolve(answer);\\n            })\\n        });\\n    });\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return new Promise(resolve => {\\n        let answer = 0;\\n        promise1.then((val1) => {\\n            answer += val1;\\n            promise2.then((val2) => {\\n                answer +=val2;\\n                resolve(answer);\\n            })\\n        });\\n    });\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3834124,
                "title": "js-one-line",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async (promise1, promise2) => await promise1 + await promise2\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async (promise1, promise2) => await promise1 + await promise2\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3831122,
                "title": "simple",
                "content": "# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function (promise1, promise2) {\\n  return (await Promise.all([promise1, promise2])).reduce((a, c) => a + c);\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function (promise1, promise2) {\\n  return (await Promise.all([promise1, promise2])).reduce((a, c) => a + c);\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3830674,
                "title": "add-two-promises-easy-solution-javascript",
                "content": "**Please UpVote!**\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n   var Sum=0;\\n   Sum+=await promise1;\\n   Sum+=await promise2;\\n   return Promise.resolve(Sum)\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n   var Sum=0;\\n   Sum+=await promise1;\\n   Sum+=await promise2;\\n   return Promise.resolve(Sum)\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3828184,
                "title": "just-a-wait",
                "content": "# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return await promise1 + await promise2\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return await promise1 + await promise2\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3825721,
                "title": "two-promises",
                "content": "# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    results = await Promise.all([promise1,promise2])\\n    if(results) return results[0] + results[1]\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    results = await Promise.all([promise1,promise2])\\n    if(results) return results[0] + results[1]\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3816886,
                "title": "javascript-good-enough",
                "content": "``` JavaScript []\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return Promise.all([promise1,promise2]).then(x=>x.reduce((a,c)=>a+c));\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` JavaScript []\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return Promise.all([promise1,promise2]).then(x=>x.reduce((a,c)=>a+c));\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3815642,
                "title": "just-get-the-sum-of-two-awaits",
                "content": "# Complexity\\n- Time complexity:\\nO(2)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return await promise1 + await promise2\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return await promise1 + await promise2\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3813211,
                "title": "promise-addition-using-promise-all",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:  O(max(t1, t2)),\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return Promise.all([promise1, promise2]).then(([value1, value2])=>value1+value2)\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return Promise.all([promise1, promise2]).then(([value1, value2])=>value1+value2)\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3810962,
                "title": "javascript-one-line-solution",
                "content": "# Intuition\\nPromise.all to wait out for all promise reslutions\\n\\n# Approach\\n1. Resolve promises by usin Promise.all, wait for it using await.\\n2. Use Array.reduce() to sum up the output of Promise.all which is an array of numbers\\n3. return the whole statement in 1 line using fat arrow.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nconst addTwoPromises = async (promise1, promise2) => (await Promise.all([promise1,promise2])).reduce((t,v)=>t+v,0);\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nconst addTwoPromises = async (promise1, promise2) => (await Promise.all([promise1,promise2])).reduce((t,v)=>t+v,0);\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3810796,
                "title": "simple-and-clear",
                "content": "\\n# Code\\n```\\nconst addTwoPromises = (promise1, promise2) => {\\n  return promise1.then((num1) => {\\n    return promise2.then((num2) => (num1 + num2))\\n  }).catch((err) => {\\n    throw err\\n  })\\n}\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst addTwoPromises = (promise1, promise2) => {\\n  return promise1.then((num1) => {\\n    return promise2.then((num2) => (num1 + num2))\\n  }).catch((err) => {\\n    throw err\\n  })\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3809479,
                "title": "one-line-solution-promise-all",
                "content": "# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return Promise.all([promise1, promise2]).then(vals => vals[0] + vals[1])\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return Promise.all([promise1, promise2]).then(vals => vals[0] + vals[1])\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3807342,
                "title": "one-line-promise-all-reduce",
                "content": "# Code\\n```\\nasync function addTwoPromises(...promises: Promise<number>[]): Promise<number> {\\n    return (await Promise.all(promises)).reduce((a, b) => a + b)\\n};\\n\\n```\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nasync function addTwoPromises(...promises: Promise<number>[]): Promise<number> {\\n    return (await Promise.all(promises)).reduce((a, b) => a + b)\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3806913,
                "title": "one-liner-solution",
                "content": "# Intuition\\nBoth promises need to be resolved\\n\\n# Approach\\nSimply call await on them\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {   \\n   return await promise1 + await promise2;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {   \\n   return await promise1 + await promise2;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3806315,
                "title": "easy-js-solution",
                "content": "Destructure the response of both promises and return the sum; \\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    const [res1,res2] = await Promise.all([promise1,promise2])\\n    return res1 + res2;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    const [res1,res2] = await Promise.all([promise1,promise2])\\n    return res1 + res2;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3804433,
                "title": "typescript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nasync function addTwoPromises(promise1: Promise<number>, promise2: Promise<number>): Promise<number> {\\n   // const a: any =  promise1.then(value=>value);\\n   // const b: any =  promise2.then(value=>value);\\n   // return new Promise(a+b);\\n   return Promise.all([promise1, promise2]).then(values => values[0] + values[1]);\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nasync function addTwoPromises(promise1: Promise<number>, promise2: Promise<number>): Promise<number> {\\n   // const a: any =  promise1.then(value=>value);\\n   // const b: any =  promise2.then(value=>value);\\n   // return new Promise(a+b);\\n   return Promise.all([promise1, promise2]).then(values => values[0] + values[1]);\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3802252,
                "title": "add-two-promises",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n   return Promise.all([promise1, promise2])\\n    .then(([result1, result2]) => {\\n      return result1 + result2;\\n    })\\n    .catch((error) => {\\n      throw error;\\n    });  \\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n   return Promise.all([promise1, promise2])\\n    .then(([result1, result2]) => {\\n      return result1 + result2;\\n    })\\n    .catch((error) => {\\n      throw error;\\n    });  \\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3799539,
                "title": "simple-intuitive-only-async-await",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse Await to to resolve both promises and store them in a value, then\\nreturn the sum of both.\\n\\n\\n# Complexity\\n- Time complexity: O(1)\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    let value1 = await promise1;\\n    let value2 = await promise2;\\n\\n    return value1 + value2;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    let value1 = await promise1;\\n    let value2 = await promise2;\\n\\n    return value1 + value2;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3797481,
                "title": "promise-all-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nconst addTwoPromises = async function(promise1, promise2) {\\n    return Promise.all([promise1, promise2])\\n        .then(values => {\\n            const sum = values.reduce((total, value) => total + value, 0);\\n            return sum;\\n        })\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nconst addTwoPromises = async function(promise1, promise2) {\\n    return Promise.all([promise1, promise2])\\n        .then(values => {\\n            const sum = values.reduce((total, value) => total + value, 0);\\n            return sum;\\n        })\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3797230,
                "title": "easy-less-code-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return  Promise.all([promise1,promise2]).then(res=>res.reduce((add,curr)=>{\\n        add += curr;\\n        return add;\\n    },0))\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return  Promise.all([promise1,promise2]).then(res=>res.reduce((add,curr)=>{\\n        add += curr;\\n        return add;\\n    },0))\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3796617,
                "title": "straight-solution-without-using-promise-all",
                "content": "# Intuition\\nResolve the promises and finally return the result.\\n\\n# Approach\\nFirst resolve the first promise with **await** keyword and store the value in a variable. Then resolve the second promise in the same way and store the value in another variable. Finally return the sum of the two values.\\n\\n# Complexity\\n- Time complexity: O(m), where m is the longest time to resolve the two promises.\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    let val1, val2;\\n    \\n    await promise1.then(\\n        (val) => val1 = val\\n    );\\n\\n    await promise2.then(\\n        (val) => val2 = val\\n    );\\n\\n    return val1 + val2;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    let val1, val2;\\n    \\n    await promise1.then(\\n        (val) => val1 = val\\n    );\\n\\n    await promise2.then(\\n        (val) => val2 = val\\n    );\\n\\n    return val1 + val2;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3794391,
                "title": "simple-and-passes-but-is-it-bad",
                "content": "Can someone explain to me if/why this is not a good solution? Seems like the most straightforward and is passes all the tests, but nobody used this solution...\\n\\n# Code\\n```\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return (await promise1) + (await promise2);\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return (await promise1) + (await promise2);\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3786541,
                "title": "easy-solution-2723-add-two-promises-level-up-your-js-skills",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n  // Wait for both promises to resolve and retrieve their values\\n  const [value1, value2] = await Promise.all([promise1, promise2]);\\n\\n  // Return a new promise that resolves with the sum of the values\\n  return value1 + value2;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n  // Wait for both promises to resolve and retrieve their values\\n  const [value1, value2] = await Promise.all([promise1, promise2]);\\n\\n  // Return a new promise that resolves with the sum of the values\\n  return value1 + value2;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3784529,
                "title": "2723-add-two-promises",
                "content": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return await promise1 + await promise2;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return await promise1 + await promise2;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3782617,
                "title": "one-line-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n  return await promise1 + await promise2;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n  return await promise1 + await promise2;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3780797,
                "title": "add-two-promises-into-a-new-promise-in-javascript",
                "content": "# Intuition\\nAdding two promises and store them in a single promise.\\n\\n# Approach\\nDeclare an array.Use Promise.all() which returns an array of promises and store this array into the array we declared.After that add elements of that array to have some of both promises.\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    const [val1,val2] = await Promise.all([promise1,promise2])\\n\\n    return val1+val2\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    const [val1,val2] = await Promise.all([promise1,promise2])\\n\\n    return val1+val2\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3777813,
                "title": "super-easy-solution-beats-more-than-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOur final promise can onlhy be resolved after both individual promises are rresolved.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nstore the results of the promises in separate variables and return their sum .\\ndont forget to use await to handle the two promises asynchronously.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    const first = await promise1;\\n    const second = await promise2;\\n    return first+second;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    const first = await promise1;\\n    const second = await promise2;\\n    return first+second;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3777548,
                "title": "short-and-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return Promise.all([promise1, promise2])\\n    .then(([value1, value2]) => {\\n      const sum = value1 + value2;\\n      return sum;\\n    });\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return Promise.all([promise1, promise2])\\n    .then(([value1, value2]) => {\\n      const sum = value1 + value2;\\n      return sum;\\n    });\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3776353,
                "title": "promises-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return new Promise(async (resolve, reject) => {\\n        const [res1, res2] = await Promise.all([promise1, promise2]);\\n        const sum = res1 + res2;\\n        resolve(sum);\\n    });\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return new Promise(async (resolve, reject) => {\\n        const [res1, res2] = await Promise.all([promise1, promise2]);\\n        const sum = res1 + res2;\\n        resolve(sum);\\n    });\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3763697,
                "title": "perfect-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n\\n    const[val1, val2]= await Promise.all([promise1, promise2]);\\n\\n    return val1+val2;\\n    // return promise1.resolve+promise2.resolve;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n\\n    const[val1, val2]= await Promise.all([promise1, promise2]);\\n\\n    return val1+val2;\\n    // return promise1.resolve+promise2.resolve;\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3760123,
                "title": "promise-task-1",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return Promise.all([promise1, promise2])\\n    .then((value) => {\\n        return( value.reduce((value1,value2) => value1+value2, 0));\\n      \\n\\n    });\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n    return Promise.all([promise1, promise2])\\n    .then((value) => {\\n        return( value.reduce((value1,value2) => value1+value2, 0));\\n      \\n\\n    });\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3758016,
                "title": "2723-add-two-promises-umarbek-s-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n   const [value1, value2] = await Promise.all([promise1, promise2]);\\n   return value1 + value2;\\n\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Promise} promise1\\n * @param {Promise} promise2\\n * @return {Promise}\\n */\\nvar addTwoPromises = async function(promise1, promise2) {\\n   const [value1, value2] = await Promise.all([promise1, promise2]);\\n   return value1 + value2;\\n\\n};\\n\\n/**\\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\\n *   .then(console.log); // 4\\n */\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 2006892,
                "content": [
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "One possible way to solve this problem is to use the Promise.all method, which takes an array of promises and returns a new promise that resolves with an array of the resolved values of the input promises. Then, we can use the reduce method on the array to sum up the values and return the result.\\n"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var addTwoPromises = async function(promise1, promise2) {\\n    return Promise.all([promise1, promise2])\\n    .then((values) => {\\n        const sum = values.reduce((total, value) => total + value, 0);\\n        return sum;\\n    });\\n};"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "just use async and await.......... await both promise and then return answer"
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "why this code doesn't work:\n```\nvar addTwoPromises = async function (promise1, promise2) {\n  return new Promise((resolve, reject) => {\n    let count = 2\n    let res = 0\n    \n    [promise1, promise2].forEach(async promise => {\n        const subRes = await promise;\n        res += subRes;\n        count--;\n\n        if (count === 0) {\n          resolve(res)\n        }\n    })\n  })\n}\n```\n\ngetting that error: \"Runtime Error\n(node:21) Warning: Accessing non-existent property 'ListNode' of module exports inside circular dependency\n(Use `nodejs run --trace-warnings ...` to show where the warning was created)\n(node:21) Warning: Accessing non-existent property 'TreeNode' of module exports inside circular dependency\n(node:21) Warning: Accessing non-existent property 'NestedInteger' of module exports inside circular dependency\nLine 6 in solution.js\n    [promise1, promise2].forEach(async promise => {\n                         ^\nTypeError: Cannot read properties of undefined (reading 'forEach')\n    Line 6: Char 26 in solution.js\n    at new Promise (<anonymous>)\n    Line 2: Char 10 in solution.js (addTwoPromises)\n    Line 40: Char 19 in solution.js (next)\n    Line 61: Char 5 in solution.js (Object.<anonymous>)\n    Line 16: Char 8 in runner.js (Object.runner)\n    Line 17: Char 26 in solution.js (Object.<anonymous>)\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\n    at Module.load (node:internal/modules/cjs/loader:981:32)\""
                    },
                    {
                        "username": "andrisuvorov",
                        "content": "You are doing this wrong, this code is over complicated. \\nSuggestion: try storing these promises in a separate variables and await each variable. Then return variable1 + variable2 result."
                    },
                    {
                        "username": "pushpendra-sharma",
                        "content": "Avoid using async functions in array methods \\nhttps://stackoverflow.com/questions/37576685/using-async-await-with-a-foreach-loop\\nhttps://youtu.be/NaJI7RkSPx8?t=424"
                    },
                    {
                        "username": "harisalimughl65",
                        "content": "Making it more complex"
                    },
                    {
                        "username": "djslim",
                        "content": "you need semicolon after `let res = 0` due to automatic semicolon insertion (ASI) edge case"
                    }
                ]
            },
            {
                "id": 1951044,
                "content": [
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "One possible way to solve this problem is to use the Promise.all method, which takes an array of promises and returns a new promise that resolves with an array of the resolved values of the input promises. Then, we can use the reduce method on the array to sum up the values and return the result.\\n"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var addTwoPromises = async function(promise1, promise2) {\\n    return Promise.all([promise1, promise2])\\n    .then((values) => {\\n        const sum = values.reduce((total, value) => total + value, 0);\\n        return sum;\\n    });\\n};"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "just use async and await.......... await both promise and then return answer"
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "why this code doesn't work:\n```\nvar addTwoPromises = async function (promise1, promise2) {\n  return new Promise((resolve, reject) => {\n    let count = 2\n    let res = 0\n    \n    [promise1, promise2].forEach(async promise => {\n        const subRes = await promise;\n        res += subRes;\n        count--;\n\n        if (count === 0) {\n          resolve(res)\n        }\n    })\n  })\n}\n```\n\ngetting that error: \"Runtime Error\n(node:21) Warning: Accessing non-existent property 'ListNode' of module exports inside circular dependency\n(Use `nodejs run --trace-warnings ...` to show where the warning was created)\n(node:21) Warning: Accessing non-existent property 'TreeNode' of module exports inside circular dependency\n(node:21) Warning: Accessing non-existent property 'NestedInteger' of module exports inside circular dependency\nLine 6 in solution.js\n    [promise1, promise2].forEach(async promise => {\n                         ^\nTypeError: Cannot read properties of undefined (reading 'forEach')\n    Line 6: Char 26 in solution.js\n    at new Promise (<anonymous>)\n    Line 2: Char 10 in solution.js (addTwoPromises)\n    Line 40: Char 19 in solution.js (next)\n    Line 61: Char 5 in solution.js (Object.<anonymous>)\n    Line 16: Char 8 in runner.js (Object.runner)\n    Line 17: Char 26 in solution.js (Object.<anonymous>)\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\n    at Module.load (node:internal/modules/cjs/loader:981:32)\""
                    },
                    {
                        "username": "andrisuvorov",
                        "content": "You are doing this wrong, this code is over complicated. \\nSuggestion: try storing these promises in a separate variables and await each variable. Then return variable1 + variable2 result."
                    },
                    {
                        "username": "pushpendra-sharma",
                        "content": "Avoid using async functions in array methods \\nhttps://stackoverflow.com/questions/37576685/using-async-await-with-a-foreach-loop\\nhttps://youtu.be/NaJI7RkSPx8?t=424"
                    },
                    {
                        "username": "harisalimughl65",
                        "content": "Making it more complex"
                    },
                    {
                        "username": "djslim",
                        "content": "you need semicolon after `let res = 0` due to automatic semicolon insertion (ASI) edge case"
                    }
                ]
            },
            {
                "id": 2074378,
                "content": [
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "One possible way to solve this problem is to use the Promise.all method, which takes an array of promises and returns a new promise that resolves with an array of the resolved values of the input promises. Then, we can use the reduce method on the array to sum up the values and return the result.\\n"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var addTwoPromises = async function(promise1, promise2) {\\n    return Promise.all([promise1, promise2])\\n    .then((values) => {\\n        const sum = values.reduce((total, value) => total + value, 0);\\n        return sum;\\n    });\\n};"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "just use async and await.......... await both promise and then return answer"
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "why this code doesn't work:\n```\nvar addTwoPromises = async function (promise1, promise2) {\n  return new Promise((resolve, reject) => {\n    let count = 2\n    let res = 0\n    \n    [promise1, promise2].forEach(async promise => {\n        const subRes = await promise;\n        res += subRes;\n        count--;\n\n        if (count === 0) {\n          resolve(res)\n        }\n    })\n  })\n}\n```\n\ngetting that error: \"Runtime Error\n(node:21) Warning: Accessing non-existent property 'ListNode' of module exports inside circular dependency\n(Use `nodejs run --trace-warnings ...` to show where the warning was created)\n(node:21) Warning: Accessing non-existent property 'TreeNode' of module exports inside circular dependency\n(node:21) Warning: Accessing non-existent property 'NestedInteger' of module exports inside circular dependency\nLine 6 in solution.js\n    [promise1, promise2].forEach(async promise => {\n                         ^\nTypeError: Cannot read properties of undefined (reading 'forEach')\n    Line 6: Char 26 in solution.js\n    at new Promise (<anonymous>)\n    Line 2: Char 10 in solution.js (addTwoPromises)\n    Line 40: Char 19 in solution.js (next)\n    Line 61: Char 5 in solution.js (Object.<anonymous>)\n    Line 16: Char 8 in runner.js (Object.runner)\n    Line 17: Char 26 in solution.js (Object.<anonymous>)\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\n    at Module.load (node:internal/modules/cjs/loader:981:32)\""
                    },
                    {
                        "username": "andrisuvorov",
                        "content": "You are doing this wrong, this code is over complicated. \\nSuggestion: try storing these promises in a separate variables and await each variable. Then return variable1 + variable2 result."
                    },
                    {
                        "username": "pushpendra-sharma",
                        "content": "Avoid using async functions in array methods \\nhttps://stackoverflow.com/questions/37576685/using-async-await-with-a-foreach-loop\\nhttps://youtu.be/NaJI7RkSPx8?t=424"
                    },
                    {
                        "username": "harisalimughl65",
                        "content": "Making it more complex"
                    },
                    {
                        "username": "djslim",
                        "content": "you need semicolon after `let res = 0` due to automatic semicolon insertion (ASI) edge case"
                    }
                ]
            },
            {
                "id": 1925950,
                "content": [
                    {
                        "username": "Gamal_mohamed_2001",
                        "content": "One possible way to solve this problem is to use the Promise.all method, which takes an array of promises and returns a new promise that resolves with an array of the resolved values of the input promises. Then, we can use the reduce method on the array to sum up the values and return the result.\\n"
                    },
                    {
                        "username": "ahimCode",
                        "content": "var addTwoPromises = async function(promise1, promise2) {\\n    return Promise.all([promise1, promise2])\\n    .then((values) => {\\n        const sum = values.reduce((total, value) => total + value, 0);\\n        return sum;\\n    });\\n};"
                    },
                    {
                        "username": "BrownCarter",
                        "content": "just use async and await.......... await both promise and then return answer"
                    },
                    {
                        "username": "kodyczasupl1",
                        "content": "why this code doesn't work:\n```\nvar addTwoPromises = async function (promise1, promise2) {\n  return new Promise((resolve, reject) => {\n    let count = 2\n    let res = 0\n    \n    [promise1, promise2].forEach(async promise => {\n        const subRes = await promise;\n        res += subRes;\n        count--;\n\n        if (count === 0) {\n          resolve(res)\n        }\n    })\n  })\n}\n```\n\ngetting that error: \"Runtime Error\n(node:21) Warning: Accessing non-existent property 'ListNode' of module exports inside circular dependency\n(Use `nodejs run --trace-warnings ...` to show where the warning was created)\n(node:21) Warning: Accessing non-existent property 'TreeNode' of module exports inside circular dependency\n(node:21) Warning: Accessing non-existent property 'NestedInteger' of module exports inside circular dependency\nLine 6 in solution.js\n    [promise1, promise2].forEach(async promise => {\n                         ^\nTypeError: Cannot read properties of undefined (reading 'forEach')\n    Line 6: Char 26 in solution.js\n    at new Promise (<anonymous>)\n    Line 2: Char 10 in solution.js (addTwoPromises)\n    Line 40: Char 19 in solution.js (next)\n    Line 61: Char 5 in solution.js (Object.<anonymous>)\n    Line 16: Char 8 in runner.js (Object.runner)\n    Line 17: Char 26 in solution.js (Object.<anonymous>)\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\n    at Module.load (node:internal/modules/cjs/loader:981:32)\""
                    },
                    {
                        "username": "andrisuvorov",
                        "content": "You are doing this wrong, this code is over complicated. \\nSuggestion: try storing these promises in a separate variables and await each variable. Then return variable1 + variable2 result."
                    },
                    {
                        "username": "pushpendra-sharma",
                        "content": "Avoid using async functions in array methods \\nhttps://stackoverflow.com/questions/37576685/using-async-await-with-a-foreach-loop\\nhttps://youtu.be/NaJI7RkSPx8?t=424"
                    },
                    {
                        "username": "harisalimughl65",
                        "content": "Making it more complex"
                    },
                    {
                        "username": "djslim",
                        "content": "you need semicolon after `let res = 0` due to automatic semicolon insertion (ASI) edge case"
                    }
                ]
            }
        ]
    },
    {
        "title": "Neither Minimum nor Maximum",
        "question_content": "<p>Given an integer array <code>nums</code> containing <strong>distinct</strong> <strong>positive</strong> integers, find and return <strong>any</strong> number from the array that is neither the <strong>minimum</strong> nor the <strong>maximum</strong> value in the array, or <strong><code>-1</code></strong> if there is no such number.</p>\n\n<p>Return <em>the selected integer.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,2,1,4]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> In this example, the minimum value is 1 and the maximum value is 4. Therefore, either 2 or 3 can be valid answers.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2]\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> Since there is no number in nums that is neither the maximum nor the minimum, we cannot select a number that satisfies the given condition. Therefore, there is no answer.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,1,3]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> Since 2 is neither the maximum nor the minimum value in nums, it is the only valid answer. \n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 100</code></li>\n\t<li>All values in <code>nums</code> are distinct</li>\n</ul>\n",
        "solutions": [
            {
                "id": 3624365,
                "title": "o-1-solution-2-methods-single-pass-solution-o-n-no-functions-used",
                "content": "## I have attached the code first and then the intuition behind the approach. \\n## => O(1) solution\\n\\n#### This uses the property that is given in the question that all the numbers are distinct.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        if (nums.size() < 3)\\n            return -1;\\n\\n        int a = min(nums[0],nums[1]);\\n        int b = max(nums[0],nums[1]);\\n        int c = nums[2];\\n\\n        if(c<b && c>a) return c; // since c cannot be the maximum nor the minimum now\\n        if(c<a) return a; //since a cannot be the minimum as it is bigger than one number and smaller than b\\n        if(c>b) return b; //since b cannot be minimum as it is bigger than a and cannot be max as it is < b\\n\\n        return -1;\\n    }\\n};\\n\\n```\\n## => O(n) Single pass solution\\n\\n#### If all the numbers were not distinct and you want the solution in single pass then this is the solution: \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        if(nums.size()<=2) return -1;\\n        int minValue = nums[0];\\n        int maxValue = nums[0];\\n        int selectedNumber = -1;\\n\\n        for (int i = 1; i < nums.size(); ++i) {\\n            if (nums[i] < minValue) {\\n                selectedNumber = minValue;\\n                minValue = nums[i];\\n            } else if (nums[i] > maxValue) {\\n                selectedNumber = maxValue;\\n                maxValue = nums[i];\\n            } else {\\n                return nums[i];\\n            }\\n        }\\n\\n        return selectedNumber;\\n    }\\n};\\n\\n```\\n\\n## Approach and Intuition\\n\\nThe approach I used in the code is as follows:\\n\\n1. If the size of the input array `nums` is less than or equal to 2, it means there are not enough elements in the array to find a number that satisfies the condition. In such cases, the function directly returns `-1`.\\n\\n2. Initialize `minValue` and `maxValue` variables with the first element of the `nums` array. These variables keep track of the minimum and maximum values encountered so far.\\n\\n3. Initialize `selectedNumber` variable with `-1`, which will hold the selected number that is not the minimum nor the maximum.\\n\\n4. Iterate through the `nums` array starting from the second element (`i = 1`) using a for loop.\\n\\n5. Compare the current element `nums[i]` with the current `minValue` and `maxValue`.\\n\\n6. If `nums[i]` is smaller than the current `minValue`, update `selectedNumber` with the previous `minValue`, and update `minValue` with `nums[i]`. This ensures that we have a new minimum value and also keep track of the previous minimum as the selected number.\\n\\n7. If `nums[i]` is larger than the current `maxValue`, update `selectedNumber` with the previous `maxValue`, and update `maxValue` with `nums[i]`. This ensures that we have a new maximum value and also keep track of the previous maximum as the selected number.\\n\\n8. If `nums[i]` is between `minValue` and `maxValue`, update `selectedNumber` with `nums[i]`. This means we have found a number that is neither the minimum nor the maximum.\\n\\n9. Finally, return the `selectedNumber` as the result.\\n\\nThe intuition behind this approach is to traverse the array once and keep track of the minimum, maximum, and a selected number that satisfies the given condition. By comparing the elements with the current minimum and maximum values, we update these values accordingly. At the end of the traversal, the selected number will be the desired result.\\n\\nThe check for the size of the array at the beginning handles cases where the array has fewer than 3 elements. In such cases, there cannot be a number that satisfies the condition, so the function immediately returns -1.\\n\\n\\n## PLEASE UPVOTE IF THIS HELPED! \\u2714",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        if (nums.size() < 3)\\n            return -1;\\n\\n        int a = min(nums[0],nums[1]);\\n        int b = max(nums[0],nums[1]);\\n        int c = nums[2];\\n\\n        if(c<b && c>a) return c; // since c cannot be the maximum nor the minimum now\\n        if(c<a) return a; //since a cannot be the minimum as it is bigger than one number and smaller than b\\n        if(c>b) return b; //since b cannot be minimum as it is bigger than a and cannot be max as it is < b\\n\\n        return -1;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        if(nums.size()<=2) return -1;\\n        int minValue = nums[0];\\n        int maxValue = nums[0];\\n        int selectedNumber = -1;\\n\\n        for (int i = 1; i < nums.size(); ++i) {\\n            if (nums[i] < minValue) {\\n                selectedNumber = minValue;\\n                minValue = nums[i];\\n            } else if (nums[i] > maxValue) {\\n                selectedNumber = maxValue;\\n                maxValue = nums[i];\\n            } else {\\n                return nums[i];\\n            }\\n        }\\n\\n        return selectedNumber;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623982,
                "title": "java-c-python-3-o-1-solutions-3-lines-mid-of-3",
                "content": "# **Explanation**\\nReturn the mid of the first 3 elements.\\nPlease upvote for your favorite one.\\n<br>\\n\\n# **Complexity**\\nTime `O(1)`\\nSpace `O(1)`\\n<br>\\n\\n**Java**\\n```java\\n    public int findNonMinOrMax(int[] A) {\\n        if (A.length < 3)\\n            return -1;\\n        int mx = Math.max(A[0], Math.max(A[1], A[2])), mn = Math.min(A[0], Math.min(A[1], A[2]));\\n        for (int i = 0; i < 3; ++i)\\n            if (mn < A[i] && A[i] < mx)\\n                return A[i];\\n        return -1;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int findNonMinOrMax(vector<int>& A) {\\n        if (A.size() < 3)\\n            return -1;\\n        int mx = max(A[0], max(A[1], A[2])), mn = min(A[0], min(A[1], A[2]));\\n        for (int i = 0; i < 3; ++i)\\n            if (mn < A[i] && A[i] < mx)\\n                return A[i];\\n        return -1;\\n    }\\n```\\n<br>\\n\\n# **Solution 2: Minus max and min**\\n\\n**Java**\\n```java\\n    public int findNonMinOrMax(int[] A) {\\n        if (A.length < 3) return -1;\\n        int mx = Math.max(A[0], Math.max(A[1], A[2])), mn = Math.min(A[0], Math.min(A[1], A[2]));\\n        return A[0] + A[1] + A[2] - mn - mx;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int findNonMinOrMax(vector<int>& A) {\\n        if (A.size() < 3) return -1;\\n        int mx = max(A[0], max(A[1], A[2])), mn = min(A[0], min(A[1], A[2]));\\n        return A[0] + A[1] + A[2] - mn - mx;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def findNonMinOrMax(self, A):\\n        return -1 if len(A) < 3 else sum(A[:3]) - min(A[:3]) - max(A[:3])\\n```\\n<br>\\n\\n# **Solution 3: Sort First 3 elements**\\n\\n**Java**\\nInput changed\\n```java\\n    public int findNonMinOrMax(int[] A) {\\n        if (A.length < 3) return -1;\\n        Arrays.sort(A, 0, 3);\\n        return A[1];\\n    }\\n```\\n\\n**C++**\\nInput changed\\n```cpp\\n    int findNonMinOrMax(vector<int>& A) {\\n        if (A.size() < 3) return -1;\\n        sort(A.begin(), A.begin() + 3);\\n        return A[1];\\n    }\\n```\\n\\n**Python**\\n```py\\n    def findNonMinOrMax(self, A):\\n        return -1 if len(A) < 3 else sorted(A[:3])[1] \\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int findNonMinOrMax(int[] A) {\\n        if (A.length < 3)\\n            return -1;\\n        int mx = Math.max(A[0], Math.max(A[1], A[2])), mn = Math.min(A[0], Math.min(A[1], A[2]));\\n        for (int i = 0; i < 3; ++i)\\n            if (mn < A[i] && A[i] < mx)\\n                return A[i];\\n        return -1;\\n    }\\n```\n```cpp\\n    int findNonMinOrMax(vector<int>& A) {\\n        if (A.size() < 3)\\n            return -1;\\n        int mx = max(A[0], max(A[1], A[2])), mn = min(A[0], min(A[1], A[2]));\\n        for (int i = 0; i < 3; ++i)\\n            if (mn < A[i] && A[i] < mx)\\n                return A[i];\\n        return -1;\\n    }\\n```\n```java\\n    public int findNonMinOrMax(int[] A) {\\n        if (A.length < 3) return -1;\\n        int mx = Math.max(A[0], Math.max(A[1], A[2])), mn = Math.min(A[0], Math.min(A[1], A[2]));\\n        return A[0] + A[1] + A[2] - mn - mx;\\n    }\\n```\n```cpp\\n    int findNonMinOrMax(vector<int>& A) {\\n        if (A.size() < 3) return -1;\\n        int mx = max(A[0], max(A[1], A[2])), mn = min(A[0], min(A[1], A[2]));\\n        return A[0] + A[1] + A[2] - mn - mx;\\n    }\\n```\n```py\\n    def findNonMinOrMax(self, A):\\n        return -1 if len(A) < 3 else sum(A[:3]) - min(A[:3]) - max(A[:3])\\n```\n```java\\n    public int findNonMinOrMax(int[] A) {\\n        if (A.length < 3) return -1;\\n        Arrays.sort(A, 0, 3);\\n        return A[1];\\n    }\\n```\n```cpp\\n    int findNonMinOrMax(vector<int>& A) {\\n        if (A.size() < 3) return -1;\\n        sort(A.begin(), A.begin() + 3);\\n        return A[1];\\n    }\\n```\n```py\\n    def findNonMinOrMax(self, A):\\n        return -1 if len(A) < 3 else sorted(A[:3])[1] \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3625049,
                "title": "python-3-2-linear-approaches-without-sorting",
                "content": "### Straightforward approach:\\n```python3 []\\nclass Solution:\\n    def findNonMinOrMax(self, nums: List[int]) -> int:\\n        minVal, maxVal = min(nums), max(nums)\\n        for n in nums:\\n            if n != minVal and n != maxVal:\\n                return n\\n        return -1\\n\\n```\\n### Approach similar to [414. Third Maximum Number](https://leetcode.com/problems/third-maximum-number/description/) but need to return any middle number:\\n```python3 []\\nclass Solution:\\n    def findNonMinOrMax(self, nums: List[int]) -> int:\\n        a = b = c = 0\\n        for n in nums:\\n            if n > a: a, b, c = n, a, b\\n            elif n > b: b, c = n, b\\n            elif n > c: c = n\\n            if a > b > c and c != 0:\\n                return b\\n        \\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def findNonMinOrMax(self, nums: List[int]) -> int:\\n        minVal, maxVal = min(nums), max(nums)\\n        for n in nums:\\n            if n != minVal and n != maxVal:\\n                return n\\n        return -1\\n\\n```\n```python3 []\\nclass Solution:\\n    def findNonMinOrMax(self, nums: List[int]) -> int:\\n        a = b = c = 0\\n        for n in nums:\\n            if n > a: a, b, c = n, a, b\\n            elif n > b: b, c = n, b\\n            elif n > c: c = n\\n            if a > b > c and c != 0:\\n                return b\\n        \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624462,
                "title": "simplest-o-1-solution-c",
                "content": "# Intuition & Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n***Since we need to return any element that is neither a minimum nor a maximum and that the given list is of distinct numers, all we need is to find such element among the first 3 numbers in the array***\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1) - as we only look into the first 3 elements regardless of the size of the array\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) - as we use constant memory\\n\\n## Please upvote if you like the approach\\n\\n# Code\\n```\\npublic class Solution {\\n    public int FindNonMinOrMax(int[] nums) {\\n        if (nums.Length <= 2)\\n            return -1;\\n        \\n        int min = Math.Min(nums[0], nums[1]);\\n        int max = Math.Max(nums[0], nums[1]);\\n\\n        if (nums[2] > min && nums[2] < max)\\n            return nums[2];\\n        else if (nums[2] < min)\\n            return min;\\n        else\\n            return max;\\n    }\\n}\\n```\\n\\n## Please upvote if you like the approach",
                "solutionTags": [
                    "C#",
                    "Math"
                ],
                "code": "```\\npublic class Solution {\\n    public int FindNonMinOrMax(int[] nums) {\\n        if (nums.Length <= 2)\\n            return -1;\\n        \\n        int min = Math.Min(nums[0], nums[1]);\\n        int max = Math.Max(nums[0], nums[1]);\\n\\n        if (nums[2] > min && nums[2] < max)\\n            return nums[2];\\n        else if (nums[2] < min)\\n            return min;\\n        else\\n            return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623827,
                "title": "using-sort-c",
                "content": "# if this code helpful for you, please upvote that\\'s more help full for me.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        for(auto &i: nums){\\n            if((i != nums[0]) && (i != nums[nums.size()-1]))return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        for(auto &i: nums){\\n            if((i != nums[0]) && (i != nums[nums.size()-1]))return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623964,
                "title": "explained-simple-and-clear-python3-code",
                "content": "# Intuition\\nThe problem asks us to find a number from the given array that is neither the minimum nor the maximum value. This means that we need to exclude the smallest and largest values from consideration and return any other number. To solve this, we can sort the array and select the second largest element, as it will not be the maximum value.\\n\\n\\n# Approach\\nThe provided solution suggests using the sorted() function to sort the given array in ascending order. Since the array contains distinct positive integers, sorting the array will arrange the numbers in increasing order. If the length of the array is less than or equal to 2, we return -1, as there would be no number that satisfies the given condition. Otherwise, we return the second largest element, which can be accessed using the [-2] index.\\n\\n\\n# Complexity\\n- Time complexity:\\nTime complexity: The time complexity of the solution depends on the sorting algorithm used. If we consider the default sorting algorithm used by Python\\'s sorted() function, the time complexity is O(n log n), where n is the length of the input array nums. Sorting the array is the most time-consuming step in this approach.\\n\\n\\n- Space complexity:\\nSpace complexity: The space complexity is O(1) since we are not using any additional data structures that grow with the size of the input. The sorting operation is performed in-place, so it does not require additional space proportional to the input size.\\n\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def findNonMinOrMax(self, nums: List[int]) -> int:\\n        if len(nums) <= 2:\\n            return -1\\n        else:\\n            return sorted(nums)[-2] \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findNonMinOrMax(self, nums: List[int]) -> int:\\n        if len(nums) <= 2:\\n            return -1\\n        else:\\n            return sorted(nums)[-2] \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623927,
                "title": "simplest-python-solution-with-bonus-1-liner",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def findNonMinOrMax(self, nums: List[int]) -> int:\\n        if len(nums) <= 2:\\n            return -1\\n        else:\\n            return sorted(nums)[-2] \\n```\\nwhich can be put in 1 line like:\\n```\\nclass Solution:\\n    def findNonMinOrMax(self, nums: List[int]) -> int:\\n        return -1 if len(nums) <= 2 else sorted(nums)[-2]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findNonMinOrMax(self, nums: List[int]) -> int:\\n        if len(nums) <= 2:\\n            return -1\\n        else:\\n            return sorted(nums)[-2] \\n```\n```\\nclass Solution:\\n    def findNonMinOrMax(self, nums: List[int]) -> int:\\n        return -1 if len(nums) <= 2 else sorted(nums)[-2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623799,
                "title": "java-easy-solution-10-lines",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int findNonMinOrMax(int[] nums) {\\n    var min = Integer.MAX_VALUE;\\n    var max = Integer.MIN_VALUE;\\n    \\n    for (var n : nums) {\\n      min = Math.min(min, n);\\n      max = Math.max(max, n);\\n    }\\n    for (var n : nums)\\n      if (n != min && n != max)\\n        return n;\\n    \\n    return -1;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n  public int findNonMinOrMax(int[] nums) {\\n    var min = Integer.MAX_VALUE;\\n    var max = Integer.MIN_VALUE;\\n    \\n    for (var n : nums) {\\n      min = Math.min(min, n);\\n      max = Math.max(max, n);\\n    }\\n    for (var n : nums)\\n      if (n != min && n != max)\\n        return n;\\n    \\n    return -1;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624067,
                "title": "3-line-solution-java",
                "content": "\\n     class Solution {\\n          public int findNonMinOrMax(int[] nums) {\\n             Arrays.sort(nums);\\n             int mid=nums.length/2;\\n             return mid==nums.length-1 || mid==0 ? -1 : nums[mid];\\n             }   }",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "class Solution {\\n          public int findNonMinOrMax(int[] nums) {\\n             Arrays.sort(nums);\\n             int mid=nums.length/2;\\n             return mid==nums.length-1 || mid==0 ? -1 : nums[mid];\\n             }",
                "codeTag": "Java"
            },
            {
                "id": 3623969,
                "title": "3-line-solution-easy-java",
                "content": "```\\npublic static int findNonMinOrMax(int[] nums) {\\n        Arrays.sort(nums);\\n        if(nums.length<=2) return -1;\\n          return nums[1];\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic static int findNonMinOrMax(int[] nums) {\\n        Arrays.sort(nums);\\n        if(nums.length<=2) return -1;\\n          return nums[1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3690279,
                "title": "easy-python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def findNonMinOrMax(self, nums: List[int]) -> int:\\n        mi=min(nums)\\n        ma=max(nums)\\n        c=0\\n        for i in set(nums):\\n            if i!=ma and i!=mi:\\n                return i\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findNonMinOrMax(self, nums: List[int]) -> int:\\n        mi=min(nums)\\n        ma=max(nums)\\n        c=0\\n        for i in set(nums):\\n            if i!=ma and i!=mi:\\n                return i\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624326,
                "title": "o-n-easy-to-understand-c",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g.  -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        int mx = *max_element(nums.begin(),nums.end());\\n        int mn = *min_element(nums.begin(),nums.end());\\n        for(auto num: nums){\\n            if(num!=mx && num!=mn) return num;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        int mx = *max_element(nums.begin(),nums.end());\\n        int mn = *min_element(nums.begin(),nums.end());\\n        for(auto num: nums){\\n            if(num!=mx && num!=mn) return num;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3783868,
                "title": "java-in-constant-time-and-space",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nReturn the mid of the first 3 elements.\\nPlease upvote !\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        if(nums.length <= 2) return - 1;\\n        Arrays.sort(nums, 0, 3);\\n        return nums[1];\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        if(nums.length <= 2) return - 1;\\n        Arrays.sort(nums, 0, 3);\\n        return nums[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3693777,
                "title": "beats-64-37-one-line-solution-js",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findNonMinOrMax = function(nums) {\\n    return nums.length < 3 ? -1 : nums.sort((a, b) => a - b)[1]\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findNonMinOrMax = function(nums) {\\n    return nums.length < 3 ? -1 : nums.sort((a, b) => a - b)[1]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3687765,
                "title": "2-line-solution-in-cpp-with-hints-and-explanation-using-basic-arrays-no-recursion-hashing",
                "content": "# Hint 1 \\n- Sort \\n\\n\\n# Approach\\n- Just sort the array.\\n- Hence the minimum is the first element and maximum is the last element.\\n- Make a check if the size of the arrays is less than or equal to 2, return -1.\\n- Else return the middle element of the array.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        if(nums.size()<=2) return -1;\\n        sort(nums.begin(),nums.end());\\n        return nums[nums.size()/2];\\n    }\\n};\\n```\\n# Please upvote!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        if(nums.size()<=2) return -1;\\n        sort(nums.begin(),nums.end());\\n        return nums[nums.size()/2];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3671000,
                "title": "fast-91-approach-o-1",
                "content": "# Intuition\\nYou don\\'t have to find the max or min. All max, min, middle numbers can be found inside three first elements. \\n\\n# Code\\n```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        if(nums.length<3) return -1;\\n    \\n        int a = nums[0];\\n        int b = nums[1];\\n        int c = nums[2];\\n\\n        if ((a > b && a < c) || (a < b && a > c)) {\\n            return a;\\n        } else if ((b > a && b < c) || (b < a && b > c)) {\\n            return b;\\n        } else {\\n            return c;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        if(nums.length<3) return -1;\\n    \\n        int a = nums[0];\\n        int b = nums[1];\\n        int c = nums[2];\\n\\n        if ((a > b && a < c) || (a < b && a > c)) {\\n            return a;\\n        } else if ((b > a && b < c) || (b < a && b > c)) {\\n            return b;\\n        } else {\\n            return c;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643386,
                "title": "probabilities-o-1",
                "content": "# Code\\n```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n            \\n            if(nums.length < 3){\\n                return -1;\\n            }\\n\\n            int min = nums[0] < nums[1] ? nums[0] : nums[1];\\n            int max = nums[0] > nums[1] ? nums[0] : nums[1];\\n\\n\\n            return nums[2] > max ? max : nums[2] < min ? min : nums[2];\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Probability and Statistics"
                ],
                "code": "```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n            \\n            if(nums.length < 3){\\n                return -1;\\n            }\\n\\n            int min = nums[0] < nums[1] ? nums[0] : nums[1];\\n            int max = nums[0] > nums[1] ? nums[0] : nums[1];\\n\\n\\n            return nums[2] > max ? max : nums[2] < min ? min : nums[2];\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625436,
                "title": "python-elegant-short-one-line",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def findNonMinOrMax(self, nums: List[int]) -> int:\\n        minimum, maximum = min(nums), max(nums)\\n        return next((num for num in nums if num not in (minimum, maximum)), -1)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findNonMinOrMax(self, nums: List[int]) -> int:\\n        minimum, maximum = min(nums), max(nums)\\n        return next((num for num in nums if num not in (minimum, maximum)), -1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625141,
                "title": "1-liner",
                "content": "**time: `O(1)`; space: `O(1)`**\\n\\n**c++**\\n```\\nint findNonMinOrMax(vector<int>& n) \\n{\\n\\treturn size(n)<3 ? -1 : min(max(min(n[0], n[1]), n[2]), max(n[0], n[1]));\\n}\\n```\\n**python**\\n```\\ndef findNonMinOrMax(self, n):\\n\\treturn -1 if len(n)<3 else min(max(min(n[0], n[1]), n[2]), max(n[0],n[1]));\\n```\\n**javascript**\\n```\\nvar findNonMinOrMax = function(n) \\n{\\n      return n.length<3 ? -1 : Math.min(Math.max(Math.min(n[0], n[1]), n[2]), Math.max(n[0],n[1]));\\n};\\n```\\n**java**\\n```\\npublic int findNonMinOrMax(int[] n) \\n{\\n\\treturn n.length<3 ? -1 : Math.min(Math.max(Math.min(n[0], n[1]), n[2]), Math.max(n[0], n[1]));\\n}\\n```\\n\\n**Other solutions (c++):**\\n```\\nint findNonMinOrMax(vector<int>& n) \\n{\\n\\treturn size(n)<3 ? -1 : max(min(n[0],n[1]), min(max(n[0],n[1]), n[2]));\\n}\\n```\\n||\\n```\\nint findNonMinOrMax(vector<int>& n) \\n{\\n\\treturn size(n)<3 ? -1 : n[0]+n[1]+n[2]-min(min(n[0],n[1]),n[2])-max(max(n[0],n[1]),n[2]);\\n}\\n```\\n||\\n```\\nint findNonMinOrMax(vector<int>& n) \\n{\\n\\tif(size(n)<3) return -1;\\n\\tif(n[0]>n[1]) swap(n[0], n[1]);\\n\\tif(n[1]>n[2]) swap(n[1], n[2]);\\n\\tif(n[0]>n[1]) swap(n[0], n[1]);\\n\\treturn n[1];\\n}\\n```\\n||\\n```\\nint findNonMinOrMax(vector<int>& n) \\n{     \\n\\treturn size(n)>2 ? sort(begin(n), end(n)), n[1] : -1;\\n}\\n```\\n\\n**Intro:**\\n`Min/max` functions are cool, as they help to eliminate **if**\\'s from the code hiding nesting inside them in a spirit of a functional programming. Also for the case of two numbers they are mutually complementary: `min` gives the number that is not `max` and vice versa. That fits our problem asking to find number that is **not** one of two other numbers. \\nThus I find it satisfying and yet somewhat surprising to find out that it\\'s possible to find the solution in terms of functions `min` and `max` only. Here\\'s the answer:\\n\\n![image](https://assets.leetcode.com/users/images/825ea6d0-0a00-4e78-8877-6ddc485e3199_1686701742.0315948.png)\\n\\nOf course you can generate more expressions by permuting `n[0], n[1]` and `n[2]` in the above expressions. \\nThere are 3!=6 different configurations of 3 different numbers so let\\'s consider all of them and convince ourselves that the formula (I\\'ll use the first one) always gives the right answer (the \"neither max nor min\" number is green dot):\\n\\n![image](https://assets.leetcode.com/users/images/1ec5fb1c-a002-4782-a75c-714ff29d880a_1686701911.0240228.png)\\n\\n\\nNow that we are convinced that the formula works let\\'s explore why.\\n\\n**Explanation:**\\nWe have three **different** numbers `n[0], n[1], n[2]`. Let me call the smallest of them \"small\", the largest - \"large\" and the one in between - \"mid\". We don\\'t know which one of `n[0], n[1], n[2]` is \"small\", \"mid\" and \"large\". Ofc, we can easily determine \"small\" and \"large\" like so: \\n```\\n\"small\" = min(min(n[0],n[1]),n[2]);\\n\"large\" = max(max(n[0],n[1]),n[2]);\\n```\\n\\n![image](https://assets.leetcode.com/users/images/81d6758e-533c-4e49-83b7-dbe979e19a73_1686555403.2322898.png)\\n\\nBut how to find \"mid\" using `max` and `min` functions only? As you\\'ll see that could be done by using the fact that:\\n> *\"mid\" is the smallest of two different numbers that are guaranteed to be not \"small\": \\n>  `\"mid\" = min( \\xB7 , \\xB7 )`.*\\n\\nIt sounds obvious so the main challenge is to find such two **different** \"not-small\" numbers. Well I\\'ll find them using the fact that\\n> *the number is not-small if it\\'s the `max` of some two numbers (because the `min` of these two numbers is clearly less than `max`), so that: \\n> `\"mid\" = min(max(  \\xB7 , \\xB7 ), max( \\xB7 , \\xB7  ))`.*\\n\\nNow the challenge is to find two pairs of numbers \\u2208 `{n[0], n[1], n[2]}` so that `max`\\'s of them are **different**.\\nOne of these pairs could easily be `{n[0], n[1]}` and the other is ... `{min(n[0],n[1]), n[2]}`. Note that we can\\'t have `{n[0], n[1]}` and `{n[1], n[2]}` as our pairs because it could be the case that `n[1]=max(n[0],n[1])=max(n[1],n[2])` so here our two \"not-small\" numbers are the same.\\n\\nAlgo:\\n* Out of `n[0], n[1]` calculate `m=min(n[0], n[1])` and `M=max(n[0], n[1])`. `M` is one of our \"not-small\" numbers we wanted to find. It can\\'t be \"small\" as `m<M`.\\n* Out of `m` and `n[2]` calculate `\\u2133=max(m, n[2])`. `\\u2133` is our second \"not-small\" number (as `min(m, n[2])<\\u2133=max(m,n[2])`) and it\\'s different from `M`! Thus we have two different candidates `M` and `\\u2133` that are \"not-small\" and it\\'s obvious that if one of them is \"mid\" then the other one is \"large\".  \\n* By definition \"mid\"<\"large\" , so \"mid\"=`min(\\u2133,M)` (\"large\" is `max(\\u2133,M)`). \\n\\nThus \\n```\\n\"mid\" = min(max(min(n[0], n[1]), n[2]), max(n[0], n[1]))\\n                -------m-------, n[2]\\n\\t\\t\\t-------------\\u2133-----------, -------M-------\\n```\\n\\n![image](https://assets.leetcode.com/users/images/71caf0c0-f24e-43a1-b87c-79b61944ba5b_1686502468.3699875.png)\\n\\nThat\\'s 4 operations `min/max` to find \"mid\" instead of 2 to find \"small/large\". However these 4 operations are structured in 3 layers while only 2 layers needed for \"small/large\". Here is the full chart:\\n\\n![image](https://assets.leetcode.com/users/images/17d9bb38-1ef2-4819-9d81-63837834350d_1686699177.4324377.png)\\n\\nIn fact you can do sorting using `max/min`. Here are expressions to sort the arrays that have 1,2,3 and 4 elements:\\n\\n![image](https://assets.leetcode.com/users/images/607f6777-80a1-4791-9c22-1c7728610062_1686770854.8127642.png)\\n\\nYou can generate these expressions recursively. Suppose we know how to sort 6 numbers with `min/nax`. To sort 7 numbers we can find the smallest number using `min`\\'s and generate and sort 6 non-small numbers `M_0 ... M_5`. These numbers could be found by using procedure that reminds the scheme for calculation of the [divided differences](https://en.wikipedia.org/wiki/Divided_differences):\\n\\n![image](https://assets.leetcode.com/users/images/0c759aa7-7f48-4481-8e92-d9978d256345_1687095229.0877616.png)\\n\\nIt\\'s easy to prove that if number of `n`\\'s is `2^n` then the number `M`\\'s is `2^n-1` as:\\n\\n![image](https://assets.leetcode.com/users/images/91dc8061-0e53-4a89-9103-fd817a9b23ca_1687095844.884648.png)\\n\\nAll this `min/max` story I\\'ve covered is connected to [sorting networks](https://en.wikipedia.org/wiki/Sorting_network). In fact, every sorting network generates `min/max` sorting expressions.\\n\\nHere are two sorting networks that sort 3-numbers:\\n\\n![image](https://assets.leetcode.com/users/images/2359ce1a-27c1-4a47-801e-862504a68f3b_1687180641.2061567.png)\\n\\nHere\\'s the sorting network to sort 4-numbers:\\n\\n![image](https://assets.leetcode.com/users/images/bd6d3197-4fd3-40f5-ba55-6a48081a9172_1687105579.277199.png)\\n\\nAs you can see these sorting nerworks generate the formulas to sort 3 and 4 numbers using `min\\\\max` that we\\'ve seen before.\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nint findNonMinOrMax(vector<int>& n) \\n{\\n\\treturn size(n)<3 ? -1 : min(max(min(n[0], n[1]), n[2]), max(n[0], n[1]));\\n}\\n```\n```\\ndef findNonMinOrMax(self, n):\\n\\treturn -1 if len(n)<3 else min(max(min(n[0], n[1]), n[2]), max(n[0],n[1]));\\n```\n```\\nvar findNonMinOrMax = function(n) \\n{\\n      return n.length<3 ? -1 : Math.min(Math.max(Math.min(n[0], n[1]), n[2]), Math.max(n[0],n[1]));\\n};\\n```\n```\\npublic int findNonMinOrMax(int[] n) \\n{\\n\\treturn n.length<3 ? -1 : Math.min(Math.max(Math.min(n[0], n[1]), n[2]), Math.max(n[0], n[1]));\\n}\\n```\n```\\nint findNonMinOrMax(vector<int>& n) \\n{\\n\\treturn size(n)<3 ? -1 : max(min(n[0],n[1]), min(max(n[0],n[1]), n[2]));\\n}\\n```\n```\\nint findNonMinOrMax(vector<int>& n) \\n{\\n\\treturn size(n)<3 ? -1 : n[0]+n[1]+n[2]-min(min(n[0],n[1]),n[2])-max(max(n[0],n[1]),n[2]);\\n}\\n```\n```\\nint findNonMinOrMax(vector<int>& n) \\n{\\n\\tif(size(n)<3) return -1;\\n\\tif(n[0]>n[1]) swap(n[0], n[1]);\\n\\tif(n[1]>n[2]) swap(n[1], n[2]);\\n\\tif(n[0]>n[1]) swap(n[0], n[1]);\\n\\treturn n[1];\\n}\\n```\n```\\nint findNonMinOrMax(vector<int>& n) \\n{     \\n\\treturn size(n)>2 ? sort(begin(n), end(n)), n[1] : -1;\\n}\\n```\n```\\n\"small\" = min(min(n[0],n[1]),n[2]);\\n\"large\" = max(max(n[0],n[1]),n[2]);\\n```\n```\\n\"mid\" = min(max(min(n[0], n[1]), n[2]), max(n[0], n[1]))\\n                -------m-------, n[2]\\n\\t\\t\\t-------------\\u2133-----------, -------M-------\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3624577,
                "title": "3-line-code-c-beginner-friendly-easy-o-nlogn-beats-100",
                "content": "# Intuition:\\nThe problem asks for finding any number from the array that is neither the minimum nor the maximum value. One approach to solve this is to sort the array and return the number at index 1, as it will be the first number after the minimum. However, if the array has less than or equal to two elements, there is no number that satisfies the given condition, so we return -1.\\n\\n# Approach:\\n\\nCheck if the size of the array is less than or equal to 2. If so, return -1.\\nSort the array in ascending order.\\nReturn the number at index 1, which will be the first number after the minimum.\\n# Time Complexity:\\nThe time complexity of this approach is dominated by the sorting operation, which has a time complexity of O(n log n), where n is the size of the array. The overall time complexity of the solution is O(n log n).\\n\\n# Space Complexity:\\nThe space complexity is O(1) because we are not using any extra space that scales with the input size. We are sorting the array in place, so the space used is constant.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        if(nums.size() <= 2) return -1;\\n        sort(nums.begin(), nums.end());\\n        return nums[1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        if(nums.size() <= 2) return -1;\\n        sort(nums.begin(), nums.end());\\n        return nums[1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623838,
                "title": "2-liner-code-easiest-c-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        return nums.size()>2? nums[1]:-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        return nums.size()>2? nums[1]:-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623810,
                "title": "java",
                "content": "# Code\\n```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        Arrays.sort(nums);\\n        return nums.length <= 2 ? -1 : nums[1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        Arrays.sort(nums);\\n        return nums.length <= 2 ? -1 : nums[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623798,
                "title": "neither-minimum-nor-maximum-o-n-easy",
                "content": "## Time Complexity : O(n)\\n## Space Complexity : O(1)\\n\\n```java []\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        if(nums.length<=2) return -1;\\n        int min = Arrays.stream(nums).min().getAsInt();\\n        int max = Arrays.stream(nums).max().getAsInt();\\n        for (int num : nums) {\\n            if (num != min && num != max) {\\n                return num;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n```cpp []\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        if (nums.size() <= 2) return -1;\\n        int min_num = *std::min_element(nums.begin(), nums.end());\\n        int max_num = *std::max_element(nums.begin(), nums.end());\\n        for (int num : nums) {\\n            if (num != min_num && num != max_num) {\\n                return num;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n    def findNonMinOrMax(self, nums: List[int]) -> int:\\n        if len(nums) <= 2:\\n            return -1\\n        min_num = min(nums)\\n        max_num = max(nums)\\n        for num in nums:\\n            if num != min_num and num != max_num:\\n                return num\\n        return -1\\n```\\n```golang []\\nfunc findNonMinOrMax(nums []int) int {\\n    if len(nums) <= 2 {\\n\\t\\treturn -1\\n\\t}\\n\\tmin_num := math.MaxInt64\\n\\tmax_num := math.MinInt64\\n\\tfor _, num := range nums {\\n\\t\\tif num < min_num {\\n\\t\\t\\tmin_num = num\\n\\t\\t}\\n\\t\\tif num > max_num {\\n\\t\\t\\tmax_num = num\\n\\t\\t}\\n\\t}\\n\\tfor _, num := range nums {\\n\\t\\tif num != min_num && num != max_num {\\n\\t\\t\\treturn num\\n\\t\\t}\\n\\t}\\n\\treturn -1\\n}\\n```\\n```scala []\\nobject Solution {\\n    def findNonMinOrMax(nums: Array[Int]): Int = {\\n        if (nums.length <= 2) return -1\\n        val min_num = nums.min\\n        val max_num = nums.max\\n        for (num <- nums) {\\n            if (num != min_num && num != max_num) {\\n                return num\\n            }\\n        }\\n        return -1\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Go",
                    "Scala"
                ],
                "code": "```java []\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        if(nums.length<=2) return -1;\\n        int min = Arrays.stream(nums).min().getAsInt();\\n        int max = Arrays.stream(nums).max().getAsInt();\\n        for (int num : nums) {\\n            if (num != min && num != max) {\\n                return num;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\n```cpp []\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        if (nums.size() <= 2) return -1;\\n        int min_num = *std::min_element(nums.begin(), nums.end());\\n        int max_num = *std::max_element(nums.begin(), nums.end());\\n        for (int num : nums) {\\n            if (num != min_num && num != max_num) {\\n                return num;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def findNonMinOrMax(self, nums: List[int]) -> int:\\n        if len(nums) <= 2:\\n            return -1\\n        min_num = min(nums)\\n        max_num = max(nums)\\n        for num in nums:\\n            if num != min_num and num != max_num:\\n                return num\\n        return -1\\n```\n```golang []\\nfunc findNonMinOrMax(nums []int) int {\\n    if len(nums) <= 2 {\\n\\t\\treturn -1\\n\\t}\\n\\tmin_num := math.MaxInt64\\n\\tmax_num := math.MinInt64\\n\\tfor _, num := range nums {\\n\\t\\tif num < min_num {\\n\\t\\t\\tmin_num = num\\n\\t\\t}\\n\\t\\tif num > max_num {\\n\\t\\t\\tmax_num = num\\n\\t\\t}\\n\\t}\\n\\tfor _, num := range nums {\\n\\t\\tif num != min_num && num != max_num {\\n\\t\\t\\treturn num\\n\\t\\t}\\n\\t}\\n\\treturn -1\\n}\\n```\n```scala []\\nobject Solution {\\n    def findNonMinOrMax(nums: Array[Int]): Int = {\\n        if (nums.length <= 2) return -1\\n        val min_num = nums.min\\n        val max_num = nums.max\\n        for (num <- nums) {\\n            if (num != min_num && num != max_num) {\\n                return num\\n            }\\n        }\\n        return -1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4025781,
                "title": "only-3-line-of-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n         sort(nums.begin(),nums.end()); // 1,2,3,4\\n         if (nums.size()==2 || nums.size()==1)\\n        {\\n            return -1;\\n        }\\n        return nums[1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n         sort(nums.begin(),nums.end()); // 1,2,3,4\\n         if (nums.size()==2 || nums.size()==1)\\n        {\\n            return -1;\\n        }\\n        return nums[1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018746,
                "title": "day-18-neither-minimum-nor-maximum-java-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        if(nums.length<=2)\\n            return -1;\\n        else\\n           return Math.max(Math.min(Math.max(nums[0], nums[1]), nums[2]), Math.min(nums[0], nums[1]));\\n           \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        if(nums.length<=2)\\n            return -1;\\n        else\\n           return Math.max(Math.min(Math.max(nums[0], nums[1]), nums[2]), Math.min(nums[0], nums[1]));\\n           \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018740,
                "title": "day-21-neither-minimum-nor-maximum-java-solution",
                "content": "# Approach\\nCompared first three **n** elements, lured down the most minimum elements and returned the max amongst them.\\n\\n---\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n---\\n\\n# Request\\nPlease **upvote**, If you find my post helpful.\\n\\n---\\n\\n# Code\\n```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        if(nums.length<3) return -1;\\n\\n        return Math.max(Math.min(Math.max(nums[0], nums[1]),nums[2]), Math.min(nums[0],nums[1]));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        if(nums.length<3) return -1;\\n\\n        return Math.max(Math.min(Math.max(nums[0], nums[1]),nums[2]), Math.min(nums[0],nums[1]));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3897261,
                "title": "most-easy-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        int n=nums.length;\\n        if(n<3) return -1;\\n        Arrays.sort(nums);\\n        return nums[1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        int n=nums.length;\\n        if(n<3) return -1;\\n        Arrays.sort(nums);\\n        return nums[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819608,
                "title": "c-most-easy-approach-beats-96",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        if(n<=2)\\n        return -1;\\n        else\\n        {\\n            sort(nums.begin(),nums.begin()+3);\\n            return nums[1];\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        if(n<=2)\\n        return -1;\\n        else\\n        {\\n            sort(nums.begin(),nums.begin()+3);\\n            return nums[1];\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3760091,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        int p=*max_element(nums.begin(),nums.end());\\n        int q=*min_element(nums.begin(),nums.end());\\n        for(auto it:nums)\\n         if(it!=p && it!=q)\\n           return it;\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        int p=*max_element(nums.begin(),nums.end());\\n        int q=*min_element(nums.begin(),nums.end());\\n        for(auto it:nums)\\n         if(it!=p && it!=q)\\n           return it;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703763,
                "title": "c-o-1-time-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\n * 2733. Neither Minimum nor Maximum\\n * \\n * Given an integer array nums containing distinct \\n * positive integers, find and return any number \\n * from the array that is neither the minimum nor \\n * the maximum value in the array, or -1 if there \\n * is no such number.\\n * \\n * Return the selected integer.\\n *\\n * 1 <= nums.length <= 100\\n * 1 <= nums[i] <= 100\\n * All values in nums are distinct\\n */\\n \\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\\n\\nint findNonMinOrMax(int* nums, int numsSize){\\n    /*\\n     * Input:\\n     *  nums, integer array\\n     *  numsSize\\n     */\\n     \\n    int sum = 0, max, min;\\n     \\n    if (numsSize <= 2) {\\n        return -1;\\n    }\\n    \\n    sum = nums[0] + nums[1] + nums[2];\\n    max = MAX(nums[0], nums[1]);\\n    max = MAX(max, nums[2]);\\n    min = MIN(nums[0], nums[1]);\\n    min = MIN(min, nums[2]);\\n\\n    /*\\n     * Output:\\n     *  find and return any number from the array \\n     *  that is neither the minimum nor the maximum \\n     *  value in the array, or -1 if there is no \\n     *  such number.\\n     */\\n\\n    return (sum - max - min);\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Math"
                ],
                "code": "```\\n/*\\n * 2733. Neither Minimum nor Maximum\\n * \\n * Given an integer array nums containing distinct \\n * positive integers, find and return any number \\n * from the array that is neither the minimum nor \\n * the maximum value in the array, or -1 if there \\n * is no such number.\\n * \\n * Return the selected integer.\\n *\\n * 1 <= nums.length <= 100\\n * 1 <= nums[i] <= 100\\n * All values in nums are distinct\\n */\\n \\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\\n\\nint findNonMinOrMax(int* nums, int numsSize){\\n    /*\\n     * Input:\\n     *  nums, integer array\\n     *  numsSize\\n     */\\n     \\n    int sum = 0, max, min;\\n     \\n    if (numsSize <= 2) {\\n        return -1;\\n    }\\n    \\n    sum = nums[0] + nums[1] + nums[2];\\n    max = MAX(nums[0], nums[1]);\\n    max = MAX(max, nums[2]);\\n    min = MIN(nums[0], nums[1]);\\n    min = MIN(min, nums[2]);\\n\\n    /*\\n     * Output:\\n     *  find and return any number from the array \\n     *  that is neither the minimum nor the maximum \\n     *  value in the array, or -1 if there is no \\n     *  such number.\\n     */\\n\\n    return (sum - max - min);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3695278,
                "title": "100-runtime-o-1-time-and-space-complexity",
                "content": "# Approach\\n- In this problem you only need first 3 elemets. Compare them and return the element that is in the middle.\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        if (nums.length < 3) return -1;\\n        int min = nums[0] < nums[1] ? nums[0] : nums[1];\\n        int max = nums[0] < nums[1] ? nums[1] : nums[0];\\n        if (nums[2] < min) {\\n            return min;\\n        } else if (nums[2] > max) {\\n            return max;\\n        } else {\\n            return nums[2];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        if (nums.length < 3) return -1;\\n        int min = nums[0] < nums[1] ? nums[0] : nums[1];\\n        int max = nums[0] < nums[1] ? nums[1] : nums[0];\\n        if (nums[2] < min) {\\n            return min;\\n        } else if (nums[2] > max) {\\n            return max;\\n        } else {\\n            return nums[2];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683963,
                "title": "using-rand-a-creative-take-on-the-question",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int size = nums.size();\\n           if (size <= 2) {\\n        return -1; \\n    }\\n    int randomIndex = rand() % (size - 2) + 1;\\n    return nums[randomIndex];\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int size = nums.size();\\n           if (size <= 2) {\\n        return -1; \\n    }\\n    int randomIndex = rand() % (size - 2) + 1;\\n    return nums[randomIndex];\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3674301,
                "title": "simple-solution-using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n     \\n     if(nums.length<=2)\\n        return -1;\\n    Arrays.sort(nums);\\n    return nums[1];  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n     \\n     if(nums.length<=2)\\n        return -1;\\n    Arrays.sort(nums);\\n    return nums[1];  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668048,
                "title": "2733-neither-minimum-nor-maximum-100-easy-java-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        for(int i=0; i<nums.length; i++){\\n            for(int j=i+1; j<nums.length; j++){\\n                if(nums[i]>nums[j]){\\n                    int temp =  nums[i];\\n                    nums[i] = nums[j];\\n                    nums[j] = temp;\\n                    \\n                }\\n            }\\n        }\\n        if(nums.length <=2){\\n            return -1;\\n        }\\n        return nums[1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        for(int i=0; i<nums.length; i++){\\n            for(int j=i+1; j<nums.length; j++){\\n                if(nums[i]>nums[j]){\\n                    int temp =  nums[i];\\n                    nums[i] = nums[j];\\n                    nums[j] = temp;\\n                    \\n                }\\n            }\\n        }\\n        if(nums.length <=2){\\n            return -1;\\n        }\\n        return nums[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3666677,
                "title": "c-simplest-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        if(nums.size()==1) return -1;\\n        int a=nums[0];\\n        int b=nums[nums.size()-1];\\n        if(nums[1]!=a && nums[1]!=b) return nums[1];\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        if(nums.size()==1) return -1;\\n        int a=nums[0];\\n        int b=nums[nums.size()-1];\\n        if(nums[1]!=a && nums[1]!=b) return nums[1];\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665750,
                "title": "java-simple-linear-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        int min = nums[0], max = nums[0];\\n        for(int i : nums){\\n            if(i < min) {\\n                min  = i;\\n            }\\n            if(i > max) {\\n                max = i;\\n            }\\n        }\\n        for(int i : nums){\\n            if(i != min && i != max) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        int min = nums[0], max = nums[0];\\n        for(int i : nums){\\n            if(i < min) {\\n                min  = i;\\n            }\\n            if(i > max) {\\n                max = i;\\n            }\\n        }\\n        for(int i : nums){\\n            if(i != min && i != max) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3653947,
                "title": "o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        int n = nums.size();\\n        int minn = nums[0], maxx = nums[0];\\n\\n        for (int i=1; i<n; i++) {\\n            minn = min(minn, nums[i]);\\n            maxx = max(maxx, nums[i]);\\n        }\\n\\n        for (auto i: nums) \\n            if (i != minn && i != maxx) return i;\\n\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        int n = nums.size();\\n        int minn = nums[0], maxx = nums[0];\\n\\n        for (int i=1; i<n; i++) {\\n            minn = min(minn, nums[i]);\\n            maxx = max(maxx, nums[i]);\\n        }\\n\\n        for (auto i: nums) \\n            if (i != minn && i != maxx) return i;\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647760,
                "title": "easiest-java-solution-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nReturn the element at first index after Sorting.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort the array. Check for few edge cases and handel it. Last step is to return the element ast first index.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.Arrays;\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        Arrays.sort(nums);\\n        if(nums.length==1) return -1;\\n        if(nums.length==2) return -1;\\n        return nums[1];\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.Arrays;\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        Arrays.sort(nums);\\n        if(nums.length==1) return -1;\\n        if(nums.length==2) return -1;\\n        return nums[1];\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3646563,
                "title": "ruby-one-liner",
                "content": "```\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef find_non_min_or_max(nums)\\n  (nums - nums.minmax)[0] || -1  \\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef find_non_min_or_max(nums)\\n  (nums - nums.minmax)[0] || -1  \\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3626411,
                "title": "java-two-pass",
                "content": "# Solution:\\n```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        int min = 101, max = 0;\\n        for (int i : nums) {\\n            if (i < min) min = i;\\n            if (i > max) max = i;\\n        }\\n        \\n        int ans = -1;\\n        for (int i : nums) {\\n            if (i < max && i > min) ans = i;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n### Time complexity: $$O(n)$$",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        int min = 101, max = 0;\\n        for (int i : nums) {\\n            if (i < min) min = i;\\n            if (i > max) max = i;\\n        }\\n        \\n        int ans = -1;\\n        for (int i : nums) {\\n            if (i < max && i > min) ans = i;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625895,
                "title": "3-line-code-super-easy-c-solution-o-nlogn-solution",
                "content": "\\n- Time complexity:\\n    $$O(n log n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        if(nums.size()<=2)return -1;\\n        sort(nums.begin(),nums.end());\\n        return nums[1];   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        if(nums.size()<=2)return -1;\\n        sort(nums.begin(),nums.end());\\n        return nums[1];   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624951,
                "title": "video-solution-accepted",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ncheck weather the size of the nums is greater than two or not\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) find weather the size is greater\\n2) if greater return any except first and last\\n3) Else return -1\\nfor more clearity watch our video solution\\n[click](https://youtu.be/b7C6JeRdkVc)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==0 || n==1 || n==2){\\n            return -1;\\n        }\\n        else{\\n            //sort(nums.begin(), nums.end());\\n            return nums[1];\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==0 || n==1 || n==2){\\n            return -1;\\n        }\\n        else{\\n            //sort(nums.begin(), nums.end());\\n            return nums[1];\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624120,
                "title": "use-first-three-numbers-no-sorting-or-looping",
                "content": "# Intuition\\nOnly need to look at the first three numbers\\nDon\\'t need to Sort or loop through all of the numbers\\n\\n# Approach\\nOnly need to look at three numbers, so look at the first three (or return -1)\\n\\nDetermine which one is between the others\\n\\nFirst approach:\\n    If A is between B and C ( or C and B) then its A\\n    If B... then its B\\n    Else its C\\n\\nBetter way to determine Between?\\nIf we substract then one will be positive and the other negative\\n    A-B, A-C one should be positive and the other negative\\nso multiply them to see which is negative, therefore between\\n    (A-B)*(A-C)<0 then A is between\\n    (B-C)*(B-A)<0 then B is between\\n    Else its C\\n\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int FindNonMinOrMax(int[] nums) {\\n        if (nums.Length <=2) return -1;\\n        \\n        /*\\n        //Works but is there a more concise solution?\\n        if (nums[1] > nums[0] && nums[1] < nums[2] ||\\n            nums[1] < nums[0] && nums[1] > nums[2] ) return nums[1];\\n        if (nums[2] > nums[1] && nums[2] < nums[0] ||\\n            nums[2] < nums[1] && nums[2] > nums[0] ) return nums[2];\\n        return nums[0];\\n        */\\n\\n        if ((nums[0] - nums[1]) * (nums[0] - nums[2]) < 0) return nums[0];\\n        if ((nums[1] - nums[2]) * (nums[1] - nums[0]) < 0) return nums[1];\\n        return nums[2];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int FindNonMinOrMax(int[] nums) {\\n        if (nums.Length <=2) return -1;\\n        \\n        /*\\n        //Works but is there a more concise solution?\\n        if (nums[1] > nums[0] && nums[1] < nums[2] ||\\n            nums[1] < nums[0] && nums[1] > nums[2] ) return nums[1];\\n        if (nums[2] > nums[1] && nums[2] < nums[0] ||\\n            nums[2] < nums[1] && nums[2] > nums[0] ) return nums[2];\\n        return nums[0];\\n        */\\n\\n        if ((nums[0] - nums[1]) * (nums[0] - nums[2]) < 0) return nums[0];\\n        if ((nums[1] - nums[2]) * (nums[1] - nums[0]) < 0) return nums[1];\\n        return nums[2];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624059,
                "title": "2-solutions",
                "content": "# Code\\n```\\nclass Solution:\\n    def findNonMinOrMax(self, nums: List[int]) -> int:\\n        for num in nums:\\n            if num != max(nums) and num != min(nums):\\n                return num\\n        return -1\\n```\\nand...\\n```\\nclass Solution:\\n    def findNonMinOrMax(self, nums: List[int]) -> int:\\n        nums = sorted(nums)\\n        isMaxMin = []\\n        for num in nums:\\n            if num != max(nums) and num != min(nums):\\n                isMaxMin.append(True)\\n            else:\\n                isMaxMin.append(False)\\n        print(isMaxMin)\\n        return nums[isMaxMin.index(True)] if True in isMaxMin else -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findNonMinOrMax(self, nums: List[int]) -> int:\\n        for num in nums:\\n            if num != max(nums) and num != min(nums):\\n                return num\\n        return -1\\n```\n```\\nclass Solution:\\n    def findNonMinOrMax(self, nums: List[int]) -> int:\\n        nums = sorted(nums)\\n        isMaxMin = []\\n        for num in nums:\\n            if num != max(nums) and num != min(nums):\\n                isMaxMin.append(True)\\n            else:\\n                isMaxMin.append(False)\\n        print(isMaxMin)\\n        return nums[isMaxMin.index(True)] if True in isMaxMin else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3624017,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def findNonMinOrMax(self, nums: List[int]) -> int:\\n        nums.sort()\\n        if len(nums)<3:\\n            return -1\\n        else:\\n            return nums[1]\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findNonMinOrMax(self, nums: List[int]) -> int:\\n        nums.sort()\\n        if len(nums)<3:\\n            return -1\\n        else:\\n            return nums[1]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623998,
                "title": "java-easiest-solution-brute-force-loops",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirstly we will think about finding the min and max of array then eliminate these numbers and print anything other than that .Here one more thing if the length is less than 3,then no element will be found .\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStart by checking the length of array .If it\\'s less than 3 ,return -1 ,else we will use a loop for array to get number other than max and min by using if condition to check if the number is equal to min and max .\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nComplexity is O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        int min = nums[0];\\n      for(int i=0; i<nums.length; i++ ) {\\n         if(nums[i]<min) {\\n            min = nums[i];\\n         }\\n      }\\n        int max = 0;\\n      for(int i=0; i<nums.length; i++ ) {\\n         if(nums[i]>max) { \\n             max = nums[i];\\n            }\\n      }\\n          if( nums.length<3) {\\n             return -1;\\n             }\\n              else {\\n               for(int num:nums){\\n                  if(num!=min && num!=max){\\n                      return num;\\n                  }\\n                }\\n              }\\n                   return -1;\\n    }\\n }\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        int min = nums[0];\\n      for(int i=0; i<nums.length; i++ ) {\\n         if(nums[i]<min) {\\n            min = nums[i];\\n         }\\n      }\\n        int max = 0;\\n      for(int i=0; i<nums.length; i++ ) {\\n         if(nums[i]>max) { \\n             max = nums[i];\\n            }\\n      }\\n          if( nums.length<3) {\\n             return -1;\\n             }\\n              else {\\n               for(int num:nums){\\n                  if(num!=min && num!=max){\\n                      return num;\\n                  }\\n                }\\n              }\\n                   return -1;\\n    }\\n }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623994,
                "title": "java-solution-easy",
                "content": "# Code\\n```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        int ans = -1;\\n        Arrays.sort(nums);\\n        int min = nums[0];\\n        int max = nums[nums.length-1];\\n        for(int x:nums){\\n            if(x!=min && x!=max){\\n                ans = x;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        int ans = -1;\\n        Arrays.sort(nums);\\n        int min = nums[0];\\n        int max = nums[nums.length-1];\\n        for(int x:nums){\\n            if(x!=min && x!=max){\\n                ans = x;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623952,
                "title": "array-minmax-array-find",
                "content": "```ruby\\ndef find_non_min_or_max a\\n    x, y = a.minmax\\n    a.find { x < _1 && _1 < y } || -1\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef find_non_min_or_max a\\n    x, y = a.minmax\\n    a.find { x < _1 && _1 < y } || -1\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3623947,
                "title": "c-easy-solution-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n<=2){\\n            return -1;\\n        }\\n\\n        int mini = INT_MAX, maxi = INT_MIN;\\n        for(auto it : nums){\\n            mini = min(mini, it);\\n            maxi = max(maxi, it);\\n        }\\n\\n        for(auto it : nums){\\n            if(it!=mini && it!=maxi){\\n                return it;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n<=2){\\n            return -1;\\n        }\\n\\n        int mini = INT_MAX, maxi = INT_MIN;\\n        for(auto it : nums){\\n            mini = min(mini, it);\\n            maxi = max(maxi, it);\\n        }\\n\\n        for(auto it : nums){\\n            if(it!=mini && it!=maxi){\\n                return it;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623936,
                "title": "c-3-lines-partial-sort",
                "content": "**Code**\\n```c++\\nint findNonMinOrMax(vector<int>& nums) {\\n    if (nums.size() <= 2) return -1;\\n    partial_sort(nums.begin(), nums.begin() + 2, nums.end());\\n    return nums[1];\\n}\\n```",
                "solutionTags": [],
                "code": "```c++\\nint findNonMinOrMax(vector<int>& nums) {\\n    if (nums.size() <= 2) return -1;\\n    partial_sort(nums.begin(), nums.begin() + 2, nums.end());\\n    return nums[1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3623887,
                "title": "c-easy-solution-sorting-t-c-o-nlogn-s-c-o-1",
                "content": "\\n\\n# Approach\\nJust sort the array and find element which is not equal to first and last element.\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n$$o(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int mini = nums[0];\\n        int n = nums.size();\\n        int maxi = nums[n-1];\\n        int ans = -1;\\n        for(int i = 0 ; i < n ; i++){\\n            if(nums[i]!=mini && nums[i]!=maxi){\\n                ans = nums[i];\\n                break;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int mini = nums[0];\\n        int n = nums.size();\\n        int maxi = nums[n-1];\\n        int ans = -1;\\n        for(int i = 0 ; i < n ; i++){\\n            if(nums[i]!=mini && nums[i]!=maxi){\\n                ans = nums[i];\\n                break;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4100867,
                "title": "java-solution-simple-if-else-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        Arrays.sort(nums);\\n        if(nums.length <= 2){\\n                return -1;\\n            }\\n        else{\\n            return nums[1];\\n        }\\n    }   \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        Arrays.sort(nums);\\n        if(nums.length <= 2){\\n                return -1;\\n            }\\n        else{\\n            return nums[1];\\n        }\\n    }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4098861,
                "title": "simple-and-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt first , I thought to find the maximum and minimum and then traverse through the array to see that an array element if not equal to maximum and minimum , return it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort the array. Now we know that the minimum element is present at the first or 0th position and the maximum element is present at the last or length-1 th position. \\nNow it would have been easy to return nums[1] but we should also consider the case when the array elements are \\n- [1,1,1,1,1] i.e, same. Here we return -1.\\n- [1,1,1,2,3,4,5,6,6] i.e, repetitive elements. Now we simply cannot return nums[1] as it is the minimum element. \\n\\nSo , in cases like this , we check that \\n- nums[current index] != nums[previous index]. If the condition is true , then return nums[current index].\\n- Say we have only 2 elements [a,b]. Now there will be 1 max , 1 min among them. We need to return the elements that are neither min nor max. So, we also added a condition that x != last position. Since x is starting from 1 , I didn\\'t feel the need to check for minimum. \\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) \\n    {\\n       /* int min= Integer.MAX_VALUE;\\n        int max = Integer.MIN_VALUE;\\n        for(int x=0;x<)     */\\n        Arrays.sort(nums);   \\n        for(int x =1 ;x<nums.length;x++)\\n        {\\n            if(nums[x]!=nums[x-1] && x!= nums.length-1)\\n                return nums[x];\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) \\n    {\\n       /* int min= Integer.MAX_VALUE;\\n        int max = Integer.MIN_VALUE;\\n        for(int x=0;x<)     */\\n        Arrays.sort(nums);   \\n        for(int x =1 ;x<nums.length;x++)\\n        {\\n            if(nums[x]!=nums[x-1] && x!= nums.length-1)\\n                return nums[x];\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4096448,
                "title": "very-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        Arrays.sort(nums);\\n        if(nums.length<=2){\\n            return -1;\\n        }\\n       return nums[nums.length/2];\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        Arrays.sort(nums);\\n        if(nums.length<=2){\\n            return -1;\\n        }\\n       return nums[nums.length/2];\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4095106,
                "title": "java-without-sorting",
                "content": "\\tclass Solution {\\n\\t\\tpublic int findNonMinOrMax(int[] nums) {\\n\\t\\t   int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;\\n\\n\\t\\t\\tfor(int num: nums){\\n\\t\\t\\t\\tif(num < min) min = num;\\n\\t\\t\\t\\tif(num > max) max = num;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(nums.length > 2){\\n\\t\\t\\t\\tfor(int num: nums){\\n\\t\\t\\t\\t\\tif(num != min && num != max){\\n\\t\\t\\t\\t\\t\\treturn num;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\tpublic int findNonMinOrMax(int[] nums) {\\n\\t\\t   int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;\\n\\n\\t\\t\\tfor(int num: nums){\\n\\t\\t\\t\\tif(num < min) min = num;\\n\\t\\t\\t\\tif(num > max) max = num;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 4092886,
                "title": "runtime-4ms-beats-99-75-in-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFinding the maximum and minimum element in the array\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFinding the max and min element in the array\\nReturning element present at any other index except that of max and min\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        int min=nums[0],max=nums[0];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(min>nums[i])\\n            min=nums[i];\\n            if(max<nums[i])\\n            max=nums[i];\\n        }\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]!=max&&nums[i]!=min)\\n            return nums[i];\\n        }\\n\\n        return(-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        int min=nums[0],max=nums[0];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(min>nums[i])\\n            min=nums[i];\\n            if(max<nums[i])\\n            max=nums[i];\\n        }\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]!=max&&nums[i]!=min)\\n            return nums[i];\\n        }\\n\\n        return(-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091767,
                "title": "easy-and-best-solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        Arrays.sort(nums);\\n       int max=nums[nums.length-1];\\n       int min=nums[0];\\n       for(int i=0; i<nums.length; i++ ){\\n           if(nums[i]!=max && nums[i]!=min){\\n               return nums[i];\\n           }\\n       }\\n      return -1; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        Arrays.sort(nums);\\n       int max=nums[nums.length-1];\\n       int min=nums[0];\\n       for(int i=0; i<nums.length; i++ ){\\n           if(nums[i]!=max && nums[i]!=min){\\n               return nums[i];\\n           }\\n       }\\n      return -1; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091124,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\ndetermine max and min of array first and then filter out those values. If the array has a length of 1 or 2 then there will be no middle number. Since it doesn\\'t matter which one is given, we will just give the first number that isn\\'t the max or min\\n\\n# Code\\n```\\nclass Solution:\\n    def findNonMinOrMax(self, nums: List[int]) -> int:\\n        maxi = max(nums)\\n        mini = min(nums)\\n\\n        if len(nums) == 2 or len(nums) == 1:\\n            return -1\\n        else:\\n            for n in nums:\\n                if n < maxi and n > mini:\\n                    return n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findNonMinOrMax(self, nums: List[int]) -> int:\\n        maxi = max(nums)\\n        mini = min(nums)\\n\\n        if len(nums) == 2 or len(nums) == 1:\\n            return -1\\n        else:\\n            for n in nums:\\n                if n < maxi and n > mini:\\n                    return n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4090747,
                "title": "simple-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nJust find the second minimum element unless the array is of length 2 or below\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findNonMinOrMax = function(nums) {\\n    if(nums.length <= 2){\\n        return -1;\\n    }\\n    let min = Number.MAX_VALUE;\\n    let min1 = Number.MAX_VALUE;\\n    nums.forEach((val) => {\\n        if(val <= min ){\\n            min1 = min;\\n            min = val\\n        }else if(val <= min1){\\n            min1 = val;\\n        }\\n    });\\n    return min1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findNonMinOrMax = function(nums) {\\n    if(nums.length <= 2){\\n        return -1;\\n    }\\n    let min = Number.MAX_VALUE;\\n    let min1 = Number.MAX_VALUE;\\n    nums.forEach((val) => {\\n        if(val <= min ){\\n            min1 = min;\\n            min = val\\n        }else if(val <= min1){\\n            min1 = val;\\n        }\\n    });\\n    return min1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4089959,
                "title": "easiest-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        Arrays.sort(nums);\\n        if(nums.length==2||nums.length==1)\\n        return -1;\\n        return nums[1];\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        Arrays.sort(nums);\\n        if(nums.length==2||nums.length==1)\\n        return -1;\\n        return nums[1];\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4087892,
                "title": "solution-with-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        Arrays.sort(nums);\\n        int low = 0;\\n        int high = nums.length - 1;\\n        int min = nums[0];\\n        int max = nums[nums.length - 1];\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n            int guess = nums[mid];\\n            if (guess != min && guess != max) return guess;\\n            if (guess == min) high = mid - 1;\\n            else low = mid + 1;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        Arrays.sort(nums);\\n        int low = 0;\\n        int high = nums.length - 1;\\n        int min = nums[0];\\n        int max = nums[nums.length - 1];\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n            int guess = nums[mid];\\n            if (guess != min && guess != max) return guess;\\n            if (guess == min) high = mid - 1;\\n            else low = mid + 1;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086203,
                "title": "easy-one-liner-using-sort",
                "content": "# Code\\n```\\nclass Solution:\\n    def findNonMinOrMax(self, nums: List[int]) -> int:\\n        return -1 if len(nums) < 3 else sorted(nums)[1] \\n# returning a number that is second minimum if len(nums) is greater\\n# than 2\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findNonMinOrMax(self, nums: List[int]) -> int:\\n        return -1 if len(nums) < 3 else sorted(nums)[1] \\n# returning a number that is second minimum if len(nums) is greater\\n# than 2\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4085302,
                "title": "java-easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n\\n        if (nums.length < 3) return -1;\\n        else Arrays.sort(nums, 0, 3);\\n\\n        return nums[1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n\\n        if (nums.length < 3) return -1;\\n        else Arrays.sort(nums, 0, 3);\\n\\n        return nums[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4085301,
                "title": "java-easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n\\n        if (nums.length < 3) return -1;\\n        else Arrays.sort(nums, 0, 3);\\n\\n        return nums[1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n\\n        if (nums.length < 3) return -1;\\n        else Arrays.sort(nums, 0, 3);\\n\\n        return nums[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4085107,
                "title": "python-easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def findNonMinOrMax(self, nums):\\n        out = 0\\n        if len(nums) <= 2:\\n            out = -1\\n        else:\\n            nums = sorted(nums)\\n            out = nums[1]\\n        return out\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findNonMinOrMax(self, nums):\\n        out = 0\\n        if len(nums) <= 2:\\n            out = -1\\n        else:\\n            nums = sorted(nums)\\n            out = nums[1]\\n        return out\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4084197,
                "title": "o-1-time-space-complexity-beats-99-7-in-time-99-1-in-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n - If length is less than 2, we return -1\\n - If length is 3 or more: Let\\'s consider only first three number. In those 3 number there will be one max, one min and one in middle. We use if loops to find the middle number\\n \\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n\\n        if (nums.length <= 2)\\n        return -1;   \\n\\n         if (nums [2] < nums[0] && nums[2]> nums [1] || nums [2] > nums[0] && nums[2] < nums [1] )\\n                return nums [2];\\n         if (nums [0] < nums[2] && nums[0]> nums [1] || nums [0] > nums[2] && nums[0] < nums [1] )\\n                return nums[0];\\n         if (nums [1] < nums[0] && nums[1]> nums [2] || nums [1] > nums[0] && nums[1] < nums [2] )\\n                return nums[1];\\n\\n          return 0; // to satisfy complier, we\\'ll never reach here\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n\\n        if (nums.length <= 2)\\n        return -1;   \\n\\n         if (nums [2] < nums[0] && nums[2]> nums [1] || nums [2] > nums[0] && nums[2] < nums [1] )\\n                return nums [2];\\n         if (nums [0] < nums[2] && nums[0]> nums [1] || nums [0] > nums[2] && nums[0] < nums [1] )\\n                return nums[0];\\n         if (nums [1] < nums[0] && nums[1]> nums [2] || nums [1] > nums[0] && nums[1] < nums [2] )\\n                return nums[1];\\n\\n          return 0; // to satisfy complier, we\\'ll never reach here\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4083102,
                "title": "beats-97-solution-in-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int FindNonMinOrMax(int[] nums) {\\n        Array.Sort(nums);\\n        if(nums.Length <=2)\\n        {\\n            return -1;\\n        }\\n        return nums[1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int FindNonMinOrMax(int[] nums) {\\n        Array.Sort(nums);\\n        if(nums.Length <=2)\\n        {\\n            return -1;\\n        }\\n        return nums[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4082604,
                "title": "python-beats-90-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findNonMinOrMax(self, nums: List[int]) -> int:\\n        if len(nums) < 3:\\n            return -1\\n        else:\\n            low = nums[0]\\n            high = nums[0]\\n            for i in nums:\\n                if i < low:\\n                    low = i\\n                if i > high:  \\n                    high = i\\n            for i in nums:\\n                if i != low and i != high:\\n                    return i \\n\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findNonMinOrMax(self, nums: List[int]) -> int:\\n        if len(nums) < 3:\\n            return -1\\n        else:\\n            low = nums[0]\\n            high = nums[0]\\n            for i in nums:\\n                if i < low:\\n                    low = i\\n                if i > high:  \\n                    high = i\\n            for i in nums:\\n                if i != low and i != high:\\n                    return i \\n\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081807,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        if(nums.size()<=2){\\n            return -1;\\n        }\\n\\n        sort(nums.begin(), nums.end());\\n        // return nums[1];\\n        \\n        int n=nums.size();\\n        return nums[n-2];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        if(nums.size()<=2){\\n            return -1;\\n        }\\n\\n        sort(nums.begin(), nums.end());\\n        // return nums[1];\\n        \\n        int n=nums.size();\\n        return nums[n-2];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078805,
                "title": "neitherminnormax",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        int max=nums[0];\\n        int min=nums[0];\\n        int output=-1;\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]>max){\\n                max=nums[i];\\n            }\\n            if(nums[i]<min){\\n                min=nums[i];\\n            }\\n\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]!=max && nums[i]!=min){\\n                 output=nums[i];\\n                 break;\\n            }\\n        }\\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        int max=nums[0];\\n        int min=nums[0];\\n        int output=-1;\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]>max){\\n                max=nums[i];\\n            }\\n            if(nums[i]<min){\\n                min=nums[i];\\n            }\\n\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]!=max && nums[i]!=min){\\n                 output=nums[i];\\n                 break;\\n            }\\n        }\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4073696,
                "title": "simple-beginner-friendly-using-c",
                "content": "# Intuition\\n**SIMPLE Beginner Friendly Aprroch Using C++**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. find max element using C++ Stl library;\\n2. find min element ;\\n3. check each element if its not max and not min;\\n4. return it as ans;\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(3N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        int maxi=*max_element(nums.begin(),nums.end());\\n        int mini=*min_element(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n           if(nums[i]!=maxi && nums[i]!=mini){\\n               return nums[i];\\n           }\\n        }\\n        return -1;\\n    }\\n};\\n```N",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        int maxi=*max_element(nums.begin(),nums.end());\\n        int mini=*min_element(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n           if(nums[i]!=maxi && nums[i]!=mini){\\n               return nums[i];\\n           }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066942,
                "title": "python-1-liner",
                "content": "Just find the mid of the first 3 sorted items:\\n\\n\\n```\\nclass Solution:\\n    def findNonMinOrMax(self, nums: List[int]) -> int:\\n        return sorted(nums)[1] if len(nums) >= 3 else -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findNonMinOrMax(self, nums: List[int]) -> int:\\n        return sorted(nums)[1] if len(nums) >= 3 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4065712,
                "title": "simple-solution-o-n-time-o-1-space",
                "content": "# Intuition\\n<!-- return the element which is not equal minimum and maximum element  -->\\n\\n# Approach\\n<!-- find minimum element \\n    find maximum element\\n    Find a element which is not equal to min and max element -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- O(n) -->\\n\\n- Space complexity:\\n<!-- O(1) -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        int res = -1 ;\\n        int min = INT_MAX ;\\n        int max = INT_MIN ;\\n        int size = nums.size() ;\\n        for(int i = 0;i < size;i++)\\n        {\\n            if(nums[i] < min)\\n                min = nums[i] ;\\n        }\\n        for(int i = 0;i < size;i++)\\n        {\\n            if(nums[i] > max)\\n                max = nums[i] ;\\n        }\\n        for(int i = 0;i < size;i++)\\n        {\\n            if(nums[i] != min and nums[i] != max)\\n            {\\n                res = nums[i] ;\\n                break ;\\n            }\\n        }\\n        return res ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        int res = -1 ;\\n        int min = INT_MAX ;\\n        int max = INT_MIN ;\\n        int size = nums.size() ;\\n        for(int i = 0;i < size;i++)\\n        {\\n            if(nums[i] < min)\\n                min = nums[i] ;\\n        }\\n        for(int i = 0;i < size;i++)\\n        {\\n            if(nums[i] > max)\\n                max = nums[i] ;\\n        }\\n        for(int i = 0;i < size;i++)\\n        {\\n            if(nums[i] != min and nums[i] != max)\\n            {\\n                res = nums[i] ;\\n                break ;\\n            }\\n        }\\n        return res ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4065100,
                "title": "c-easy-solution",
                "content": "\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint findNonMinOrMax(int* nums, int numsSize){\\nint max=0 ,min=101; //int max=100 ,min=1 ;\\nif(numsSize==1||numsSize==2)\\n{\\n    return -1;\\n}\\nfor(int i=0;i<numsSize;i++)\\n{\\n    if(nums[i]>max)\\n    max=nums[i];\\n    if(nums[i]<min)\\n    min=nums[i];\\n}\\n\\nfor(int i=0;i<numsSize;i++)\\n{\\n    if(nums[i]!=min&&nums[i]!=max)\\n    return nums[i];\\n}\\n\\n    return -11;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint findNonMinOrMax(int* nums, int numsSize){\\nint max=0 ,min=101; //int max=100 ,min=1 ;\\nif(numsSize==1||numsSize==2)\\n{\\n    return -1;\\n}\\nfor(int i=0;i<numsSize;i++)\\n{\\n    if(nums[i]>max)\\n    max=nums[i];\\n    if(nums[i]<min)\\n    min=nums[i];\\n}\\n\\nfor(int i=0;i<numsSize;i++)\\n{\\n    if(nums[i]!=min&&nums[i]!=max)\\n    return nums[i];\\n}\\n\\n    return -11;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4064042,
                "title": "easy-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findNonMinOrMax = function(nums) {\\n    let max =nums[0]\\n    let min = nums[0]\\n    for(let i = 0; i< nums.length; i++){\\n        max = Math.max(nums[i],max)\\n        min = Math.min(nums[i],min)\\n    }\\n    for(let i = 0;i<nums.length; i++){\\n        if(nums[i]!==max && nums[i]!==min){\\n            return nums[i]\\n        }\\n    }\\n    return -1\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findNonMinOrMax = function(nums) {\\n    let max =nums[0]\\n    let min = nums[0]\\n    for(let i = 0; i< nums.length; i++){\\n        max = Math.max(nums[i],max)\\n        min = Math.min(nums[i],min)\\n    }\\n    for(let i = 0;i<nums.length; i++){\\n        if(nums[i]!==max && nums[i]!==min){\\n            return nums[i]\\n        }\\n    }\\n    return -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4063117,
                "title": "beat-97-in-memory-and-80-in-time-and-easy-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findNonMinOrMax(self, nums: List[int]) -> int:\\n        if len(nums)<=2:\\n            return -1\\n        else:\\n            mi=min(nums)\\n            ma=max(nums)\\n            for i in range(len(nums)):\\n                if nums[i]!=mi and nums[i]!=ma:\\n                    return nums[i]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findNonMinOrMax(self, nums: List[int]) -> int:\\n        if len(nums)<=2:\\n            return -1\\n        else:\\n            mi=min(nums)\\n            ma=max(nums)\\n            for i in range(len(nums)):\\n                if nums[i]!=mi and nums[i]!=ma:\\n                    return nums[i]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4062682,
                "title": "easy-python-solution-python",
                "content": "# EASY PYTHON SOLUTION || PYTHON || \\u270C\\u270C\\n\\n# Code\\n```\\nclass Solution:\\n    def findNonMinOrMax(self, nums: List[int]) -> int:\\n        #print(nums)\\n        nums.sort()\\n        print(nums)\\n        n = len(nums)\\n        if  n>=3:\\n            i = 0\\n            j = n-1\\n            m = i+j//2\\n            return nums[m]\\n    \\n        else:\\n            return -1\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findNonMinOrMax(self, nums: List[int]) -> int:\\n        #print(nums)\\n        nums.sort()\\n        print(nums)\\n        n = len(nums)\\n        if  n>=3:\\n            i = 0\\n            j = n-1\\n            m = i+j//2\\n            return nums[m]\\n    \\n        else:\\n            return -1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4062309,
                "title": "good-php-solution-best-memory-and-top-speed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @return Integer\\n     */\\n    function findNonMinOrMax($nums) {\\n        \\n        if (count($nums) < 3) {\\n\\n            return -1;\\n        } else {\\n            sort($nums);\\n\\n            return $nums[1];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @return Integer\\n     */\\n    function findNonMinOrMax($nums) {\\n        \\n        if (count($nums) < 3) {\\n\\n            return -1;\\n        } else {\\n            sort($nums);\\n\\n            return $nums[1];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4058953,
                "title": "2-approach-s-explained-for-both-o-n-beats-99-76-and-o-n-2-for-simple-understanding",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n# Approach 1-\\n- check if size of array is less than or equal to 2 return -1.\\n- sort the array (which will give you min at start and max at end).\\n- return mid element (return any ele if it is not equal to min and max).\\n\\n(since i have used bubble sort) \\nTime complexity: O(N^2).\\n(but as array input grows its storage will)\\n![image.png](https://assets.leetcode.com/users/images/6b32bd08-fc32-4906-bfc0-e0f32211016e_1695020150.7835925.png)\\n\\n---\\n\\n\\n# Approach 2-\\n(if you read carefully you can return any element until and unless it is not minimum and maximum)\\n- check if size of array is less than or equal to 2 return -1.\\n- get min and max element from array through iteration.\\n- check if middle ele is equal to min or max, if not then return mid\\n- if mid=min, check should we + or - the index (conditions are same)\\n    - since mid=min we need to check for max and perform + or - \\n- if mid=max, check should we + or - the index\\n    - since mid=max we need to check for min and perform + or - \\n\\nTime complexity: O(N).\\n![image.png](https://assets.leetcode.com/users/images/5baa2677-3374-4db4-a206-e538b90bd54b_1695020413.5066078.png)\\n\\n-Please suggest the more efficient approach and code\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n\\n/////////////**Approach 1**///////////////\\npublic int findNonMinOrMax(int[] nums) {\\n    if(nums.length<=2){return -1;}\\n    Arrays.sort(nums);\\n    ////bubble sort (in case you want to check edge cases)\\n    //for (int a = 0; a < nums.length; a++) {\\n    //for (int b = 0; b < nums.length; b++) {\\n    //if (nums[a] < nums[b]) {\\n    //int temp = nums[a];\\n    //nums[a] = nums[b];\\n    //nums[b] = temp;\\n    //}\\n    //}\\n    //}\\n    return nums[nums.length / 2];\\n\\n\\n\\n/////////////Approach 2///////////////\\n    public int findNonMinOrMax(int[] nums) {\\n        int len = nums.length;\\n        int ans = nums[len / 2];\\n        if (len <= 2) {\\n            return -1;\\n        }\\n        int min = nums[0], max = nums[0];\\n        for (int i = 0; i < len; i++) {\\n            min = Math.min(min, nums[i]);\\n            max = Math.max(max, nums[i]);\\n        }\\n        if (ans == min) {\\n            if ((nums[(len / 2) + 1]) < max && (nums[(len / 2) - 1]) != max) {\\n                ans = nums[(len / 2) + 1];\\n            } else {\\n                ans = nums[(len / 2) - 1];\\n            }\\n        }\\n        if (ans == max) {\\n            if ((nums[(len / 2) - 1]) < max && (nums[(len / 2) - 1]) != min) {\\n                ans = nums[(len / 2) - 1];\\n            } else {\\n                ans = nums[(len / 2) + 1];\\n            }\\n        }\\n        return ans;      \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n\\n/////////////**Approach 1**///////////////\\npublic int findNonMinOrMax(int[] nums) {\\n    if(nums.length<=2){return -1;}\\n    Arrays.sort(nums);\\n    ////bubble sort (in case you want to check edge cases)\\n    //for (int a = 0; a < nums.length; a++) {\\n    //for (int b = 0; b < nums.length; b++) {\\n    //if (nums[a] < nums[b]) {\\n    //int temp = nums[a];\\n    //nums[a] = nums[b];\\n    //nums[b] = temp;\\n    //}\\n    //}\\n    //}\\n    return nums[nums.length / 2];\\n\\n\\n\\n/////////////Approach 2///////////////\\n    public int findNonMinOrMax(int[] nums) {\\n        int len = nums.length;\\n        int ans = nums[len / 2];\\n        if (len <= 2) {\\n            return -1;\\n        }\\n        int min = nums[0], max = nums[0];\\n        for (int i = 0; i < len; i++) {\\n            min = Math.min(min, nums[i]);\\n            max = Math.max(max, nums[i]);\\n        }\\n        if (ans == min) {\\n            if ((nums[(len / 2) + 1]) < max && (nums[(len / 2) - 1]) != max) {\\n                ans = nums[(len / 2) + 1];\\n            } else {\\n                ans = nums[(len / 2) - 1];\\n            }\\n        }\\n        if (ans == max) {\\n            if ((nums[(len / 2) - 1]) < max && (nums[(len / 2) - 1]) != min) {\\n                ans = nums[(len / 2) - 1];\\n            } else {\\n                ans = nums[(len / 2) + 1];\\n            }\\n        }\\n        return ans;      \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4052019,
                "title": "swift-o-n-solution",
                "content": "# Intuition\\nTo return a number that is in between the largest and the smallest, else to return -1 .\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    func findNonMinOrMax(_ nums: [Int]) -> Int {\\n        for i in nums {\\n            if i < nums.max()! && i > nums.min()! {\\n                return i\\n            }\\n        }\\n        return -1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    func findNonMinOrMax(_ nums: [Int]) -> Int {\\n        for i in nums {\\n            if i < nums.max()! && i > nums.min()! {\\n                return i\\n            }\\n        }\\n        return -1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4049700,
                "title": "java-beginner-level-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        int min = nums[0];\\n        int max = nums[0];\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] > max) max = nums[i];\\n            if (nums[i] < min) min = nums[i];\\n        }\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] != max && nums[i] != min) return nums[i];\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        int min = nums[0];\\n        int max = nums[0];\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] > max) max = nums[i];\\n            if (nums[i] < min) min = nums[i];\\n        }\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] != max && nums[i] != min) return nums[i];\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048953,
                "title": "2-cpp-solution-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        // int mini = INT_MAX, maxi = INT_MIN;\\n\\n        // for(int i = 0; i < nums.size(); i++){\\n        //     mini = min(mini, nums[i]);\\n        //     maxi = max(maxi, nums[i]);\\n        // }\\n\\n        // for(int i = 0; i < nums.size(); i++){\\n        //     if(nums[i] > mini && nums[i] < maxi) return nums[i];\\n        // }\\n\\n        sort(nums.begin(), nums.end());\\n\\n        if(nums.size() > 2){\\n            return nums[1];\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        // int mini = INT_MAX, maxi = INT_MIN;\\n\\n        // for(int i = 0; i < nums.size(); i++){\\n        //     mini = min(mini, nums[i]);\\n        //     maxi = max(maxi, nums[i]);\\n        // }\\n\\n        // for(int i = 0; i < nums.size(); i++){\\n        //     if(nums[i] > mini && nums[i] < maxi) return nums[i];\\n        // }\\n\\n        sort(nums.begin(), nums.end());\\n\\n        if(nums.size() > 2){\\n            return nums[1];\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048862,
                "title": "simple-javascript-solution-fast",
                "content": "# Intuition\\nNo need to go through all the elements. We just need to go through first 3 elements and it will work.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findNonMinOrMax = function(nums) {\\n    if(nums.length < 3){ \\n       return -1\\n    }\\n\\n    if(nums[0] > nums[1]){\\n        low = nums[1]\\n        mid = nums[0]\\n    }\\n    else{\\n        low = nums[0]\\n        mid = nums[1]\\n    }\\n\\n    if(nums[2] > mid){\\n        return mid;\\n    } \\n    else{\\n        return nums[2] > low ? nums[2] : low;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findNonMinOrMax = function(nums) {\\n    if(nums.length < 3){ \\n       return -1\\n    }\\n\\n    if(nums[0] > nums[1]){\\n        low = nums[1]\\n        mid = nums[0]\\n    }\\n    else{\\n        low = nums[0]\\n        mid = nums[1]\\n    }\\n\\n    if(nums[2] > mid){\\n        return mid;\\n    } \\n    else{\\n        return nums[2] > low ? nums[2] : low;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4048727,
                "title": "c-o-1-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        if(nums.size()<=2) return -1;\\n        if(nums[0]>nums[1] && nums[0]>nums[2]) return nums[1]>nums[2]?nums[1]:nums[2];\\n        if(nums[1]>nums[2] && nums[1]>nums[0]) return nums[0]>nums[2]?nums[0]:nums[2];\\n        return nums[1]>nums[0]?nums[1]:nums[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        if(nums.size()<=2) return -1;\\n        if(nums[0]>nums[1] && nums[0]>nums[2]) return nums[1]>nums[2]?nums[1]:nums[2];\\n        if(nums[1]>nums[2] && nums[1]>nums[0]) return nums[0]>nums[2]?nums[0]:nums[2];\\n        return nums[1]>nums[0]?nums[1]:nums[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047354,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) \\n    {\\n        int maxValue,minValue;\\n        maxValue=minValue=nums[0];\\n        for(int x:nums)\\n        {\\n            maxValue=Math.max(maxValue,x);\\n            minValue=Math.min(minValue,x);\\n        }\\n        int ans=-1;\\n        for(int x:nums)\\n        {\\n            if(x<maxValue&&x>minValue)\\n            {\\n                ans=x;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) \\n    {\\n        int maxValue,minValue;\\n        maxValue=minValue=nums[0];\\n        for(int x:nums)\\n        {\\n            maxValue=Math.max(maxValue,x);\\n            minValue=Math.min(minValue,x);\\n        }\\n        int ans=-1;\\n        for(int x:nums)\\n        {\\n            if(x<maxValue&&x>minValue)\\n            {\\n                ans=x;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047233,
                "title": "beats-61-27-runtime-and-beats-78-52-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n\\t\\tArrays.sort(nums);\\n\\t\\tif(nums.length<=2)\\n\\t\\t\\treturn -1;\\n        return nums[1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n\\t\\tArrays.sort(nums);\\n\\t\\tif(nums.length<=2)\\n\\t\\t\\treturn -1;\\n        return nums[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044867,
                "title": "easy-java-and-python",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Java\\n```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        int min = Integer.MAX_VALUE;\\n        int max = Integer.MIN_VALUE;\\n\\n        for (int num : nums) {\\n            min = Math.min(min, num);\\n            max = Math.max(max, num);\\n        }\\n\\n        for (int num : nums) {\\n            if (num != min && num != max) {\\n                return num;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```\\n\\n# Python\\n```\\nclass Solution:\\n    def findNonMinOrMax(self, nums: List[int]) -> int:\\n        min_val, max_val = min(nums), max(nums)\\n\\n        for num in nums:\\n            if num != min_val and num != max_val:\\n                return num\\n\\n        return -1\\n```",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        int min = Integer.MAX_VALUE;\\n        int max = Integer.MIN_VALUE;\\n\\n        for (int num : nums) {\\n            min = Math.min(min, num);\\n            max = Math.max(max, num);\\n        }\\n\\n        for (int num : nums) {\\n            if (num != min && num != max) {\\n                return num;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def findNonMinOrMax(self, nums: List[int]) -> int:\\n        min_val, max_val = min(nums), max(nums)\\n\\n        for num in nums:\\n            if num != min_val and num != max_val:\\n                return num\\n\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044571,
                "title": "2-line-javascript",
                "content": "# Code\\n```\\nvar findNonMinOrMax = function(nums) {\\n    nums.sort((a,b) => a-b)\\n    return nums.length < 3 ? -1 : nums[1]\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findNonMinOrMax = function(nums) {\\n    nums.sort((a,b) => a-b)\\n    return nums.length < 3 ? -1 : nums[1]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4041339,
                "title": "",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def findNonMinOrMax(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        flag=True\\n        for i in nums:\\n            if (flag)&(i!=max(nums))&(i!=min(nums)):\\n                flag=False\\n                return i\\n        if flag:\\n            return -1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findNonMinOrMax(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        flag=True\\n        for i in nums:\\n            if (flag)&(i!=max(nums))&(i!=min(nums)):\\n                flag=False\\n                return i\\n        if flag:\\n            return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039425,
                "title": "easy-method-beats-100-faster-beginner-s-friendly",
                "content": "## Easy and Short Method (Beats 92% Faster)\\n```\\nconst findNonMinOrMax = function(nums) {\\n    if(nums.length <= 2) return -1;\\n    nums = nums.sort((a,b) => a-b);\\n    return nums[1];\\n};\\n```\\n\\n\\n## Long Method (Beats 100% Faster)\\n```\\nconst getMin = (arr) => {\\n  let min = arr[0];\\n  for(let i=1;i<arr.length;i++){\\n    if(min < arr[i]) min = arr[i];\\n  }\\n  return min;\\n}\\n\\nconst getMax = (arr) => {\\n let max = arr[0];\\n  for(let i=1;i<arr.length;i++){\\n    if(max > arr[i]) max = arr[i];\\n  }\\n  return max;\\n}\\n\\nconst findNonMinOrMax = function(nums) {\\n  if(nums.length <= 2) return -1;\\n  let min = getMin(nums), max = getMax(nums);\\n  for(let i=0;i<nums.length;i++){\\n    if(nums[i] !== max && nums[i] !== min) return nums[i];\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nconst findNonMinOrMax = function(nums) {\\n    if(nums.length <= 2) return -1;\\n    nums = nums.sort((a,b) => a-b);\\n    return nums[1];\\n};\\n```\n```\\nconst getMin = (arr) => {\\n  let min = arr[0];\\n  for(let i=1;i<arr.length;i++){\\n    if(min < arr[i]) min = arr[i];\\n  }\\n  return min;\\n}\\n\\nconst getMax = (arr) => {\\n let max = arr[0];\\n  for(let i=1;i<arr.length;i++){\\n    if(max > arr[i]) max = arr[i];\\n  }\\n  return max;\\n}\\n\\nconst findNonMinOrMax = function(nums) {\\n  if(nums.length <= 2) return -1;\\n  let min = getMin(nums), max = getMax(nums);\\n  for(let i=0;i<nums.length;i++){\\n    if(nums[i] !== max && nums[i] !== min) return nums[i];\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4037346,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findNonMinOrMax(self, nums: List[int]) -> int:\\n        if len(nums)<=2:\\n            return -1\\n        else:\\n            nums.sort()\\n            return nums[1]\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findNonMinOrMax(self, nums: List[int]) -> int:\\n        if len(nums)<=2:\\n            return -1\\n        else:\\n            nums.sort()\\n            return nums[1]\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4034779,
                "title": "js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findNonMinOrMax = function(nums) {\\n    nums=nums.sort((a,b)=>a-b);\\n    if(nums.length>2)\\n    return nums[1];\\n    else\\n    return -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findNonMinOrMax = function(nums) {\\n    nums=nums.sort((a,b)=>a-b);\\n    if(nums.length>2)\\n    return nums[1];\\n    else\\n    return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4031104,
                "title": "",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        Arrays.sort(nums);\\n         \\n        for(int i=1; i<nums.length-1; i++){\\n           return nums[i];\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        Arrays.sort(nums);\\n         \\n        for(int i=1; i<nums.length-1; i++){\\n           return nums[i];\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4024780,
                "title": "java-o-n-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        int maxn = Integer.MIN_VALUE;\\n        int minn = Integer.MAX_VALUE;\\n        for(int num: nums){\\n           maxn = Math.max(maxn, num);\\n           minn = Math.min(minn, num);\\n        }\\n        for(int num: nums){\\n            if(num != maxn && num != minn){\\n                return num;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        int maxn = Integer.MIN_VALUE;\\n        int minn = Integer.MAX_VALUE;\\n        for(int num: nums){\\n           maxn = Math.max(maxn, num);\\n           minn = Math.min(minn, num);\\n        }\\n        for(int num: nums){\\n            if(num != maxn && num != minn){\\n                return num;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023707,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        if(nums.length <= 2){\\n            return -1;\\n        }\\n        Arrays.sort(nums);\\n        return nums[nums.length/2];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        if(nums.length <= 2){\\n            return -1;\\n        }\\n        Arrays.sort(nums);\\n        return nums[nums.length/2];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022444,
                "title": "2-lines-simple-and-easy-to-understand-solution-in-c-beats-100-users-of-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        if(nums.size()<=2) return -1; else return nums[1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        if(nums.size()<=2) return -1; else return nums[1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4021837,
                "title": "easy-c-code-easy-approach-linear-time-using-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        int max=INT_MIN;\\n        int  min=INT_MAX;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>max){\\n                max=nums[i];\\n            }\\n        }\\n        for(int i=0;i<nums.size();i++){\\n             if(nums[i]<min){\\n                min=nums[i];\\n            }\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=min &&  nums[i]!=max){\\n                return nums[i];\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        int max=INT_MIN;\\n        int  min=INT_MAX;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]>max){\\n                max=nums[i];\\n            }\\n        }\\n        for(int i=0;i<nums.size();i++){\\n             if(nums[i]<min){\\n                min=nums[i];\\n            }\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]!=min &&  nums[i]!=max){\\n                return nums[i];\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4021144,
                "title": "easy-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        \\n        if(nums.length<=2){\\n            return -1;\\n        }\\n        Arrays.sort(nums);\\n        return nums[nums.length/2];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        \\n        if(nums.length<=2){\\n            return -1;\\n        }\\n        Arrays.sort(nums);\\n        return nums[nums.length/2];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4013410,
                "title": "neither-minimum-nor-maximum-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findNonMinOrMax(self, nums: List[int]) -> int:\\n        nums.sort()\\n        if len(nums)>2:\\n            return nums[1]\\n        else:\\n            return -1\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findNonMinOrMax(self, nums: List[int]) -> int:\\n        nums.sort()\\n        if len(nums)>2:\\n            return nums[1]\\n        else:\\n            return -1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012773,
                "title": "neither-minimum-nor-maximum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n       Arrays.sort(nums);\\n       if(nums.length<3){\\n           return -1;\\n       }\\n       return nums[1];\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n       Arrays.sort(nums);\\n       if(nums.length<3){\\n           return -1;\\n       }\\n       return nums[1];\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006613,
                "title": "c-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& arr) \\n    {\\n        if(arr.size() < 3)\\n            return -1;\\n        if(arr[0] < arr[1])\\n        {\\n            if(arr[2] < arr[0])\\n                return arr[0];\\n            if(arr[2] > arr[1])\\n                return arr[1];\\n            return arr[2];\\n        }\\n        else\\n        {\\n            if(arr[2] < arr[1])\\n                return arr[1];\\n            if(arr[2] > arr[0])\\n                return arr[0];\\n            return arr[2];\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& arr) \\n    {\\n        if(arr.size() < 3)\\n            return -1;\\n        if(arr[0] < arr[1])\\n        {\\n            if(arr[2] < arr[0])\\n                return arr[0];\\n            if(arr[2] > arr[1])\\n                return arr[1];\\n            return arr[2];\\n        }\\n        else\\n        {\\n            if(arr[2] < arr[1])\\n                return arr[1];\\n            if(arr[2] > arr[0])\\n                return arr[0];\\n            return arr[2];\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4004828,
                "title": "java-solution-4-line-code-shortcut-method",
                "content": "\\n# Intuition:\\nThe problem asks for finding a non-minimum and non-maximum element in the given array.\\n\\n# Approach:\\n1. Check if the array length is less than or equal to 2. If so, return -1 as there won\\'t be a valid answer.\\n2. Sort the array in ascending order.\\n3. The second element (index 1) in the sorted array will be the non-minimum element.\\n4. Return the non-minimum element.\\n\\n# Complexity:\\n- *Time complexity*: O(nlogn) due to the sorting operation, where n is the length of the input array.\\n- *Space complexity*: O(1), as no additional data structures are used.\\n\\n# Code:\\n```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        if(nums.length <= 2)\\n            return -1;\\n        Arrays.sort(nums);\\n        return nums[1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        if(nums.length <= 2)\\n            return -1;\\n        Arrays.sort(nums);\\n        return nums[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4002474,
                "title": "o-n-solution-easy-java-c-solution-one-itration",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n     public int findNonMinOrMax(int[] nums) {\\n        int ans = 0, min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;\\n        for (int i = 0; i < nums.length; i++) {\\n            int n=nums[i];\\n            if(n>max){\\n                max=n;\\n            }\\n            if(n<min){\\n                min=n;\\n            }\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            int n=nums[i];\\n            if(n!=min && n!=max){\\n                ans=nums[i];\\n                break;\\n            }\\n        }\\n\\n        return nums.length <= 2 ? -1 : ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n     public int findNonMinOrMax(int[] nums) {\\n        int ans = 0, min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;\\n        for (int i = 0; i < nums.length; i++) {\\n            int n=nums[i];\\n            if(n>max){\\n                max=n;\\n            }\\n            if(n<min){\\n                min=n;\\n            }\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            int n=nums[i];\\n            if(n!=min && n!=max){\\n                ans=nums[i];\\n                break;\\n            }\\n        }\\n\\n        return nums.length <= 2 ? -1 : ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4002216,
                "title": "c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        int mx = *max_element(nums.begin(),nums.end());\\n        int mn = *min_element(nums.begin(),nums.end());\\n        for(auto num: nums){\\n            if(num!=mx && num!=mn) return num;\\n        }\\n        return -1;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        int mx = *max_element(nums.begin(),nums.end());\\n        int mn = *min_element(nums.begin(),nums.end());\\n        for(auto num: nums){\\n            if(num!=mx && num!=mn) return num;\\n        }\\n        return -1;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001376,
                "title": "using-sorting-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n       int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        if(n>2)\\n        {\\n            return nums[1];\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n       int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        if(n>2)\\n        {\\n            return nums[1];\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001142,
                "title": "c",
                "content": "class Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        if(nums.size()<=2){\\n            return -1;\\n        }\\n        return nums[1];\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        if(nums.size()<=2){\\n            return -1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4000981,
                "title": "beginner-friendly-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        int min=Integer.MAX_VALUE;\\n        int max=0;\\n        for(int i=0;i<nums.length;i++){\\n          max=Math.max(max,nums[i]);\\n          min=Math.min(min,nums[i]);\\n        }\\n        int ans=-1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]!=max && nums[i]!=min){\\n                ans=nums[i];\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        int min=Integer.MAX_VALUE;\\n        int max=0;\\n        for(int i=0;i<nums.length;i++){\\n          max=Math.max(max,nums[i]);\\n          min=Math.min(min,nums[i]);\\n        }\\n        int ans=-1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]!=max && nums[i]!=min){\\n                ans=nums[i];\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4000523,
                "title": "easiest-method-in-java-without-loops",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n    Sort the array and return the nums[1] value which will be the frist one greater than the min value and lesser than the maximum value\\n\\n# Complexity\\n- Time complexity:\\n    o(nlogn) as Arrays.sort() takes that.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        if(nums.length<=2) return -1;\\n        Arrays.sort(nums);\\n        return nums[1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        if(nums.length<=2) return -1;\\n        Arrays.sort(nums);\\n        return nums[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999092,
                "title": "simplest-sleekest-o-1-method-explained",
                "content": "# Intuition\\nIf the numbers are distinct, and we are looking for ANY number that is neither the minimum nor the maxinum number, we just have to make sure that the number is in between ANY two numbers, as that must imply it is neither the minimum and maximum\\n\\n# Approach\\nWe look at only the first three numbers and find the middle number of the three. \\n\\n- Time complexity and Space complexity\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def findNonMinOrMax(self, nums: List[int]) -> int:\\n        # If there are not at least 3 distinct numbers, there can not be a middle number.\\n        if len(nums) < 3: return -1\\n        # Find the smallest and largest number of the first three numbers O(1)\\n        mmin, mmax = min(nums[:3]), max(nums[:3])\\n        # As the numbers are distinct, in the first three numbers, there must exist a number between the min and max of the first three numbers\\n        for num in nums[:3]: \\n            if mmin < num < mmax: return num\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findNonMinOrMax(self, nums: List[int]) -> int:\\n        # If there are not at least 3 distinct numbers, there can not be a middle number.\\n        if len(nums) < 3: return -1\\n        # Find the smallest and largest number of the first three numbers O(1)\\n        mmin, mmax = min(nums[:3]), max(nums[:3])\\n        # As the numbers are distinct, in the first three numbers, there must exist a number between the min and max of the first three numbers\\n        for num in nums[:3]: \\n            if mmin < num < mmax: return num\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998275,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        Arrays.sort(nums);\\n        if(nums.length<=2){\\n            return -1;\\n        }\\n        return nums[1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        Arrays.sort(nums);\\n        if(nums.length<=2){\\n            return -1;\\n        }\\n        return nums[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3997122,
                "title": "easy-cpp-beats-98",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        if(nums.size()<=2)\\n        {\\n            return -1;\\n        }\\n        return nums[1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        if(nums.size()<=2)\\n        {\\n            return -1;\\n        }\\n        return nums[1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3992455,
                "title": "c-solution-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans;\\n        if(nums.size() == 2) return -1;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i] > nums[0] && nums[i] < nums[nums.size()-1]){\\n                ans = nums[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans;\\n        if(nums.size() == 2) return -1;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i] > nums[0] && nums[i] < nums[nums.size()-1]){\\n                ans = nums[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3992118,
                "title": "easy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findNonMinOrMax(self, nums: List[int]) -> int:\\n        \\n        nums.sort()\\n\\n        while len(nums) > 2:\\n            return nums[1]\\n        return -1 \\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findNonMinOrMax(self, nums: List[int]) -> int:\\n        \\n        nums.sort()\\n\\n        while len(nums) > 2:\\n            return nums[1]\\n        return -1 \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991722,
                "title": "intuitive-easiest-solution-in-java-with-explanation",
                "content": "# Intuition\\nFirst idea - to breeze through array find max and min and delete them.\\n\\n# Approach\\nThen, remembered about existing Arrays.sort(int[]) and the need for the \"for + if\" construct is eliminated. Ok, go on. Now in our array we have min at the first place and max at the end. From the problem - we need ANY elements EXCEPT min and max. In my case, I am taking the second element of the array. We return \\'-1\\' if the length of the array is less than 2, because if we had only two elements, it must be min and max and there are no other elements there.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n log n)$$ - if n > 2 \\n$$O(1)$$ - if n <= 2 || array already sorted\\n\\n- Space complexity:\\n$$O(n log n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        <!--  -->\\n        Arrays.sort(nums); //from [3, 5, 1] to [1, 3, 5]\\n        if(nums.length <= 2) return -1; //if sorted array = [1, 2] then our max = 2 and min = 1 and no other elements so return -1\\n        else return nums[1]; // return next element after first - \"3\"\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        <!--  -->\\n        Arrays.sort(nums); //from [3, 5, 1] to [1, 3, 5]\\n        if(nums.length <= 2) return -1; //if sorted array = [1, 2] then our max = 2 and min = 1 and no other elements so return -1\\n        else return nums[1]; // return next element after first - \"3\"\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3987422,
                "title": "easy-js-solution",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findNonMinOrMax = function(nums) {\\n\\n    if (nums.length <= 2) return -1\\n\\n    nums.sort((a,b) => a - b)[1]\\n\\n    return nums[1]\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findNonMinOrMax = function(nums) {\\n\\n    if (nums.length <= 2) return -1\\n\\n    nums.sort((a,b) => a - b)[1]\\n\\n    return nums[1]\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3986913,
                "title": "elixir-simple-solution",
                "content": "```\\ndefmodule Solution do\\n  @spec find_non_min_or_max(nums :: [integer]) :: integer\\n  def find_non_min_or_max(nums) do\\n    nums = Enum.take(nums, 3)\\n\\n    if length(nums) < 3 do\\n      -1\\n    else\\n      [_, a, _] = Enum.sort(nums)\\n      a\\n    end\\n  end\\nend\\n\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```\\ndefmodule Solution do\\n  @spec find_non_min_or_max(nums :: [integer]) :: integer\\n  def find_non_min_or_max(nums) do\\n    nums = Enum.take(nums, 3)\\n\\n    if length(nums) < 3 do\\n      -1\\n    else\\n      [_, a, _] = Enum.sort(nums)\\n      a\\n    end\\n  end\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3985093,
                "title": "typescript-solution",
                "content": "```ts\\nfunction findNonMinOrMax(nums: number[]): number {\\n    if(nums.length < 3) return -1;\\n    const sortArr = nums.sort((a,b) => a - b);\\n    return sortArr[1];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```ts\\nfunction findNonMinOrMax(nums: number[]): number {\\n    if(nums.length < 3) return -1;\\n    const sortArr = nums.sort((a,b) => a - b);\\n    return sortArr[1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3980200,
                "title": "solution-involving-single-parse-of-the-vector",
                "content": "# Intuition\\nIf the array has more than 2 elements, there will be a solution among those three elements. Hence in essence we should only need to parse the first three elements of the array. Moreover we do not need to find the global maxima or minima. Whatever the global maxima and minima be, the window between local maxima and minima would only widen with more elements being parsed. Therefore we just set the local maxima and minima among the first two elements, and we can get the solution by comparing the third element among them with the local maxima and minima.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Please upvote if found useful\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        int max = nums[0];\\n        int min = nums[0];\\n        for(int i = 1; i < nums.size(); i++){\\n            if (nums[i] > max){\\n                if(max!=min) return max;\\n                max = nums[i];\\n            }\\n            else if (nums[i] < min){\\n                if(max!=min) return min;\\n                min = nums[i];\\n            }\\n            else return nums[i];\\n        }\\n        return -1;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        int max = nums[0];\\n        int min = nums[0];\\n        for(int i = 1; i < nums.size(); i++){\\n            if (nums[i] > max){\\n                if(max!=min) return max;\\n                max = nums[i];\\n            }\\n            else if (nums[i] < min){\\n                if(max!=min) return min;\\n                min = nums[i];\\n            }\\n            else return nums[i];\\n        }\\n        return -1;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974803,
                "title": "pyton3-solution",
                "content": "```\\nclass Solution:\\n    def findNonMinOrMax(self, nums: List[int]) -> int:\\n        a = list(set(nums))\\n        r=-1\\n        if len(a)<3:\\n            return r\\n        else:\\n            a.remove(max(a))\\n            a.remove(min(a))\\n            return a[0]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findNonMinOrMax(self, nums: List[int]) -> int:\\n        a = list(set(nums))\\n        r=-1\\n        if len(a)<3:\\n            return r\\n        else:\\n            a.remove(max(a))\\n            a.remove(min(a))\\n            return a[0]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3972258,
                "title": "neither-minimum-nor-maximum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1);\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        int num=0;\\n\\n        if(nums.size() > 2)\\n        {\\n            sort(nums.begin(),nums.end());\\n\\n            num=nums[1];\\n\\n        }\\n        else\\n        {\\n            return -1;\\n        }\\n        return num;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        int num=0;\\n\\n        if(nums.size() > 2)\\n        {\\n            sort(nums.begin(),nums.end());\\n\\n            num=nums[1];\\n\\n        }\\n        else\\n        {\\n            return -1;\\n        }\\n        return num;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3968020,
                "title": "heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        priority_queue<int>pq;\\n        for(auto it:nums)\\n        {\\n            pq.push(it);\\n        }\\n        pq.pop();\\n        if(pq.size()>1)\\n        return pq.top();\\n      \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        priority_queue<int>pq;\\n        for(auto it:nums)\\n        {\\n            pq.push(it);\\n        }\\n        pq.pop();\\n        if(pq.size()>1)\\n        return pq.top();\\n      \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3964217,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        Arrays.sort(nums);\\n        int n=nums.length;\\n        if(n==0 ||n==1||n==2)\\n        return -1;\\n        else if(nums[n/2]!=nums[0] && nums[n/2]!=nums[n-1])\\n        return nums[n/2];\\n        else\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        Arrays.sort(nums);\\n        int n=nums.length;\\n        if(n==0 ||n==1||n==2)\\n        return -1;\\n        else if(nums[n/2]!=nums[0] && nums[n/2]!=nums[n-1])\\n        return nums[n/2];\\n        else\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3961177,
                "title": "easiest-c-solution-3-lines-of-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        if(nums.size()==2 || nums.size()==1)\\n        return -1;\\n        else\\n        return nums[1]; \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        if(nums.size()==2 || nums.size()==1)\\n        return -1;\\n        else\\n        return nums[1]; \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954425,
                "title": "another-o-n-approach-c-p",
                "content": "# Intuition\\nAfter solving this problem by sorting it and returning the second element which was of O(nlogn) time complexity, I thought priority queue can return me largest element much faster. Thus I just have to return the number next to the largest number.\\n\\n# Approach\\nAs we need to return a number which is neither min nor max, so there must be minimum of three number like (min_num, x, max_num).\\nThis algo checks if len(num) is less than 3. If its true then it will return -1.\\nOtherwise it will initialize a priority queue by inserting elements from vector nums. This requires O(n) time complexity and O(n) space complexity(if I\\'m not wrong).\\nThen we will pop the first element from the heap because we dont need the max element from the heap which is O(log(n)).\\nWe will return the next max element which is the ans that requires time complexity of  O(1). <!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Total time taken would be O(n) + O(log(n)) + O(1).\\n- But as O(n) grows faster than other complexities here, so the time complexity would be O(n).\\n\\n- Space complexity: O(n)\\n- Total space would be O(n) + constants.\\n- So the space complexity would be O(n). \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        if(nums.size() < 3) return -1;\\n        priority_queue<int> numHeap(nums.begin(), nums.end());\\n        numHeap.pop();\\n        return numHeap.top();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        if(nums.size() < 3) return -1;\\n        priority_queue<int> numHeap(nums.begin(), nums.end());\\n        numHeap.pop();\\n        return numHeap.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953180,
                "title": "3-line-of-code-o-nlog-n-beats-98-35-in-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nsort using sort pre-defined function.\\n\\n# Complexity\\n- Time complexity:\\n SORT pre-defined funtion - O(Nlog(N))\\n\\n- Space complexity:\\n0(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        if(nums.size() < 3) return -1;\\n        sort(nums.begin(),nums.end());\\n        return nums[1];  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        if(nums.size() < 3) return -1;\\n        sort(nums.begin(),nums.end());\\n        return nums[1];  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951504,
                "title": "neither-minimum-nor-maximum",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        if(nums.length<3) return -1;\\n        Arrays.sort(nums);\\n        return nums[1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        if(nums.length<3) return -1;\\n        Arrays.sort(nums);\\n        return nums[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3950871,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        int n = nums.length;\\n        if(n < 3)\\n            return -1;\\n        Arrays.sort(nums);\\n        return nums[1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        int n = nums.length;\\n        if(n < 3)\\n            return -1;\\n        Arrays.sort(nums);\\n        return nums[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3950091,
                "title": "hehe",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def findNonMinOrMax(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n\\n        if len(nums)<=2:\\n            return -1\\n        \\n        nums.sort()\\n\\n        elements_except_min_max = nums[1:-1]\\n\\n        return elements_except_min_max[0]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findNonMinOrMax(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n\\n        if len(nums)<=2:\\n            return -1\\n        \\n        nums.sort()\\n\\n        elements_except_min_max = nums[1:-1]\\n\\n        return elements_except_min_max[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947375,
                "title": "one-liner",
                "content": "# Code\\n```\\nclass Solution:\\n    def findNonMinOrMax(self, nums: List[int]) -> int:\\n        return next((x for x in nums if x != min(nums) and x != max(nums)), -1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findNonMinOrMax(self, nums: List[int]) -> int:\\n        return next((x for x in nums if x != min(nums) and x != max(nums)), -1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3946945,
                "title": "python3-average-type-answer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findNonMinOrMax(self, nums: List[int]) -> int:\\n        a= min(nums)\\n        b= max(nums)\\n        for i in range(len(nums)):\\n            if nums[i] != a and nums[i] != b:\\n                return nums[i]\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findNonMinOrMax(self, nums: List[int]) -> int:\\n        a= min(nums)\\n        b= max(nums)\\n        for i in range(len(nums)):\\n            if nums[i] != a and nums[i] != b:\\n                return nums[i]\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3945361,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n//         int min=nums[0];\\n//         int max=nums[0];\\n//         int ans=-1;\\n//         for(int i=0;i<nums.length;i++){\\n//             if(nums[i]>max){\\n//           max=nums[i];\\n//             }\\n//             if(nums[i]<min){\\n//                 min=nums[i];\\n//             }\\n//         }\\n//         for(int i=0;i<nums.length;i++){\\n//             if(nums[i]!=min && nums[i]!=max){\\n//                  ans= nums[i];\\n//             }\\n//         }\\n// return ans;\\n\\n\\nint ans=-1;\\nArrays.sort(nums);\\nint min=nums[0];\\nint max=nums[nums.length-1];\\nfor(int i=1;i<nums.length;i++){\\n            if(nums[i]!=min && nums[i]!=max){\\n                 ans= nums[i];\\n                 break;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n//         int min=nums[0];\\n//         int max=nums[0];\\n//         int ans=-1;\\n//         for(int i=0;i<nums.length;i++){\\n//             if(nums[i]>max){\\n//           max=nums[i];\\n//             }\\n//             if(nums[i]<min){\\n//                 min=nums[i];\\n//             }\\n//         }\\n//         for(int i=0;i<nums.length;i++){\\n//             if(nums[i]!=min && nums[i]!=max){\\n//                  ans= nums[i];\\n//             }\\n//         }\\n// return ans;\\n\\n\\nint ans=-1;\\nArrays.sort(nums);\\nint min=nums[0];\\nint max=nums[nums.length-1];\\nfor(int i=1;i<nums.length;i++){\\n            if(nums[i]!=min && nums[i]!=max){\\n                 ans= nums[i];\\n                 break;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944411,
                "title": "simplest-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        int max=INT_MIN;\\n  int min=INT_MAX;\\n  int val=-1;\\n  for(int i=0;i<nums.size();i++){\\n      if(nums[i]>max){\\n        max=nums[i];\\n      }\\n  }\\n    for(int i=0;i<nums.size();i++){\\n      if(nums[i]<min){\\n        min=nums[i];\\n      }\\n    }\\n  for(int i=0;i<nums.size();i++){\\n    if(nums[i]!=max && nums[i]!=min){\\n      val=nums[i];\\n      break;\\n    }    \\n    \\n}\\n  return val;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        int max=INT_MIN;\\n  int min=INT_MAX;\\n  int val=-1;\\n  for(int i=0;i<nums.size();i++){\\n      if(nums[i]>max){\\n        max=nums[i];\\n      }\\n  }\\n    for(int i=0;i<nums.size();i++){\\n      if(nums[i]<min){\\n        min=nums[i];\\n      }\\n    }\\n  for(int i=0;i<nums.size();i++){\\n    if(nums[i]!=max && nums[i]!=min){\\n      val=nums[i];\\n      break;\\n    }    \\n    \\n}\\n  return val;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943952,
                "title": "simple-solution-that-beats-94-users",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        int min = INT_MAX,max=INT_MIN;\\n        for(int i : nums)\\n        {\\n            if(i>max)\\n            {\\n                max = i;\\n            }\\n            if(i<min)\\n            {\\n                min = i;\\n            }\\n        }\\n        cout<<min<<endl;\\n        for(int i: nums)\\n        {\\n            if(i!=min && i!=max)\\n            {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        int min = INT_MAX,max=INT_MIN;\\n        for(int i : nums)\\n        {\\n            if(i>max)\\n            {\\n                max = i;\\n            }\\n            if(i<min)\\n            {\\n                min = i;\\n            }\\n        }\\n        cout<<min<<endl;\\n        for(int i: nums)\\n        {\\n            if(i!=min && i!=max)\\n            {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3941295,
                "title": "solution-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findNonMinOrMax(self, nums: List[int]) -> int:\\n        nums.sort()\\n        if len(nums) == 2 or len(nums) == 1:\\n            return -1\\n        return nums[len(nums)//2]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findNonMinOrMax(self, nums: List[int]) -> int:\\n        nums.sort()\\n        if len(nums) == 2 or len(nums) == 1:\\n            return -1\\n        return nums[len(nums)//2]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3940412,
                "title": "c-simple-and-easy-approach",
                "content": "# Intuition\\nGiven an integer array nums containing distinct positive integers, we have to find and return any number from the array that is neither the minimum nor the maximum value in the array, or -1 if there is no such number.\\n\\n# Approach\\nWe initialize min and max with value of nums[0], we then run for loop on nums and get the min and max values, we then run another loop where we check if any element is such that it is neither min nor max, if that is the case we return that element, otherwise if such an element is not found we return -1.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        int min = nums[0];\\n        int max = nums[0];\\n        for(int i=1; i<nums.size(); i++)\\n        {\\n            if(nums[i]<min)\\n            {\\n                min = nums[i];\\n            }\\n            else if(nums[i]>max)\\n            {\\n                max = nums[i];\\n            }\\n        }\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i]!=min&&nums[i]!=max)\\n            {\\n                return nums[i];\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        int min = nums[0];\\n        int max = nums[0];\\n        for(int i=1; i<nums.size(); i++)\\n        {\\n            if(nums[i]<min)\\n            {\\n                min = nums[i];\\n            }\\n            else if(nums[i]>max)\\n            {\\n                max = nums[i];\\n            }\\n        }\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i]!=min&&nums[i]!=max)\\n            {\\n                return nums[i];\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939993,
                "title": "beats-99-in-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n\\t    return nums.length<3 ? -1 : Math.min(Math.max(Math.min(nums[0], nums[1]), nums[2]), Math.max(nums[0], nums[1]));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n\\t    return nums.length<3 ? -1 : Math.min(Math.max(Math.min(nums[0], nums[1]), nums[2]), Math.max(nums[0], nums[1]));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939868,
                "title": "python-solution-with-one-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nYou can think this problem as finding second maximum element in nums. If it\\'s not equal to min value then return it otherwise -1\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findNonMinOrMax(self, nums: List[int]) -> int:\\n\\n        mx = -1\\n        mn = 101\\n        ans = -1\\n        for v in nums:\\n            mn = min(mn, v)\\n            if v > mx:\\n                ans = mx\\n                mx = v\\n            else:\\n                ans = max(v, ans)\\n            if ans != -1 and ans != mn:\\n                return ans\\n        \\n        return -1\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findNonMinOrMax(self, nums: List[int]) -> int:\\n\\n        mx = -1\\n        mn = 101\\n        ans = -1\\n        for v in nums:\\n            mn = min(mn, v)\\n            if v > mx:\\n                ans = mx\\n                mx = v\\n            else:\\n                ans = max(v, ans)\\n            if ans != -1 and ans != mn:\\n                return ans\\n        \\n        return -1\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939500,
                "title": "look-at-the-question",
                "content": "\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        Arrays.sort(nums);\\n        int min = 0;\\n        if(nums.length==1){\\n            return -1;\\n        }else if(nums.length==2){\\n            return -1;\\n        }else if(nums.length%2==0){\\n            return nums[2];\\n        }else{\\n            return nums[nums.length/2];\\n        }\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        Arrays.sort(nums);\\n        int min = 0;\\n        if(nums.length==1){\\n            return -1;\\n        }else if(nums.length==2){\\n            return -1;\\n        }else if(nums.length%2==0){\\n            return nums[2];\\n        }else{\\n            return nums[nums.length/2];\\n        }\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938880,
                "title": "using-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n) && O(n*logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n// linear solution\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        if(nums.size()<=2)\\n         return -1;\\n\\n         int maxi = *max_element(nums.begin(), nums.end());\\n         int mini = *min_element(nums.begin(), nums.end());\\n         for(auto num : nums) {\\n             if(num != maxi && num != mini) {\\n                 return num;\\n             }\\n         }\\n         return -1;\\n    }\\n};\\n```\\n\\n```\\n// using sorting\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        if(nums.size()<=2)\\n         return -1;\\n        sort(nums.begin(), nums.end());\\n        for(int i=1;i<nums.size()-1;i++) {\\n            return nums[i];\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\n\\n// linear solution\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        if(nums.size()<=2)\\n         return -1;\\n\\n         int maxi = *max_element(nums.begin(), nums.end());\\n         int mini = *min_element(nums.begin(), nums.end());\\n         for(auto num : nums) {\\n             if(num != maxi && num != mini) {\\n                 return num;\\n             }\\n         }\\n         return -1;\\n    }\\n};\\n```\n```\\n// using sorting\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        if(nums.size()<=2)\\n         return -1;\\n        sort(nums.begin(), nums.end());\\n        for(int i=1;i<nums.size()-1;i++) {\\n            return nums[i];\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3937973,
                "title": "easy-solution-from-java-for-beginner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n         Arrays.sort(nums);\\n        int n=nums.length;\\n        if(n<=2){\\n            return -1;\\n        }\\n        int l=0;\\n        int h=n-1;\\n        int mid=(l+h)/2;\\n        return nums[mid];\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n         Arrays.sort(nums);\\n        int n=nums.length;\\n        if(n<=2){\\n            return -1;\\n        }\\n        int l=0;\\n        int h=n-1;\\n        int mid=(l+h)/2;\\n        return nums[mid];\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3937771,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nthis is the normal solution by applying the sorting of array and after that simply find out mid of the array\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        Arrays.sort(nums);\\n        int n= nums.length;\\n        if(n<=2){\\n            return -1;\\n        }\\n        int l=0;\\n        int h=n-1;\\n        int mid= (l+h)/2;\\n        return nums[mid];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        Arrays.sort(nums);\\n        int n= nums.length;\\n        if(n<=2){\\n            return -1;\\n        }\\n        int l=0;\\n        int h=n-1;\\n        int mid= (l+h)/2;\\n        return nums[mid];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3937580,
                "title": "python-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def findNonMinOrMax(self, nums: List[int]) -> int:\\n        nums = sorted(nums)\\n        if len(nums)<3:\\n            return -1\\n        return nums[len(nums)//2]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findNonMinOrMax(self, nums: List[int]) -> int:\\n        nums = sorted(nums)\\n        if len(nums)<3:\\n            return -1\\n        return nums[len(nums)//2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3934413,
                "title": "only-2-lines-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        Arrays.sort(nums);\\n        if(nums.length <= 2) return -1;\\n        return nums[1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        Arrays.sort(nums);\\n        if(nums.length <= 2) return -1;\\n        return nums[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928407,
                "title": "neither-minimum-nor-maximum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        if(nums.length <= 2)return -1;\\n        Arrays.sort(nums);\\n        return nums[1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        if(nums.length <= 2)return -1;\\n        Arrays.sort(nums);\\n        return nums[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3925813,
                "title": "o-1-solution-return-answer-using-first-three-elements-only",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince all elements are distinct, answer will be there in 1st three elements itself. Even if min and max are there in 1st three elements, the third element could be our answer\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Take the 1st three elements\\n- Sort the array\\n- Return the second element\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\nclass Solution:\\n    def findNonMinOrMax(self, nums: List[int]) -> int:\\n        if len(nums) < 3:\\n            return -1\\n        s = nums[:3]\\n        s.sort()\\n        return s[1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findNonMinOrMax(self, nums: List[int]) -> int:\\n        if len(nums) < 3:\\n            return -1\\n        s = nums[:3]\\n        s.sort()\\n        return s[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923724,
                "title": "easy-java-solution",
                "content": "```class Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        int min = nums[0];\\n        int max = nums[0];\\n        for(int num : nums) {\\n            min = Math.min(min,num);\\n            max = Math.max(max,num);\\n        }\\n        \\n        if(min == max)\\n            return -1;\\n        \\n        for(int num : nums) {\\n            if(min != num && max != num)\\n                return num;\\n        }\\n        return -1;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int findNonMinOrMax(int[] nums) {\\n        int min = nums[0];\\n        int max = nums[0];\\n        for(int num : nums) {\\n            min = Math.min(min,num);\\n            max = Math.max(max,num);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3922954,
                "title": "c-code-96-92-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        if(nums.size()<=2)\\n        return -1;\\n        sort(nums.begin(),nums.end());\\n        for(int i=1;i<nums.size();i++)\\n          if((nums[i]>nums[i-1])&&(nums[i]<nums[nums.size()-1]))\\n          return nums[i];\\n\\n          return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        if(nums.size()<=2)\\n        return -1;\\n        sort(nums.begin(),nums.end());\\n        for(int i=1;i<nums.size();i++)\\n          if((nums[i]>nums[i-1])&&(nums[i]<nums[nums.size()-1]))\\n          return nums[i];\\n\\n          return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3922776,
                "title": "easy-solution-in-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        if(n==1) return -1;\\n        else if (n==2) return -1;\\n        else return nums[1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        if(n==1) return -1;\\n        else if (n==2) return -1;\\n        else return nums[1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3922773,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        if(n==1) return -1;\\n        else if (n==2) return -1;\\n        else return nums[1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        if(n==1) return -1;\\n        else if (n==2) return -1;\\n        else return nums[1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3922074,
                "title": "fastest-solution-with-o-1-time-complexity",
                "content": "\\n# Approach\\nwe dont need traverse the whole array. Just sort the first 3 elements and nums[1] ie. second element will be your answer because it mentioned that array contains distinct elements.\\nif no of elements are less then 3 ans is always -1\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    Tc = O(1) because sorting first 3 elements take only constant time.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n <= 2)return -1;\\n        sort(nums.begin(),nums.begin() + 3);\\n        return nums[1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNonMinOrMax(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n <= 2)return -1;\\n        sort(nums.begin(),nums.begin() + 3);\\n        return nums[1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1940714,
                "content": [
                    {
                        "username": "nishant_singh_",
                        "content": "This is my first code which I have executed fully without any help, Mark my words I\\'ll be working in TOP MNCS in India in coming 2 years..."
                    },
                    {
                        "username": "user8675309",
                        "content": "[@Nishant singh](/nishant_singh_) Congrats man, you\\'re nearly two months in now. Still remember how you felt back when you solved this problem? :-)"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "[@Ayush10web](/Ayush10web) Agreed!!After 1 yr I have my campus placement,hope meh placed hojawu!!!"
                    },
                    {
                        "username": "Ayush10web",
                        "content": "Hope... but avi thand rakh bro bohot long journey hai ...all the best"
                    },
                    {
                        "username": "ninonick0426",
                        "content": "Good job! See you there in 2 years!"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You will definitely!"
                    },
                    {
                        "username": "lanfeust69",
                        "content": "Hint : when the hint is a verbatim repetition of the text, there should be no hint at all..."
                    },
                    {
                        "username": "ninonick0426",
                        "content": "lmao fr"
                    },
                    {
                        "username": "Gao481",
                        "content": "You only need to look at any 3 ints in this array, easy O(1) problem"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "That\\'s not even easy"
                    },
                    {
                        "username": "zaid81567",
                        "content": "<b><h2>Algorithm</b>\\n<ul>\\n<li>check if len(nums) < 3 -> Ture : return -1</li>\\n<li>else: sort the nums & return the 2nd indexed value -> nums[1] </li>\\n</ul>"
                    },
                    {
                        "username": "krevsunegor789",
                        "content": "\n\nHello. I'm starting to master such tasks. There are three arrays in the condition. I click run and everything works. He shows me three green buttons. And when I want to send the result, they show me a completely different array. What's it? [2,4 ,25]?"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "To solve this problem the easy approach \\nSort an array and return first index\\nhttps://leetcode.com/problems/neither-minimum-nor-maximum/solutions/3670469/best-solutio\\n"
                    },
                    {
                        "username": "sawang325",
                        "content": "Considering time complexity, sort is not a good solution."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Perhaps this type of problem has appeared too many times in the easy category?"
                    }
                ]
            },
            {
                "id": 1925861,
                "content": [
                    {
                        "username": "nishant_singh_",
                        "content": "This is my first code which I have executed fully without any help, Mark my words I\\'ll be working in TOP MNCS in India in coming 2 years..."
                    },
                    {
                        "username": "user8675309",
                        "content": "[@Nishant singh](/nishant_singh_) Congrats man, you\\'re nearly two months in now. Still remember how you felt back when you solved this problem? :-)"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "[@Ayush10web](/Ayush10web) Agreed!!After 1 yr I have my campus placement,hope meh placed hojawu!!!"
                    },
                    {
                        "username": "Ayush10web",
                        "content": "Hope... but avi thand rakh bro bohot long journey hai ...all the best"
                    },
                    {
                        "username": "ninonick0426",
                        "content": "Good job! See you there in 2 years!"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You will definitely!"
                    },
                    {
                        "username": "lanfeust69",
                        "content": "Hint : when the hint is a verbatim repetition of the text, there should be no hint at all..."
                    },
                    {
                        "username": "ninonick0426",
                        "content": "lmao fr"
                    },
                    {
                        "username": "Gao481",
                        "content": "You only need to look at any 3 ints in this array, easy O(1) problem"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "That\\'s not even easy"
                    },
                    {
                        "username": "zaid81567",
                        "content": "<b><h2>Algorithm</b>\\n<ul>\\n<li>check if len(nums) < 3 -> Ture : return -1</li>\\n<li>else: sort the nums & return the 2nd indexed value -> nums[1] </li>\\n</ul>"
                    },
                    {
                        "username": "krevsunegor789",
                        "content": "\n\nHello. I'm starting to master such tasks. There are three arrays in the condition. I click run and everything works. He shows me three green buttons. And when I want to send the result, they show me a completely different array. What's it? [2,4 ,25]?"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "To solve this problem the easy approach \\nSort an array and return first index\\nhttps://leetcode.com/problems/neither-minimum-nor-maximum/solutions/3670469/best-solutio\\n"
                    },
                    {
                        "username": "sawang325",
                        "content": "Considering time complexity, sort is not a good solution."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Perhaps this type of problem has appeared too many times in the easy category?"
                    }
                ]
            },
            {
                "id": 1955297,
                "content": [
                    {
                        "username": "nishant_singh_",
                        "content": "This is my first code which I have executed fully without any help, Mark my words I\\'ll be working in TOP MNCS in India in coming 2 years..."
                    },
                    {
                        "username": "user8675309",
                        "content": "[@Nishant singh](/nishant_singh_) Congrats man, you\\'re nearly two months in now. Still remember how you felt back when you solved this problem? :-)"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "[@Ayush10web](/Ayush10web) Agreed!!After 1 yr I have my campus placement,hope meh placed hojawu!!!"
                    },
                    {
                        "username": "Ayush10web",
                        "content": "Hope... but avi thand rakh bro bohot long journey hai ...all the best"
                    },
                    {
                        "username": "ninonick0426",
                        "content": "Good job! See you there in 2 years!"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You will definitely!"
                    },
                    {
                        "username": "lanfeust69",
                        "content": "Hint : when the hint is a verbatim repetition of the text, there should be no hint at all..."
                    },
                    {
                        "username": "ninonick0426",
                        "content": "lmao fr"
                    },
                    {
                        "username": "Gao481",
                        "content": "You only need to look at any 3 ints in this array, easy O(1) problem"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "That\\'s not even easy"
                    },
                    {
                        "username": "zaid81567",
                        "content": "<b><h2>Algorithm</b>\\n<ul>\\n<li>check if len(nums) < 3 -> Ture : return -1</li>\\n<li>else: sort the nums & return the 2nd indexed value -> nums[1] </li>\\n</ul>"
                    },
                    {
                        "username": "krevsunegor789",
                        "content": "\n\nHello. I'm starting to master such tasks. There are three arrays in the condition. I click run and everything works. He shows me three green buttons. And when I want to send the result, they show me a completely different array. What's it? [2,4 ,25]?"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "To solve this problem the easy approach \\nSort an array and return first index\\nhttps://leetcode.com/problems/neither-minimum-nor-maximum/solutions/3670469/best-solutio\\n"
                    },
                    {
                        "username": "sawang325",
                        "content": "Considering time complexity, sort is not a good solution."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Perhaps this type of problem has appeared too many times in the easy category?"
                    }
                ]
            },
            {
                "id": 1925808,
                "content": [
                    {
                        "username": "nishant_singh_",
                        "content": "This is my first code which I have executed fully without any help, Mark my words I\\'ll be working in TOP MNCS in India in coming 2 years..."
                    },
                    {
                        "username": "user8675309",
                        "content": "[@Nishant singh](/nishant_singh_) Congrats man, you\\'re nearly two months in now. Still remember how you felt back when you solved this problem? :-)"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "[@Ayush10web](/Ayush10web) Agreed!!After 1 yr I have my campus placement,hope meh placed hojawu!!!"
                    },
                    {
                        "username": "Ayush10web",
                        "content": "Hope... but avi thand rakh bro bohot long journey hai ...all the best"
                    },
                    {
                        "username": "ninonick0426",
                        "content": "Good job! See you there in 2 years!"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You will definitely!"
                    },
                    {
                        "username": "lanfeust69",
                        "content": "Hint : when the hint is a verbatim repetition of the text, there should be no hint at all..."
                    },
                    {
                        "username": "ninonick0426",
                        "content": "lmao fr"
                    },
                    {
                        "username": "Gao481",
                        "content": "You only need to look at any 3 ints in this array, easy O(1) problem"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "That\\'s not even easy"
                    },
                    {
                        "username": "zaid81567",
                        "content": "<b><h2>Algorithm</b>\\n<ul>\\n<li>check if len(nums) < 3 -> Ture : return -1</li>\\n<li>else: sort the nums & return the 2nd indexed value -> nums[1] </li>\\n</ul>"
                    },
                    {
                        "username": "krevsunegor789",
                        "content": "\n\nHello. I'm starting to master such tasks. There are three arrays in the condition. I click run and everything works. He shows me three green buttons. And when I want to send the result, they show me a completely different array. What's it? [2,4 ,25]?"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "To solve this problem the easy approach \\nSort an array and return first index\\nhttps://leetcode.com/problems/neither-minimum-nor-maximum/solutions/3670469/best-solutio\\n"
                    },
                    {
                        "username": "sawang325",
                        "content": "Considering time complexity, sort is not a good solution."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Perhaps this type of problem has appeared too many times in the easy category?"
                    }
                ]
            },
            {
                "id": 2016420,
                "content": [
                    {
                        "username": "nishant_singh_",
                        "content": "This is my first code which I have executed fully without any help, Mark my words I\\'ll be working in TOP MNCS in India in coming 2 years..."
                    },
                    {
                        "username": "user8675309",
                        "content": "[@Nishant singh](/nishant_singh_) Congrats man, you\\'re nearly two months in now. Still remember how you felt back when you solved this problem? :-)"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "[@Ayush10web](/Ayush10web) Agreed!!After 1 yr I have my campus placement,hope meh placed hojawu!!!"
                    },
                    {
                        "username": "Ayush10web",
                        "content": "Hope... but avi thand rakh bro bohot long journey hai ...all the best"
                    },
                    {
                        "username": "ninonick0426",
                        "content": "Good job! See you there in 2 years!"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You will definitely!"
                    },
                    {
                        "username": "lanfeust69",
                        "content": "Hint : when the hint is a verbatim repetition of the text, there should be no hint at all..."
                    },
                    {
                        "username": "ninonick0426",
                        "content": "lmao fr"
                    },
                    {
                        "username": "Gao481",
                        "content": "You only need to look at any 3 ints in this array, easy O(1) problem"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "That\\'s not even easy"
                    },
                    {
                        "username": "zaid81567",
                        "content": "<b><h2>Algorithm</b>\\n<ul>\\n<li>check if len(nums) < 3 -> Ture : return -1</li>\\n<li>else: sort the nums & return the 2nd indexed value -> nums[1] </li>\\n</ul>"
                    },
                    {
                        "username": "krevsunegor789",
                        "content": "\n\nHello. I'm starting to master such tasks. There are three arrays in the condition. I click run and everything works. He shows me three green buttons. And when I want to send the result, they show me a completely different array. What's it? [2,4 ,25]?"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "To solve this problem the easy approach \\nSort an array and return first index\\nhttps://leetcode.com/problems/neither-minimum-nor-maximum/solutions/3670469/best-solutio\\n"
                    },
                    {
                        "username": "sawang325",
                        "content": "Considering time complexity, sort is not a good solution."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Perhaps this type of problem has appeared too many times in the easy category?"
                    }
                ]
            },
            {
                "id": 2008151,
                "content": [
                    {
                        "username": "nishant_singh_",
                        "content": "This is my first code which I have executed fully without any help, Mark my words I\\'ll be working in TOP MNCS in India in coming 2 years..."
                    },
                    {
                        "username": "user8675309",
                        "content": "[@Nishant singh](/nishant_singh_) Congrats man, you\\'re nearly two months in now. Still remember how you felt back when you solved this problem? :-)"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "[@Ayush10web](/Ayush10web) Agreed!!After 1 yr I have my campus placement,hope meh placed hojawu!!!"
                    },
                    {
                        "username": "Ayush10web",
                        "content": "Hope... but avi thand rakh bro bohot long journey hai ...all the best"
                    },
                    {
                        "username": "ninonick0426",
                        "content": "Good job! See you there in 2 years!"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You will definitely!"
                    },
                    {
                        "username": "lanfeust69",
                        "content": "Hint : when the hint is a verbatim repetition of the text, there should be no hint at all..."
                    },
                    {
                        "username": "ninonick0426",
                        "content": "lmao fr"
                    },
                    {
                        "username": "Gao481",
                        "content": "You only need to look at any 3 ints in this array, easy O(1) problem"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "That\\'s not even easy"
                    },
                    {
                        "username": "zaid81567",
                        "content": "<b><h2>Algorithm</b>\\n<ul>\\n<li>check if len(nums) < 3 -> Ture : return -1</li>\\n<li>else: sort the nums & return the 2nd indexed value -> nums[1] </li>\\n</ul>"
                    },
                    {
                        "username": "krevsunegor789",
                        "content": "\n\nHello. I'm starting to master such tasks. There are three arrays in the condition. I click run and everything works. He shows me three green buttons. And when I want to send the result, they show me a completely different array. What's it? [2,4 ,25]?"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "To solve this problem the easy approach \\nSort an array and return first index\\nhttps://leetcode.com/problems/neither-minimum-nor-maximum/solutions/3670469/best-solutio\\n"
                    },
                    {
                        "username": "sawang325",
                        "content": "Considering time complexity, sort is not a good solution."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Perhaps this type of problem has appeared too many times in the easy category?"
                    }
                ]
            },
            {
                "id": 1940040,
                "content": [
                    {
                        "username": "nishant_singh_",
                        "content": "This is my first code which I have executed fully without any help, Mark my words I\\'ll be working in TOP MNCS in India in coming 2 years..."
                    },
                    {
                        "username": "user8675309",
                        "content": "[@Nishant singh](/nishant_singh_) Congrats man, you\\'re nearly two months in now. Still remember how you felt back when you solved this problem? :-)"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "[@Ayush10web](/Ayush10web) Agreed!!After 1 yr I have my campus placement,hope meh placed hojawu!!!"
                    },
                    {
                        "username": "Ayush10web",
                        "content": "Hope... but avi thand rakh bro bohot long journey hai ...all the best"
                    },
                    {
                        "username": "ninonick0426",
                        "content": "Good job! See you there in 2 years!"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You will definitely!"
                    },
                    {
                        "username": "lanfeust69",
                        "content": "Hint : when the hint is a verbatim repetition of the text, there should be no hint at all..."
                    },
                    {
                        "username": "ninonick0426",
                        "content": "lmao fr"
                    },
                    {
                        "username": "Gao481",
                        "content": "You only need to look at any 3 ints in this array, easy O(1) problem"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "That\\'s not even easy"
                    },
                    {
                        "username": "zaid81567",
                        "content": "<b><h2>Algorithm</b>\\n<ul>\\n<li>check if len(nums) < 3 -> Ture : return -1</li>\\n<li>else: sort the nums & return the 2nd indexed value -> nums[1] </li>\\n</ul>"
                    },
                    {
                        "username": "krevsunegor789",
                        "content": "\n\nHello. I'm starting to master such tasks. There are three arrays in the condition. I click run and everything works. He shows me three green buttons. And when I want to send the result, they show me a completely different array. What's it? [2,4 ,25]?"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "To solve this problem the easy approach \\nSort an array and return first index\\nhttps://leetcode.com/problems/neither-minimum-nor-maximum/solutions/3670469/best-solutio\\n"
                    },
                    {
                        "username": "sawang325",
                        "content": "Considering time complexity, sort is not a good solution."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Perhaps this type of problem has appeared too many times in the easy category?"
                    }
                ]
            },
            {
                "id": 1926598,
                "content": [
                    {
                        "username": "nishant_singh_",
                        "content": "This is my first code which I have executed fully without any help, Mark my words I\\'ll be working in TOP MNCS in India in coming 2 years..."
                    },
                    {
                        "username": "user8675309",
                        "content": "[@Nishant singh](/nishant_singh_) Congrats man, you\\'re nearly two months in now. Still remember how you felt back when you solved this problem? :-)"
                    },
                    {
                        "username": "munu8998rai",
                        "content": "[@Ayush10web](/Ayush10web) Agreed!!After 1 yr I have my campus placement,hope meh placed hojawu!!!"
                    },
                    {
                        "username": "Ayush10web",
                        "content": "Hope... but avi thand rakh bro bohot long journey hai ...all the best"
                    },
                    {
                        "username": "ninonick0426",
                        "content": "Good job! See you there in 2 years!"
                    },
                    {
                        "username": "NishiTiwari5195",
                        "content": "You will definitely!"
                    },
                    {
                        "username": "lanfeust69",
                        "content": "Hint : when the hint is a verbatim repetition of the text, there should be no hint at all..."
                    },
                    {
                        "username": "ninonick0426",
                        "content": "lmao fr"
                    },
                    {
                        "username": "Gao481",
                        "content": "You only need to look at any 3 ints in this array, easy O(1) problem"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "That\\'s not even easy"
                    },
                    {
                        "username": "zaid81567",
                        "content": "<b><h2>Algorithm</b>\\n<ul>\\n<li>check if len(nums) < 3 -> Ture : return -1</li>\\n<li>else: sort the nums & return the 2nd indexed value -> nums[1] </li>\\n</ul>"
                    },
                    {
                        "username": "krevsunegor789",
                        "content": "\n\nHello. I'm starting to master such tasks. There are three arrays in the condition. I click run and everything works. He shows me three green buttons. And when I want to send the result, they show me a completely different array. What's it? [2,4 ,25]?"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "To solve this problem the easy approach \\nSort an array and return first index\\nhttps://leetcode.com/problems/neither-minimum-nor-maximum/solutions/3670469/best-solutio\\n"
                    },
                    {
                        "username": "sawang325",
                        "content": "Considering time complexity, sort is not a good solution."
                    },
                    {
                        "username": "qazFatNerd",
                        "content": "Perhaps this type of problem has appeared too many times in the easy category?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Count Substrings Without Repeating Character",
        "question_content": null,
        "solutions": [],
        "discussions": []
    },
    {
        "title": "Deep Merge of Two Objects",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 2044599,
                "content": [
                    {
                        "username": "janicezhong516",
                        "content": "I almost bang my head into the wall while dealing with type checking in this question"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "Please specify the expected order of keys in the resulting object."
                    },
                    {
                        "username": "calvinchankf",
                        "content": "As a dev for years, tbh dealing with null and undefined is always the pain in the ass"
                    }
                ]
            },
            {
                "id": 2005494,
                "content": [
                    {
                        "username": "janicezhong516",
                        "content": "I almost bang my head into the wall while dealing with type checking in this question"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "Please specify the expected order of keys in the resulting object."
                    },
                    {
                        "username": "calvinchankf",
                        "content": "As a dev for years, tbh dealing with null and undefined is always the pain in the ass"
                    }
                ]
            },
            {
                "id": 1953564,
                "content": [
                    {
                        "username": "janicezhong516",
                        "content": "I almost bang my head into the wall while dealing with type checking in this question"
                    },
                    {
                        "username": "nskybytskyi",
                        "content": "Please specify the expected order of keys in the resulting object."
                    },
                    {
                        "username": "calvinchankf",
                        "content": "As a dev for years, tbh dealing with null and undefined is always the pain in the ass"
                    }
                ]
            }
        ]
    },
    {
        "title": "Longest Alternating Subarray",
        "question_content": "<p>You are given a <strong>0-indexed</strong> integer array <code>nums</code>. A subarray <code>s</code> of length <code>m</code> is called <strong>alternating</strong> if:</p>\n\n<ul>\n\t<li><code>m</code> is greater than <code>1</code>.</li>\n\t<li><code>s<sub>1</sub> = s<sub>0</sub> + 1</code>.</li>\n\t<li>The <strong>0-indexed</strong> subarray <code>s</code> looks like <code>[s<sub>0</sub>, s<sub>1</sub>, s<sub>0</sub>, s<sub>1</sub>,...,s<sub>(m-1) % 2</sub>]</code>. In other words, <code>s<sub>1</sub> - s<sub>0</sub> = 1</code>, <code>s<sub>2</sub> - s<sub>1</sub> = -1</code>, <code>s<sub>3</sub> - s<sub>2</sub> = 1</code>, <code>s<sub>4</sub> - s<sub>3</sub> = -1</code>, and so on up to <code>s[m - 1] - s[m - 2] = (-1)<sup>m</sup></code>.</li>\n</ul>\n\n<p>Return <em>the maximum length of all <strong>alternating</strong> subarrays present in </em><code>nums</code> <em>or </em><code>-1</code><em> if no such subarray exists</em><em>.</em></p>\n\n<p>A subarray is a contiguous <strong>non-empty</strong> sequence of elements within an array.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,3,4,3,4]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> The alternating subarrays are [3,4], [3,4,3], and [3,4,3,4]. The longest of these is [3,4,3,4], which is of length 4.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [4,5,6]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> [4,5] and [5,6] are the only two alternating subarrays. They are both of length 2.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3737191,
                "title": "java-c-python-two-pointers-and-dp-solutions",
                "content": "# **Solution 0: Brute Force Check**\\n\\nSum up the equations\\n`s1 - s0 = 1`\\n`s2 - s1 = -1,`\\n`s3 - s2 = 1`\\nwe can have\\n`si - s0 = i % 2`\\n\\nSo for each `A[i]`,\\nfind the longest alternating subarray where `A[j] == A[i] + (j - i) % 2`\\n\\nThe length of alternating subarray is `j - i + 1`\\n\\nTime `O(n^2)`\\nSpace `O(1)`\\n\\n**Java**\\n```java\\n    public int alternatingSubarray(int[] A) {\\n        int n = A.length, res = 0, j = 0;\\n        for (int i = 0; i < n; ++i)\\n            for (j = i + 1; j < n && A[j] == A[i] + (j - i) % 2; ++j)\\n                res = Math.max(res, j - i + 1);\\n        return res > 1 ? res : -1;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int alternatingSubarray(vector<int>& A) {\\n        int n = A.size(), res = 0, j = 0;\\n        for (int i = 0; i < n; ++i)\\n            for (j = i + 1; j < n && A[j] == A[i] + (j - i) % 2; ++j)\\n                res = max(res, j - i + 1);\\n        return res > 1 ? res : -1;\\n    }\\n```\\n<br>\\n\\n# **Solution 1, Two Pointers**\\n\\nIn solution above,\\n`A[i], A[i + 1], ... , A[j - 1]` is alternating subarray\\nwe check subarray startting at `A[i + 1]` after `A[i]`.\\n\\nNoticed that two alternating arrays won\\'t overlap with more than 2 element:\\nFor example in `[1,2,1,2,3,2,3]`, \\n`[1,2,1,2]` and `[2,3,2,3]` overlap 2 elements.\\n\\nSo we don\\'t need to check subarray starting at `A[i + 1], A[i + 2]... A[j - 2]`\\nwe can start to check subarray from the last element in the alternating subarray.\\n\\nFor example,\\n`1,2,1,2,1,2,3`\\nwe can directly check the last `2` in the array.\\nSo we can solve this problem with 2 pointers.\\n\\n\\nTime `O(n)`\\nSpace `O(1)`\\n\\n**Java**\\n```java\\n    public int alternatingSubarray(int[] A) {\\n        int n = A.length, res = 0, j = 0;\\n        for (int i = 0; i < n; i = Math.max(i + 1, j - 1))\\n            for (j = i + 1; j < n && A[j] == A[i] + (j - i) % 2; ++j)\\n                res = Math.max(res, j - i + 1);\\n        return res > 1 ? res : -1;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int alternatingSubarray(vector<int>& A) {\\n        int n = A.size(), res = 0, j = 0;\\n        for (int i = 0; i < n; i = max(i + 1, j - 1))\\n            for (j = i + 1; j < n && A[j] == A[i] + (j - i) % 2; ++j)\\n                res = max(res, j - i + 1);\\n        return res > 1 ? res : -1;\\n    }\\n```\\n<br>\\n\\n# Solution 3, DP-like Solution\\n\\nIf `A[i] == A[i - 2]` and `dp[i - 1] > 0`\\nextends the alternatice subarray\\nthen `dp[i] = dp[i - 1] + 1`\\n\\nelse if `A[i] == A[i - 1] + 1`,\\nstarts the alternatice subarray\\n`dp[i] = 2`\\n\\nelse\\nnot in the alternatice subarray\\n`dp[i] = -1`\\n\\nTime `O(n)`\\nSpace `O(1)`\\n\\n\\n**Java**\\n```java\\n    public int alternatingSubarray(int[] A) {\\n        int n = A.length, res = -1, dp = -1;\\n        for (int i = 1; i < n; ++i, res = Math.max(res, dp))\\n            if (dp > 0 && A[i] == A[i - 2])\\n                dp++;\\n            else\\n                dp = A[i] == A[i - 1] + 1 ? 2 : -1;\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int alternatingSubarray(vector<int>& A) {\\n        int n = A.size(), res = -1, dp = -1;\\n        for (int i = 1; i < n; ++i, res = max(res, dp))\\n            if (dp > 0 && A[i] == A[i - 2])\\n                dp++;\\n            else\\n                dp = A[i] == A[i - 1] + 1 ? 2 : -1;\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def alternatingSubarray(self, A: List[int]) -> int:\\n        n = len(A)\\n        res = dp = -1\\n        for i in range(1, n):\\n            if dp > 0 and A[i] == A[i - 2]:\\n                dp += 1\\n            else:\\n                dp = 2 if A[i] == A[i - 1] + 1 else -1\\n            res = max(res, dp)\\n        return res\\n```\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int alternatingSubarray(int[] A) {\\n        int n = A.length, res = 0, j = 0;\\n        for (int i = 0; i < n; ++i)\\n            for (j = i + 1; j < n && A[j] == A[i] + (j - i) % 2; ++j)\\n                res = Math.max(res, j - i + 1);\\n        return res > 1 ? res : -1;\\n    }\\n```\n```cpp\\n    int alternatingSubarray(vector<int>& A) {\\n        int n = A.size(), res = 0, j = 0;\\n        for (int i = 0; i < n; ++i)\\n            for (j = i + 1; j < n && A[j] == A[i] + (j - i) % 2; ++j)\\n                res = max(res, j - i + 1);\\n        return res > 1 ? res : -1;\\n    }\\n```\n```java\\n    public int alternatingSubarray(int[] A) {\\n        int n = A.length, res = 0, j = 0;\\n        for (int i = 0; i < n; i = Math.max(i + 1, j - 1))\\n            for (j = i + 1; j < n && A[j] == A[i] + (j - i) % 2; ++j)\\n                res = Math.max(res, j - i + 1);\\n        return res > 1 ? res : -1;\\n    }\\n```\n```cpp\\n    int alternatingSubarray(vector<int>& A) {\\n        int n = A.size(), res = 0, j = 0;\\n        for (int i = 0; i < n; i = max(i + 1, j - 1))\\n            for (j = i + 1; j < n && A[j] == A[i] + (j - i) % 2; ++j)\\n                res = max(res, j - i + 1);\\n        return res > 1 ? res : -1;\\n    }\\n```\n```java\\n    public int alternatingSubarray(int[] A) {\\n        int n = A.length, res = -1, dp = -1;\\n        for (int i = 1; i < n; ++i, res = Math.max(res, dp))\\n            if (dp > 0 && A[i] == A[i - 2])\\n                dp++;\\n            else\\n                dp = A[i] == A[i - 1] + 1 ? 2 : -1;\\n        return res;\\n    }\\n```\n```cpp\\n    int alternatingSubarray(vector<int>& A) {\\n        int n = A.size(), res = -1, dp = -1;\\n        for (int i = 1; i < n; ++i, res = max(res, dp))\\n            if (dp > 0 && A[i] == A[i - 2])\\n                dp++;\\n            else\\n                dp = A[i] == A[i - 1] + 1 ? 2 : -1;\\n        return res;\\n    }\\n```\n```py\\n    def alternatingSubarray(self, A: List[int]) -> int:\\n        n = len(A)\\n        res = dp = -1\\n        for i in range(1, n):\\n            if dp > 0 and A[i] == A[i - 2]:\\n                dp += 1\\n            else:\\n                dp = 2 if A[i] == A[i - 1] + 1 else -1\\n            res = max(res, dp)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3737090,
                "title": "two-pointer-sliding-window-simple-solution",
                "content": "\\n\\n# Code\\n```\\nint alternatingSubarray(vector<int>& nums) {\\n    int front = 1, back = 0, state = INT_MAX, ans = 0;\\n    while(front < nums.size()){\\n        int diff = nums[front] - nums[front-1];\\n        if(diff == state*(-1)){\\n            state = state * (-1);\\n            ans = max(ans, front - back + 1);\\n        }else{\\n            if(diff == 1){\\n                state = diff;\\n                back = front - 1;\\n                ans = max(ans, front - back + 1);\\n            }else state = INT_MAX;\\n        }\\n        front++;\\n    }\\n    return ans?ans: -1;\\n}\\n```\\n\\n<b>Here is an article of my last interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint alternatingSubarray(vector<int>& nums) {\\n    int front = 1, back = 0, state = INT_MAX, ans = 0;\\n    while(front < nums.size()){\\n        int diff = nums[front] - nums[front-1];\\n        if(diff == state*(-1)){\\n            state = state * (-1);\\n            ans = max(ans, front - back + 1);\\n        }else{\\n            if(diff == 1){\\n                state = diff;\\n                back = front - 1;\\n                ans = max(ans, front - back + 1);\\n            }else state = INT_MAX;\\n        }\\n        front++;\\n    }\\n    return ans?ans: -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3737164,
                "title": "brute-to-optimal-c-slidingwindow",
                "content": "## Conect with me on LinkedIN : https://www.linkedin.com/in/aditya-jhunjhunwala-51b586195/\\n# Complexity\\n```\\n- Time complexity:\\n1st Approach : O(n^2)\\n2nd Approach : O(n)\\n\\n```\\n```\\n- Space complexity:\\nO(1)\\n```\\n\\n# Code\\n## An Upvote will be encouraging\\uD83E\\uDD17 & it motivates me to post more such solutions\\uD83C\\uDF1F\\n# 1st Approach(BRUTE FORCE):-\\n```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int n = nums.size(); // Size of the input vector\\n        int maxi = -1; // Initialize the maximum length of an alternating subarray as -1\\n        \\n        for(int i = 0; i < n-1; i++) { // Outer loop for starting index of subarray\\n            bool ch = false; // Flag to track increasing or decreasing order\\n            \\n            for(int j = i + 1; j < n; j++) { // Inner loop for ending index of subarray\\n                if(!ch) { // Subarray is in increasing order\\n                    if(nums[j] - nums[j-1] == 1) { // Check for alternating pattern\\n                        ch = true; // Set flag to true\\n                        maxi = max(maxi, j - i + 1); // Update maximum length if necessary\\n                    } else {\\n                        break; // Break the inner loop if alternating pattern is not valid\\n                    }\\n                } else { // Subarray is in decreasing order\\n                    if(nums[j] - nums[j-1] == -1) { // Check for alternating pattern\\n                        ch = false; // Set flag to false\\n                        maxi = max(maxi, j - i + 1); // Update maximum length if necessary\\n                    } else {\\n                        break; // Break the inner loop if alternating pattern is not valid\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return maxi; // Return the maximum length of an alternating subarray\\n    }\\n};\\n\\n```\\n# 2nd Approach(Sliding Window):-\\n```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int n = nums.size(),i = 0,j = 1,maxi = -1;\\n        bool ch = false;\\n        while(j < n){\\n            if(!ch){\\n                if(nums[j] - nums[j-1] == 1){\\n                    ch = true;\\n                    maxi = max(maxi,j - i + 1);\\n                }\\n                else\\n                    i = j;\\n            }\\n            else{\\n                if(nums[j] - nums[j-1] == -1){\\n                    ch = false;\\n                    maxi = max(maxi,j - i + 1);\\n                }\\n                else if(nums[j] - nums[j-1] == 1){\\n                    i = j - 1;\\n                    maxi = max(maxi,j - i + 1);\\n                }\\n                else{\\n                    ch = false;\\n                    i = j;\\n                }\\n            }\\n            j++;\\n        }\\n        return maxi;\\n    }\\n};\\n```\\n![e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png](https://assets.leetcode.com/users/images/80396fa7-b3ae-4bba-8027-9cabd87be968_1688868145.7181556.png)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\n- Time complexity:\\n1st Approach : O(n^2)\\n2nd Approach : O(n)\\n\\n```\n```\\n- Space complexity:\\nO(1)\\n```\n```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int n = nums.size(); // Size of the input vector\\n        int maxi = -1; // Initialize the maximum length of an alternating subarray as -1\\n        \\n        for(int i = 0; i < n-1; i++) { // Outer loop for starting index of subarray\\n            bool ch = false; // Flag to track increasing or decreasing order\\n            \\n            for(int j = i + 1; j < n; j++) { // Inner loop for ending index of subarray\\n                if(!ch) { // Subarray is in increasing order\\n                    if(nums[j] - nums[j-1] == 1) { // Check for alternating pattern\\n                        ch = true; // Set flag to true\\n                        maxi = max(maxi, j - i + 1); // Update maximum length if necessary\\n                    } else {\\n                        break; // Break the inner loop if alternating pattern is not valid\\n                    }\\n                } else { // Subarray is in decreasing order\\n                    if(nums[j] - nums[j-1] == -1) { // Check for alternating pattern\\n                        ch = false; // Set flag to false\\n                        maxi = max(maxi, j - i + 1); // Update maximum length if necessary\\n                    } else {\\n                        break; // Break the inner loop if alternating pattern is not valid\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return maxi; // Return the maximum length of an alternating subarray\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int n = nums.size(),i = 0,j = 1,maxi = -1;\\n        bool ch = false;\\n        while(j < n){\\n            if(!ch){\\n                if(nums[j] - nums[j-1] == 1){\\n                    ch = true;\\n                    maxi = max(maxi,j - i + 1);\\n                }\\n                else\\n                    i = j;\\n            }\\n            else{\\n                if(nums[j] - nums[j-1] == -1){\\n                    ch = false;\\n                    maxi = max(maxi,j - i + 1);\\n                }\\n                else if(nums[j] - nums[j-1] == 1){\\n                    i = j - 1;\\n                    maxi = max(maxi,j - i + 1);\\n                }\\n                else{\\n                    ch = false;\\n                    i = j;\\n                }\\n            }\\n            j++;\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3737338,
                "title": "2-approach-brute-force-sliding-window",
                "content": "<!-- # Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach\\nDescribe your approach to solving the problem. --> \\n\\n<!-- # Complexity -->\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Sliding Window\\n```\\nclass Solution {\\npublic:\\n    // Function to check if subarray at indices i and l is alternating\\n    bool isAlternating(vector<int>& nums, int i, int l) {\\n        int distance = i - l;\\n        if (distance % 2 == 1) {\\n            // Odd distance, check for consecutive increasing elements\\n            if (nums[i] - nums[l] == 1 && nums[l + 1] - nums[l] == 1)\\n                return true;\\n            return false;\\n        } else {\\n            // Even distance, check for equal elements\\n            return nums[i] - nums[l] == 0;\\n        }\\n    }\\n\\n    int alternatingSubarray(vector<int>& nums) {\\n        int maxLength = 0;\\n        int l = 0;\\n        \\n        for (int i = 1; i < (int)nums.size(); i++) {\\n            while (!isAlternating(nums, i, l)) {\\n                l++;\\n            }\\n            maxLength = max(maxLength, i - l + 1);\\n        }\\n        \\n        return (maxLength <= 1) ? -1 : maxLength;\\n    }\\n};\\n\\n```\\n# Brute Force \\n```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int maxCount = 1; // Maximum count of alternating subarray\\n        int currentCount = 1; // Current count of alternating subarray\\n        int n = nums.size(); // Size of the input array\\n        int prevIndex = 0; // Index of the previous element in the input array\\n\\n        for(int i = 1; i < n; i++) {\\n            if(abs(nums[i] - nums[i-1]) == 1) { // Check if the current pair is alternating\\n                prevIndex = i - 2; // Update the index of the previous element\\n                if(currentCount == 1 && nums[i] < nums[i-1]) continue; // Skip if it\\'s a decreasing pair after a single element\\n                if(i > 1 && nums[prevIndex] != nums[i]) {\\n                    currentCount = 2; // Start a new alternating subarray if the previous element is different\\n                }\\n                else {\\n                    currentCount++; // Increment the count of the alternating subarray\\n                }\\n                \\n                maxCount = max(maxCount, currentCount); // Update the maximum count\\n            }\\n            else {\\n                currentCount = 1; // Reset the count if the pair is not alternating\\n            }\\n        }\\n\\n        if(maxCount == 1) {\\n            return -1; // If there is no alternating subarray, return -1\\n        }\\n        \\n        return maxCount; // Return the maximum count of alternating subarray\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Function to check if subarray at indices i and l is alternating\\n    bool isAlternating(vector<int>& nums, int i, int l) {\\n        int distance = i - l;\\n        if (distance % 2 == 1) {\\n            // Odd distance, check for consecutive increasing elements\\n            if (nums[i] - nums[l] == 1 && nums[l + 1] - nums[l] == 1)\\n                return true;\\n            return false;\\n        } else {\\n            // Even distance, check for equal elements\\n            return nums[i] - nums[l] == 0;\\n        }\\n    }\\n\\n    int alternatingSubarray(vector<int>& nums) {\\n        int maxLength = 0;\\n        int l = 0;\\n        \\n        for (int i = 1; i < (int)nums.size(); i++) {\\n            while (!isAlternating(nums, i, l)) {\\n                l++;\\n            }\\n            maxLength = max(maxLength, i - l + 1);\\n        }\\n        \\n        return (maxLength <= 1) ? -1 : maxLength;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int maxCount = 1; // Maximum count of alternating subarray\\n        int currentCount = 1; // Current count of alternating subarray\\n        int n = nums.size(); // Size of the input array\\n        int prevIndex = 0; // Index of the previous element in the input array\\n\\n        for(int i = 1; i < n; i++) {\\n            if(abs(nums[i] - nums[i-1]) == 1) { // Check if the current pair is alternating\\n                prevIndex = i - 2; // Update the index of the previous element\\n                if(currentCount == 1 && nums[i] < nums[i-1]) continue; // Skip if it\\'s a decreasing pair after a single element\\n                if(i > 1 && nums[prevIndex] != nums[i]) {\\n                    currentCount = 2; // Start a new alternating subarray if the previous element is different\\n                }\\n                else {\\n                    currentCount++; // Increment the count of the alternating subarray\\n                }\\n                \\n                maxCount = max(maxCount, currentCount); // Update the maximum count\\n            }\\n            else {\\n                currentCount = 1; // Reset the count if the pair is not alternating\\n            }\\n        }\\n\\n        if(maxCount == 1) {\\n            return -1; // If there is no alternating subarray, return -1\\n        }\\n        \\n        return maxCount; // Return the maximum count of alternating subarray\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3737157,
                "title": "two-pointers",
                "content": "We maintain alternating subarray `[j, i]`:\\n- `nums[i] == nums[j]` if distance between `j` and `i` is even.\\n- `nums[i] == nums[j] + 1` otherwise.\\n\\nIf the above conditions are not satisfied for `i`, we start a new subarray:\\n- `j = i - 1` if `nums[i - 1] == nums[i] - 1`.\\n- `j = i` otherwise.\\n\\n**C++**\\n```cpp\\nint alternatingSubarray(vector<int>& nums) {\\n    int j = 0, res = 0;\\n    for (int i = 1; i < nums.size(); ++i) {\\n        if (nums[i] != nums[j] + (i - j) % 2)\\n            j = i - (nums[i - 1]  == nums[i] - 1);\\n        res = max(res, i - j + 1);\\n    }\\n    return res == 1 ? -1 : res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint alternatingSubarray(vector<int>& nums) {\\n    int j = 0, res = 0;\\n    for (int i = 1; i < nums.size(); ++i) {\\n        if (nums[i] != nums[j] + (i - j) % 2)\\n            j = i - (nums[i - 1]  == nums[i] - 1);\\n        res = max(res, i - j + 1);\\n    }\\n    return res == 1 ? -1 : res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3737114,
                "title": "cpp-bruteforce",
                "content": "```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& v) {\\n        int ans = 0;\\n        for(int i = 0; i < v.size() - 1; i += 1) {\\n            bool flag = true;\\n            int cnt = 1;\\n            for(int j = i + 1; j < v.size(); j += 1) {\\n                if(v[j] - v[j - 1] != (flag ? 1 : -1)) break;\\n                flag = !flag;\\n                cnt += 1;\\n            }\\n            ans = max(ans, cnt);\\n        }\\n        return ans <= 1 ? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& v) {\\n        int ans = 0;\\n        for(int i = 0; i < v.size() - 1; i += 1) {\\n            bool flag = true;\\n            int cnt = 1;\\n            for(int j = i + 1; j < v.size(); j += 1) {\\n                if(v[j] - v[j - 1] != (flag ? 1 : -1)) break;\\n                flag = !flag;\\n                cnt += 1;\\n            }\\n            ans = max(ans, cnt);\\n        }\\n        return ans <= 1 ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3737369,
                "title": "track-last",
                "content": "Similar to [978. Longest Turbulent Subarray](https://leetcode.com/problems/longest-turbulent-subarray/)\\n# C++\\n    int alternatingSubarray(vector<int>& A) {\\n        int res = 1, cnt = 1;\\n        for(int i = 1;i < size(A); ++i) {\\n            int prev = cnt & 1 ? -1 : 1;\\n            if(prev == A[i - 1] - A[i]) \\n\\t\\t\\t    ++cnt;\\n            else \\n\\t\\t\\t    cnt = A[i - 1] - A[i] == -1 ? 2 : 1;\\n            res = max(res, cnt);\\n        }\\n        return res == 1 ? -1 : res;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "Similar to [978. Longest Turbulent Subarray](https://leetcode.com/problems/longest-turbulent-subarray/)\\n# C++\\n    int alternatingSubarray(vector<int>& A) {\\n        int res = 1, cnt = 1;\\n        for(int i = 1;i < size(A); ++i) {\\n            int prev = cnt & 1 ? -1 : 1;\\n            if(prev == A[i - 1] - A[i]) \\n\\t\\t\\t    ++cnt;\\n            else \\n\\t\\t\\t    cnt = A[i - 1] - A[i] == -1 ? 2 : 1;\\n            res = max(res, cnt);\\n        }\\n        return res == 1 ? -1 : res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3737160,
                "title": "c-o-n-linear-search-dp",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int max_length = 1;\\n        \\n        int n=nums.size();\\n        \\n        vector<int> inc(n,1), dec(n,1);\\n            \\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]==nums[i-1]+1){\\n                inc[i] = dec[i-1]+1;\\n            }else if(nums[i]==nums[i-1]-1){\\n                dec[i] = (inc[i-1] > 1 ? inc[i-1]+1:1); // since sequence should start with s1=s0+1\\n            }\\n            \\n            max_length = max(max_length, max(inc[i],dec[i]));\\n        }\\n        \\n        return (max_length > 1 ? max_length:-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int max_length = 1;\\n        \\n        int n=nums.size();\\n        \\n        vector<int> inc(n,1), dec(n,1);\\n            \\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]==nums[i-1]+1){\\n                inc[i] = dec[i-1]+1;\\n            }else if(nums[i]==nums[i-1]-1){\\n                dec[i] = (inc[i-1] > 1 ? inc[i-1]+1:1); // since sequence should start with s1=s0+1\\n            }\\n            \\n            max_length = max(max_length, max(inc[i],dec[i]));\\n        }\\n        \\n        return (max_length > 1 ? max_length:-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740022,
                "title": "o-n2-accepted-solution-beginner-approach",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def alternatingSubarray(self, nums):\\n        res=-1\\n        for i in range(len(nums)):            \\n            for j in range(i+1,len(nums)):\\n                if nums[j-1]!=nums[j]+(-1)**(j-i):\\n                    break\\n                res=max(res, j-i+1)\\n        return res\\n```\\n\\nChecking if the range from i to j is an alternating sequence everytime.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def alternatingSubarray(self, nums):\\n        res=-1\\n        for i in range(len(nums)):            \\n            for j in range(i+1,len(nums)):\\n                if nums[j-1]!=nums[j]+(-1)**(j-i):\\n                    break\\n                res=max(res, j-i+1)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3737352,
                "title": "java-o-n-solution-without-2-pointers-with-direction-and-counter",
                "content": "# Approach\\nFollow ans keep track of the direction. When the direction condition is not satisfied, reset curr counter depending on the previous value.\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int alternatingSubarray(int[] nums) {\\n        int ans = -1;\\n        int n = nums.length;\\n        int curr = 1;\\n        int dir = 1;\\n        for (int i = 1; i<n; i++) {\\n            if (nums[i] - nums[i-1] == dir) {\\n                curr++;\\n                dir = -dir;\\n                ans = Math.max(ans, curr);\\n            } else {\\n                if (nums[i] - nums[i-1] == 1) {\\n                    curr = 2;\\n                    dir = -1;\\n                } else {\\n                    curr = 1;\\n                    dir = 1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int alternatingSubarray(int[] nums) {\\n        int ans = -1;\\n        int n = nums.length;\\n        int curr = 1;\\n        int dir = 1;\\n        for (int i = 1; i<n; i++) {\\n            if (nums[i] - nums[i-1] == dir) {\\n                curr++;\\n                dir = -dir;\\n                ans = Math.max(ans, curr);\\n            } else {\\n                if (nums[i] - nums[i-1] == 1) {\\n                    curr = 2;\\n                    dir = -1;\\n                } else {\\n                    curr = 1;\\n                    dir = 1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3737284,
                "title": "js-solution-o-n-with-detailed-explanation",
                "content": "# Intuition\\nThe problem asks us to find the maximum length of alternating subarrays within the given array `nums`.\\n\\nAn alternating subarray is defined as a subarray where the difference between adjacent elements follows a specific pattern: starting with an increase of 1, followed by a decrease of 1, then an increase of 1 again, and so on. For instance, the pattern is: `+1`, `-1`, `+1`, `-1`, `+1`, and so on.\\n\\n# Approach\\nThe solution utilizes a sliding window approach to analyze the array and identify alternating subarrays. The main steps of the approach are as follows:\\n\\n1. **Initialization:** Initialize three variables:\\n    - `curr` (current length of the alternating subarray) with a value of 1.\\n    - `check` (pattern check) with a value of 1, representing the expected difference between adjacent elements.\\n    - `max` (maximum length of alternating subarrays) with a value of -1, indicating no alternating subarrays found yet.\\n2. **Iteration:** Iterate through the array, starting from the second element (index 1). For each element:\\n    - Compare the difference between the current element `nums[i]` and the previous element `nums[i - 1]` with the `check` value.\\n    - If the difference matches the expected pattern (`nums[i] - nums[i - 1] == check`), then:\\n        - Increment the `curr` value (current subarray length).\\n        - Update the `check` to its opposite value (flip the sign) to maintain the alternating pattern.\\n        - Update the `max` value by taking the larger of the current `max` and `curr`. This keeps track of the maximum alternating subarray length encountered so far.\\n    - If the difference doesn\\'t match the expected pattern, then:\\n        - Check if the difference is equal to `1`. If true, start a new alternating subarray with length `2` and a descending pattern.\\n        - If the difference is not equal to `1`, start a new alternating subarray with length `1` and an ascending pattern.\\n3. **Result:** After iterating through the entire array, the `max` value will represent the maximum length of alternating subarrays found. Return the `max` value.\\n\\n# Complexity\\n- Time complexity:\\nThe algorithm iterates through the entire array once, with each iteration taking constant time operations. Therefore, the time complexity is `O(n)`, where `n` is the length of the input array.\\n\\n- Space complexity:\\nThe algorithm uses a constant amount of extra space for the variables `curr`, `check`, and `max`, as well as the loop index variable. Therefore, the space complexity is `O(1)`, indicating constant space usage regardless of the input array size.\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nconst alternatingSubarray = function (nums) {\\n  let [curr, check] = [1, 1];\\n  let max = -1;\\n  for (let i = 1; i < nums.length; i++) {\\n    if (nums[i] - nums[i - 1] == check) {\\n      curr++;\\n      check *= -1;\\n      max = Math.max(max, curr);\\n    } else {\\n      if (nums[i] - nums[i - 1] == 1) {\\n        [curr, check] = [2, -1];\\n      } else {\\n        [curr, check] = [1, 1];\\n      }\\n    }\\n  }\\n  return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nconst alternatingSubarray = function (nums) {\\n  let [curr, check] = [1, 1];\\n  let max = -1;\\n  for (let i = 1; i < nums.length; i++) {\\n    if (nums[i] - nums[i - 1] == check) {\\n      curr++;\\n      check *= -1;\\n      max = Math.max(max, curr);\\n    } else {\\n      if (nums[i] - nums[i - 1] == 1) {\\n        [curr, check] = [2, -1];\\n      } else {\\n        [curr, check] = [1, 1];\\n      }\\n    }\\n  }\\n  return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3737113,
                "title": "simple-c-java-solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int max = -1, cnt = -1, j;\\n        if(nums.size() == 2 && nums[1] - nums[0] == 1)  return 2;\\n        for(int i = 2; i <= nums.size(); i++){\\n            if(i == nums.size() && nums[i-1] - nums[i-2] == 1){\\n                max = std::max(max, 2);\\n                break;\\n            }\\n            if(nums[i-1] - nums[i-2] == 1){\\n                cnt = 2;\\n                j = i;\\n                while(j < nums.size() && nums[j] == nums[j-2]){\\n                    j++;\\n                    cnt++;\\n                }\\n                max = std::max(max, cnt);\\n            }\\n        }\\n        return max;\\n    }\\n};\\n\\n```\\n\\n```Java []\\nclass Solution {\\n    public int alternatingSubarray(int[] nums) {\\n        int max = -1, cnt = -1, j;\\n        if(nums.length == 2 && nums[1] - nums[0] == 1)  return 2;\\n        for(int i=2; i<=nums.length; i++){\\n            if(i == nums.length && nums[i-1] - nums[i-2] == 1){\\n                max = Math.max(max,2);\\n                break;\\n            }\\n            if(nums[i-1] - nums[i-2] == 1){\\n                cnt = 2;\\n                j = i;\\n                while(j < nums.length && nums[j] == nums[j-2]){\\n                    j++;\\n                    cnt++;\\n                }\\n                max = Math.max(max,cnt);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int max = -1, cnt = -1, j;\\n        if(nums.size() == 2 && nums[1] - nums[0] == 1)  return 2;\\n        for(int i = 2; i <= nums.size(); i++){\\n            if(i == nums.size() && nums[i-1] - nums[i-2] == 1){\\n                max = std::max(max, 2);\\n                break;\\n            }\\n            if(nums[i-1] - nums[i-2] == 1){\\n                cnt = 2;\\n                j = i;\\n                while(j < nums.size() && nums[j] == nums[j-2]){\\n                    j++;\\n                    cnt++;\\n                }\\n                max = std::max(max, cnt);\\n            }\\n        }\\n        return max;\\n    }\\n};\\n\\n```\n```Java []\\nclass Solution {\\n    public int alternatingSubarray(int[] nums) {\\n        int max = -1, cnt = -1, j;\\n        if(nums.length == 2 && nums[1] - nums[0] == 1)  return 2;\\n        for(int i=2; i<=nums.length; i++){\\n            if(i == nums.length && nums[i-1] - nums[i-2] == 1){\\n                max = Math.max(max,2);\\n                break;\\n            }\\n            if(nums[i-1] - nums[i-2] == 1){\\n                cnt = 2;\\n                j = i;\\n                while(j < nums.length && nums[j] == nums[j-2]){\\n                    j++;\\n                    cnt++;\\n                }\\n                max = Math.max(max,cnt);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3737095,
                "title": "python-brute-force",
                "content": "```python\\nclass Solution:\\n    def alternatingSubarray(self, nums: List[int]) -> int:\\n        best = float(\\'-inf\\')\\n\\n        for i in range(len(nums)):\\n            odd = True\\n            for j in range(i, len(nums) - 1):\\n                if odd:\\n                    if nums[j] + 1 != nums[j + 1]:\\n                        break\\n                else:\\n                    if nums[j] - 1 != nums[j + 1]:\\n                        break\\n\\n                odd = not odd\\n                best = max(best, j - i + 2)\\n\\n        return best if best != float(\\'-inf\\') else -1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def alternatingSubarray(self, nums: List[int]) -> int:\\n        best = float(\\'-inf\\')\\n\\n        for i in range(len(nums)):\\n            odd = True\\n            for j in range(i, len(nums) - 1):\\n                if odd:\\n                    if nums[j] + 1 != nums[j + 1]:\\n                        break\\n                else:\\n                    if nums[j] - 1 != nums[j + 1]:\\n                        break\\n\\n                odd = not odd\\n                best = max(best, j - i + 2)\\n\\n        return best if best != float(\\'-inf\\') else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3737094,
                "title": "java-c-python-two-pointers-and-dp-solutions",
                "content": "# **Solution 0**\\n\\nSum up the equations\\n`s1 - s0 = 1`\\n`s2 - s1 = -1,`\\n`s3 - s2 = 1`\\nwe can have\\n`si - s0 = i % 2`\\n\\nSo for each `A[i]`,\\nfind the longest alternating subarray where `A[j] == A[i] + (j - i) % 2`\\n\\nThe length of alternating subarray is `j - i + 1`\\n\\nTime `O(n^2)`\\nSpace `O(1)`\\n\\n**Java**\\n```java\\n    public int alternatingSubarray(int[] A) {\\n        int n = A.length, res = 0, j = 0;\\n        for (int i = 0; i < n; ++i)\\n            for (j = i + 1; j < n && A[j] == A[i] + (j - i) % 2; ++j)\\n                res = Math.max(res, j - i + 1);\\n        return res > 1 ? res : -1;\\n    }\\n```\\n\\n**C++*\\n```cpp\\n    int alternatingSubarray(vector<int>& A) {\\n        int n = A.size(), res = 0, j = 0;\\n        for (int i = 0; i < n; ++i)\\n            for (j = i + 1; j < n && A[j] == A[i] + (j - i) % 2; ++j)\\n                res = max(res, j - i + 1);\\n        return res > 1 ? res : -1;\\n    }\\n```\\n<br>\\n\\n# **Solution 1**\\n\\nIn solution above,\\n`A[i], A[i + 1], ... , A[j - 1]` is alternating subarray\\nwe check subarray startting at `A[i + 1]` after `A[i]`.\\nActually we don\\'t need to check `A[i + 1], A[i + 2]... A[j - 2]`\\nwe can start to check subarray from the last element in the alternating subarray.\\n\\nFor example,\\n`1,2,1,2,1,2,3`\\nwe can check from the last `2` in the array.\\n\\nTime `O(n)`\\nSpace `O(1)`\\n\\n**Java**\\n```java\\n    public int alternatingSubarray(int[] A) {\\n        int n = A.length, res = 0, j = 0;\\n        for (int i = 0; i < n; i = Math.max(i + 1, j - 1))\\n            for (j = i + 1; j < n && A[j] == A[i] + (j - i) % 2; ++j)\\n                res = Math.max(res, j - i + 1);\\n        return res > 1 ? res : -1;\\n    }\\n```\\n\\n**C++*\\n```cpp\\n    int alternatingSubarray(vector<int>& A) {\\n        int n = A.size(), res = 0, j = 0;\\n        for (int i = 0; i < n; i = max(i + 1, j - 1))\\n            for (j = i + 1; j < n && A[j] == A[i] + (j - i) % 2; ++j)\\n                res = max(res, j - i + 1);\\n        return res > 1 ? res : -1;\\n    }\\n```\\n<br>\\n\\n# Solution 3, DP-like Solution\\n\\nIf `A[i] == A[i - 2]` and `dp[i - 1] > 0`\\nextends the alternatice subarray\\nthen `dp[i] = dp[i - 1] + 1`\\n\\nelse if `A[i] == A[i - 1] + 1`,\\nstarts the alternatice subarray\\n`dp[i] = 2`\\n\\nelse\\nnot in the alternatice subarray\\n`dp[i] = -1`\\n\\nTime `O(n)`\\nSpace `O(1)`\\n\\n\\n**Java**\\n```java\\n    public int alternatingSubarray(int[] A) {\\n        int n = A.length, res = -1, dp = -1;\\n        for (int i = 1; i < n; ++i, res = Math.max(res, dp))\\n            if (dp > 0 && A[i] == A[i - 2])\\n                dp++;\\n            else\\n                dp = A[i] == A[i - 1] + 1 ? 2 : -1;\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int alternatingSubarray(vector<int>& A) {\\n        int n = A.size(), res = -1, dp = -1;\\n        for (int i = 1; i < n; ++i, res = max(res, dp))\\n            if (dp > 0 && A[i] == A[i - 2])\\n                dp++;\\n            else\\n                dp = A[i] == A[i - 1] + 1 ? 2 : -1;\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def alternatingSubarray(self, A: List[int]) -> int:\\n        n = len(A)\\n        res = dp = -1\\n        for i in range(1, n):\\n            if dp > 0 and A[i] == A[i - 2]:\\n                dp += 1\\n            else:\\n                dp = 2 if A[i] == A[i - 1] + 1 else -1\\n            res = max(res, dp)\\n        return res\\n```\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int alternatingSubarray(int[] A) {\\n        int n = A.length, res = 0, j = 0;\\n        for (int i = 0; i < n; ++i)\\n            for (j = i + 1; j < n && A[j] == A[i] + (j - i) % 2; ++j)\\n                res = Math.max(res, j - i + 1);\\n        return res > 1 ? res : -1;\\n    }\\n```\n```cpp\\n    int alternatingSubarray(vector<int>& A) {\\n        int n = A.size(), res = 0, j = 0;\\n        for (int i = 0; i < n; ++i)\\n            for (j = i + 1; j < n && A[j] == A[i] + (j - i) % 2; ++j)\\n                res = max(res, j - i + 1);\\n        return res > 1 ? res : -1;\\n    }\\n```\n```java\\n    public int alternatingSubarray(int[] A) {\\n        int n = A.length, res = 0, j = 0;\\n        for (int i = 0; i < n; i = Math.max(i + 1, j - 1))\\n            for (j = i + 1; j < n && A[j] == A[i] + (j - i) % 2; ++j)\\n                res = Math.max(res, j - i + 1);\\n        return res > 1 ? res : -1;\\n    }\\n```\n```cpp\\n    int alternatingSubarray(vector<int>& A) {\\n        int n = A.size(), res = 0, j = 0;\\n        for (int i = 0; i < n; i = max(i + 1, j - 1))\\n            for (j = i + 1; j < n && A[j] == A[i] + (j - i) % 2; ++j)\\n                res = max(res, j - i + 1);\\n        return res > 1 ? res : -1;\\n    }\\n```\n```java\\n    public int alternatingSubarray(int[] A) {\\n        int n = A.length, res = -1, dp = -1;\\n        for (int i = 1; i < n; ++i, res = Math.max(res, dp))\\n            if (dp > 0 && A[i] == A[i - 2])\\n                dp++;\\n            else\\n                dp = A[i] == A[i - 1] + 1 ? 2 : -1;\\n        return res;\\n    }\\n```\n```cpp\\n    int alternatingSubarray(vector<int>& A) {\\n        int n = A.size(), res = -1, dp = -1;\\n        for (int i = 1; i < n; ++i, res = max(res, dp))\\n            if (dp > 0 && A[i] == A[i - 2])\\n                dp++;\\n            else\\n                dp = A[i] == A[i - 1] + 1 ? 2 : -1;\\n        return res;\\n    }\\n```\n```py\\n    def alternatingSubarray(self, A: List[int]) -> int:\\n        n = len(A)\\n        res = dp = -1\\n        for i in range(1, n):\\n            if dp > 0 and A[i] == A[i - 2]:\\n                dp += 1\\n            else:\\n                dp = 2 if A[i] == A[i - 1] + 1 else -1\\n            res = max(res, dp)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3930194,
                "title": "easy-to-understand-o-n-solution-no-dp-two-pointers-with-explanation",
                "content": "\\n# Approach\\nThis code finds the length of the longest alternating subarray within the given \\'nums\\' array.\\n\\n1. Initialize variables: \\'longest\\' for the longest alternating subarray length, \\'cur\\' for the current alternating subarray length, and \\'x\\' to track the expected sign of the next number (initialized to -1 for the first number).\\n\\n2. Iteration through the Array:\\n   - Iterate through the array from index 1.\\n   - For each number at index \\'i\\':\\n      - Check if \\'nums[i]\\' plus \\'x\\' equals the previous number \\'nums[i-1]\\'.\\n         - If true, we have an alternating sequence:\\n           - Increment \\'cur\\' for the current alternating subarray length.\\n           - Update \\'x\\' to the opposite sign, indicating the expectation for the next number.\\n           - Set \\'flag\\' to \\'true\\' to mark continuous alternation and move to the next iteration.\\n      - If the sum condition isn\\'t met, the alternating sequence breaks:\\n         - Update \\'longest\\' if \\'cur\\' is greater than the existing longest alternating subarray.\\n         - Reset \\'cur\\' to 1 since a non-alternating number is encountered.\\n         - Reset \\'x\\' to -1, indicating we expect the first number of the next alternating sequence.\\n\\n3. Handling Continuous Alternations:\\n   - If \\'flag\\' is \\'true\\', we encountered continuous alternation in the previous iteration. Reset \\'flag\\' and proceed to the next iteration to avoid double-counting.\\n\\n4. Final Check and Return:\\n   - After the loop, make a final comparison between \\'longest\\' and 1 (since a subarray with one element can\\'t alternate). If \\'longest\\' is 1, return -1 as there\\'s no valid alternating sequence.\\n   - Otherwise, return \\'longest\\' as the answer.\\n\\nThe code scans through the array, identifies alternating sequences by checking if each number meets the alternating pattern criteria, and tracks both the current and longest alternating subarray lengths. It efficiently captures alternating patterns and their lengths.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int longest=0,cur=1;\\n        int x=-1;\\n        bool flag=false;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]+x==nums[i-1]){\\n                cur++;\\n                x=-x;\\n                flag=true;\\n            }\\n            else{\\n                longest=max(longest,cur);\\n                cur=1;\\n                x=-1;\\n                if(flag){\\n                    i--;\\n                    flag=false;\\n                }\\n\\n            }\\n        }\\n        longest=max(longest,cur);\\n        if(longest==1){\\n            return -1;\\n        }\\n        return longest;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int longest=0,cur=1;\\n        int x=-1;\\n        bool flag=false;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]+x==nums[i-1]){\\n                cur++;\\n                x=-x;\\n                flag=true;\\n            }\\n            else{\\n                longest=max(longest,cur);\\n                cur=1;\\n                x=-1;\\n                if(flag){\\n                    i--;\\n                    flag=false;\\n                }\\n\\n            }\\n        }\\n        longest=max(longest,cur);\\n        if(longest==1){\\n            return -1;\\n        }\\n        return longest;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3842273,
                "title": "easy-sol-in-c-java-leetcode-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int alternatingSubarray(int[] nums) {\\n        int ans=0,i=0,temp=0;\\n        boolean a=false;\\n        for(i=0;i<nums.length-1;i++)\\n        {\\n            if(nums[i+1]-nums[i] == 1 && a==false)\\n            {\\n                temp++;\\n                a=true;\\n            }\\n            else if(nums[i+1]-nums[i]== -1 && a==true)\\n            {\\n                temp++;\\n                a=false;\\n            }\\n            else\\n            {\\n                ans=Math.max(ans,temp);\\n                temp=0;\\n                if(nums[i+1]-nums[i] == 1)\\n                {\\n                    temp++;\\n                    a=true;\\n                }\\n                else{\\n                    a=false;\\n                }\\n            } \\n        }\\n        ans=Math.max(ans,temp);\\n        return (ans > 0 ? ans + 1 : -1);\\n    }\\n}\\n```\\n\\n# Please UpVote if u like...\\uD83D\\uDC4D\\n\\nIn c++ : \\n```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int ans = 0, temp = 0;\\n        bool a = false;\\n        for (int i = 0; i < nums.size() - 1; i++) {\\n            if (nums[i + 1] - nums[i] == 1 && !a) {\\n                temp++;\\n                a = true;\\n            } else if (nums[i + 1] - nums[i] == -1 && a) {\\n                temp++;\\n                a = false;\\n            } else {\\n                ans = max(ans, temp);\\n                temp = 0;\\n                if (nums[i + 1] - nums[i] == 1) {\\n                    temp++;\\n                    a = true;\\n                } else {\\n                    a = false;\\n                }\\n            }\\n        }\\n        ans = max(ans, temp);\\n        return (ans > 0 ? ans + 1 : -1);\\n    }\\n};\\n```\\n# Please UpVote if u like...\\uD83D\\uDC4D",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int alternatingSubarray(int[] nums) {\\n        int ans=0,i=0,temp=0;\\n        boolean a=false;\\n        for(i=0;i<nums.length-1;i++)\\n        {\\n            if(nums[i+1]-nums[i] == 1 && a==false)\\n            {\\n                temp++;\\n                a=true;\\n            }\\n            else if(nums[i+1]-nums[i]== -1 && a==true)\\n            {\\n                temp++;\\n                a=false;\\n            }\\n            else\\n            {\\n                ans=Math.max(ans,temp);\\n                temp=0;\\n                if(nums[i+1]-nums[i] == 1)\\n                {\\n                    temp++;\\n                    a=true;\\n                }\\n                else{\\n                    a=false;\\n                }\\n            } \\n        }\\n        ans=Math.max(ans,temp);\\n        return (ans > 0 ? ans + 1 : -1);\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int ans = 0, temp = 0;\\n        bool a = false;\\n        for (int i = 0; i < nums.size() - 1; i++) {\\n            if (nums[i + 1] - nums[i] == 1 && !a) {\\n                temp++;\\n                a = true;\\n            } else if (nums[i + 1] - nums[i] == -1 && a) {\\n                temp++;\\n                a = false;\\n            } else {\\n                ans = max(ans, temp);\\n                temp = 0;\\n                if (nums[i + 1] - nums[i] == 1) {\\n                    temp++;\\n                    a = true;\\n                } else {\\n                    a = false;\\n                }\\n            }\\n        }\\n        ans = max(ans, temp);\\n        return (ans > 0 ? ans + 1 : -1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785144,
                "title": "video-master-the-art-of-alternating-arrays-with-python",
                "content": "## Intuition\\nMy first thought was to traverse the array and keep track of the longest subarray that meets the criteria. This would involve checking if each number in the array could be part of an alternating sequence and keeping track of the longest such sequence found.\\n\\nhttps://youtu.be/tNbO-ePM3qs\\n\\n## Approach\\nI implemented a dynamic programming approach to solve this problem. \\n\\nThe algorithm works as follows:\\n\\n1. Start by initializing two variables, `res` and `dp`, to -1. `res` will keep track of the maximum length of an alternating subarray we\\'ve found so far, and `dp` will keep track of the current length of the alternating subarray.\\n   \\n2. Then, iterate through the array from the second element. For each element, check if it\\'s the same as the element two indices before it. If it is, that means it\\'s part of the same alternating sequence, and increment `dp`. \\n   \\n3. If it\\'s not part of the same alternating sequence, then check if it\\'s one more than the previous element. If it is, that means it\\'s the start of a new alternating sequence, and reset `dp` to 2. If it\\'s not either of these, set `dp` to -1.\\n\\n4. Finally, at each step, update `res` with the maximum of `res` and `dp`. This ensures that `res` always contains the length of the longest alternating subarray found.\\n\\n## Complexity\\n- Time complexity: The time complexity of this algorithm is O(n), where n is the length of the input array. This is because we are iterating over the array once.\\n- Space complexity: The space complexity of this algorithm is O(1), as we are using a constant amount of space to store the variables `res` and `dp`.\\n\\n## Code\\n```python\\nclass Solution:\\n    def alternatingSubarray(self, nums: List[int]) -> int:\\n        n = len(nums) \\n        res = dp = -1 \\n        for i in range(1, n): \\n            if dp > 0 and nums[i] == nums[i - 2]: \\n                dp += 1 \\n            else: \\n                dp = 2 if nums[i] == nums[i - 1] + 1 else -1 \\n            res = max(res, dp) \\n        return res \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def alternatingSubarray(self, nums: List[int]) -> int:\\n        n = len(nums) \\n        res = dp = -1 \\n        for i in range(1, n): \\n            if dp > 0 and nums[i] == nums[i - 2]: \\n                dp += 1 \\n            else: \\n                dp = 2 if nums[i] == nums[i - 1] + 1 else -1 \\n            res = max(res, dp) \\n        return res \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754370,
                "title": "clean-code-easy-to-read",
                "content": "# Please upvote me if you like \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int alternatingSubarray(int[] nums) {\\n        int max = -1, cnt = -1, j;\\n        if(nums.length == 2 && nums[1] - nums[0] == 1)  return 2;\\n        for(int i=2; i<=nums.length; i++){\\n            if(i == nums.length && nums[i-1] - nums[i-2] == 1){\\n                max = Math.max(max,2);\\n                break;\\n            }\\n            if(nums[i-1] - nums[i-2] == 1){\\n                cnt = 2;\\n                j = i;\\n                while(j < nums.length && nums[j] == nums[j-2]){\\n                    j++;\\n                    cnt++;\\n                }\\n                max = Math.max(max,cnt);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int alternatingSubarray(int[] nums) {\\n        int max = -1, cnt = -1, j;\\n        if(nums.length == 2 && nums[1] - nums[0] == 1)  return 2;\\n        for(int i=2; i<=nums.length; i++){\\n            if(i == nums.length && nums[i-1] - nums[i-2] == 1){\\n                max = Math.max(max,2);\\n                break;\\n            }\\n            if(nums[i-1] - nums[i-2] == 1){\\n                cnt = 2;\\n                j = i;\\n                while(j < nums.length && nums[j] == nums[j-2]){\\n                    j++;\\n                    cnt++;\\n                }\\n                max = Math.max(max,cnt);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3743463,
                "title": "c-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSlide a window and record the max. window size\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Keep moving the right pointer `r`\\n- Shrink the left pointer `l` if the subarray doesn\\'t match the condition\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // time/space: O(n)/O(1)\\n    int alternatingSubarray(vector<int>& nums) {\\n        const int n = nums.size();\\n        int result = 1;\\n        \\n        for (int l = 0, r = 0; r < n; r++) {\\n            while (!isGood(nums, l, r)) l++;\\n            result = max(result, r - l + 1);\\n        }\\n\\n        if (result == 1) return -1;\\n        return result;\\n    }\\nprivate:\\n    bool isGood(vector<int>& nums, int l, int r) {\\n        const int distance = r - l;\\n        \\n        // l == r\\n        if (distance == 0) return true;\\n        // odd\\n        if ((distance & 1) == 1) return ((nums[r] - nums[l]) == 1);\\n        // even\\n        if (nums[r] != nums[l]) return false;\\n        if ((nums[l + 1] - nums[l]) != 1) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // time/space: O(n)/O(1)\\n    int alternatingSubarray(vector<int>& nums) {\\n        const int n = nums.size();\\n        int result = 1;\\n        \\n        for (int l = 0, r = 0; r < n; r++) {\\n            while (!isGood(nums, l, r)) l++;\\n            result = max(result, r - l + 1);\\n        }\\n\\n        if (result == 1) return -1;\\n        return result;\\n    }\\nprivate:\\n    bool isGood(vector<int>& nums, int l, int r) {\\n        const int distance = r - l;\\n        \\n        // l == r\\n        if (distance == 0) return true;\\n        // odd\\n        if ((distance & 1) == 1) return ((nums[r] - nums[l]) == 1);\\n        // even\\n        if (nums[r] != nums[l]) return false;\\n        if ((nums[l + 1] - nums[l]) != 1) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740058,
                "title": "c-simple-straight-forward-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int n = nums.size();\\n        int maxi = 0;\\n        \\n        for(int i = 0; i < n - 1; i++){\\n            int len = 0;\\n            bool flag = true;\\n            for(int j = i + 1; j < n; j++){\\n                if(nums[j] - nums[j-1] == 1 && flag){\\n                    flag = !flag;\\n                    len++;\\n                }\\n                else if(nums[j] - nums[j-1] == -1 && !flag){\\n                    flag = !flag;\\n                    len++;\\n                }\\n                else {\\n                    break;\\n                }\\n                maxi = max(maxi, len);\\n            }\\n        }\\n        return maxi == 0 ? -1 : maxi+1;\\n    }\\n};\\n\\n```\\n\\n![image](https://assets.leetcode.com/users/images/39451a8b-4887-46f6-9b8f-b994e2e40253_1687453528.6643982.jpeg)\\n\\n**please upvote!! if you like.**\\ncomment below\\uD83D\\uDC47",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int n = nums.size();\\n        int maxi = 0;\\n        \\n        for(int i = 0; i < n - 1; i++){\\n            int len = 0;\\n            bool flag = true;\\n            for(int j = i + 1; j < n; j++){\\n                if(nums[j] - nums[j-1] == 1 && flag){\\n                    flag = !flag;\\n                    len++;\\n                }\\n                else if(nums[j] - nums[j-1] == -1 && !flag){\\n                    flag = !flag;\\n                    len++;\\n                }\\n                else {\\n                    break;\\n                }\\n                maxi = max(maxi, len);\\n            }\\n        }\\n        return maxi == 0 ? -1 : maxi+1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3737342,
                "title": "c-most-easy-solution-brute-force",
                "content": "\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int ans = 0;\\n        \\n        for(int i = 0; i < nums.size(); i++) {\\n            int diff = 1;\\n            for(int j = i+1; j < nums.size(); j++) {\\n                if(nums[j] - nums[j-1] == diff) {\\n                    ans = max(ans, j-i+1);\\n                } \\n                else {\\n                    break;\\n                }\\n                diff = -diff;\\n            }\\n        }\\n        \\n        if(ans == 0)\\n            return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int ans = 0;\\n        \\n        for(int i = 0; i < nums.size(); i++) {\\n            int diff = 1;\\n            for(int j = i+1; j < nums.size(); j++) {\\n                if(nums[j] - nums[j-1] == diff) {\\n                    ans = max(ans, j-i+1);\\n                } \\n                else {\\n                    break;\\n                }\\n                diff = -diff;\\n            }\\n        }\\n        \\n        if(ans == 0)\\n            return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3737124,
                "title": "brute-force-very-simple-and-easy-explaintion",
                "content": "# Intuition\\n# **Simple observation:\\n# s1 - s0 = 1, s2 - s1 = -1\\n\\n# Here (s0 = 1 + s1) and (s1 =  s2+1),**\\n\\nSubstitute the value of S1 you\\'ll Observe S0 == S2 (That is 1st and 3rd elements should be same).\\n\\n\\n# So the sequence can be \\n1 2 1 2 1 2 1 2 1\\nor\\n2 3 2 3 2 3\\nor \\n9 10 9\\n\\n\\nCan\\'t be\\n10 9 10 9\\n\\n\\n# Approach\\nBrute Force:\\n1. Standing on the current index store the value at current index in a temp variable\\n2. Element after that index i.e at i+1 should be one greater a[i+1] = temp+1 and a[i+2] == temp so to check that you can see the code.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int ans = 0;\\n        for(int i=0;i<nums.size();i++)\\n        {   \\n            int temp = nums[i];\\n            int j = i+1;\\n            bool first = false; \\n            while(j<n)\\n            {\\n                if(nums[j] == temp+1 && !first)\\n                {\\n                    j++;\\n                    first = true;  \\n                }\\n                else if(nums[j] == temp && first)\\n                {\\n                    j++;\\n                    first = false;\\n                }\\n                else break;\\n            }\\n            ans = max(ans,j-i);\\n        }\\n        if(ans==1) return -1; // Not allowed\\n        return ans;\\n    }\\n};\\n\\n# Please Upvote if it was Helpful\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int ans = 0;\\n        for(int i=0;i<nums.size();i++)\\n        {   \\n            int temp = nums[i];\\n            int j = i+1;\\n            bool first = false; \\n            while(j<n)\\n            {\\n                if(nums[j] == temp+1 && !first)\\n                {\\n                    j++;\\n                    first = true;  \\n                }\\n                else if(nums[j] == temp && first)\\n                {\\n                    j++;\\n                    first = false;\\n                }\\n                else break;\\n            }\\n            ans = max(ans,j-i);\\n        }\\n        if(ans==1) return -1; // Not allowed\\n        return ans;\\n    }\\n};\\n\\n# Please Upvote if it was Helpful\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3737050,
                "title": "c-brute-force",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int ans = 0;\\n        int n = nums.size();\\n        for (int i = 0; i < n; i++){\\n            bool f = 0;\\n            int maxi = 1;\\n            int count = 1;\\n            for (int j = i; j < n - 1; j++){\\n                if(!f && nums[j + 1] - nums[j] == 1){\\n                    count++;\\n                    maxi = max(maxi, count);\\n                }\\n                else if(f && nums[j + 1] - nums[j] == -1){\\n                    count++;\\n                    maxi = max(maxi, count);\\n                }\\n                else{\\n                    break;\\n                }\\n                f = !f;\\n            }\\n            ans = max(ans, maxi);\\n        }\\n        if(ans == 1){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int ans = 0;\\n        int n = nums.size();\\n        for (int i = 0; i < n; i++){\\n            bool f = 0;\\n            int maxi = 1;\\n            int count = 1;\\n            for (int j = i; j < n - 1; j++){\\n                if(!f && nums[j + 1] - nums[j] == 1){\\n                    count++;\\n                    maxi = max(maxi, count);\\n                }\\n                else if(f && nums[j + 1] - nums[j] == -1){\\n                    count++;\\n                    maxi = max(maxi, count);\\n                }\\n                else{\\n                    break;\\n                }\\n                f = !f;\\n            }\\n            ans = max(ans, maxi);\\n        }\\n        if(ans == 1){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924804,
                "title": "2ms-beats-98-38-of-users-with-java-using-recursion",
                "content": "\\n## Intuition\\nThe problem involves finding the length of the longest alternating subarray, where the difference between adjacent elements is either 1 or -1.\\n\\n## Approach\\n1. **Initialization**: Initialize a variable `max` to store the maximum length of alternating subarrays found, and initialize a variable `step` to keep track of the length of the current alternating subarray (initialized to 1 since any single element is an alternating subarray by itself).\\n\\n2. **Iterating through the array**: Start iterating through the array from the second element (index 1) to the end.\\n   - Calculate the absolute difference between the current element and the previous element, and store it in the variable `diff`.\\n   - Check if `diff` is either 1 or -1. If yes, it satisfies the alternating pattern, so increment `step`.\\n   - If `diff` doesn\\'t satisfy the pattern, update `max` if `step` is greater than `max`, and reset `step` to 1.\\n\\n3. **After the loop**: After the loop completes, check one last time if `step` is greater than `max`, and update `max` accordingly.\\n\\n4. **Return result**: Return `max` as the result, which represents the length of the longest alternating subarray.\\n\\n## Complexity\\n- **Time complexity**: The algorithm iterates through the array once, visiting each element exactly once. Thus, the time complexity is O(n), where n is the length of the input array.\\n\\n- **Space complexity**: The algorithm uses a constant amount of extra space to store variables (`max` and `step`), so the space complexity is O(1).\\n\\n# Code\\n```\\nclass Solution {\\n    int max=-1;\\n    public void dfs(int i,int nums[],int step,int d){\\n        max=Math.max(max,step);\\n        if(i>=nums.length-1){\\n            max=Math.max(max,step);\\n            return;\\n        }\\n        int diff=nums[i]-nums[i+1];\\n        if(diff==d||diff!=-1&&diff!=1)return;\\n        \\n        dfs(i+1,nums,step+1,diff);\\n    }\\n    public int alternatingSubarray(int[] nums) {\\n        for(int i=0;i<nums.length-1;i++){\\n           if(nums[i]-nums[i+1]==-1){\\n               dfs(i+1,nums,2,nums[i]-nums[i+1]);\\n           }\\n        }\\n        return max;\\n    }\\n}\\n```\\n# If it is helpful for you then please UPVOTE \\uD83D\\uDE42\\uD83D\\uDE42\\uD83D\\uDE42(\\u2741\\xB4\\u25E1`\\u2741)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int max=-1;\\n    public void dfs(int i,int nums[],int step,int d){\\n        max=Math.max(max,step);\\n        if(i>=nums.length-1){\\n            max=Math.max(max,step);\\n            return;\\n        }\\n        int diff=nums[i]-nums[i+1];\\n        if(diff==d||diff!=-1&&diff!=1)return;\\n        \\n        dfs(i+1,nums,step+1,diff);\\n    }\\n    public int alternatingSubarray(int[] nums) {\\n        for(int i=0;i<nums.length-1;i++){\\n           if(nums[i]-nums[i+1]==-1){\\n               dfs(i+1,nums,2,nums[i]-nums[i+1]);\\n           }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820652,
                "title": "o-n-2-solution-in-cpp",
                "content": "\\n# Complexity\\n- Time complexity: ```O(n)```\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: ```O(1)```\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int ans = 0, k = 1, cnt = 0;\\n        for(int i = 0; i <  nums.size(); i++){\\n                k = 1; cnt = 1;\\n                for(int j = i; j < nums.size() - 1; j++){\\n                    if(nums[j + 1] - nums[j] == k)\\n                            cnt++;\\n                     else{\\n                        ans = max(cnt, ans); \\n                        cnt = 1;\\n                        break;\\n                      }\\n                       k *= -1;\\n                }\\n                ans = max(cnt, ans);\\n           \\n        }\\n\\n        if(ans == 1)\\n            ans = -1;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```O(n)```\n```O(1)```\n```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int ans = 0, k = 1, cnt = 0;\\n        for(int i = 0; i <  nums.size(); i++){\\n                k = 1; cnt = 1;\\n                for(int j = i; j < nums.size() - 1; j++){\\n                    if(nums[j + 1] - nums[j] == k)\\n                            cnt++;\\n                     else{\\n                        ans = max(cnt, ans); \\n                        cnt = 1;\\n                        break;\\n                      }\\n                       k *= -1;\\n                }\\n                ans = max(cnt, ans);\\n           \\n        }\\n\\n        if(ans == 1)\\n            ans = -1;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3818666,
                "title": "simple-linear-scan",
                "content": "# Intuition\\nWe notice that the last alternating sign (+/-1) in the currently-considered array must match whether we have an even or odd number of numbers in the array. For this, we use the formula `(c%2)*2-1`. For example, if we\\'re just starting and `c=1`, then the sign must be +1 (i.e., `(1%2)*2-1=1`). Otherwise, if we have already counted, e.g., `c=32` numbers in our array, then the last alternating sign must be -1 (i.e., `(32%2)*2-1=-1`).\\n\\n# Approach\\nWe go through each number in the array and record the largest alternating array up to the current number, i.e. `c`. When the alternating sequence is broken, we reset the counter `c=1`. We keep track of the maximum sequence `res`.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def alternatingSubarray(self, nums: List[int]) -> int:\\n        res,c=0,1\\n        for i in range(1,len(nums)):\\n            if nums[i]-nums[i-1]==(c%2)*2-1:\\n                c+=1\\n            elif nums[i]-nums[i-1]==1:\\n                c=2\\n            else:\\n                c=1\\n            res=max(res,c)\\n        return res if res>1 else -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def alternatingSubarray(self, nums: List[int]) -> int:\\n        res,c=0,1\\n        for i in range(1,len(nums)):\\n            if nums[i]-nums[i-1]==(c%2)*2-1:\\n                c+=1\\n            elif nums[i]-nums[i-1]==1:\\n                c=2\\n            else:\\n                c=1\\n            res=max(res,c)\\n        return res if res>1 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3756285,
                "title": "python-3-one-line",
                "content": "# Intuition\\n\\nWe\\'re counting the longest streak, and we don\\'t have to go back to the beginning when we reach the end of the streak, we can just reset the streak to 1 or 2 (2 if the last pair was rising, 1 otherwise), and keep going.\\n\\nAt the end, return the max streak we\\'ve seen.\\n\\nAlso, we need to return -1 if the max streak was 1.\\n\\n# Approach\\n\\nUse `pairwise` to iterate on each adjascent pair.\\n\\nUse `(1,-1)[streak%2]` to calculate whether we expect a rise or fall.\\n\\nSo given `streak` and the next pair `a` and `b`, we can calculate the new streak:\\n```\\nfor a,b in pairwise(nums):\\n  if a == b + (1, -1)[streak % 2]:\\n    streak = streak + 1\\n  else:\\n    streak = (a == b - 1) + 1\\n```\\n\\nWhich simplifies to:\\n\\n```\\nfor a,b in pairwise(nums):\\n  streak = (streak if a == b + (1, -1)[streak % 2] else a == b - 1) + 1\\n```\\n\\nThen we just need to capture the max value of `streak` as we go through, and do the funny 1 -> -1 logic at the end.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ one pass\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n  def alternatingSubarray(self, nums: List[int]) -> int:\\n    best = streak = 1\\n    for a,b in pairwise(nums):\\n      streak = (streak if a == b + (1, -1)[streak % 2] else a == b - 1) + 1\\n      best = max(best, streak)\\n    return -1 if best == 1 else best\\n```\\n\\n# One line\\n\\nWe can use `max(accumulate(...))` to calculate the streak in one line:\\n\\n```\\nclass Solution:\\n  def alternatingSubarray(self, nums: List[int]) -> int:\\n    return b if (b := max(accumulate(pairwise(nums), lambda s,x: (s if x[0]==x[1]+(1,-1)[s%2] else x[0]==x[1]-1) + 1, initial=1))) - 1 else -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfor a,b in pairwise(nums):\\n  if a == b + (1, -1)[streak % 2]:\\n    streak = streak + 1\\n  else:\\n    streak = (a == b - 1) + 1\\n```\n```\\nfor a,b in pairwise(nums):\\n  streak = (streak if a == b + (1, -1)[streak % 2] else a == b - 1) + 1\\n```\n```\\nclass Solution:\\n  def alternatingSubarray(self, nums: List[int]) -> int:\\n    best = streak = 1\\n    for a,b in pairwise(nums):\\n      streak = (streak if a == b + (1, -1)[streak % 2] else a == b - 1) + 1\\n      best = max(best, streak)\\n    return -1 if best == 1 else best\\n```\n```\\nclass Solution:\\n  def alternatingSubarray(self, nums: List[int]) -> int:\\n    return b if (b := max(accumulate(pairwise(nums), lambda s,x: (s if x[0]==x[1]+(1,-1)[s%2] else x[0]==x[1]-1) + 1, initial=1))) - 1 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741936,
                "title": "c-o-n-time-o-1-space-super-optimized-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        int ans = -1;\\n        int var = -1;\\n        for(int i=1; i<n; i++){\\n            if(var > 0 && nums[i] == nums[i-2]){\\n                var++;\\n            }\\n            else{\\n                var = nums[i]==nums[i-1]+1 ? 2 : -1;\\n            }\\n            ans = max(ans,var);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        int ans = -1;\\n        int var = -1;\\n        for(int i=1; i<n; i++){\\n            if(var > 0 && nums[i] == nums[i-2]){\\n                var++;\\n            }\\n            else{\\n                var = nums[i]==nums[i-1]+1 ? 2 : -1;\\n            }\\n            ans = max(ans,var);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740908,
                "title": "c-easy-and-readable-solution-faster-than-100-less-than-100",
                "content": "![image.png](https://assets.leetcode.com/users/images/99004d86-3e7d-4f5c-b7f8-34c56c8c6a7c_1688905137.597801.png)\\n\\n**Don\\'t hesitate to suggest or ask bellow about something that you don\\'t understand**\\n\\n```\\npublic class Solution {\\n    public int AlternatingSubarray(int[] nums) {\\n        int ans = -1;\\n        for (int i = 1; i < nums.Length;)\\n        {\\n            if (nums[i - 1] + 1 != nums[i++])\\n                continue;\\n            ans = Math.Max(ans, 2);\\n            for (int j = 3; i < nums.Length && nums[i] == nums[i - 2]; i++, j++)\\n                ans = Math.Max(ans, j);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nIf you like it don\\'t forget to **upvote!**",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int AlternatingSubarray(int[] nums) {\\n        int ans = -1;\\n        for (int i = 1; i < nums.Length;)\\n        {\\n            if (nums[i - 1] + 1 != nums[i++])\\n                continue;\\n            ans = Math.Max(ans, 2);\\n            for (int j = 3; i < nums.Length && nums[i] == nums[i - 2]; i++, j++)\\n                ans = Math.Max(ans, j);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740467,
                "title": "two-loops-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int maxi = 0;\\n\\n        for(int i=1; i<nums.size(); i++){\\n          int a = 0,ans = 0;\\n          for(int j=i; j<nums.size(); j++){\\n              int var = nums[j] - nums[j-1];\\n\\n              if(var == 1 && a%2==0)        ans++;\\n              else if(var == -1 && a%2!=0)  ans++;\\n              else  break;\\n              \\n              a++;\\n          }\\n          maxi  = max(maxi,ans);\\n      }\\n      return maxi != 0? maxi + 1 : -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int maxi = 0;\\n\\n        for(int i=1; i<nums.size(); i++){\\n          int a = 0,ans = 0;\\n          for(int j=i; j<nums.size(); j++){\\n              int var = nums[j] - nums[j-1];\\n\\n              if(var == 1 && a%2==0)        ans++;\\n              else if(var == -1 && a%2!=0)  ans++;\\n              else  break;\\n              \\n              a++;\\n          }\\n          maxi  = max(maxi,ans);\\n      }\\n      return maxi != 0? maxi + 1 : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740237,
                "title": "c-o-n-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int> &arr) {\\n        int maxi=1,cnt=1;\\n        int prev;  \\n        int n=arr.size();\\n        for (int i=1;i<n;i++){\\n            if(cnt%2==1) prev=-1;\\n            else prev=1;\\n            if(prev==arr[i-1]-arr[i]) cnt++;\\n            else if(arr[i-1]-arr[i]==-1) cnt=2;\\n            else cnt=1;\\n            maxi=max(maxi,cnt);\\n        }       \\n        if(maxi==1) return -1;\\n        return maxi;     \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int> &arr) {\\n        int maxi=1,cnt=1;\\n        int prev;  \\n        int n=arr.size();\\n        for (int i=1;i<n;i++){\\n            if(cnt%2==1) prev=-1;\\n            else prev=1;\\n            if(prev==arr[i-1]-arr[i]) cnt++;\\n            else if(arr[i-1]-arr[i]==-1) cnt=2;\\n            else cnt=1;\\n            maxi=max(maxi,cnt);\\n        }       \\n        if(maxi==1) return -1;\\n        return maxi;     \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739901,
                "title": "brute-force-easy-to-understand-for-begineer-s",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int alternatingSubarray(int[] nums) {\\n        int max=0;\\n        for(int i=0;i<nums.length;i++){\\n            int odd=0;\\n            int count=1;\\n            for(int j=i;j<nums.length-1;j++){\\n                if(nums[j+1]-nums[j]==1&&odd%2==0){\\n                    count++;\\n                }\\n                else if(nums[j+1]-nums[j]==-1&&odd%2!=0){\\n                    count++;\\n                }\\n                else{\\n                    break;\\n                }\\n                odd++;\\n            }\\n            max=Math.max(count,max);\\n        }\\n        if(max==1){\\n            return -1;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int alternatingSubarray(int[] nums) {\\n        int max=0;\\n        for(int i=0;i<nums.length;i++){\\n            int odd=0;\\n            int count=1;\\n            for(int j=i;j<nums.length-1;j++){\\n                if(nums[j+1]-nums[j]==1&&odd%2==0){\\n                    count++;\\n                }\\n                else if(nums[j+1]-nums[j]==-1&&odd%2!=0){\\n                    count++;\\n                }\\n                else{\\n                    break;\\n                }\\n                odd++;\\n            }\\n            max=Math.max(count,max);\\n        }\\n        if(max==1){\\n            return -1;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739797,
                "title": "code-with-proper-comment-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public static int find(int[] nums, int k) {\\n        int currentLength = 1; // Length of the current alternating subarray\\n        int maxLength = 0; // Maximum length of alternating subarray found\\n        int direction = 1; // Direction indicator (1: positive to negative, -1: negative to positive)\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            // Check if the difference between the current and previous element matches the expected pattern\\n            if (nums[i] - nums[i - 1] == Math.pow(-1, i + k) && Math.pow(-1, i + k) == direction) {\\n                currentLength++; // Increment the length if the condition is satisfied\\n                maxLength = Math.max(maxLength, currentLength); // Update the maximum length\\n                direction = -direction; // Toggle the direction indicator\\n            } else {\\n                currentLength = 1; // Reset the length if the condition is not satisfied\\n                direction = 1; // Reset the direction indicator\\n            }\\n        }\\n\\n        return maxLength; // Return the maximum length of the alternating subarray\\n    }\\n\\n    public int alternatingSubarray(int[] nums) {\\n        int maxLength = Math.max(find(nums, 0), find(nums, 1)); // Find the maximum length for both k=0 and k=1\\n\\n        if (maxLength <= 1) {\\n            return -1; // If the maximum length is less than or equal to 1, return -1\\n        } else {\\n            return maxLength; // Otherwise, return the maximum length\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public static int find(int[] nums, int k) {\\n        int currentLength = 1; // Length of the current alternating subarray\\n        int maxLength = 0; // Maximum length of alternating subarray found\\n        int direction = 1; // Direction indicator (1: positive to negative, -1: negative to positive)\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            // Check if the difference between the current and previous element matches the expected pattern\\n            if (nums[i] - nums[i - 1] == Math.pow(-1, i + k) && Math.pow(-1, i + k) == direction) {\\n                currentLength++; // Increment the length if the condition is satisfied\\n                maxLength = Math.max(maxLength, currentLength); // Update the maximum length\\n                direction = -direction; // Toggle the direction indicator\\n            } else {\\n                currentLength = 1; // Reset the length if the condition is not satisfied\\n                direction = 1; // Reset the direction indicator\\n            }\\n        }\\n\\n        return maxLength; // Return the maximum length of the alternating subarray\\n    }\\n\\n    public int alternatingSubarray(int[] nums) {\\n        int maxLength = Math.max(find(nums, 0), find(nums, 1)); // Find the maximum length for both k=0 and k=1\\n\\n        if (maxLength <= 1) {\\n            return -1; // If the maximum length is less than or equal to 1, return -1\\n        } else {\\n            return maxLength; // Otherwise, return the maximum length\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738643,
                "title": "python-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def alternatingSubarray(self, nums: List[int]) -> int:\\n        res = -1\\n        for i in range(len(nums) - 1):\\n            if nums[i + 1] - nums[i] == 1:\\n                longest = 2\\n                for j in range(i + 2, len(nums)):\\n                    if j < len(nums) and nums[j] == nums[j - 2]:\\n                        longest += 1\\n                    else:\\n                        break\\n                res = max(res, longest)\\n        return res if res != 0 else -1\\n\\n\\n\\nclass Solution {\\n    public int alternatingSubarray(int[] nums) {\\n        int res = -1;\\n        for (int i = 0; i < nums.length - 1; i ++) {\\n            if (nums[i + 1] - nums[i] == 1) {\\n                int longest = 2;\\n                for (int j = i + 2; j < nums.length; j ++) {\\n                    if (j < nums.length && nums[j] == nums[j - 2]) {\\n                        longest ++;\\n                    } else {\\n                        break;\\n                    }\\n                }\\n                res = Math.max(res, longest);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def alternatingSubarray(self, nums: List[int]) -> int:\\n        res = -1\\n        for i in range(len(nums) - 1):\\n            if nums[i + 1] - nums[i] == 1:\\n                longest = 2\\n                for j in range(i + 2, len(nums)):\\n                    if j < len(nums) and nums[j] == nums[j - 2]:\\n                        longest += 1\\n                    else:\\n                        break\\n                res = max(res, longest)\\n        return res if res != 0 else -1\\n\\n\\n\\nclass Solution {\\n    public int alternatingSubarray(int[] nums) {\\n        int res = -1;\\n        for (int i = 0; i < nums.length - 1; i ++) {\\n            if (nums[i + 1] - nums[i] == 1) {\\n                int longest = 2;\\n                for (int j = i + 2; j < nums.length; j ++) {\\n                    if (j < nums.length && nums[j] == nums[j - 2]) {\\n                        longest ++;\\n                    } else {\\n                        break;\\n                    }\\n                }\\n                res = Math.max(res, longest);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738118,
                "title": "c-simple-sliding-window-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int ans=0;\\n        int check=0,curr=-2;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]-nums[i-1]==1 && curr==-1){\\n                curr=1;\\n                ans=max(ans,i-check+1);\\n            }else if(nums[i]-nums[i-1]==-1 && curr==1){\\n                curr=-1;\\n                ans=max(ans,i-check+1);\\n            }else if(nums[i]-nums[i-1]==1 && curr==-2){\\n                curr=1;\\n                check=i-1;\\n                ans=max(ans,2);\\n            }else if(nums[i]-nums[i-1]==1 && curr==1){\\n                check=i-1;\\n                ans=max(ans,2);\\n            }else{\\n                curr=-2;\\n            }\\n        }\\n        return ans==0?-1:ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int ans=0;\\n        int check=0,curr=-2;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]-nums[i-1]==1 && curr==-1){\\n                curr=1;\\n                ans=max(ans,i-check+1);\\n            }else if(nums[i]-nums[i-1]==-1 && curr==1){\\n                curr=-1;\\n                ans=max(ans,i-check+1);\\n            }else if(nums[i]-nums[i-1]==1 && curr==-2){\\n                curr=1;\\n                check=i-1;\\n                ans=max(ans,2);\\n            }else if(nums[i]-nums[i-1]==1 && curr==1){\\n                check=i-1;\\n                ans=max(ans,2);\\n            }else{\\n                curr=-2;\\n            }\\n        }\\n        return ans==0?-1:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738096,
                "title": "longest-alternating-subarray",
                "content": "# Explanation\\n**I used simple two pointers/ sliding window approach for this question. \\nI started with a window of size 2, and maintain a variable \\'k\\' and initialised with 1.\\nin every window, i find the difference of last and second last element of window, and if it is equal to k, then increament the head (increase the window size), invert the value of k (k= -k) , increase the length counter and keep performing the same step untill either my head reaches to last index of array or my condition (nums[head]-nums[head-1] == k) is false, in this case, simply shrinked the window size to two and move the window further (tail++; head = tail+1;), make k equals to 1 again, and length counter again 1. After each iteration, calculate the max length of  valid subarray (len2 = max(len2, len1);). and at last, if max length is equals to 1, then it means i never got any valid subarray, and simply retrun -1, or otherwise, returned max length (len2).**\\n```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) \\n    {\\n        int head = 1, tail = 0, k = 1, len1 = 1, len2 = 1;\\n        while(head < nums.size())\\n        {\\n            if(nums[head]-nums[head-1] == k)\\n            {\\n                head++;\\n                k = -k;\\n                len1++;\\n            }\\n            else\\n            {\\n                tail++;\\n                head = tail+1;\\n                k = 1;\\n                len1 = 1;\\n            }\\n            len2 = max(len2, len1);\\n        }\\n        if(len2 == 1)\\n        {\\n            return -1;\\n        }\\n        return len2;\\n    }\\n};\\n...",
                "solutionTags": [
                    "C",
                    "Array",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) \\n    {\\n        int head = 1, tail = 0, k = 1, len1 = 1, len2 = 1;\\n        while(head < nums.size())\\n        {\\n            if(nums[head]-nums[head-1] == k)\\n            {\\n                head++;\\n                k = -k;\\n                len1++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3737537,
                "title": "javascript-2765-longest-alternating-subarray",
                "content": "**Biweekly Contest 108 answers:**\\n- Q1\\n  - https://leetcode.com/problems/longest-alternating-subarray/solutions/3737537/javascript-2765-longest-alternating-subarray/\\n- Q2\\n  - https://leetcode.com/problems/partition-string-into-minimum-beautiful-substrings/solutions/3737527/javascript-partition-string-into-minimum-beautiful-substrings/\\n- Q3\\n  - https://leetcode.com/problems/relocate-marbles/solutions/3737501/javascript-2766-relocate-marbles/\\n\\n===\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar alternatingSubarray = function (a) {\\n  let n = a.length\\n  let maxcc = -1\\n  for (let j = 1; j < n; j++) {\\n    let requiredVal = -1\\n    let cc = 1\\n    for (let i = j; i < n; i++) {\\n      let v = a[i - 1] - a[i]\\n      if (v === requiredVal) {\\n        requiredVal = -requiredVal\\n        cc++\\n        maxcc = Math.max(maxcc, cc)\\n      } else {\\n        requiredVal = -1\\n        cc = 1\\n      }\\n    }\\n  }\\n  return maxcc\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar alternatingSubarray = function (a) {\\n  let n = a.length\\n  let maxcc = -1\\n  for (let j = 1; j < n; j++) {\\n    let requiredVal = -1\\n    let cc = 1\\n    for (let i = j; i < n; i++) {\\n      let v = a[i - 1] - a[i]\\n      if (v === requiredVal) {\\n        requiredVal = -requiredVal\\n        cc++\\n        maxcc = Math.max(maxcc, cc)\\n      } else {\\n        requiredVal = -1\\n        cc = 1\\n      }\\n    }\\n  }\\n  return maxcc\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3737468,
                "title": "c-simple-explanation-generating-subarrays",
                "content": "The is to generate subarrays now for every element check the condition. if initially we start a subarray from index 0 then we check for next elemnts whether we can include or not. For that we take boolean variable which takes into consideration whether difference should be 1 or -1.\\nIf we cannot take the current element we cannot take the next element so we break. Now the ans will be maximum of all the values starting from any index of the array.\\n\\n**Please Upvote if u liked the soln!**\\n\\n```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int n= nums.size();\\n        int ans=-1;\\n        for(int i=0; i<n; i++){\\n            int len=1;\\n            bool flag= true;\\n            for(int j= i+1; j<n; j++){\\n                if(nums[j]-nums[j-1]==1 && flag== true){\\n                    len++;\\n                    ans= max(ans,len);\\n                    flag= false;\\n                    \\n                }\\n               else if(nums[j]-nums[j-1]==-1 && flag== false){\\n                   len++;\\n                   ans= max(ans,len);\\n                   flag= true;\\n               }\\n                else{\\n                    break;\\n                }\\n                    \\n                \\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "class Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int n= nums.size();\\n        int ans=-1;\\n        for(int i=0; i<n; i++){\\n            int len=1;\\n            bool flag= true;\\n            for(int j= i+1; j<n; j++){\\n                if(nums[j]-nums[j-1]==1 && flag== true){\\n                    len++;\\n                    ans= max(ans,len);\\n                    flag= false;\\n                    \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3737464,
                "title": "c-sliding-window",
                "content": "# Sliding Window\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) \\n    {\\n        int c=0;\\n        int n = nums.size();\\n        int i=0,j;\\n        while(i<n-1)\\n        {\\n            if(nums[i+1]-nums[i]==1)\\n            {\\n                j=i+2;\\n                int prev2 = nums[i];\\n                int prev = nums[i+1];\\n                int a=1;\\n                while(j<n && nums[j]==prev2)\\n                {\\n                    a++;\\n                    prev2=prev;\\n                    prev = nums[j];\\n                    j++;\\n                }\\n                c=max(c,a);\\n                i=j-2;\\n            }\\n            i++;\\n        }\\n        if(c==0) return -1;\\n        return c+1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) \\n    {\\n        int c=0;\\n        int n = nums.size();\\n        int i=0,j;\\n        while(i<n-1)\\n        {\\n            if(nums[i+1]-nums[i]==1)\\n            {\\n                j=i+2;\\n                int prev2 = nums[i];\\n                int prev = nums[i+1];\\n                int a=1;\\n                while(j<n && nums[j]==prev2)\\n                {\\n                    a++;\\n                    prev2=prev;\\n                    prev = nums[j];\\n                    j++;\\n                }\\n                c=max(c,a);\\n                i=j-2;\\n            }\\n            i++;\\n        }\\n        if(c==0) return -1;\\n        return c+1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3737249,
                "title": "java-two-pointers-beats-100-o-n-t-c",
                "content": "```\\nclass Solution {\\n    public int alternatingSubarray(int[] nums) {\\n        int i = 0, j = 1, diff = 1, n = nums.length, len = -1;\\n        while (j < n) {\\n            if (nums[j] - nums[j - 1] != diff) {\\n                if (nums[j] - nums[j - 1] == 1) {\\n                    i = j - 1;\\n                } else {\\n                    i = j;\\n                    j++;\\n                }\\n                diff = 1;\\n                continue;\\n            }\\n            len = Math.max(len, j - i + 1);\\n            diff = diff > 0 ? -1 : 1;\\n            j++;\\n        }\\n        return len;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int alternatingSubarray(int[] nums) {\\n        int i = 0, j = 1, diff = 1, n = nums.length, len = -1;\\n        while (j < n) {\\n            if (nums[j] - nums[j - 1] != diff) {\\n                if (nums[j] - nums[j - 1] == 1) {\\n                    i = j - 1;\\n                } else {\\n                    i = j;\\n                    j++;\\n                }\\n                diff = 1;\\n                continue;\\n            }\\n            len = Math.max(len, j - i + 1);\\n            diff = diff > 0 ? -1 : 1;\\n            j++;\\n        }\\n        return len;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3737200,
                "title": "detailed-explanation-python",
                "content": "# Solution\\n\\n```\\nclass Solution:\\n    def alternatingSubarray(self, nums: List[int]) -> int:\\n        \\n        left = 0\\n        right = 1\\n        ans = -1\\n        \\n        while right < len(nums):\\n            while right < len(nums) and nums[right] != nums[right - 1] + 1:\\n                left = right\\n                right += 1\\n            if right == len(nums):\\n                break\\n            \\n            ans = max(ans, right - left + 1)\\n            \\n            while right + 1 < len(nums) and nums[right + 1] == nums[right - 1]:\\n                right += 1\\n            ans = max(ans, right - left + 1)\\n            left = right\\n            right += 1\\n        return ans\\n```\\n\\n\\n## Concept\\n\\nThis problem is about finding the length of the longest alternating subarray in a given array. A subarray is considered alternating if it starts with some value `s0` and then continues with an alternating pattern of increment and decrement. \\n\\nThe core of the solution involves using a two-pointer approach to efficiently track and measure the size of potential alternating subarrays in the given array.\\n\\n## Detailed Explanation\\n\\nLet\\'s break down the code:\\n\\n1. **Initialize pointers and answer variable:** Two pointers, `left` and `right`, are initialized at 0 and 1 respectively, and a variable `ans` is initialized at -1 to store the maximum length of the alternating subarrays found.\\n\\n    ```python\\n    left = 0\\n    right = 1\\n    ans = -1\\n    ```\\n\\n2. **Find possible alternating subarray beginnings:** The `while` loop begins by moving the `right` pointer through the array until it encounters a value that is not one more than the value at the previous index. This effectively finds the start of a potential alternating subarray.\\n\\n    ```python\\n    while right < len(nums) and nums[right] != nums[right - 1] + 1:\\n        left = right\\n        right += 1\\n    if right == len(nums):\\n        break\\n    ```\\n\\n3. **Update maximum length:** When an alternating subarray start has been found, the maximum length `ans` is updated.\\n\\n    ```python\\n    ans = max(ans, right - left + 1)\\n    ```\\n\\n4. **Find possible alternating subarray endings:** Now, the `right` pointer continues to move through the array until it encounters a value that is not equal to the value two indices before it. This effectively finds the end of the alternating subarray.\\n\\n    ```python\\n    while right + 1 < len(nums) and nums[right + 1] == nums[right - 1]:\\n        right += 1\\n    ```\\n\\n5. **Update maximum length again:** The maximum length `ans` is updated again to account for the entire length of the found alternating subarray.\\n\\n    ```python\\n    ans = max(ans, right - left + 1)\\n    ```\\n\\n6. **Prepare for the next iteration:** The `left` pointer is moved to the current position of the `right` pointer, and the `right` pointer is moved one position forward, preparing for the next potential alternating subarray.\\n\\n    ```python\\n    left = right\\n    right += 1\\n    ```\\n\\n7. **Return the maximum length:** Finally, the maximum length `ans` of all found alternating subarrays is returned.\\n\\n    ```python\\n    return ans\\n    ```\\n\\n## Time and Space Complexity\\n\\nThe time complexity of the solution is O(n), where n is the length of the input array `nums`. This is because the algorithm involves a single pass over the array. \\n\\nThe space complexity is O(1) as the algorithm uses a constant amount of space to store the two pointers and the variable to keep track of the maximum length. \\n\\n## Conclusion\\n\\nThis solution uses the two-pointer method in a smart way to track potential alternating subarrays, calculating their lengths and updating the maximum length as necessary. It does this in a single pass, providing an efficient and elegant solution to the problem. The key understanding lies in observing the properties of the alternating subarrays and designing the logic to detect their start and end points accurately.",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def alternatingSubarray(self, nums: List[int]) -> int:\\n        \\n        left = 0\\n        right = 1\\n        ans = -1\\n        \\n        while right < len(nums):\\n            while right < len(nums) and nums[right] != nums[right - 1] + 1:\\n                left = right\\n                right += 1\\n            if right == len(nums):\\n                break\\n            \\n            ans = max(ans, right - left + 1)\\n            \\n            while right + 1 < len(nums) and nums[right + 1] == nums[right - 1]:\\n                right += 1\\n            ans = max(ans, right - left + 1)\\n            left = right\\n            right += 1\\n        return ans\\n```\n```python\\n    left = 0\\n    right = 1\\n    ans = -1\\n    ```\n```python\\n    while right < len(nums) and nums[right] != nums[right - 1] + 1:\\n        left = right\\n        right += 1\\n    if right == len(nums):\\n        break\\n    ```\n```python\\n    ans = max(ans, right - left + 1)\\n    ```\n```python\\n    while right + 1 < len(nums) and nums[right + 1] == nums[right - 1]:\\n        right += 1\\n    ```\n```python\\n    ans = max(ans, right - left + 1)\\n    ```\n```python\\n    left = right\\n    right += 1\\n    ```\n```python\\n    return ans\\n    ```",
                "codeTag": "Java"
            },
            {
                "id": 3737151,
                "title": "c-easy-to-understand-solution-using-flag",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nKeeping a boolean flag to know the alternate subarray order\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int maxLen = INT_MIN;\\n        int maxCurr = 1;\\n        bool plusOne = true;\\n        for(int i = 0; i < nums.size()-1; i++)\\n        {\\n            if(nums[i+1]-nums[i] == 1 && plusOne)\\n            {\\n                maxCurr++;\\n                plusOne = false;\\n            }\\n            else if(nums[i+1]-nums[i] == -1 && !plusOne)\\n            {\\n                maxCurr++;\\n                plusOne = true;\\n            }\\n            else\\n            {\\n                maxLen = max(maxLen,maxCurr);\\n                if(nums[i+1]-nums[i] == 1)\\n                {\\n                    maxCurr = 2;\\n                    plusOne = false;\\n                }\\n                else\\n                {\\n                    maxCurr = 1;\\n                    plusOne = true;\\n                }\\n            }\\n        }\\n        \\n        \\n        int res = max(maxLen,maxCurr);\\n        if(res == 1)\\n            return -1;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int maxLen = INT_MIN;\\n        int maxCurr = 1;\\n        bool plusOne = true;\\n        for(int i = 0; i < nums.size()-1; i++)\\n        {\\n            if(nums[i+1]-nums[i] == 1 && plusOne)\\n            {\\n                maxCurr++;\\n                plusOne = false;\\n            }\\n            else if(nums[i+1]-nums[i] == -1 && !plusOne)\\n            {\\n                maxCurr++;\\n                plusOne = true;\\n            }\\n            else\\n            {\\n                maxLen = max(maxLen,maxCurr);\\n                if(nums[i+1]-nums[i] == 1)\\n                {\\n                    maxCurr = 2;\\n                    plusOne = false;\\n                }\\n                else\\n                {\\n                    maxCurr = 1;\\n                    plusOne = true;\\n                }\\n            }\\n        }\\n        \\n        \\n        int res = max(maxLen,maxCurr);\\n        if(res == 1)\\n            return -1;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4099046,
                "title": "2ms-solution-easy-to-understand-just-using-loops",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nwe have used here a boolean datatype to ensure whether the difference is 1 or -1\\n\\nwe have returned count+1 not count because here as increase prev integer we start it from second place \\ni think rest is easy to understand\\n\\n# Complexity\\n- Time complexity:\\nO(n!)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int alternatingSubarray(int[] nums) {\\n        int count =0;\\n        int prev=0;\\n        boolean flag = true;\\n\\n        for(int i=0;i<nums.length-1;i++){\\n            for(int j=i+1; j<nums.length;j++){\\n                if(flag==true){\\n                    if(nums[j]-nums[j-1]==1){\\n                        prev++;\\n                        flag=false;\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                }\\n                else{\\n                    if(nums[j]-nums[j-1]==-1){\\n                        prev++;\\n                        flag=true;\\n                    }\\n                    else{\\n                        flag=true;\\n                        break;\\n                    }\\n                }\\n            }\\n            count = Math.max(count, prev);\\n            prev=0;\\n        }\\n\\n        if(count==0){\\n            return -1;\\n        }\\n\\n        return count+1;\\n    }\\n}\\n```\\n![upvote2.jpeg](https://assets.leetcode.com/users/images/92fdf3c1-86dd-4560-a8ed-be49f954a153_1695879350.7301524.jpeg)\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int alternatingSubarray(int[] nums) {\\n        int count =0;\\n        int prev=0;\\n        boolean flag = true;\\n\\n        for(int i=0;i<nums.length-1;i++){\\n            for(int j=i+1; j<nums.length;j++){\\n                if(flag==true){\\n                    if(nums[j]-nums[j-1]==1){\\n                        prev++;\\n                        flag=false;\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                }\\n                else{\\n                    if(nums[j]-nums[j-1]==-1){\\n                        prev++;\\n                        flag=true;\\n                    }\\n                    else{\\n                        flag=true;\\n                        break;\\n                    }\\n                }\\n            }\\n            count = Math.max(count, prev);\\n            prev=0;\\n        }\\n\\n        if(count==0){\\n            return -1;\\n        }\\n\\n        return count+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078739,
                "title": "c-easy-solution-with-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAnother way to look at this problem is to understand certain numbers in the given array needs to be a certain position.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn the given array, first try to find an index i such that nums[i-1]+1 == nums[i+1]. In other words the same number needs to exsist at index i-1 and i+1\\nOnce such i is found, we know that there are at least 2 alternativing subarray, so we set the result as 2.\\nFrom this point onwards, we need to check if the number at index i-2 == i. If yes keep increamenting i until this condition breaks and also update the answer by one with each increament of i.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int AlternatingSubarray(int[] nums) {\\n        int result = -1;\\n        for(int i=1;i<nums.Length;){\\n            if(nums[i-1]+1 != nums[i++]){\\n                continue;\\n            }\\n            result = Math.Max(result,2);\\n            for(int j=3; i < nums.Length && nums[i-2]== nums[i];i++,j++){\\n                result = Math.Max(result,j);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int AlternatingSubarray(int[] nums) {\\n        int result = -1;\\n        for(int i=1;i<nums.Length;){\\n            if(nums[i-1]+1 != nums[i++]){\\n                continue;\\n            }\\n            result = Math.Max(result,2);\\n            for(int j=3; i < nums.Length && nums[i-2]== nums[i];i++,j++){\\n                result = Math.Max(result,j);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4058362,
                "title": "simple-approach-in-single-loop-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int count = 0, maxi = INT_MIN;\\n        bool flag = true;\\n        for( int i=1; i<nums.size(); i++ ) {\\n            if( (flag && (nums.at(i) - nums.at(i-1)) == 1) || (!flag && (nums.at(i) - nums.at(i-1)) == -1) ) {\\n                count++;\\n                maxi = max( count, maxi );\\n                flag = !flag;\\n            }\\n            else {\\n                maxi = max( count, maxi );\\n                count = 0;\\n                flag = true;\\n                if( (flag && (nums.at(i) - nums.at(i-1)) == 1) || (!flag && (nums.at(i) - nums.at(i-1)) == -1) ) {\\n                    count++;\\n                    flag = !flag;\\n                }\\n            }\\n        }\\n        \\n        return !maxi ? -1 : maxi+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int count = 0, maxi = INT_MIN;\\n        bool flag = true;\\n        for( int i=1; i<nums.size(); i++ ) {\\n            if( (flag && (nums.at(i) - nums.at(i-1)) == 1) || (!flag && (nums.at(i) - nums.at(i-1)) == -1) ) {\\n                count++;\\n                maxi = max( count, maxi );\\n                flag = !flag;\\n            }\\n            else {\\n                maxi = max( count, maxi );\\n                count = 0;\\n                flag = true;\\n                if( (flag && (nums.at(i) - nums.at(i-1)) == 1) || (!flag && (nums.at(i) - nums.at(i-1)) == -1) ) {\\n                    count++;\\n                    flag = !flag;\\n                }\\n            }\\n        }\\n        \\n        return !maxi ? -1 : maxi+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4050336,
                "title": "python-rust-solutions-0-ms",
                "content": "# Code\\n```python []\\nclass Solution:\\n    def alternatingSubarray(self, nums: List[int]) -> int:\\n        alternate_array: list[int] = []\\n        prev, count, result = 0, 0, 0\\n\\n        for i in range(len(nums) - 1):\\n            alternate_array.append(nums[i + 1] - nums[i])\\n\\n        for s in alternate_array:\\n            if (s == 1 and (prev == -1 or count == 0)) or (s == -1 and prev == 1):\\n                count += 1\\n                prev = s\\n                continue\\n            prev = s\\n            result = max(result, count)\\n            if s == 1 and prev != -1:\\n                count = 1\\n            else:\\n                count = 0\\n\\n        if count != 0:\\n            result = max(result, count)\\n        if result == 0:\\n            return -1\\n        return result + 1\\n```\\n```rust []\\nimpl Solution {\\n    pub fn alternating_subarray(nums: Vec<i32>) -> i32 {\\n        let mut alternate_array = vec![];\\n        for num in nums.windows(2) {\\n            alternate_array.push(num[1] - num[0]);\\n        }\\n        let (mut prev, mut count, mut result) = (0, 0, 0);\\n        for &s in alternate_array.iter() {\\n            if (s == 1 && (prev == -1 || count == 0)) || (s == -1 && prev == 1) {\\n                count += 1;\\n                prev = s;\\n                continue;\\n            }\\n            prev = s;\\n            result = result.max(count);\\n            if s == 1 && prev != -1 {\\n                count = 1;\\n            } else {\\n                count = 0;\\n            }\\n        }\\n        if count != 0 {\\n            result = result.max(count);\\n        }\\n        if result == 0 {\\n            return -1;\\n        }\\n        result + 1\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Rust"
                ],
                "code": "```python []\\nclass Solution:\\n    def alternatingSubarray(self, nums: List[int]) -> int:\\n        alternate_array: list[int] = []\\n        prev, count, result = 0, 0, 0\\n\\n        for i in range(len(nums) - 1):\\n            alternate_array.append(nums[i + 1] - nums[i])\\n\\n        for s in alternate_array:\\n            if (s == 1 and (prev == -1 or count == 0)) or (s == -1 and prev == 1):\\n                count += 1\\n                prev = s\\n                continue\\n            prev = s\\n            result = max(result, count)\\n            if s == 1 and prev != -1:\\n                count = 1\\n            else:\\n                count = 0\\n\\n        if count != 0:\\n            result = max(result, count)\\n        if result == 0:\\n            return -1\\n        return result + 1\\n```\n```rust []\\nimpl Solution {\\n    pub fn alternating_subarray(nums: Vec<i32>) -> i32 {\\n        let mut alternate_array = vec![];\\n        for num in nums.windows(2) {\\n            alternate_array.push(num[1] - num[0]);\\n        }\\n        let (mut prev, mut count, mut result) = (0, 0, 0);\\n        for &s in alternate_array.iter() {\\n            if (s == 1 && (prev == -1 || count == 0)) || (s == -1 && prev == 1) {\\n                count += 1;\\n                prev = s;\\n                continue;\\n            }\\n            prev = s;\\n            result = result.max(count);\\n            if s == 1 && prev != -1 {\\n                count = 1;\\n            } else {\\n                count = 0;\\n            }\\n        }\\n        if count != 0 {\\n            result = result.max(count);\\n        }\\n        if result == 0 {\\n            return -1;\\n        }\\n        result + 1\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035682,
                "title": "php-simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @return Integer\\n     */\\n    function alternatingSubarray($nums) {\\n        $result = 0;\\n        $ln = count($nums);\\n        \\n        for($i = 0; $i < $ln; $i++) {\\n            $curMax = 0;\\n            $carry = 0;\\n            \\n            for($j = $i + 1; $j < $ln; $j++) {\\n                $sum = $nums[$j] - $nums[$j - 1];\\n\\n                if ($carry === 0) {\\n                    if ($sum === 1) {\\n                        $curMax += 2;\\n                        $carry = $sum;\\n                    } else {\\n                        break;\\n                    }\\n\\n                    continue;\\n                }\\n\\n                if ($sum + $carry === 0) {\\n                    $curMax++;\\n                    $carry = $sum;\\n                    \\n                    continue;\\n                } \\n\\n                break;\\n            }\\n\\n            if ($curMax > $result) {\\n                $result = $curMax;\\n            }\\n        }\\n        \\n        return $result > 0? $result: -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @return Integer\\n     */\\n    function alternatingSubarray($nums) {\\n        $result = 0;\\n        $ln = count($nums);\\n        \\n        for($i = 0; $i < $ln; $i++) {\\n            $curMax = 0;\\n            $carry = 0;\\n            \\n            for($j = $i + 1; $j < $ln; $j++) {\\n                $sum = $nums[$j] - $nums[$j - 1];\\n\\n                if ($carry === 0) {\\n                    if ($sum === 1) {\\n                        $curMax += 2;\\n                        $carry = $sum;\\n                    } else {\\n                        break;\\n                    }\\n\\n                    continue;\\n                }\\n\\n                if ($sum + $carry === 0) {\\n                    $curMax++;\\n                    $carry = $sum;\\n                    \\n                    continue;\\n                } \\n\\n                break;\\n            }\\n\\n            if ($curMax > $result) {\\n                $result = $curMax;\\n            }\\n        }\\n        \\n        return $result > 0? $result: -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4024898,
                "title": "python3-straightforward-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def alternatingSubarray(self, nums: List[int]) -> int:\\n        N = len(nums)\\n        ans = -1\\n\\n        for i in range(N-1):\\n            a = nums[i]\\n            b = nums[i+1]\\n            if b-a != 1:\\n                continue\\n            curIdx = i\\n            cnt = 2\\n            alt = 0\\n            for k in range(i+2, N):\\n                if alt%2==0:\\n                    if nums[k]==a:\\n                        cnt+=1\\n                    else:\\n                        break\\n                else:\\n                    if nums[k]==b:\\n                        cnt+=1\\n                    else:\\n                        break\\n                alt+=1\\n            ans = max(ans, cnt)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def alternatingSubarray(self, nums: List[int]) -> int:\\n        N = len(nums)\\n        ans = -1\\n\\n        for i in range(N-1):\\n            a = nums[i]\\n            b = nums[i+1]\\n            if b-a != 1:\\n                continue\\n            curIdx = i\\n            cnt = 2\\n            alt = 0\\n            for k in range(i+2, N):\\n                if alt%2==0:\\n                    if nums[k]==a:\\n                        cnt+=1\\n                    else:\\n                        break\\n                else:\\n                    if nums[k]==b:\\n                        cnt+=1\\n                    else:\\n                        break\\n                alt+=1\\n            ans = max(ans, cnt)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4013841,
                "title": "most-easy-java-solution-with-time-complexity-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nBrute Force \\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:=O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int alternatingSubarray(int[] nums) {\\n        int count = 0; int prevcount = 0;\\n        for(int i = 0;i<nums.length;i++){\\n        if(i==nums.length-1){if(count>=1){count++; break;}else break;}\\n            if(nums[i+1]-nums[i] == (int) Math.pow(-1,count)){ count+=1;}\\n            else{if(count>=prevcount){\\n                count++;  \\n                prevcount = count;\\n                count=0;\\n                if(nums[i+1] - nums[i] == (int) Math.pow(-1,count)){\\n                count+=1; }\\n            }\\n            else{count=0;\\n            if(nums[i+1]-nums[i] == (int) Math.pow(-1,count)){\\n                count+=1; }}}\\n        }\\n        if(prevcount>1 && prevcount>count) return prevcount;\\n        else if(count>1) return count;\\n        else{return -1;}\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int alternatingSubarray(int[] nums) {\\n        int count = 0; int prevcount = 0;\\n        for(int i = 0;i<nums.length;i++){\\n        if(i==nums.length-1){if(count>=1){count++; break;}else break;}\\n            if(nums[i+1]-nums[i] == (int) Math.pow(-1,count)){ count+=1;}\\n            else{if(count>=prevcount){\\n                count++;  \\n                prevcount = count;\\n                count=0;\\n                if(nums[i+1] - nums[i] == (int) Math.pow(-1,count)){\\n                count+=1; }\\n            }\\n            else{count=0;\\n            if(nums[i+1]-nums[i] == (int) Math.pow(-1,count)){\\n                count+=1; }}}\\n        }\\n        if(prevcount>1 && prevcount>count) return prevcount;\\n        else if(count>1) return count;\\n        else{return -1;}\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010326,
                "title": "easy-to-understand-python3-solution-brute-force-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def alternatingSubarray(self, nums: List[int]) -> int:\\n        m = -1\\n        l = 0\\n\\n        while l < len(nums)-1:\\n            r = l + 1\\n            neg = False\\n            while r < len(nums):\\n                if not neg:\\n                    if nums[r] == nums[r-1] + 1:\\n                        neg = True\\n                    else:\\n                        break\\n                elif neg:\\n                    if nums[r] == nums[r-1] - 1:\\n                        neg = False\\n                    else:\\n                        break\\n                else:\\n                    break\\n                r += 1\\n \\n            m = max(m, r-l)\\n            l += 1\\n\\n        if m > 1:\\n            return m\\n        \\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def alternatingSubarray(self, nums: List[int]) -> int:\\n        m = -1\\n        l = 0\\n\\n        while l < len(nums)-1:\\n            r = l + 1\\n            neg = False\\n            while r < len(nums):\\n                if not neg:\\n                    if nums[r] == nums[r-1] + 1:\\n                        neg = True\\n                    else:\\n                        break\\n                elif neg:\\n                    if nums[r] == nums[r-1] - 1:\\n                        neg = False\\n                    else:\\n                        break\\n                else:\\n                    break\\n                r += 1\\n \\n            m = max(m, r-l)\\n            l += 1\\n\\n        if m > 1:\\n            return m\\n        \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4008402,
                "title": "simple-o-n-javascript-typescript-solution-beats-100",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nconst alternatingSubarray = (nums: number[]): number => {\\n  let curLength = 1;\\n  let maxLength = 1;\\n  let diff = 1;\\n\\n  for (let i = 1; i < nums.length; i++) {\\n    if (nums[i] - nums[i - 1] === diff) {\\n      curLength++;\\n      diff = 0 - diff;\\n      maxLength = Math.max(maxLength, curLength);\\n      continue;\\n    }\\n    const isSecond = nums[i] - nums[i - 1] === 1;\\n    curLength = isSecond ? 2 : 1;\\n    diff = isSecond ? -1 : 1;\\n  }\\n\\n  return maxLength > 1 ? maxLength : -1;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nconst alternatingSubarray = (nums: number[]): number => {\\n  let curLength = 1;\\n  let maxLength = 1;\\n  let diff = 1;\\n\\n  for (let i = 1; i < nums.length; i++) {\\n    if (nums[i] - nums[i - 1] === diff) {\\n      curLength++;\\n      diff = 0 - diff;\\n      maxLength = Math.max(maxLength, curLength);\\n      continue;\\n    }\\n    const isSecond = nums[i] - nums[i - 1] === 1;\\n    curLength = isSecond ? 2 : 1;\\n    diff = isSecond ? -1 : 1;\\n  }\\n\\n  return maxLength > 1 ? maxLength : -1;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3999520,
                "title": "beats-95-c-easy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int n = nums.size();\\n        int res = 0;\\n        for (int i=0;i<n;++i)  {\\n            for(int j=i+1;j<n && nums[j] == nums[i] +(j-i)%2;++j){\\n                res = max(res,j-i+1);\\n            }\\n        } \\n        return res>1 ? res: -1; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int n = nums.size();\\n        int res = 0;\\n        for (int i=0;i<n;++i)  {\\n            for(int j=i+1;j<n && nums[j] == nums[i] +(j-i)%2;++j){\\n                res = max(res,j-i+1);\\n            }\\n        } \\n        return res>1 ? res: -1; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988137,
                "title": "easy-explained-solution-without-2-pointers-python",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def alternatingSubarray(self, nums: List[int]) -> int:\\n        i = 1\\n        max_len, curr_len = 0, 1\\n        diff = -1\\n\\n        # since the continuation of the array does not depend on the start\\n        # of the array, there is not need to do an embedded loop to restart\\n        # from the same left index every time, instead, when the continuation\\n        # breaks, we have two cases:\\n        # 1- there was an actual continuation up to a certain point and now we have\\n        # to break it, in which case just decrement the index to restart from where we are now\\n        # 2- there was no actual continuation (curr_len is still = 1, ex: nums[i] = 5, nums[i-1] = 30),\\n        # in this case, we do not decrement the index as we will enter a continuous loop\\n        while i < len(nums):\\n            if nums[i] - nums[i-1] == -diff:\\n                diff = -diff\\n                curr_len += 1\\n            else:\\n                max_len = max(max_len, curr_len)\\n                if curr_len > 1:\\n                    i -= 1\\n                curr_len = 1\\n                diff = -1\\n            \\n            i += 1\\n\\n        max_len = max(max_len, curr_len)\\n        return max_len if max_len > 1 else -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def alternatingSubarray(self, nums: List[int]) -> int:\\n        i = 1\\n        max_len, curr_len = 0, 1\\n        diff = -1\\n\\n        # since the continuation of the array does not depend on the start\\n        # of the array, there is not need to do an embedded loop to restart\\n        # from the same left index every time, instead, when the continuation\\n        # breaks, we have two cases:\\n        # 1- there was an actual continuation up to a certain point and now we have\\n        # to break it, in which case just decrement the index to restart from where we are now\\n        # 2- there was no actual continuation (curr_len is still = 1, ex: nums[i] = 5, nums[i-1] = 30),\\n        # in this case, we do not decrement the index as we will enter a continuous loop\\n        while i < len(nums):\\n            if nums[i] - nums[i-1] == -diff:\\n                diff = -diff\\n                curr_len += 1\\n            else:\\n                max_len = max(max_len, curr_len)\\n                if curr_len > 1:\\n                    i -= 1\\n                curr_len = 1\\n                diff = -1\\n            \\n            i += 1\\n\\n        max_len = max(max_len, curr_len)\\n        return max_len if max_len > 1 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977745,
                "title": "cute-javascript-solution",
                "content": "\\n```\\nvar alternatingSubarray = function (nums) {\\n    let max = -1\\n    for (let i = 0; i < nums.length; i++) {\\n        const start = nums[i]\\n        let shouldBeSameAsStart = false\\n        for (let j = i + 1; i < nums.length; j++) {\\n            const end = nums[j]\\n            if ((shouldBeSameAsStart && end === start)\\n                || (!shouldBeSameAsStart && end === start + 1)) {\\n                max = Math.max(max, j - i + 1)\\n                shouldBeSameAsStart = !shouldBeSameAsStart\\n            }\\n            else break\\n        }\\n    }\\n    return max\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar alternatingSubarray = function (nums) {\\n    let max = -1\\n    for (let i = 0; i < nums.length; i++) {\\n        const start = nums[i]\\n        let shouldBeSameAsStart = false\\n        for (let j = i + 1; i < nums.length; j++) {\\n            const end = nums[j]\\n            if ((shouldBeSameAsStart && end === start)\\n                || (!shouldBeSameAsStart && end === start + 1)) {\\n                max = Math.max(max, j - i + 1)\\n                shouldBeSameAsStart = !shouldBeSameAsStart\\n            }\\n            else break\\n        }\\n    }\\n    return max\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3969740,
                "title": "beats-100-simple-for-loop-c",
                "content": "# Intuition\\nEasy but with 33.1% acceptance, tricky; you need to reread the problem again to understand it well.\\n\\n# Approach\\nI got this by trial and error in response to failed submissions. \\nOne For loop with many ifs LOL\\nI have created pretty simple logic tho \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n  public int AlternatingSubarray(int[] nums) {\\n\\n    int len = nums.Length;\\n    int res = -1;\\n    int temp = -1;\\n\\n    for(int i = 0; i < len - 1; i++){\\n      if(nums[i+1] - nums[i] == 1 && res == -1){\\n        res = 2;\\n      }\\n      \\n      if(i < len -2){\\n        if(nums[i] == nums[i+2] && nums[i+1] - nums[i] == 1 && temp == -1){\\n          temp = 3;\\n        }\\n        else if(nums[i] == nums[i+2] && temp > -1){\\n          temp++;\\n        }\\n        else{\\n          temp = -1;\\n        }\\n      }\\n      if(temp > res){\\n        res = temp;\\n      }      \\n    }\\n\\n    return res;\\n  }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n  public int AlternatingSubarray(int[] nums) {\\n\\n    int len = nums.Length;\\n    int res = -1;\\n    int temp = -1;\\n\\n    for(int i = 0; i < len - 1; i++){\\n      if(nums[i+1] - nums[i] == 1 && res == -1){\\n        res = 2;\\n      }\\n      \\n      if(i < len -2){\\n        if(nums[i] == nums[i+2] && nums[i+1] - nums[i] == 1 && temp == -1){\\n          temp = 3;\\n        }\\n        else if(nums[i] == nums[i+2] && temp > -1){\\n          temp++;\\n        }\\n        else{\\n          temp = -1;\\n        }\\n      }\\n      if(temp > res){\\n        res = temp;\\n      }      \\n    }\\n\\n    return res;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3967458,
                "title": "runtime-beats-99-memory-beats-89",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def alternatingSubarray(self, nums: List[int]) -> int:\\n        counter = 1\\n        max_length = 1\\n        is_increasing = False\\n        is_decreasing = False\\n        for i in range(1, len(nums)):\\n            if nums[i] - nums[i - 1] == 1:\\n                if is_increasing and not(is_decreasing):\\n                    counter = 2\\n                elif is_decreasing:\\n                    counter += 1\\n                    is_increasing = True\\n                    is_decreasing = False\\n                elif not(is_increasing and is_decreasing):\\n                    counter += 1\\n                    is_increasing = True\\n            elif nums[i] - nums[i - 1] == -1:\\n                if is_decreasing and not(is_increasing):\\n                    counter = 1\\n                elif is_increasing:\\n                    counter += 1\\n                    is_decreasing = True\\n                    is_increasing = False\\n                elif not(is_increasing and is_decreasing):\\n                    counter = 1\\n                    is_decreasing = True\\n            else:\\n                is_increasing = False\\n                is_decreasing = False\\n                max_length = max(max_length, counter)\\n                counter = 1\\n                \\n            max_length = max(max_length, counter)\\n\\n\\n        \\n        return -1 if max_length == 1 else max_length\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def alternatingSubarray(self, nums: List[int]) -> int:\\n        counter = 1\\n        max_length = 1\\n        is_increasing = False\\n        is_decreasing = False\\n        for i in range(1, len(nums)):\\n            if nums[i] - nums[i - 1] == 1:\\n                if is_increasing and not(is_decreasing):\\n                    counter = 2\\n                elif is_decreasing:\\n                    counter += 1\\n                    is_increasing = True\\n                    is_decreasing = False\\n                elif not(is_increasing and is_decreasing):\\n                    counter += 1\\n                    is_increasing = True\\n            elif nums[i] - nums[i - 1] == -1:\\n                if is_decreasing and not(is_increasing):\\n                    counter = 1\\n                elif is_increasing:\\n                    counter += 1\\n                    is_decreasing = True\\n                    is_increasing = False\\n                elif not(is_increasing and is_decreasing):\\n                    counter = 1\\n                    is_decreasing = True\\n            else:\\n                is_increasing = False\\n                is_decreasing = False\\n                max_length = max(max_length, counter)\\n                counter = 1\\n                \\n            max_length = max(max_length, counter)\\n\\n\\n        \\n        return -1 if max_length == 1 else max_length\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3961561,
                "title": "simple-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int alternatingSubarray(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        vector<int> diff(n-1,0);\\n        for(int x=0; x<n-1; x++)\\n        {\\n            diff[x]=nums[x+1]-nums[x];\\n        }\\n        int ans=0;\\n        for(int x=0; x<diff.size(); x++)\\n        {\\n            if(diff[x]==1)\\n            {\\n                int y=x;\\n                int num=1;\\n                while(y<n-1 && diff[y]==num)\\n                {\\n                    y++;\\n                    num=(num==-1)?1:-1;\\n                }\\n                ans=max(ans,y-x+1);\\n            }\\n        }\\n        if(ans==0) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int alternatingSubarray(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        vector<int> diff(n-1,0);\\n        for(int x=0; x<n-1; x++)\\n        {\\n            diff[x]=nums[x+1]-nums[x];\\n        }\\n        int ans=0;\\n        for(int x=0; x<diff.size(); x++)\\n        {\\n            if(diff[x]==1)\\n            {\\n                int y=x;\\n                int num=1;\\n                while(y<n-1 && diff[y]==num)\\n                {\\n                    y++;\\n                    num=(num==-1)?1:-1;\\n                }\\n                ans=max(ans,y-x+1);\\n            }\\n        }\\n        if(ans==0) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939380,
                "title": "python-sliding-window-o-n",
                "content": "```\\nclass Solution:\\n    def alternatingSubarray(self, nums: List[int]) -> int:\\n        r = 1\\n        best = 0\\n        n=len(nums)\\n        while r<n:\\n            parity = nums[r]-nums[r-1]\\n            if parity==1:\\n                currl = 1\\n                while r<n and nums[r]-nums[r-1]==parity:\\n                    r+=1\\n                    currl+=1\\n                    parity = -1*parity\\n                if currl!=1:best = max(best,currl)\\n            else:\\n                r+=1\\n        return best if best!=0 else -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def alternatingSubarray(self, nums: List[int]) -> int:\\n        r = 1\\n        best = 0\\n        n=len(nums)\\n        while r<n:\\n            parity = nums[r]-nums[r-1]\\n            if parity==1:\\n                currl = 1\\n                while r<n and nums[r]-nums[r-1]==parity:\\n                    r+=1\\n                    currl+=1\\n                    parity = -1*parity\\n                if currl!=1:best = max(best,currl)\\n            else:\\n                r+=1\\n        return best if best!=0 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3935776,
                "title": "simple-solution-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def alternatingSubarray(self, nums: List[int]) -> int:\\n        result, count = -1, 0\\n        state = True\\n        \\n        for i in range(1, len(nums)):\\n            if nums[i] - nums[i-1] == 1:\\n                if not state:\\n                    count = 0\\n                count += 1\\n                state = False\\n            elif nums[i] - nums[i-1] == -1 and not state:\\n                count += 1\\n                state = True\\n            else:\\n                state = True\\n                count = 0\\n                \\n            result = max(result, count)\\n            \\n        return result + 1 if result != 0 else -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def alternatingSubarray(self, nums: List[int]) -> int:\\n        result, count = -1, 0\\n        state = True\\n        \\n        for i in range(1, len(nums)):\\n            if nums[i] - nums[i-1] == 1:\\n                if not state:\\n                    count = 0\\n                count += 1\\n                state = False\\n            elif nums[i] - nums[i-1] == -1 and not state:\\n                count += 1\\n                state = True\\n            else:\\n                state = True\\n                count = 0\\n                \\n            result = max(result, count)\\n            \\n        return result + 1 if result != 0 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3932757,
                "title": "easy-and-clean-code-to-understand-c-beginner-friendly-solution",
                "content": "Upvote if you find the solution helpful !!\\n```cpp\\nint alternatingSubarray(vector<int>& nums) \\n    {\\n        int longest=0,cur=1,x=-1;\\n        bool flag=false;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i-1]-x==nums[i])\\n            {\\n                cur++;\\n                x=-x;\\n                flag=true;\\n            }\\n            else\\n            {\\n                longest=max(longest,cur);\\n                cur=1;\\n                x=-1;\\n                if(flag)\\n                {\\n                    i--;\\n                    flag=false;\\n                }\\n            }\\n        }\\n        longest=max(longest,cur);\\n        if(longest==1)\\n        {\\n            return -1;\\n        }\\n        return longest;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "Upvote if you find the solution helpful !!\\n```cpp\\nint alternatingSubarray(vector<int>& nums) \\n    {\\n        int longest=0,cur=1,x=-1;\\n        bool flag=false;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i-1]-x==nums[i])\\n            {\\n                cur++;\\n                x=-x;\\n                flag=true;\\n            }\\n            else\\n            {\\n                longest=max(longest,cur);\\n                cur=1;\\n                x=-1;\\n                if(flag)\\n                {\\n                    i--;\\n                    flag=false;\\n                }\\n            }\\n        }\\n        longest=max(longest,cur);\\n        if(longest==1)\\n        {\\n            return -1;\\n        }\\n        return longest;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3924374,
                "title": "java-beats-98-38-o-n-time",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int alternatingSubarray(int[] nums) {\\n        int n = nums.length;\\n        int[] inc = new int[n];\\n        int[] dec = new int[n];\\n        inc[n-1] = 1;\\n        dec[n-1] = 1;\\n        int ans = 0;\\n        for(int i = n-2;i>=0;i--)\\n        {\\n            if(nums[i]-nums[i+1] == -1)\\n            {\\n                inc[i] = dec[i+1]+1;\\n                dec[i] = 1;\\n            }\\n            else if(nums[i]-nums[i+1] == 1)\\n            {\\n                inc[i] = 1;\\n                dec[i] = inc[i+1]+1;\\n            }\\n            else\\n            {\\n                dec[i] = 1;\\n                inc[i] = 1;\\n            }\\n            ans = Math.max(ans,inc[i]);\\n        }\\n        return ans==1?-1:ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int alternatingSubarray(int[] nums) {\\n        int n = nums.length;\\n        int[] inc = new int[n];\\n        int[] dec = new int[n];\\n        inc[n-1] = 1;\\n        dec[n-1] = 1;\\n        int ans = 0;\\n        for(int i = n-2;i>=0;i--)\\n        {\\n            if(nums[i]-nums[i+1] == -1)\\n            {\\n                inc[i] = dec[i+1]+1;\\n                dec[i] = 1;\\n            }\\n            else if(nums[i]-nums[i+1] == 1)\\n            {\\n                inc[i] = 1;\\n                dec[i] = inc[i+1]+1;\\n            }\\n            else\\n            {\\n                dec[i] = 1;\\n                inc[i] = 1;\\n            }\\n            ans = Math.max(ans,inc[i]);\\n        }\\n        return ans==1?-1:ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3915680,
                "title": "js-two-solutions-simple-and-clear-o-n",
                "content": "1. Solution - O (n ^ 2)\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar alternatingSubarray = function(nums) {\\n    max = 0\\n\\n    for (let i = 1; i < nums.length; i++) {\\n        val = 1, count = 0\\n        for (let j = i; j < nums.length; j++) {\\n            if (nums[j] - nums[j-1] == val) {\\n                count ++\\n                val *= -1\\n                max = Math.max(count, max)\\n            } else {\\n                break\\n            }\\n        }\\n    }\\n\\n    return max > 0 ? max + 1 : -1\\n};\\n```\\n2. Solution - O (n)\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar alternatingSubarray = function(nums) {\\n    max = 0\\n\\n    for (let i = 1; i < nums.length; i++) {\\n        val = 1, count = 0\\n        for (let j = i; j < nums.length; j++) {\\n            if (nums[j] - nums[j-1] == val) {\\n                count ++\\n                val *= -1\\n                max = Math.max(count, max)\\n            } else {\\n                if (count > 1) i += count - 1   // move i index forward on count value\\n                break\\n            }\\n        }\\n    }\\n\\n    return max > 0 ? max + 1 : -1\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar alternatingSubarray = function(nums) {\\n    max = 0\\n\\n    for (let i = 1; i < nums.length; i++) {\\n        val = 1, count = 0\\n        for (let j = i; j < nums.length; j++) {\\n            if (nums[j] - nums[j-1] == val) {\\n                count ++\\n                val *= -1\\n                max = Math.max(count, max)\\n            } else {\\n                break\\n            }\\n        }\\n    }\\n\\n    return max > 0 ? max + 1 : -1\\n};\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar alternatingSubarray = function(nums) {\\n    max = 0\\n\\n    for (let i = 1; i < nums.length; i++) {\\n        val = 1, count = 0\\n        for (let j = i; j < nums.length; j++) {\\n            if (nums[j] - nums[j-1] == val) {\\n                count ++\\n                val *= -1\\n                max = Math.max(count, max)\\n            } else {\\n                if (count > 1) i += count - 1   // move i index forward on count value\\n                break\\n            }\\n        }\\n    }\\n\\n    return max > 0 ? max + 1 : -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3906372,
                "title": "simple-solution-python",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def alternatingSubarray(self, nums: List[int]) -> int:\\n        result, count = -1, 0\\n        state = True\\n        \\n        for i in range(1, len(nums)):\\n            if nums[i] - nums[i-1] == 1:\\n                if not state:\\n                    count = 0\\n                count += 1\\n                state = False\\n            elif nums[i] - nums[i-1] == -1 and not state:\\n                count += 1\\n                state = True\\n            else:\\n                state = True\\n                count = 0\\n                \\n            result = max(result, count)\\n            \\n        return result + 1 if result != 0 else -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def alternatingSubarray(self, nums: List[int]) -> int:\\n        result, count = -1, 0\\n        state = True\\n        \\n        for i in range(1, len(nums)):\\n            if nums[i] - nums[i-1] == 1:\\n                if not state:\\n                    count = 0\\n                count += 1\\n                state = False\\n            elif nums[i] - nums[i-1] == -1 and not state:\\n                count += 1\\n                state = True\\n            else:\\n                state = True\\n                count = 0\\n                \\n            result = max(result, count)\\n            \\n        return result + 1 if result != 0 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3891280,
                "title": "easy-sol-in-c-leetcode-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        int maxlen=1;\\n        for(int i=0;i<n;i++){\\n            int len=1;\\n            int t=0;\\n            for(int j=i+1;j<n;j++){\\n                 int p=pow(-1,t);\\n                 t++;\\n                \\n                int k=nums[j]-nums[j-1];\\n                \\n                if(k==p){\\n                    len++;\\n                }else{\\n                    break;\\n                }\\n                \\n              \\n                \\n            }\\n            \\n            maxlen=max(len,maxlen);\\n        }\\n        \\n        if(maxlen==1){\\n            return -1;\\n        }\\n        return maxlen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n        int maxlen=1;\\n        for(int i=0;i<n;i++){\\n            int len=1;\\n            int t=0;\\n            for(int j=i+1;j<n;j++){\\n                 int p=pow(-1,t);\\n                 t++;\\n                \\n                int k=nums[j]-nums[j-1];\\n                \\n                if(k==p){\\n                    len++;\\n                }else{\\n                    break;\\n                }\\n                \\n              \\n                \\n            }\\n            \\n            maxlen=max(len,maxlen);\\n        }\\n        \\n        if(maxlen==1){\\n            return -1;\\n        }\\n        return maxlen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889215,
                "title": "java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int alternatingSubarray(int[] nums) {\\n        \\n        int ans = -1;\\n        int count = 1;\\n        boolean bool = true;\\n\\n        for(int i=1; i<nums.length; i++){\\n\\n            if(bool){\\n                if(nums[i]-nums[i-1] != 1){\\n                    ans = Math.max(ans,count > 1 ?count :-1);\\n                    count = 1;\\n                }\\n                else{\\n                    count++;\\n                    bool = false;\\n                }\\n            }\\n            else{\\n                if(nums[i]-nums[i-1] != -1){\\n                    ans = Math.max(ans,count > 1 ?count :-1);\\n                    count = 1;\\n                    i--;\\n                }\\n                else{\\n                    count++;\\n                }\\n                bool = true;\\n            }\\n        }\\n\\n        ans = Math.max(ans,count > 1 ?count :-1);\\n\\n        return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int alternatingSubarray(int[] nums) {\\n        \\n        int ans = -1;\\n        int count = 1;\\n        boolean bool = true;\\n\\n        for(int i=1; i<nums.length; i++){\\n\\n            if(bool){\\n                if(nums[i]-nums[i-1] != 1){\\n                    ans = Math.max(ans,count > 1 ?count :-1);\\n                    count = 1;\\n                }\\n                else{\\n                    count++;\\n                    bool = false;\\n                }\\n            }\\n            else{\\n                if(nums[i]-nums[i-1] != -1){\\n                    ans = Math.max(ans,count > 1 ?count :-1);\\n                    count = 1;\\n                    i--;\\n                }\\n                else{\\n                    count++;\\n                }\\n                bool = true;\\n            }\\n        }\\n\\n        ans = Math.max(ans,count > 1 ?count :-1);\\n\\n        return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3883001,
                "title": "go-simple-brute-force",
                "content": "```\\nfunc alternatingSubarray(nums []int) int {\\n    for i := len(nums); i >= 2; i-- {\\n        for j := 0; j < len(nums) - i + 1; j++ {\\n            if isAltSub(nums[j:j + i]) { return i }\\n        }\\n    }\\n    return -1\\n}\\n\\nfunc isAltSub(nums []int) bool {\\n    a, b := nums[0], nums[1]\\n    if b != a + 1 { return false }\\n\\n    for i := 2; i < len(nums); i++ {\\n        if i % 2 == 0 && nums[i] != a { return false }\\n        if i % 2 != 0 && nums[i] != b { return false }\\n    }\\n\\n    return true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc alternatingSubarray(nums []int) int {\\n    for i := len(nums); i >= 2; i-- {\\n        for j := 0; j < len(nums) - i + 1; j++ {\\n            if isAltSub(nums[j:j + i]) { return i }\\n        }\\n    }\\n    return -1\\n}\\n\\nfunc isAltSub(nums []int) bool {\\n    a, b := nums[0], nums[1]\\n    if b != a + 1 { return false }\\n\\n    for i := 2; i < len(nums); i++ {\\n        if i % 2 == 0 && nums[i] != a { return false }\\n        if i % 2 != 0 && nums[i] != b { return false }\\n    }\\n\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3875798,
                "title": "alternating-subarray",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def alternatingSubarray(self, nums: List[int]) -> int:\\n        num=0\\n        for i in range(len(nums)):\\n            lst=[]\\n            if len(nums)-i<num:\\n                return num\\n            for j in range(i+1,len(nums)):\\n                if (j-i)%2!=0 and nums[i]+1==nums[j]:\\n                    if j==i+1:\\n                        lst.append(nums[i])\\n                    lst.append(nums[j])\\n                elif (j-i)%2==0 and nums[i]==nums[j]:\\n                    lst.append(nums[i+1])\\n                else:\\n                    break\\n            if num<=len(lst):\\n                num=len(lst)\\n        return num if num>1 else -1\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution:\\n    def alternatingSubarray(self, nums: List[int]) -> int:\\n        num=0\\n        for i in range(len(nums)):\\n            lst=[]\\n            if len(nums)-i<num:\\n                return num\\n            for j in range(i+1,len(nums)):\\n                if (j-i)%2!=0 and nums[i]+1==nums[j]:\\n                    if j==i+1:\\n                        lst.append(nums[i])\\n                    lst.append(nums[j])\\n                elif (j-i)%2==0 and nums[i]==nums[j]:\\n                    lst.append(nums[i+1])\\n                else:\\n                    break\\n            if num<=len(lst):\\n                num=len(lst)\\n        return num if num>1 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3875713,
                "title": "longest-alternating-subarray-java-o-n-easy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int alternatingSubarray(int[] nums) {\\n        int ans=-1;\\n\\n        for(int i=1;i<nums.length;i++){\\n            // System.out.println(i);\\n            if(nums[i]-nums[i-1]==1){\\n                int local=2;\\n                int j=i+1;\\n                boolean flag=true;\\n                \\n                while(flag && j<nums.length){\\n\\n                    int p=local%2==0?-1:1; \\n                    // System.out.println(p);\\n                    if(nums[j]-nums[j-1]==p){\\n                        // System.out.println(nums[j]);\\n                        local++;\\n                        j++;\\n                    }else{\\n                        flag=false;\\n                    } \\n                }\\n\\n                ans=Math.max(ans,local);\\n                i=j-1;\\n                // System.out.println(j+\" *\");\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int alternatingSubarray(int[] nums) {\\n        int ans=-1;\\n\\n        for(int i=1;i<nums.length;i++){\\n            // System.out.println(i);\\n            if(nums[i]-nums[i-1]==1){\\n                int local=2;\\n                int j=i+1;\\n                boolean flag=true;\\n                \\n                while(flag && j<nums.length){\\n\\n                    int p=local%2==0?-1:1; \\n                    // System.out.println(p);\\n                    if(nums[j]-nums[j-1]==p){\\n                        // System.out.println(nums[j]);\\n                        local++;\\n                        j++;\\n                    }else{\\n                        flag=false;\\n                    } \\n                }\\n\\n                ans=Math.max(ans,local);\\n                i=j-1;\\n                // System.out.println(j+\" *\");\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3871949,
                "title": "track-increase-decrease-with-variable-and-get-to-the-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int alternatingSubarray(int[] nums) {\\n\\n        int countResult = 0;\\n        String expectNext = \"I\"; //I: Increase, D: Decrese.\\n\\n        for (int i = 0; i < nums.length; i++) {\\n\\n            int count = 0;\\n\\n            for (int k = i; k < nums.length - 1; k++) {\\n                \\n                if (nums[k + 1] == nums[k] + 1 && expectNext.equals(\"I\")) {\\n                    expectNext = \"D\"; //set to D to expect decrease next time.\\n                    count++;\\n                }\\n                else if (nums[k + 1] == nums[k] - 1 && expectNext.equals(\"D\")) {\\n                    expectNext = \"I\"; //set to I to expect increase next time.\\n                    count++;\\n                }\\n                else{\\n                    expectNext = \"I\"; //reset to I in order to expect Increase in next major iteration.\\n                    break;\\n                }\\n\\n            }\\n\\n            if(countResult < count)\\n                countResult = count;\\n\\n        }\\n\\n        return countResult == 0 ? -1 : countResult + 1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int alternatingSubarray(int[] nums) {\\n\\n        int countResult = 0;\\n        String expectNext = \"I\"; //I: Increase, D: Decrese.\\n\\n        for (int i = 0; i < nums.length; i++) {\\n\\n            int count = 0;\\n\\n            for (int k = i; k < nums.length - 1; k++) {\\n                \\n                if (nums[k + 1] == nums[k] + 1 && expectNext.equals(\"I\")) {\\n                    expectNext = \"D\"; //set to D to expect decrease next time.\\n                    count++;\\n                }\\n                else if (nums[k + 1] == nums[k] - 1 && expectNext.equals(\"D\")) {\\n                    expectNext = \"I\"; //set to I to expect increase next time.\\n                    count++;\\n                }\\n                else{\\n                    expectNext = \"I\"; //reset to I in order to expect Increase in next major iteration.\\n                    break;\\n                }\\n\\n            }\\n\\n            if(countResult < count)\\n                countResult = count;\\n\\n        }\\n\\n        return countResult == 0 ? -1 : countResult + 1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3871785,
                "title": "c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint alternatingSubarray(int* nums, int numsSize){\\n    int max=1;\\n    int ans=1;\\n    int i=0;\\n    int t=0;\\n    while(i<numsSize-1){\\n        if(t==0){\\n            if(nums[i]-nums[i+1]==-1){\\n                max++;\\n                t=1;\\n                i++;\\n                if(ans<max) ans=max;\\n            }\\n            else{\\n                max=1;\\n                t=0;\\n                i++;\\n            }\\n        }\\n        else if(t==1){\\n            if(nums[i]-nums[i+1]==1){\\n                max++;\\n                t=0;\\n                i++;\\n                if(ans<max) ans=max;\\n            }\\n            else{\\n                max=1;\\n                t=0;\\n\\n            }\\n        }\\n        \\n    }//\\n\\n    if(ans==1) return -1;\\n    else return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint alternatingSubarray(int* nums, int numsSize){\\n    int max=1;\\n    int ans=1;\\n    int i=0;\\n    int t=0;\\n    while(i<numsSize-1){\\n        if(t==0){\\n            if(nums[i]-nums[i+1]==-1){\\n                max++;\\n                t=1;\\n                i++;\\n                if(ans<max) ans=max;\\n            }\\n            else{\\n                max=1;\\n                t=0;\\n                i++;\\n            }\\n        }\\n        else if(t==1){\\n            if(nums[i]-nums[i+1]==1){\\n                max++;\\n                t=0;\\n                i++;\\n                if(ans<max) ans=max;\\n            }\\n            else{\\n                max=1;\\n                t=0;\\n\\n            }\\n        }\\n        \\n    }//\\n\\n    if(ans==1) return -1;\\n    else return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3863315,
                "title": "c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        int ans = -1;\\n        int cur = 1;\\n\\n        for(int i = 0; i < n; i++){\\n            int j = i;\\n\\n            while(j < n-1){\\n\\n                if(j+1 < n and nums[j+1] - nums[j] == 1){\\n                    cur++;\\n                    j++;\\n                } else {\\n                    ans = max(ans, cur);\\n                    cur = 1;\\n                    break;\\n                }\\n\\n                if(j+1 < n and nums[j+1] - nums[j] == -1){\\n                    cur++;\\n                    j++;\\n                } else {\\n                    ans = max(ans, cur);\\n                    cur = 1;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        ans = max(ans, cur);\\n\\n        if(ans == 1) return -1;\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        int ans = -1;\\n        int cur = 1;\\n\\n        for(int i = 0; i < n; i++){\\n            int j = i;\\n\\n            while(j < n-1){\\n\\n                if(j+1 < n and nums[j+1] - nums[j] == 1){\\n                    cur++;\\n                    j++;\\n                } else {\\n                    ans = max(ans, cur);\\n                    cur = 1;\\n                    break;\\n                }\\n\\n                if(j+1 < n and nums[j+1] - nums[j] == -1){\\n                    cur++;\\n                    j++;\\n                } else {\\n                    ans = max(ans, cur);\\n                    cur = 1;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        ans = max(ans, cur);\\n\\n        if(ans == 1) return -1;\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862573,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func alternatingSubarray(_ nums: [Int]) -> Int {\\n        \\n        var best = 0\\n        var i = 0\\n        var cur = 0\\n\\n        while i < nums.count {\\n            \\n            let diff = cur % 2 == 1 ? 1 : -1\\n\\n            if cur == 0 || nums[i] - nums[i - 1] == diff {\\n                cur += 1\\n                i += 1\\n            }\\n            else {\\n                best = max(best, cur)\\n                cur = 0\\n                if nums[i] - nums[i - 1] == 1 { i -= 1 }\\n            }\\n        }\\n\\n        best = max(best, cur)\\n\\n        return best > 1 ? best : -1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func alternatingSubarray(_ nums: [Int]) -> Int {\\n        \\n        var best = 0\\n        var i = 0\\n        var cur = 0\\n\\n        while i < nums.count {\\n            \\n            let diff = cur % 2 == 1 ? 1 : -1\\n\\n            if cur == 0 || nums[i] - nums[i - 1] == diff {\\n                cur += 1\\n                i += 1\\n            }\\n            else {\\n                best = max(best, cur)\\n                cur = 0\\n                if nums[i] - nums[i - 1] == 1 { i -= 1 }\\n            }\\n        }\\n\\n        best = max(best, cur)\\n\\n        return best > 1 ? best : -1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860174,
                "title": "most-efficient-solution-in-javascript-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar alternatingSubarray = function(nums) {\\n    let max = -1, len = 1;\\n    for(let j = 0; j < nums.length - 1; j++) {\\n        let res = nums[j + 1] - nums[j];\\n        if(Math.pow(-1, len + 1) == res) {\\n            len++;\\n            max = Math.max(max, len);\\n        } else {\\n            if(len > 1) j--;\\n            len = 1;\\n        }\\n    }\\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar alternatingSubarray = function(nums) {\\n    let max = -1, len = 1;\\n    for(let j = 0; j < nums.length - 1; j++) {\\n        let res = nums[j + 1] - nums[j];\\n        if(Math.pow(-1, len + 1) == res) {\\n            len++;\\n            max = Math.max(max, len);\\n        } else {\\n            if(len > 1) j--;\\n            len = 1;\\n        }\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3858708,
                "title": "python-beats-97-doesn-t-feel-like-easy-python-dp-kadane-like-solution",
                "content": "The explanation might be confusing as I\\'m not really used to writing out explanations. Writing this down mostly for myself later on.\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt first I tried to do a sliding window but kept getting off errors and not updating when numbers were decreasing constantly so the minimum window that I got was always one. \\n\\nThe approach that I updated was that I realized I could set the conditions for whether or not to expand the imaginary subarray depending on the largest subarray that can be formed by the current element being the last element of the subarray. (This is similar to a DP problem because you use the results of the previous calculations). \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI saved the calculation at each index in a prefix array, but I think it can be simplified to a constant that checks against the global maximum.\\n\\nIf the largest subarray that can be formed by the previous element is 0, then we check that whether it is increasing or decreasing. If the previous subarray is size 0, to build on that subarray, the current element MUST be greater than the previous element. \\n\\nIf the previous subarray is greater than 0, I split the conditions into two situations: whether the previous subarray formed is odd or even in size. If its length is odd, then to build onto the array, the current element at i must be 1 less than the previous. If even, the current element at i must be 1 greater than the previous. For any other situation, we can reset the size formed to 0. \\n\\nThe edge case here is if we are expecting the nums[i] to be 1 less than the previous, but it is greater than the previous by 1 instead: in this case, we would reset the size to 2.\\n\\n**This could be further simplified** in that for cases where we have a prev subarray size greater than 0, we can ALWAYS add the current element to it if the current element is the same as the element two indices before this one (i - 2). Since i - 2 by definition belows in the previous subarray, we know that as long as nums[i] == nums[i - 2] then it is alternating. If it is not the same, then we can reset the current subarray size to be 0. \\n\\nif the prev subarray size is less than 0, then we can check whether nums[i] is 1 greater than nums[i - 1], and if this is true, we can count the current subarray size as 2, and reset the subarray formed. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) for the prefix array but could be optimized to O(1) if we save the last element that we save onto the prefix as a constant dp variable. In the latter case, we would need to check the dp value against a global maximum value similar to the way you might do so in Kadane\\'s algorithm.\\n\\nThis question almost broke me actually because I was expecting to finish this question in 15 minutes only for me to take an hour.\\n\\nNote that the brute force solution also seems to be accepted.\\n\\n# Code\\n```\\nclass Solution:\\n    def alternatingSubarray(self, nums: List[int]) -> int:\\n        # sliding window? \\n        # any s2 - s1 = -1\\n        prefix = [0 for _ in range(len(nums))]\\n        for i in range(1, len(nums)): \\n            prev = nums[i - 1] \\n            cur = nums[i]\\n            if prefix[i - 1] == 0:\\n                if cur == prev + 1:\\n                    prefix[i] = 2 \\n                else:\\n                    prefix[i] = 0\\n            else:\\n                if prefix[i - 1] % 2 == 0:\\n                    # if the previous is even, then the this number should be smaller than previous to increment 1\\n                    # if it is greater than previous by 1, then we reset to 0\\n                    # if not greater or lesser by 1, we reset to 0\\n                    if cur + 1 == prev: \\n                        prefix[i] = prefix[i - 1] + 1\\n                    elif cur - 1 == prev:\\n                        prefix[i] = 2\\n                    else: \\n                        prefix[i] = 0\\n                elif prefix[i - 1] % 2 == 1:\\n                    # if previous is odd, that means we have at least three, which means we have at least three\\n                    if cur - 1 == prev:  \\n                        prefix[i] = prefix[i - 1] + 1\\n                    else:\\n                        prefix[i] = 0\\n                # if cur == nums[i - 2]: \\n                #     prefix[i] = prefix[i - 1] + 1\\n                # else:\\n                #     prefix[i] = 0\\n        \\n        greatest = max(prefix)\\n        return -1 if greatest == 0 else greatest\\n                \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def alternatingSubarray(self, nums: List[int]) -> int:\\n        # sliding window? \\n        # any s2 - s1 = -1\\n        prefix = [0 for _ in range(len(nums))]\\n        for i in range(1, len(nums)): \\n            prev = nums[i - 1] \\n            cur = nums[i]\\n            if prefix[i - 1] == 0:\\n                if cur == prev + 1:\\n                    prefix[i] = 2 \\n                else:\\n                    prefix[i] = 0\\n            else:\\n                if prefix[i - 1] % 2 == 0:\\n                    # if the previous is even, then the this number should be smaller than previous to increment 1\\n                    # if it is greater than previous by 1, then we reset to 0\\n                    # if not greater or lesser by 1, we reset to 0\\n                    if cur + 1 == prev: \\n                        prefix[i] = prefix[i - 1] + 1\\n                    elif cur - 1 == prev:\\n                        prefix[i] = 2\\n                    else: \\n                        prefix[i] = 0\\n                elif prefix[i - 1] % 2 == 1:\\n                    # if previous is odd, that means we have at least three, which means we have at least three\\n                    if cur - 1 == prev:  \\n                        prefix[i] = prefix[i - 1] + 1\\n                    else:\\n                        prefix[i] = 0\\n                # if cur == nums[i - 2]: \\n                #     prefix[i] = prefix[i - 1] + 1\\n                # else:\\n                #     prefix[i] = 0\\n        \\n        greatest = max(prefix)\\n        return -1 if greatest == 0 else greatest\\n                \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849546,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBruteforce\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int ans=-1;\\n        int x=-1,y=0;\\n        \\n        for(int i=0;i<nums.size()-1;++i){\\n            if(nums[i+1]-nums[i]==1){\\n                if(y==-1){\\n                    y=1;\\n                    ++x;\\n                }\\n                else if(y==0){\\n                    x=2;\\n                    y=1;\\n                }\\n                else if(y==1){\\n                    y=1;\\n                    x=2;\\n                }\\n            }\\n            else if(nums[i+1]-nums[i]==-1){\\n               if(y==1){\\n                   ++x;\\n                   y=-1;\\n               }\\n               else if(y==-1){\\n                   x=-1;\\n                   y=0;\\n               }\\n            }\\n            else{\\n                x=-1;\\n                y=0;\\n            }\\n            \\n            ans=max(ans,x);\\n\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int ans=-1;\\n        int x=-1,y=0;\\n        \\n        for(int i=0;i<nums.size()-1;++i){\\n            if(nums[i+1]-nums[i]==1){\\n                if(y==-1){\\n                    y=1;\\n                    ++x;\\n                }\\n                else if(y==0){\\n                    x=2;\\n                    y=1;\\n                }\\n                else if(y==1){\\n                    y=1;\\n                    x=2;\\n                }\\n            }\\n            else if(nums[i+1]-nums[i]==-1){\\n               if(y==1){\\n                   ++x;\\n                   y=-1;\\n               }\\n               else if(y==-1){\\n                   x=-1;\\n                   y=0;\\n               }\\n            }\\n            else{\\n                x=-1;\\n                y=0;\\n            }\\n            \\n            ans=max(ans,x);\\n\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3839479,
                "title": "easy-simple-c-solution-using-bruteforce",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            int d=1;\\n            for(int j=1+i;j<nums.size();j++){\\n                if(nums[j]-nums[j-1]==d){\\n                    ans=max(ans,j-i+1);\\n                }\\n                else{\\n                    break;\\n                }\\n                d=-d;\\n            }\\n        }\\n        if(ans==0){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            int d=1;\\n            for(int j=1+i;j<nums.size();j++){\\n                if(nums[j]-nums[j-1]==d){\\n                    ans=max(ans,j-i+1);\\n                }\\n                else{\\n                    break;\\n                }\\n                d=-d;\\n            }\\n        }\\n        if(ans==0){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832512,
                "title": "php",
                "content": "# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @return Integer\\n     */\\n    function alternatingSubarray($nums) {\\n        $ans = 0;\\n        foreach ($nums as $key => $num) {\\n            $tmp = [$num];\\n            $equal = 1;\\n\\n            while ($next = $nums[++$key] ?? null) {\\n                $sub = $next - end($tmp);\\n\\n                if ($sub !== $equal) break;\\n\\n                array_push($tmp, $next);\\n                $equal = -$equal;\\n            }\\n\\n            $ans = ($len = count($tmp)) > $ans ? $len : $ans;\\n        }\\n\\n        return $ans === 1 ? -1 : $ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @return Integer\\n     */\\n    function alternatingSubarray($nums) {\\n        $ans = 0;\\n        foreach ($nums as $key => $num) {\\n            $tmp = [$num];\\n            $equal = 1;\\n\\n            while ($next = $nums[++$key] ?? null) {\\n                $sub = $next - end($tmp);\\n\\n                if ($sub !== $equal) break;\\n\\n                array_push($tmp, $next);\\n                $equal = -$equal;\\n            }\\n\\n            $ans = ($len = count($tmp)) > $ans ? $len : $ans;\\n        }\\n\\n        return $ans === 1 ? -1 : $ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821777,
                "title": "simple-solution-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int ret = -1;\\n        int flag = 0;\\n        int cnt = 1;\\n        for (int i = 0; i < nums.size() - 1; i++) {\\n            if (flag == 0) {\\n                if (nums[i + 1] - nums[i] == 1) {\\n                    cnt++;\\n                    ret = max(ret, cnt);\\n                    flag = 1;\\n                }\\n                else {\\n                    cnt = 1;\\n                }\\n            }\\n            else if (flag == 1) {\\n                if (nums[i + 1] - nums[i] == -1) {\\n                    cnt++;\\n                    ret = max(ret, cnt);\\n                    flag = 0;\\n                }\\n                else if (nums[i + 1] - nums[i] == 1) {\\n                    cnt=2;\\n                    ret = max(ret, cnt);\\n                    flag = 1;\\n                }\\n                else {\\n                    cnt = 1;\\n                    flag = 0;\\n                }\\n\\n            }\\n        }\\n        return ret >= 2 ? ret : -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int ret = -1;\\n        int flag = 0;\\n        int cnt = 1;\\n        for (int i = 0; i < nums.size() - 1; i++) {\\n            if (flag == 0) {\\n                if (nums[i + 1] - nums[i] == 1) {\\n                    cnt++;\\n                    ret = max(ret, cnt);\\n                    flag = 1;\\n                }\\n                else {\\n                    cnt = 1;\\n                }\\n            }\\n            else if (flag == 1) {\\n                if (nums[i + 1] - nums[i] == -1) {\\n                    cnt++;\\n                    ret = max(ret, cnt);\\n                    flag = 0;\\n                }\\n                else if (nums[i + 1] - nums[i] == 1) {\\n                    cnt=2;\\n                    ret = max(ret, cnt);\\n                    flag = 1;\\n                }\\n                else {\\n                    cnt = 1;\\n                    flag = 0;\\n                }\\n\\n            }\\n        }\\n        return ret >= 2 ? ret : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3813986,
                "title": "3-pointers-o-n-tc-o-1-sc",
                "content": "# Intuition\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n\\n        int maxLength{-1}, currLength{-1}, n = nums.size();\\n\\n        if(n == 2){\\n            return nums[1] - nums[0] == 1 ? 2 : -1;\\n        }\\n\\n        for(int i = 2; i < n; i++){\\n\\n            int first{nums[i - 2]}, second{nums[i - 1]}, third{nums[i]};\\n\\n            if(first == third && second - first == 1){\\n                if(currLength != -1) currLength++;\\n                else currLength = 3;\\n            } \\n\\n            else if(currLength != -1 && first == third && second - first == -1){\\n                currLength++; \\n            }\\n\\n            else if(currLength == -1 && (second - first == 1 || third - second == 1) ){\\n                currLength = 2;\\n            }\\n\\n            else{\\n                currLength = -1;\\n            }\\n\\n            maxLength = max(maxLength, currLength);\\n        }\\n\\n        return maxLength;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n\\n        int maxLength{-1}, currLength{-1}, n = nums.size();\\n\\n        if(n == 2){\\n            return nums[1] - nums[0] == 1 ? 2 : -1;\\n        }\\n\\n        for(int i = 2; i < n; i++){\\n\\n            int first{nums[i - 2]}, second{nums[i - 1]}, third{nums[i]};\\n\\n            if(first == third && second - first == 1){\\n                if(currLength != -1) currLength++;\\n                else currLength = 3;\\n            } \\n\\n            else if(currLength != -1 && first == third && second - first == -1){\\n                currLength++; \\n            }\\n\\n            else if(currLength == -1 && (second - first == 1 || third - second == 1) ){\\n                currLength = 2;\\n            }\\n\\n            else{\\n                currLength = -1;\\n            }\\n\\n            maxLength = max(maxLength, currLength);\\n        }\\n\\n        return maxLength;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3813697,
                "title": "python-solution-beats-90-6-users",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n  def alternatingSubarray(self, nums):\\n    ans = 0\\n    if len(nums)==1:\\n      return 1\\n    for i in range(len(nums)-1):\\n      count = 0\\n      prev = nums[i]\\n      o = 1\\n      for j in range(i+1, len(nums)):\\n        if nums[j] - prev == o:\\n          o*=-1\\n          count = max(count, j-i+1)\\n          prev = nums[j]\\n        else:\\n          break\\n      ans = max(ans, count)\\n    return ans if ans>0 else -1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n  def alternatingSubarray(self, nums):\\n    ans = 0\\n    if len(nums)==1:\\n      return 1\\n    for i in range(len(nums)-1):\\n      count = 0\\n      prev = nums[i]\\n      o = 1\\n      for j in range(i+1, len(nums)):\\n        if nums[j] - prev == o:\\n          o*=-1\\n          count = max(count, j-i+1)\\n          prev = nums[j]\\n        else:\\n          break\\n      ans = max(ans, count)\\n    return ans if ans>0 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3806800,
                "title": "easy-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar alternatingSubarray = function(nums) {\\n    let res =0;\\n    let n=1;\\n    for(let i=1; i<nums.length; i++){\\n        if((n-1)%2==0 && nums[i-1]+1 == nums[i]){\\n            n++;\\n        }else if((n-1)%2==1 && nums[i-1]-1==nums[i]){\\n            n++\\n        }else{\\n            if(n>1) i--;\\n            n=1;\\n        }\\n        if(n>res){\\n            res=n;\\n        }\\n    }\\n    if(res==1) return -1;\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar alternatingSubarray = function(nums) {\\n    let res =0;\\n    let n=1;\\n    for(let i=1; i<nums.length; i++){\\n        if((n-1)%2==0 && nums[i-1]+1 == nums[i]){\\n            n++;\\n        }else if((n-1)%2==1 && nums[i-1]-1==nums[i]){\\n            n++\\n        }else{\\n            if(n>1) i--;\\n            n=1;\\n        }\\n        if(n>res){\\n            res=n;\\n        }\\n    }\\n    if(res==1) return -1;\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3806725,
                "title": "python-time-complexity-o-n-and-space-o-1-solution-by-updating-global-maximum-value",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsolve this problem by one iteration of the array through keeping calculating current alternating subarray length and update global maxium result  \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe tricky thing here is when the diff between s[i]-s[i-1] is not equal to \\n(-1)^m\\nwe need to check if diff is 1 in order to update cur and m correclty\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def alternatingSubarray(self, nums: List[int]) -> int:\\n        #result maintain global maximum for alernating subarray length\\n        #cur maintains current alertnating subarray length\\n        #m indicates next diff should be by calculating (-1)**m\\n        result,cur,m = -1,1,0\\n        for i in range(1,len(nums)):\\n            diff=nums[i]-nums[i-1]\\n            if diff == (-1)**m:\\n                cur+=1\\n                m+=1\\n                result=max(result,cur)\\n            else:\\n                #when breaking the continuus alternating rule\\n                # if the diff is 1, reset as alreay found first pair of element  \\n                if diff==1:\\n                    m=1\\n                    cur=2\\n                else:\\n                    # if the diff is not 1, reset as not yet found any pair \\n                    m=0\\n                    cur=1    \\n\\n        return result          \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def alternatingSubarray(self, nums: List[int]) -> int:\\n        #result maintain global maximum for alernating subarray length\\n        #cur maintains current alertnating subarray length\\n        #m indicates next diff should be by calculating (-1)**m\\n        result,cur,m = -1,1,0\\n        for i in range(1,len(nums)):\\n            diff=nums[i]-nums[i-1]\\n            if diff == (-1)**m:\\n                cur+=1\\n                m+=1\\n                result=max(result,cur)\\n            else:\\n                #when breaking the continuus alternating rule\\n                # if the diff is 1, reset as alreay found first pair of element  \\n                if diff==1:\\n                    m=1\\n                    cur=2\\n                else:\\n                    # if the diff is not 1, reset as not yet found any pair \\n                    m=0\\n                    cur=1    \\n\\n        return result          \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3806654,
                "title": "c-simple-while-loop",
                "content": "\\n\\n# Approach\\n- checking if it is even index or not\\n- if even index checking for difference is 1;else -1\\n- incrementing len accordingly\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nno extra space is used\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int ans=INT_MIN;\\n        int i=0,j=1;\\n        bool even=true;\\n        int len=0;\\n        int prev=0;\\n        int n=nums.size();\\n        while(j<n){\\n            if(even){\\n                if(nums[j]-nums[i]==1){\\n                    if(len==0){\\n                        len=2;\\n                        prev=nums[i];\\n                        i++;j++;\\n                        ans=max(ans,len);\\n                        even=false;\\n                    }\\n                    else{\\n                        if(prev==nums[j]){\\n                            len++;\\n                            prev=nums[i];\\n                            ans=max(ans,len);\\n                            i++;j++;\\n                            even=false;\\n                        }\\n                        else{\\n                            len=0;\\n                            even=true;\\n                        }\\n                    }\\n                }\\n                else{\\n                    len=0;\\n                    even=true;\\n                    i++;\\n                    j++;\\n                }\\n            }\\n            else{\\n                if(nums[j]-nums[i]==-1)\\n                {\\n                    if(prev==nums[j]){\\n                        len++;\\n                        prev=nums[i];\\n                        ans=max(ans,len);\\n                        i++;j++;\\n                        even=true;\\n                    }\\n                    else{\\n                        len=0;\\n                        even=true;\\n                    }\\n                }\\n                else{\\n                    len=0;\\n                    prev=nums[i];\\n                    even=true;\\n                    //i++;j++;\\n                }\\n            }\\n\\n        }\\n        return ans==INT_MIN? -1:ans;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int ans=INT_MIN;\\n        int i=0,j=1;\\n        bool even=true;\\n        int len=0;\\n        int prev=0;\\n        int n=nums.size();\\n        while(j<n){\\n            if(even){\\n                if(nums[j]-nums[i]==1){\\n                    if(len==0){\\n                        len=2;\\n                        prev=nums[i];\\n                        i++;j++;\\n                        ans=max(ans,len);\\n                        even=false;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3806502,
                "title": "iterative",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int finalAns=-1;\\n    bool isValidSe(vector<int> &nums,int i,int j){\\n        bool alter=true;\\n        int count =0;\\n        int pass=false;\\n        bool d=false;\\n        int x=i;\\n        int y=x+1;\\n        while(x<=j-1 and y<=j){\\n            if(d==false){\\n            if(alter){\\n                alter=false;\\n                if(nums[y]-nums[x]==1){\\n                    count++;\\n                }\\n                else{\\n                    d=true;\\n                }\\n                x++;\\n                y++;\\n\\n            }\\n            else{\\n                alter=true;\\n                if(nums[y]-nums[x]==-1){\\n                    count++;\\n                }\\n                else{\\n                    d=true;\\n                }\\n                x++;\\n                y++;\\n            }\\n        }\\n        else{\\n            x++;\\n            y++;\\n        }\\n        }\\n        if(d==false)return true;\\n        return false;\\n    }\\n\\n    int alternatingSubarray(vector<int>& nums) {\\n        int i=0;\\n        int j=nums.size()-1;\\n        for(int x=0;x<nums.size();x++){\\n            for(int y=x+1;y<nums.size();y++){\\n                if(isValidSe(nums,x,y)){\\n                    finalAns=max(finalAns,y-x+1);\\n                }\\n            }\\n        }\\n        return finalAns;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int finalAns=-1;\\n    bool isValidSe(vector<int> &nums,int i,int j){\\n        bool alter=true;\\n        int count =0;\\n        int pass=false;\\n        bool d=false;\\n        int x=i;\\n        int y=x+1;\\n        while(x<=j-1 and y<=j){\\n            if(d==false){\\n            if(alter){\\n                alter=false;\\n                if(nums[y]-nums[x]==1){\\n                    count++;\\n                }\\n                else{\\n                    d=true;\\n                }\\n                x++;\\n                y++;\\n\\n            }\\n            else{\\n                alter=true;\\n                if(nums[y]-nums[x]==-1){\\n                    count++;\\n                }\\n                else{\\n                    d=true;\\n                }\\n                x++;\\n                y++;\\n            }\\n        }\\n        else{\\n            x++;\\n            y++;\\n        }\\n        }\\n        if(d==false)return true;\\n        return false;\\n    }\\n\\n    int alternatingSubarray(vector<int>& nums) {\\n        int i=0;\\n        int j=nums.size()-1;\\n        for(int x=0;x<nums.size();x++){\\n            for(int y=x+1;y<nums.size();y++){\\n                if(isValidSe(nums,x,y)){\\n                    finalAns=max(finalAns,y-x+1);\\n                }\\n            }\\n        }\\n        return finalAns;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801716,
                "title": "simple-java-solution",
                "content": "# Simple JAVA Solution!!!\\n\\n# Code\\n```\\nclass Solution {\\n    public int alternatingSubarray(int[] nums) {\\n        \\n        int l = nums.length,ans=1,f=1;\\n        for(int i=1;i<l;i++)\\n        {\\n            int a=0;\\n            if(nums[i]-nums[i-1]==1)\\n            {\\n                f=0;\\n                int b=nums[i-1],c=nums[i],d=1;\\n                for(int j=i-1;j<l;j++,d++)\\n                {\\n                    if(d%2==1 && nums[j]==b)\\n                    {\\n                        a++;continue;\\n                    }\\n                    if(d%2==0 && nums[j]==c)\\n                    {\\n                        a++;continue;\\n                    }\\n                    break;\\n                }\\n            }\\n            if(a>ans) ans=a;\\n        }\\n        if(f==1) return -1;\\n        return ans;\\n    }\\n   \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int alternatingSubarray(int[] nums) {\\n        \\n        int l = nums.length,ans=1,f=1;\\n        for(int i=1;i<l;i++)\\n        {\\n            int a=0;\\n            if(nums[i]-nums[i-1]==1)\\n            {\\n                f=0;\\n                int b=nums[i-1],c=nums[i],d=1;\\n                for(int j=i-1;j<l;j++,d++)\\n                {\\n                    if(d%2==1 && nums[j]==b)\\n                    {\\n                        a++;continue;\\n                    }\\n                    if(d%2==0 && nums[j]==c)\\n                    {\\n                        a++;continue;\\n                    }\\n                    break;\\n                }\\n            }\\n            if(a>ans) ans=a;\\n        }\\n        if(f==1) return -1;\\n        return ans;\\n    }\\n   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799369,
                "title": "easy-solution-cpp",
                "content": "# Complexity\\n- Time complexity:O(N*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=1;\\n        for(int i=0; i<n; i++){\\n            int prev=nums[i];\\n            int cnt=1, temp=1;\\n            for(int j=i+1; j<n; j++){\\n                if(nums[j]-prev==temp){\\n                    cnt++, temp*=-1;\\n                    prev=nums[j];\\n                }\\n                else\\n                    break;\\n            }\\n            ans=max(ans, cnt);\\n        }\\n        return ans==1 ? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=1;\\n        for(int i=0; i<n; i++){\\n            int prev=nums[i];\\n            int cnt=1, temp=1;\\n            for(int j=i+1; j<n; j++){\\n                if(nums[j]-prev==temp){\\n                    cnt++, temp*=-1;\\n                    prev=nums[j];\\n                }\\n                else\\n                    break;\\n            }\\n            ans=max(ans, cnt);\\n        }\\n        return ans==1 ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3796784,
                "title": "o-n-simple-java-solution-using-two-pointers",
                "content": "# Intuition\\nUsing Two Pointers in single Iteration\\n\\n# Approach\\nEven though we are using two pointers we can solve this problem in a single iteration. variables `l` and `maxLen` are taken to store current length and maximum length. Variables used as pointers for our array `nums[]` are `i` and `k`. \\n\\n- At the beginning we will set `l=0` which means pointers are not set so on entering the loop if `l==0` then `k` will be set at that index, `l=1` and continue.\\n- For any value at index k we will check for equality-\\nat even distances i: `nums[k]==nums[i]`\\nat odd distances i: `nums[k]+1==nums[i]`\\nif true we will `update l` and `maxLen `\\n- else set `l=0` and set value of i to:\\n  if `i` was at even distance `i=i-2`\\n if `i` was at odd distance `i=i-1`\\n- at the end we will return vlaue of `maxLen`. If it is equal to 1 then that means no alternating subsequence exists so we will return -1\\n\\n**Note:** To check if distance is even or odd, formula used is `(k-i)%2`. If it is equal to 1 then odd distance else even.\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int alternatingSubarray(int[] nums) {\\n        int l=0,k=0,maxLen=1;\\n        for(int i=0;i<nums.length;i++){\\n            if(l==0){k=i;l=1;continue;}\\n            if(((i-k)%2+nums[k])==nums[i]){\\n                l++;\\n                maxLen=Math.max(maxLen,l);\\n            }\\n            else{\\n                l=0;\\n                if((k-i)%2==0)i=i-2;\\n                else i=i-1;\\n            }\\n        }\\n        if(maxLen==1) return -1;\\n        return maxLen;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int alternatingSubarray(int[] nums) {\\n        int l=0,k=0,maxLen=1;\\n        for(int i=0;i<nums.length;i++){\\n            if(l==0){k=i;l=1;continue;}\\n            if(((i-k)%2+nums[k])==nums[i]){\\n                l++;\\n                maxLen=Math.max(maxLen,l);\\n            }\\n            else{\\n                l=0;\\n                if((k-i)%2==0)i=i-2;\\n                else i=i-1;\\n            }\\n        }\\n        if(maxLen==1) return -1;\\n        return maxLen;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3790313,
                "title": "java-commented-solution-with-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int alternatingSubarray(int[] nums) {\\n        // If only a single element, then return -1. No alternating subarrays.\\n        if (nums.length == 1) return -1;\\n\\n        int max = Integer.MIN_VALUE;\\n\\n        // Initialize start of window to 0, end to 1. We already know that there exist at least 2 elements from the first check above.\\n        int start = 0;\\n        int end = 1;\\n\\n        // Set direction to \"1\" which means next number should be 1 greater. -1 means next number should be 1 lesser.\\n        int direction = 1;\\n\\n        // Set a found flag to false (honestly, to make things easier to return -1).\\n        boolean found = false;\\n\\n        // Setup a variable to capture currentLength.\\n        int currentLength = 0;\\n\\n        // Start the loop.\\n        while (true) {\\n            \\n            // If end is beyond the last index then break.\\n            if (end == nums.length) break;\\n\\n            // Capture the first number.\\n            int num1 = nums[start];\\n\\n            // Start moving the end pointer till:\\n            // -- we reach a point where the directional condition is not satisfied\\n            // OR\\n            // -- end is beyond the last index.\\n            while (true) {\\n\\n                // Check for our condition.\\n                if (nums[end] - num1 == direction) {\\n\\n                    // If condition is valid, capture the value for the next iteration.\\n                    num1 = nums[end];\\n\\n                    // Increment the end pointer.\\n                    end++;\\n\\n                    // For the next iteration we want to check the opposite equality.\\n                    direction = direction * -1;\\n\\n                    // We found at least a single match. So set this flag to true.\\n                    found = true;\\n\\n                    // If we reached the end of the array then just break.\\n                    if (end == nums.length) break;\\n                } else {\\n                    // Our condition was not satisfied. So break from here.\\n                    break;\\n                }\\n            }\\n\\n            // Get the currentLength as the difference between end and start.\\n            currentLength = end - start;\\n\\n            // Set the max.\\n            max = Math.max(max, currentLength);\\n\\n            // Adjust the window.\\n            // If we came here when end was less than the last index, then move up start as below. \\n            if (end < nums.length) {\\n\\n                // If number at end is 1 greater than number at end - 1, then set start to end - 1.\\n                if (nums[end] == nums[end - 1] + 1) {\\n                    start = end - 1;\\n                } else {\\n                    // Else set start to end and increment end by 1 (similar to how we started this entire while loop).\\n                    start = end;\\n                    end++;\\n                }\\n                // Set direction back to 1 since we are restarting the search.\\n                direction = 1;\\n            }\\n        }\\n\\n        // If we came here and we didn\\'t find anything at all, then return -1.\\n        if (!found) return -1;\\n\\n        return max;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int alternatingSubarray(int[] nums) {\\n        // If only a single element, then return -1. No alternating subarrays.\\n        if (nums.length == 1) return -1;\\n\\n        int max = Integer.MIN_VALUE;\\n\\n        // Initialize start of window to 0, end to 1. We already know that there exist at least 2 elements from the first check above.\\n        int start = 0;\\n        int end = 1;\\n\\n        // Set direction to \"1\" which means next number should be 1 greater. -1 means next number should be 1 lesser.\\n        int direction = 1;\\n\\n        // Set a found flag to false (honestly, to make things easier to return -1).\\n        boolean found = false;\\n\\n        // Setup a variable to capture currentLength.\\n        int currentLength = 0;\\n\\n        // Start the loop.\\n        while (true) {\\n            \\n            // If end is beyond the last index then break.\\n            if (end == nums.length) break;\\n\\n            // Capture the first number.\\n            int num1 = nums[start];\\n\\n            // Start moving the end pointer till:\\n            // -- we reach a point where the directional condition is not satisfied\\n            // OR\\n            // -- end is beyond the last index.\\n            while (true) {\\n\\n                // Check for our condition.\\n                if (nums[end] - num1 == direction) {\\n\\n                    // If condition is valid, capture the value for the next iteration.\\n                    num1 = nums[end];\\n\\n                    // Increment the end pointer.\\n                    end++;\\n\\n                    // For the next iteration we want to check the opposite equality.\\n                    direction = direction * -1;\\n\\n                    // We found at least a single match. So set this flag to true.\\n                    found = true;\\n\\n                    // If we reached the end of the array then just break.\\n                    if (end == nums.length) break;\\n                } else {\\n                    // Our condition was not satisfied. So break from here.\\n                    break;\\n                }\\n            }\\n\\n            // Get the currentLength as the difference between end and start.\\n            currentLength = end - start;\\n\\n            // Set the max.\\n            max = Math.max(max, currentLength);\\n\\n            // Adjust the window.\\n            // If we came here when end was less than the last index, then move up start as below. \\n            if (end < nums.length) {\\n\\n                // If number at end is 1 greater than number at end - 1, then set start to end - 1.\\n                if (nums[end] == nums[end - 1] + 1) {\\n                    start = end - 1;\\n                } else {\\n                    // Else set start to end and increment end by 1 (similar to how we started this entire while loop).\\n                    start = end;\\n                    end++;\\n                }\\n                // Set direction back to 1 since we are restarting the search.\\n                direction = 1;\\n            }\\n        }\\n\\n        // If we came here and we didn\\'t find anything at all, then return -1.\\n        if (!found) return -1;\\n\\n        return max;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3787782,
                "title": "python-sliding-window-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def alternatingSubarray(self, nums: List[int]) -> int:\\n        if not nums:\\n            return \\n        \\n        length = -1\\n        start = 0\\n\\n        for end in range(1, len(nums)):\\n            if nums[end] == nums[start] + (start - end) % 2:\\n                length = max(length, end - start + 1)\\n            \\n            else:\\n                if nums[end] == nums[end-1] + 1:\\n                    start = end -1 \\n                else:\\n                    start = end\\n        \\n        return length\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def alternatingSubarray(self, nums: List[int]) -> int:\\n        if not nums:\\n            return \\n        \\n        length = -1\\n        start = 0\\n\\n        for end in range(1, len(nums)):\\n            if nums[end] == nums[start] + (start - end) % 2:\\n                length = max(length, end - start + 1)\\n            \\n            else:\\n                if nums[end] == nums[end-1] + 1:\\n                    start = end -1 \\n                else:\\n                    start = end\\n        \\n        return length\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785659,
                "title": "c-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int mx=-1,c=INT_MAX;\\n        for(int r=1,l=0;r<size(nums);++r){\\n            int d=nums[r]-nums[r-1];\\n            if(d==c*(-1)){\\n                c*=-1;\\n                mx=max(mx,r-l+1);\\n            }\\n            else{\\n                if(d==1){\\n                    c=1;\\n                    l=r-1;\\n                    mx=max(mx,r-l+1);\\n                }\\n                else c=INT_MAX;\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int mx=-1,c=INT_MAX;\\n        for(int r=1,l=0;r<size(nums);++r){\\n            int d=nums[r]-nums[r-1];\\n            if(d==c*(-1)){\\n                c*=-1;\\n                mx=max(mx,r-l+1);\\n            }\\n            else{\\n                if(d==1){\\n                    c=1;\\n                    l=r-1;\\n                    mx=max(mx,r-l+1);\\n                }\\n                else c=INT_MAX;\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3780897,
                "title": "simple-javascript-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)2$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)2$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar alternatingSubarray = function(nums) {\\n    let max = -1;\\n    for (let i = 0; i < nums.length - 1; i ++) {\\n        if (nums[i + 1] - nums[i] == 1) {\\n            let longest = 2;\\n            for (let j = i + 2; j < nums.length; j ++) {\\n                if (j < nums.length && nums[j] == nums[j - 2]) longest ++;\\n                else break;\\n            }\\n            max = Math.max(max, longest);\\n        }\\n    }\\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar alternatingSubarray = function(nums) {\\n    let max = -1;\\n    for (let i = 0; i < nums.length - 1; i ++) {\\n        if (nums[i + 1] - nums[i] == 1) {\\n            let longest = 2;\\n            for (let j = i + 2; j < nums.length; j ++) {\\n                if (j < nums.length && nums[j] == nums[j - 2]) longest ++;\\n                else break;\\n            }\\n            max = Math.max(max, longest);\\n        }\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3780816,
                "title": "c-2ptrs",
                "content": "```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        nums.push_back(-1);\\n        int l = 0, diff = 1, res = -1;\\n        for (int i = 1; i < nums.size(); ++i) {\\n            int x = nums[i] - nums[i - 1];\\n            if (diff != x) {\\n                diff = (x == 1) ? -1 : 1, res = max(i - l, res), l = i - (x == 1);\\n            } else {\\n                diff = -diff;\\n            }\\n        }\\n        return res < 2 ? -1 : res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        nums.push_back(-1);\\n        int l = 0, diff = 1, res = -1;\\n        for (int i = 1; i < nums.size(); ++i) {\\n            int x = nums[i] - nums[i - 1];\\n            if (diff != x) {\\n                diff = (x == 1) ? -1 : 1, res = max(i - l, res), l = i - (x == 1);\\n            } else {\\n                diff = -diff;\\n            }\\n        }\\n        return res < 2 ? -1 : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779565,
                "title": "my-naive-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int alternatingSubarray(int[] nums) {\\n        int maxLength = -1;\\n        int currentLength;\\n        int index = 0;\\n\\n        while (index < nums.length - 1) {\\n            if (nums[index] + 1 == nums[index + 1]) {\\n                currentLength = findAlternateArrayLength(nums, index);\\n                index = index + currentLength - 1;\\n                maxLength = Math.max(currentLength, maxLength);\\n            } else {\\n                index++;\\n            }\\n        }\\n        return maxLength;\\n    }\\n\\n    private int findAlternateArrayLength(int[] nums, int index) {\\n        int length = 1;\\n        int diff = 1;\\n\\n        for (int i = index; i < nums.length - 1; i++) {\\n            if (nums[i] + diff == nums[i + 1]) {\\n                length++;\\n                diff = -1 * diff;\\n            } else {\\n                break;\\n            }\\n        }\\n\\n        return length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int alternatingSubarray(int[] nums) {\\n        int maxLength = -1;\\n        int currentLength;\\n        int index = 0;\\n\\n        while (index < nums.length - 1) {\\n            if (nums[index] + 1 == nums[index + 1]) {\\n                currentLength = findAlternateArrayLength(nums, index);\\n                index = index + currentLength - 1;\\n                maxLength = Math.max(currentLength, maxLength);\\n            } else {\\n                index++;\\n            }\\n        }\\n        return maxLength;\\n    }\\n\\n    private int findAlternateArrayLength(int[] nums, int index) {\\n        int length = 1;\\n        int diff = 1;\\n\\n        for (int i = index; i < nums.length - 1; i++) {\\n            if (nums[i] + diff == nums[i + 1]) {\\n                length++;\\n                diff = -1 * diff;\\n            } else {\\n                break;\\n            }\\n        }\\n\\n        return length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779022,
                "title": "java-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int alternatingSubarray(int[] nums) {\\n        int i = 0;\\n        int n = nums.length;\\n\\n        int ans = -1;\\n        while(i < n-1){\\n            int count = 1;\\n            boolean check = true;\\n            int j = i;\\n            for(j = i;j<n-1;j++){\\n                if(check == true && nums[j+1] - nums[j] == 1)\\n                    count++;\\n                else if(check == false && nums[j + 1] - nums[j] == -1)\\n                    count++;\\n                else\\n                    break;\\n                check = !check;\\n            }\\n            if(count > 1 && count > ans)\\n                ans = count;\\n            if(i == j)\\n                i = j+1;\\n            else\\n                i = j;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int alternatingSubarray(int[] nums) {\\n        int i = 0;\\n        int n = nums.length;\\n\\n        int ans = -1;\\n        while(i < n-1){\\n            int count = 1;\\n            boolean check = true;\\n            int j = i;\\n            for(j = i;j<n-1;j++){\\n                if(check == true && nums[j+1] - nums[j] == 1)\\n                    count++;\\n                else if(check == false && nums[j + 1] - nums[j] == -1)\\n                    count++;\\n                else\\n                    break;\\n                check = !check;\\n            }\\n            if(count > 1 && count > ans)\\n                ans = count;\\n            if(i == j)\\n                i = j+1;\\n            else\\n                i = j;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777673,
                "title": "python-simple-python-solution-brute-force",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 1556 ms, faster than 5.00% of Python3 online submissions for Longest Alternating Subarray.\\n# Memory Usage: 16.3 MB, less than 61.56% of Python3 online submissions for Longest Alternating Subarray.\\n\\n\\tclass Solution:\\n\\t\\tdef alternatingSubarray(self, nums: List[int]) -> int:\\n\\n\\t\\t\\tresult = -1\\n\\n\\t\\t\\tdef check(subarray):\\n\\n\\t\\t\\t\\talternating_difference = True\\n\\n\\t\\t\\t\\tfor index in range(1, len(subarray)):\\n\\n\\t\\t\\t\\t\\tif (subarray[index] - subarray[index - 1]) == 1 and alternating_difference == True:\\n\\t\\t\\t\\t\\t\\talternating_difference = False\\n\\n\\t\\t\\t\\t\\telif (subarray[index] - subarray[index - 1]) == -1 and alternating_difference == False:\\n\\t\\t\\t\\t\\t\\talternating_difference = True\\n\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t\\treturn True\\n\\n\\t\\t\\tfor i in range(len(nums)):\\n\\t\\t\\t\\tfor j in range(i + 1 , len(nums)):\\n\\n\\t\\t\\t\\t\\tsubarray = nums[i : j + 1]\\n\\n\\t\\t\\t\\t\\tif check(subarray) == True:\\n\\n\\t\\t\\t\\t\\t\\tresult = max(result , len(subarray))\\n\\n\\t\\t\\treturn result\\n\\t\\t\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 1556 ms, faster than 5.00% of Python3 online submissions for Longest Alternating Subarray.\\n# Memory Usage: 16.3 MB, less than 61.56% of Python3 online submissions for Longest Alternating Subarray.\\n\\n\\tclass Solution:\\n\\t\\tdef alternatingSubarray(self, nums: List[int]) -> int:\\n\\n\\t\\t\\tresult = -1\\n\\n\\t\\t\\tdef check(subarray):\\n\\n\\t\\t\\t\\talternating_difference = True\\n\\n\\t\\t\\t\\tfor index in range(1, len(subarray)):\\n\\n\\t\\t\\t\\t\\tif (subarray[index] - subarray[index - 1]) == 1 and alternating_difference == True:\\n\\t\\t\\t\\t\\t\\talternating_difference = False\\n\\n\\t\\t\\t\\t\\telif (subarray[index] - subarray[index - 1]) == -1 and alternating_difference == False:\\n\\t\\t\\t\\t\\t\\talternating_difference = True\\n\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t\\treturn True\\n\\n\\t\\t\\tfor i in range(len(nums)):\\n\\t\\t\\t\\tfor j in range(i + 1 , len(nums)):\\n\\n\\t\\t\\t\\t\\tsubarray = nums[i : j + 1]\\n\\n\\t\\t\\t\\t\\tif check(subarray) == True:\\n\\n\\t\\t\\t\\t\\t\\tresult = max(result , len(subarray))\\n\\n\\t\\t\\treturn result\\n\\t\\t\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 3774555,
                "title": "100-2ms-easy-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int alternatingSubarray(int[] nums) {\\n        int length = nums.length;\\n        int result = -1;\\n        int currentLength = -1;\\n\\n        for (int i = 1; i < length; ++i, result = Math.max(result, currentLength)) {\\n            if (currentLength > 0 && nums[i] == nums[i - 2]) {\\n                currentLength++;\\n            } else {\\n                // Reset the currentLength if the alternating pattern is broken\\n                // Set currentLength to 2 if the current element is equal to the previous element + 1\\n                // Otherwise, set currentLength to -1\\n                currentLength = nums[i] == nums[i - 1] + 1 ? 2 : -1;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int alternatingSubarray(int[] nums) {\\n        int length = nums.length;\\n        int result = -1;\\n        int currentLength = -1;\\n\\n        for (int i = 1; i < length; ++i, result = Math.max(result, currentLength)) {\\n            if (currentLength > 0 && nums[i] == nums[i - 2]) {\\n                currentLength++;\\n            } else {\\n                // Reset the currentLength if the alternating pattern is broken\\n                // Set currentLength to 2 if the current element is equal to the previous element + 1\\n                // Otherwise, set currentLength to -1\\n                currentLength = nums[i] == nums[i - 1] + 1 ? 2 : -1;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3769570,
                "title": "java-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int alternatingSubarray(int[] nums) {\\n    int ans = -1;\\n    for(int i = 1; i != nums.length; ++i)\\n      if(nums[i] - nums[i-1] == 1){\\n        int j = i;\\n        for(int k = 1; j != nums.length; ++j, k = -k)\\n          if(nums[j] - nums[j-1] != k) break;\\n        ans = Math.max(ans, j-i+1);\\n        i = j-1;\\n      } \\n\\n    return ans;       \\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int alternatingSubarray(int[] nums) {\\n    int ans = -1;\\n    for(int i = 1; i != nums.length; ++i)\\n      if(nums[i] - nums[i-1] == 1){\\n        int j = i;\\n        for(int k = 1; j != nums.length; ++j, k = -k)\\n          if(nums[j] - nums[j-1] != k) break;\\n        ans = Math.max(ans, j-i+1);\\n        i = j-1;\\n      } \\n\\n    return ans;       \\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766058,
                "title": "solution-through-checking-s-2",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nconst alternatingSubarray = function (nums) {\\n  let maxLen = 0;\\n  let count = 0;\\n  for (let i = 1; i < nums.length; i++) {\\n    const prev = nums[i - 1];\\n    const curr = nums[i];\\n    if (count && (count % 2 === 0 && curr === prev - 1 || count % 2 === 1 && curr === prev + 1)) count++;\\n    else {\\n      maxLen = Math.max(maxLen, count);\\n      count = 0;\\n      if (curr === prev + 1) count += 2;\\n    }\\n  }\\n  maxLen = Math.max(maxLen, count);\\n  return maxLen ? maxLen : -1;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nconst alternatingSubarray = function (nums) {\\n  let maxLen = 0;\\n  let count = 0;\\n  for (let i = 1; i < nums.length; i++) {\\n    const prev = nums[i - 1];\\n    const curr = nums[i];\\n    if (count && (count % 2 === 0 && curr === prev - 1 || count % 2 === 1 && curr === prev + 1)) count++;\\n    else {\\n      maxLen = Math.max(maxLen, count);\\n      count = 0;\\n      if (curr === prev + 1) count += 2;\\n    }\\n  }\\n  maxLen = Math.max(maxLen, count);\\n  return maxLen ? maxLen : -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3765918,
                "title": "if-else",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def alternatingSubarray(self, nums: List[int]) -> int:\\n        up,down=0,0\\n        i=0\\n        ans=-1\\n        while i < len(nums)-1:\\n            if nums[i+1] - nums[i] == 1:\\n                up+=1\\n            elif nums[i+1] - nums[i] == -1:\\n                down+=1\\n            else:\\n                up,down=0,0\\n            if up> down+1:\\n                ans=max(ans,up+down-1)\\n                up,down=1,0\\n            if down>up:\\n                ans=max(ans,up+down-1)\\n                up,down=0,0\\n            ans=max(ans,up+down)\\n            i+=1\\n        if ans==0:\\n            return -1\\n        return ans+1\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def alternatingSubarray(self, nums: List[int]) -> int:\\n        up,down=0,0\\n        i=0\\n        ans=-1\\n        while i < len(nums)-1:\\n            if nums[i+1] - nums[i] == 1:\\n                up+=1\\n            elif nums[i+1] - nums[i] == -1:\\n                down+=1\\n            else:\\n                up,down=0,0\\n            if up> down+1:\\n                ans=max(ans,up+down-1)\\n                up,down=1,0\\n            if down>up:\\n                ans=max(ans,up+down-1)\\n                up,down=0,0\\n            ans=max(ans,up+down)\\n            i+=1\\n        if ans==0:\\n            return -1\\n        return ans+1\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3764783,
                "title": "fixed-size-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsliding window with fixed size = 2(two element inside window)\\nmake a flag variable to ensure when we need +ve 1 when -1 \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int alternatingSubarray(int[] arr) {\\n        int n = arr.length ;\\n        boolean flag  = true;\\n        int i = 0, j = 0;\\n        int ans = 0,count = 0;\\n        while(j<n){\\n            int diff = arr[j] -arr[i];\\n            if(j-i+1 !=2){\\n                j++;\\n                continue;\\n            }\\n            if(diff == 1 && flag){\\n                ans = Math.max(ans,++count);\\n                i++; j++;\\n                flag = false;\\n            }\\n            else if(diff == -1 && !flag){\\n                ans = Math.max(ans,++count);\\n                i++; j++;\\n                flag = true;;\\n            }\\n            else{\\n                if(diff == 1){\\n                    flag = false;\\n                    count = 1;\\n                    i++;j++;\\n                }\\n                else{\\n                    flag = true;\\n                    count = 0;\\n                    i++;j++;\\n                }\\n            }\\n        }\\n        return ans == 0 ? -1:ans+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int alternatingSubarray(int[] arr) {\\n        int n = arr.length ;\\n        boolean flag  = true;\\n        int i = 0, j = 0;\\n        int ans = 0,count = 0;\\n        while(j<n){\\n            int diff = arr[j] -arr[i];\\n            if(j-i+1 !=2){\\n                j++;\\n                continue;\\n            }\\n            if(diff == 1 && flag){\\n                ans = Math.max(ans,++count);\\n                i++; j++;\\n                flag = false;\\n            }\\n            else if(diff == -1 && !flag){\\n                ans = Math.max(ans,++count);\\n                i++; j++;\\n                flag = true;;\\n            }\\n            else{\\n                if(diff == 1){\\n                    flag = false;\\n                    count = 1;\\n                    i++;j++;\\n                }\\n                else{\\n                    flag = true;\\n                    count = 0;\\n                    i++;j++;\\n                }\\n            }\\n        }\\n        return ans == 0 ? -1:ans+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3764534,
                "title": "c-simple-solution",
                "content": "\\n# Approach\\nExample of valid sequence: 3,4,3,4,3,4,3,4\\n\\nStart the valid sequence when it meet a condition (nums[i]==nums[i+1]-1) then we will check a condition nums[i]==nums[i-2] for subsequent numbers in valid sequence. \\n# Complexity\\n- Time complexity:\\nO(N) -> Number of elements in nums\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int l=-1,s=0;\\n        for(int i=1;i<nums.size();i++){\\n            if (i==s+1 && nums[i]!=nums[s]+1){\\n                s=i;\\n                continue;\\n            }\\n            else if (i>s+1 && nums[i]!=nums[i-2]){\\n                if (nums[i]==nums[i-1]+1) s=i-1;\\n                else s=i;\\n                continue;\\n            }\\n            l=max(l,i-s+1);\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int l=-1,s=0;\\n        for(int i=1;i<nums.size();i++){\\n            if (i==s+1 && nums[i]!=nums[s]+1){\\n                s=i;\\n                continue;\\n            }\\n            else if (i>s+1 && nums[i]!=nums[i-2]){\\n                if (nums[i]==nums[i-1]+1) s=i-1;\\n                else s=i;\\n                continue;\\n            }\\n            l=max(l,i-s+1);\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3762746,
                "title": "standard-sliding-window-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int n = nums.size();\\n        int maxlen = 0;\\n        for(int i=0,j=1;j<n;j++){\\n            int diff = nums[j]-nums[j-1];\\n            int reqd = (j-i)%2 ? 1 : -1;\\n            if(reqd == diff) maxlen = max(maxlen,j-i+1);\\n            else if(diff == 1) i = j-1;\\n            else i = j;\\n        }\\n        return maxlen == 0 ? -1 : maxlen;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int n = nums.size();\\n        int maxlen = 0;\\n        for(int i=0,j=1;j<n;j++){\\n            int diff = nums[j]-nums[j-1];\\n            int reqd = (j-i)%2 ? 1 : -1;\\n            if(reqd == diff) maxlen = max(maxlen,j-i+1);\\n            else if(diff == 1) i = j-1;\\n            else i = j;\\n        }\\n        return maxlen == 0 ? -1 : maxlen;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3762714,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int alternatingSubarray(int[] nums) {  \\n        int n= nums.length;\\n        int res=0;\\n        for(int i=0;i<n-1;i++){\\n            int prev=nums[i];\\n            int count=0;\\n            int dir=1;\\n            \\n            for(int j=i+1;j<n;j++){\\n                if(nums[j]-prev==dir){\\n                    count=Math.max(count,j-i+1);\\n                    dir*=-1;\\n                    prev=nums[j];\\n                }else{\\n                    break;\\n                }\\n            }\\n            res=Math.max(res,count);\\n        }\\n        return res==0 ?-1 : res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int alternatingSubarray(int[] nums) {  \\n        int n= nums.length;\\n        int res=0;\\n        for(int i=0;i<n-1;i++){\\n            int prev=nums[i];\\n            int count=0;\\n            int dir=1;\\n            \\n            for(int j=i+1;j<n;j++){\\n                if(nums[j]-prev==dir){\\n                    count=Math.max(count,j-i+1);\\n                    dir*=-1;\\n                    prev=nums[j];\\n                }else{\\n                    break;\\n                }\\n            }\\n            res=Math.max(res,count);\\n        }\\n        return res==0 ?-1 : res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3758927,
                "title": "brute-approach-at-first-look-to-question",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(N*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int n=nums.size();\\n        int maxi=-1;\\n        for(int i=0;i<n;i++){\\n            int a=i,cnt= 1;\\n            bool flag=true;\\n            bool flag1=false;\\n          for(int j=i+1;j<n;j++){\\n                if(nums[j]-nums[a]==1 && flag==true){\\n                    a=j;\\n                    cnt++;\\n                    flag1=true;\\n                    flag=false;\\n                }\\n                else if(nums[j]-nums[a]==-1 && flag==false){\\n                    a=j;\\n                    cnt++;\\n                    flag=true;\\n                    flag1=true;\\n                }\\n                else break;\\n            }\\n            if(flag1)\\n            maxi=max(maxi,cnt);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int n=nums.size();\\n        int maxi=-1;\\n        for(int i=0;i<n;i++){\\n            int a=i,cnt= 1;\\n            bool flag=true;\\n            bool flag1=false;\\n          for(int j=i+1;j<n;j++){\\n                if(nums[j]-nums[a]==1 && flag==true){\\n                    a=j;\\n                    cnt++;\\n                    flag1=true;\\n                    flag=false;\\n                }\\n                else if(nums[j]-nums[a]==-1 && flag==false){\\n                    a=j;\\n                    cnt++;\\n                    flag=true;\\n                    flag1=true;\\n                }\\n                else break;\\n            }\\n            if(flag1)\\n            maxi=max(maxi,cnt);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3756332,
                "title": "simple-c-solution-by-checking-for-all-subarrays",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int maxi=-1,count=0,k=0;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            count=1;k=0;\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(nums[j]-nums[j-1]==pow(-1,k))\\n                {\\n                    count++;\\n                    k++;\\n                    maxi=max(maxi,count);\\n                }\\n                else\\n                break;\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Enumeration"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int maxi=-1,count=0,k=0;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            count=1;k=0;\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(nums[j]-nums[j-1]==pow(-1,k))\\n                {\\n                    count++;\\n                    k++;\\n                    maxi=max(maxi,count);\\n                }\\n                else\\n                break;\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3756275,
                "title": "linear-time-with-a-very-beginner-friendly-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int n=nums.size();\\n        int i=0,j=0;\\n        int len=1;\\n        int ans=-1;\\n        while(j<n){\\n            if(j+1<n and nums[j]==nums[j+1]-1){\\n                len++;\\n                ans=max(ans,len);\\n                if(j+2<n and nums[j+2]==nums[j]){\\n                    len++;\\n                    j++;\\n                    // ans=max(ans,len);\\n                }else{\\n                    len=1;\\n                }\\n                ans=max(ans,len);\\n            }\\n            else{\\n                len=1;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int n=nums.size();\\n        int i=0,j=0;\\n        int len=1;\\n        int ans=-1;\\n        while(j<n){\\n            if(j+1<n and nums[j]==nums[j+1]-1){\\n                len++;\\n                ans=max(ans,len);\\n                if(j+2<n and nums[j+2]==nums[j]){\\n                    len++;\\n                    j++;\\n                    // ans=max(ans,len);\\n                }else{\\n                    len=1;\\n                }\\n                ans=max(ans,len);\\n            }\\n            else{\\n                len=1;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3756274,
                "title": "linear-time-with-a-very-beginner-friendly-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int n=nums.size();\\n        int i=0,j=0;\\n        int len=1;\\n        int ans=-1;\\n        while(j<n){\\n            if(j+1<n and nums[j]==nums[j+1]-1){\\n                len++;\\n                ans=max(ans,len);\\n                if(j+2<n and nums[j+2]==nums[j]){\\n                    len++;\\n                    j++;\\n                    // ans=max(ans,len);\\n                }else{\\n                    len=1;\\n                }\\n                ans=max(ans,len);\\n            }\\n            else{\\n                len=1;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int n=nums.size();\\n        int i=0,j=0;\\n        int len=1;\\n        int ans=-1;\\n        while(j<n){\\n            if(j+1<n and nums[j]==nums[j+1]-1){\\n                len++;\\n                ans=max(ans,len);\\n                if(j+2<n and nums[j+2]==nums[j]){\\n                    len++;\\n                    j++;\\n                    // ans=max(ans,len);\\n                }else{\\n                    len=1;\\n                }\\n                ans=max(ans,len);\\n            }\\n            else{\\n                len=1;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754122,
                "title": "ruby-one-liner-with-regex",
                "content": "```\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef alternating_subarray(nums)\\n  nums.each_cons(2).map { {1 => 1, -1 => 0}[_2 - _1] || 2 }.join.scan(/1(?:01)*0?/).map(&:size).max&.succ || -1  \\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef alternating_subarray(nums)\\n  nums.each_cons(2).map { {1 => 1, -1 => 0}[_2 - _1] || 2 }.join.scan(/1(?:01)*0?/).map(&:size).max&.succ || -1  \\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3754121,
                "title": "ruby-one-liner-with-regex",
                "content": "```\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef alternating_subarray(nums)\\n  nums.each_cons(2).map { {1 => 1, -1 => 0}[_2 - _1] || 2 }.join.scan(/1(?:01)*0?/).map(&:size).max&.succ || -1  \\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef alternating_subarray(nums)\\n  nums.each_cons(2).map { {1 => 1, -1 => 0}[_2 - _1] || 2 }.join.scan(/1(?:01)*0?/).map(&:size).max&.succ || -1  \\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3753880,
                "title": "java-o-n-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int alternatingSubarray(int[] nums) {\\n        int maxlen = 0;\\n        int len = 1;\\n        int next = 1;\\n        int n = nums.length;\\n        for(int i=1;i<n;i++) {\\n            if( next == 1 && nums[i] -nums[i-1] == 1 ){\\n                len ++;\\n                next =-1;\\n            }\\n            else if(next == -1 && nums[i] - nums[i-1] == -1) {\\n                len++;\\n                next = 1;\\n            }\\n            else {\\n                maxlen = Math.max(maxlen, len);\\n                if( nums[i] -nums[i-1] == 1  ) {\\n                    len = 2;\\n                    next = -1;\\n                }\\n                else {\\n                    len = 1;\\n                    next = 1;\\n                }\\n\\n                \\n            }\\n            \\n        }\\n        maxlen = Math.max(maxlen, len);\\n        return maxlen == 1 ? -1 : maxlen;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int alternatingSubarray(int[] nums) {\\n        int maxlen = 0;\\n        int len = 1;\\n        int next = 1;\\n        int n = nums.length;\\n        for(int i=1;i<n;i++) {\\n            if( next == 1 && nums[i] -nums[i-1] == 1 ){\\n                len ++;\\n                next =-1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3751760,
                "title": "easy-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int alternatingSubarray(int[] nums) {\\n        int startIndex = -1;\\n        int ans = -1;\\n        int expectedDiff = 1;\\n        for(int i=1; i<nums.length; i++)\\n        \\n            if(nums[i] - nums[i-1] == expectedDiff)\\n            {\\n                if(startIndex == -1)\\n                startIndex = i-1;\\n                expectedDiff *= -1;\\n            }\\n            else if(startIndex != -1)\\n            {\\n                ans = Math.max(ans, i-startIndex);\\n                startIndex = -1;\\n                expectedDiff = 1;\\n                i--;\\n            }\\n            if(startIndex != -1)\\n            ans = Math.max(ans, nums.length- startIndex);\\n            return ans;\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int alternatingSubarray(int[] nums) {\\n        int startIndex = -1;\\n        int ans = -1;\\n        int expectedDiff = 1;\\n        for(int i=1; i<nums.length; i++)\\n        \\n            if(nums[i] - nums[i-1] == expectedDiff)\\n            {\\n                if(startIndex == -1)\\n                startIndex = i-1;\\n                expectedDiff *= -1;\\n            }\\n            else if(startIndex != -1)\\n            {\\n                ans = Math.max(ans, i-startIndex);\\n                startIndex = -1;\\n                expectedDiff = 1;\\n                i--;\\n            }\\n            if(startIndex != -1)\\n            ans = Math.max(ans, nums.length- startIndex);\\n            return ans;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3750667,
                "title": "sliding-window-c-faster-than-100-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        if(nums.size()<2)\\n            return -1;\\n        int i=0,j=1,len=0;\\n        while(j<nums.size()){\\n            if(nums[j]==nums[i]+1){\\n                int x=nums[j];\\n                while(j<nums.size() && nums[j]==x){\\n                    x=nums[j-1];\\n                    j++;\\n                }\\n                len=max(len,j-i);\\n                j=++i+1;\\n            }\\n            else\\n                j=++i+1;\\n        }\\n        return len==0? -1:len;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        if(nums.size()<2)\\n            return -1;\\n        int i=0,j=1,len=0;\\n        while(j<nums.size()){\\n            if(nums[j]==nums[i]+1){\\n                int x=nums[j];\\n                while(j<nums.size() && nums[j]==x){\\n                    x=nums[j-1];\\n                    j++;\\n                }\\n                len=max(len,j-i);\\n                j=++i+1;\\n            }\\n            else\\n                j=++i+1;\\n        }\\n        return len==0? -1:len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3750628,
                "title": "java-easy-100-space-and-time-simple-to-understand-no-collection",
                "content": "# Intuition\\nOne traversal is enough, why ? because we don\\'t have to memorise previous output or input, we just have to depend on one step previous value which is easy to store in one variable\\n\\n# Approach\\ngo one by one step, if `local` is zero then we\\'re starting sequence else we\\'re continuing sequence.\\nWhile continuing sequence if appropriate increment/decrement is not happening then reset the `local` and start again while staying there only (that\\'s why `i--` because at the loop end automatic `i++` is executed so to counter that we\\'ve to add `i--`)\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ only one loop traversal\\n\\n- Space complexity:\\n$$O(1)$$ only 4 variable storage needed\\n\\n# Code\\n```\\nclass Solution {\\n    public int alternatingSubarray(int[] nums) {\\n        int max = -1;\\n        int local = 0;\\n        boolean cont = false, inc = true;\\n        for(int i=0;i<nums.length-1;i++){\\n            if(local==0){\\n                if(nums[i]+1 == nums[i+1]) {\\n                    local = 2;\\n                    inc = false;\\n                    if(max==-1) max = 2;\\n                }\\n            } else {\\n                if(inc) {\\n                    if(nums[i]+1 == nums[i+1]){\\n                        local++;\\n                        inc = false;\\n                        if(local>max) max = local;\\n                    } else {\\n                        local = 0;\\n                        i--;\\n                    }\\n                } else {\\n                    if(nums[i]-1 == nums[i+1]){\\n                        local++;\\n                        inc = true;\\n                        if(local>max) max = local;\\n                    } else {\\n                        local = 0;\\n                        i--;\\n                    }\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int alternatingSubarray(int[] nums) {\\n        int max = -1;\\n        int local = 0;\\n        boolean cont = false, inc = true;\\n        for(int i=0;i<nums.length-1;i++){\\n            if(local==0){\\n                if(nums[i]+1 == nums[i+1]) {\\n                    local = 2;\\n                    inc = false;\\n                    if(max==-1) max = 2;\\n                }\\n            } else {\\n                if(inc) {\\n                    if(nums[i]+1 == nums[i+1]){\\n                        local++;\\n                        inc = false;\\n                        if(local>max) max = local;\\n                    } else {\\n                        local = 0;\\n                        i--;\\n                    }\\n                } else {\\n                    if(nums[i]-1 == nums[i+1]){\\n                        local++;\\n                        inc = true;\\n                        if(local>max) max = local;\\n                    } else {\\n                        local = 0;\\n                        i--;\\n                    }\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3750410,
                "title": "java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int alternatingSubarray(int[] nums) {\\n      int sign = 1;\\n\\n\\t\\tint max = Integer.MIN_VALUE;\\n\\n\\t\\tArrayList<Integer> list = new ArrayList<>();\\n\\n\\t\\tfor (int i = 0; i <= nums.length - 1; i++) {\\n\\n\\t\\t\\tint k = i;\\n\\n\\t\\t\\tsign = 1;\\n\\t\\t\\tif(i==nums.length-1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif ((list.size() / 2) + 1 > max)\\n\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (list.size() != 0)\\n\\t\\t\\t\\t\\t\\tmax = (list.size() / 2) + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (int j = i + 1; j <= nums.length - 1; j++) {\\n\\n\\t\\t\\t\\tif (nums[j] - nums[k] == sign)\\n\\n\\t\\t\\t\\t{\\n\\n\\t\\t\\t\\t\\tlist.add(nums[j]);\\n\\n\\t\\t\\t\\t\\tlist.add(nums[k]);\\n\\t\\t\\t\\t\\t\\n\\n\\t\\t\\t\\t\\tsign = -(sign);\\n\\n\\t\\t\\t\\t\\tk++;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\telse\\n\\n\\t\\t\\t\\t{\\n\\n\\t\\t\\t\\t\\tif ((list.size() / 2) + 1 > max)\\n\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif (list.size() != 0)\\n\\t\\t\\t\\t\\t\\t\\tmax = (list.size() / 2) + 1;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tlist.clear();\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tif (max == Integer.MIN_VALUE)\\n\\t\\t\\tmax = -1;\\n\\n       return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int alternatingSubarray(int[] nums) {\\n      int sign = 1;\\n\\n\\t\\tint max = Integer.MIN_VALUE;\\n\\n\\t\\tArrayList<Integer> list = new ArrayList<>();\\n\\n\\t\\tfor (int i = 0; i <= nums.length - 1; i++) {\\n\\n\\t\\t\\tint k = i;\\n\\n\\t\\t\\tsign = 1;\\n\\t\\t\\tif(i==nums.length-1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif ((list.size() / 2) + 1 > max)\\n\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (list.size() != 0)\\n\\t\\t\\t\\t\\t\\tmax = (list.size() / 2) + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (int j = i + 1; j <= nums.length - 1; j++) {\\n\\n\\t\\t\\t\\tif (nums[j] - nums[k] == sign)\\n\\n\\t\\t\\t\\t{\\n\\n\\t\\t\\t\\t\\tlist.add(nums[j]);\\n\\n\\t\\t\\t\\t\\tlist.add(nums[k]);\\n\\t\\t\\t\\t\\t\\n\\n\\t\\t\\t\\t\\tsign = -(sign);\\n\\n\\t\\t\\t\\t\\tk++;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\telse\\n\\n\\t\\t\\t\\t{\\n\\n\\t\\t\\t\\t\\tif ((list.size() / 2) + 1 > max)\\n\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif (list.size() != 0)\\n\\t\\t\\t\\t\\t\\t\\tmax = (list.size() / 2) + 1;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tlist.clear();\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tif (max == Integer.MIN_VALUE)\\n\\t\\t\\tmax = -1;\\n\\n       return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3749020,
                "title": "brute-force-approach-in-c-do-as-said",
                "content": "```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int ans=-1;\\n        for(int i=0;i<nums.size();i++){\\n            bool vis=false;\\n            int temp=0;\\n            int c=1;\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[j]-nums[j-1]==c){\\n                    vis=true;\\n                    c*=-1;\\n                    temp++;\\n                }\\n                else{\\n                    break; //most important\\n                }\\n            }\\n            if(vis==true)\\n            ans=max(ans,temp+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int ans=-1;\\n        for(int i=0;i<nums.size();i++){\\n            bool vis=false;\\n            int temp=0;\\n            int c=1;\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[j]-nums[j-1]==c){\\n                    vis=true;\\n                    c*=-1;\\n                    temp++;\\n                }\\n                else{\\n                    break; //most important\\n                }\\n            }\\n            if(vis==true)\\n            ans=max(ans,temp+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3747508,
                "title": "elixir-solution-use-enum-reduce-and-enum-reduce-while",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 627ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 63.6MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ndefmodule Solution do\\n  @spec alternating_subarray(nums :: [integer]) :: integer\\n  def alternating_subarray(nums) do\\n    n = Enum.count(nums)\\n    res = Enum.reduce(0..n - 1, 0, fn i, res ->\\n      Enum.reduce_while(i + 1..n - 1, res, fn j, res ->\\n        if Enum.at(nums, j) != Enum.at(nums, i) + rem(j - i, 2) do\\n          {:halt, res}\\n        else\\n          {:cont, max(res, j - i + 1)}\\n        end\\n      end)\\n    end)\\n    if res > 1 do\\n      res\\n    else\\n      -1\\n    end\\n  end\\nend\\n\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```\\ndefmodule Solution do\\n  @spec alternating_subarray(nums :: [integer]) :: integer\\n  def alternating_subarray(nums) do\\n    n = Enum.count(nums)\\n    res = Enum.reduce(0..n - 1, 0, fn i, res ->\\n      Enum.reduce_while(i + 1..n - 1, res, fn j, res ->\\n        if Enum.at(nums, j) != Enum.at(nums, i) + rem(j - i, 2) do\\n          {:halt, res}\\n        else\\n          {:cont, max(res, j - i + 1)}\\n        end\\n      end)\\n    end)\\n    if res > 1 do\\n      res\\n    else\\n      -1\\n    end\\n  end\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3747251,
                "title": "easy-to-understand-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int n = nums.size();\\n        int fast = 0 , slow = 0;\\n        int prev = 0;\\n        int maxi = -1e9,cnt=0;\\n\\n        while(fast<n-1){\\n           int diff = nums[fast]-nums[fast+1];\\n           if(prev==0 && (diff==-1)){\\n               prev=diff;\\n               cnt+=2;\\n               fast++;\\n           }\\n           else if(prev == 1 && diff==-1){\\n               prev = diff;\\n               cnt++;\\n               fast++;\\n           }\\n           else if(prev == -1 && diff==1){\\n               prev = diff;\\n               cnt++;\\n               fast++;\\n           }\\n           \\n           else {\\n               maxi = max(maxi,cnt);\\n               slow++;\\n               fast = slow;\\n               prev = 0;\\n               cnt=0;\\n           }\\n           \\n        }\\n        maxi = max(cnt,maxi);\\n        if(maxi==0) return -1;\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int n = nums.size();\\n        int fast = 0 , slow = 0;\\n        int prev = 0;\\n        int maxi = -1e9,cnt=0;\\n\\n        while(fast<n-1){\\n           int diff = nums[fast]-nums[fast+1];\\n           if(prev==0 && (diff==-1)){\\n               prev=diff;\\n               cnt+=2;\\n               fast++;\\n           }\\n           else if(prev == 1 && diff==-1){\\n               prev = diff;\\n               cnt++;\\n               fast++;\\n           }\\n           else if(prev == -1 && diff==1){\\n               prev = diff;\\n               cnt++;\\n               fast++;\\n           }\\n           \\n           else {\\n               maxi = max(maxi,cnt);\\n               slow++;\\n               fast = slow;\\n               prev = 0;\\n               cnt=0;\\n           }\\n           \\n        }\\n        maxi = max(cnt,maxi);\\n        if(maxi==0) return -1;\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3747051,
                "title": "java-easy-solution-beats-100-3-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int alternatingSubarray(int[] nums) {\\n       int startIndex = -1;\\n       int ans = -1;\\n       int expectedDiff= 1;\\n       for(int i = 1 ; i < nums.length ; i++)\\n           if( nums[i] - nums [i-1] == expectedDiff)\\n           {\\n               if(startIndex == -1)\\n                   startIndex = i - 1;\\n               expectedDiff *= -1;\\n           } else if (startIndex != -1)\\n           {\\n               ans = Math.max (ans, i - startIndex);\\n               startIndex= -1;\\n               expectedDiff= 1;\\n               i--;\\n           }\\n       if(startIndex != -1)\\n            ans = Math.max (ans, nums.length - startIndex);\\n       return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int alternatingSubarray(int[] nums) {\\n       int startIndex = -1;\\n       int ans = -1;\\n       int expectedDiff= 1;\\n       for(int i = 1 ; i < nums.length ; i++)\\n           if( nums[i] - nums [i-1] == expectedDiff)\\n           {\\n               if(startIndex == -1)\\n                   startIndex = i - 1;\\n               expectedDiff *= -1;\\n           } else if (startIndex != -1)\\n           {\\n               ans = Math.max (ans, i - startIndex);\\n               startIndex= -1;\\n               expectedDiff= 1;\\n               i--;\\n           }\\n       if(startIndex != -1)\\n            ans = Math.max (ans, nums.length - startIndex);\\n       return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3746790,
                "title": "simple-one-pass",
                "content": "# Approach\\n* Look for nums[i] = 1\\n* Then count alternating differences of 1, -1 going forward\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nfunc alternatingSubarray(nums []int) int {\\n\\tct := 0\\n\\n\\tvar curr int\\n\\n\\tfor i := 1; i < len(nums); i++ {\\n\\t\\tcurr = 0\\n\\t\\tif nums[i]-nums[i-1] == 1 {\\n\\t\\t\\tcurr = 2\\n\\t\\t\\tfor j := i + 1; j < len(nums) && (nums[j]-nums[i]) == -(nums[i]-nums[i-1]); j++ {\\n\\t\\t\\t\\tcurr++\\n\\t\\t\\t\\ti++\\n\\t\\t\\t}\\n\\t\\t\\tif curr > ct {\\n\\t\\t\\t\\tct = curr\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif ct < 1 {\\n\\t\\treturn -1\\n\\t}\\n\\treturn ct\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc alternatingSubarray(nums []int) int {\\n\\tct := 0\\n\\n\\tvar curr int\\n\\n\\tfor i := 1; i < len(nums); i++ {\\n\\t\\tcurr = 0\\n\\t\\tif nums[i]-nums[i-1] == 1 {\\n\\t\\t\\tcurr = 2\\n\\t\\t\\tfor j := i + 1; j < len(nums) && (nums[j]-nums[i]) == -(nums[i]-nums[i-1]); j++ {\\n\\t\\t\\t\\tcurr++\\n\\t\\t\\t\\ti++\\n\\t\\t\\t}\\n\\t\\t\\tif curr > ct {\\n\\t\\t\\t\\tct = curr\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tif ct < 1 {\\n\\t\\treturn -1\\n\\t}\\n\\treturn ct\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3746444,
                "title": "o-n-python-sliding-window",
                "content": "\\n```\\nclass Solution:\\n    def alternatingSubarray(self, nums: List[int]) -> int:\\n        res = -1\\n        ln = len(nums)\\n        if ln < 2:\\n            return -1\\n        i,j=0,1\\n        while j < ln and nums[j] != nums[i]+1:\\n            i+=1\\n            j+=1\\n        while j < ln:\\n            if nums[j] != nums[j-2]:\\n                i = j-1\\n                while j < ln and nums[j] != nums[i]+1:\\n                    i += 1\\n                    j += 1\\n            res = max(res,j-i+1)\\n            j += 1\\n        return res\\n\\n            \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def alternatingSubarray(self, nums: List[int]) -> int:\\n        res = -1\\n        ln = len(nums)\\n        if ln < 2:\\n            return -1\\n        i,j=0,1\\n        while j < ln and nums[j] != nums[i]+1:\\n            i+=1\\n            j+=1\\n        while j < ln:\\n            if nums[j] != nums[j-2]:\\n                i = j-1\\n                while j < ln and nums[j] != nums[i]+1:\\n                    i += 1\\n                    j += 1\\n            res = max(res,j-i+1)\\n            j += 1\\n        return res\\n\\n            \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3745546,
                "title": "sliding-window-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int alternatingSubarray(int[] arr) {\\n        int m=arr.length;\\n        if(m<2){\\n            return -1;\\n        }\\n        int i=0;int j=0;int max=0;\\n        for( j=0;j<m;j++){\\n            if(i==j){\\n                if(j+1<m && arr[j+1]==arr[i]+1){\\n                    j++;\\n                    max=Math.max(max,j-i+1);\\n                }\\n            }\\n                    while(j<m&&i!=j){\\n                        if(arr[i]==arr[j]&&(i+j)%2==0){\\n                            max=Math.max(max,j-i+1);\\n                            j++;\\n                        }\\n                        else if(arr[i]+1==arr[j]&&arr[i+1]==arr[i]+1&&arr[j]-1==arr[j-1]){\\n                            max=Math.max(max,j-i+1);\\n                            j++;\\n                        }else{\\n                            i++;\\n                        }\\n                    }\\n                    \\n\\n\\n                }\\n                if(max==0){\\n                    return -1;\\n                }\\n                return max;\\n            \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int alternatingSubarray(int[] arr) {\\n        int m=arr.length;\\n        if(m<2){\\n            return -1;\\n        }\\n        int i=0;int j=0;int max=0;\\n        for( j=0;j<m;j++){\\n            if(i==j){\\n                if(j+1<m && arr[j+1]==arr[i]+1){\\n                    j++;\\n                    max=Math.max(max,j-i+1);\\n                }\\n            }\\n                    while(j<m&&i!=j){\\n                        if(arr[i]==arr[j]&&(i+j)%2==0){\\n                            max=Math.max(max,j-i+1);\\n                            j++;\\n                        }\\n                        else if(arr[i]+1==arr[j]&&arr[i+1]==arr[i]+1&&arr[j]-1==arr[j-1]){\\n                            max=Math.max(max,j-i+1);\\n                            j++;\\n                        }else{\\n                            i++;\\n                        }\\n                    }\\n                    \\n\\n\\n                }\\n                if(max==0){\\n                    return -1;\\n                }\\n                return max;\\n            \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3745202,
                "title": "intuitive-sliding-window",
                "content": "take two pointers l and r and with  \\nl=0;\\nr=1;\\ntake a variable t which can hold -1 and 1 only and we will add this number in previous to check the sequence validity and everytime we will flip the value\\n\\nhave a look on code :\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& a) \\n    {\\n        int l=0;\\n        int r=1;\\n        \\n        int ans=-1;        \\n        int n=a.size();\\n        int t=1;\\n        while(r<n)\\n        {\\n            if(a[r]==a[r-1]+t)\\n            {\\n              t*=-1;  // keep flipping\\n              ans=max(ans, r-l+1);\\n            }else // if sequece breaks;\\n            {\\n                if(a[r-1]+1==a[r])  // if new sequence just begin where previous one broke eg= 2,3,4,3,4\\n                {\\n                    t=-1;  // at first 4 we lost the previous sequence but a new one is formed so  addition part is already done 3+1=4 so\\n                          // begin with -1 bcz in next step needs subtraction\\n                    l=r-1; // start index of  next sequence\\n                    ans= max(ans, r-l+1);\\n                    \\n                }else\\n                {\\n                    t=1; // else  start a new sequence from r \\n                    l=r;\\n                }\\n            }\\n            \\n            r++;\\n           \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& a) \\n    {\\n        int l=0;\\n        int r=1;\\n        \\n        int ans=-1;        \\n        int n=a.size();\\n        int t=1;\\n        while(r<n)\\n        {\\n            if(a[r]==a[r-1]+t)\\n            {\\n              t*=-1;  // keep flipping\\n              ans=max(ans, r-l+1);\\n            }else // if sequece breaks;\\n            {\\n                if(a[r-1]+1==a[r])  // if new sequence just begin where previous one broke eg= 2,3,4,3,4\\n                {\\n                    t=-1;  // at first 4 we lost the previous sequence but a new one is formed so  addition part is already done 3+1=4 so\\n                          // begin with -1 bcz in next step needs subtraction\\n                    l=r-1; // start index of  next sequence\\n                    ans= max(ans, r-l+1);\\n                    \\n                }else\\n                {\\n                    t=1; // else  start a new sequence from r \\n                    l=r;\\n                }\\n            }\\n            \\n            r++;\\n           \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3745179,
                "title": "c-basic-and-simple-to-understand-concept",
                "content": "# Intuition\\nUsing basic traversing and using concept of maximum consecutive ones question.\\n\\n# Approach\\nYou can understand the approach by following steps:-\\nInside the loop, it checks if the current element (arr[i]) is equal to the previous element (arr[i-1]) plus either 1 or -1, depending on whether cnt is even or odd.\\n\\nIf the condition is satisfied, it means the current element is part of the alternating subarray. In that case, the cnt variable is incremented.\\n\\nIf the condition is not satisfied, it means the current element breaks the alternating pattern. Therefore, the cnt is reset to 0 and the code checks again if the current element satisfies the alternating condition.\\n\\nAfter each iteration, the code updates the ans variable with the maximum count (cnt + 1) encountered so far.\\n\\nFinally, the function returns ans if it is greater than 1 (indicating that there is at least one alternating subarray),\\n\\n# Complexity\\n- Time complexity:\\nWorst case O(n).\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& arr) {\\n        int n=arr.size();\\n        int ans=1;\\n        int cnt=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(arr[i]==arr[i-1]+(cnt%2==0?1:-1))\\n            {\\n                cnt++;\\n            }\\n            else\\n            {\\n                cnt=0;\\n                if(arr[i]==arr[i-1]+(cnt%2==0?1:-1))\\n                {\\n                    cnt++;\\n                }\\n            }\\n            ans=max(ans,cnt+1);\\n        }\\n        \\n        return ans==1?-1:ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& arr) {\\n        int n=arr.size();\\n        int ans=1;\\n        int cnt=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(arr[i]==arr[i-1]+(cnt%2==0?1:-1))\\n            {\\n                cnt++;\\n            }\\n            else\\n            {\\n                cnt=0;\\n                if(arr[i]==arr[i-1]+(cnt%2==0?1:-1))\\n                {\\n                    cnt++;\\n                }\\n            }\\n            ans=max(ans,cnt+1);\\n        }\\n        \\n        return ans==1?-1:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3745088,
                "title": "c-o-n-beats-100-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int n = (int)nums.size();\\n        int i = 0, j = 1;\\n        int ans = -1;\\n        int k = 1;\\n        while(j < n)\\n        {\\n            int cnt = 1;\\n            while(j < n && nums[j] - nums[j-1] == k)\\n            {\\n                k = -k;\\n                cnt++;\\n                j++;\\n            }\\n            if(cnt != 1)\\n            {\\n                k = 1;\\n                ans = max(ans,cnt);\\n            }\\n            else\\n                j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int n = (int)nums.size();\\n        int i = 0, j = 1;\\n        int ans = -1;\\n        int k = 1;\\n        while(j < n)\\n        {\\n            int cnt = 1;\\n            while(j < n && nums[j] - nums[j-1] == k)\\n            {\\n                k = -k;\\n                cnt++;\\n                j++;\\n            }\\n            if(cnt != 1)\\n            {\\n                k = 1;\\n                ans = max(ans,cnt);\\n            }\\n            else\\n                j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3744925,
                "title": "mmy-java-eassy-solution-for-easy-question",
                "content": "\\n```\\nclass Solution {\\n    int max=-1;\\n    void ch(int[]n,int i,int p,int f,int len){\\n        if(i==n.length){\\n            if(len>=2)\\n            max = Math.max(max,len);\\n            return ;\\n        }\\n        int ne= f==-1?1:-1;\\n            if(f==n[i]-p){\\n                ch(n,i+1,n[i],ne,len+1);\\n            }\\n            else{\\n                 if(len>=2)\\n                    max = Math.max(max,len);\\n                if(f==-1){               \\n                if(ne==n[i]-p)\\n                    ch(n,i+1,n[i],f,2);\\n               else ch(n,i+1,n[i],1,1);\\n                }                \\n                else ch(n,i+1,n[i],1,1);\\n            }\\n        return;\\n    }\\n    public int alternatingSubarray(int[] nums) {\\n        ch(nums,0,-4,1,1);\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int max=-1;\\n    void ch(int[]n,int i,int p,int f,int len){\\n        if(i==n.length){\\n            if(len>=2)\\n            max = Math.max(max,len);\\n            return ;\\n        }\\n        int ne= f==-1?1:-1;\\n            if(f==n[i]-p){\\n                ch(n,i+1,n[i],ne,len+1);\\n            }\\n            else{\\n                 if(len>=2)\\n                    max = Math.max(max,len);\\n                if(f==-1){               \\n                if(ne==n[i]-p)\\n                    ch(n,i+1,n[i],f,2);\\n               else ch(n,i+1,n[i],1,1);\\n                }                \\n                else ch(n,i+1,n[i],1,1);\\n            }\\n        return;\\n    }\\n    public int alternatingSubarray(int[] nums) {\\n        ch(nums,0,-4,1,1);\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3744832,
                "title": "simple-solution-on-java",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int alternatingSubarray(int[] a) {\\n        int n = a.length, max = Integer.MIN_VALUE;\\n        \\n\\n        boolean o = false;    \\n        int c = 1, count = 1;\\n        for (int i = 1; i < n; i++){\\n            int b = a[i] - a[i - 1];\\n\\n            if(b == 1 && !o)\\n                o = true;\\n\\n            if(b == c){\\n                count++;\\n                c = (c == 1 ? -1 : 1);\\n            }else{\\n                max = Math.max(max, count);\\n\\n                if(b != 1){\\n                    count = c = 1;\\n                }else if(b != -1){\\n                    count = 2;\\n                    c = -1;\\n                }\\n            }\\n        }\\n        \\n        max = Math.max(max, count);\\n        return !o ? -1 : max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int alternatingSubarray(int[] a) {\\n        int n = a.length, max = Integer.MIN_VALUE;\\n        \\n\\n        boolean o = false;    \\n        int c = 1, count = 1;\\n        for (int i = 1; i < n; i++){\\n            int b = a[i] - a[i - 1];\\n\\n            if(b == 1 && !o)\\n                o = true;\\n\\n            if(b == c){\\n                count++;\\n                c = (c == 1 ? -1 : 1);\\n            }else{\\n                max = Math.max(max, count);\\n\\n                if(b != 1){\\n                    count = c = 1;\\n                }else if(b != -1){\\n                    count = 2;\\n                    c = -1;\\n                }\\n            }\\n        }\\n        \\n        max = Math.max(max, count);\\n        return !o ? -1 : max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3744753,
                "title": "c-greedy-1-pass",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int maxLength = -1;\\n        int currentLength = 1;\\n        for (int i = 1; i < nums.size(); ++i) {\\n            if (nums[i] == nums[i-1] + (currentLength % 2 ? 1 : -1)) {\\n                maxLength = max(++currentLength, maxLength);\\n            } else {\\n                currentLength = nums[i-1] + 1 == nums[i] ? 2 : 1;\\n            }\\n        }\\n        return maxLength;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int maxLength = -1;\\n        int currentLength = 1;\\n        for (int i = 1; i < nums.size(); ++i) {\\n            if (nums[i] == nums[i-1] + (currentLength % 2 ? 1 : -1)) {\\n                maxLength = max(++currentLength, maxLength);\\n            } else {\\n                currentLength = nums[i-1] + 1 == nums[i] ? 2 : 1;\\n            }\\n        }\\n        return maxLength;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3744578,
                "title": "longest-alternating-subarray-solution",
                "content": "# Approach 1 - Brute Force\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem can be solved simply by examining every subarray. Check if a subarray is alternating by comparing each element to the conditions. Keep track of the longest alternating subarray length throughout.\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int alternatingSubarray(const vector<int>& nums) {\\n        int longest = -1;\\n        \\n        for (int i = 0; i < nums.size(); i++) {\\n            for (int j = 0; j < nums.size(); j++) {\\n                if (alternating(nums, i, j)) {\\n                    longest = max(longest, j-i+1);\\n                }\\n            }\\n        }\\n                    \\n        return longest;\\n    }\\n        \\n    bool alternating(const vector<int>& arr, const int& i, const int& j) {\\n        if (j - i + 1 <= 1) {\\n            return false;\\n        }\\n        \\n        for (int k = i; k <= j; k++) {\\n            if (arr[k] != arr[i] + (k - i)%2) {\\n                return false;\\n            }\\n        }\\n            \\n        return true;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int alternatingSubarray(int[] nums) {\\n        int longest = -1;\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = 0; j < nums.length; j++) {\\n                if (alternating(nums, i, j)) {\\n                    longest = Math.max(longest, j-i+1);\\n                }\\n            }\\n        }\\n                    \\n        return longest;\\n    }\\n        \\n    public boolean alternating(int[] arr, int i, int j) {\\n        if (j - i + 1 <= 1) {\\n            return false;\\n        }\\n        \\n        for (int k = i; k <= j; k++) {\\n            if (arr[k] != arr[i] + (k - i)%2) {\\n                return false;\\n            }\\n        }\\n            \\n        return true;\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def alternatingSubarray(self, nums: List[int]) -> int:\\n        longest = -1\\n        \\n        for i in range(len(nums)):\\n            for j in range(i, len(nums)):\\n                if self.alternating(nums, i, j):\\n                    longest = max(longest, j-i+1)\\n                    \\n        return longest\\n        \\n    def alternating(self, arr: List[int], i: int, j: int) -> bool:\\n        if j - i + 1 <= 1:\\n            return False\\n        \\n        for k in range(i, j+1):\\n            if arr[k] != arr[i] + (k - i)%2:\\n                return False\\n            \\n        return True\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n^3)$$\\n    - There are $$\\\\frac{(1+n)n}{2} = O(n^2)$$ subarrays\\n    - It takes $$O(n)$$ time to check if a subarray is alternating\\n    - Total time is $$O(n^2)*O(n) = O(n^3)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n    - The primitive variables take up constant space \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Approach 2 - Sliding Window\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe longest alternating subarray can be found by extending subarrays rightward as far as possible. Keep track of the current alternating subarray with pointers `i` and `j`. For alternating subarray `nums[i...j]`, the status of subarray `nums[i...j+1]` can be found by comparing `nums[j+1]` to `nums[i]` and `nums[i+1]`. If `nums[i...j+1]` is alternating, extend the current alternating subarray by updating `j` to `j+1`. If `nums[i...j+1]` is not alternating, begin a new subarray by setting `i` to `j` or `j-1`. \\n\\nBy extending subarrays as far right as possible and only shifting the left end when absolutely necessary, one finds the longest alternating subarray ending at each index.  With only endpoints needed to determine the status of new subarrays, this problem can be solved with a single pass.\\n\\n# Algorithm\\n\\n1. Create variables `longest` and `i`. Set `longest = -1` and `i = 0`.\\n2. For each `j` in range `1` to `nums.length`:\\n    - If `j mod 2 = i mod 2 AND nums[j] = nums[i]` OR `j mod 2 = (i+1) mod 2 AND nums[j] = nums[i] + 1`, subarray `nums[i...j]` is alternating. Update `longest = max(longest, j-i+1)`.\\n    - Otherwise `nums[i...j]` is not alternating and new subarray must be created. Set `i = j-1` if `nums[j-1] + 1 = nums[j]`. Otherwise set `i = j`.\\n3. Output `longest`\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int alternatingSubarray(const vector<int>& nums) {\\n        int longest = -1;\\n        int i = 0;\\n\\n        for (int j = 1; j < nums.size(); j++) {\\n            if (nums[j] == nums[i] + (j - i)%2) {\\n                longest = max(longest, j - i + 1);\\n            }\\n            else {\\n                const int shift = int(nums[j] - nums[j-1] == 1);\\n                i = j - shift;\\n            }\\n        }\\n                    \\n        return longest;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int alternatingSubarray(int[] nums) {\\n        int longest = -1;\\n        int i = 0;\\n\\n        for (int j = 1; j < nums.length; j++) {\\n            if (nums[j] == nums[i] + (j - i)%2) {\\n                longest = Math.max(longest, j - i + 1);\\n            }\\n            else {\\n                final int shift = (nums[j] - nums[j-1] == 1) ? 1 : 0;\\n                i = j - shift;\\n            }\\n        }\\n                    \\n        return longest;\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def alternatingSubarray(self, nums: List[int]) -> int:\\n        longest = -1\\n        i = 0\\n\\n        for j in range(1, len(nums)):\\n            if nums[j] == nums[i] + (j - i)%2:\\n                longest = max(longest, j - i + 1)\\n            else:\\n                shift = int(nums[j] - nums[j-1] == 1)\\n                i = j - shift\\n                    \\n        return longest\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n    - It takes $$O(n)$$ time to iterate over all $$n$$ elements of `nums`\\n    - The steps inside the loop occur in constant time\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n    - The primitive variables take up constant space \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int alternatingSubarray(const vector<int>& nums) {\\n        int longest = -1;\\n        \\n        for (int i = 0; i < nums.size(); i++) {\\n            for (int j = 0; j < nums.size(); j++) {\\n                if (alternating(nums, i, j)) {\\n                    longest = max(longest, j-i+1);\\n                }\\n            }\\n        }\\n                    \\n        return longest;\\n    }\\n        \\n    bool alternating(const vector<int>& arr, const int& i, const int& j) {\\n        if (j - i + 1 <= 1) {\\n            return false;\\n        }\\n        \\n        for (int k = i; k <= j; k++) {\\n            if (arr[k] != arr[i] + (k - i)%2) {\\n                return false;\\n            }\\n        }\\n            \\n        return true;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int alternatingSubarray(int[] nums) {\\n        int longest = -1;\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = 0; j < nums.length; j++) {\\n                if (alternating(nums, i, j)) {\\n                    longest = Math.max(longest, j-i+1);\\n                }\\n            }\\n        }\\n                    \\n        return longest;\\n    }\\n        \\n    public boolean alternating(int[] arr, int i, int j) {\\n        if (j - i + 1 <= 1) {\\n            return false;\\n        }\\n        \\n        for (int k = i; k <= j; k++) {\\n            if (arr[k] != arr[i] + (k - i)%2) {\\n                return false;\\n            }\\n        }\\n            \\n        return true;\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def alternatingSubarray(self, nums: List[int]) -> int:\\n        longest = -1\\n        \\n        for i in range(len(nums)):\\n            for j in range(i, len(nums)):\\n                if self.alternating(nums, i, j):\\n                    longest = max(longest, j-i+1)\\n                    \\n        return longest\\n        \\n    def alternating(self, arr: List[int], i: int, j: int) -> bool:\\n        if j - i + 1 <= 1:\\n            return False\\n        \\n        for k in range(i, j+1):\\n            if arr[k] != arr[i] + (k - i)%2:\\n                return False\\n            \\n        return True\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int alternatingSubarray(const vector<int>& nums) {\\n        int longest = -1;\\n        int i = 0;\\n\\n        for (int j = 1; j < nums.size(); j++) {\\n            if (nums[j] == nums[i] + (j - i)%2) {\\n                longest = max(longest, j - i + 1);\\n            }\\n            else {\\n                const int shift = int(nums[j] - nums[j-1] == 1);\\n                i = j - shift;\\n            }\\n        }\\n                    \\n        return longest;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int alternatingSubarray(int[] nums) {\\n        int longest = -1;\\n        int i = 0;\\n\\n        for (int j = 1; j < nums.length; j++) {\\n            if (nums[j] == nums[i] + (j - i)%2) {\\n                longest = Math.max(longest, j - i + 1);\\n            }\\n            else {\\n                final int shift = (nums[j] - nums[j-1] == 1) ? 1 : 0;\\n                i = j - shift;\\n            }\\n        }\\n                    \\n        return longest;\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def alternatingSubarray(self, nums: List[int]) -> int:\\n        longest = -1\\n        i = 0\\n\\n        for j in range(1, len(nums)):\\n            if nums[j] == nums[i] + (j - i)%2:\\n                longest = max(longest, j - i + 1)\\n            else:\\n                shift = int(nums[j] - nums[j-1] == 1)\\n                i = j - shift\\n                    \\n        return longest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3744167,
                "title": "c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n          int count = 0,maxi =-1e9;\\n    for(int i=0;i<nums.size()-1;i++){\\n        bool flag =1;\\n        count=1;\\n        for(int j=i;j<nums.size()-1;j++){\\n            if(flag and nums[j]-nums[j+1]  == -1) {\\n                count++;\\n                flag = 0;\\n            }\\n            else if(!flag && nums[j]- nums[j+1]==1){\\n                count++;\\n                flag = 1;\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        maxi = max(count ,maxi);\\n    }\\n        if(maxi ==1) return -1;\\nreturn maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n          int count = 0,maxi =-1e9;\\n    for(int i=0;i<nums.size()-1;i++){\\n        bool flag =1;\\n        count=1;\\n        for(int j=i;j<nums.size()-1;j++){\\n            if(flag and nums[j]-nums[j+1]  == -1) {\\n                count++;\\n                flag = 0;\\n            }\\n            else if(!flag && nums[j]- nums[j+1]==1){\\n                count++;\\n                flag = 1;\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        maxi = max(count ,maxi);\\n    }\\n        if(maxi ==1) return -1;\\nreturn maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3744061,
                "title": "c-best-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int ct = 0;\\n        int n = nums.size();\\n        if(n==1) return -1;\\n        for(int i = 0; i < n-1; i++)\\n        {\\n            int ct1 = 0;\\n            if(nums[i+1]-nums[i]==1)\\n            {\\n                ct1+=2;\\n                int tp = 0;\\n                for(int j = i+2; j < n; j++)\\n                {\\n                    if(tp%2==0)\\n                    {\\n                        if(nums[j]-nums[j-1]==-1)\\n                        {\\n                            ct1++;\\n                        }\\n                        else\\n                        {\\n                            break;\\n                        }\\n                    }\\n                    else\\n                    {\\n                        if(nums[j]-nums[j-1]==1)\\n                        {\\n                            ct1++;\\n                        }\\n                        else\\n                        {\\n                            break;\\n                        }\\n                    }\\n                    tp++;\\n                }\\n                ct = max(ct, ct1);\\n            }\\n            \\n        }\\n        return ct<=1 ? -1 : ct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int ct = 0;\\n        int n = nums.size();\\n        if(n==1) return -1;\\n        for(int i = 0; i < n-1; i++)\\n        {\\n            int ct1 = 0;\\n            if(nums[i+1]-nums[i]==1)\\n            {\\n                ct1+=2;\\n                int tp = 0;\\n                for(int j = i+2; j < n; j++)\\n                {\\n                    if(tp%2==0)\\n                    {\\n                        if(nums[j]-nums[j-1]==-1)\\n                        {\\n                            ct1++;\\n                        }\\n                        else\\n                        {\\n                            break;\\n                        }\\n                    }\\n                    else\\n                    {\\n                        if(nums[j]-nums[j-1]==1)\\n                        {\\n                            ct1++;\\n                        }\\n                        else\\n                        {\\n                            break;\\n                        }\\n                    }\\n                    tp++;\\n                }\\n                ct = max(ct, ct1);\\n            }\\n            \\n        }\\n        return ct<=1 ? -1 : ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3743931,
                "title": "swift-simple-coding-solution-two-pointers",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    func alternatingSubarray(_ nums: [Int]) -> Int {\\n        var start = 0\\n        var end = 1\\n        var maxCount = 0\\n         var index = 1 // 1 = positive diff, -1 = negative diff\\n         // index alterates with each num in subarray.\\n         \\n        while end < nums.count {\\n            let difference = nums[end] - nums[end-1]\\n            if difference == index {\\n                    end += 1\\n                    index = -index\\n            } else {\\n                    maxCount = max(end-start-1, maxCount)\\n                    start += 1\\n                    end = start + 1\\n                    index = 1\\n            }\\n        }\\n        maxCount = max(end-start-1, maxCount)\\n\\n        return maxCount == 0 ? -1 : maxCount+1\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func alternatingSubarray(_ nums: [Int]) -> Int {\\n        var start = 0\\n        var end = 1\\n        var maxCount = 0\\n         var index = 1 // 1 = positive diff, -1 = negative diff\\n         // index alterates with each num in subarray.\\n         \\n        while end < nums.count {\\n            let difference = nums[end] - nums[end-1]\\n            if difference == index {\\n                    end += 1\\n                    index = -index\\n            } else {\\n                    maxCount = max(end-start-1, maxCount)\\n                    start += 1\\n                    end = start + 1\\n                    index = 1\\n            }\\n        }\\n        maxCount = max(end-start-1, maxCount)\\n\\n        return maxCount == 0 ? -1 : maxCount+1\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3743726,
                "title": "python-o-n-time-o-1-space-easy-to-understand",
                "content": "# Intuition\\nAs we iterate through the array, each new element can be either: \\n1. Not part of an alternating subarray\\n2. The start of a new alternating subarray\\n3. The continuation of an existing alternating subarray\\n\\n# Approach\\nUse a flag to determine if we are already in an alternating subarray.  If we are already in an alternating subarray, then determine if the new element extends or ends it.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def alternatingSubarray(self, nums: List[int]) -> int:\\n        res = -1\\n        curr_len = 0\\n        is_alternating = False\\n        \\n        for i in range(1, len(nums)):\\n            if is_alternating:\\n                if nums[i] == nums[i-2]: # new element continues subarray\\n                    curr_len += 1\\n                else: # new element ends subarray\\n                    is_alternating = False\\n            if not is_alternating and nums[i] == nums[i-1] + 1: #start new alternating subarray\\n                is_alternating = True\\n                curr_len = 2\\n            res = max(res, curr_len)\\n        \\n        return res if curr_len > 0 else -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def alternatingSubarray(self, nums: List[int]) -> int:\\n        res = -1\\n        curr_len = 0\\n        is_alternating = False\\n        \\n        for i in range(1, len(nums)):\\n            if is_alternating:\\n                if nums[i] == nums[i-2]: # new element continues subarray\\n                    curr_len += 1\\n                else: # new element ends subarray\\n                    is_alternating = False\\n            if not is_alternating and nums[i] == nums[i-1] + 1: #start new alternating subarray\\n                is_alternating = True\\n                curr_len = 2\\n            res = max(res, curr_len)\\n        \\n        return res if curr_len > 0 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3743329,
                "title": "sliding-window-approach-in-c-with-o-n-tc-and-o-1-sc",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int index=0,ans=INT_MIN;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i] - nums[i-1] == 1)\\n            {\\n                ans=max(ans,i-index+1);\\n                if(i==nums.size()-1) break;\\n                if(nums[i-1]!=nums[i+1]) index=i; \\n                else\\n                {\\n                    ans=max(ans,i-index+2);\\n                    i++;\\n                }     \\n            }\\n            else index=i;\\n        }\\n        return ans==INT_MIN ? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int index=0,ans=INT_MIN;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i] - nums[i-1] == 1)\\n            {\\n                ans=max(ans,i-index+1);\\n                if(i==nums.size()-1) break;\\n                if(nums[i-1]!=nums[i+1]) index=i; \\n                else\\n                {\\n                    ans=max(ans,i-index+2);\\n                    i++;\\n                }     \\n            }\\n            else index=i;\\n        }\\n        return ans==INT_MIN ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3743062,
                "title": "c-cases",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int l = 0;\\n        int best = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            if(l == 0){\\n                l++;\\n            }\\n            else if((l % 2) == 1){\\n                if(nums[i] == (nums[i-1] + 1))\\n                    l++;\\n                else l = 1;\\n            }\\n            else{\\n                if(nums[i] == (nums[i-1] - 1))\\n                    l++;\\n                else{\\n                    if(nums[i] == (nums[i-1] + 1)) l = 2;\\n                    else l = 1;\\n                }\\n            }\\n            best = max(l, best);\\n        }\\n        return (best == 1) ? -1 : best;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int l = 0;\\n        int best = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            if(l == 0){\\n                l++;\\n            }\\n            else if((l % 2) == 1){\\n                if(nums[i] == (nums[i-1] + 1))\\n                    l++;\\n                else l = 1;\\n            }\\n            else{\\n                if(nums[i] == (nums[i-1] - 1))\\n                    l++;\\n                else{\\n                    if(nums[i] == (nums[i-1] + 1)) l = 2;\\n                    else l = 1;\\n                }\\n            }\\n            best = max(l, best);\\n        }\\n        return (best == 1) ? -1 : best;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3742939,
                "title": "java-no-nested-loop-3ms-beated-100-o-n-easy-to-understand",
                "content": "# Intuition\\nUse a for loop to check every one and the previous one\\n\\n# Approach\\nMake a boolean as a switch(boolean bool),\\nrun a for loop from the second(index 1) integer , \\nif the switch is default , and the integer is greater than the last one , count it and compare to the max, else if the switch is set , than check if the existing integer is smaller then the last one to count and compare.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int alternatingSubarray(int[] nums) {\\n        int ans = 1;\\n        int res = 0;\\n        boolean bool = false;\\n        for(int i = 1 ; i < nums.length ; i++){\\n            if(!bool &&nums[i] == nums[i-1]+1){\\n                bool = true;\\n                ans++;\\n                res = Math.max(ans,res);\\n                continue;\\n            }\\n            if(bool && nums[i] == nums[i-1]-1){\\n                bool = false;\\n                ans++;\\n                res = Math.max(ans,res);\\n                continue;\\n            }\\n            if(bool && nums[i] == nums[i-1]+1){\\n                bool = true;\\n                ans = 2;\\n                res = Math.max(ans,res);\\n                continue;\\n            }\\n            ans = 1 ;\\n            bool = false;\\n        }\\n\\n        return res > 0 ? res : -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int alternatingSubarray(int[] nums) {\\n        int ans = 1;\\n        int res = 0;\\n        boolean bool = false;\\n        for(int i = 1 ; i < nums.length ; i++){\\n            if(!bool &&nums[i] == nums[i-1]+1){\\n                bool = true;\\n                ans++;\\n                res = Math.max(ans,res);\\n                continue;\\n            }\\n            if(bool && nums[i] == nums[i-1]-1){\\n                bool = false;\\n                ans++;\\n                res = Math.max(ans,res);\\n                continue;\\n            }\\n            if(bool && nums[i] == nums[i-1]+1){\\n                bool = true;\\n                ans = 2;\\n                res = Math.max(ans,res);\\n                continue;\\n            }\\n            ans = 1 ;\\n            bool = false;\\n        }\\n\\n        return res > 0 ? res : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3742521,
                "title": "c-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int AlternatingSubarray(int[] nums) {\\n        int start = 0; int end = 1;\\n        int k = 1;\\n        int currentMax = 1; int overallMax = 1;\\n\\n        while(end < nums.Length){\\n            if(nums[end] - nums[end-1] == k){\\n                end++;\\n                k = -k;\\n                currentMax++;\\n            }else{\\n                start++;\\n                end = start+1;\\n                k = 1;\\n                currentMax = 1;\\n            }\\n            overallMax = Math.Max(currentMax, overallMax);\\n        }\\n\\n        return overallMax == 1 ? -1 : overallMax; \\n    \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int AlternatingSubarray(int[] nums) {\\n        int start = 0; int end = 1;\\n        int k = 1;\\n        int currentMax = 1; int overallMax = 1;\\n\\n        while(end < nums.Length){\\n            if(nums[end] - nums[end-1] == k){\\n                end++;\\n                k = -k;\\n                currentMax++;\\n            }else{\\n                start++;\\n                end = start+1;\\n                k = 1;\\n                currentMax = 1;\\n            }\\n            overallMax = Math.Max(currentMax, overallMax);\\n        }\\n\\n        return overallMax == 1 ? -1 : overallMax; \\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3742400,
                "title": "easy-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int alternatingSubarray(int[] nums) {\\n        int i = 1;\\n        while(i < nums.length && nums[i] - nums[i - 1] != 1)\\n        i++;\\n        if(i == nums.length)\\n        return -1;\\n        int diff = nums[i] - nums[i - 1];\\n        i++;\\n        int len = 2;\\n        int maxLen = 2;\\n        while(i < nums.length)\\n        {\\n            if(nums[i] - nums[i - 1] == diff * -1)\\n            {\\n                len++;\\n                diff *= -1;            \\n            }\\n            else\\n            {\\n                while(i < nums.length && nums[i] - nums[i - 1] != 1)\\n                i++;\\n                if(i == nums.length)\\n                {\\n                    maxLen = Math.max(maxLen, len);\\n                    return maxLen;\\n                }\\n                diff = nums[i] - nums[i-1];\\n                len = 2;\\n            }\\n            i++;\\n            maxLen = Math.max(maxLen, len);\\n        }\\n        return maxLen;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int alternatingSubarray(int[] nums) {\\n        int i = 1;\\n        while(i < nums.length && nums[i] - nums[i - 1] != 1)\\n        i++;\\n        if(i == nums.length)\\n        return -1;\\n        int diff = nums[i] - nums[i - 1];\\n        i++;\\n        int len = 2;\\n        int maxLen = 2;\\n        while(i < nums.length)\\n        {\\n            if(nums[i] - nums[i - 1] == diff * -1)\\n            {\\n                len++;\\n                diff *= -1;            \\n            }\\n            else\\n            {\\n                while(i < nums.length && nums[i] - nums[i - 1] != 1)\\n                i++;\\n                if(i == nums.length)\\n                {\\n                    maxLen = Math.max(maxLen, len);\\n                    return maxLen;\\n                }\\n                diff = nums[i] - nums[i-1];\\n                len = 2;\\n            }\\n            i++;\\n            maxLen = Math.max(maxLen, len);\\n        }\\n        return maxLen;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3742125,
                "title": "c-unique-solution-using-two-stacks",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem can be solved by using two stacks simultaneously.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n![image.png](https://assets.leetcode.com/users/images/a689d99a-a8d8-4467-a09c-66b26ce50db1_1688925125.9023488.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        stack <int> a, b;\\n        int ans = -1;\\n        for(int i = 0; i < nums.size(); i++){\\n            if(a.empty() and b.empty()){\\n                a.push(nums[i]);\\n            }\\n            else if(!a.empty() and b.empty()){\\n                if(nums[i] - a.top() == 1){\\n                    b.push(nums[i]);\\n                    int val = a.size() + b.size();\\n                    ans = max(ans, val);\\n                }\\n                else{\\n                    a = stack<int>();\\n                    a.push(nums[i]);\\n                }\\n            }\\n            else if(a.size() == b.size() and nums[i] == a.top()){\\n                a.push(nums[i]);\\n                int val = a.size() + b.size();\\n                ans = max(ans, val);\\n            }\\n            else if(a.size() - b.size() == 1 and nums[i] == b.top()){\\n                b.push(nums[i]);\\n                int val = a.size() + b.size();\\n                ans = max(ans, val);\\n            }\\n            else{\\n                a = stack<int>();\\n                b = stack<int>();\\n                i -= 2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        stack <int> a, b;\\n        int ans = -1;\\n        for(int i = 0; i < nums.size(); i++){\\n            if(a.empty() and b.empty()){\\n                a.push(nums[i]);\\n            }\\n            else if(!a.empty() and b.empty()){\\n                if(nums[i] - a.top() == 1){\\n                    b.push(nums[i]);\\n                    int val = a.size() + b.size();\\n                    ans = max(ans, val);\\n                }\\n                else{\\n                    a = stack<int>();\\n                    a.push(nums[i]);\\n                }\\n            }\\n            else if(a.size() == b.size() and nums[i] == a.top()){\\n                a.push(nums[i]);\\n                int val = a.size() + b.size();\\n                ans = max(ans, val);\\n            }\\n            else if(a.size() - b.size() == 1 and nums[i] == b.top()){\\n                b.push(nums[i]);\\n                int val = a.size() + b.size();\\n                ans = max(ans, val);\\n            }\\n            else{\\n                a = stack<int>();\\n                b = stack<int>();\\n                i -= 2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3742024,
                "title": "optimized-solution-beats-100-java",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int alternatingSubarray(int[] nums) {\\n        int max = Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length-1;i++){\\n            int temp=0;\\n            int count =1;\\n            for(int j=i;j<nums.length-1;j++){\\n                if(temp%2==0 && nums[j]-nums[j+1]==-1)\\n                    count++;\\n                else if(temp%2==1 && nums[j]-nums[j+1]==1)\\n                    count++;\\n                else\\n                    break;\\n                temp++;\\n            }\\n            max = Math.max(max,count);\\n        }\\n        return max<2?-1:max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int alternatingSubarray(int[] nums) {\\n        int max = Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length-1;i++){\\n            int temp=0;\\n            int count =1;\\n            for(int j=i;j<nums.length-1;j++){\\n                if(temp%2==0 && nums[j]-nums[j+1]==-1)\\n                    count++;\\n                else if(temp%2==1 && nums[j]-nums[j+1]==1)\\n                    count++;\\n                else\\n                    break;\\n                temp++;\\n            }\\n            max = Math.max(max,count);\\n        }\\n        return max<2?-1:max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741801,
                "title": "solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def alternatingSubarray(self, nums: List[int]) -> int:\\n        ret = -1\\n        for left in range(len(nums)-1):\\n            if nums[left+1]-nums[left] != 1: continue\\n            pat = [nums[left], nums[left+1]]\\n            right = left+2\\n            while right < len(nums):\\n                if nums[right] != pat[(right-left)%2]:\\n                    break\\n                right += 1\\n            ret = max(ret, right-left)\\n        return ret\\n                \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def alternatingSubarray(self, nums: List[int]) -> int:\\n        ret = -1\\n        for left in range(len(nums)-1):\\n            if nums[left+1]-nums[left] != 1: continue\\n            pat = [nums[left], nums[left+1]]\\n            right = left+2\\n            while right < len(nums):\\n                if nums[right] != pat[(right-left)%2]:\\n                    break\\n                right += 1\\n            ret = max(ret, right-left)\\n        return ret\\n                \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741680,
                "title": "begginer-c-solutions",
                "content": "class Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int ans=-1;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            int temp=nums[i];\\n            int cnt=1;\\n            int flag1=0;\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(i%2==0)\\n                {\\n               if(j%2==1 && nums[j]==temp+1)\\n               {\\n                   cnt++;\\n               }\\n               else if(j%2==0 && nums[j]==temp)\\n               {\\n                   cnt++;\\n               }\\n                else\\n                {\\n                    break;\\n                }\\n                }\\n                \\n                if(i%2==1)\\n                {\\n               if(j%2==0 && nums[j]==temp+1)\\n               {\\n                   cnt++;\\n               }\\n               else if(j%2==1 && nums[j]==temp)\\n               {\\n                   cnt++;\\n               }\\n                else\\n                {\\n                    break;\\n                }\\n                }\\n                \\n            }\\n           ans= max(ans,cnt);\\n        }\\n        if(ans==1)\\n        {\\n            return -1;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int ans=-1;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            int temp=nums[i];\\n            int cnt=1;\\n            int flag1=0;\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                if(i%2==0)\\n                {\\n               if(j%2==1 && nums[j]==temp+1)\\n               {\\n                   cnt++;\\n               }",
                "codeTag": "Java"
            },
            {
                "id": 3741669,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def alternatingSubarray(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        mx=-1\\n        for i in range(len(nums)):\\n            for j in range(len(nums)+1):\\n                lst=nums[i:j]\\n                if len(lst)>=2 and self.check(lst):\\n                    mx=max(mx,len(lst))\\n        return mx\\n    def check(self,nums):\\n        a,b=nums[0],nums[1]\\n        if b!=a+1:\\n            return False\\n        for i in range(len(nums)):\\n            if (i%2==0 and nums[i]!=a) or (i%2==1 and nums[i]!=b):\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def alternatingSubarray(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        mx=-1\\n        for i in range(len(nums)):\\n            for j in range(len(nums)+1):\\n                lst=nums[i:j]\\n                if len(lst)>=2 and self.check(lst):\\n                    mx=max(mx,len(lst))\\n        return mx\\n    def check(self,nums):\\n        a,b=nums[0],nums[1]\\n        if b!=a+1:\\n            return False\\n        for i in range(len(nums)):\\n            if (i%2==0 and nums[i]!=a) or (i%2==1 and nums[i]!=b):\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741541,
                "title": "py-o-n-time-o-n-space-grouping-algo",
                "content": "![image](https://assets.leetcode.com/users/images/62ffca74-631c-4f0e-b2df-5387735b5c8f_1688916110.09686.png)\\n\\n\\n\\tdef alternatingSubarray(self, nums: List[int]) -> int:\\n        \"\"\" O(N)TS \"\"\"\\n        i, ans = 0, 0\\n\\n        for j in range(len(nums) + 1):\\n            if j >= len(nums) or nums[j] != nums[i] + (j - i)%2:\\n                ans = max(ans, j - i)\\n                if j < len(nums):\\n                    i = j - (nums[j - 1] == nums[j] - 1)\\n\\n        return ans if ans != 1 else -1\\n\\n\\n\\n    def alternatingSubarray(self, nums: List[int]) -> int:\\n        \"\"\" O(N)TS \"\"\"\\n        i, ans = 0, 0\\n\\n        for j in range(len(nums)):\\n            if nums[j] != nums[i] + (j - i)%2:\\n                i = j - (nums[j - 1] == nums[j] - 1)\\n            ans = max(ans, j - i + 1)\\n\\n        return ans if ans != 1 else -1",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/62ffca74-631c-4f0e-b2df-5387735b5c8f_1688916110.09686.png)\\n\\n\\n\\tdef alternatingSubarray(self, nums: List[int]) -> int:\\n        \"\"\" O(N)TS \"\"\"\\n        i, ans = 0, 0\\n\\n        for j in range(len(nums) + 1):\\n            if j >= len(nums) or nums[j] != nums[i] + (j - i)%2:\\n                ans = max(ans, j - i)\\n                if j < len(nums):\\n                    i = j - (nums[j - 1] == nums[j] - 1)\\n\\n        return ans if ans != 1 else -1\\n\\n\\n\\n    def alternatingSubarray(self, nums: List[int]) -> int:\\n        \"\"\" O(N)TS \"\"\"\\n        i, ans = 0, 0\\n\\n        for j in range(len(nums)):\\n            if nums[j] != nums[i] + (j - i)%2:\\n                i = j - (nums[j - 1] == nums[j] - 1)\\n            ans = max(ans, j - i + 1)\\n\\n        return ans if ans != 1 else -1",
                "codeTag": "Python3"
            },
            {
                "id": 3741466,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int alternatingSubarray(int[] nums) {\\n            int ans=-1;\\n        for(int i=0;i<nums.length-1;i++){\\n            int df=1;\\n        \\n            for(int j=i+1;j<nums.length;j++){\\n                if(nums[j]-nums[j-1]==df){\\n                    df=-df;\\n                    ans=Math.max(ans,j-i+1);\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int alternatingSubarray(int[] nums) {\\n            int ans=-1;\\n        for(int i=0;i<nums.length-1;i++){\\n            int df=1;\\n        \\n            for(int j=i+1;j<nums.length;j++){\\n                if(nums[j]-nums[j-1]==df){\\n                    df=-df;\\n                    ans=Math.max(ans,j-i+1);\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741425,
                "title": "two-steps-simple-c-soln-sliding-window-beginner-approach",
                "content": "# Intuition\\nStarting from the i=1 index till n-1 and simultaneously checking for alternating difference`(nums[i]-nums[i-1])*(nums[i+1]-nums[i])==-1)`this will give -1 only when `(1 * -1)` are consecutive differences.\\nInitialising c=0 and for a difference(encountering 1 for the first time) c=2 (length of subarray) and then increasing c++ for rest elements.\\n\\nHere is my solution. Hope it helps!!\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int alternatingSubarray(vector<int>& nums) {\\n    int maxi=0;\\n    int n=nums.size();\\n       \\n    int c=0;\\n    for(int i=1;i<n;i++){\\n        if(nums[i]-nums[i-1]==1){\\n         c=2;\\n         while(i<n-1 && (nums[i]-nums[i-1])*(nums[i+1]-nums[i])==-1){\\n            c++;\\n            i++;\\n         }\\n        }\\n        maxi=max(c,maxi);    \\n    }\\n    if(maxi==0) return -1;\\n    else return maxi;   \\n    }  \\n};\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n   int alternatingSubarray(vector<int>& nums) {\\n    int maxi=0;\\n    int n=nums.size();\\n       \\n    int c=0;\\n    for(int i=1;i<n;i++){\\n        if(nums[i]-nums[i-1]==1){\\n         c=2;\\n         while(i<n-1 && (nums[i]-nums[i-1])*(nums[i+1]-nums[i])==-1){\\n            c++;\\n            i++;\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 3741325,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int AlternatingSubarray(int[] nums) {\\n        int max =0;\\n        int n = nums.Length;\\n        \\n        int i=0;\\n        while(i<n){\\n            int j= i+1;\\n            bool found=false;\\n            int op=1;\\n            while(j < n){\\n                if(nums[j] == nums[j-1] + op){\\n                    //Console.WriteLine(nums[j-1] + \" \" + nums[j]);\\n                    found = true;\\n                    op=-op;\\n                }\\n                else{\\n                    if(found){\\n                        //Console.WriteLine(j-i);\\n                        max = Math.Max(max,j-i);\\n                        found=false;\\n                    }\\n                    break;\\n                }\\n                j++;\\n            }\\n            \\n            if(found)\\n            {\\n                //Console.WriteLine(j-i);\\n                max = Math.Max(max,j-i);\\n            }\\n            \\n            i++;\\n        }\\n        \\n        return max == 0 ? -1 : max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int AlternatingSubarray(int[] nums) {\\n        int max =0;\\n        int n = nums.Length;\\n        \\n        int i=0;\\n        while(i<n){\\n            int j= i+1;\\n            bool found=false;\\n            int op=1;\\n            while(j < n){\\n                if(nums[j] == nums[j-1] + op){\\n                    //Console.WriteLine(nums[j-1] + \" \" + nums[j]);\\n                    found = true;\\n                    op=-op;\\n                }\\n                else{\\n                    if(found){\\n                        //Console.WriteLine(j-i);\\n                        max = Math.Max(max,j-i);\\n                        found=false;\\n                    }\\n                    break;\\n                }\\n                j++;\\n            }\\n            \\n            if(found)\\n            {\\n                //Console.WriteLine(j-i);\\n                max = Math.Max(max,j-i);\\n            }\\n            \\n            i++;\\n        }\\n        \\n        return max == 0 ? -1 : max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741182,
                "title": "o-n-solution-100-faster-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=-1;\\n        int m,j;\\n       for(int i=0;i<n-1;i++)\\n       {\\n           j=i+1;\\n           if(nums[j]-nums[i]==1)\\n           {\\n               m=2;\\n               while(j<n and nums[j]-nums[j-1]==pow(-1,m))\\n               {\\n                   j++;\\n                   m++;\\n               }\\n               ans=max(ans,j-i);\\n               i=j-2;\\n           }\\n       } \\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=-1;\\n        int m,j;\\n       for(int i=0;i<n-1;i++)\\n       {\\n           j=i+1;\\n           if(nums[j]-nums[i]==1)\\n           {\\n               m=2;\\n               while(j<n and nums[j]-nums[j-1]==pow(-1,m))\\n               {\\n                   j++;\\n                   m++;\\n               }\\n               ans=max(ans,j-i);\\n               i=j-2;\\n           }\\n       } \\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741093,
                "title": "o-n-time-o-1-space-java-linear-time-solution-with-constant-o-1-space",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRead the array from backside. There are 3 base conditions:\\n```\\n1. preMinusOne == -1 && currentMinusOne != preMinusOne && currentMinusOne == \\n            || (preMinusOne == 0 && currentMinusOne == 1)\\n2. reMinusOne == 0 && currentMinusOne == -1\\n3. preMinusOne == currentMinusOne\\n        When the forward and the backward diffrence is same, reset the current alternating sequence, but the max length will not be considered in this situation. \\n```\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int alternatingSubarray(int[] nums) {\\n    int preMinusOne = 0, currentMinusOne = 0, currentAltSeqLength = 0, max = -1;\\n    for (int i = nums.length - 2; i >= 0; i--)\\n      if (Math.abs(nums[i + 1] - nums[i]) == 1) {\\n        currentMinusOne = nums[i + 1] - nums[i];\\n        if (preMinusOne == -1 && currentMinusOne != preMinusOne && currentMinusOne == 1\\n            || (preMinusOne == 0 && currentMinusOne == 1)) {\\n          currentAltSeqLength += 2;\\n          max = Math.max(max, currentAltSeqLength);\\n        } \\n        else if (preMinusOne == 0 && currentMinusOne == -1)\\n          currentAltSeqLength += 1;\\n        else if (preMinusOne == currentMinusOne)\\n          currentAltSeqLength = currentMinusOne == 1 ? 2 : 0;\\n\\n        preMinusOne = currentMinusOne;\\n      } \\n      else\\n        currentAltSeqLength = preMinusOne = 0;\\n    return max;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n1. preMinusOne == -1 && currentMinusOne != preMinusOne && currentMinusOne == \\n            || (preMinusOne == 0 && currentMinusOne == 1)\\n2. reMinusOne == 0 && currentMinusOne == -1\\n3. preMinusOne == currentMinusOne\\n        When the forward and the backward diffrence is same, reset the current alternating sequence, but the max length will not be considered in this situation. \\n```\n```\\nclass Solution {\\n  public int alternatingSubarray(int[] nums) {\\n    int preMinusOne = 0, currentMinusOne = 0, currentAltSeqLength = 0, max = -1;\\n    for (int i = nums.length - 2; i >= 0; i--)\\n      if (Math.abs(nums[i + 1] - nums[i]) == 1) {\\n        currentMinusOne = nums[i + 1] - nums[i];\\n        if (preMinusOne == -1 && currentMinusOne != preMinusOne && currentMinusOne == 1\\n            || (preMinusOne == 0 && currentMinusOne == 1)) {\\n          currentAltSeqLength += 2;\\n          max = Math.max(max, currentAltSeqLength);\\n        } \\n        else if (preMinusOne == 0 && currentMinusOne == -1)\\n          currentAltSeqLength += 1;\\n        else if (preMinusOne == currentMinusOne)\\n          currentAltSeqLength = currentMinusOne == 1 ? 2 : 0;\\n\\n        preMinusOne = currentMinusOne;\\n      } \\n      else\\n        currentAltSeqLength = preMinusOne = 0;\\n    return max;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741009,
                "title": "c-o-n-simple-and-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int mx=0;\\n        int k=1;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i+1]==nums[i]+1&&k%2)\\n                k++;\\n            else if(nums[i+1]==nums[i]-1&&k%2==0)\\n                k++;\\n            else{\\n                if(nums[i+1]==nums[i]+1)\\n                    k=2;\\n                else\\n                    k=1;\\n            }\\n            mx=max(mx,k);\\n        }\\n        if(mx==1) \\n            return -1;\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int mx=0;\\n        int k=1;\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i+1]==nums[i]+1&&k%2)\\n                k++;\\n            else if(nums[i+1]==nums[i]-1&&k%2==0)\\n                k++;\\n            else{\\n                if(nums[i+1]==nums[i]+1)\\n                    k=2;\\n                else\\n                    k=1;\\n            }\\n            mx=max(mx,k);\\n        }\\n        if(mx==1) \\n            return -1;\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740954,
                "title": "c-two-pointers-solution-with-a-single-pointer",
                "content": "# Intuition\\nThe sequence starts with an increase by 1.\\nEvery second element is the same in a correct sequence.\\nThe possible overlap between 2 good sequences is just 1 element.\\n\\n# Approach\\nLet\\'s find the start of the sequence and then keep going as long as possible with it. \\nIf we found the end, make a one step back in case we messed up with the next good sequence, e.g.: \\n[1,2,1,2,3,2,3,2] -> [1,2,1,2] and [2,3,2,3,2]\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int res=-1, cur=0;\\n        for(int i=1;i<nums.size();i++) {\\n            if(nums[i]==nums[i-1]+1) {\\n                cur=2;\\n                for(i++;i<nums.size() && nums[i]==nums[i-2];i++) \\n                    cur++;\\n                res=max(res,cur);\\n                i--;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& nums) {\\n        int res=-1, cur=0;\\n        for(int i=1;i<nums.size();i++) {\\n            if(nums[i]==nums[i-1]+1) {\\n                cur=2;\\n                for(i++;i<nums.size() && nums[i]==nums[i-2];i++) \\n                    cur++;\\n                res=max(res,cur);\\n                i--;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1963938,
                "content": [
                    {
                        "username": "NoMansGhost",
                        "content": "Felt like a medium-easy. Definitely a tough problem for beginners, so don't beat yourself up if you struggled with it. Look into solving Sliding Window and Two Pointers problems."
                    },
                    {
                        "username": "2uringTested",
                        "content": "The constraints are pretty small for it to be a medium, it can be solved directly by generating all the subarrays"
                    },
                    {
                        "username": "akash__ag",
                        "content": "In example 1 \\nwhy  subarray `[2,3]` is not a valid subarray"
                    },
                    {
                        "username": "apooos3",
                        "content": "[@bparanj](/bparanj) If that would be the case for input [2, 3], it should have expected result of -1 but it\\'s 2. That means it confirms it is an alternating sequence.\\nEven if you try [2, 3, 6, 3, 7] as input, it returns 2 (And apart from 2, 3, there are no other alternating sequence). So, yeah, [2, 3] is definitely a valid alternating subsequence albeit for input [2,3,4,3,4], the largest subarray following the sequence is different, but that doesn\\'t mean [2, 3] itself is not a valid subarray following the sequence."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem statement, an alternating subarray is defined as a subarray where each element alternates between increasing by 1 and decreasing by 1 compared to the previous element. In other words, if we denote the elements of the subarray as s0, s1, s2, ..., sm, it should follow this pattern:\\n\\n- s1 - s0 = 1 (increasing by 1)\\n- s2 - s1 = -1 (decreasing by 1)\\n- s3 - s2 = 1 (increasing by 1)\\n- s4 - s3 = -1 (decreasing by 1)\\n- and so on...\\n\\nFor the example 1 where `nums = [2,3,4,3,4]`, if we consider the subarray [2,3], it only consists of two elements. According to the alternating rule, the second element should be one more than the first element, which is the case here (3 is 1 more than 2). However, we can\\'t say whether it\\'s truly an alternating subarray because it does not have any more elements to check for the alternating increase and decrease pattern.\\n\\nThe subarray [3,4] is considered an alternating subarray because it\\'s part of a larger alternating subarray [3,4,3,4]. The element after 4 is 3, which is 1 less than 4, confirming the alternating pattern.\\n\\nIn general, a subarray of only two elements can be considered as the start of an alternating subarray, but it\\'s not \"alternating\" in itself because it doesn\\'t demonstrate the full increase/decrease pattern. That\\'s why [2,3] is not considered as a valid alternating subarray in this context."
                    },
                    {
                        "username": "apooos3",
                        "content": "I agree, it should be present. When you run the test case with just [2,3] it says expected result to be 2. So, it is most certainly a valid subarray."
                    },
                    {
                        "username": "GrilledSamwich",
                        "content": "Was able to solve it but felt more like a medium than an easy. Just me?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "The constraints are pretty small for it to be a medium, it can be solved directly by generating all the subarrays"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "yeah it was pretty haard"
                    },
                    {
                        "username": "medbk",
                        "content": "I am a beginner, and this is definitely not an easy level problem. I would suggest to change it to medium"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "nice one ,  pay attention to this  condition of the problem s1 = s0 + 1. "
                    },
                    {
                        "username": "Abidi_Ramzi",
                        "content": "I could only solve it after the contest due to the server issue !!\nthis contest is ruined !!\n"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Why leetcode always crash????"
                    },
                    {
                        "username": "najwer23",
                        "content": "[@sUraJ1771singH](/sUraJ1771singH) xD"
                    },
                    {
                        "username": "apooos3",
                        "content": "It's time leetcode engineers read the system design course they made for us. :')"
                    },
                    {
                        "username": "sUraJ1771singH",
                        "content": "LeetCode may crash, but our connection is like strongly connected graph and our hearts are bound together in an infinite loop of affection.."
                    },
                    {
                        "username": "mitchie",
                        "content": "Input : [14,30,29,49,3,23,44,21,26,52]\\nOutput: 2\\nExpected: -1\\n\\nHow does this make sense? 30,29 are alternating so the output should be 2?"
                    },
                    {
                        "username": "gupta_ji_813",
                        "content": "basically the 30 is at 0th index of subarray and 29 is at 1st index...so it is not satisfy the condition s1-s0=1"
                    },
                    {
                        "username": "bparanj",
                        "content": "In this problem, a subarray needs to consist of more than two elements to be considered \"alternating\". This is explicitly stated in the problem statement: \"A subarray s of length m is called alternating if m is greater than 1.\"\\n\\nWhile 30,29 is technically alternating according to the definition given, the problem statement asks for the maximum length of all alternating subarrays present in nums or -1 if no such subarray exists.\\n\\nSo, if you only find two-element subarrays that are alternating, like 30,29, they don\\'t satisfy the problem condition, and the correct output is -1.\\n\\nThe output you\\'ve mentioned is expected based on the problem\\'s conditions: it\\'s looking for alternating subarrays of more than two elements. If there are none, it returns -1."
                    },
                    {
                        "username": "apooos3",
                        "content": "Second condition: s1 = s0 + 1, the alternating sequence should start with +1 (not -1). "
                    },
                    {
                        "username": "sarrransh",
                        "content": "Maybe i am missing something but \\uD83E\\uDD72\\uD83D\\uDE05\\nFor example 2 when all the elements are different , the answer is 2\\nInput: nums = [4,5,6]\\nOutput: 2\\nExplanation: [4,5] and [5,6] are the only two alternating subarrays. They are both of length 2.\\n\\nthen why in this testcase it is -1?\\nInput\\nnums =\\n[21,9,5]\\n\\nUse Testcase\\nOutput\\n2\\nExpected\\n-1\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sarrransh",
                        "content": "[@apooos3](/apooos3) ohhhh, i get it, my bad, thanks a lot\\n"
                    },
                    {
                        "username": "apooos3",
                        "content": "Look at the second constraint `s1 = s0 + 1` \nif you had [21, 9, 10] you'd get 2, in case of [21, 9, 5], it is -1."
                    },
                    {
                        "username": "cybertrailyst",
                        "content": "guys i made this XD\\n"
                    },
                    {
                        "username": "JamesHardenSon",
                        "content": "lil bro is cracked orz"
                    }
                ]
            },
            {
                "id": 1968624,
                "content": [
                    {
                        "username": "NoMansGhost",
                        "content": "Felt like a medium-easy. Definitely a tough problem for beginners, so don't beat yourself up if you struggled with it. Look into solving Sliding Window and Two Pointers problems."
                    },
                    {
                        "username": "2uringTested",
                        "content": "The constraints are pretty small for it to be a medium, it can be solved directly by generating all the subarrays"
                    },
                    {
                        "username": "akash__ag",
                        "content": "In example 1 \\nwhy  subarray `[2,3]` is not a valid subarray"
                    },
                    {
                        "username": "apooos3",
                        "content": "[@bparanj](/bparanj) If that would be the case for input [2, 3], it should have expected result of -1 but it\\'s 2. That means it confirms it is an alternating sequence.\\nEven if you try [2, 3, 6, 3, 7] as input, it returns 2 (And apart from 2, 3, there are no other alternating sequence). So, yeah, [2, 3] is definitely a valid alternating subsequence albeit for input [2,3,4,3,4], the largest subarray following the sequence is different, but that doesn\\'t mean [2, 3] itself is not a valid subarray following the sequence."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem statement, an alternating subarray is defined as a subarray where each element alternates between increasing by 1 and decreasing by 1 compared to the previous element. In other words, if we denote the elements of the subarray as s0, s1, s2, ..., sm, it should follow this pattern:\\n\\n- s1 - s0 = 1 (increasing by 1)\\n- s2 - s1 = -1 (decreasing by 1)\\n- s3 - s2 = 1 (increasing by 1)\\n- s4 - s3 = -1 (decreasing by 1)\\n- and so on...\\n\\nFor the example 1 where `nums = [2,3,4,3,4]`, if we consider the subarray [2,3], it only consists of two elements. According to the alternating rule, the second element should be one more than the first element, which is the case here (3 is 1 more than 2). However, we can\\'t say whether it\\'s truly an alternating subarray because it does not have any more elements to check for the alternating increase and decrease pattern.\\n\\nThe subarray [3,4] is considered an alternating subarray because it\\'s part of a larger alternating subarray [3,4,3,4]. The element after 4 is 3, which is 1 less than 4, confirming the alternating pattern.\\n\\nIn general, a subarray of only two elements can be considered as the start of an alternating subarray, but it\\'s not \"alternating\" in itself because it doesn\\'t demonstrate the full increase/decrease pattern. That\\'s why [2,3] is not considered as a valid alternating subarray in this context."
                    },
                    {
                        "username": "apooos3",
                        "content": "I agree, it should be present. When you run the test case with just [2,3] it says expected result to be 2. So, it is most certainly a valid subarray."
                    },
                    {
                        "username": "GrilledSamwich",
                        "content": "Was able to solve it but felt more like a medium than an easy. Just me?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "The constraints are pretty small for it to be a medium, it can be solved directly by generating all the subarrays"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "yeah it was pretty haard"
                    },
                    {
                        "username": "medbk",
                        "content": "I am a beginner, and this is definitely not an easy level problem. I would suggest to change it to medium"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "nice one ,  pay attention to this  condition of the problem s1 = s0 + 1. "
                    },
                    {
                        "username": "Abidi_Ramzi",
                        "content": "I could only solve it after the contest due to the server issue !!\nthis contest is ruined !!\n"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Why leetcode always crash????"
                    },
                    {
                        "username": "najwer23",
                        "content": "[@sUraJ1771singH](/sUraJ1771singH) xD"
                    },
                    {
                        "username": "apooos3",
                        "content": "It's time leetcode engineers read the system design course they made for us. :')"
                    },
                    {
                        "username": "sUraJ1771singH",
                        "content": "LeetCode may crash, but our connection is like strongly connected graph and our hearts are bound together in an infinite loop of affection.."
                    },
                    {
                        "username": "mitchie",
                        "content": "Input : [14,30,29,49,3,23,44,21,26,52]\\nOutput: 2\\nExpected: -1\\n\\nHow does this make sense? 30,29 are alternating so the output should be 2?"
                    },
                    {
                        "username": "gupta_ji_813",
                        "content": "basically the 30 is at 0th index of subarray and 29 is at 1st index...so it is not satisfy the condition s1-s0=1"
                    },
                    {
                        "username": "bparanj",
                        "content": "In this problem, a subarray needs to consist of more than two elements to be considered \"alternating\". This is explicitly stated in the problem statement: \"A subarray s of length m is called alternating if m is greater than 1.\"\\n\\nWhile 30,29 is technically alternating according to the definition given, the problem statement asks for the maximum length of all alternating subarrays present in nums or -1 if no such subarray exists.\\n\\nSo, if you only find two-element subarrays that are alternating, like 30,29, they don\\'t satisfy the problem condition, and the correct output is -1.\\n\\nThe output you\\'ve mentioned is expected based on the problem\\'s conditions: it\\'s looking for alternating subarrays of more than two elements. If there are none, it returns -1."
                    },
                    {
                        "username": "apooos3",
                        "content": "Second condition: s1 = s0 + 1, the alternating sequence should start with +1 (not -1). "
                    },
                    {
                        "username": "sarrransh",
                        "content": "Maybe i am missing something but \\uD83E\\uDD72\\uD83D\\uDE05\\nFor example 2 when all the elements are different , the answer is 2\\nInput: nums = [4,5,6]\\nOutput: 2\\nExplanation: [4,5] and [5,6] are the only two alternating subarrays. They are both of length 2.\\n\\nthen why in this testcase it is -1?\\nInput\\nnums =\\n[21,9,5]\\n\\nUse Testcase\\nOutput\\n2\\nExpected\\n-1\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sarrransh",
                        "content": "[@apooos3](/apooos3) ohhhh, i get it, my bad, thanks a lot\\n"
                    },
                    {
                        "username": "apooos3",
                        "content": "Look at the second constraint `s1 = s0 + 1` \nif you had [21, 9, 10] you'd get 2, in case of [21, 9, 5], it is -1."
                    },
                    {
                        "username": "cybertrailyst",
                        "content": "guys i made this XD\\n"
                    },
                    {
                        "username": "JamesHardenSon",
                        "content": "lil bro is cracked orz"
                    }
                ]
            },
            {
                "id": 1963571,
                "content": [
                    {
                        "username": "NoMansGhost",
                        "content": "Felt like a medium-easy. Definitely a tough problem for beginners, so don't beat yourself up if you struggled with it. Look into solving Sliding Window and Two Pointers problems."
                    },
                    {
                        "username": "2uringTested",
                        "content": "The constraints are pretty small for it to be a medium, it can be solved directly by generating all the subarrays"
                    },
                    {
                        "username": "akash__ag",
                        "content": "In example 1 \\nwhy  subarray `[2,3]` is not a valid subarray"
                    },
                    {
                        "username": "apooos3",
                        "content": "[@bparanj](/bparanj) If that would be the case for input [2, 3], it should have expected result of -1 but it\\'s 2. That means it confirms it is an alternating sequence.\\nEven if you try [2, 3, 6, 3, 7] as input, it returns 2 (And apart from 2, 3, there are no other alternating sequence). So, yeah, [2, 3] is definitely a valid alternating subsequence albeit for input [2,3,4,3,4], the largest subarray following the sequence is different, but that doesn\\'t mean [2, 3] itself is not a valid subarray following the sequence."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem statement, an alternating subarray is defined as a subarray where each element alternates between increasing by 1 and decreasing by 1 compared to the previous element. In other words, if we denote the elements of the subarray as s0, s1, s2, ..., sm, it should follow this pattern:\\n\\n- s1 - s0 = 1 (increasing by 1)\\n- s2 - s1 = -1 (decreasing by 1)\\n- s3 - s2 = 1 (increasing by 1)\\n- s4 - s3 = -1 (decreasing by 1)\\n- and so on...\\n\\nFor the example 1 where `nums = [2,3,4,3,4]`, if we consider the subarray [2,3], it only consists of two elements. According to the alternating rule, the second element should be one more than the first element, which is the case here (3 is 1 more than 2). However, we can\\'t say whether it\\'s truly an alternating subarray because it does not have any more elements to check for the alternating increase and decrease pattern.\\n\\nThe subarray [3,4] is considered an alternating subarray because it\\'s part of a larger alternating subarray [3,4,3,4]. The element after 4 is 3, which is 1 less than 4, confirming the alternating pattern.\\n\\nIn general, a subarray of only two elements can be considered as the start of an alternating subarray, but it\\'s not \"alternating\" in itself because it doesn\\'t demonstrate the full increase/decrease pattern. That\\'s why [2,3] is not considered as a valid alternating subarray in this context."
                    },
                    {
                        "username": "apooos3",
                        "content": "I agree, it should be present. When you run the test case with just [2,3] it says expected result to be 2. So, it is most certainly a valid subarray."
                    },
                    {
                        "username": "GrilledSamwich",
                        "content": "Was able to solve it but felt more like a medium than an easy. Just me?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "The constraints are pretty small for it to be a medium, it can be solved directly by generating all the subarrays"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "yeah it was pretty haard"
                    },
                    {
                        "username": "medbk",
                        "content": "I am a beginner, and this is definitely not an easy level problem. I would suggest to change it to medium"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "nice one ,  pay attention to this  condition of the problem s1 = s0 + 1. "
                    },
                    {
                        "username": "Abidi_Ramzi",
                        "content": "I could only solve it after the contest due to the server issue !!\nthis contest is ruined !!\n"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Why leetcode always crash????"
                    },
                    {
                        "username": "najwer23",
                        "content": "[@sUraJ1771singH](/sUraJ1771singH) xD"
                    },
                    {
                        "username": "apooos3",
                        "content": "It's time leetcode engineers read the system design course they made for us. :')"
                    },
                    {
                        "username": "sUraJ1771singH",
                        "content": "LeetCode may crash, but our connection is like strongly connected graph and our hearts are bound together in an infinite loop of affection.."
                    },
                    {
                        "username": "mitchie",
                        "content": "Input : [14,30,29,49,3,23,44,21,26,52]\\nOutput: 2\\nExpected: -1\\n\\nHow does this make sense? 30,29 are alternating so the output should be 2?"
                    },
                    {
                        "username": "gupta_ji_813",
                        "content": "basically the 30 is at 0th index of subarray and 29 is at 1st index...so it is not satisfy the condition s1-s0=1"
                    },
                    {
                        "username": "bparanj",
                        "content": "In this problem, a subarray needs to consist of more than two elements to be considered \"alternating\". This is explicitly stated in the problem statement: \"A subarray s of length m is called alternating if m is greater than 1.\"\\n\\nWhile 30,29 is technically alternating according to the definition given, the problem statement asks for the maximum length of all alternating subarrays present in nums or -1 if no such subarray exists.\\n\\nSo, if you only find two-element subarrays that are alternating, like 30,29, they don\\'t satisfy the problem condition, and the correct output is -1.\\n\\nThe output you\\'ve mentioned is expected based on the problem\\'s conditions: it\\'s looking for alternating subarrays of more than two elements. If there are none, it returns -1."
                    },
                    {
                        "username": "apooos3",
                        "content": "Second condition: s1 = s0 + 1, the alternating sequence should start with +1 (not -1). "
                    },
                    {
                        "username": "sarrransh",
                        "content": "Maybe i am missing something but \\uD83E\\uDD72\\uD83D\\uDE05\\nFor example 2 when all the elements are different , the answer is 2\\nInput: nums = [4,5,6]\\nOutput: 2\\nExplanation: [4,5] and [5,6] are the only two alternating subarrays. They are both of length 2.\\n\\nthen why in this testcase it is -1?\\nInput\\nnums =\\n[21,9,5]\\n\\nUse Testcase\\nOutput\\n2\\nExpected\\n-1\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sarrransh",
                        "content": "[@apooos3](/apooos3) ohhhh, i get it, my bad, thanks a lot\\n"
                    },
                    {
                        "username": "apooos3",
                        "content": "Look at the second constraint `s1 = s0 + 1` \nif you had [21, 9, 10] you'd get 2, in case of [21, 9, 5], it is -1."
                    },
                    {
                        "username": "cybertrailyst",
                        "content": "guys i made this XD\\n"
                    },
                    {
                        "username": "JamesHardenSon",
                        "content": "lil bro is cracked orz"
                    }
                ]
            },
            {
                "id": 1999051,
                "content": [
                    {
                        "username": "NoMansGhost",
                        "content": "Felt like a medium-easy. Definitely a tough problem for beginners, so don't beat yourself up if you struggled with it. Look into solving Sliding Window and Two Pointers problems."
                    },
                    {
                        "username": "2uringTested",
                        "content": "The constraints are pretty small for it to be a medium, it can be solved directly by generating all the subarrays"
                    },
                    {
                        "username": "akash__ag",
                        "content": "In example 1 \\nwhy  subarray `[2,3]` is not a valid subarray"
                    },
                    {
                        "username": "apooos3",
                        "content": "[@bparanj](/bparanj) If that would be the case for input [2, 3], it should have expected result of -1 but it\\'s 2. That means it confirms it is an alternating sequence.\\nEven if you try [2, 3, 6, 3, 7] as input, it returns 2 (And apart from 2, 3, there are no other alternating sequence). So, yeah, [2, 3] is definitely a valid alternating subsequence albeit for input [2,3,4,3,4], the largest subarray following the sequence is different, but that doesn\\'t mean [2, 3] itself is not a valid subarray following the sequence."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem statement, an alternating subarray is defined as a subarray where each element alternates between increasing by 1 and decreasing by 1 compared to the previous element. In other words, if we denote the elements of the subarray as s0, s1, s2, ..., sm, it should follow this pattern:\\n\\n- s1 - s0 = 1 (increasing by 1)\\n- s2 - s1 = -1 (decreasing by 1)\\n- s3 - s2 = 1 (increasing by 1)\\n- s4 - s3 = -1 (decreasing by 1)\\n- and so on...\\n\\nFor the example 1 where `nums = [2,3,4,3,4]`, if we consider the subarray [2,3], it only consists of two elements. According to the alternating rule, the second element should be one more than the first element, which is the case here (3 is 1 more than 2). However, we can\\'t say whether it\\'s truly an alternating subarray because it does not have any more elements to check for the alternating increase and decrease pattern.\\n\\nThe subarray [3,4] is considered an alternating subarray because it\\'s part of a larger alternating subarray [3,4,3,4]. The element after 4 is 3, which is 1 less than 4, confirming the alternating pattern.\\n\\nIn general, a subarray of only two elements can be considered as the start of an alternating subarray, but it\\'s not \"alternating\" in itself because it doesn\\'t demonstrate the full increase/decrease pattern. That\\'s why [2,3] is not considered as a valid alternating subarray in this context."
                    },
                    {
                        "username": "apooos3",
                        "content": "I agree, it should be present. When you run the test case with just [2,3] it says expected result to be 2. So, it is most certainly a valid subarray."
                    },
                    {
                        "username": "GrilledSamwich",
                        "content": "Was able to solve it but felt more like a medium than an easy. Just me?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "The constraints are pretty small for it to be a medium, it can be solved directly by generating all the subarrays"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "yeah it was pretty haard"
                    },
                    {
                        "username": "medbk",
                        "content": "I am a beginner, and this is definitely not an easy level problem. I would suggest to change it to medium"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "nice one ,  pay attention to this  condition of the problem s1 = s0 + 1. "
                    },
                    {
                        "username": "Abidi_Ramzi",
                        "content": "I could only solve it after the contest due to the server issue !!\nthis contest is ruined !!\n"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Why leetcode always crash????"
                    },
                    {
                        "username": "najwer23",
                        "content": "[@sUraJ1771singH](/sUraJ1771singH) xD"
                    },
                    {
                        "username": "apooos3",
                        "content": "It's time leetcode engineers read the system design course they made for us. :')"
                    },
                    {
                        "username": "sUraJ1771singH",
                        "content": "LeetCode may crash, but our connection is like strongly connected graph and our hearts are bound together in an infinite loop of affection.."
                    },
                    {
                        "username": "mitchie",
                        "content": "Input : [14,30,29,49,3,23,44,21,26,52]\\nOutput: 2\\nExpected: -1\\n\\nHow does this make sense? 30,29 are alternating so the output should be 2?"
                    },
                    {
                        "username": "gupta_ji_813",
                        "content": "basically the 30 is at 0th index of subarray and 29 is at 1st index...so it is not satisfy the condition s1-s0=1"
                    },
                    {
                        "username": "bparanj",
                        "content": "In this problem, a subarray needs to consist of more than two elements to be considered \"alternating\". This is explicitly stated in the problem statement: \"A subarray s of length m is called alternating if m is greater than 1.\"\\n\\nWhile 30,29 is technically alternating according to the definition given, the problem statement asks for the maximum length of all alternating subarrays present in nums or -1 if no such subarray exists.\\n\\nSo, if you only find two-element subarrays that are alternating, like 30,29, they don\\'t satisfy the problem condition, and the correct output is -1.\\n\\nThe output you\\'ve mentioned is expected based on the problem\\'s conditions: it\\'s looking for alternating subarrays of more than two elements. If there are none, it returns -1."
                    },
                    {
                        "username": "apooos3",
                        "content": "Second condition: s1 = s0 + 1, the alternating sequence should start with +1 (not -1). "
                    },
                    {
                        "username": "sarrransh",
                        "content": "Maybe i am missing something but \\uD83E\\uDD72\\uD83D\\uDE05\\nFor example 2 when all the elements are different , the answer is 2\\nInput: nums = [4,5,6]\\nOutput: 2\\nExplanation: [4,5] and [5,6] are the only two alternating subarrays. They are both of length 2.\\n\\nthen why in this testcase it is -1?\\nInput\\nnums =\\n[21,9,5]\\n\\nUse Testcase\\nOutput\\n2\\nExpected\\n-1\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sarrransh",
                        "content": "[@apooos3](/apooos3) ohhhh, i get it, my bad, thanks a lot\\n"
                    },
                    {
                        "username": "apooos3",
                        "content": "Look at the second constraint `s1 = s0 + 1` \nif you had [21, 9, 10] you'd get 2, in case of [21, 9, 5], it is -1."
                    },
                    {
                        "username": "cybertrailyst",
                        "content": "guys i made this XD\\n"
                    },
                    {
                        "username": "JamesHardenSon",
                        "content": "lil bro is cracked orz"
                    }
                ]
            },
            {
                "id": 1962965,
                "content": [
                    {
                        "username": "NoMansGhost",
                        "content": "Felt like a medium-easy. Definitely a tough problem for beginners, so don't beat yourself up if you struggled with it. Look into solving Sliding Window and Two Pointers problems."
                    },
                    {
                        "username": "2uringTested",
                        "content": "The constraints are pretty small for it to be a medium, it can be solved directly by generating all the subarrays"
                    },
                    {
                        "username": "akash__ag",
                        "content": "In example 1 \\nwhy  subarray `[2,3]` is not a valid subarray"
                    },
                    {
                        "username": "apooos3",
                        "content": "[@bparanj](/bparanj) If that would be the case for input [2, 3], it should have expected result of -1 but it\\'s 2. That means it confirms it is an alternating sequence.\\nEven if you try [2, 3, 6, 3, 7] as input, it returns 2 (And apart from 2, 3, there are no other alternating sequence). So, yeah, [2, 3] is definitely a valid alternating subsequence albeit for input [2,3,4,3,4], the largest subarray following the sequence is different, but that doesn\\'t mean [2, 3] itself is not a valid subarray following the sequence."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem statement, an alternating subarray is defined as a subarray where each element alternates between increasing by 1 and decreasing by 1 compared to the previous element. In other words, if we denote the elements of the subarray as s0, s1, s2, ..., sm, it should follow this pattern:\\n\\n- s1 - s0 = 1 (increasing by 1)\\n- s2 - s1 = -1 (decreasing by 1)\\n- s3 - s2 = 1 (increasing by 1)\\n- s4 - s3 = -1 (decreasing by 1)\\n- and so on...\\n\\nFor the example 1 where `nums = [2,3,4,3,4]`, if we consider the subarray [2,3], it only consists of two elements. According to the alternating rule, the second element should be one more than the first element, which is the case here (3 is 1 more than 2). However, we can\\'t say whether it\\'s truly an alternating subarray because it does not have any more elements to check for the alternating increase and decrease pattern.\\n\\nThe subarray [3,4] is considered an alternating subarray because it\\'s part of a larger alternating subarray [3,4,3,4]. The element after 4 is 3, which is 1 less than 4, confirming the alternating pattern.\\n\\nIn general, a subarray of only two elements can be considered as the start of an alternating subarray, but it\\'s not \"alternating\" in itself because it doesn\\'t demonstrate the full increase/decrease pattern. That\\'s why [2,3] is not considered as a valid alternating subarray in this context."
                    },
                    {
                        "username": "apooos3",
                        "content": "I agree, it should be present. When you run the test case with just [2,3] it says expected result to be 2. So, it is most certainly a valid subarray."
                    },
                    {
                        "username": "GrilledSamwich",
                        "content": "Was able to solve it but felt more like a medium than an easy. Just me?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "The constraints are pretty small for it to be a medium, it can be solved directly by generating all the subarrays"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "yeah it was pretty haard"
                    },
                    {
                        "username": "medbk",
                        "content": "I am a beginner, and this is definitely not an easy level problem. I would suggest to change it to medium"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "nice one ,  pay attention to this  condition of the problem s1 = s0 + 1. "
                    },
                    {
                        "username": "Abidi_Ramzi",
                        "content": "I could only solve it after the contest due to the server issue !!\nthis contest is ruined !!\n"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Why leetcode always crash????"
                    },
                    {
                        "username": "najwer23",
                        "content": "[@sUraJ1771singH](/sUraJ1771singH) xD"
                    },
                    {
                        "username": "apooos3",
                        "content": "It's time leetcode engineers read the system design course they made for us. :')"
                    },
                    {
                        "username": "sUraJ1771singH",
                        "content": "LeetCode may crash, but our connection is like strongly connected graph and our hearts are bound together in an infinite loop of affection.."
                    },
                    {
                        "username": "mitchie",
                        "content": "Input : [14,30,29,49,3,23,44,21,26,52]\\nOutput: 2\\nExpected: -1\\n\\nHow does this make sense? 30,29 are alternating so the output should be 2?"
                    },
                    {
                        "username": "gupta_ji_813",
                        "content": "basically the 30 is at 0th index of subarray and 29 is at 1st index...so it is not satisfy the condition s1-s0=1"
                    },
                    {
                        "username": "bparanj",
                        "content": "In this problem, a subarray needs to consist of more than two elements to be considered \"alternating\". This is explicitly stated in the problem statement: \"A subarray s of length m is called alternating if m is greater than 1.\"\\n\\nWhile 30,29 is technically alternating according to the definition given, the problem statement asks for the maximum length of all alternating subarrays present in nums or -1 if no such subarray exists.\\n\\nSo, if you only find two-element subarrays that are alternating, like 30,29, they don\\'t satisfy the problem condition, and the correct output is -1.\\n\\nThe output you\\'ve mentioned is expected based on the problem\\'s conditions: it\\'s looking for alternating subarrays of more than two elements. If there are none, it returns -1."
                    },
                    {
                        "username": "apooos3",
                        "content": "Second condition: s1 = s0 + 1, the alternating sequence should start with +1 (not -1). "
                    },
                    {
                        "username": "sarrransh",
                        "content": "Maybe i am missing something but \\uD83E\\uDD72\\uD83D\\uDE05\\nFor example 2 when all the elements are different , the answer is 2\\nInput: nums = [4,5,6]\\nOutput: 2\\nExplanation: [4,5] and [5,6] are the only two alternating subarrays. They are both of length 2.\\n\\nthen why in this testcase it is -1?\\nInput\\nnums =\\n[21,9,5]\\n\\nUse Testcase\\nOutput\\n2\\nExpected\\n-1\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sarrransh",
                        "content": "[@apooos3](/apooos3) ohhhh, i get it, my bad, thanks a lot\\n"
                    },
                    {
                        "username": "apooos3",
                        "content": "Look at the second constraint `s1 = s0 + 1` \nif you had [21, 9, 10] you'd get 2, in case of [21, 9, 5], it is -1."
                    },
                    {
                        "username": "cybertrailyst",
                        "content": "guys i made this XD\\n"
                    },
                    {
                        "username": "JamesHardenSon",
                        "content": "lil bro is cracked orz"
                    }
                ]
            },
            {
                "id": 1962107,
                "content": [
                    {
                        "username": "NoMansGhost",
                        "content": "Felt like a medium-easy. Definitely a tough problem for beginners, so don't beat yourself up if you struggled with it. Look into solving Sliding Window and Two Pointers problems."
                    },
                    {
                        "username": "2uringTested",
                        "content": "The constraints are pretty small for it to be a medium, it can be solved directly by generating all the subarrays"
                    },
                    {
                        "username": "akash__ag",
                        "content": "In example 1 \\nwhy  subarray `[2,3]` is not a valid subarray"
                    },
                    {
                        "username": "apooos3",
                        "content": "[@bparanj](/bparanj) If that would be the case for input [2, 3], it should have expected result of -1 but it\\'s 2. That means it confirms it is an alternating sequence.\\nEven if you try [2, 3, 6, 3, 7] as input, it returns 2 (And apart from 2, 3, there are no other alternating sequence). So, yeah, [2, 3] is definitely a valid alternating subsequence albeit for input [2,3,4,3,4], the largest subarray following the sequence is different, but that doesn\\'t mean [2, 3] itself is not a valid subarray following the sequence."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem statement, an alternating subarray is defined as a subarray where each element alternates between increasing by 1 and decreasing by 1 compared to the previous element. In other words, if we denote the elements of the subarray as s0, s1, s2, ..., sm, it should follow this pattern:\\n\\n- s1 - s0 = 1 (increasing by 1)\\n- s2 - s1 = -1 (decreasing by 1)\\n- s3 - s2 = 1 (increasing by 1)\\n- s4 - s3 = -1 (decreasing by 1)\\n- and so on...\\n\\nFor the example 1 where `nums = [2,3,4,3,4]`, if we consider the subarray [2,3], it only consists of two elements. According to the alternating rule, the second element should be one more than the first element, which is the case here (3 is 1 more than 2). However, we can\\'t say whether it\\'s truly an alternating subarray because it does not have any more elements to check for the alternating increase and decrease pattern.\\n\\nThe subarray [3,4] is considered an alternating subarray because it\\'s part of a larger alternating subarray [3,4,3,4]. The element after 4 is 3, which is 1 less than 4, confirming the alternating pattern.\\n\\nIn general, a subarray of only two elements can be considered as the start of an alternating subarray, but it\\'s not \"alternating\" in itself because it doesn\\'t demonstrate the full increase/decrease pattern. That\\'s why [2,3] is not considered as a valid alternating subarray in this context."
                    },
                    {
                        "username": "apooos3",
                        "content": "I agree, it should be present. When you run the test case with just [2,3] it says expected result to be 2. So, it is most certainly a valid subarray."
                    },
                    {
                        "username": "GrilledSamwich",
                        "content": "Was able to solve it but felt more like a medium than an easy. Just me?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "The constraints are pretty small for it to be a medium, it can be solved directly by generating all the subarrays"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "yeah it was pretty haard"
                    },
                    {
                        "username": "medbk",
                        "content": "I am a beginner, and this is definitely not an easy level problem. I would suggest to change it to medium"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "nice one ,  pay attention to this  condition of the problem s1 = s0 + 1. "
                    },
                    {
                        "username": "Abidi_Ramzi",
                        "content": "I could only solve it after the contest due to the server issue !!\nthis contest is ruined !!\n"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Why leetcode always crash????"
                    },
                    {
                        "username": "najwer23",
                        "content": "[@sUraJ1771singH](/sUraJ1771singH) xD"
                    },
                    {
                        "username": "apooos3",
                        "content": "It's time leetcode engineers read the system design course they made for us. :')"
                    },
                    {
                        "username": "sUraJ1771singH",
                        "content": "LeetCode may crash, but our connection is like strongly connected graph and our hearts are bound together in an infinite loop of affection.."
                    },
                    {
                        "username": "mitchie",
                        "content": "Input : [14,30,29,49,3,23,44,21,26,52]\\nOutput: 2\\nExpected: -1\\n\\nHow does this make sense? 30,29 are alternating so the output should be 2?"
                    },
                    {
                        "username": "gupta_ji_813",
                        "content": "basically the 30 is at 0th index of subarray and 29 is at 1st index...so it is not satisfy the condition s1-s0=1"
                    },
                    {
                        "username": "bparanj",
                        "content": "In this problem, a subarray needs to consist of more than two elements to be considered \"alternating\". This is explicitly stated in the problem statement: \"A subarray s of length m is called alternating if m is greater than 1.\"\\n\\nWhile 30,29 is technically alternating according to the definition given, the problem statement asks for the maximum length of all alternating subarrays present in nums or -1 if no such subarray exists.\\n\\nSo, if you only find two-element subarrays that are alternating, like 30,29, they don\\'t satisfy the problem condition, and the correct output is -1.\\n\\nThe output you\\'ve mentioned is expected based on the problem\\'s conditions: it\\'s looking for alternating subarrays of more than two elements. If there are none, it returns -1."
                    },
                    {
                        "username": "apooos3",
                        "content": "Second condition: s1 = s0 + 1, the alternating sequence should start with +1 (not -1). "
                    },
                    {
                        "username": "sarrransh",
                        "content": "Maybe i am missing something but \\uD83E\\uDD72\\uD83D\\uDE05\\nFor example 2 when all the elements are different , the answer is 2\\nInput: nums = [4,5,6]\\nOutput: 2\\nExplanation: [4,5] and [5,6] are the only two alternating subarrays. They are both of length 2.\\n\\nthen why in this testcase it is -1?\\nInput\\nnums =\\n[21,9,5]\\n\\nUse Testcase\\nOutput\\n2\\nExpected\\n-1\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sarrransh",
                        "content": "[@apooos3](/apooos3) ohhhh, i get it, my bad, thanks a lot\\n"
                    },
                    {
                        "username": "apooos3",
                        "content": "Look at the second constraint `s1 = s0 + 1` \nif you had [21, 9, 10] you'd get 2, in case of [21, 9, 5], it is -1."
                    },
                    {
                        "username": "cybertrailyst",
                        "content": "guys i made this XD\\n"
                    },
                    {
                        "username": "JamesHardenSon",
                        "content": "lil bro is cracked orz"
                    }
                ]
            },
            {
                "id": 1961900,
                "content": [
                    {
                        "username": "NoMansGhost",
                        "content": "Felt like a medium-easy. Definitely a tough problem for beginners, so don't beat yourself up if you struggled with it. Look into solving Sliding Window and Two Pointers problems."
                    },
                    {
                        "username": "2uringTested",
                        "content": "The constraints are pretty small for it to be a medium, it can be solved directly by generating all the subarrays"
                    },
                    {
                        "username": "akash__ag",
                        "content": "In example 1 \\nwhy  subarray `[2,3]` is not a valid subarray"
                    },
                    {
                        "username": "apooos3",
                        "content": "[@bparanj](/bparanj) If that would be the case for input [2, 3], it should have expected result of -1 but it\\'s 2. That means it confirms it is an alternating sequence.\\nEven if you try [2, 3, 6, 3, 7] as input, it returns 2 (And apart from 2, 3, there are no other alternating sequence). So, yeah, [2, 3] is definitely a valid alternating subsequence albeit for input [2,3,4,3,4], the largest subarray following the sequence is different, but that doesn\\'t mean [2, 3] itself is not a valid subarray following the sequence."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem statement, an alternating subarray is defined as a subarray where each element alternates between increasing by 1 and decreasing by 1 compared to the previous element. In other words, if we denote the elements of the subarray as s0, s1, s2, ..., sm, it should follow this pattern:\\n\\n- s1 - s0 = 1 (increasing by 1)\\n- s2 - s1 = -1 (decreasing by 1)\\n- s3 - s2 = 1 (increasing by 1)\\n- s4 - s3 = -1 (decreasing by 1)\\n- and so on...\\n\\nFor the example 1 where `nums = [2,3,4,3,4]`, if we consider the subarray [2,3], it only consists of two elements. According to the alternating rule, the second element should be one more than the first element, which is the case here (3 is 1 more than 2). However, we can\\'t say whether it\\'s truly an alternating subarray because it does not have any more elements to check for the alternating increase and decrease pattern.\\n\\nThe subarray [3,4] is considered an alternating subarray because it\\'s part of a larger alternating subarray [3,4,3,4]. The element after 4 is 3, which is 1 less than 4, confirming the alternating pattern.\\n\\nIn general, a subarray of only two elements can be considered as the start of an alternating subarray, but it\\'s not \"alternating\" in itself because it doesn\\'t demonstrate the full increase/decrease pattern. That\\'s why [2,3] is not considered as a valid alternating subarray in this context."
                    },
                    {
                        "username": "apooos3",
                        "content": "I agree, it should be present. When you run the test case with just [2,3] it says expected result to be 2. So, it is most certainly a valid subarray."
                    },
                    {
                        "username": "GrilledSamwich",
                        "content": "Was able to solve it but felt more like a medium than an easy. Just me?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "The constraints are pretty small for it to be a medium, it can be solved directly by generating all the subarrays"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "yeah it was pretty haard"
                    },
                    {
                        "username": "medbk",
                        "content": "I am a beginner, and this is definitely not an easy level problem. I would suggest to change it to medium"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "nice one ,  pay attention to this  condition of the problem s1 = s0 + 1. "
                    },
                    {
                        "username": "Abidi_Ramzi",
                        "content": "I could only solve it after the contest due to the server issue !!\nthis contest is ruined !!\n"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Why leetcode always crash????"
                    },
                    {
                        "username": "najwer23",
                        "content": "[@sUraJ1771singH](/sUraJ1771singH) xD"
                    },
                    {
                        "username": "apooos3",
                        "content": "It's time leetcode engineers read the system design course they made for us. :')"
                    },
                    {
                        "username": "sUraJ1771singH",
                        "content": "LeetCode may crash, but our connection is like strongly connected graph and our hearts are bound together in an infinite loop of affection.."
                    },
                    {
                        "username": "mitchie",
                        "content": "Input : [14,30,29,49,3,23,44,21,26,52]\\nOutput: 2\\nExpected: -1\\n\\nHow does this make sense? 30,29 are alternating so the output should be 2?"
                    },
                    {
                        "username": "gupta_ji_813",
                        "content": "basically the 30 is at 0th index of subarray and 29 is at 1st index...so it is not satisfy the condition s1-s0=1"
                    },
                    {
                        "username": "bparanj",
                        "content": "In this problem, a subarray needs to consist of more than two elements to be considered \"alternating\". This is explicitly stated in the problem statement: \"A subarray s of length m is called alternating if m is greater than 1.\"\\n\\nWhile 30,29 is technically alternating according to the definition given, the problem statement asks for the maximum length of all alternating subarrays present in nums or -1 if no such subarray exists.\\n\\nSo, if you only find two-element subarrays that are alternating, like 30,29, they don\\'t satisfy the problem condition, and the correct output is -1.\\n\\nThe output you\\'ve mentioned is expected based on the problem\\'s conditions: it\\'s looking for alternating subarrays of more than two elements. If there are none, it returns -1."
                    },
                    {
                        "username": "apooos3",
                        "content": "Second condition: s1 = s0 + 1, the alternating sequence should start with +1 (not -1). "
                    },
                    {
                        "username": "sarrransh",
                        "content": "Maybe i am missing something but \\uD83E\\uDD72\\uD83D\\uDE05\\nFor example 2 when all the elements are different , the answer is 2\\nInput: nums = [4,5,6]\\nOutput: 2\\nExplanation: [4,5] and [5,6] are the only two alternating subarrays. They are both of length 2.\\n\\nthen why in this testcase it is -1?\\nInput\\nnums =\\n[21,9,5]\\n\\nUse Testcase\\nOutput\\n2\\nExpected\\n-1\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sarrransh",
                        "content": "[@apooos3](/apooos3) ohhhh, i get it, my bad, thanks a lot\\n"
                    },
                    {
                        "username": "apooos3",
                        "content": "Look at the second constraint `s1 = s0 + 1` \nif you had [21, 9, 10] you'd get 2, in case of [21, 9, 5], it is -1."
                    },
                    {
                        "username": "cybertrailyst",
                        "content": "guys i made this XD\\n"
                    },
                    {
                        "username": "JamesHardenSon",
                        "content": "lil bro is cracked orz"
                    }
                ]
            },
            {
                "id": 1984358,
                "content": [
                    {
                        "username": "NoMansGhost",
                        "content": "Felt like a medium-easy. Definitely a tough problem for beginners, so don't beat yourself up if you struggled with it. Look into solving Sliding Window and Two Pointers problems."
                    },
                    {
                        "username": "2uringTested",
                        "content": "The constraints are pretty small for it to be a medium, it can be solved directly by generating all the subarrays"
                    },
                    {
                        "username": "akash__ag",
                        "content": "In example 1 \\nwhy  subarray `[2,3]` is not a valid subarray"
                    },
                    {
                        "username": "apooos3",
                        "content": "[@bparanj](/bparanj) If that would be the case for input [2, 3], it should have expected result of -1 but it\\'s 2. That means it confirms it is an alternating sequence.\\nEven if you try [2, 3, 6, 3, 7] as input, it returns 2 (And apart from 2, 3, there are no other alternating sequence). So, yeah, [2, 3] is definitely a valid alternating subsequence albeit for input [2,3,4,3,4], the largest subarray following the sequence is different, but that doesn\\'t mean [2, 3] itself is not a valid subarray following the sequence."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem statement, an alternating subarray is defined as a subarray where each element alternates between increasing by 1 and decreasing by 1 compared to the previous element. In other words, if we denote the elements of the subarray as s0, s1, s2, ..., sm, it should follow this pattern:\\n\\n- s1 - s0 = 1 (increasing by 1)\\n- s2 - s1 = -1 (decreasing by 1)\\n- s3 - s2 = 1 (increasing by 1)\\n- s4 - s3 = -1 (decreasing by 1)\\n- and so on...\\n\\nFor the example 1 where `nums = [2,3,4,3,4]`, if we consider the subarray [2,3], it only consists of two elements. According to the alternating rule, the second element should be one more than the first element, which is the case here (3 is 1 more than 2). However, we can\\'t say whether it\\'s truly an alternating subarray because it does not have any more elements to check for the alternating increase and decrease pattern.\\n\\nThe subarray [3,4] is considered an alternating subarray because it\\'s part of a larger alternating subarray [3,4,3,4]. The element after 4 is 3, which is 1 less than 4, confirming the alternating pattern.\\n\\nIn general, a subarray of only two elements can be considered as the start of an alternating subarray, but it\\'s not \"alternating\" in itself because it doesn\\'t demonstrate the full increase/decrease pattern. That\\'s why [2,3] is not considered as a valid alternating subarray in this context."
                    },
                    {
                        "username": "apooos3",
                        "content": "I agree, it should be present. When you run the test case with just [2,3] it says expected result to be 2. So, it is most certainly a valid subarray."
                    },
                    {
                        "username": "GrilledSamwich",
                        "content": "Was able to solve it but felt more like a medium than an easy. Just me?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "The constraints are pretty small for it to be a medium, it can be solved directly by generating all the subarrays"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "yeah it was pretty haard"
                    },
                    {
                        "username": "medbk",
                        "content": "I am a beginner, and this is definitely not an easy level problem. I would suggest to change it to medium"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "nice one ,  pay attention to this  condition of the problem s1 = s0 + 1. "
                    },
                    {
                        "username": "Abidi_Ramzi",
                        "content": "I could only solve it after the contest due to the server issue !!\nthis contest is ruined !!\n"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Why leetcode always crash????"
                    },
                    {
                        "username": "najwer23",
                        "content": "[@sUraJ1771singH](/sUraJ1771singH) xD"
                    },
                    {
                        "username": "apooos3",
                        "content": "It's time leetcode engineers read the system design course they made for us. :')"
                    },
                    {
                        "username": "sUraJ1771singH",
                        "content": "LeetCode may crash, but our connection is like strongly connected graph and our hearts are bound together in an infinite loop of affection.."
                    },
                    {
                        "username": "mitchie",
                        "content": "Input : [14,30,29,49,3,23,44,21,26,52]\\nOutput: 2\\nExpected: -1\\n\\nHow does this make sense? 30,29 are alternating so the output should be 2?"
                    },
                    {
                        "username": "gupta_ji_813",
                        "content": "basically the 30 is at 0th index of subarray and 29 is at 1st index...so it is not satisfy the condition s1-s0=1"
                    },
                    {
                        "username": "bparanj",
                        "content": "In this problem, a subarray needs to consist of more than two elements to be considered \"alternating\". This is explicitly stated in the problem statement: \"A subarray s of length m is called alternating if m is greater than 1.\"\\n\\nWhile 30,29 is technically alternating according to the definition given, the problem statement asks for the maximum length of all alternating subarrays present in nums or -1 if no such subarray exists.\\n\\nSo, if you only find two-element subarrays that are alternating, like 30,29, they don\\'t satisfy the problem condition, and the correct output is -1.\\n\\nThe output you\\'ve mentioned is expected based on the problem\\'s conditions: it\\'s looking for alternating subarrays of more than two elements. If there are none, it returns -1."
                    },
                    {
                        "username": "apooos3",
                        "content": "Second condition: s1 = s0 + 1, the alternating sequence should start with +1 (not -1). "
                    },
                    {
                        "username": "sarrransh",
                        "content": "Maybe i am missing something but \\uD83E\\uDD72\\uD83D\\uDE05\\nFor example 2 when all the elements are different , the answer is 2\\nInput: nums = [4,5,6]\\nOutput: 2\\nExplanation: [4,5] and [5,6] are the only two alternating subarrays. They are both of length 2.\\n\\nthen why in this testcase it is -1?\\nInput\\nnums =\\n[21,9,5]\\n\\nUse Testcase\\nOutput\\n2\\nExpected\\n-1\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sarrransh",
                        "content": "[@apooos3](/apooos3) ohhhh, i get it, my bad, thanks a lot\\n"
                    },
                    {
                        "username": "apooos3",
                        "content": "Look at the second constraint `s1 = s0 + 1` \nif you had [21, 9, 10] you'd get 2, in case of [21, 9, 5], it is -1."
                    },
                    {
                        "username": "cybertrailyst",
                        "content": "guys i made this XD\\n"
                    },
                    {
                        "username": "JamesHardenSon",
                        "content": "lil bro is cracked orz"
                    }
                ]
            },
            {
                "id": 1978481,
                "content": [
                    {
                        "username": "NoMansGhost",
                        "content": "Felt like a medium-easy. Definitely a tough problem for beginners, so don't beat yourself up if you struggled with it. Look into solving Sliding Window and Two Pointers problems."
                    },
                    {
                        "username": "2uringTested",
                        "content": "The constraints are pretty small for it to be a medium, it can be solved directly by generating all the subarrays"
                    },
                    {
                        "username": "akash__ag",
                        "content": "In example 1 \\nwhy  subarray `[2,3]` is not a valid subarray"
                    },
                    {
                        "username": "apooos3",
                        "content": "[@bparanj](/bparanj) If that would be the case for input [2, 3], it should have expected result of -1 but it\\'s 2. That means it confirms it is an alternating sequence.\\nEven if you try [2, 3, 6, 3, 7] as input, it returns 2 (And apart from 2, 3, there are no other alternating sequence). So, yeah, [2, 3] is definitely a valid alternating subsequence albeit for input [2,3,4,3,4], the largest subarray following the sequence is different, but that doesn\\'t mean [2, 3] itself is not a valid subarray following the sequence."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem statement, an alternating subarray is defined as a subarray where each element alternates between increasing by 1 and decreasing by 1 compared to the previous element. In other words, if we denote the elements of the subarray as s0, s1, s2, ..., sm, it should follow this pattern:\\n\\n- s1 - s0 = 1 (increasing by 1)\\n- s2 - s1 = -1 (decreasing by 1)\\n- s3 - s2 = 1 (increasing by 1)\\n- s4 - s3 = -1 (decreasing by 1)\\n- and so on...\\n\\nFor the example 1 where `nums = [2,3,4,3,4]`, if we consider the subarray [2,3], it only consists of two elements. According to the alternating rule, the second element should be one more than the first element, which is the case here (3 is 1 more than 2). However, we can\\'t say whether it\\'s truly an alternating subarray because it does not have any more elements to check for the alternating increase and decrease pattern.\\n\\nThe subarray [3,4] is considered an alternating subarray because it\\'s part of a larger alternating subarray [3,4,3,4]. The element after 4 is 3, which is 1 less than 4, confirming the alternating pattern.\\n\\nIn general, a subarray of only two elements can be considered as the start of an alternating subarray, but it\\'s not \"alternating\" in itself because it doesn\\'t demonstrate the full increase/decrease pattern. That\\'s why [2,3] is not considered as a valid alternating subarray in this context."
                    },
                    {
                        "username": "apooos3",
                        "content": "I agree, it should be present. When you run the test case with just [2,3] it says expected result to be 2. So, it is most certainly a valid subarray."
                    },
                    {
                        "username": "GrilledSamwich",
                        "content": "Was able to solve it but felt more like a medium than an easy. Just me?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "The constraints are pretty small for it to be a medium, it can be solved directly by generating all the subarrays"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "yeah it was pretty haard"
                    },
                    {
                        "username": "medbk",
                        "content": "I am a beginner, and this is definitely not an easy level problem. I would suggest to change it to medium"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "nice one ,  pay attention to this  condition of the problem s1 = s0 + 1. "
                    },
                    {
                        "username": "Abidi_Ramzi",
                        "content": "I could only solve it after the contest due to the server issue !!\nthis contest is ruined !!\n"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Why leetcode always crash????"
                    },
                    {
                        "username": "najwer23",
                        "content": "[@sUraJ1771singH](/sUraJ1771singH) xD"
                    },
                    {
                        "username": "apooos3",
                        "content": "It's time leetcode engineers read the system design course they made for us. :')"
                    },
                    {
                        "username": "sUraJ1771singH",
                        "content": "LeetCode may crash, but our connection is like strongly connected graph and our hearts are bound together in an infinite loop of affection.."
                    },
                    {
                        "username": "mitchie",
                        "content": "Input : [14,30,29,49,3,23,44,21,26,52]\\nOutput: 2\\nExpected: -1\\n\\nHow does this make sense? 30,29 are alternating so the output should be 2?"
                    },
                    {
                        "username": "gupta_ji_813",
                        "content": "basically the 30 is at 0th index of subarray and 29 is at 1st index...so it is not satisfy the condition s1-s0=1"
                    },
                    {
                        "username": "bparanj",
                        "content": "In this problem, a subarray needs to consist of more than two elements to be considered \"alternating\". This is explicitly stated in the problem statement: \"A subarray s of length m is called alternating if m is greater than 1.\"\\n\\nWhile 30,29 is technically alternating according to the definition given, the problem statement asks for the maximum length of all alternating subarrays present in nums or -1 if no such subarray exists.\\n\\nSo, if you only find two-element subarrays that are alternating, like 30,29, they don\\'t satisfy the problem condition, and the correct output is -1.\\n\\nThe output you\\'ve mentioned is expected based on the problem\\'s conditions: it\\'s looking for alternating subarrays of more than two elements. If there are none, it returns -1."
                    },
                    {
                        "username": "apooos3",
                        "content": "Second condition: s1 = s0 + 1, the alternating sequence should start with +1 (not -1). "
                    },
                    {
                        "username": "sarrransh",
                        "content": "Maybe i am missing something but \\uD83E\\uDD72\\uD83D\\uDE05\\nFor example 2 when all the elements are different , the answer is 2\\nInput: nums = [4,5,6]\\nOutput: 2\\nExplanation: [4,5] and [5,6] are the only two alternating subarrays. They are both of length 2.\\n\\nthen why in this testcase it is -1?\\nInput\\nnums =\\n[21,9,5]\\n\\nUse Testcase\\nOutput\\n2\\nExpected\\n-1\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sarrransh",
                        "content": "[@apooos3](/apooos3) ohhhh, i get it, my bad, thanks a lot\\n"
                    },
                    {
                        "username": "apooos3",
                        "content": "Look at the second constraint `s1 = s0 + 1` \nif you had [21, 9, 10] you'd get 2, in case of [21, 9, 5], it is -1."
                    },
                    {
                        "username": "cybertrailyst",
                        "content": "guys i made this XD\\n"
                    },
                    {
                        "username": "JamesHardenSon",
                        "content": "lil bro is cracked orz"
                    }
                ]
            },
            {
                "id": 1970790,
                "content": [
                    {
                        "username": "NoMansGhost",
                        "content": "Felt like a medium-easy. Definitely a tough problem for beginners, so don't beat yourself up if you struggled with it. Look into solving Sliding Window and Two Pointers problems."
                    },
                    {
                        "username": "2uringTested",
                        "content": "The constraints are pretty small for it to be a medium, it can be solved directly by generating all the subarrays"
                    },
                    {
                        "username": "akash__ag",
                        "content": "In example 1 \\nwhy  subarray `[2,3]` is not a valid subarray"
                    },
                    {
                        "username": "apooos3",
                        "content": "[@bparanj](/bparanj) If that would be the case for input [2, 3], it should have expected result of -1 but it\\'s 2. That means it confirms it is an alternating sequence.\\nEven if you try [2, 3, 6, 3, 7] as input, it returns 2 (And apart from 2, 3, there are no other alternating sequence). So, yeah, [2, 3] is definitely a valid alternating subsequence albeit for input [2,3,4,3,4], the largest subarray following the sequence is different, but that doesn\\'t mean [2, 3] itself is not a valid subarray following the sequence."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem statement, an alternating subarray is defined as a subarray where each element alternates between increasing by 1 and decreasing by 1 compared to the previous element. In other words, if we denote the elements of the subarray as s0, s1, s2, ..., sm, it should follow this pattern:\\n\\n- s1 - s0 = 1 (increasing by 1)\\n- s2 - s1 = -1 (decreasing by 1)\\n- s3 - s2 = 1 (increasing by 1)\\n- s4 - s3 = -1 (decreasing by 1)\\n- and so on...\\n\\nFor the example 1 where `nums = [2,3,4,3,4]`, if we consider the subarray [2,3], it only consists of two elements. According to the alternating rule, the second element should be one more than the first element, which is the case here (3 is 1 more than 2). However, we can\\'t say whether it\\'s truly an alternating subarray because it does not have any more elements to check for the alternating increase and decrease pattern.\\n\\nThe subarray [3,4] is considered an alternating subarray because it\\'s part of a larger alternating subarray [3,4,3,4]. The element after 4 is 3, which is 1 less than 4, confirming the alternating pattern.\\n\\nIn general, a subarray of only two elements can be considered as the start of an alternating subarray, but it\\'s not \"alternating\" in itself because it doesn\\'t demonstrate the full increase/decrease pattern. That\\'s why [2,3] is not considered as a valid alternating subarray in this context."
                    },
                    {
                        "username": "apooos3",
                        "content": "I agree, it should be present. When you run the test case with just [2,3] it says expected result to be 2. So, it is most certainly a valid subarray."
                    },
                    {
                        "username": "GrilledSamwich",
                        "content": "Was able to solve it but felt more like a medium than an easy. Just me?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "The constraints are pretty small for it to be a medium, it can be solved directly by generating all the subarrays"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "yeah it was pretty haard"
                    },
                    {
                        "username": "medbk",
                        "content": "I am a beginner, and this is definitely not an easy level problem. I would suggest to change it to medium"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "nice one ,  pay attention to this  condition of the problem s1 = s0 + 1. "
                    },
                    {
                        "username": "Abidi_Ramzi",
                        "content": "I could only solve it after the contest due to the server issue !!\nthis contest is ruined !!\n"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Why leetcode always crash????"
                    },
                    {
                        "username": "najwer23",
                        "content": "[@sUraJ1771singH](/sUraJ1771singH) xD"
                    },
                    {
                        "username": "apooos3",
                        "content": "It's time leetcode engineers read the system design course they made for us. :')"
                    },
                    {
                        "username": "sUraJ1771singH",
                        "content": "LeetCode may crash, but our connection is like strongly connected graph and our hearts are bound together in an infinite loop of affection.."
                    },
                    {
                        "username": "mitchie",
                        "content": "Input : [14,30,29,49,3,23,44,21,26,52]\\nOutput: 2\\nExpected: -1\\n\\nHow does this make sense? 30,29 are alternating so the output should be 2?"
                    },
                    {
                        "username": "gupta_ji_813",
                        "content": "basically the 30 is at 0th index of subarray and 29 is at 1st index...so it is not satisfy the condition s1-s0=1"
                    },
                    {
                        "username": "bparanj",
                        "content": "In this problem, a subarray needs to consist of more than two elements to be considered \"alternating\". This is explicitly stated in the problem statement: \"A subarray s of length m is called alternating if m is greater than 1.\"\\n\\nWhile 30,29 is technically alternating according to the definition given, the problem statement asks for the maximum length of all alternating subarrays present in nums or -1 if no such subarray exists.\\n\\nSo, if you only find two-element subarrays that are alternating, like 30,29, they don\\'t satisfy the problem condition, and the correct output is -1.\\n\\nThe output you\\'ve mentioned is expected based on the problem\\'s conditions: it\\'s looking for alternating subarrays of more than two elements. If there are none, it returns -1."
                    },
                    {
                        "username": "apooos3",
                        "content": "Second condition: s1 = s0 + 1, the alternating sequence should start with +1 (not -1). "
                    },
                    {
                        "username": "sarrransh",
                        "content": "Maybe i am missing something but \\uD83E\\uDD72\\uD83D\\uDE05\\nFor example 2 when all the elements are different , the answer is 2\\nInput: nums = [4,5,6]\\nOutput: 2\\nExplanation: [4,5] and [5,6] are the only two alternating subarrays. They are both of length 2.\\n\\nthen why in this testcase it is -1?\\nInput\\nnums =\\n[21,9,5]\\n\\nUse Testcase\\nOutput\\n2\\nExpected\\n-1\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sarrransh",
                        "content": "[@apooos3](/apooos3) ohhhh, i get it, my bad, thanks a lot\\n"
                    },
                    {
                        "username": "apooos3",
                        "content": "Look at the second constraint `s1 = s0 + 1` \nif you had [21, 9, 10] you'd get 2, in case of [21, 9, 5], it is -1."
                    },
                    {
                        "username": "cybertrailyst",
                        "content": "guys i made this XD\\n"
                    },
                    {
                        "username": "JamesHardenSon",
                        "content": "lil bro is cracked orz"
                    }
                ]
            },
            {
                "id": 1963938,
                "content": [
                    {
                        "username": "NoMansGhost",
                        "content": "Felt like a medium-easy. Definitely a tough problem for beginners, so don't beat yourself up if you struggled with it. Look into solving Sliding Window and Two Pointers problems."
                    },
                    {
                        "username": "2uringTested",
                        "content": "The constraints are pretty small for it to be a medium, it can be solved directly by generating all the subarrays"
                    },
                    {
                        "username": "akash__ag",
                        "content": "In example 1 \\nwhy  subarray `[2,3]` is not a valid subarray"
                    },
                    {
                        "username": "apooos3",
                        "content": "[@bparanj](/bparanj) If that would be the case for input [2, 3], it should have expected result of -1 but it\\'s 2. That means it confirms it is an alternating sequence.\\nEven if you try [2, 3, 6, 3, 7] as input, it returns 2 (And apart from 2, 3, there are no other alternating sequence). So, yeah, [2, 3] is definitely a valid alternating subsequence albeit for input [2,3,4,3,4], the largest subarray following the sequence is different, but that doesn\\'t mean [2, 3] itself is not a valid subarray following the sequence."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem statement, an alternating subarray is defined as a subarray where each element alternates between increasing by 1 and decreasing by 1 compared to the previous element. In other words, if we denote the elements of the subarray as s0, s1, s2, ..., sm, it should follow this pattern:\\n\\n- s1 - s0 = 1 (increasing by 1)\\n- s2 - s1 = -1 (decreasing by 1)\\n- s3 - s2 = 1 (increasing by 1)\\n- s4 - s3 = -1 (decreasing by 1)\\n- and so on...\\n\\nFor the example 1 where `nums = [2,3,4,3,4]`, if we consider the subarray [2,3], it only consists of two elements. According to the alternating rule, the second element should be one more than the first element, which is the case here (3 is 1 more than 2). However, we can\\'t say whether it\\'s truly an alternating subarray because it does not have any more elements to check for the alternating increase and decrease pattern.\\n\\nThe subarray [3,4] is considered an alternating subarray because it\\'s part of a larger alternating subarray [3,4,3,4]. The element after 4 is 3, which is 1 less than 4, confirming the alternating pattern.\\n\\nIn general, a subarray of only two elements can be considered as the start of an alternating subarray, but it\\'s not \"alternating\" in itself because it doesn\\'t demonstrate the full increase/decrease pattern. That\\'s why [2,3] is not considered as a valid alternating subarray in this context."
                    },
                    {
                        "username": "apooos3",
                        "content": "I agree, it should be present. When you run the test case with just [2,3] it says expected result to be 2. So, it is most certainly a valid subarray."
                    },
                    {
                        "username": "GrilledSamwich",
                        "content": "Was able to solve it but felt more like a medium than an easy. Just me?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "The constraints are pretty small for it to be a medium, it can be solved directly by generating all the subarrays"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "yeah it was pretty haard"
                    },
                    {
                        "username": "medbk",
                        "content": "I am a beginner, and this is definitely not an easy level problem. I would suggest to change it to medium"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "nice one ,  pay attention to this  condition of the problem s1 = s0 + 1. "
                    },
                    {
                        "username": "Abidi_Ramzi",
                        "content": "I could only solve it after the contest due to the server issue !!\nthis contest is ruined !!\n"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Why leetcode always crash????"
                    },
                    {
                        "username": "najwer23",
                        "content": "[@sUraJ1771singH](/sUraJ1771singH) xD"
                    },
                    {
                        "username": "apooos3",
                        "content": "It's time leetcode engineers read the system design course they made for us. :')"
                    },
                    {
                        "username": "sUraJ1771singH",
                        "content": "LeetCode may crash, but our connection is like strongly connected graph and our hearts are bound together in an infinite loop of affection.."
                    },
                    {
                        "username": "mitchie",
                        "content": "Input : [14,30,29,49,3,23,44,21,26,52]\\nOutput: 2\\nExpected: -1\\n\\nHow does this make sense? 30,29 are alternating so the output should be 2?"
                    },
                    {
                        "username": "gupta_ji_813",
                        "content": "basically the 30 is at 0th index of subarray and 29 is at 1st index...so it is not satisfy the condition s1-s0=1"
                    },
                    {
                        "username": "bparanj",
                        "content": "In this problem, a subarray needs to consist of more than two elements to be considered \"alternating\". This is explicitly stated in the problem statement: \"A subarray s of length m is called alternating if m is greater than 1.\"\\n\\nWhile 30,29 is technically alternating according to the definition given, the problem statement asks for the maximum length of all alternating subarrays present in nums or -1 if no such subarray exists.\\n\\nSo, if you only find two-element subarrays that are alternating, like 30,29, they don\\'t satisfy the problem condition, and the correct output is -1.\\n\\nThe output you\\'ve mentioned is expected based on the problem\\'s conditions: it\\'s looking for alternating subarrays of more than two elements. If there are none, it returns -1."
                    },
                    {
                        "username": "apooos3",
                        "content": "Second condition: s1 = s0 + 1, the alternating sequence should start with +1 (not -1). "
                    },
                    {
                        "username": "sarrransh",
                        "content": "Maybe i am missing something but \\uD83E\\uDD72\\uD83D\\uDE05\\nFor example 2 when all the elements are different , the answer is 2\\nInput: nums = [4,5,6]\\nOutput: 2\\nExplanation: [4,5] and [5,6] are the only two alternating subarrays. They are both of length 2.\\n\\nthen why in this testcase it is -1?\\nInput\\nnums =\\n[21,9,5]\\n\\nUse Testcase\\nOutput\\n2\\nExpected\\n-1\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sarrransh",
                        "content": "[@apooos3](/apooos3) ohhhh, i get it, my bad, thanks a lot\\n"
                    },
                    {
                        "username": "apooos3",
                        "content": "Look at the second constraint `s1 = s0 + 1` \nif you had [21, 9, 10] you'd get 2, in case of [21, 9, 5], it is -1."
                    },
                    {
                        "username": "cybertrailyst",
                        "content": "guys i made this XD\\n"
                    },
                    {
                        "username": "JamesHardenSon",
                        "content": "lil bro is cracked orz"
                    }
                ]
            },
            {
                "id": 1968624,
                "content": [
                    {
                        "username": "NoMansGhost",
                        "content": "Felt like a medium-easy. Definitely a tough problem for beginners, so don't beat yourself up if you struggled with it. Look into solving Sliding Window and Two Pointers problems."
                    },
                    {
                        "username": "2uringTested",
                        "content": "The constraints are pretty small for it to be a medium, it can be solved directly by generating all the subarrays"
                    },
                    {
                        "username": "akash__ag",
                        "content": "In example 1 \\nwhy  subarray `[2,3]` is not a valid subarray"
                    },
                    {
                        "username": "apooos3",
                        "content": "[@bparanj](/bparanj) If that would be the case for input [2, 3], it should have expected result of -1 but it\\'s 2. That means it confirms it is an alternating sequence.\\nEven if you try [2, 3, 6, 3, 7] as input, it returns 2 (And apart from 2, 3, there are no other alternating sequence). So, yeah, [2, 3] is definitely a valid alternating subsequence albeit for input [2,3,4,3,4], the largest subarray following the sequence is different, but that doesn\\'t mean [2, 3] itself is not a valid subarray following the sequence."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem statement, an alternating subarray is defined as a subarray where each element alternates between increasing by 1 and decreasing by 1 compared to the previous element. In other words, if we denote the elements of the subarray as s0, s1, s2, ..., sm, it should follow this pattern:\\n\\n- s1 - s0 = 1 (increasing by 1)\\n- s2 - s1 = -1 (decreasing by 1)\\n- s3 - s2 = 1 (increasing by 1)\\n- s4 - s3 = -1 (decreasing by 1)\\n- and so on...\\n\\nFor the example 1 where `nums = [2,3,4,3,4]`, if we consider the subarray [2,3], it only consists of two elements. According to the alternating rule, the second element should be one more than the first element, which is the case here (3 is 1 more than 2). However, we can\\'t say whether it\\'s truly an alternating subarray because it does not have any more elements to check for the alternating increase and decrease pattern.\\n\\nThe subarray [3,4] is considered an alternating subarray because it\\'s part of a larger alternating subarray [3,4,3,4]. The element after 4 is 3, which is 1 less than 4, confirming the alternating pattern.\\n\\nIn general, a subarray of only two elements can be considered as the start of an alternating subarray, but it\\'s not \"alternating\" in itself because it doesn\\'t demonstrate the full increase/decrease pattern. That\\'s why [2,3] is not considered as a valid alternating subarray in this context."
                    },
                    {
                        "username": "apooos3",
                        "content": "I agree, it should be present. When you run the test case with just [2,3] it says expected result to be 2. So, it is most certainly a valid subarray."
                    },
                    {
                        "username": "GrilledSamwich",
                        "content": "Was able to solve it but felt more like a medium than an easy. Just me?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "The constraints are pretty small for it to be a medium, it can be solved directly by generating all the subarrays"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "yeah it was pretty haard"
                    },
                    {
                        "username": "medbk",
                        "content": "I am a beginner, and this is definitely not an easy level problem. I would suggest to change it to medium"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "nice one ,  pay attention to this  condition of the problem s1 = s0 + 1. "
                    },
                    {
                        "username": "Abidi_Ramzi",
                        "content": "I could only solve it after the contest due to the server issue !!\nthis contest is ruined !!\n"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Why leetcode always crash????"
                    },
                    {
                        "username": "najwer23",
                        "content": "[@sUraJ1771singH](/sUraJ1771singH) xD"
                    },
                    {
                        "username": "apooos3",
                        "content": "It's time leetcode engineers read the system design course they made for us. :')"
                    },
                    {
                        "username": "sUraJ1771singH",
                        "content": "LeetCode may crash, but our connection is like strongly connected graph and our hearts are bound together in an infinite loop of affection.."
                    },
                    {
                        "username": "mitchie",
                        "content": "Input : [14,30,29,49,3,23,44,21,26,52]\\nOutput: 2\\nExpected: -1\\n\\nHow does this make sense? 30,29 are alternating so the output should be 2?"
                    },
                    {
                        "username": "gupta_ji_813",
                        "content": "basically the 30 is at 0th index of subarray and 29 is at 1st index...so it is not satisfy the condition s1-s0=1"
                    },
                    {
                        "username": "bparanj",
                        "content": "In this problem, a subarray needs to consist of more than two elements to be considered \"alternating\". This is explicitly stated in the problem statement: \"A subarray s of length m is called alternating if m is greater than 1.\"\\n\\nWhile 30,29 is technically alternating according to the definition given, the problem statement asks for the maximum length of all alternating subarrays present in nums or -1 if no such subarray exists.\\n\\nSo, if you only find two-element subarrays that are alternating, like 30,29, they don\\'t satisfy the problem condition, and the correct output is -1.\\n\\nThe output you\\'ve mentioned is expected based on the problem\\'s conditions: it\\'s looking for alternating subarrays of more than two elements. If there are none, it returns -1."
                    },
                    {
                        "username": "apooos3",
                        "content": "Second condition: s1 = s0 + 1, the alternating sequence should start with +1 (not -1). "
                    },
                    {
                        "username": "sarrransh",
                        "content": "Maybe i am missing something but \\uD83E\\uDD72\\uD83D\\uDE05\\nFor example 2 when all the elements are different , the answer is 2\\nInput: nums = [4,5,6]\\nOutput: 2\\nExplanation: [4,5] and [5,6] are the only two alternating subarrays. They are both of length 2.\\n\\nthen why in this testcase it is -1?\\nInput\\nnums =\\n[21,9,5]\\n\\nUse Testcase\\nOutput\\n2\\nExpected\\n-1\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sarrransh",
                        "content": "[@apooos3](/apooos3) ohhhh, i get it, my bad, thanks a lot\\n"
                    },
                    {
                        "username": "apooos3",
                        "content": "Look at the second constraint `s1 = s0 + 1` \nif you had [21, 9, 10] you'd get 2, in case of [21, 9, 5], it is -1."
                    },
                    {
                        "username": "cybertrailyst",
                        "content": "guys i made this XD\\n"
                    },
                    {
                        "username": "JamesHardenSon",
                        "content": "lil bro is cracked orz"
                    }
                ]
            },
            {
                "id": 1963571,
                "content": [
                    {
                        "username": "NoMansGhost",
                        "content": "Felt like a medium-easy. Definitely a tough problem for beginners, so don't beat yourself up if you struggled with it. Look into solving Sliding Window and Two Pointers problems."
                    },
                    {
                        "username": "2uringTested",
                        "content": "The constraints are pretty small for it to be a medium, it can be solved directly by generating all the subarrays"
                    },
                    {
                        "username": "akash__ag",
                        "content": "In example 1 \\nwhy  subarray `[2,3]` is not a valid subarray"
                    },
                    {
                        "username": "apooos3",
                        "content": "[@bparanj](/bparanj) If that would be the case for input [2, 3], it should have expected result of -1 but it\\'s 2. That means it confirms it is an alternating sequence.\\nEven if you try [2, 3, 6, 3, 7] as input, it returns 2 (And apart from 2, 3, there are no other alternating sequence). So, yeah, [2, 3] is definitely a valid alternating subsequence albeit for input [2,3,4,3,4], the largest subarray following the sequence is different, but that doesn\\'t mean [2, 3] itself is not a valid subarray following the sequence."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem statement, an alternating subarray is defined as a subarray where each element alternates between increasing by 1 and decreasing by 1 compared to the previous element. In other words, if we denote the elements of the subarray as s0, s1, s2, ..., sm, it should follow this pattern:\\n\\n- s1 - s0 = 1 (increasing by 1)\\n- s2 - s1 = -1 (decreasing by 1)\\n- s3 - s2 = 1 (increasing by 1)\\n- s4 - s3 = -1 (decreasing by 1)\\n- and so on...\\n\\nFor the example 1 where `nums = [2,3,4,3,4]`, if we consider the subarray [2,3], it only consists of two elements. According to the alternating rule, the second element should be one more than the first element, which is the case here (3 is 1 more than 2). However, we can\\'t say whether it\\'s truly an alternating subarray because it does not have any more elements to check for the alternating increase and decrease pattern.\\n\\nThe subarray [3,4] is considered an alternating subarray because it\\'s part of a larger alternating subarray [3,4,3,4]. The element after 4 is 3, which is 1 less than 4, confirming the alternating pattern.\\n\\nIn general, a subarray of only two elements can be considered as the start of an alternating subarray, but it\\'s not \"alternating\" in itself because it doesn\\'t demonstrate the full increase/decrease pattern. That\\'s why [2,3] is not considered as a valid alternating subarray in this context."
                    },
                    {
                        "username": "apooos3",
                        "content": "I agree, it should be present. When you run the test case with just [2,3] it says expected result to be 2. So, it is most certainly a valid subarray."
                    },
                    {
                        "username": "GrilledSamwich",
                        "content": "Was able to solve it but felt more like a medium than an easy. Just me?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "The constraints are pretty small for it to be a medium, it can be solved directly by generating all the subarrays"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "yeah it was pretty haard"
                    },
                    {
                        "username": "medbk",
                        "content": "I am a beginner, and this is definitely not an easy level problem. I would suggest to change it to medium"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "nice one ,  pay attention to this  condition of the problem s1 = s0 + 1. "
                    },
                    {
                        "username": "Abidi_Ramzi",
                        "content": "I could only solve it after the contest due to the server issue !!\nthis contest is ruined !!\n"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Why leetcode always crash????"
                    },
                    {
                        "username": "najwer23",
                        "content": "[@sUraJ1771singH](/sUraJ1771singH) xD"
                    },
                    {
                        "username": "apooos3",
                        "content": "It's time leetcode engineers read the system design course they made for us. :')"
                    },
                    {
                        "username": "sUraJ1771singH",
                        "content": "LeetCode may crash, but our connection is like strongly connected graph and our hearts are bound together in an infinite loop of affection.."
                    },
                    {
                        "username": "mitchie",
                        "content": "Input : [14,30,29,49,3,23,44,21,26,52]\\nOutput: 2\\nExpected: -1\\n\\nHow does this make sense? 30,29 are alternating so the output should be 2?"
                    },
                    {
                        "username": "gupta_ji_813",
                        "content": "basically the 30 is at 0th index of subarray and 29 is at 1st index...so it is not satisfy the condition s1-s0=1"
                    },
                    {
                        "username": "bparanj",
                        "content": "In this problem, a subarray needs to consist of more than two elements to be considered \"alternating\". This is explicitly stated in the problem statement: \"A subarray s of length m is called alternating if m is greater than 1.\"\\n\\nWhile 30,29 is technically alternating according to the definition given, the problem statement asks for the maximum length of all alternating subarrays present in nums or -1 if no such subarray exists.\\n\\nSo, if you only find two-element subarrays that are alternating, like 30,29, they don\\'t satisfy the problem condition, and the correct output is -1.\\n\\nThe output you\\'ve mentioned is expected based on the problem\\'s conditions: it\\'s looking for alternating subarrays of more than two elements. If there are none, it returns -1."
                    },
                    {
                        "username": "apooos3",
                        "content": "Second condition: s1 = s0 + 1, the alternating sequence should start with +1 (not -1). "
                    },
                    {
                        "username": "sarrransh",
                        "content": "Maybe i am missing something but \\uD83E\\uDD72\\uD83D\\uDE05\\nFor example 2 when all the elements are different , the answer is 2\\nInput: nums = [4,5,6]\\nOutput: 2\\nExplanation: [4,5] and [5,6] are the only two alternating subarrays. They are both of length 2.\\n\\nthen why in this testcase it is -1?\\nInput\\nnums =\\n[21,9,5]\\n\\nUse Testcase\\nOutput\\n2\\nExpected\\n-1\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sarrransh",
                        "content": "[@apooos3](/apooos3) ohhhh, i get it, my bad, thanks a lot\\n"
                    },
                    {
                        "username": "apooos3",
                        "content": "Look at the second constraint `s1 = s0 + 1` \nif you had [21, 9, 10] you'd get 2, in case of [21, 9, 5], it is -1."
                    },
                    {
                        "username": "cybertrailyst",
                        "content": "guys i made this XD\\n"
                    },
                    {
                        "username": "JamesHardenSon",
                        "content": "lil bro is cracked orz"
                    }
                ]
            },
            {
                "id": 1999051,
                "content": [
                    {
                        "username": "NoMansGhost",
                        "content": "Felt like a medium-easy. Definitely a tough problem for beginners, so don't beat yourself up if you struggled with it. Look into solving Sliding Window and Two Pointers problems."
                    },
                    {
                        "username": "2uringTested",
                        "content": "The constraints are pretty small for it to be a medium, it can be solved directly by generating all the subarrays"
                    },
                    {
                        "username": "akash__ag",
                        "content": "In example 1 \\nwhy  subarray `[2,3]` is not a valid subarray"
                    },
                    {
                        "username": "apooos3",
                        "content": "[@bparanj](/bparanj) If that would be the case for input [2, 3], it should have expected result of -1 but it\\'s 2. That means it confirms it is an alternating sequence.\\nEven if you try [2, 3, 6, 3, 7] as input, it returns 2 (And apart from 2, 3, there are no other alternating sequence). So, yeah, [2, 3] is definitely a valid alternating subsequence albeit for input [2,3,4,3,4], the largest subarray following the sequence is different, but that doesn\\'t mean [2, 3] itself is not a valid subarray following the sequence."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem statement, an alternating subarray is defined as a subarray where each element alternates between increasing by 1 and decreasing by 1 compared to the previous element. In other words, if we denote the elements of the subarray as s0, s1, s2, ..., sm, it should follow this pattern:\\n\\n- s1 - s0 = 1 (increasing by 1)\\n- s2 - s1 = -1 (decreasing by 1)\\n- s3 - s2 = 1 (increasing by 1)\\n- s4 - s3 = -1 (decreasing by 1)\\n- and so on...\\n\\nFor the example 1 where `nums = [2,3,4,3,4]`, if we consider the subarray [2,3], it only consists of two elements. According to the alternating rule, the second element should be one more than the first element, which is the case here (3 is 1 more than 2). However, we can\\'t say whether it\\'s truly an alternating subarray because it does not have any more elements to check for the alternating increase and decrease pattern.\\n\\nThe subarray [3,4] is considered an alternating subarray because it\\'s part of a larger alternating subarray [3,4,3,4]. The element after 4 is 3, which is 1 less than 4, confirming the alternating pattern.\\n\\nIn general, a subarray of only two elements can be considered as the start of an alternating subarray, but it\\'s not \"alternating\" in itself because it doesn\\'t demonstrate the full increase/decrease pattern. That\\'s why [2,3] is not considered as a valid alternating subarray in this context."
                    },
                    {
                        "username": "apooos3",
                        "content": "I agree, it should be present. When you run the test case with just [2,3] it says expected result to be 2. So, it is most certainly a valid subarray."
                    },
                    {
                        "username": "GrilledSamwich",
                        "content": "Was able to solve it but felt more like a medium than an easy. Just me?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "The constraints are pretty small for it to be a medium, it can be solved directly by generating all the subarrays"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "yeah it was pretty haard"
                    },
                    {
                        "username": "medbk",
                        "content": "I am a beginner, and this is definitely not an easy level problem. I would suggest to change it to medium"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "nice one ,  pay attention to this  condition of the problem s1 = s0 + 1. "
                    },
                    {
                        "username": "Abidi_Ramzi",
                        "content": "I could only solve it after the contest due to the server issue !!\nthis contest is ruined !!\n"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Why leetcode always crash????"
                    },
                    {
                        "username": "najwer23",
                        "content": "[@sUraJ1771singH](/sUraJ1771singH) xD"
                    },
                    {
                        "username": "apooos3",
                        "content": "It's time leetcode engineers read the system design course they made for us. :')"
                    },
                    {
                        "username": "sUraJ1771singH",
                        "content": "LeetCode may crash, but our connection is like strongly connected graph and our hearts are bound together in an infinite loop of affection.."
                    },
                    {
                        "username": "mitchie",
                        "content": "Input : [14,30,29,49,3,23,44,21,26,52]\\nOutput: 2\\nExpected: -1\\n\\nHow does this make sense? 30,29 are alternating so the output should be 2?"
                    },
                    {
                        "username": "gupta_ji_813",
                        "content": "basically the 30 is at 0th index of subarray and 29 is at 1st index...so it is not satisfy the condition s1-s0=1"
                    },
                    {
                        "username": "bparanj",
                        "content": "In this problem, a subarray needs to consist of more than two elements to be considered \"alternating\". This is explicitly stated in the problem statement: \"A subarray s of length m is called alternating if m is greater than 1.\"\\n\\nWhile 30,29 is technically alternating according to the definition given, the problem statement asks for the maximum length of all alternating subarrays present in nums or -1 if no such subarray exists.\\n\\nSo, if you only find two-element subarrays that are alternating, like 30,29, they don\\'t satisfy the problem condition, and the correct output is -1.\\n\\nThe output you\\'ve mentioned is expected based on the problem\\'s conditions: it\\'s looking for alternating subarrays of more than two elements. If there are none, it returns -1."
                    },
                    {
                        "username": "apooos3",
                        "content": "Second condition: s1 = s0 + 1, the alternating sequence should start with +1 (not -1). "
                    },
                    {
                        "username": "sarrransh",
                        "content": "Maybe i am missing something but \\uD83E\\uDD72\\uD83D\\uDE05\\nFor example 2 when all the elements are different , the answer is 2\\nInput: nums = [4,5,6]\\nOutput: 2\\nExplanation: [4,5] and [5,6] are the only two alternating subarrays. They are both of length 2.\\n\\nthen why in this testcase it is -1?\\nInput\\nnums =\\n[21,9,5]\\n\\nUse Testcase\\nOutput\\n2\\nExpected\\n-1\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sarrransh",
                        "content": "[@apooos3](/apooos3) ohhhh, i get it, my bad, thanks a lot\\n"
                    },
                    {
                        "username": "apooos3",
                        "content": "Look at the second constraint `s1 = s0 + 1` \nif you had [21, 9, 10] you'd get 2, in case of [21, 9, 5], it is -1."
                    },
                    {
                        "username": "cybertrailyst",
                        "content": "guys i made this XD\\n"
                    },
                    {
                        "username": "JamesHardenSon",
                        "content": "lil bro is cracked orz"
                    }
                ]
            },
            {
                "id": 1962965,
                "content": [
                    {
                        "username": "NoMansGhost",
                        "content": "Felt like a medium-easy. Definitely a tough problem for beginners, so don't beat yourself up if you struggled with it. Look into solving Sliding Window and Two Pointers problems."
                    },
                    {
                        "username": "2uringTested",
                        "content": "The constraints are pretty small for it to be a medium, it can be solved directly by generating all the subarrays"
                    },
                    {
                        "username": "akash__ag",
                        "content": "In example 1 \\nwhy  subarray `[2,3]` is not a valid subarray"
                    },
                    {
                        "username": "apooos3",
                        "content": "[@bparanj](/bparanj) If that would be the case for input [2, 3], it should have expected result of -1 but it\\'s 2. That means it confirms it is an alternating sequence.\\nEven if you try [2, 3, 6, 3, 7] as input, it returns 2 (And apart from 2, 3, there are no other alternating sequence). So, yeah, [2, 3] is definitely a valid alternating subsequence albeit for input [2,3,4,3,4], the largest subarray following the sequence is different, but that doesn\\'t mean [2, 3] itself is not a valid subarray following the sequence."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem statement, an alternating subarray is defined as a subarray where each element alternates between increasing by 1 and decreasing by 1 compared to the previous element. In other words, if we denote the elements of the subarray as s0, s1, s2, ..., sm, it should follow this pattern:\\n\\n- s1 - s0 = 1 (increasing by 1)\\n- s2 - s1 = -1 (decreasing by 1)\\n- s3 - s2 = 1 (increasing by 1)\\n- s4 - s3 = -1 (decreasing by 1)\\n- and so on...\\n\\nFor the example 1 where `nums = [2,3,4,3,4]`, if we consider the subarray [2,3], it only consists of two elements. According to the alternating rule, the second element should be one more than the first element, which is the case here (3 is 1 more than 2). However, we can\\'t say whether it\\'s truly an alternating subarray because it does not have any more elements to check for the alternating increase and decrease pattern.\\n\\nThe subarray [3,4] is considered an alternating subarray because it\\'s part of a larger alternating subarray [3,4,3,4]. The element after 4 is 3, which is 1 less than 4, confirming the alternating pattern.\\n\\nIn general, a subarray of only two elements can be considered as the start of an alternating subarray, but it\\'s not \"alternating\" in itself because it doesn\\'t demonstrate the full increase/decrease pattern. That\\'s why [2,3] is not considered as a valid alternating subarray in this context."
                    },
                    {
                        "username": "apooos3",
                        "content": "I agree, it should be present. When you run the test case with just [2,3] it says expected result to be 2. So, it is most certainly a valid subarray."
                    },
                    {
                        "username": "GrilledSamwich",
                        "content": "Was able to solve it but felt more like a medium than an easy. Just me?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "The constraints are pretty small for it to be a medium, it can be solved directly by generating all the subarrays"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "yeah it was pretty haard"
                    },
                    {
                        "username": "medbk",
                        "content": "I am a beginner, and this is definitely not an easy level problem. I would suggest to change it to medium"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "nice one ,  pay attention to this  condition of the problem s1 = s0 + 1. "
                    },
                    {
                        "username": "Abidi_Ramzi",
                        "content": "I could only solve it after the contest due to the server issue !!\nthis contest is ruined !!\n"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Why leetcode always crash????"
                    },
                    {
                        "username": "najwer23",
                        "content": "[@sUraJ1771singH](/sUraJ1771singH) xD"
                    },
                    {
                        "username": "apooos3",
                        "content": "It's time leetcode engineers read the system design course they made for us. :')"
                    },
                    {
                        "username": "sUraJ1771singH",
                        "content": "LeetCode may crash, but our connection is like strongly connected graph and our hearts are bound together in an infinite loop of affection.."
                    },
                    {
                        "username": "mitchie",
                        "content": "Input : [14,30,29,49,3,23,44,21,26,52]\\nOutput: 2\\nExpected: -1\\n\\nHow does this make sense? 30,29 are alternating so the output should be 2?"
                    },
                    {
                        "username": "gupta_ji_813",
                        "content": "basically the 30 is at 0th index of subarray and 29 is at 1st index...so it is not satisfy the condition s1-s0=1"
                    },
                    {
                        "username": "bparanj",
                        "content": "In this problem, a subarray needs to consist of more than two elements to be considered \"alternating\". This is explicitly stated in the problem statement: \"A subarray s of length m is called alternating if m is greater than 1.\"\\n\\nWhile 30,29 is technically alternating according to the definition given, the problem statement asks for the maximum length of all alternating subarrays present in nums or -1 if no such subarray exists.\\n\\nSo, if you only find two-element subarrays that are alternating, like 30,29, they don\\'t satisfy the problem condition, and the correct output is -1.\\n\\nThe output you\\'ve mentioned is expected based on the problem\\'s conditions: it\\'s looking for alternating subarrays of more than two elements. If there are none, it returns -1."
                    },
                    {
                        "username": "apooos3",
                        "content": "Second condition: s1 = s0 + 1, the alternating sequence should start with +1 (not -1). "
                    },
                    {
                        "username": "sarrransh",
                        "content": "Maybe i am missing something but \\uD83E\\uDD72\\uD83D\\uDE05\\nFor example 2 when all the elements are different , the answer is 2\\nInput: nums = [4,5,6]\\nOutput: 2\\nExplanation: [4,5] and [5,6] are the only two alternating subarrays. They are both of length 2.\\n\\nthen why in this testcase it is -1?\\nInput\\nnums =\\n[21,9,5]\\n\\nUse Testcase\\nOutput\\n2\\nExpected\\n-1\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sarrransh",
                        "content": "[@apooos3](/apooos3) ohhhh, i get it, my bad, thanks a lot\\n"
                    },
                    {
                        "username": "apooos3",
                        "content": "Look at the second constraint `s1 = s0 + 1` \nif you had [21, 9, 10] you'd get 2, in case of [21, 9, 5], it is -1."
                    },
                    {
                        "username": "cybertrailyst",
                        "content": "guys i made this XD\\n"
                    },
                    {
                        "username": "JamesHardenSon",
                        "content": "lil bro is cracked orz"
                    }
                ]
            },
            {
                "id": 1962107,
                "content": [
                    {
                        "username": "NoMansGhost",
                        "content": "Felt like a medium-easy. Definitely a tough problem for beginners, so don't beat yourself up if you struggled with it. Look into solving Sliding Window and Two Pointers problems."
                    },
                    {
                        "username": "2uringTested",
                        "content": "The constraints are pretty small for it to be a medium, it can be solved directly by generating all the subarrays"
                    },
                    {
                        "username": "akash__ag",
                        "content": "In example 1 \\nwhy  subarray `[2,3]` is not a valid subarray"
                    },
                    {
                        "username": "apooos3",
                        "content": "[@bparanj](/bparanj) If that would be the case for input [2, 3], it should have expected result of -1 but it\\'s 2. That means it confirms it is an alternating sequence.\\nEven if you try [2, 3, 6, 3, 7] as input, it returns 2 (And apart from 2, 3, there are no other alternating sequence). So, yeah, [2, 3] is definitely a valid alternating subsequence albeit for input [2,3,4,3,4], the largest subarray following the sequence is different, but that doesn\\'t mean [2, 3] itself is not a valid subarray following the sequence."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem statement, an alternating subarray is defined as a subarray where each element alternates between increasing by 1 and decreasing by 1 compared to the previous element. In other words, if we denote the elements of the subarray as s0, s1, s2, ..., sm, it should follow this pattern:\\n\\n- s1 - s0 = 1 (increasing by 1)\\n- s2 - s1 = -1 (decreasing by 1)\\n- s3 - s2 = 1 (increasing by 1)\\n- s4 - s3 = -1 (decreasing by 1)\\n- and so on...\\n\\nFor the example 1 where `nums = [2,3,4,3,4]`, if we consider the subarray [2,3], it only consists of two elements. According to the alternating rule, the second element should be one more than the first element, which is the case here (3 is 1 more than 2). However, we can\\'t say whether it\\'s truly an alternating subarray because it does not have any more elements to check for the alternating increase and decrease pattern.\\n\\nThe subarray [3,4] is considered an alternating subarray because it\\'s part of a larger alternating subarray [3,4,3,4]. The element after 4 is 3, which is 1 less than 4, confirming the alternating pattern.\\n\\nIn general, a subarray of only two elements can be considered as the start of an alternating subarray, but it\\'s not \"alternating\" in itself because it doesn\\'t demonstrate the full increase/decrease pattern. That\\'s why [2,3] is not considered as a valid alternating subarray in this context."
                    },
                    {
                        "username": "apooos3",
                        "content": "I agree, it should be present. When you run the test case with just [2,3] it says expected result to be 2. So, it is most certainly a valid subarray."
                    },
                    {
                        "username": "GrilledSamwich",
                        "content": "Was able to solve it but felt more like a medium than an easy. Just me?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "The constraints are pretty small for it to be a medium, it can be solved directly by generating all the subarrays"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "yeah it was pretty haard"
                    },
                    {
                        "username": "medbk",
                        "content": "I am a beginner, and this is definitely not an easy level problem. I would suggest to change it to medium"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "nice one ,  pay attention to this  condition of the problem s1 = s0 + 1. "
                    },
                    {
                        "username": "Abidi_Ramzi",
                        "content": "I could only solve it after the contest due to the server issue !!\nthis contest is ruined !!\n"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Why leetcode always crash????"
                    },
                    {
                        "username": "najwer23",
                        "content": "[@sUraJ1771singH](/sUraJ1771singH) xD"
                    },
                    {
                        "username": "apooos3",
                        "content": "It's time leetcode engineers read the system design course they made for us. :')"
                    },
                    {
                        "username": "sUraJ1771singH",
                        "content": "LeetCode may crash, but our connection is like strongly connected graph and our hearts are bound together in an infinite loop of affection.."
                    },
                    {
                        "username": "mitchie",
                        "content": "Input : [14,30,29,49,3,23,44,21,26,52]\\nOutput: 2\\nExpected: -1\\n\\nHow does this make sense? 30,29 are alternating so the output should be 2?"
                    },
                    {
                        "username": "gupta_ji_813",
                        "content": "basically the 30 is at 0th index of subarray and 29 is at 1st index...so it is not satisfy the condition s1-s0=1"
                    },
                    {
                        "username": "bparanj",
                        "content": "In this problem, a subarray needs to consist of more than two elements to be considered \"alternating\". This is explicitly stated in the problem statement: \"A subarray s of length m is called alternating if m is greater than 1.\"\\n\\nWhile 30,29 is technically alternating according to the definition given, the problem statement asks for the maximum length of all alternating subarrays present in nums or -1 if no such subarray exists.\\n\\nSo, if you only find two-element subarrays that are alternating, like 30,29, they don\\'t satisfy the problem condition, and the correct output is -1.\\n\\nThe output you\\'ve mentioned is expected based on the problem\\'s conditions: it\\'s looking for alternating subarrays of more than two elements. If there are none, it returns -1."
                    },
                    {
                        "username": "apooos3",
                        "content": "Second condition: s1 = s0 + 1, the alternating sequence should start with +1 (not -1). "
                    },
                    {
                        "username": "sarrransh",
                        "content": "Maybe i am missing something but \\uD83E\\uDD72\\uD83D\\uDE05\\nFor example 2 when all the elements are different , the answer is 2\\nInput: nums = [4,5,6]\\nOutput: 2\\nExplanation: [4,5] and [5,6] are the only two alternating subarrays. They are both of length 2.\\n\\nthen why in this testcase it is -1?\\nInput\\nnums =\\n[21,9,5]\\n\\nUse Testcase\\nOutput\\n2\\nExpected\\n-1\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sarrransh",
                        "content": "[@apooos3](/apooos3) ohhhh, i get it, my bad, thanks a lot\\n"
                    },
                    {
                        "username": "apooos3",
                        "content": "Look at the second constraint `s1 = s0 + 1` \nif you had [21, 9, 10] you'd get 2, in case of [21, 9, 5], it is -1."
                    },
                    {
                        "username": "cybertrailyst",
                        "content": "guys i made this XD\\n"
                    },
                    {
                        "username": "JamesHardenSon",
                        "content": "lil bro is cracked orz"
                    }
                ]
            },
            {
                "id": 1961900,
                "content": [
                    {
                        "username": "NoMansGhost",
                        "content": "Felt like a medium-easy. Definitely a tough problem for beginners, so don't beat yourself up if you struggled with it. Look into solving Sliding Window and Two Pointers problems."
                    },
                    {
                        "username": "2uringTested",
                        "content": "The constraints are pretty small for it to be a medium, it can be solved directly by generating all the subarrays"
                    },
                    {
                        "username": "akash__ag",
                        "content": "In example 1 \\nwhy  subarray `[2,3]` is not a valid subarray"
                    },
                    {
                        "username": "apooos3",
                        "content": "[@bparanj](/bparanj) If that would be the case for input [2, 3], it should have expected result of -1 but it\\'s 2. That means it confirms it is an alternating sequence.\\nEven if you try [2, 3, 6, 3, 7] as input, it returns 2 (And apart from 2, 3, there are no other alternating sequence). So, yeah, [2, 3] is definitely a valid alternating subsequence albeit for input [2,3,4,3,4], the largest subarray following the sequence is different, but that doesn\\'t mean [2, 3] itself is not a valid subarray following the sequence."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem statement, an alternating subarray is defined as a subarray where each element alternates between increasing by 1 and decreasing by 1 compared to the previous element. In other words, if we denote the elements of the subarray as s0, s1, s2, ..., sm, it should follow this pattern:\\n\\n- s1 - s0 = 1 (increasing by 1)\\n- s2 - s1 = -1 (decreasing by 1)\\n- s3 - s2 = 1 (increasing by 1)\\n- s4 - s3 = -1 (decreasing by 1)\\n- and so on...\\n\\nFor the example 1 where `nums = [2,3,4,3,4]`, if we consider the subarray [2,3], it only consists of two elements. According to the alternating rule, the second element should be one more than the first element, which is the case here (3 is 1 more than 2). However, we can\\'t say whether it\\'s truly an alternating subarray because it does not have any more elements to check for the alternating increase and decrease pattern.\\n\\nThe subarray [3,4] is considered an alternating subarray because it\\'s part of a larger alternating subarray [3,4,3,4]. The element after 4 is 3, which is 1 less than 4, confirming the alternating pattern.\\n\\nIn general, a subarray of only two elements can be considered as the start of an alternating subarray, but it\\'s not \"alternating\" in itself because it doesn\\'t demonstrate the full increase/decrease pattern. That\\'s why [2,3] is not considered as a valid alternating subarray in this context."
                    },
                    {
                        "username": "apooos3",
                        "content": "I agree, it should be present. When you run the test case with just [2,3] it says expected result to be 2. So, it is most certainly a valid subarray."
                    },
                    {
                        "username": "GrilledSamwich",
                        "content": "Was able to solve it but felt more like a medium than an easy. Just me?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "The constraints are pretty small for it to be a medium, it can be solved directly by generating all the subarrays"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "yeah it was pretty haard"
                    },
                    {
                        "username": "medbk",
                        "content": "I am a beginner, and this is definitely not an easy level problem. I would suggest to change it to medium"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "nice one ,  pay attention to this  condition of the problem s1 = s0 + 1. "
                    },
                    {
                        "username": "Abidi_Ramzi",
                        "content": "I could only solve it after the contest due to the server issue !!\nthis contest is ruined !!\n"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Why leetcode always crash????"
                    },
                    {
                        "username": "najwer23",
                        "content": "[@sUraJ1771singH](/sUraJ1771singH) xD"
                    },
                    {
                        "username": "apooos3",
                        "content": "It's time leetcode engineers read the system design course they made for us. :')"
                    },
                    {
                        "username": "sUraJ1771singH",
                        "content": "LeetCode may crash, but our connection is like strongly connected graph and our hearts are bound together in an infinite loop of affection.."
                    },
                    {
                        "username": "mitchie",
                        "content": "Input : [14,30,29,49,3,23,44,21,26,52]\\nOutput: 2\\nExpected: -1\\n\\nHow does this make sense? 30,29 are alternating so the output should be 2?"
                    },
                    {
                        "username": "gupta_ji_813",
                        "content": "basically the 30 is at 0th index of subarray and 29 is at 1st index...so it is not satisfy the condition s1-s0=1"
                    },
                    {
                        "username": "bparanj",
                        "content": "In this problem, a subarray needs to consist of more than two elements to be considered \"alternating\". This is explicitly stated in the problem statement: \"A subarray s of length m is called alternating if m is greater than 1.\"\\n\\nWhile 30,29 is technically alternating according to the definition given, the problem statement asks for the maximum length of all alternating subarrays present in nums or -1 if no such subarray exists.\\n\\nSo, if you only find two-element subarrays that are alternating, like 30,29, they don\\'t satisfy the problem condition, and the correct output is -1.\\n\\nThe output you\\'ve mentioned is expected based on the problem\\'s conditions: it\\'s looking for alternating subarrays of more than two elements. If there are none, it returns -1."
                    },
                    {
                        "username": "apooos3",
                        "content": "Second condition: s1 = s0 + 1, the alternating sequence should start with +1 (not -1). "
                    },
                    {
                        "username": "sarrransh",
                        "content": "Maybe i am missing something but \\uD83E\\uDD72\\uD83D\\uDE05\\nFor example 2 when all the elements are different , the answer is 2\\nInput: nums = [4,5,6]\\nOutput: 2\\nExplanation: [4,5] and [5,6] are the only two alternating subarrays. They are both of length 2.\\n\\nthen why in this testcase it is -1?\\nInput\\nnums =\\n[21,9,5]\\n\\nUse Testcase\\nOutput\\n2\\nExpected\\n-1\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sarrransh",
                        "content": "[@apooos3](/apooos3) ohhhh, i get it, my bad, thanks a lot\\n"
                    },
                    {
                        "username": "apooos3",
                        "content": "Look at the second constraint `s1 = s0 + 1` \nif you had [21, 9, 10] you'd get 2, in case of [21, 9, 5], it is -1."
                    },
                    {
                        "username": "cybertrailyst",
                        "content": "guys i made this XD\\n"
                    },
                    {
                        "username": "JamesHardenSon",
                        "content": "lil bro is cracked orz"
                    }
                ]
            },
            {
                "id": 1984358,
                "content": [
                    {
                        "username": "NoMansGhost",
                        "content": "Felt like a medium-easy. Definitely a tough problem for beginners, so don't beat yourself up if you struggled with it. Look into solving Sliding Window and Two Pointers problems."
                    },
                    {
                        "username": "2uringTested",
                        "content": "The constraints are pretty small for it to be a medium, it can be solved directly by generating all the subarrays"
                    },
                    {
                        "username": "akash__ag",
                        "content": "In example 1 \\nwhy  subarray `[2,3]` is not a valid subarray"
                    },
                    {
                        "username": "apooos3",
                        "content": "[@bparanj](/bparanj) If that would be the case for input [2, 3], it should have expected result of -1 but it\\'s 2. That means it confirms it is an alternating sequence.\\nEven if you try [2, 3, 6, 3, 7] as input, it returns 2 (And apart from 2, 3, there are no other alternating sequence). So, yeah, [2, 3] is definitely a valid alternating subsequence albeit for input [2,3,4,3,4], the largest subarray following the sequence is different, but that doesn\\'t mean [2, 3] itself is not a valid subarray following the sequence."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem statement, an alternating subarray is defined as a subarray where each element alternates between increasing by 1 and decreasing by 1 compared to the previous element. In other words, if we denote the elements of the subarray as s0, s1, s2, ..., sm, it should follow this pattern:\\n\\n- s1 - s0 = 1 (increasing by 1)\\n- s2 - s1 = -1 (decreasing by 1)\\n- s3 - s2 = 1 (increasing by 1)\\n- s4 - s3 = -1 (decreasing by 1)\\n- and so on...\\n\\nFor the example 1 where `nums = [2,3,4,3,4]`, if we consider the subarray [2,3], it only consists of two elements. According to the alternating rule, the second element should be one more than the first element, which is the case here (3 is 1 more than 2). However, we can\\'t say whether it\\'s truly an alternating subarray because it does not have any more elements to check for the alternating increase and decrease pattern.\\n\\nThe subarray [3,4] is considered an alternating subarray because it\\'s part of a larger alternating subarray [3,4,3,4]. The element after 4 is 3, which is 1 less than 4, confirming the alternating pattern.\\n\\nIn general, a subarray of only two elements can be considered as the start of an alternating subarray, but it\\'s not \"alternating\" in itself because it doesn\\'t demonstrate the full increase/decrease pattern. That\\'s why [2,3] is not considered as a valid alternating subarray in this context."
                    },
                    {
                        "username": "apooos3",
                        "content": "I agree, it should be present. When you run the test case with just [2,3] it says expected result to be 2. So, it is most certainly a valid subarray."
                    },
                    {
                        "username": "GrilledSamwich",
                        "content": "Was able to solve it but felt more like a medium than an easy. Just me?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "The constraints are pretty small for it to be a medium, it can be solved directly by generating all the subarrays"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "yeah it was pretty haard"
                    },
                    {
                        "username": "medbk",
                        "content": "I am a beginner, and this is definitely not an easy level problem. I would suggest to change it to medium"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "nice one ,  pay attention to this  condition of the problem s1 = s0 + 1. "
                    },
                    {
                        "username": "Abidi_Ramzi",
                        "content": "I could only solve it after the contest due to the server issue !!\nthis contest is ruined !!\n"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Why leetcode always crash????"
                    },
                    {
                        "username": "najwer23",
                        "content": "[@sUraJ1771singH](/sUraJ1771singH) xD"
                    },
                    {
                        "username": "apooos3",
                        "content": "It's time leetcode engineers read the system design course they made for us. :')"
                    },
                    {
                        "username": "sUraJ1771singH",
                        "content": "LeetCode may crash, but our connection is like strongly connected graph and our hearts are bound together in an infinite loop of affection.."
                    },
                    {
                        "username": "mitchie",
                        "content": "Input : [14,30,29,49,3,23,44,21,26,52]\\nOutput: 2\\nExpected: -1\\n\\nHow does this make sense? 30,29 are alternating so the output should be 2?"
                    },
                    {
                        "username": "gupta_ji_813",
                        "content": "basically the 30 is at 0th index of subarray and 29 is at 1st index...so it is not satisfy the condition s1-s0=1"
                    },
                    {
                        "username": "bparanj",
                        "content": "In this problem, a subarray needs to consist of more than two elements to be considered \"alternating\". This is explicitly stated in the problem statement: \"A subarray s of length m is called alternating if m is greater than 1.\"\\n\\nWhile 30,29 is technically alternating according to the definition given, the problem statement asks for the maximum length of all alternating subarrays present in nums or -1 if no such subarray exists.\\n\\nSo, if you only find two-element subarrays that are alternating, like 30,29, they don\\'t satisfy the problem condition, and the correct output is -1.\\n\\nThe output you\\'ve mentioned is expected based on the problem\\'s conditions: it\\'s looking for alternating subarrays of more than two elements. If there are none, it returns -1."
                    },
                    {
                        "username": "apooos3",
                        "content": "Second condition: s1 = s0 + 1, the alternating sequence should start with +1 (not -1). "
                    },
                    {
                        "username": "sarrransh",
                        "content": "Maybe i am missing something but \\uD83E\\uDD72\\uD83D\\uDE05\\nFor example 2 when all the elements are different , the answer is 2\\nInput: nums = [4,5,6]\\nOutput: 2\\nExplanation: [4,5] and [5,6] are the only two alternating subarrays. They are both of length 2.\\n\\nthen why in this testcase it is -1?\\nInput\\nnums =\\n[21,9,5]\\n\\nUse Testcase\\nOutput\\n2\\nExpected\\n-1\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sarrransh",
                        "content": "[@apooos3](/apooos3) ohhhh, i get it, my bad, thanks a lot\\n"
                    },
                    {
                        "username": "apooos3",
                        "content": "Look at the second constraint `s1 = s0 + 1` \nif you had [21, 9, 10] you'd get 2, in case of [21, 9, 5], it is -1."
                    },
                    {
                        "username": "cybertrailyst",
                        "content": "guys i made this XD\\n"
                    },
                    {
                        "username": "JamesHardenSon",
                        "content": "lil bro is cracked orz"
                    }
                ]
            },
            {
                "id": 1978481,
                "content": [
                    {
                        "username": "NoMansGhost",
                        "content": "Felt like a medium-easy. Definitely a tough problem for beginners, so don't beat yourself up if you struggled with it. Look into solving Sliding Window and Two Pointers problems."
                    },
                    {
                        "username": "2uringTested",
                        "content": "The constraints are pretty small for it to be a medium, it can be solved directly by generating all the subarrays"
                    },
                    {
                        "username": "akash__ag",
                        "content": "In example 1 \\nwhy  subarray `[2,3]` is not a valid subarray"
                    },
                    {
                        "username": "apooos3",
                        "content": "[@bparanj](/bparanj) If that would be the case for input [2, 3], it should have expected result of -1 but it\\'s 2. That means it confirms it is an alternating sequence.\\nEven if you try [2, 3, 6, 3, 7] as input, it returns 2 (And apart from 2, 3, there are no other alternating sequence). So, yeah, [2, 3] is definitely a valid alternating subsequence albeit for input [2,3,4,3,4], the largest subarray following the sequence is different, but that doesn\\'t mean [2, 3] itself is not a valid subarray following the sequence."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem statement, an alternating subarray is defined as a subarray where each element alternates between increasing by 1 and decreasing by 1 compared to the previous element. In other words, if we denote the elements of the subarray as s0, s1, s2, ..., sm, it should follow this pattern:\\n\\n- s1 - s0 = 1 (increasing by 1)\\n- s2 - s1 = -1 (decreasing by 1)\\n- s3 - s2 = 1 (increasing by 1)\\n- s4 - s3 = -1 (decreasing by 1)\\n- and so on...\\n\\nFor the example 1 where `nums = [2,3,4,3,4]`, if we consider the subarray [2,3], it only consists of two elements. According to the alternating rule, the second element should be one more than the first element, which is the case here (3 is 1 more than 2). However, we can\\'t say whether it\\'s truly an alternating subarray because it does not have any more elements to check for the alternating increase and decrease pattern.\\n\\nThe subarray [3,4] is considered an alternating subarray because it\\'s part of a larger alternating subarray [3,4,3,4]. The element after 4 is 3, which is 1 less than 4, confirming the alternating pattern.\\n\\nIn general, a subarray of only two elements can be considered as the start of an alternating subarray, but it\\'s not \"alternating\" in itself because it doesn\\'t demonstrate the full increase/decrease pattern. That\\'s why [2,3] is not considered as a valid alternating subarray in this context."
                    },
                    {
                        "username": "apooos3",
                        "content": "I agree, it should be present. When you run the test case with just [2,3] it says expected result to be 2. So, it is most certainly a valid subarray."
                    },
                    {
                        "username": "GrilledSamwich",
                        "content": "Was able to solve it but felt more like a medium than an easy. Just me?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "The constraints are pretty small for it to be a medium, it can be solved directly by generating all the subarrays"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "yeah it was pretty haard"
                    },
                    {
                        "username": "medbk",
                        "content": "I am a beginner, and this is definitely not an easy level problem. I would suggest to change it to medium"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "nice one ,  pay attention to this  condition of the problem s1 = s0 + 1. "
                    },
                    {
                        "username": "Abidi_Ramzi",
                        "content": "I could only solve it after the contest due to the server issue !!\nthis contest is ruined !!\n"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Why leetcode always crash????"
                    },
                    {
                        "username": "najwer23",
                        "content": "[@sUraJ1771singH](/sUraJ1771singH) xD"
                    },
                    {
                        "username": "apooos3",
                        "content": "It's time leetcode engineers read the system design course they made for us. :')"
                    },
                    {
                        "username": "sUraJ1771singH",
                        "content": "LeetCode may crash, but our connection is like strongly connected graph and our hearts are bound together in an infinite loop of affection.."
                    },
                    {
                        "username": "mitchie",
                        "content": "Input : [14,30,29,49,3,23,44,21,26,52]\\nOutput: 2\\nExpected: -1\\n\\nHow does this make sense? 30,29 are alternating so the output should be 2?"
                    },
                    {
                        "username": "gupta_ji_813",
                        "content": "basically the 30 is at 0th index of subarray and 29 is at 1st index...so it is not satisfy the condition s1-s0=1"
                    },
                    {
                        "username": "bparanj",
                        "content": "In this problem, a subarray needs to consist of more than two elements to be considered \"alternating\". This is explicitly stated in the problem statement: \"A subarray s of length m is called alternating if m is greater than 1.\"\\n\\nWhile 30,29 is technically alternating according to the definition given, the problem statement asks for the maximum length of all alternating subarrays present in nums or -1 if no such subarray exists.\\n\\nSo, if you only find two-element subarrays that are alternating, like 30,29, they don\\'t satisfy the problem condition, and the correct output is -1.\\n\\nThe output you\\'ve mentioned is expected based on the problem\\'s conditions: it\\'s looking for alternating subarrays of more than two elements. If there are none, it returns -1."
                    },
                    {
                        "username": "apooos3",
                        "content": "Second condition: s1 = s0 + 1, the alternating sequence should start with +1 (not -1). "
                    },
                    {
                        "username": "sarrransh",
                        "content": "Maybe i am missing something but \\uD83E\\uDD72\\uD83D\\uDE05\\nFor example 2 when all the elements are different , the answer is 2\\nInput: nums = [4,5,6]\\nOutput: 2\\nExplanation: [4,5] and [5,6] are the only two alternating subarrays. They are both of length 2.\\n\\nthen why in this testcase it is -1?\\nInput\\nnums =\\n[21,9,5]\\n\\nUse Testcase\\nOutput\\n2\\nExpected\\n-1\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sarrransh",
                        "content": "[@apooos3](/apooos3) ohhhh, i get it, my bad, thanks a lot\\n"
                    },
                    {
                        "username": "apooos3",
                        "content": "Look at the second constraint `s1 = s0 + 1` \nif you had [21, 9, 10] you'd get 2, in case of [21, 9, 5], it is -1."
                    },
                    {
                        "username": "cybertrailyst",
                        "content": "guys i made this XD\\n"
                    },
                    {
                        "username": "JamesHardenSon",
                        "content": "lil bro is cracked orz"
                    }
                ]
            },
            {
                "id": 1970790,
                "content": [
                    {
                        "username": "NoMansGhost",
                        "content": "Felt like a medium-easy. Definitely a tough problem for beginners, so don't beat yourself up if you struggled with it. Look into solving Sliding Window and Two Pointers problems."
                    },
                    {
                        "username": "2uringTested",
                        "content": "The constraints are pretty small for it to be a medium, it can be solved directly by generating all the subarrays"
                    },
                    {
                        "username": "akash__ag",
                        "content": "In example 1 \\nwhy  subarray `[2,3]` is not a valid subarray"
                    },
                    {
                        "username": "apooos3",
                        "content": "[@bparanj](/bparanj) If that would be the case for input [2, 3], it should have expected result of -1 but it\\'s 2. That means it confirms it is an alternating sequence.\\nEven if you try [2, 3, 6, 3, 7] as input, it returns 2 (And apart from 2, 3, there are no other alternating sequence). So, yeah, [2, 3] is definitely a valid alternating subsequence albeit for input [2,3,4,3,4], the largest subarray following the sequence is different, but that doesn\\'t mean [2, 3] itself is not a valid subarray following the sequence."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem statement, an alternating subarray is defined as a subarray where each element alternates between increasing by 1 and decreasing by 1 compared to the previous element. In other words, if we denote the elements of the subarray as s0, s1, s2, ..., sm, it should follow this pattern:\\n\\n- s1 - s0 = 1 (increasing by 1)\\n- s2 - s1 = -1 (decreasing by 1)\\n- s3 - s2 = 1 (increasing by 1)\\n- s4 - s3 = -1 (decreasing by 1)\\n- and so on...\\n\\nFor the example 1 where `nums = [2,3,4,3,4]`, if we consider the subarray [2,3], it only consists of two elements. According to the alternating rule, the second element should be one more than the first element, which is the case here (3 is 1 more than 2). However, we can\\'t say whether it\\'s truly an alternating subarray because it does not have any more elements to check for the alternating increase and decrease pattern.\\n\\nThe subarray [3,4] is considered an alternating subarray because it\\'s part of a larger alternating subarray [3,4,3,4]. The element after 4 is 3, which is 1 less than 4, confirming the alternating pattern.\\n\\nIn general, a subarray of only two elements can be considered as the start of an alternating subarray, but it\\'s not \"alternating\" in itself because it doesn\\'t demonstrate the full increase/decrease pattern. That\\'s why [2,3] is not considered as a valid alternating subarray in this context."
                    },
                    {
                        "username": "apooos3",
                        "content": "I agree, it should be present. When you run the test case with just [2,3] it says expected result to be 2. So, it is most certainly a valid subarray."
                    },
                    {
                        "username": "GrilledSamwich",
                        "content": "Was able to solve it but felt more like a medium than an easy. Just me?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "The constraints are pretty small for it to be a medium, it can be solved directly by generating all the subarrays"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "yeah it was pretty haard"
                    },
                    {
                        "username": "medbk",
                        "content": "I am a beginner, and this is definitely not an easy level problem. I would suggest to change it to medium"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "nice one ,  pay attention to this  condition of the problem s1 = s0 + 1. "
                    },
                    {
                        "username": "Abidi_Ramzi",
                        "content": "I could only solve it after the contest due to the server issue !!\nthis contest is ruined !!\n"
                    },
                    {
                        "username": "seeker_747",
                        "content": "Why leetcode always crash????"
                    },
                    {
                        "username": "najwer23",
                        "content": "[@sUraJ1771singH](/sUraJ1771singH) xD"
                    },
                    {
                        "username": "apooos3",
                        "content": "It's time leetcode engineers read the system design course they made for us. :')"
                    },
                    {
                        "username": "sUraJ1771singH",
                        "content": "LeetCode may crash, but our connection is like strongly connected graph and our hearts are bound together in an infinite loop of affection.."
                    },
                    {
                        "username": "mitchie",
                        "content": "Input : [14,30,29,49,3,23,44,21,26,52]\\nOutput: 2\\nExpected: -1\\n\\nHow does this make sense? 30,29 are alternating so the output should be 2?"
                    },
                    {
                        "username": "gupta_ji_813",
                        "content": "basically the 30 is at 0th index of subarray and 29 is at 1st index...so it is not satisfy the condition s1-s0=1"
                    },
                    {
                        "username": "bparanj",
                        "content": "In this problem, a subarray needs to consist of more than two elements to be considered \"alternating\". This is explicitly stated in the problem statement: \"A subarray s of length m is called alternating if m is greater than 1.\"\\n\\nWhile 30,29 is technically alternating according to the definition given, the problem statement asks for the maximum length of all alternating subarrays present in nums or -1 if no such subarray exists.\\n\\nSo, if you only find two-element subarrays that are alternating, like 30,29, they don\\'t satisfy the problem condition, and the correct output is -1.\\n\\nThe output you\\'ve mentioned is expected based on the problem\\'s conditions: it\\'s looking for alternating subarrays of more than two elements. If there are none, it returns -1."
                    },
                    {
                        "username": "apooos3",
                        "content": "Second condition: s1 = s0 + 1, the alternating sequence should start with +1 (not -1). "
                    },
                    {
                        "username": "sarrransh",
                        "content": "Maybe i am missing something but \\uD83E\\uDD72\\uD83D\\uDE05\\nFor example 2 when all the elements are different , the answer is 2\\nInput: nums = [4,5,6]\\nOutput: 2\\nExplanation: [4,5] and [5,6] are the only two alternating subarrays. They are both of length 2.\\n\\nthen why in this testcase it is -1?\\nInput\\nnums =\\n[21,9,5]\\n\\nUse Testcase\\nOutput\\n2\\nExpected\\n-1\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "sarrransh",
                        "content": "[@apooos3](/apooos3) ohhhh, i get it, my bad, thanks a lot\\n"
                    },
                    {
                        "username": "apooos3",
                        "content": "Look at the second constraint `s1 = s0 + 1` \nif you had [21, 9, 10] you'd get 2, in case of [21, 9, 5], it is -1."
                    },
                    {
                        "username": "cybertrailyst",
                        "content": "guys i made this XD\\n"
                    },
                    {
                        "username": "JamesHardenSon",
                        "content": "lil bro is cracked orz"
                    }
                ]
            }
        ]
    },
    {
        "title": "Number of Unique Categories",
        "question_content": null,
        "solutions": [],
        "discussions": []
    },
    {
        "title": "Count Nodes That Are Great Enough",
        "question_content": null,
        "solutions": [],
        "discussions": []
    }
]