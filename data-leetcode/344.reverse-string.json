[
    {
        "title": "Wildcard Matching",
        "question_content": "Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*' where:\n\n\t'?' Matches any single character.\n\t'*' Matches any sequence of characters (including the empty sequence).\n\nThe matching should cover the entire input string (not partial).\n&nbsp;\nExample 1:\n\nInput: s = \"aa\", p = \"a\"\nOutput: false\nExplanation: \"a\" does not match the entire string \"aa\".\n\nExample 2:\n\nInput: s = \"aa\", p = \"*\"\nOutput: true\nExplanation:&nbsp;'*' matches any sequence.\n\nExample 3:\n\nInput: s = \"cb\", p = \"?a\"\nOutput: false\nExplanation:&nbsp;'?' matches 'c', but the second letter is 'a', which does not match 'b'.\n\n&nbsp;\nConstraints:\n\n\t0 <= s.length, p.length <= 2000\n\ts contains only lowercase English letters.\n\tp contains only lowercase English letters, '?' or '*'.",
        "solutions": [
            {
                "id": 17810,
                "title": "linear-runtime-and-constant-space-solution",
                "content": "I found this solution from http://yucoding.blogspot.com/2013/02/leetcode-question-123-wildcard-matching.html\\n\\n\\n----------\\n\\n\\nThe basic idea is to have one pointer for the string and one pointer for the pattern.  This algorithm iterates at most length(string) + length(pattern) times, for each iteration, at least one pointer advance one step. \\n\\n\\n----------\\n\\nHere is Yu's elegant solution in C++\\n\\n     bool isMatch(const char *s, const char *p) {\\n            const char* star=NULL;\\n            const char* ss=s;\\n            while (*s){\\n                //advancing both pointers when (both characters match) or ('?' found in pattern)\\n                //note that *p will not advance beyond its length \\n                if ((*p=='?')||(*p==*s)){s++;p++;continue;} \\n\\n                // * found in pattern, track index of *, only advancing pattern pointer \\n                if (*p=='*'){star=p++; ss=s;continue;} \\n\\n                //current characters didn't match, last pattern pointer was *, current pattern pointer is not *\\n                //only advancing pattern pointer\\n                if (star){ p = star+1; s=++ss;continue;} \\n\\n               //current pattern pointer is not star, last patter pointer was not *\\n               //characters do not match\\n                return false;\\n            }\\n \\n           //check for remaining characters in pattern\\n            while (*p=='*'){p++;}\\n\\n            return !*p;  \\n        }\\n\\n\\n----------\\n\\n\\nHere is my re-write in Java\\n\\n    \\ufeff\\ufeff\\ufeffboolean comparison(String str, String pattern) {\\n            int s = 0, p = 0, match = 0, starIdx = -1;            \\n            while (s < str.length()){\\n                // advancing both pointers\\n                if (p < pattern.length()  && (pattern.charAt(p) == '?' || str.charAt(s) == pattern.charAt(p))){\\n                    s++;\\n                    p++;\\n                }\\n                // * found, only advancing pattern pointer\\n                else if (p < pattern.length() && pattern.charAt(p) == '*'){\\n                    starIdx = p;\\n                    match = s;\\n                    p++;\\n                }\\n               // last pattern pointer was *, advancing string pointer\\n                else if (starIdx != -1){\\n                    p = starIdx + 1;\\n                    match++;\\n                    s = match;\\n                }\\n               //current pattern pointer is not star, last patter pointer was not *\\n              //characters do not match\\n                else return false;\\n            }\\n            \\n            //check for remaining characters in pattern\\n            while (p < pattern.length() && pattern.charAt(p) == '*')\\n                p++;\\n            \\n            return p == pattern.length();\\n    }",
                "solutionTags": [],
                "code": "I found this solution from http://yucoding.blogspot.com/2013/02/leetcode-question-123-wildcard-matching.html\\n\\n\\n----------\\n\\n\\nThe basic idea is to have one pointer for the string and one pointer for the pattern.  This algorithm iterates at most length(string) + length(pattern) times, for each iteration, at least one pointer advance one step. \\n\\n\\n----------\\n\\nHere is Yu's elegant solution in C++\\n\\n     bool isMatch(const char *s, const char *p) {\\n            const char* star=NULL;\\n            const char* ss=s;\\n            while (*s){\\n                //advancing both pointers when (both characters match) or ('?' found in pattern)\\n                //note that *p will not advance beyond its length \\n                if ((*p=='?')||(*p==*s)){s++;p++;continue;} \\n\\n                // * found in pattern, track index of *, only advancing pattern pointer \\n                if (*p=='*'){star=p++; ss=s;continue;} \\n\\n                //current characters didn't match, last pattern pointer was *, current pattern pointer is not *\\n                //only advancing pattern pointer\\n                if (star){ p = star+1; s=++ss;continue;} \\n\\n               //current pattern pointer is not star, last patter pointer was not *\\n               //characters do not match\\n                return false;\\n            }\\n \\n           //check for remaining characters in pattern\\n            while (*p=='*'){p++;}\\n\\n            return !*p;  \\n        }\\n\\n\\n----------\\n\\n\\nHere is my re-write in Java\\n\\n    \\ufeff\\ufeff\\ufeffboolean comparison(String str, String pattern) {\\n            int s = 0, p = 0, match = 0, starIdx = -1;            \\n            while (s < str.length()){\\n                // advancing both pointers\\n                if (p < pattern.length()  && (pattern.charAt(p) == '?' || str.charAt(s) == pattern.charAt(p))){\\n                    s++;\\n                    p++;\\n                }\\n                // * found, only advancing pattern pointer\\n                else if (p < pattern.length() && pattern.charAt(p) == '*'){\\n                    starIdx = p;\\n                    match = s;\\n                    p++;\\n                }\\n               // last pattern pointer was *, advancing string pointer\\n                else if (starIdx != -1){\\n                    p = starIdx + 1;\\n                    match++;\\n                    s = match;\\n                }\\n               //current pattern pointer is not star, last patter pointer was not *\\n              //characters do not match\\n                else return false;\\n            }\\n            \\n            //check for remaining characters in pattern\\n            while (p < pattern.length() && pattern.charAt(p) == '*')\\n                p++;\\n            \\n            return p == pattern.length();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 17812,
                "title": "my-java-dp-solution-using-2d-table",
                "content": "    public class Solution {\\n        public boolean isMatch(String s, String p) {\\n            boolean[][] match=new boolean[s.length()+1][p.length()+1];\\n            match[s.length()][p.length()]=true;\\n            for(int i=p.length()-1;i>=0;i--){\\n                if(p.charAt(i)!='*')\\n                    break;\\n                else\\n                    match[s.length()][i]=true;\\n            }\\n            for(int i=s.length()-1;i>=0;i--){\\n                for(int j=p.length()-1;j>=0;j--){\\n                    if(s.charAt(i)==p.charAt(j)||p.charAt(j)=='?')\\n                            match[i][j]=match[i+1][j+1];\\n                    else if(p.charAt(j)=='*')\\n                            match[i][j]=match[i+1][j]||match[i][j+1];\\n                    else\\n                        match[i][j]=false;\\n                }\\n            }\\n            return match[0][0];\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n        public boolean isMatch(String s, String p) {\\n            boolean[][] match=new boolean[s.length()+1][p.length()+1];\\n            match[s.length()][p.length()]=true;\\n            for(int i=p.length()-1;i>=0;i--){\\n                if(p.charAt(i)!='*')\\n                    break;\\n                else\\n                    match[s.length()][i]=true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 138878,
                "title": "finite-state-machine-with-python-dictionary-13-lines-o-p-s-time",
                "content": "```python\\nclass Solution(object):\\n    def isMatch(self, s, p):\\n        \"\"\"\\n        :type s: str\\n        :type p: str\\n        :rtype: bool\\n        \"\"\"\\n        transfer = {}\\n        state = 0\\n        \\n        for char in p:\\n            if char == \\'*\\':\\n                transfer[state, char] = state\\n            else:\\n                transfer[state, char] = state + 1\\n                state += 1\\n        \\n        accept = state\\n        states = {0}\\n        \\n        for char in s:\\n            states = {transfer.get((at, token)) for at in states if at is not None for token in (char, \\'*\\', \\'?\\')}\\n        \\n        return accept in states\\n```\\n\\nAbout finite-state machine: https://en.wikipedia.org/wiki/Finite-state_machine\\n\\nThe string pattern matching can be seen as running a FSM. For example, you can use the following FSM to represent pattern `a*c?b`. \\nYou always start at state 0, and take each character of `s` as a \"token\". When a token matches the label on a link, you can transfer from one state to another via that link. `*` and `?` are special tokens that can match any token, or in other words, you can always transfer via a `*` or `?` link regardless of what token is fed from `s`. At the end, if you reach the final state, called the accepting state (state 4 in our example), that means you\\'ve got a match. \\n`*` and `?` are slightly different: `?` can match only 1 character, which means after you transfer via a `?` link, you can\\'t traverse it again, but after you transfer via a `*` link, you still have access to it, infinitely. This is why a `?` link takes you to a new state, while a `*` link takes you back to where it starts, thus this link can be traversed infinitely.\\nDue to the behavior of `*` links, you may have access to multiple states from a certain state. E.g. at state 1 below, with a token `c` you can transfer via the `c` link and arrive at 2, or transfer via the `*` link to arrive back at state 1. As a result, you can be at multiple states simultenaously (think of parallel universes). Among all the states you \"can be at\", you only need one of them being the accepting state to conclude a successful match.\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/guozhenli/image_1529467714.png)\\n\\nThe first `for` loop builds up a FSM from `p`. The states of the machine are labeled as 0, 1, 2, ... The last state reached during the FSM building is the accepting state.\\n\\nThe second `for` loop scans string `s` and run the FSM, by tracking what `states` the machine is at, and what `token` is read from `s`. The `*` and `?` tokens are always available. Because you can be at multiple states at the same time, in the second loop the `states` variable is a set of integers, rather than a single integer.\\n\\nFinally, if any of the state the FSM has reached matches the accepting state, we can conclude `s` and `p` match, otherwise they don\\'t match.\\n\\n\\n\\nThe first loop (FSM building) takes O(p) time. The second loop (string scanning) iterates over `s` once, thus O(s) iterations. Overall there are O(p+s) iterations. However, more strictly speaking in each iteration of the `for char in s` loop, you also iterate through all states you may be at (`for at in states`), which can be as many interations as the number of `*`\\'s in `p`, which is bounded by p. Thus the overall complexity in worst case is O(p+sp). If you believe the number of `*`\\'s in `p` can be bounded by a constant, then the overall complexity can be reduced to O(p+s).\\n\\nThe FSM diagram was drawn with [Finite State Machine Designer - by Evan Wallace](http://madebyevan.com/fsm/).\\n\\n**[Update 2020-02-08]**\\n\\nThanks to the very insightful comments from @ericauld , I\\'m realizing the connections between the FSM solution and DP solutions. I really like this finding so I\\'m happily writing it down with some visualization.\\n\\nQuote @ericauld\\n> it\\'s nice to think of it as a decision tree with nodes corresponding to pairs (state, location in s). That leaves the approach open to different types of solutions, and makes the problem more clear. We can traverse this decision tree in breadth-first fashion, as you do, or in depth-first fashion, as other solutions do. I think saying \"you can be in multiple states at the same time\" obscures what\\'s really going on and is confusing. Thanks for helping me think of the problem more clearly.\\n\\nTo visualize this, imagine matching string `acccb` with pattern `a*c?b` again. The FSM is set up the same as above, and your journey down the path will look like this:\\n![image](https://assets.leetcode.com/users/guozhenli/image_1581232923.png)\\nEach node in this diagram means <state in FSM, substring matched so far>. Starting at 0, where your only choice with string token \\'a\\' is to match with \\'a\\' in pattern, and arrive at state 1. At state 1, you have the next token in `s` -- \\'c\\' to work with, and your choices are to mathch it with \\'\\\\*\\' thus circle back to state 1 (the \\'c=\\\\*\\' arrow), or to match \\'c\\' of `s` with \\'c\\' of `p` and go to state 2 (the \\'c=c\\' arrow). In either case, you\\'ve matched \\'ac\\' so far. Keep doing this, when you\\'ve used all tokens in `s` you\\'re at the leaves to the right-most side, and the states you could be at are {1, 3, 4}, which is actually the final value of `states` at `return` time in my code above. Among these states, 4 is an accepting state, so we return `True`.\\n\\nNow that nodes in the same column/depth of this decision tree have the same \"substring matched so far\" value, bring them up to top, make a row for each state, and mark every valid node with a \"T\", we get:\\n|   | \\'\\' | a | ac | acc | accc | acccb |\\n|---|----|---|----|-----|------|-------|\\n| 0 | T  |   |    |     |      |       |\\n| 1 |    | T | T  | T   | T    | T     |\\n| 2 |    |   | T  | T   | T    |       |\\n| 3 |    |   |    | T   | T    | T     |\\n| 4 |    |   |    |     |      | T     |\\n\\nHere you go the DP table! Other DP solutions essentially fill this table row-by-row from top down (DFS), and the FSM solution essentially fills it column-by-column from left to right (BFS).\\n\\n**[Update 2020-07-08]**\\nA few slight changes to squeeze some performance:\\nThe line `states = ...` changed from\\n```python\\nstates = set([transfer.get((at, token)) for at in states for token in [char, \\'*\\', \\'?\\']])\\n```\\nto\\n```python\\nstates = {transfer.get((at, token)) for at in states if at is not None for token in (char, \\'*\\', \\'?\\')}\\n```\\n\\n3 things happened here:\\n1. `set([...])` to `{...}` -- to avoid creating a list before converting it to a set; instead, construct a set directly\\n2. `for at in states` to `for at in states if at is not None` -- to avoid executing `transfer.get((None, token))`, which we know is not any useful, potentially many times. (Thanks to comment from @Xyzzy123 for pointing out this inefficiency.)\\n3. `token in [char, \\'*\\', \\'?\\']` to `for token in (char, \\'*\\', \\'?\\')` -- because [constructing a tuple is faster than cosntructing a list](https://stackoverflow.com/questions/3340539/why-is-tuple-faster-than-list-in-python)",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def isMatch(self, s, p):\\n        \"\"\"\\n        :type s: str\\n        :type p: str\\n        :rtype: bool\\n        \"\"\"\\n        transfer = {}\\n        state = 0\\n        \\n        for char in p:\\n            if char == \\'*\\':\\n                transfer[state, char] = state\\n            else:\\n                transfer[state, char] = state + 1\\n                state += 1\\n        \\n        accept = state\\n        states = {0}\\n        \\n        for char in s:\\n            states = {transfer.get((at, token)) for at in states if at is not None for token in (char, \\'*\\', \\'?\\')}\\n        \\n        return accept in states\\n```\n```python\\nstates = set([transfer.get((at, token)) for at in states for token in [char, \\'*\\', \\'?\\']])\\n```\n```python\\nstates = {transfer.get((at, token)) for at in states if at is not None for token in (char, \\'*\\', \\'?\\')}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1001130,
                "title": "c-clean-and-concise-bottom-up-dp-code-with-detailed-explanation-easy-to-understand",
                "content": "This question is similar to [10. Regular Expression Matching](https://leetcode.com/problems/regular-expression-matching/), and both question can be solved using dynamic programming.\\n\\nFirst, we need to create a 2d dp table `dp`. The size of this table is `(s.size() + 1) * (p.size() + 1)`. We introduce `+1` here to better handle the edge cases where we have an empty string or an empty pattern. `dp[i][j]` means whether the substring from index `0` to `i - 1` of the original string `s` matches with the subpattern from index `0` to `j - 1` of the original pattern `p`.\\n\\nNext, we initialize the base cases. There are three base cases:\\n1. **When both the string and the pattern are empty.**\\n\\tAlways match. `dp[0][0] = true;`\\n2. **When only the string is empty.**\\n\\tOnly if the subpattern only consists of  `*`, we have a match. \\n3. **When only the pattern is empty.**\\n\\tAlways not match.\\n\\t\\nThere are two special characters that we need to take special care in the pattern.\\n1. `?`\\n\\tThis is actually easy to deal with. Everytime when we encounter this, we can consider it matches with any character in the string. Say we are currently at `dp[i][j]`, and we have `p[j - 1] == \\'?\\'`, then we know it matches with `s[i - 1]`, no matter what `s[i - 1]` actually is.\\n2. `*`\\n\\tThis is slightly hard to deal with. A small technique while dealing this kind of question is to actually draw out the dp table, and try to fill out the table manually, when the state transfer function is not very straightforward. Everything will become much clearer after you fill out one row or two.\\n\\tWhen we encounter a `*` in the pattern, and assuming that we\\'re currently trying to figure out what `dp[i][j]` is. Then we need to consider two cases if `p[j - 1] == \\'*\\'`.\\n\\t1. **Is `dp[i - 1][j]` true?**\\n\\t\\tIf yes, it means the current subpattern `p[0...j - 1]` we have matches the substring `s[0... i - 2]`. Then will `p[0...j - 1]` match with `s[0... i - 1]`? The answer is yes, because `*` can match any sequence of characters, so it\\'s able to match one more character `s[i - 1]`.\\n\\t2. **Is `dp[i][j - 1]` true?**\\n\\t\\tIf yes, it just means the current substring `s[0...i - 1]` matches with the subpattern `p[0...j - 2]`. Therefore, if we add one more `*` into the subpattern, it will also match as `*` can match empty subsequence.\\n\\t\\t\\n\\n##### O(mn) space\\n**Note**: `m` means the size of the string, `n` means the size of the pattern.\\n```cpp\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        vector<vector<bool>> dp(s.size() + 1, vector(p.size() + 1, false));\\n        dp[0][0] = true;\\n        for (int j = 0; j < p.size() && p[j] == \\'*\\'; ++j) {\\n            dp[0][j + 1] = true;\\n        }\\n        \\n        for (int i = 1; i <= s.size(); ++i) {\\n            for (int j = 1; j <= p.size(); ++j) {\\n                if (p[j - 1] == \\'*\\') {\\n                    dp[i][j] = dp[i - 1][j] || dp[i][j - 1];\\n                } else {\\n                    dp[i][j] = (s[i - 1] == p[j - 1] || p[j - 1] == \\'?\\') && dp[i - 1][j - 1];\\n                }\\n            }\\n        }\\n\\n        return dp[s.size()][p.size()];\\n    }\\n};\\n```\\n\\n##### O(n) space\\nWe can also use 1d table to solve this problem, but the code will be less readable.\\n**Note**: `n` means the size of the pattern.\\n```cpp\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        vector<bool> dp(p.size() + 1, false);\\n        dp[0] = true;\\n        for (int j = 0; j < p.size() && p[j] == \\'*\\'; ++j) {\\n            dp[j + 1] = true;\\n        }\\n        \\n        for (int i = 1; i <= s.size(); ++i) {\\n            dp[0] = false;\\n            bool neighborLastRow = i == 1;\\n            for (int j = 1; j <= p.size(); ++j) {\\n                bool currLastRow = dp[j];\\n                if (p[j - 1] == \\'*\\') {\\n                    dp[j] = currLastRow || dp[j - 1];\\n                } else {\\n                    dp[j] = (s[i - 1] == p[j - 1] || p[j - 1] == \\'?\\') && neighborLastRow;\\n                }\\n                neighborLastRow = currLastRow;\\n            }\\n        }\\n\\n        return dp[p.size()];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        vector<vector<bool>> dp(s.size() + 1, vector(p.size() + 1, false));\\n        dp[0][0] = true;\\n        for (int j = 0; j < p.size() && p[j] == \\'*\\'; ++j) {\\n            dp[0][j + 1] = true;\\n        }\\n        \\n        for (int i = 1; i <= s.size(); ++i) {\\n            for (int j = 1; j <= p.size(); ++j) {\\n                if (p[j - 1] == \\'*\\') {\\n                    dp[i][j] = dp[i - 1][j] || dp[i][j - 1];\\n                } else {\\n                    dp[i][j] = (s[i - 1] == p[j - 1] || p[j - 1] == \\'?\\') && dp[i - 1][j - 1];\\n                }\\n            }\\n        }\\n\\n        return dp[s.size()][p.size()];\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        vector<bool> dp(p.size() + 1, false);\\n        dp[0] = true;\\n        for (int j = 0; j < p.size() && p[j] == \\'*\\'; ++j) {\\n            dp[j + 1] = true;\\n        }\\n        \\n        for (int i = 1; i <= s.size(); ++i) {\\n            dp[0] = false;\\n            bool neighborLastRow = i == 1;\\n            for (int j = 1; j <= p.size(); ++j) {\\n                bool currLastRow = dp[j];\\n                if (p[j - 1] == \\'*\\') {\\n                    dp[j] = currLastRow || dp[j - 1];\\n                } else {\\n                    dp[j] = (s[i - 1] == p[j - 1] || p[j - 1] == \\'?\\') && neighborLastRow;\\n                }\\n                neighborLastRow = currLastRow;\\n            }\\n        }\\n\\n        return dp[p.size()];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 256025,
                "title": "python-dp-with-illustration",
                "content": "I had to look at other solutions for the top row, we set values to true until a non \"*\" character is found\\n```\\nclass Solution:\\n    def isMatch(self, s, p):\\n        dp = [[False for _ in range(len(p)+1)] for i in range(len(s)+1)]\\n        dp[0][0] = True\\n        for j in range(1, len(p)+1):\\n            if p[j-1] != \\'*\\':\\n                break\\n            dp[0][j] = True\\n                \\n        for i in range(1, len(s)+1):\\n            for j in range(1, len(p)+1):\\n                if p[j-1] in {s[i-1], \\'?\\'}:\\n                    dp[i][j] = dp[i-1][j-1]\\n                elif p[j-1] == \\'*\\':\\n                    dp[i][j] = dp[i-1][j] or dp[i][j-1]\\n        return dp[-1][-1]\\n```\\n![image](https://assets.leetcode.com/users/etherealoptimist/image_1552687196.png)\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def isMatch(self, s, p):\\n        dp = [[False for _ in range(len(p)+1)] for i in range(len(s)+1)]\\n        dp[0][0] = True\\n        for j in range(1, len(p)+1):\\n            if p[j-1] != \\'*\\':\\n                break\\n            dp[0][j] = True\\n                \\n        for i in range(1, len(s)+1):\\n            for j in range(1, len(p)+1):\\n                if p[j-1] in {s[i-1], \\'?\\'}:\\n                    dp[i][j] = dp[i-1][j-1]\\n                elif p[j-1] == \\'*\\':\\n                    dp[i][j] = dp[i-1][j] or dp[i][j-1]\\n        return dp[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17833,
                "title": "accepted-c-dp-solution-with-a-trick",
                "content": "**Updated**: Since the OJ has relaxed the time constraint, the following DP solution is now accepted without the trick :-) \\n\\nWell, so many people has tried to solve this problem using DP. And almost all of them get TLE (if you see a **C++** DP solution that gets accepted, please let me know ^_^). Well, this post aims at providing an **accpted** DP solution which uses a **trick** to get around the largest test case, insteaed of a solution that is **fully correct**. So please do not give me down votes for that :-) \\n\\nLet's briefly summarize the idea of DP. We define the state `P[i][j]` to be whether `s[0..i)` matches `p[0..j)`. The state equations are as follows: \\n\\n 1. `P[i][j] = P[i - 1][j - 1] && (s[i - 1] == p[j - 1] || p[j - 1] == '?')`, if `p[j - 1] != '*'`;\\n 2. `P[i][j] = P[i][j - 1] || P[i - 1][j]`, if `p[j - 1] == '*'`.\\n\\nIf you feel confused with the second equation, you may refer to [this link][1]. There is an explanation in the comments.\\n\\nWe optimize the DP code to `O(m)` space by recording `P[i - 1][j - 1]` using a single variable `pre`.\\n\\nThe trick to avoid TLE is to hard-code the result for the largest test case by \\n\\n    if (n > 30000) return false;  \\n\\nThe complete code is as follows.\\n\\n    class Solution {\\n    public:\\n        bool isMatch(string s, string p) { \\n            int m = s.length(), n = p.length();\\n            if (n > 30000) return false; // the trick\\n            vector<bool> cur(m + 1, false); \\n            cur[0] = true;\\n            for (int j = 1; j <= n; j++) {\\n                bool pre = cur[0]; // use the value before update\\n                cur[0] = cur[0] && p[j - 1] == '*'; \\n                for (int i = 1; i <= m; i++) {\\n                    bool temp = cur[i]; // record the value before update\\n                    if (p[j - 1] != '*')\\n                        cur[i] = pre && (s[i - 1] == p[j - 1] || p[j - 1] == '?');\\n                    else cur[i] = cur[i - 1] || cur[i];\\n                    pre = temp;\\n                }\\n            }\\n            return cur[m]; \\n        }\\n    };\\n\\nFor those interested in a fully correct solution, [this link][2] has a nice Greedy solution. And I have rewritten the code below to fit the new C++ interface (changed from `char*` to `string`).\\n\\n    class Solution {\\n    public:\\n        bool isMatch(string s, string p) {\\n            int m = s.length(), n = p.length();\\n            int i = 0, j = 0, asterisk = -1, match;\\n            while (i < m) {\\n                if (j < n && p[j] == '*') {\\n                    match = i; \\n                    asterisk = j++;\\n                }\\n                else if (j < n && (s[i] == p[j] || p[j] == '?')) {\\n                    i++; \\n                    j++;\\n                }\\n                else if (asterisk >= 0) {\\n                    i = ++match;\\n                    j = asterisk + 1;\\n                }\\n                else return false;\\n            }\\n            while (j < n && p[j] == '*') j++;\\n            return j == n;\\n        }\\n    };\\n\\n  [1]: https://leetcode.com/discuss/21634/c-dp-solution\\n  [2]: https://leetcode.com/discuss/10133/linear-runtime-and-constant-space-solution",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public:\\n        bool isMatch(string s, string p) { \\n            int m = s.length(), n = p.length();\\n            if (n > 30000) return false; // the trick\\n            vector<bool> cur(m + 1, false); \\n            cur[0] = true;\\n            for (int j = 1; j <= n; j++) {\\n                bool pre = cur[0]; // use the value before update\\n                cur[0] = cur[0] && p[j - 1] == '*'; \\n                for (int i = 1; i <= m; i++) {\\n                    bool temp = cur[i]; // record the value before update\\n                    if (p[j - 1] != '*')\\n                        cur[i] = pre && (s[i - 1] == p[j - 1] || p[j - 1] == '?');\\n                    else cur[i] = cur[i - 1] || cur[i];\\n                    pre = temp;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1336621,
                "title": "python-dfs-with-memoization-clean-concise",
                "content": "```python\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        @lru_cache(None)\\n        def dfs(i, j):\\n            if j == len(p):  # Reach full pattern\\n                return i == len(s)\\n\\n            if i < len(s) and (s[i] == p[j] or p[j] == \\'?\\'):  # Match Single character\\n                return dfs(i + 1, j + 1)\\n            \\n            if p[j] == \\'*\\':\\n                return dfs(i, j + 1) or i < len(s) and dfs(i + 1, j)  # Match zero or one or more character\\n            \\n            return False\\n\\n        return dfs(0, 0)\\n```\\nComplexity:\\n- Time: `O(M * N)`, where `M <= 2000` is the length of string `s`, `N <= 2000` is the length of string `t`.\\n- Space: `O(M * N)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        @lru_cache(None)\\n        def dfs(i, j):\\n            if j == len(p):  # Reach full pattern\\n                return i == len(s)\\n\\n            if i < len(s) and (s[i] == p[j] or p[j] == \\'?\\'):  # Match Single character\\n                return dfs(i + 1, j + 1)\\n            \\n            if p[j] == \\'*\\':\\n                return dfs(i, j + 1) or i < len(s) and dfs(i + 1, j)  # Match zero or one or more character\\n            \\n            return False\\n\\n        return dfs(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17859,
                "title": "evolve-from-brute-force-to-optimal",
                "content": "This is similar to [regular expression matching ](https://discuss.leetcode.com/topic/54908/evolve-from-brute-force-to-dp) but more tricky.\\n1. Recursion O(2^n), * matches 0 or more chars.\\n```\\n    bool isMatch(string s, string p) {\\n        return isMatch(0,0,s,p);    \\n    }\\n    bool isMatch(int i, int j, string& s, string& p) {\\n        int sn = s.size();\\n        if(j==p.size()) return i==sn;\\n        if(p[j]==\\'*\\') {\\n            for(int k=i;k<=sn;k++) if(isMatch(k,j+1,s,p)) return 1;\\n            return 0;\\n        }\\n        if(i<sn && (p[j]==\\'?\\'||s[i]==p[j])) return isMatch(i+1,j+1,s,p);\\n        return 0;\\n    }\\n```\\n2. Use recursion instead of iteration when * matches non empty string, O(2^n)\\n* c++\\n```\\n    bool isMatch(string s, string p) {\\n        return isMatch(0,0,s,p);    \\n    }\\n    bool isMatch(int i, int j, string& s, string& p) {\\n        int sn = s.size();\\n        if(j==p.size()) return i==sn;\\n        if(p[j]==\\'*\\') return isMatch(i,j+1,s,p) || (i<sn && isMatch(i+1,j,s,p));\\n        if(i<sn && (p[j]==\\'?\\'|| s[i]==p[j])) return isMatch(i+1,j+1,s,p);\\n        return 0;\\n    }\\n```\\n* java\\n```\\n\\tpublic boolean isMatch(String s, String p) {\\n        return isMatch(0, s, 0, p);\\n    }\\n    private boolean isMatch(int i, String s, int j, String p) {\\n        int sn = s.length(), pn = p.length();\\n        if(j==pn) {\\n            return i==sn;\\n        }\\n        char pj = p.charAt(j);\\n        if(i<sn && pj == \\'?\\') {\\n            return isMatch(i+1, s, j+1, p);\\n        } else if(pj == \\'*\\') {\\n            return isMatch(i,s,j+1,p) || i<sn && isMatch(i+1,s,j,p);   \\n        } else if(i<sn && pj == s.charAt(i)) {\\n            return isMatch(i+1, s, j+1, p);\\n        }\\n        return false;\\n    }\\n```\\n3. Memorization O(n^2), memorization turns out to be faster than dp. I think it is because dfs terminates as soon as a match is found but dp is always n^2.  \\n* c++\\n```\\n    bool isMatch(string s, string p) {\\n        vector<vector<char>> mem(s.size()+1,vector<char>(p.size(),-1));\\n        return isMatch(0,0,s,p,mem);    \\n    }\\n    bool isMatch(int i, int j, string& s, string& p,vector<vector<char>> &mem) {\\n        int sn = s.size();\\n        if(j==p.size()) return i==sn;\\n        if(mem[i][j]!=-1) return mem[i][j];\\n        if(p[j]==\\'*\\') return mem[i][j]= isMatch(i,j+1,s,p,mem) || (i<sn && isMatch(i+1,j,s,p,mem));\\n        if(i<sn && (p[j]==\\'?\\'|| s[i]==p[j])) return mem[i][j]=isMatch(i+1,j+1,s,p,mem);\\n        return mem[i][j]=0;\\n    }\\n```\\n* java\\n```\\n\\tBoolean[][] mem;\\n    public boolean isMatch(String s, String p) {\\n        mem = new Boolean[s.length()+1][p.length()+1];\\n        return isMatch(0, s, 0, p);\\n    }\\n    private boolean isMatch(int i, String s, int j, String p) {\\n        int sn = s.length(), pn = p.length();\\n        if(j==pn) {\\n            return i==sn;\\n        }\\n        if(mem[i][j] != null) {\\n            return mem[i][j];\\n        }\\n        char pj = p.charAt(j);\\n        if(i<sn && pj == \\'?\\') {\\n            return mem[i][j] = isMatch(i+1, s, j+1, p);\\n        } else if(pj == \\'*\\') {\\n            return mem[i][j] = isMatch(i,s,j+1,p) || i<sn && isMatch(i+1,s,j,p);   \\n        } else if(i<sn && pj == s.charAt(i)) {\\n            return mem[i][j] = isMatch(i+1, s, j+1, p);\\n        }\\n        return mem[i][j] = false;\\n    }\\n```\\n4. dp O(n^2)\\n```\\n    bool isMatch(string s, string p) {\\n        int sn = s.size(), pn = p.size();\\n        vector<vector<bool>> dp(sn+1,vector<bool>(pn+1));\\n        dp[sn][pn]=1;\\n        for(int i=sn;i>=0;i--)\\n            for(int j=pn-1;j>=0;j--)\\n                if(p[j]==\\'*\\') dp[i][j] = dp[i][j+1]||(i<sn && dp[i+1][j]);\\n                else dp[i][j] = i<sn && (p[j]==\\'?\\'|| s[i]==p[j]) && dp[i+1][j+1]; \\n        return dp[0][0];    \\n    }\\n```\\n5. For most recursion to dp problems, we are done. However, we can still do better in this problem. For each star, we match it incrementally with 0, 1, 2 ... chars. If a path fails, we only need to backtrack from the last star. Backtracking from earlier stars eats more chars in s and leaves a shorter string for the last star. This does not create any more choices for the last star. More formally, \\n\\n\\t*Say we use #1 and have 2 stars in p separated by characters. When we reach the 2nd star for the first time, there is a match right before it between s(0...i) and p(0......j). s(0...i) is the first/shortest substring that matches p(0...j) because we match  to chars incrementally. Matching the 2nd star starts from s[i+1]. If we backtrack the 1st star and match it with more characters then the next time when s(0...k) matche s p(0...j), k must be larger than i. At this point, matching the 2nd star starts from s[k+1]. Since k>i, so it is covered by just backtracking the 2nd star. Therefore backtracking the 1st star does not create more opportunities and we can ignore it.*\\n\\n* c++ Code is based on #1.\\n```\\n    bool isMatch(string s, string p) {\\n        bool star = 0;\\n        return isMatch(star,0,0,s,p);    \\n    }\\n    bool isMatch(bool& star, int i, int j, string& s, string& p) {\\n        int sn = s.size();\\n        if(j==p.size()) return i==sn;\\n        if(p[j]==\\'*\\') {\\n            for(int k=i;k<=sn;k++) {\\n                if(isMatch(star,k,j+1,s,p)) return 1;\\n                if(star) return 0;\\n            }\\n            star = 1;\\n            return 0;\\n        }\\n        if(i<sn && (p[j]==\\'?\\'||s[i]==p[j])) return isMatch(star,i+1,j+1,s,p);\\n        return 0;\\n    }\\n```\\n* java\\n```\\n\\t int lastStar;\\n    public boolean isMatch(String s, String p) {\\n        lastStar = -1;\\n        return isMatch(0, s, 0, p);\\n    }\\n    private boolean isMatch(int i, String s, int j, String p) {\\n        int sn = s.length(), pn = p.length();\\n        if(j==pn) {\\n            return i==sn;\\n        }\\n        char pj = p.charAt(j);\\n        if(i<sn && pj == \\'?\\') {\\n            return isMatch(i+1, s, j+1, p);\\n        } else if(pj == \\'*\\') {\\n            lastStar = j;\\n            return isMatch(i,s,j+1,p) || i<sn && j==lastStar && isMatch(i+1,s,j,p);   \\n        } else if(i<sn && pj == s.charAt(i)) {\\n            return isMatch(i+1, s, j+1, p);\\n        }\\n        return false;\\n    }\\n```\\n6. Iterative backtracking O(n^2), same as #4. [Idea is from the top solution](https://discuss.leetcode.com/topic/3040/linear-runtime-and-constant-space-solution)\\n```\\n    bool isMatch(string s, string p) {\\n        int i=0,j=0,star=-1,si=0;\\n        while(i<s.size()) {\\n            if(p[j]==\\'?\\'||s[i]==p[j]) {\\n                i++;\\n                j++;\\n            } else if (p[j]==\\'*\\') {\\n                star = j++;\\n                si = i;\\n            } else if (star >=0 ) {\\n                i = ++si;\\n                j = star+1;\\n            } else return 0;\\n        }\\n        while(j<p.size()) if(p[j++]!=\\'*\\') return 0;\\n        return 1;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    bool isMatch(string s, string p) {\\n        return isMatch(0,0,s,p);    \\n    }\\n    bool isMatch(int i, int j, string& s, string& p) {\\n        int sn = s.size();\\n        if(j==p.size()) return i==sn;\\n        if(p[j]==\\'*\\') {\\n            for(int k=i;k<=sn;k++) if(isMatch(k,j+1,s,p)) return 1;\\n            return 0;\\n        }\\n        if(i<sn && (p[j]==\\'?\\'||s[i]==p[j])) return isMatch(i+1,j+1,s,p);\\n        return 0;\\n    }\\n```\n```\\n    bool isMatch(string s, string p) {\\n        return isMatch(0,0,s,p);    \\n    }\\n    bool isMatch(int i, int j, string& s, string& p) {\\n        int sn = s.size();\\n        if(j==p.size()) return i==sn;\\n        if(p[j]==\\'*\\') return isMatch(i,j+1,s,p) || (i<sn && isMatch(i+1,j,s,p));\\n        if(i<sn && (p[j]==\\'?\\'|| s[i]==p[j])) return isMatch(i+1,j+1,s,p);\\n        return 0;\\n    }\\n```\n```\\n\\tpublic boolean isMatch(String s, String p) {\\n        return isMatch(0, s, 0, p);\\n    }\\n    private boolean isMatch(int i, String s, int j, String p) {\\n        int sn = s.length(), pn = p.length();\\n        if(j==pn) {\\n            return i==sn;\\n        }\\n        char pj = p.charAt(j);\\n        if(i<sn && pj == \\'?\\') {\\n            return isMatch(i+1, s, j+1, p);\\n        } else if(pj == \\'*\\') {\\n            return isMatch(i,s,j+1,p) || i<sn && isMatch(i+1,s,j,p);   \\n        } else if(i<sn && pj == s.charAt(i)) {\\n            return isMatch(i+1, s, j+1, p);\\n        }\\n        return false;\\n    }\\n```\n```\\n    bool isMatch(string s, string p) {\\n        vector<vector<char>> mem(s.size()+1,vector<char>(p.size(),-1));\\n        return isMatch(0,0,s,p,mem);    \\n    }\\n    bool isMatch(int i, int j, string& s, string& p,vector<vector<char>> &mem) {\\n        int sn = s.size();\\n        if(j==p.size()) return i==sn;\\n        if(mem[i][j]!=-1) return mem[i][j];\\n        if(p[j]==\\'*\\') return mem[i][j]= isMatch(i,j+1,s,p,mem) || (i<sn && isMatch(i+1,j,s,p,mem));\\n        if(i<sn && (p[j]==\\'?\\'|| s[i]==p[j])) return mem[i][j]=isMatch(i+1,j+1,s,p,mem);\\n        return mem[i][j]=0;\\n    }\\n```\n```\\n\\tBoolean[][] mem;\\n    public boolean isMatch(String s, String p) {\\n        mem = new Boolean[s.length()+1][p.length()+1];\\n        return isMatch(0, s, 0, p);\\n    }\\n    private boolean isMatch(int i, String s, int j, String p) {\\n        int sn = s.length(), pn = p.length();\\n        if(j==pn) {\\n            return i==sn;\\n        }\\n        if(mem[i][j] != null) {\\n            return mem[i][j];\\n        }\\n        char pj = p.charAt(j);\\n        if(i<sn && pj == \\'?\\') {\\n            return mem[i][j] = isMatch(i+1, s, j+1, p);\\n        } else if(pj == \\'*\\') {\\n            return mem[i][j] = isMatch(i,s,j+1,p) || i<sn && isMatch(i+1,s,j,p);   \\n        } else if(i<sn && pj == s.charAt(i)) {\\n            return mem[i][j] = isMatch(i+1, s, j+1, p);\\n        }\\n        return mem[i][j] = false;\\n    }\\n```\n```\\n    bool isMatch(string s, string p) {\\n        int sn = s.size(), pn = p.size();\\n        vector<vector<bool>> dp(sn+1,vector<bool>(pn+1));\\n        dp[sn][pn]=1;\\n        for(int i=sn;i>=0;i--)\\n            for(int j=pn-1;j>=0;j--)\\n                if(p[j]==\\'*\\') dp[i][j] = dp[i][j+1]||(i<sn && dp[i+1][j]);\\n                else dp[i][j] = i<sn && (p[j]==\\'?\\'|| s[i]==p[j]) && dp[i+1][j+1]; \\n        return dp[0][0];    \\n    }\\n```\n```\\n    bool isMatch(string s, string p) {\\n        bool star = 0;\\n        return isMatch(star,0,0,s,p);    \\n    }\\n    bool isMatch(bool& star, int i, int j, string& s, string& p) {\\n        int sn = s.size();\\n        if(j==p.size()) return i==sn;\\n        if(p[j]==\\'*\\') {\\n            for(int k=i;k<=sn;k++) {\\n                if(isMatch(star,k,j+1,s,p)) return 1;\\n                if(star) return 0;\\n            }\\n            star = 1;\\n            return 0;\\n        }\\n        if(i<sn && (p[j]==\\'?\\'||s[i]==p[j])) return isMatch(star,i+1,j+1,s,p);\\n        return 0;\\n    }\\n```\n```\\n\\t int lastStar;\\n    public boolean isMatch(String s, String p) {\\n        lastStar = -1;\\n        return isMatch(0, s, 0, p);\\n    }\\n    private boolean isMatch(int i, String s, int j, String p) {\\n        int sn = s.length(), pn = p.length();\\n        if(j==pn) {\\n            return i==sn;\\n        }\\n        char pj = p.charAt(j);\\n        if(i<sn && pj == \\'?\\') {\\n            return isMatch(i+1, s, j+1, p);\\n        } else if(pj == \\'*\\') {\\n            lastStar = j;\\n            return isMatch(i,s,j+1,p) || i<sn && j==lastStar && isMatch(i+1,s,j,p);   \\n        } else if(i<sn && pj == s.charAt(i)) {\\n            return isMatch(i+1, s, j+1, p);\\n        }\\n        return false;\\n    }\\n```\n```\\n    bool isMatch(string s, string p) {\\n        int i=0,j=0,star=-1,si=0;\\n        while(i<s.size()) {\\n            if(p[j]==\\'?\\'||s[i]==p[j]) {\\n                i++;\\n                j++;\\n            } else if (p[j]==\\'*\\') {\\n                star = j++;\\n                si = i;\\n            } else if (star >=0 ) {\\n                i = ++si;\\n                j = star+1;\\n            } else return 0;\\n        }\\n        while(j<p.size()) if(p[j++]!=\\'*\\') return 0;\\n        return 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 17845,
                "title": "python-dp-solution",
                "content": "    class Solution:\\n    # @return a boolean\\n    def isMatch(self, s, p):\\n        length = len(s)\\n        if len(p) - p.count('*') > length:\\n            return False\\n        dp = [True] + [False]*length\\n        for i in p:\\n            if i != '*':\\n                for n in reversed(range(length)):\\n                    dp[n+1] = dp[n] and (i == s[n] or i == '?')\\n            else:\\n                for n in range(1, length+1):\\n                    dp[n] = dp[n-1] or dp[n]\\n            dp[0] = dp[0] and i == '*'\\n        return dp[-1]\\n\\ndp[n] means the substring s[:n] if match the pattern i\\n\\ndp[0] means the empty string '' or s[:0] which only match the pattern '*'\\n\\nuse the reversed builtin because for every dp[n+1] we use the previous 'dp'\\n\\n\\n\\nadd Java O(m*n) version code\\n\\n    public boolean isMatch(String s, String p) {\\n        int count = 0;\\n        for (char c : p.toCharArray()) {\\n            if (c == '*')\\n                count++;\\n        }\\n        if (p.length() - count > s.length())\\n            return false;\\n        boolean[][] dp = new boolean[p.length() + 1][s.length() + 1];\\n        dp[0][0] = true;\\n        for (int j = 1; j <= p.length(); j++) {\\n            char pattern = p.charAt(j - 1);\\n            dp[j][0] = dp[j - 1][0] && pattern == '*';\\n            for (int i = 1; i <= s.length(); i++) {\\n                char letter = s.charAt(i - 1);\\n                if (pattern != '*') {\\n                    dp[j][i] = dp[j - 1][i - 1] && (pattern == '?' || pattern == letter);\\n                } else\\n                    dp[j][i] = dp[j][i - 1] || dp[j - 1][i];\\n            }\\n        }\\n        return dp[p.length()][s.length()];\\n    }",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    # @return a boolean\\n    def isMatch(self, s, p):\\n        length = len(s)\\n        if len(p) - p.count('*') > length:\\n            return False\\n        dp = [True] + [False]*length\\n        for i in p:\\n            if i != '*':\\n                for n in reversed(range(length)):\\n                    dp[n+1] = dp[n] and (i == s[n] or i == '?')\\n            else:\\n                for n in range(1, length+1):\\n                    dp[n] = dp[n-1] or dp[n]\\n            dp[0] = dp[0] and i == '*'\\n        return dp[-1]\\n\\ndp[n] means the substring s[:n] if match the pattern i\\n\\ndp[0] means the empty string '' or s[:0] which only match the pattern '*'\\n\\nuse the reversed builtin because for every dp[n+1] we use the previous 'dp'\\n\\n\\n\\nadd Java O(m*n) version code\\n\\n    public boolean isMatch(String s, String p) {\\n        int count = 0;\\n        for (char c : p.toCharArray()) {\\n            if (c == '*')\\n                count++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 17811,
                "title": "my-three-c-solutions-iterative-16ms-dp-180ms-modified-recursion-88ms",
                "content": "The reason that the iterative solution is much faster for this case is we only need to save (and deal with) the positions (iStar for s, jStar for p) of the last \"*\" we met. We only need to do traceback using iStar and jStar and all the previous \"*\" can be ignored since the last \"*\" will cover all the traceback cases for the previous \"*\". \\nWhat we need to do are\\n\\n - if the current p character is '*' (i.e. p[j]=='*'), then we update iStar and jStar with the cureent i and j values. iStar/jStar will be used for traceback. Also we do --i to start the depth first search with the case that '*' represents a null string.\\n - if p[j]!='*', then we check if mismatch occurs (i.e. p[j]!=s[i] and p[j]!='?'), if so we check if we met a '*' before (iStar>=0), if not, then we return false since no match can achieve. Otherwise, we traceback to the positions at which the last '*' happens and do the next possible dfs search (i.e.  i = iStar++;  j = jStar; remember to update iStar too to save the i position to try in the next traceback).\\n - The loop will quit when we reach the end of s. At last, we need to skip all the '*' in p to see if we can reach the end of p. if so, match, otherwise mismatch\\n\\n------------------------------------------------------------------------------------------------\\n    class Solution {\\n    public:\\n        bool isMatch(string s, string p) {\\n            int  slen = s.size(), plen = p.size(), i, j, iStar=-1, jStar=-1;\\n    \\n            for(i=0,j=0 ; i<slen; ++i, ++j)\\n            {\\n                if(p[j]=='*')\\n                { //meet a new '*', update traceback i/j info\\n                    iStar = i;\\n                    jStar = j;\\n                    --i;\\n                }\\n                else\\n                { \\n                    if(p[j]!=s[i] && p[j]!='?')\\n                    {  // mismatch happens\\n                        if(iStar >=0)\\n                        { // met a '*' before, then do traceback\\n                            i = iStar++;\\n                            j = jStar;\\n                        }\\n                        else return false; // otherwise fail\\n                    }\\n                }\\n            }\\n            while(p[j]=='*') ++j;\\n            return j==plen;\\n        }\\n    };\\n\\nA DP solution is also given here. It has O(N^2) time complexity and O(N) space\\n\\n    class Solution {\\n    public:\\n        bool isMatch(string s, string p) {\\n            int pLen = p.size(), sLen = s.size(), i, j, k, cur, prev;\\n            if(!pLen) return sLen == 0;\\n            bool matched[2][sLen+1];\\n            fill_n(&matched[0][0], 2*(sLen+1), false);\\n            \\n            matched[0][0] = true;\\n            for(i=1; i<=pLen; ++i)\\n            {\\n                cur = i%2, prev= 1-cur;\\n                matched[cur][0]= matched[prev][0] && p[i-1]=='*';\\n                if(p[i-1]=='*') for(j=1; j<=sLen; ++j) matched[cur][j] = matched[cur][j-1] || matched[prev][j];\\n                else for(j=1; j<=sLen; ++j)            matched[cur][j] =  matched[prev][j-1] && (p[i-1]=='?' || p[i-1]==s[j-1]) ;\\n            }\\n                return matched[cur][sLen];\\n        }\\n    };\\n\\n A recursion version. A typical recursion version will give us TLE due to too many unnecessary recursive calls. As we explained, all the traceback recursive calls at the '*' we met (except the last '*') are unneccessary and should be avoided. In the below version, we use recLevel to track the recursion level (i.e the total '*' we met) and we also use curLevel to save the order of '*' we currently process. If it is not the last '*' we met (i.e  if(recLevel>curLevel+1) ), then we will return false directly ( if(recLevel>curLevel+1) return false;) to skip all unneccessary recursion call at the '*' before the last '*'.\\n\\n    class Solution {\\n    private:\\n        bool helper(const string &s, const string &p, int si, int pi, int &recLevel)\\n        {\\n            int sSize = s.size(), pSize = p.size(), i, curLevel = recLevel;\\n            bool first=true;\\n            while(si<sSize && (p[pi]==s[si] || p[pi]=='?')) {++pi; ++si;} //match as many as possible\\n            if(pi == pSize) return si == sSize; // if p reaches the end, return\\n            if(p[pi]=='*')\\n            { // if a star is met\\n                while(p[++pi]=='*'); //skip all the following stars\\n                if(pi>=pSize) return true; // if the rest of p are all star, return true\\n                for(i=si; i<sSize; ++i)\\n                {   // then do recursion\\n                    if(p[pi]!= '?' && p[pi]!=s[i]) continue;\\n                    if(first) {++recLevel; first = false;}\\n                    if(helper(s, p, i, pi, recLevel)) return true;\\n                    if(recLevel>curLevel+1) return false; // if the currently processed star is not the last one, return\\n                }\\n            }\\n            return false;\\n        }\\n    public:\\n        bool isMatch(string s, string p) {\\n            int recLevel = 0;\\n            return helper(s, p, 0, 0, recLevel);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isMatch(string s, string p) {\\n            int  slen = s.size(), plen = p.size(), i, j, iStar=-1, jStar=-1;\\n    \\n            for(i=0,j=0 ; i<slen; ++i, ++j)\\n            {\\n                if(p[j]=='*')\\n                { //meet a new '*', update traceback i/j info\\n                    iStar = i;\\n                    jStar = j;\\n                    --i;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 752350,
                "title": "recursion-brute-force-to-top-down-dp-and-bottom-up",
                "content": "We can solve this problem using recursion. The basic conditions that we need to put here is when j reaches the end of pattern length, then we need to check if the i has also reached the end or not, if not then it will return false, otherwise true.\\n\\nIf the i reaches the end of the string i.e. i=s.length(), then only when p[j]=\\' * \\'  since * can be equal to the empty sequence as well. \\n\\nWe will now check if the current charcter of pattern and string are equal or not. They would be equal if either s[i]==p[j] or p[j]=\\'?\\'. \\n\\nif the current pattern character is \\' * \\' then we have two options either to move j forward and don\\'t use it for matching or we can match and move the string index and keep the pattern index at j only. \\n\\nif the current character is not \\' * \\', then we need to check only if the first_match is true and move both the i and j index by 1.\\n\\n```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        return helper(s,p,0,0);\\n    }\\n    \\n    bool helper(string s, string p, int i, int j)\\n    {\\n        if(j==p.length())\\n            return i==s.length();\\n        if(i==s.length())\\n            return (p[j]==\\'*\\' && helper(s,p,i,j+1));\\n        bool first_match=(i<s.length() && (p[j]==s[i] || p[j]==\\'?\\'));\\n        \\n        if(p[j]==\\'*\\')\\n        {\\n            return (helper(s,p,i+1,j) || helper(s,p,i,j+1));\\n        }\\n        else\\n        {\\n            return (first_match && helper(s,p,i+1,j+1));\\n        }\\n    }\\n};\\n```\\n\\nTop down DP solution :\\n\\nWe are solving the same subproblems many times instead we can save those problems and resuse them. We can initialize the dp array with -1 so that if it becomes postive then that means it has been solved for that i and j. \\n\\n```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        if(p.length()==0){\\n            return (s.length()==0);\\n        }\\n        vector<vector<int>> v(s.length()+1,vector<int> (p.length()+1,-1));\\n      return  helper(s,p,0,0,v);\\n      \\n    }\\n    bool helper(string s, string p,int i,int j,vector<vector<int>> &v)\\n    {\\n        if(j==p.length())\\n            return (i==s.length());\\n        if(v[i][j]<0){\\n        if(i==s.length())\\n            v[i][j]= (p[j]==\\'*\\' && helper(s,p,i,j+1,v));\\n        else if(i<s.length() &&  (p[j]==s[i] || p[j]==\\'?\\'))\\n        {\\n           v[i][j]=  helper(s,p,i+1,j+1,v);\\n        }\\n        \\n        else if(p[j]==\\'*\\')\\n        {\\n            v[i][j]= (helper(s,p,i,j+1,v) || helper(s,p,i+1,j,v));\\n        }\\n        else\\n        v[i][j]= false;\\n        }\\n        return v[i][j];\\n    }\\n};\\n```\\n\\nBottom up solution\\n\\nWe can use bottom up approach to solve this problem. \\n\\ndp[0][0]=true or 1. it is because if the length of the pattern and matching string is 0 then, they are equal or they are a match.\\n\\nWe can fill the first row of the dp. First row of DP tells us that the matching string length is zero, then uptill which column the pattern matches the empty string. So we know that it can only happen if the pattern character at that point is \\' * \\' and if anything else comes other then a \\' * \\' then we break. \\n\\nNow, we can start filling the second row of dp, if the pattern is \\' * \\' at j-1, then either we can use it to match in that case it would be equal to dp[i-1][j] and if we use the empty string for \\' * \\' then it is equal to dp[i][j-1].\\n\\nIf the pattern at j-1 is not \\' * \\' then we need check if the characters are equal or pattern character at j-1 is \\' ? \\' then dp[i][j] =dp[i-1][j-1];\\n\\n```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        if(p.length()==0)\\n            return (s.length()==0);\\n        vector<vector<int>> dp(s.length()+1,vector<int>(p.length()+1,0));\\n        dp[0][0]=1;\\n        for(int i=1;i<=p.length();i++)\\n        {\\n            if(p[i-1]==\\'*\\')\\n                dp[0][i]=1;\\n            else\\n                break;\\n        }\\n        for(int i=1;i<=s.length();i++)\\n        {\\n            for(int j=1;j<=p.length();j++)\\n            {\\n                if(p[j-1]==\\'*\\')\\n                {\\n                    dp[i][j]=dp[i-1][j] || dp[i][j-1];\\n                }\\n                else if(p[j-1]==s[i-1] || p[j-1]==\\'?\\')\\n                {\\n                    dp[i][j]=dp[i-1][j-1];\\n                }\\n            }\\n        }\\n        return dp[s.length()][p.length()];\\n      \\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        return helper(s,p,0,0);\\n    }\\n    \\n    bool helper(string s, string p, int i, int j)\\n    {\\n        if(j==p.length())\\n            return i==s.length();\\n        if(i==s.length())\\n            return (p[j]==\\'*\\' && helper(s,p,i,j+1));\\n        bool first_match=(i<s.length() && (p[j]==s[i] || p[j]==\\'?\\'));\\n        \\n        if(p[j]==\\'*\\')\\n        {\\n            return (helper(s,p,i+1,j) || helper(s,p,i,j+1));\\n        }\\n        else\\n        {\\n            return (first_match && helper(s,p,i+1,j+1));\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        if(p.length()==0){\\n            return (s.length()==0);\\n        }\\n        vector<vector<int>> v(s.length()+1,vector<int> (p.length()+1,-1));\\n      return  helper(s,p,0,0,v);\\n      \\n    }\\n    bool helper(string s, string p,int i,int j,vector<vector<int>> &v)\\n    {\\n        if(j==p.length())\\n            return (i==s.length());\\n        if(v[i][j]<0){\\n        if(i==s.length())\\n            v[i][j]= (p[j]==\\'*\\' && helper(s,p,i,j+1,v));\\n        else if(i<s.length() &&  (p[j]==s[i] || p[j]==\\'?\\'))\\n        {\\n           v[i][j]=  helper(s,p,i+1,j+1,v);\\n        }\\n        \\n        else if(p[j]==\\'*\\')\\n        {\\n            v[i][j]= (helper(s,p,i,j+1,v) || helper(s,p,i+1,j,v));\\n        }\\n        else\\n        v[i][j]= false;\\n        }\\n        return v[i][j];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        if(p.length()==0)\\n            return (s.length()==0);\\n        vector<vector<int>> dp(s.length()+1,vector<int>(p.length()+1,0));\\n        dp[0][0]=1;\\n        for(int i=1;i<=p.length();i++)\\n        {\\n            if(p[i-1]==\\'*\\')\\n                dp[0][i]=1;\\n            else\\n                break;\\n        }\\n        for(int i=1;i<=s.length();i++)\\n        {\\n            for(int j=1;j<=p.length();j++)\\n            {\\n                if(p[j-1]==\\'*\\')\\n                {\\n                    dp[i][j]=dp[i-1][j] || dp[i][j-1];\\n                }\\n                else if(p[j-1]==s[i-1] || p[j-1]==\\'?\\')\\n                {\\n                    dp[i][j]=dp[i-1][j-1];\\n                }\\n            }\\n        }\\n        return dp[s.length()][p.length()];\\n      \\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17839,
                "title": "c-recursive-solution-16-ms",
                "content": "    class Solution {\\n        // return value:\\n        // 0: reach the end of s but unmatched\\n        // 1: unmatched without reaching the end of s\\n        // 2: matched\\n        int dfs(string& s, string& p, int si, int pi) {\\n            if (si == s.size() and pi == p.size()) return 2;\\n            if (si == s.size() and p[pi] != '*') return 0;\\n            if (pi == p.size()) return 1;\\n            if (p[pi] == '*') {\\n                if (pi+1 < p.size() and p[pi+1] == '*') \\n                    return dfs(s, p, si, pi+1); // skip duplicate '*'\\n                for(int i = 0; i <= s.size()-si; ++i) {\\n                    int ret = dfs(s, p, si+i, pi+1);\\n                    if (ret == 0 or ret == 2) return ret; \\n                }\\n            }\\n            if (p[pi] == '?' or s[si] == p[pi])\\n                return dfs(s, p, si+1, pi+1);\\n            return 1;\\n        }    \\n        \\n    public:\\n        bool isMatch(string s, string p) {\\n            return dfs(s, p, 0, 0) > 1;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "class Solution {\\n        // return value:\\n        // 0: reach the end of s but unmatched\\n        // 1: unmatched without reaching the end of s\\n        // 2: matched\\n        int dfs(string& s, string& p, int si, int pi) {\\n            if (si == s.size() and pi == p.size()) return 2;\\n            if (si == s.size() and p[pi] != '*') return 0;\\n            if (pi == p.size()) return 1;\\n            if (p[pi] == '*') {\\n                if (pi+1 < p.size() and p[pi+1] == '*') \\n                    return dfs(s, p, si, pi+1); // skip duplicate '*'\\n                for(int i = 0; i <= s.size()-si; ++i) {\\n                    int ret = dfs(s, p, si+i, pi+1);\\n                    if (ret == 0 or ret == 2) return ret; \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 17828,
                "title": "java-dp-accepted",
                "content": "    public class Solution {\\n        public boolean isMatch(String s, String p) {\\n            int m = s.length(), n = p.length();\\n            char[] ws = s.toCharArray();\\n            char[] wp = p.toCharArray();\\n            boolean[][] dp = new boolean[m+1][n+1];\\n            dp[0][0] = true;\\n            for (int j = 1; j <= n; j++)\\n                dp[0][j] = dp[0][j-1] && wp[j-1] == '*';\\n            for (int i = 1; i <= m; i++)\\n                dp[i][0] = false;\\n            for (int i = 1; i <= m; i++) {\\n                for (int j = 1; j <= n; j++) {\\n                \\tif (wp[j-1] == '?' || ws[i-1] == wp[j-1])\\n                \\t\\tdp[i][j] = dp[i-1][j-1];\\n                \\telse if (wp[j-1] == '*')\\n                \\t\\tdp[i][j] = dp[i-1][j] || dp[i][j-1];\\n                }\\n            }\\n            return dp[m][n];\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean isMatch(String s, String p) {\\n            int m = s.length(), n = p.length();\\n            char[] ws = s.toCharArray();\\n            char[] wp = p.toCharArray();\\n            boolean[][] dp = new boolean[m+1][n+1];\\n            dp[0][0] = true;\\n            for (int j = 1; j <= n; j++)\\n                dp[0][j] = dp[0][j-1] && wp[j-1] == '*';\\n            for (int i = 1; i <= m; i++)\\n                dp[i][0] = false;\\n            for (int i = 1; i <= m; i++) {\\n                for (int j = 1; j <= n; j++) {\\n                \\tif (wp[j-1] == '?' || ws[i-1] == wp[j-1])\\n                \\t\\tdp[i][j] = dp[i-1][j-1];\\n                \\telse if (wp[j-1] == '*')\\n                \\t\\tdp[i][j] = dp[i-1][j] || dp[i][j-1];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1355942,
                "title": "swift-wildcard-matching-test-cases",
                "content": "```swift\\nclass Solution {\\n    func isMatch(_ s: String, _ p: String) -> Bool {\\n        let sArr = Array(s), pArr = Array(p)\\n        let pBools = [Bool](repeating: false, count: p.count + 1)\\n        var dp = Array(repeating: pBools, count: s.count + 1)\\n        dp[0][0] = true\\n        (0...s.count).forEach {\\n            for j in 0...p.count where j > 0 {\\n                let cp = pArr[j-1]\\n                if cp != \"*\" {\\n                    dp[$0][j] = $0 > 0 && dp[$0-1][j-1] && (cp == sArr[$0-1] || cp == \"?\")\\n                } else {\\n                    var flag = false\\n                    for k in 0...$0 where dp[k][j-1] {\\n                        flag = true\\n                    }\\n                    dp[$0][j] = flag || j == 1\\n                }\\n            }\\n        }\\n        return dp[s.count][p.count]\\n    }\\n}\\n```\\n\\n```swift\\nimport XCTest\\n\\n// Executed 5 tests, with 0 failures (0 unexpected) in 0.045 (0.047) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test0() {\\n        let res = s.isMatch(\"aa\",\"a\")\\n        XCTAssertEqual(res, false)\\n    }\\n    func test1() {\\n        let res = s.isMatch(\"aa\",\"*\")\\n        XCTAssertEqual(res, true)\\n    }\\n    func test2() {\\n        let res = s.isMatch(\"cb\",\"?a\")\\n        XCTAssertEqual(res, false)\\n    }\\n    func test3() {\\n        let res = s.isMatch(\"adceb\",\"*a*b\")\\n        XCTAssertEqual(res, true)\\n    }\\n    func test4() {\\n        let res = s.isMatch(\"acdcb\",\"a*c?b\")\\n        XCTAssertEqual(res, false)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func isMatch(_ s: String, _ p: String) -> Bool {\\n        let sArr = Array(s), pArr = Array(p)\\n        let pBools = [Bool](repeating: false, count: p.count + 1)\\n        var dp = Array(repeating: pBools, count: s.count + 1)\\n        dp[0][0] = true\\n        (0...s.count).forEach {\\n            for j in 0...p.count where j > 0 {\\n                let cp = pArr[j-1]\\n                if cp != \"*\" {\\n                    dp[$0][j] = $0 > 0 && dp[$0-1][j-1] && (cp == sArr[$0-1] || cp == \"?\")\\n                } else {\\n                    var flag = false\\n                    for k in 0...$0 where dp[k][j-1] {\\n                        flag = true\\n                    }\\n                    dp[$0][j] = flag || j == 1\\n                }\\n            }\\n        }\\n        return dp[s.count][p.count]\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\n// Executed 5 tests, with 0 failures (0 unexpected) in 0.045 (0.047) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test0() {\\n        let res = s.isMatch(\"aa\",\"a\")\\n        XCTAssertEqual(res, false)\\n    }\\n    func test1() {\\n        let res = s.isMatch(\"aa\",\"*\")\\n        XCTAssertEqual(res, true)\\n    }\\n    func test2() {\\n        let res = s.isMatch(\"cb\",\"?a\")\\n        XCTAssertEqual(res, false)\\n    }\\n    func test3() {\\n        let res = s.isMatch(\"adceb\",\"*a*b\")\\n        XCTAssertEqual(res, true)\\n    }\\n    func test4() {\\n        let res = s.isMatch(\"acdcb\",\"a*c?b\")\\n        XCTAssertEqual(res, false)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3402050,
                "title": "detailed-explaination-with-pictures-in-c-java-python-dp-top-down-tabulation",
                "content": "# Approach\\n- Here the Approach is literally same as the sum [https://leetcode.com/problems/regular-expression-matching/]() or a small improvisation of it here the \\'*\\' symbol can take any pattern that is the only difference between those two, below is the pictorical representation of the approach followed and the breifing of it is given below.\\n\\n- ![pic1.png](https://assets.leetcode.com/users/images/20f32b02-f04f-4d07-a667-a47e38e0fe02_1681159815.5575788.png)\\n\\n>- Here we can clearly see that the final DP table is completely dependent on its previous states $i.e$ given by the expression as follows -\\n`dp[i][j] = dp[i-1][j] | dp[i][j-1] | dp[i-1][j-1] ` when `p[j-1]` is\\nindicated by a \\'*\\' otherwise we go with `dp[i-1][j-1]` as the state transition. \\n\\n>- This would be the way in which we must proceed based and the prev state and the final answer would be `dp[m][n]` we always do a step down indexing for convineance purposes.\\n\\n---\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n    int n=s.length();\\n        int m=p.length();\\n        bool res[m+1][n+1];\\n        memset(res,false,sizeof(res));\\n        res[0][0]=true;\\n        for(int i=1;i<=m;i++){\\n            if(p[i-1]==\\'*\\'){\\n                res[i][0]=res[i-1][0];\\n            }\\n            for(int j=1;j<=n;j++){\\n                if(p[i-1]==\\'*\\'){\\n                    res[i][j]=res[i-1][j]||res[i][j-1];\\n                }\\n                else if(p[i-1]==s[j-1]||\\'?\\'==p[i-1]){\\n                    res[i][j]=res[i-1][j-1];\\n                }\\n            }\\n        }\\n        return res[m][n];\\n    }   \\n};\\n```\\n```Java []\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        int sIndex = 0, pIndex = 0, matchIndex = 0, starIndex = -1;\\n        \\n        while (sIndex < s.length()) {\\n            if (pIndex < p.length() && (s.charAt(sIndex) == p.charAt(pIndex) || p.charAt(pIndex) == \\'?\\')) {\\n                sIndex++;\\n                pIndex++;\\n            } else if (pIndex < p.length() && p.charAt(pIndex) == \\'*\\') {\\n                starIndex = pIndex;\\n                matchIndex = sIndex;\\n                pIndex++;\\n            } else if (starIndex != -1) {\\n                pIndex = starIndex + 1;\\n                matchIndex++;\\n                sIndex = matchIndex;\\n            } else {\\n                return false;\\n            }\\n        }\\n        \\n        while (pIndex < p.length() && p.charAt(pIndex) == \\'*\\') {\\n            pIndex++;\\n        }\\n        \\n        return pIndex == p.length();\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        s_len, p_len, p_idx, s_idx, p_star, s_backtrack = len(s), len(p), 0, 0, -1, -1\\n        \\n        while s_idx < s_len:\\n            if p_idx < p_len and p[p_idx] in [\\'?\\', s[s_idx]]:\\n                p_idx += 1\\n                s_idx += 1\\n            elif p_idx < p_len and p[p_idx] == \\'*\\':\\n                p_star = p_idx\\n                s_backtrack = s_idx\\n                p_idx += 1\\n            else: #elif p_idx == p_len or p[p_idx] != s[s_idx]:\\n                if p_star == -1:\\n                    return False\\n                else:\\n                    #backtrack\\n                    p_idx = p_star + 1\\n                    s_idx = s_backtrack + 1\\n                    s_backtrack = s_idx\\n\\n        return all(p[idx] == \\'*\\' for idx in range(p_idx, p_len))\\n```\\n---\\n# Complexity\\n>- Time complexity: Here the complexity would be $O(n^2)$ as we can see that we need a 2d looping for the management of memoization using the length so $O(n^2)$.\\n\\n>- Space complexity: Here We can clearly see that we need a 2D dp so the space complexity will also be $O(n^2)$ and which can be further optimised to $O(n)$ by using space optimisation in Dp as the final states and previous states differ by one index.\\n\\n\\n---\\n\\nIF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.\\n\\n![UPVOTE.jpg](https://assets.leetcode.com/users/images/0ba8ee63-53aa-40f7-994a-663b1bc3c77f_1681159079.630099.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n    int n=s.length();\\n        int m=p.length();\\n        bool res[m+1][n+1];\\n        memset(res,false,sizeof(res));\\n        res[0][0]=true;\\n        for(int i=1;i<=m;i++){\\n            if(p[i-1]==\\'*\\'){\\n                res[i][0]=res[i-1][0];\\n            }\\n            for(int j=1;j<=n;j++){\\n                if(p[i-1]==\\'*\\'){\\n                    res[i][j]=res[i-1][j]||res[i][j-1];\\n                }\\n                else if(p[i-1]==s[j-1]||\\'?\\'==p[i-1]){\\n                    res[i][j]=res[i-1][j-1];\\n                }\\n            }\\n        }\\n        return res[m][n];\\n    }   \\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        int sIndex = 0, pIndex = 0, matchIndex = 0, starIndex = -1;\\n        \\n        while (sIndex < s.length()) {\\n            if (pIndex < p.length() && (s.charAt(sIndex) == p.charAt(pIndex) || p.charAt(pIndex) == \\'?\\')) {\\n                sIndex++;\\n                pIndex++;\\n            } else if (pIndex < p.length() && p.charAt(pIndex) == \\'*\\') {\\n                starIndex = pIndex;\\n                matchIndex = sIndex;\\n                pIndex++;\\n            } else if (starIndex != -1) {\\n                pIndex = starIndex + 1;\\n                matchIndex++;\\n                sIndex = matchIndex;\\n            } else {\\n                return false;\\n            }\\n        }\\n        \\n        while (pIndex < p.length() && p.charAt(pIndex) == \\'*\\') {\\n            pIndex++;\\n        }\\n        \\n        return pIndex == p.length();\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        s_len, p_len, p_idx, s_idx, p_star, s_backtrack = len(s), len(p), 0, 0, -1, -1\\n        \\n        while s_idx < s_len:\\n            if p_idx < p_len and p[p_idx] in [\\'?\\', s[s_idx]]:\\n                p_idx += 1\\n                s_idx += 1\\n            elif p_idx < p_len and p[p_idx] == \\'*\\':\\n                p_star = p_idx\\n                s_backtrack = s_idx\\n                p_idx += 1\\n            else: #elif p_idx == p_len or p[p_idx] != s[s_idx]:\\n                if p_star == -1:\\n                    return False\\n                else:\\n                    #backtrack\\n                    p_idx = p_star + 1\\n                    s_idx = s_backtrack + 1\\n                    s_backtrack = s_idx\\n\\n        return all(p[idx] == \\'*\\' for idx in range(p_idx, p_len))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17950,
                "title": "fastest-non-dp-solution-with-o-1-space",
                "content": " \\n    def isWildcardMatch(self, s, p):\\n        sn, pn = len(s), len(p)\\n        si = pi = 0\\n        save_si, save_pi = None, None\\n        while si < sn:\\n            if pi < pn and (p[pi] == '?' or p[pi] == s[si]):\\n                si += 1\\n                pi += 1\\n            elif pi < pn and p[pi] == '*':\\n                # Meet \"*\", save si and pi, searching for next character\\n                save_si, save_pi = si + 1, pi\\n                pi += 1\\n            elif save_pi is not None:\\n                # Dead end, restore si and pi, carry on.\\n                si, pi = save_si, save_pi\\n            else:\\n                return False\\n        # Check trailing \"*\"\\n        return p[pi:].count(\"*\") == pn - pi",
                "solutionTags": [
                    "Python"
                ],
                "code": " \\n    def isWildcardMatch(self, s, p):\\n        sn, pn = len(s), len(p)\\n        si = pi = 0\\n        save_si, save_pi = None, None\\n        while si < sn:\\n            if pi < pn and (p[pi] == '?' or p[pi] == s[si]):\\n                si += 1\\n                pi += 1\\n            elif pi < pn and p[pi] == '*':\\n                # Meet \"*\", save si and pi, searching for next character\\n                save_si, save_pi = si + 1, pi\\n                pi += 1\\n            elif save_pi is not None:\\n                # Dead end, restore si and pi, carry on.\\n                si, pi = save_si, save_pi\\n            else:\\n                return False\\n        # Check trailing \"*\"\\n        return p[pi:].count(\"*\") == pn - pi",
                "codeTag": "Python3"
            },
            {
                "id": 17904,
                "title": "java-solution-o-n-2-dp-solution-with-some-explanations",
                "content": "I had a solution for \"Regular Expression Matching\" problem: https://leetcode.com/discuss/66032/java-solution-o-n-2-dp-with-some-explanations.\\n\\nSlight change to that solution gives an O(n^3) DP solution for this \"Wildcard Matching\" problem:\\n\\n    // O(n^3) DP solution for understanding the algorightm:\\n    public boolean isMatch(String s, String p) {\\n        int sL = s.length(), pL = p.length();\\n        \\n        boolean[][] dp = new boolean[sL+1][pL+1];\\n        dp[0][0] = true; // If s and p are \"\", isMathch() returns true;\\n        \\n        for(int i=0; i<=sL; i++) {\\n            \\n            // j starts from 1, since dp[i][0] is false when i!=0;\\n            for(int j=1; j<=pL; j++) {\\n                char c = p.charAt(j-1);\\n                \\n                if(c != '*') {\\n                    // The last character of s and p should match;\\n                    // And, dp[i-1][j-1] is true;\\n                    dp[i][j] = i>0 && dp[i-1][j-1] && (c=='?' || c==s.charAt(i-1));\\n                }\\n                else {\\n                    // Two situations:\\n                    // (1) '*' is the first character in p;\\n                    // (2) For k>=0 and k<=i, there is some dp[k][j-1] being true;\\n                    //     and '*' will match the rest sequence in s after index k;\\n                    boolean flag = false;\\n                    for(int k=i; k>=0; k--) { flag = dp[k][j-1]; if(flag) break;};\\n                    \\n                    dp[i][j] = j==1 || flag;\\n                }\\n            }\\n        }\\n        \\n        return dp[sL][pL];\\n    }\\n\\nBased on the same idea, I transposed the dp[][] matric and got the O(n^2) DP solution:\\n\\n    // O(n^2) DP solution with dp[][] matric transposed:\\n    public boolean isMatch(String s, String p) {\\n        int sL = s.length(), pL = p.length();\\n        \\n        boolean[][] dp = new boolean[pL+1][sL+1];\\n        dp[0][0] = true;\\n\\n        for(int i=1; i<=pL; i++) {\\n            boolean flag = false; // The flag is moved here;\\n\\n            for(int j=0; j<=sL; j++) {\\n                flag = flag || dp[i-1][j];\\n                char c = p.charAt(i-1);\\n                \\n                if(c != '*') {\\n                    dp[i][j] = j>0 && dp[i-1][j-1] && (c=='?' || c==s.charAt(j-1));\\n                }\\n                else {\\n                    // For k>=0 and k<=j, if any dp[i-1][k] is true,\\n                    // then '*' will match the rest sequence in s after index k;\\n                    dp[i][j] = i==1 || flag;\\n                }\\n            }\\n        }\\n        \\n        return dp[pL][sL];\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "I had a solution for \"Regular Expression Matching\" problem: https://leetcode.com/discuss/66032/java-solution-o-n-2-dp-with-some-explanations.\\n\\nSlight change to that solution gives an O(n^3) DP solution for this \"Wildcard Matching\" problem:\\n\\n    // O(n^3) DP solution for understanding the algorightm:\\n    public boolean isMatch(String s, String p) {\\n        int sL = s.length(), pL = p.length();\\n        \\n        boolean[][] dp = new boolean[sL+1][pL+1];\\n        dp[0][0] = true; // If s and p are \"\", isMathch() returns true;\\n        \\n        for(int i=0; i<=sL; i++) {\\n            \\n            // j starts from 1, since dp[i][0] is false when i!=0;\\n            for(int j=1; j<=pL; j++) {\\n                char c = p.charAt(j-1);\\n                \\n                if(c != '*') {\\n                    // The last character of s and p should match;\\n                    // And, dp[i-1][j-1] is true;\\n                    dp[i][j] = i>0 && dp[i-1][j-1] && (c=='?' || c==s.charAt(i-1));\\n                }\\n                else {\\n                    // Two situations:\\n                    // (1) '*' is the first character in p;\\n                    // (2) For k>=0 and k<=i, there is some dp[k][j-1] being true;\\n                    //     and '*' will match the rest sequence in s after index k;\\n                    boolean flag = false;\\n                    for(int k=i; k>=0; k--) { flag = dp[k][j-1]; if(flag) break;};\\n                    \\n                    dp[i][j] = j==1 || flag;\\n                }\\n            }\\n        }\\n        \\n        return dp[sL][pL];\\n    }\\n\\nBased on the same idea, I transposed the dp[][] matric and got the O(n^2) DP solution:\\n\\n    // O(n^2) DP solution with dp[][] matric transposed:\\n    public boolean isMatch(String s, String p) {\\n        int sL = s.length(), pL = p.length();\\n        \\n        boolean[][] dp = new boolean[pL+1][sL+1];\\n        dp[0][0] = true;\\n\\n        for(int i=1; i<=pL; i++) {\\n            boolean flag = false; // The flag is moved here;\\n\\n            for(int j=0; j<=sL; j++) {\\n                flag = flag || dp[i-1][j];\\n                char c = p.charAt(i-1);\\n                \\n                if(c != '*') {\\n                    dp[i][j] = j>0 && dp[i-1][j-1] && (c=='?' || c==s.charAt(j-1));\\n                }\\n                else {\\n                    // For k>=0 and k<=j, if any dp[i-1][k] is true,\\n                    // then '*' will match the rest sequence in s after index k;\\n                    dp[i][j] = i==1 || flag;\\n                }\\n            }\\n        }\\n        \\n        return dp[pL][sL];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 17836,
                "title": "my-java-dp-solution",
                "content": "At first I cannot pass the the long 'aaa...' test case. Then I add more check and pass it.\\n\\n    public class Solution {\\n        public boolean isMatch(String s, String p) {\\n            int m = s.length(), n = p.length();\\n            int count = 0;\\n            for (int i = 0; i < n; i++) {\\n                if (p.charAt(i) == '*') count++;\\n            }\\n            if (count==0 && m != n) return false;\\n            else if (n - count > m) return false;\\n            \\n            boolean[] match = new boolean[m+1];\\n            match[0] = true;\\n            for (int i = 0; i < m; i++) {\\n                match[i+1] = false;\\n            }\\n            for (int i = 0; i < n; i++) {\\n                if (p.charAt(i) == '*') {\\n                    for (int j = 0; j < m; j++) {\\n                        match[j+1] = match[j] || match[j+1]; \\n                    }\\n                } else {\\n                    for (int j = m-1; j >= 0; j--) {\\n                        match[j+1] = (p.charAt(i) == '?' || p.charAt(i) == s.charAt(j)) && match[j];\\n                    }\\n                    match[0] = false;\\n                }\\n            }\\n            return match[m];\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean isMatch(String s, String p) {\\n            int m = s.length(), n = p.length();\\n            int count = 0;\\n            for (int i = 0; i < n; i++) {\\n                if (p.charAt(i) == '*') count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 17957,
                "title": "c-dp-solution",
                "content": "It seems that only Greedy solution can pass all test cases (sorry if I omit any DP solution that passes all test cases). My DP solution also fails to pass the s=aaaaaaaaaaaaaa.............. (lots of a's...). However, despite this very large case my DP solution passes all other cases. The idea is:\\n\\nf(i,j) == whether the first i chars of s match the first j chars of p. The transition equation is:\\n\\n    1). if(p[j-1]!='*') f(i, j) = f(i-1, j-1) && (s[i-1]==p[j-1] || p[j-1]=='?')\\n\\n    2). if(p[j-1]=='*') f(i, j) = f(i, j-1) || f(i-1, j)\\n\\n    bool isMatch(const char *s, const char *p) {\\n        const int m = strlen(s);\\n        const int n = strlen(p);\\n        if(m>30000) return false; // to skip the large test case\\n        vector<bool> prev(n+1,false); // to save space, just O(n) space is used\\n        prev[0]=true;\\n        for(int j=1; j<=n; j++)\\n            prev[j] = prev[j-1] && p[j-1]=='*';\\n        for(int i=1; i<=m; i++) {\\n            vector<bool> cur(n+1,false);\\n            for(int j=1; j<=n; j++) {\\n                if(p[j-1]=='*') {\\n                    cur[j] = cur[j-1] || prev[j];\\n                }\\n                else {\\n                    cur[j] = prev[j-1] && (s[i-1]==p[j-1] || p[j-1]=='?');\\n                }\\n            }\\n            prev = cur;\\n        }\\n        return prev[n];\\n    }\\n\\n> Equation 1). means that if p[j-1] is not *, f(i,j) is determined\\n> by if s[0:i-2] matches p[0:j-2] and if (s[i-1]==p[j-1] or\\n> p[j-1]=='?'). \\n> \\n> Equation 2). means that if p[j-1] is *, f(i,j) is true if either\\n> f(i,j-1) is true: s[0:i-1] matches p[0:j-2] and * is not used\\n> here; or f(i-1,j) is true: s[0:i-2] matches p[0:j-1] and * is\\n> used to match s[i-1].",
                "solutionTags": [],
                "code": "It seems that only Greedy solution can pass all test cases (sorry if I omit any DP solution that passes all test cases). My DP solution also fails to pass the s=aaaaaaaaaaaaaa.............. (lots of a's...). However, despite this very large case my DP solution passes all other cases. The idea is:\\n\\nf(i,j) == whether the first i chars of s match the first j chars of p. The transition equation is:\\n\\n    1). if(p[j-1]!='*') f(i, j) = f(i-1, j-1) && (s[i-1]==p[j-1] || p[j-1]=='?')\\n\\n    2). if(p[j-1]=='*') f(i, j) = f(i, j-1) || f(i-1, j)\\n\\n    bool isMatch(const char *s, const char *p) {\\n        const int m = strlen(s);\\n        const int n = strlen(p);\\n        if(m>30000) return false; // to skip the large test case\\n        vector<bool> prev(n+1,false); // to save space, just O(n) space is used\\n        prev[0]=true;\\n        for(int j=1; j<=n; j++)\\n            prev[j] = prev[j-1] && p[j-1]=='*';\\n        for(int i=1; i<=m; i++) {\\n            vector<bool> cur(n+1,false);\\n            for(int j=1; j<=n; j++) {\\n                if(p[j-1]=='*') {\\n                    cur[j] = cur[j-1] || prev[j];\\n                }\\n                else {\\n                    cur[j] = prev[j-1] && (s[i-1]==p[j-1] || p[j-1]=='?');\\n                }\\n            }\\n            prev = cur;\\n        }\\n        return prev[n];\\n    }\\n\\n> Equation 1). means that if p[j-1] is not *, f(i,j) is determined\\n> by if s[0:i-2] matches p[0:j-2] and if (s[i-1]==p[j-1] or\\n> p[j-1]=='?'). \\n> \\n> Equation 2). means that if p[j-1] is *, f(i,j) is true if either\\n> f(i,j-1) is true: s[0:i-1] matches p[0:j-2] and * is not used\\n> here; or f(i-1,j) is true: s[0:i-2] matches p[0:j-1] and * is\\n> used to match s[i-1].",
                "codeTag": "Unknown"
            },
            {
                "id": 2242620,
                "title": "c-recursion-memoization-tabulation",
                "content": "**RECURSION (TLE)**\\n```\\nclass Solution {\\npublic:\\n    bool f(int i,int j, string &s,string &p)\\n    {\\n        if(i<0 && j<0) return true;\\n        if(j<0 && i>=0) return false;\\n        if(i<0 && j>=0)\\n        {\\n            while(j>=0)\\n            {\\n                if(p[j]==\\'*\\') j--;\\n                else return false;\\n            }\\n            return true;\\n        }\\n        \\n        if(s[i]==p[j] || p[j]==\\'?\\') return f(i-1,j-1,s,p);\\n        \\n        if(p[j]==\\'*\\')\\n        {\\n            return f(i-1,j,s,p) || f(i,j-1,s,p);\\n            //Two cases\\n            //Consider * as len=0\\n            //Give one charcter to * and remain at *\\n            //at next step it will again be decided from both these cases\\n        }\\n        return false;\\n        \\n    }\\n    \\n    bool isMatch(string s, string p) {\\n        int n=s.length(),m=p.length();\\n        return f(n-1,m-1,s,p);\\n    }\\n};\\n```\\n**Memoization**\\n```\\nclass Solution {\\npublic:\\n    int f(int i,int j, string &s,string &p,vector<vector<int>> &dp)\\n    {\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        if(i==0 && j==0) return dp[i][j]=1;\\n        if(j==0 && i>0) return dp[i][j]=0;\\n        if(i==0 && j>0)\\n        {\\n            while(j>0)\\n            {\\n                if(p[j-1]==\\'*\\') j--;\\n                else return dp[i][j]=0;\\n            }\\n            return dp[i][j]=1;\\n        }\\n        \\n        if(s[i-1]==p[j-1] || p[j-1]==\\'?\\') return dp[i][j]=f(i-1,j-1,s,p,dp);\\n        \\n        if(p[j-1]==\\'*\\')\\n        {\\n            return dp[i][j] = f(i-1,j,s,p,dp) || f(i,j-1,s,p,dp) ? 1:0;\\n            //Two cases\\n            //Consider * as len=0\\n            //Give one charcter to * and remain at *\\n            //at next step it will again be decided from both these cases\\n        }\\n        return dp[i][j]=0;\\n        \\n    }\\n    \\n    bool isMatch(string s, string p) {\\n        int n=s.length(),m=p.length();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        return f(n,m,s,p,dp);\\n    }\\n};\\n```\\n**Tabulation**\\n```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        int n=s.length(),m=p.length();\\n        vector<vector<bool>> dp(n+1,vector<bool>(m+1));\\n        dp[0][0]=true;\\n        for(int i=1;i<=n;i++) dp[i][0]=false;\\n        \\n        bool flag=true;\\n        for(int i=1;i<=m;i++)\\n        {\\n            if(p[i-1]!=\\'*\\')\\n                flag=false;\\n            dp[0][i]=flag;\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=m;j++)\\n            {\\n                if(s[i-1]==p[j-1] || p[j-1]==\\'?\\')\\n                    dp[i][j]=dp[i-1][j-1];\\n                else if(p[j-1]==\\'*\\')\\n                    dp[i][j] = dp[i-1][j] || dp[i][j-1];\\n                else dp[i][j]=false;\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```\\n**Space Optimized**\\n```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        int n=s.length(),m=p.length();\\n        // vector<vector<bool>> dp(n+1,vector<bool>(m+1));\\n        \\n        vector<bool> prev(m+1);\\n        //Initially prev is for n=0\\n        prev[0]=true;\\n        \\n        bool flag=true;\\n        for(int i=1;i<=m;i++)\\n        {\\n            if(p[i-1]!=\\'*\\')\\n                flag=false;\\n            prev[i]=flag;\\n        }\\n        vector<bool> curr(m+1);\\n        \\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            curr[0]=false;\\n            for(int j=1;j<=m;j++)\\n            {\\n                if(s[i-1]==p[j-1] || p[j-1]==\\'?\\')\\n                    curr[j]=prev[j-1];\\n                else if(p[j-1]==\\'*\\')\\n                    curr[j] = prev[j] || curr[j-1];\\n                else curr[j]=false;\\n            }\\n            prev=curr;\\n        }\\n        return prev[m];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool f(int i,int j, string &s,string &p)\\n    {\\n        if(i<0 && j<0) return true;\\n        if(j<0 && i>=0) return false;\\n        if(i<0 && j>=0)\\n        {\\n            while(j>=0)\\n            {\\n                if(p[j]==\\'*\\') j--;\\n                else return false;\\n            }\\n            return true;\\n        }\\n        \\n        if(s[i]==p[j] || p[j]==\\'?\\') return f(i-1,j-1,s,p);\\n        \\n        if(p[j]==\\'*\\')\\n        {\\n            return f(i-1,j,s,p) || f(i,j-1,s,p);\\n            //Two cases\\n            //Consider * as len=0\\n            //Give one charcter to * and remain at *\\n            //at next step it will again be decided from both these cases\\n        }\\n        return false;\\n        \\n    }\\n    \\n    bool isMatch(string s, string p) {\\n        int n=s.length(),m=p.length();\\n        return f(n-1,m-1,s,p);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int f(int i,int j, string &s,string &p,vector<vector<int>> &dp)\\n    {\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        if(i==0 && j==0) return dp[i][j]=1;\\n        if(j==0 && i>0) return dp[i][j]=0;\\n        if(i==0 && j>0)\\n        {\\n            while(j>0)\\n            {\\n                if(p[j-1]==\\'*\\') j--;\\n                else return dp[i][j]=0;\\n            }\\n            return dp[i][j]=1;\\n        }\\n        \\n        if(s[i-1]==p[j-1] || p[j-1]==\\'?\\') return dp[i][j]=f(i-1,j-1,s,p,dp);\\n        \\n        if(p[j-1]==\\'*\\')\\n        {\\n            return dp[i][j] = f(i-1,j,s,p,dp) || f(i,j-1,s,p,dp) ? 1:0;\\n            //Two cases\\n            //Consider * as len=0\\n            //Give one charcter to * and remain at *\\n            //at next step it will again be decided from both these cases\\n        }\\n        return dp[i][j]=0;\\n        \\n    }\\n    \\n    bool isMatch(string s, string p) {\\n        int n=s.length(),m=p.length();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        return f(n,m,s,p,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        int n=s.length(),m=p.length();\\n        vector<vector<bool>> dp(n+1,vector<bool>(m+1));\\n        dp[0][0]=true;\\n        for(int i=1;i<=n;i++) dp[i][0]=false;\\n        \\n        bool flag=true;\\n        for(int i=1;i<=m;i++)\\n        {\\n            if(p[i-1]!=\\'*\\')\\n                flag=false;\\n            dp[0][i]=flag;\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=m;j++)\\n            {\\n                if(s[i-1]==p[j-1] || p[j-1]==\\'?\\')\\n                    dp[i][j]=dp[i-1][j-1];\\n                else if(p[j-1]==\\'*\\')\\n                    dp[i][j] = dp[i-1][j] || dp[i][j-1];\\n                else dp[i][j]=false;\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        int n=s.length(),m=p.length();\\n        // vector<vector<bool>> dp(n+1,vector<bool>(m+1));\\n        \\n        vector<bool> prev(m+1);\\n        //Initially prev is for n=0\\n        prev[0]=true;\\n        \\n        bool flag=true;\\n        for(int i=1;i<=m;i++)\\n        {\\n            if(p[i-1]!=\\'*\\')\\n                flag=false;\\n            prev[i]=flag;\\n        }\\n        vector<bool> curr(m+1);\\n        \\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            curr[0]=false;\\n            for(int j=1;j<=m;j++)\\n            {\\n                if(s[i-1]==p[j-1] || p[j-1]==\\'?\\')\\n                    curr[j]=prev[j-1];\\n                else if(p[j-1]==\\'*\\')\\n                    curr[j] = prev[j] || curr[j-1];\\n                else curr[j]=false;\\n            }\\n            prev=curr;\\n        }\\n        return prev[m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17939,
                "title": "python-dp-solution",
                "content": "For a 2d table, dp[i][j] would mean whether sub-pattern p[:i + 1] matches sub-string s[:j + 1].\\nMost tricky part is when the current pattern letter is `*`, suppose its index is `i`, p[:i + 1] will match sub-string s[:j + 1] if p[:i + 1] matches s[:j] *or* p[:i] matches s[:j + 1], namely current cell value is true if its top or its left is true.  Since the current row only depends on the previous row, we can use two rolling lists to do the dp instead of a matrix.\\n    \\n    def isMatch(self, s, p):\\n        l = len(s)\\n        if len(p) - p.count('*') > l:\\n            return False\\n        dp = [True]  + [False] * l\\n        for letter in p:\\n            new_dp = [dp[0] and letter == '*']\\n            if letter == '*':\\n                for j in range(l):\\n                    new_dp.append(new_dp[-1] or dp[j + 1])\\n            elif letter == '?':\\n                new_dp += dp[:l]\\n            else:\\n                new_dp += [dp[j] and s[j] == letter for j in range(l)]\\n            dp = new_dp\\n        return dp[-1]",
                "solutionTags": [
                    "Python"
                ],
                "code": "For a 2d table, dp[i][j] would mean whether sub-pattern p[:i + 1] matches sub-string s[:j + 1].\\nMost tricky part is when the current pattern letter is `*`, suppose its index is `i`, p[:i + 1] will match sub-string s[:j + 1] if p[:i + 1] matches s[:j] *or* p[:i] matches s[:j + 1], namely current cell value is true if its top or its left is true.  Since the current row only depends on the previous row, we can use two rolling lists to do the dp instead of a matrix.\\n    \\n    def isMatch(self, s, p):\\n        l = len(s)\\n        if len(p) - p.count('*') > l:\\n            return False\\n        dp = [True]  + [False] * l\\n        for letter in p:\\n            new_dp = [dp[0] and letter == '*']\\n            if letter == '*':\\n                for j in range(l):\\n                    new_dp.append(new_dp[-1] or dp[j + 1])\\n            elif letter == '?':\\n                new_dp += dp[:l]\\n            else:\\n                new_dp += [dp[j] and s[j] == letter for j in range(l)]\\n            dp = new_dp\\n        return dp[-1]",
                "codeTag": "Python3"
            },
            {
                "id": 2874339,
                "title": "python-faster-than-90-explained-with-comments",
                "content": "# Complexity\\n- Time complexity:\\nBetter than 90%\\n\\n- Space complexity:\\nBetter than 90%\\n\\n# Code\\n```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        # Initialize the pointers for the input string and the pattern\\n        i = 0\\n        j = 0\\n    \\n        # Initialize the pointers for the last character matched and the last\\n        # \\'*\\' encountered in the pattern\\n        last_match = 0\\n        star = -1\\n    \\n        # Loop through the input string and the pattern\\n        while i < len(s):\\n            # Check if the current characters in the input string and the pattern\\n            # match, or if the pattern character is a \\'?\\'\\n            if j < len(p) and (s[i] == p[j] or p[j] == \\'?\\'):\\n                # Move the pointers for the input string and the pattern forward\\n                i += 1\\n                j += 1\\n            # Check if the current pattern character is a \\'*\\'\\n            elif j < len(p) and p[j] == \\'*\\':\\n                # Store the current positions of the pointers for the input string\\n                # and the pattern\\n                last_match = i\\n                star = j\\n                # Move the pointer for the pattern forward\\n                j += 1\\n            # If none of the above conditions are met, check if we have encountered\\n            # a \\'*\\' in the pattern previously\\n            elif star != -1:\\n                # Move the pointer for the pattern back to the last \\'*\\'\\n                j = star + 1\\n                # Move the pointer for the input string to the next character\\n                # after the last character matched\\n                i = last_match + 1\\n                # Move the pointer for the last character matched forward\\n                last_match += 1\\n            # If none of the above conditions are met, the input string and the\\n            # pattern do not match\\n            else:\\n                return False\\n    \\n        # Loop through the remaining characters in the pattern and check if they\\n        # are all \\'*\\' characters\\n        while j < len(p) and p[j] == \\'*\\':\\n            j += 1\\n    \\n        # Return True if all the characters in the pattern have been processed,\\n        # False otherwise\\n        return j == len(p)\\n    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        # Initialize the pointers for the input string and the pattern\\n        i = 0\\n        j = 0\\n    \\n        # Initialize the pointers for the last character matched and the last\\n        # \\'*\\' encountered in the pattern\\n        last_match = 0\\n        star = -1\\n    \\n        # Loop through the input string and the pattern\\n        while i < len(s):\\n            # Check if the current characters in the input string and the pattern\\n            # match, or if the pattern character is a \\'?\\'\\n            if j < len(p) and (s[i] == p[j] or p[j] == \\'?\\'):\\n                # Move the pointers for the input string and the pattern forward\\n                i += 1\\n                j += 1\\n            # Check if the current pattern character is a \\'*\\'\\n            elif j < len(p) and p[j] == \\'*\\':\\n                # Store the current positions of the pointers for the input string\\n                # and the pattern\\n                last_match = i\\n                star = j\\n                # Move the pointer for the pattern forward\\n                j += 1\\n            # If none of the above conditions are met, check if we have encountered\\n            # a \\'*\\' in the pattern previously\\n            elif star != -1:\\n                # Move the pointer for the pattern back to the last \\'*\\'\\n                j = star + 1\\n                # Move the pointer for the input string to the next character\\n                # after the last character matched\\n                i = last_match + 1\\n                # Move the pointer for the last character matched forward\\n                last_match += 1\\n            # If none of the above conditions are met, the input string and the\\n            # pattern do not match\\n            else:\\n                return False\\n    \\n        # Loop through the remaining characters in the pattern and check if they\\n        # are all \\'*\\' characters\\n        while j < len(p) and p[j] == \\'*\\':\\n            j += 1\\n    \\n        # Return True if all the characters in the pattern have been processed,\\n        # False otherwise\\n        return j == len(p)\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560759,
                "title": "java-easiest-solution-with-proper-comments",
                "content": "Hi Family,\\n\\nPlease have a look into the code with proper comment\\nIf you liked the code Please Please upvote !!!\\n\\n```\\nclass Solution {\\n    Boolean dp[][];\\n    public boolean isMatch(String s, String p) {\\n        int m = p.length();\\n        int n = s.length();\\n        \\n        dp = new Boolean[m][n];\\n        \\n        return is_match(m-1,n-1,p,s);\\n    }\\n    \\n    private boolean is_match(int m,int n,String p,String s){\\n        \\n        //Base Case\\n        //if m and n both are 0 i.e strings are matching\\n        if (m<0 && n<0) return true;\\n        \\n        // if n has some character but m is empty\\n        if (m<0 && n>=0) return false;\\n        \\n        // if m has some character but n is empty\\n        \\n        if (n<0 && m>=0) {\\n            /*\\n                if str = \"\" && pattern = \"***\" then return true;\\n                    because we can neglect the * also\\n                else str = \"\"  && pattern = \"sd**\" return false;\\n                    because after neglecting the * pattern has some more character\\n            \\n            */\\n            for (int i=0;i<=m;i++){\\n                if (p.charAt(i) != \\'*\\') return false;\\n            }\\n            return true;\\n        }\\n        \\n        //Memorisation\\n        if (dp[m][n] != null) return dp[m][n];\\n        \\n        //if both the character is equal || patern[m] == ?\\n        if (p.charAt(m) == s.charAt(n) || p.charAt(m) == \\'?\\'){\\n            return dp[m][n] = is_match(m-1,n-1,p,s);\\n        }\\n        \\n        // if p has \\'*\\'\\n        if (p.charAt(m) == \\'*\\'){\\n            return dp[m][n] = is_match(m-1,n,p,s) || is_match(m,n-1,p,s);\\n        }\\n        // if both the character is not equal\\n        return false;\\n            \\n    }\\n}\\n```\\n\\nThanks\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    Boolean dp[][];\\n    public boolean isMatch(String s, String p) {\\n        int m = p.length();\\n        int n = s.length();\\n        \\n        dp = new Boolean[m][n];\\n        \\n        return is_match(m-1,n-1,p,s);\\n    }\\n    \\n    private boolean is_match(int m,int n,String p,String s){\\n        \\n        //Base Case\\n        //if m and n both are 0 i.e strings are matching\\n        if (m<0 && n<0) return true;\\n        \\n        // if n has some character but m is empty\\n        if (m<0 && n>=0) return false;\\n        \\n        // if m has some character but n is empty\\n        \\n        if (n<0 && m>=0) {\\n            /*\\n                if str = \"\" && pattern = \"***\" then return true;\\n                    because we can neglect the * also\\n                else str = \"\"  && pattern = \"sd**\" return false;\\n                    because after neglecting the * pattern has some more character\\n            \\n            */\\n            for (int i=0;i<=m;i++){\\n                if (p.charAt(i) != \\'*\\') return false;\\n            }\\n            return true;\\n        }\\n        \\n        //Memorisation\\n        if (dp[m][n] != null) return dp[m][n];\\n        \\n        //if both the character is equal || patern[m] == ?\\n        if (p.charAt(m) == s.charAt(n) || p.charAt(m) == \\'?\\'){\\n            return dp[m][n] = is_match(m-1,n-1,p,s);\\n        }\\n        \\n        // if p has \\'*\\'\\n        if (p.charAt(m) == \\'*\\'){\\n            return dp[m][n] = is_match(m-1,n,p,s) || is_match(m,n-1,p,s);\\n        }\\n        // if both the character is not equal\\n        return false;\\n            \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 895500,
                "title": "dp-bottom-up-java-solution-with-detailed-explanation",
                "content": "```\\n\\t // Bottom Up DP\\n    public boolean isMatch(String s, String p) {\\n        // corner case\\n        if (s == null || p == null)\\n            return false;\\n\\n        int m = s.length();\\n        int n = p.length();\\n\\n        boolean[][] dp = new boolean[n + 1][m + 1];\\n\\n        // 1. dp[0][0] = true, since empty string matches empty pattern\\n        dp[0][0] = true;\\n\\n        // 2. dp[0][i] = false\\n        // since empty pattern cannot match non-empty string\\n\\n        // 3. dp[j][0]\\n        // for any continuative \\'*\\' will match empty string\\n        // e.g s=\\'aasffdasda\\' p=\\'*\\'/\\'**\\'/\\'***\\'....\\n        for (int j = 1; j < n + 1; j++) {\\n            if (p.charAt(j - 1) == \\'*\\') {\\n                dp[j][0] = dp[j - 1][0];\\n            }\\n        }\\n\\n        // 1. if p.charAt(j) == s.charAt(i), match single character\\n        // =>>> dp[i][j] = dp[i - 1][j - 1]\\n        // 2. if p.charAt(j) == \\'?\\', \\'?\\' match single character\\n        // =>>> dp[i][j] = dp[i - 1][j - 1]\\n\\n        // 3. if p.charAt(j) == \\'*\\', dp[i][j]=dp[i-1][j]||dp[i][j-1]\\n        // =>>> a. \\'*\\' match empty: dp[i][j]=dp[i-1][j]\\n        // =>>> b. \\'*\\' match multiple characters: dp[i][j]=dp[i][j-1]\\n\\n        for (int i = 1; i < m + 1; i++) {\\n            for (int j = 1; j < n + 1; j++) {\\n                char charS = s.charAt(i - 1);\\n                char charP = p.charAt(j - 1);\\n                if (charS == charP || charP == \\'?\\')\\n                    dp[j][i] = dp[j - 1][i - 1];\\n                else if (charP == \\'*\\')\\n                    dp[j][i] = dp[j - 1][i] || dp[j][i - 1];\\n\\n            }\\n        }\\n\\n        return dp[n][m];\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\t // Bottom Up DP\\n    public boolean isMatch(String s, String p) {\\n        // corner case\\n        if (s == null || p == null)\\n            return false;\\n\\n        int m = s.length();\\n        int n = p.length();\\n\\n        boolean[][] dp = new boolean[n + 1][m + 1];\\n\\n        // 1. dp[0][0] = true, since empty string matches empty pattern\\n        dp[0][0] = true;\\n\\n        // 2. dp[0][i] = false\\n        // since empty pattern cannot match non-empty string\\n\\n        // 3. dp[j][0]\\n        // for any continuative \\'*\\' will match empty string\\n        // e.g s=\\'aasffdasda\\' p=\\'*\\'/\\'**\\'/\\'***\\'....\\n        for (int j = 1; j < n + 1; j++) {\\n            if (p.charAt(j - 1) == \\'*\\') {\\n                dp[j][0] = dp[j - 1][0];\\n            }\\n        }\\n\\n        // 1. if p.charAt(j) == s.charAt(i), match single character\\n        // =>>> dp[i][j] = dp[i - 1][j - 1]\\n        // 2. if p.charAt(j) == \\'?\\', \\'?\\' match single character\\n        // =>>> dp[i][j] = dp[i - 1][j - 1]\\n\\n        // 3. if p.charAt(j) == \\'*\\', dp[i][j]=dp[i-1][j]||dp[i][j-1]\\n        // =>>> a. \\'*\\' match empty: dp[i][j]=dp[i-1][j]\\n        // =>>> b. \\'*\\' match multiple characters: dp[i][j]=dp[i][j-1]\\n\\n        for (int i = 1; i < m + 1; i++) {\\n            for (int j = 1; j < n + 1; j++) {\\n                char charS = s.charAt(i - 1);\\n                char charP = p.charAt(j - 1);\\n                if (charS == charP || charP == \\'?\\')\\n                    dp[j][i] = dp[j - 1][i - 1];\\n                else if (charP == \\'*\\')\\n                    dp[j][i] = dp[j - 1][i] || dp[j][i - 1];\\n\\n            }\\n        }\\n\\n        return dp[n][m];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 477823,
                "title": "recursive-dfs-solution-with-memoization-top-down-approach",
                "content": "Algorithm:\\n- We have two pointers i,j pointing towards `S` and `P`.\\n- We create a dp[][] where dp[i][j]=1 indicates that 0..ith substring in `S` has been matched with 0..jth substring in `P`\\n- If s[i]==p[j] then we increment both check for s[i+1] and p[j+1]\\n- If given char in p is `*` then we have certainly three options\\n- either match the current `ith` char in with  `*` in j\\n- either end the matching of current `ith` char with `*` and increment both (i,j) -> (i+1,j+1).\\n- or match `*` with null characters and increment only `j`.\\n```\\nclass Solution {\\n    \\n    Integer[][] dp;\\n    public boolean isMatch(String s, String p) {\\n         \\n        dp = new Integer[s.length()+1][p.length()+1];\\n        dp[s.length()][p.length()] = 1;\\n        \\n        for(int i=p.length()-1;i>=0;--i){\\n            dp[s.length()][i] = p.charAt(i)==\\'*\\'? dp[s.length()][i+1]:0;\\n        }\\n        \\n        for(int j=0;j<s.length();++j){  dp[j][p.length()] = 0;}\\n        \\n        dfsHelper(s,p,0,0);\\n        return dp[0][0]==1;\\n        \\n    }\\n    \\n    private int dfsHelper(String s,String p,int sp,int pp){\\n        \\n        if(dp[sp][pp]!=null){\\n            return dp[sp][pp];\\n        }\\n        \\n        if(s.charAt(sp)==p.charAt(pp) || p.charAt(pp)==\\'?\\'){\\n            dp[sp][pp] = dfsHelper(s,p,sp+1,pp+1);\\n        }\\n        \\n        else if(p.charAt(pp)==\\'*\\'){\\n            \\n            int resultOne = dfsHelper(s,p,sp+1,pp); // matching seq with *\\n            int resultTwo = dfsHelper(s,p,sp,pp+1); // matching * with empty string\\n            int resultThree = dfsHelper(s,p,sp+1,pp+1); // end matching seq with * and inc both\\n            \\n            dp[sp][pp] = (resultOne + resultTwo + resultThree)>0 ? 1:0;\\n            \\n        }else{\\n            dp[sp][pp] = 0;\\n        }\\n        \\n        return dp[sp][pp]; \\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/arihant95/image_1578804311.png)\\n\\n",
                "solutionTags": [
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    \\n    Integer[][] dp;\\n    public boolean isMatch(String s, String p) {\\n         \\n        dp = new Integer[s.length()+1][p.length()+1];\\n        dp[s.length()][p.length()] = 1;\\n        \\n        for(int i=p.length()-1;i>=0;--i){\\n            dp[s.length()][i] = p.charAt(i)==\\'*\\'? dp[s.length()][i+1]:0;\\n        }\\n        \\n        for(int j=0;j<s.length();++j){  dp[j][p.length()] = 0;}\\n        \\n        dfsHelper(s,p,0,0);\\n        return dp[0][0]==1;\\n        \\n    }\\n    \\n    private int dfsHelper(String s,String p,int sp,int pp){\\n        \\n        if(dp[sp][pp]!=null){\\n            return dp[sp][pp];\\n        }\\n        \\n        if(s.charAt(sp)==p.charAt(pp) || p.charAt(pp)==\\'?\\'){\\n            dp[sp][pp] = dfsHelper(s,p,sp+1,pp+1);\\n        }\\n        \\n        else if(p.charAt(pp)==\\'*\\'){\\n            \\n            int resultOne = dfsHelper(s,p,sp+1,pp); // matching seq with *\\n            int resultTwo = dfsHelper(s,p,sp,pp+1); // matching * with empty string\\n            int resultThree = dfsHelper(s,p,sp+1,pp+1); // end matching seq with * and inc both\\n            \\n            dp[sp][pp] = (resultOne + resultTwo + resultThree)>0 ? 1:0;\\n            \\n        }else{\\n            dp[sp][pp] = 0;\\n        }\\n        \\n        return dp[sp][pp]; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 899000,
                "title": "java-dp-memoization-video-explanation",
                "content": "```\\nclass Solution {\\n    // global dp array \\n    Boolean dp[][];\\n    \\n    boolean wm(String s , String p , int i , int j){\\n        // if we reach end of both string simultaneously return true\\n        if(s.length()==i && p.length() == j) return true;\\n        \\n        \\n        //if string s has ended we need to check that remaining characters in p are all asteriks.\\n        if(i == s.length()){\\n            for(int index = j;index<p.length();index++){\\n                if(p.charAt(index)!=\\'*\\'){\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n        \\n        //if string p has ended and s still remains , there is no way to match, think think!\\n        if(j == p.length() && i!=s.length())return false;\\n        \\n        //if sub problem already solved return it\\n        if(dp[i][j]!=null)return dp[i][j];\\n        \\n        boolean ans = false;\\n        \\n        if(p.charAt(j)==\\'?\\'){\\n            //using ? as a single character(go ahead in both s and p )\\n            if(wm(s,p,i+1,j+1)){\\n                ans = true;\\n            }\\n          \\n        }\\n        else if(p.charAt(j)==\\'*\\'){\\n            //using * as empty string (go ahead in just p)\\n            if(wm(s,p,i,j+1)){\\n                ans = true;\\n            }      \\n            //using * as multiple characters(go ahead in s but not p)\\n             if(wm(s,p,i+1,j)){\\n                ans = true;\\n            }\\n            // using * as single character(go ahead in both s and p)\\n             if(wm(s,p,i+1,j+1)){\\n                ans   = true;\\n            }\\n            \\n        }\\n        //if both i and j have characters then if they match go ahead in both else ans is false by default\\n        else if(p.charAt(j)==s.charAt(i) && wm(s,p,i+1,j+1)){\\n                ans= true;\\n        }\\n        dp[i][j] = ans;\\n        return ans;\\n    }\\n    public boolean isMatch(String s, String p) {\\n        dp = new Boolean[s.length()][p.length()];\\n        return wm (s , p , 0 , 0);\\n    }\\n}\\n```\\nVideo Explanation:\\nhttps://www.youtube.com/watch?v=x4TG1x0STNE",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    // global dp array \\n    Boolean dp[][];\\n    \\n    boolean wm(String s , String p , int i , int j){\\n        // if we reach end of both string simultaneously return true\\n        if(s.length()==i && p.length() == j) return true;\\n        \\n        \\n        //if string s has ended we need to check that remaining characters in p are all asteriks.\\n        if(i == s.length()){\\n            for(int index = j;index<p.length();index++){\\n                if(p.charAt(index)!=\\'*\\'){\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n        \\n        //if string p has ended and s still remains , there is no way to match, think think!\\n        if(j == p.length() && i!=s.length())return false;\\n        \\n        //if sub problem already solved return it\\n        if(dp[i][j]!=null)return dp[i][j];\\n        \\n        boolean ans = false;\\n        \\n        if(p.charAt(j)==\\'?\\'){\\n            //using ? as a single character(go ahead in both s and p )\\n            if(wm(s,p,i+1,j+1)){\\n                ans = true;\\n            }\\n          \\n        }\\n        else if(p.charAt(j)==\\'*\\'){\\n            //using * as empty string (go ahead in just p)\\n            if(wm(s,p,i,j+1)){\\n                ans = true;\\n            }      \\n            //using * as multiple characters(go ahead in s but not p)\\n             if(wm(s,p,i+1,j)){\\n                ans = true;\\n            }\\n            // using * as single character(go ahead in both s and p)\\n             if(wm(s,p,i+1,j+1)){\\n                ans   = true;\\n            }\\n            \\n        }\\n        //if both i and j have characters then if they match go ahead in both else ans is false by default\\n        else if(p.charAt(j)==s.charAt(i) && wm(s,p,i+1,j+1)){\\n                ans= true;\\n        }\\n        dp[i][j] = ans;\\n        return ans;\\n    }\\n    public boolean isMatch(String s, String p) {\\n        dp = new Boolean[s.length()][p.length()];\\n        return wm (s , p , 0 , 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1054184,
                "title": "cpp-easy-solution-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    bool match(string& s, string& p, int i, int j, vector<vector<int>>& v){\\n        if(i==s.size()&&j==p.size())\\n            return true;\\n        else if(i==s.size()) \\n            return (p[j]==\\'*\\'&& match(s,p,i,j+1,v));\\n        else if(j==p.size())\\n            return false;\\n        \\n        if(v[i][j]!=-1) return v[i][j];\\n        \\n        if(p[j]==\\'*\\')\\n            return v[i][j]= (match(s,p,i,j+1,v)||match(s,p,i+1,j,v));\\n        \\n        if(p[j]==\\'?\\'||s[i]==p[j])\\n            return v[i][j] = match(s,p,i+1,j+1,v);\\n        \\n        return false;\\n    }\\n    \\n    bool isMatch(string s, string p) {\\n       vector<vector<int>> v(s.size(), vector<int>(p.size(), -1));  \\n       return match(s,p,0,0,v);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool match(string& s, string& p, int i, int j, vector<vector<int>>& v){\\n        if(i==s.size()&&j==p.size())\\n            return true;\\n        else if(i==s.size()) \\n            return (p[j]==\\'*\\'&& match(s,p,i,j+1,v));\\n        else if(j==p.size())\\n            return false;\\n        \\n        if(v[i][j]!=-1) return v[i][j];\\n        \\n        if(p[j]==\\'*\\')\\n            return v[i][j]= (match(s,p,i,j+1,v)||match(s,p,i+1,j,v));\\n        \\n        if(p[j]==\\'?\\'||s[i]==p[j])\\n            return v[i][j] = match(s,p,i+1,j+1,v);\\n        \\n        return false;\\n    }\\n    \\n    bool isMatch(string s, string p) {\\n       vector<vector<int>> v(s.size(), vector<int>(p.size(), -1));  \\n       return match(s,p,0,0,v);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 270729,
                "title": "java-13ms-dp-solution-with-explanation",
                "content": "This problem is simliar to [10. Regular Expression Matching](https://leetcode.com/problems/regular-expression-matching/). The difference lies in how the ```*``` works. In the previous problem, ```*``` can only matches zero or more of its preceding element. In this problem, ```*``` can match any sequence (including empty sequence). \\nOf course, both the problems can be solved with DP, and the key is how we process ```*```.  In the previous problem, a* can be decoded as zero ```a```, one ```a``` or more ```a```. Similarly, in this problem, ```*``` can be decoded as empty sequence, one character or more character. \\nHere, we use a two demension array to denote whether substrings of ```s``` and ```p``` match. ```match[i][j]``` denotes whether ```s.substring(0, i)``` and ```p.substring(0, j)``` matches. If ```p.charAt(j)``` is not ```*```, we judge whether ```p.charAt(j)``` and ```s.charAt(i)``` matches. If ```p.charAt(j)``` is ```*```, then there could be three conditions:\\n1. ```match[i][j] = match[i][j - 1]```, i.e., ```*``` is decoded as empty sequence\\n2. ```match[i][j] = match[i - 1][j - 1]```, i.e., ```*``` is decoded as one character\\n3. ```match[i][j] = match[i - 1][j]```, i.e., ```*``` is decoded as more than one character\\n```\\npublic boolean isMatch(String s, String p) {\\n\\tboolean match[][] = new boolean[s.length() + 1][p.length() + 1];\\n\\tmatch[0][0] = true;\\n\\tfor (int i = 0; i < p.length(); i++) // judge whether the substring of p matchese empty sequence\\n\\t\\tif (p.charAt(i) == \\'*\\')\\n\\t\\t\\tmatch[0][i + 1] = match[0][i];\\n\\tfor (int i = 0; i < s.length(); i++)\\n\\t\\tfor (int j = 0; j < p.length(); j++) {\\n\\t\\t\\tif( p.charAt(j) == \\'*\\' )\\n\\t\\t\\t\\tmatch[i + 1][j + 1] = (match[i][j + 1] | match[i + 1][j] | match[i][j]);\\n\\t\\t\\telse if( s.charAt(i) == p.charAt(j) || p.charAt(j) == \\'?\\' )\\n\\t\\t\\t\\tmatch[i + 1][j + 1] = match[i][j];\\n\\t\\t}\\n\\treturn match[s.length()][p.length()];\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```*```\n```*```\n```*```\n```*```\n```a```\n```a```\n```a```\n```*```\n```s```\n```p```\n```match[i][j]```\n```s.substring(0, i)```\n```p.substring(0, j)```\n```p.charAt(j)```\n```*```\n```p.charAt(j)```\n```s.charAt(i)```\n```p.charAt(j)```\n```*```\n```match[i][j] = match[i][j - 1]```\n```*```\n```match[i][j] = match[i - 1][j - 1]```\n```*```\n```match[i][j] = match[i - 1][j]```\n```*```\n```\\npublic boolean isMatch(String s, String p) {\\n\\tboolean match[][] = new boolean[s.length() + 1][p.length() + 1];\\n\\tmatch[0][0] = true;\\n\\tfor (int i = 0; i < p.length(); i++) // judge whether the substring of p matchese empty sequence\\n\\t\\tif (p.charAt(i) == \\'*\\')\\n\\t\\t\\tmatch[0][i + 1] = match[0][i];\\n\\tfor (int i = 0; i < s.length(); i++)\\n\\t\\tfor (int j = 0; j < p.length(); j++) {\\n\\t\\t\\tif( p.charAt(j) == \\'*\\' )\\n\\t\\t\\t\\tmatch[i + 1][j + 1] = (match[i][j + 1] | match[i + 1][j] | match[i][j]);\\n\\t\\t\\telse if( s.charAt(i) == p.charAt(j) || p.charAt(j) == \\'?\\' )\\n\\t\\t\\t\\tmatch[i + 1][j + 1] = match[i][j];\\n\\t\\t}\\n\\treturn match[s.length()][p.length()];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2194986,
                "title": "dp-solution-4-different-solutions",
                "content": "**Recursive:** Time Limit Exceeded\\n\\n\\tTime Complexity: O(Exponential)\\n\\tSpace Complexity: O(N + M)\\n\\t\\n```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        int n = p.length();\\n        int m = s.length();\\n        \\n        return f(n - 1, m - 1, p, s);\\n    }\\n    \\n    private boolean f(int i, int j, String p, String s) {\\n        \\n        // Base Case\\n        \\n        // if both strings get exhausted\\n        if (i < 0 && j < 0) return true;\\n        \\n        // if one get exhausted and other didn\\'t\\n        if (i < 0 && j >= 0) return false;\\n        \\n        // if p is left, it has to be all \\'*\\'\\n        if (j < 0 && i >= 0) {\\n            for (int k = 0; k <= i; k++) {\\n                if (p.charAt(k) != \\'*\\') {\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n        \\n\\n        // If match found or \\'?\\' is found \\n        if (p.charAt(i) == s.charAt(j) || p.charAt(i) == \\'?\\') {\\n            return f(i - 1, j - 1, p, s);\\n        }\\n        \\n        // if it is a \\'*\\'\\n        if (p.charAt(i) == \\'*\\') {\\n            return f (i - 1, j, p, s) || f (i, j - 1, p, s);\\n        }\\n        \\n        // No match found\\n        return false;\\n    }\\n}\\n```\\n\\n**Memoization:**\\n\\n\\tTime Complexity: O(N x M)\\n\\tSpace Complexity: O(N x M) + O(N + M)\\n\\t\\n```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        int n = p.length();\\n        int m = s.length();\\n        \\n        int[][] dp = new int[n][m];\\n        for (int[] row: dp) {\\n            Arrays.fill(row, -1);\\n        }\\n        \\n        return f(n - 1, m - 1, p, s, dp);\\n    }\\n    \\n    private boolean f(int i, int j, String p, String s, int[][] dp) {\\n        \\n        // Base Case\\n        \\n        // if both strings get exhausted\\n        if (i < 0 && j < 0) return true;\\n        \\n        // if one get exhausted and other didn\\'t\\n        if (i < 0 && j >= 0) return false;\\n        \\n        // if p is left, it has to be all \\'*\\'\\n        if (j < 0 && i >= 0) {\\n            for (int k = 0; k <= i; k++) {\\n                if (p.charAt(k) != \\'*\\') {\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n        \\n        \\n        if (dp[i][j] != -1) {\\n            return dp[i][j] == 1 ? true : false;\\n        }\\n        \\n        // If match found or \\'?\\' is found \\n        if (p.charAt(i) == s.charAt(j) || p.charAt(i) == \\'?\\') {\\n            boolean flag = f(i - 1, j - 1, p, s, dp);\\n            dp[i][j] = (flag == true) ? 1 : 0;\\n            \\n            return flag;\\n        }\\n        \\n        // if it is a \\'*\\'\\n        if (p.charAt(i) == \\'*\\') {\\n            boolean flag = f (i - 1, j, p, s, dp) || f (i, j - 1, p, s, dp);\\n            dp[i][j] = (flag == true) ? 1 : 0;\\n            \\n            return flag;\\n        }\\n        \\n        // No match found\\n        dp[i][j] = 0;\\n        return false;\\n    }\\n}\\n```\\n\\n**Tabulation:**\\n\\n\\tTime Complexity: O(N x M)\\n\\tSpace Complexity: O(N x M)\\n\\t\\n```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        int n = p.length();\\n        int m = s.length();\\n        \\n        boolean[][] dp = new boolean[n + 1][m + 1];\\n        \\n        // Base Case\\n        dp[0][0] = true;\\n        \\n        for (int j = 1; j <= m; j++) {\\n            dp[0][j] = false;\\n        }\\n        \\n        for (int i = 1; i <= n; i++) {\\n            boolean flag = true;\\n            for (int k = 1; k <= i; k++) {\\n                if (p.charAt(k - 1) != \\'*\\') {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            dp[i][0] = flag;\\n        }\\n        \\n        \\n        \\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= m; j++) {\\n                // If match found or \\'?\\' is found \\n                if (p.charAt(i - 1) == s.charAt(j - 1) || p.charAt(i - 1) == \\'?\\') {\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                }\\n\\n                // if it is a \\'*\\'\\n                else if (p.charAt(i - 1) == \\'*\\') {\\n                    dp[i][j] = dp[i - 1][j] || dp[i][j - 1];\\n                }\\n\\n                // No match found\\n                else dp[i][j] = false;\\n            }\\n        }\\n        \\n        return dp[n][m];\\n    }\\n}\\n```\\n\\n**Space Optimised:**\\n\\n\\tTime Complexity: O(N x M)\\n\\tSpace Complexity: O(M) + O(M)\\n\\t\\n```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        int n = p.length();\\n        int m = s.length();\\n        \\n        boolean[] prev = new boolean[m + 1];\\n        \\n        // Base Case\\n        prev[0] = true;\\n        \\n        for (int j = 1; j <= m; j++) {\\n            prev[j] = false;\\n        }\\n        \\n        for (int i = 1; i <= n; i++) {\\n            boolean[] cur = new boolean[m + 1];\\n            \\n            boolean flag = true;\\n            for (int k = 1; k <= i; k++) {\\n                if (p.charAt(k - 1) != \\'*\\') {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            cur[0] = flag;\\n            \\n            for (int j = 1; j <= m; j++) {\\n                // If match found or \\'?\\' is found \\n                if (p.charAt(i - 1) == s.charAt(j - 1) || p.charAt(i - 1) == \\'?\\') {\\n                    cur[j] = prev[j - 1];\\n                }\\n\\n                // if it is a \\'*\\'\\n                else if (p.charAt(i - 1) == \\'*\\') {\\n                    cur[j] = prev[j] || cur[j - 1];\\n                }\\n\\n                // No match found\\n                else cur[j] = false;\\n            }\\n            prev = cur;\\n        }\\n        \\n        return prev[m];\\n    }\\n}\\n\\n// Please upvote if you find this helpful\\n// Feel free to ask doubt\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        int n = p.length();\\n        int m = s.length();\\n        \\n        return f(n - 1, m - 1, p, s);\\n    }\\n    \\n    private boolean f(int i, int j, String p, String s) {\\n        \\n        // Base Case\\n        \\n        // if both strings get exhausted\\n        if (i < 0 && j < 0) return true;\\n        \\n        // if one get exhausted and other didn\\'t\\n        if (i < 0 && j >= 0) return false;\\n        \\n        // if p is left, it has to be all \\'*\\'\\n        if (j < 0 && i >= 0) {\\n            for (int k = 0; k <= i; k++) {\\n                if (p.charAt(k) != \\'*\\') {\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n        \\n\\n        // If match found or \\'?\\' is found \\n        if (p.charAt(i) == s.charAt(j) || p.charAt(i) == \\'?\\') {\\n            return f(i - 1, j - 1, p, s);\\n        }\\n        \\n        // if it is a \\'*\\'\\n        if (p.charAt(i) == \\'*\\') {\\n            return f (i - 1, j, p, s) || f (i, j - 1, p, s);\\n        }\\n        \\n        // No match found\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        int n = p.length();\\n        int m = s.length();\\n        \\n        int[][] dp = new int[n][m];\\n        for (int[] row: dp) {\\n            Arrays.fill(row, -1);\\n        }\\n        \\n        return f(n - 1, m - 1, p, s, dp);\\n    }\\n    \\n    private boolean f(int i, int j, String p, String s, int[][] dp) {\\n        \\n        // Base Case\\n        \\n        // if both strings get exhausted\\n        if (i < 0 && j < 0) return true;\\n        \\n        // if one get exhausted and other didn\\'t\\n        if (i < 0 && j >= 0) return false;\\n        \\n        // if p is left, it has to be all \\'*\\'\\n        if (j < 0 && i >= 0) {\\n            for (int k = 0; k <= i; k++) {\\n                if (p.charAt(k) != \\'*\\') {\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n        \\n        \\n        if (dp[i][j] != -1) {\\n            return dp[i][j] == 1 ? true : false;\\n        }\\n        \\n        // If match found or \\'?\\' is found \\n        if (p.charAt(i) == s.charAt(j) || p.charAt(i) == \\'?\\') {\\n            boolean flag = f(i - 1, j - 1, p, s, dp);\\n            dp[i][j] = (flag == true) ? 1 : 0;\\n            \\n            return flag;\\n        }\\n        \\n        // if it is a \\'*\\'\\n        if (p.charAt(i) == \\'*\\') {\\n            boolean flag = f (i - 1, j, p, s, dp) || f (i, j - 1, p, s, dp);\\n            dp[i][j] = (flag == true) ? 1 : 0;\\n            \\n            return flag;\\n        }\\n        \\n        // No match found\\n        dp[i][j] = 0;\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        int n = p.length();\\n        int m = s.length();\\n        \\n        boolean[][] dp = new boolean[n + 1][m + 1];\\n        \\n        // Base Case\\n        dp[0][0] = true;\\n        \\n        for (int j = 1; j <= m; j++) {\\n            dp[0][j] = false;\\n        }\\n        \\n        for (int i = 1; i <= n; i++) {\\n            boolean flag = true;\\n            for (int k = 1; k <= i; k++) {\\n                if (p.charAt(k - 1) != \\'*\\') {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            dp[i][0] = flag;\\n        }\\n        \\n        \\n        \\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= m; j++) {\\n                // If match found or \\'?\\' is found \\n                if (p.charAt(i - 1) == s.charAt(j - 1) || p.charAt(i - 1) == \\'?\\') {\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                }\\n\\n                // if it is a \\'*\\'\\n                else if (p.charAt(i - 1) == \\'*\\') {\\n                    dp[i][j] = dp[i - 1][j] || dp[i][j - 1];\\n                }\\n\\n                // No match found\\n                else dp[i][j] = false;\\n            }\\n        }\\n        \\n        return dp[n][m];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        int n = p.length();\\n        int m = s.length();\\n        \\n        boolean[] prev = new boolean[m + 1];\\n        \\n        // Base Case\\n        prev[0] = true;\\n        \\n        for (int j = 1; j <= m; j++) {\\n            prev[j] = false;\\n        }\\n        \\n        for (int i = 1; i <= n; i++) {\\n            boolean[] cur = new boolean[m + 1];\\n            \\n            boolean flag = true;\\n            for (int k = 1; k <= i; k++) {\\n                if (p.charAt(k - 1) != \\'*\\') {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            cur[0] = flag;\\n            \\n            for (int j = 1; j <= m; j++) {\\n                // If match found or \\'?\\' is found \\n                if (p.charAt(i - 1) == s.charAt(j - 1) || p.charAt(i - 1) == \\'?\\') {\\n                    cur[j] = prev[j - 1];\\n                }\\n\\n                // if it is a \\'*\\'\\n                else if (p.charAt(i - 1) == \\'*\\') {\\n                    cur[j] = prev[j] || cur[j - 1];\\n                }\\n\\n                // No match found\\n                else cur[j] = false;\\n            }\\n            prev = cur;\\n        }\\n        \\n        return prev[m];\\n    }\\n}\\n\\n// Please upvote if you find this helpful\\n// Feel free to ask doubt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909407,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func isMatch(_ s: String, _ p: String) -> Bool {\\n        var regular = \"\"\\n        var last: Character = \" \"\\n        \\n        for c in p {\\n            if c == \"?\" {\\n                regular += \".\"\\n            } else if c == \"*\" && last != \"*\" {\\n                regular += \".*\"\\n            } else {\\n                regular += String(c)\\n            }\\n            last = c\\n        }\\n        return regularExpressionMatching(s, regular)\\n    }\\n\\n\\n    func regularExpressionMatching(_ s: String, _ p: String) -> Bool {\\n        var string = Array(s)\\n        var chars: [Character] = []\\n        var marks : [Bool] = []\\n        var isMark: Bool = false\\n        var list = [[-1, -1, 1]] // [start, end, is need to add next start]\\n        var max = Int.min\\n\\n\\n        func nextRange(_ list: [[Int]], _ char: Character, _ mark: Bool) -> [[Int]] {\\n            var res = Set<[Int]>()\\n            for range in list {\\n                let lower = range[0] + range[2]\\n                let upper = range[1] + 1\\n                for i in lower...upper {\\n                    if mark {\\n                        var j = i\\n                        var count = 0\\n                        while j < string.count {\\n                            if char == string[j] || char == \".\" {\\n                                j += 1\\n                                count += 1\\n                            } else {\\n                                break\\n                            }\\n                        }\\n                        j = i + (count > 0 ? count - 1 : 0) \\n                        if count > 0 {\\n                            res.insert([i, j, 0])\\n                        } else {\\n                            res.insert(range)\\n                        }\\n                    } else {\\n                        if i < string.count && (char == string[i] || char == \".\") {\\n                            res.insert([i, i, 1])\\n                        }\\n                    }\\n                }\\n            }\\n\\n            return Array(res)\\n        }\\n\\n        for (_, c) in p.enumerated().reversed() {\\n            if c == \"*\" {\\n                isMark = true\\n            } else {\\n                chars.insert(c, at: 0)\\n                marks.insert(isMark, at: 0)\\n                isMark = false\\n            }\\n        }\\n\\n        for (index, c) in chars.enumerated() {\\n            let mark = marks[index]\\n            list = nextRange(list, c, mark)\\n        }\\n        for rang in list { max = max > rang[1] ? max : rang[1] }        \\n        return max == string.count - 1\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func isMatch(_ s: String, _ p: String) -> Bool {\\n        var regular = \"\"\\n        var last: Character = \" \"\\n        \\n        for c in p {\\n            if c == \"?\" {\\n                regular += \".\"\\n            } else if c == \"*\" && last != \"*\" {\\n                regular += \".*\"\\n            } else {\\n                regular += String(c)\\n            }\\n            last = c\\n        }\\n        return regularExpressionMatching(s, regular)\\n    }\\n\\n\\n    func regularExpressionMatching(_ s: String, _ p: String) -> Bool {\\n        var string = Array(s)\\n        var chars: [Character] = []\\n        var marks : [Bool] = []\\n        var isMark: Bool = false\\n        var list = [[-1, -1, 1]] // [start, end, is need to add next start]\\n        var max = Int.min\\n\\n\\n        func nextRange(_ list: [[Int]], _ char: Character, _ mark: Bool) -> [[Int]] {\\n            var res = Set<[Int]>()\\n            for range in list {\\n                let lower = range[0] + range[2]\\n                let upper = range[1] + 1\\n                for i in lower...upper {\\n                    if mark {\\n                        var j = i\\n                        var count = 0\\n                        while j < string.count {\\n                            if char == string[j] || char == \".\" {\\n                                j += 1\\n                                count += 1\\n                            } else {\\n                                break\\n                            }\\n                        }\\n                        j = i + (count > 0 ? count - 1 : 0) \\n                        if count > 0 {\\n                            res.insert([i, j, 0])\\n                        } else {\\n                            res.insert(range)\\n                        }\\n                    } else {\\n                        if i < string.count && (char == string[i] || char == \".\") {\\n                            res.insert([i, i, 1])\\n                        }\\n                    }\\n                }\\n            }\\n\\n            return Array(res)\\n        }\\n\\n        for (_, c) in p.enumerated().reversed() {\\n            if c == \"*\" {\\n                isMark = true\\n            } else {\\n                chars.insert(c, at: 0)\\n                marks.insert(isMark, at: 0)\\n                isMark = false\\n            }\\n        }\\n\\n        for (index, c) in chars.enumerated() {\\n            let mark = marks[index]\\n            list = nextRange(list, c, mark)\\n        }\\n        for rang in list { max = max > rang[1] ? max : rang[1] }        \\n        return max == string.count - 1\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1573893,
                "title": "c-recursive-memoized-dp-explained",
                "content": "**Logic:** Explained as comments in recursive code.\\nT.C of memoized and DP solution: O(NM). where N, M is length of string s and p.\\n\\n**1. Recursive**\\n```\\n    bool isMatch(string s, string p) {\\n        int i=0, j=0;\\n        \\n        //i is pointer on s\\n        //j is pointer on p\\n        return fun(s,p,i,j);\\n    }\\n    \\n    bool fun(string& s, string& p, int i, int j){\\n        //1. Base case\\n        //a. String p has ended - s must have ended for a match between them.\\n        if(j==p.size()) return i == s.size();\\n        \\n        //b. String s has ended - p[j] could only be \\'*\\' or multiple \\'*\\' for a match.\\n        if(i==s.size()) return (p[j] == \\'*\\' && fun(s,p,i,j+1));\\n        \\n        //2. If none of them has ended and p[j] is \\'*\\', nothing can be said before comparing rest of the strings, both of them.\\n        if(p[j] == \\'*\\') return fun(s,p,i+1,j) || fun(s,p,i,j+1);\\n        \\n        //3. Else, when p[j] = \\'?\\' or a character - If it is a character it must be same as s[i]\\n        else{\\n            bool sameChar = i<s.size() && (p[j] == s[i] || p[j] == \\'?\\');\\n            return (sameChar && fun(s,p,i+1,j+1));\\n        }\\n    }\\n```\\n\\n**2. Memoized:** (Recursion + Storage)\\n```\\n\\tbool isMatch(string s, string p) {\\n        int i=0, j=0;\\n        \\n        //i is pointer on s\\n        //j is pointer on p\\n        int x = s.size(), y = p.size();\\n        int t[2002][2002];\\n        \\n        for(int k=0; k<x+1; k++){\\n            for(int m=0; m<y+1; m++){\\n                t[k][m] = -1;\\n            }\\n        }\\n        return fun(s,p,i,j, t);\\n    }\\n    \\n    bool fun(string& s, string& p, int i, int j, int t[][2002]){\\n        //1. Base case\\n        //a. String p has ended - s must have ended for a match between them.\\n        if(j==p.size()) return i == s.size();\\n        \\n\\t\\t//Check if result exists\\n        if(t[i][j] != -1) return t[i][j];\\n\\t\\t\\n        //b. String s has ended - p[j] could only be \\'*\\' or multiple \\'*\\' for a match.\\n        if(i==s.size()) return (p[j] == \\'*\\' && fun(s,p,i,j+1, t));\\n        \\n        \\n        //2. If none of them has ended and p[j] is \\'*\\', nothing can be said before comparing rest of the strings, both of them.\\n        if(p[j] == \\'*\\') {\\n            t[i][j] = fun(s,p,i+1,j,t) || fun(s,p,i,j+1, t);\\n            return t[i][j];\\n        }\\n        \\n        //3. Else, when p[j] = \\'?\\' or a character - If it is a character it must be same as s[i]\\n        else{\\n            bool sameChar = i<s.size() && (p[j] == s[i] || p[j] == \\'?\\');\\n            t[i][j] = (sameChar && fun(s,p,i+1,j+1, t));\\n            return t[i][j];\\n        }\\n    }\\n```\\n\\n**3. DP:** \\n```\\nbool isMatch(string& s, string& p) {\\n        if(p.size()==0) return s.size() == 0;\\n        \\n        int x = s.size(), y = p.size();\\n        vector<vector<int>> t(x+1, vector<int>(y+1,0));\\n        \\n        t[0][0] = 1;\\n        \\n        for(int i=1; i<=p.size(); i++){\\n            if(p[i-1] == \\'*\\') t[0][i] = 1;\\n            else break;\\n        }\\n        \\n        for(int i=1; i<=s.size(); i++){\\n            for(int j=1; j<=p.size(); j++){\\n                if(p[j-1] == \\'*\\')  t[i][j] = t[i-1][j] || t[i][j-1];\\n                else if(p[j-1] == \\'?\\' || p[j-1] == s[i-1]) {\\n                    t[i][j] = t[i-1][j-1];\\n                }\\n            }\\n        }\\n        return t[x][y];\\n    }\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n    bool isMatch(string s, string p) {\\n        int i=0, j=0;\\n        \\n        //i is pointer on s\\n        //j is pointer on p\\n        return fun(s,p,i,j);\\n    }\\n    \\n    bool fun(string& s, string& p, int i, int j){\\n        //1. Base case\\n        //a. String p has ended - s must have ended for a match between them.\\n        if(j==p.size()) return i == s.size();\\n        \\n        //b. String s has ended - p[j] could only be \\'*\\' or multiple \\'*\\' for a match.\\n        if(i==s.size()) return (p[j] == \\'*\\' && fun(s,p,i,j+1));\\n        \\n        //2. If none of them has ended and p[j] is \\'*\\', nothing can be said before comparing rest of the strings, both of them.\\n        if(p[j] == \\'*\\') return fun(s,p,i+1,j) || fun(s,p,i,j+1);\\n        \\n        //3. Else, when p[j] = \\'?\\' or a character - If it is a character it must be same as s[i]\\n        else{\\n            bool sameChar = i<s.size() && (p[j] == s[i] || p[j] == \\'?\\');\\n            return (sameChar && fun(s,p,i+1,j+1));\\n        }\\n    }\\n```\n```\\n\\tbool isMatch(string s, string p) {\\n        int i=0, j=0;\\n        \\n        //i is pointer on s\\n        //j is pointer on p\\n        int x = s.size(), y = p.size();\\n        int t[2002][2002];\\n        \\n        for(int k=0; k<x+1; k++){\\n            for(int m=0; m<y+1; m++){\\n                t[k][m] = -1;\\n            }\\n        }\\n        return fun(s,p,i,j, t);\\n    }\\n    \\n    bool fun(string& s, string& p, int i, int j, int t[][2002]){\\n        //1. Base case\\n        //a. String p has ended - s must have ended for a match between them.\\n        if(j==p.size()) return i == s.size();\\n        \\n\\t\\t//Check if result exists\\n        if(t[i][j] != -1) return t[i][j];\\n\\t\\t\\n        //b. String s has ended - p[j] could only be \\'*\\' or multiple \\'*\\' for a match.\\n        if(i==s.size()) return (p[j] == \\'*\\' && fun(s,p,i,j+1, t));\\n        \\n        \\n        //2. If none of them has ended and p[j] is \\'*\\', nothing can be said before comparing rest of the strings, both of them.\\n        if(p[j] == \\'*\\') {\\n            t[i][j] = fun(s,p,i+1,j,t) || fun(s,p,i,j+1, t);\\n            return t[i][j];\\n        }\\n        \\n        //3. Else, when p[j] = \\'?\\' or a character - If it is a character it must be same as s[i]\\n        else{\\n            bool sameChar = i<s.size() && (p[j] == s[i] || p[j] == \\'?\\');\\n            t[i][j] = (sameChar && fun(s,p,i+1,j+1, t));\\n            return t[i][j];\\n        }\\n    }\\n```\n```\\nbool isMatch(string& s, string& p) {\\n        if(p.size()==0) return s.size() == 0;\\n        \\n        int x = s.size(), y = p.size();\\n        vector<vector<int>> t(x+1, vector<int>(y+1,0));\\n        \\n        t[0][0] = 1;\\n        \\n        for(int i=1; i<=p.size(); i++){\\n            if(p[i-1] == \\'*\\') t[0][i] = 1;\\n            else break;\\n        }\\n        \\n        for(int i=1; i<=s.size(); i++){\\n            for(int j=1; j<=p.size(); j++){\\n                if(p[j-1] == \\'*\\')  t[i][j] = t[i-1][j] || t[i][j-1];\\n                else if(p[j-1] == \\'?\\' || p[j-1] == s[i-1]) {\\n                    t[i][j] = t[i-1][j-1];\\n                }\\n            }\\n        }\\n        return t[x][y];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 17910,
                "title": "clear-c-dp-solution-similar-to-the-last-matching-problem",
                "content": "    bool isMatch(string s, string p) {\\n        int n1 = s.size(), n2 = p.size();\\n        vector<vector<bool>> res(n1 + 1, vector<bool>(n2 + 1));\\n        res[0][0] = true;\\n        for(int i=1; i<=n2; i++){\\n            if(p[i-1] == '*')\\n                res[0][i] = res[0][i-1];\\n        }\\n        for(int i=1; i<=n1; i++){\\n            for(int j=1; j<=n2; j++){\\n                if(p[j-1] != '*'){\\n                    res[i][j] = (s[i-1] == p[j-1] || p[j-1] == '?') && res[i-1][j-1]; \\n                }\\n                else{\\n                    res[i][j] = res[i-1][j] || res[i][j-1];\\n                }\\n            }\\n        }\\n        return res[n1][n2];\\n    }",
                "solutionTags": [],
                "code": "    bool isMatch(string s, string p) {\\n        int n1 = s.size(), n2 = p.size();\\n        vector<vector<bool>> res(n1 + 1, vector<bool>(n2 + 1));\\n        res[0][0] = true;\\n        for(int i=1; i<=n2; i++){\\n            if(p[i-1] == '*')\\n                res[0][i] = res[0][i-1];\\n        }\\n        for(int i=1; i<=n1; i++){\\n            for(int j=1; j<=n2; j++){\\n                if(p[j-1] != '*'){\\n                    res[i][j] = (s[i-1] == p[j-1] || p[j-1] == '?') && res[i-1][j-1]; \\n                }\\n                else{\\n                    res[i][j] = res[i-1][j] || res[i][j-1];\\n                }\\n            }\\n        }\\n        return res[n1][n2];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3416314,
                "title": "c-dp-recursive-memoization",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool c(string &s,string &p,int i,int j,vector<vector<int>>&dp){\\n        if(i==s.size()){\\n            int t=0;\\n            for(int g=j;g<p.size();g++)if(p[g]==\\'*\\')t++;\\n            if(t==(p.size()-j))return true;\\n            else return false;\\n        }\\n        \\n        if(j>=p.size() || i>s.size())return false;\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        bool ans=false;\\n        if(p[j]>=\\'a\\' && p[j]<=\\'z\\'){\\n           if(s[i]!=p[j])ans=false;\\n           else ans|= c(s,p,i+1,j+1,dp);\\n        }\\n        else if(p[j]==\\'?\\')ans|= c(s,p,i+1,j+1,dp);\\n        else {\\n            for(int h=i;h<s.size();h++){\\n                    ans |= c(s,p,h+1,j+1,dp);\\n                    ans |= c(s,p,h,j+1,dp);\\n            }\\n        }\\n        dp[i][j]=ans;\\n        return ans;\\n    \\n    }\\n    bool isMatch(string s, string p) {\\n        vector<vector<int>>dp(s.size(),vector<int>(p.size(),-1));\\n        return c(s,p,0,0,dp);\\n    }\\n};\\n```\\n![upvote (3).jpg](https://assets.leetcode.com/users/images/78f09d88-c388-486a-89e7-1e3efd936b18_1681475282.875831.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool c(string &s,string &p,int i,int j,vector<vector<int>>&dp){\\n        if(i==s.size()){\\n            int t=0;\\n            for(int g=j;g<p.size();g++)if(p[g]==\\'*\\')t++;\\n            if(t==(p.size()-j))return true;\\n            else return false;\\n        }\\n        \\n        if(j>=p.size() || i>s.size())return false;\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        bool ans=false;\\n        if(p[j]>=\\'a\\' && p[j]<=\\'z\\'){\\n           if(s[i]!=p[j])ans=false;\\n           else ans|= c(s,p,i+1,j+1,dp);\\n        }\\n        else if(p[j]==\\'?\\')ans|= c(s,p,i+1,j+1,dp);\\n        else {\\n            for(int h=i;h<s.size();h++){\\n                    ans |= c(s,p,h+1,j+1,dp);\\n                    ans |= c(s,p,h,j+1,dp);\\n            }\\n        }\\n        dp[i][j]=ans;\\n        return ans;\\n    \\n    }\\n    bool isMatch(string s, string p) {\\n        vector<vector<int>>dp(s.size(),vector<int>(p.size(),-1));\\n        return c(s,p,0,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 321724,
                "title": "different-python-solutions-with-thinking-process",
                "content": "Please see and vote for my standard DP solutions for\\n[10. Regular Expression Matching](https://leetcode.com/problems/regular-expression-matching/discuss/314237/Python-DP-solution-with-detailed-explanation)\\n[44. Wildcard Matching](https://leetcode.com/problems/wildcard-matching/discuss/321724/Different-Python-solutions-with-thinking-process)\\n\\nMethod 1: standard DP solution using a 2D table (1040 ms, beat 17%)\\n```\\nLet m = len(s), n = len(p), dp[i][j] = whether p[:j] matches s[:i] or not,\\nBase cases: \\ndp[0][0] = True\\ndp[i][0] = False, when i = 1, 2, ..., m\\ndp[0][j] = False if p[j-1] is \\'?\\' or a lowercase letter,  dp[0][j-1] if dp[j-1] == \\'*\\', when j = 1, 2, ..., n\\nRecursive relationship:  for i in range(1, m + 1), for j in range(1, n + 1)\\n(1) if p[j-1] is a lowercase letter, dp[i][j] = (p[j-1] == s[i-1]) and dp[i-1][j-1]\\n(2) if p[j-1] == \\'?\\', dp[i][j] = dp[i-1][j-1]\\n(3) if p[j-1] == \\'*\\', dp[i][j] =\\n        (i) \\'*\\' match nothing,  dp[i][j-1]\\n   or (ii) \\'*\\' match at least one character dp[i-1][j]\\n```\\n```\\n    def isMatch(self, s, p):\\n        m, n = len(s), len(p)\\n        dp = [[False for _ in range(n + 1)] for _ in range(m + 1)]\\n        dp[0][0] = True\\n        for j in range(1, n + 1):\\n            if p[j-1].isalpha() or p[j-1] == \\'?\\':\\n                dp[0][j] = False\\n            else:\\n                dp[0][j] = dp[0][j-1]\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                if p[j-1].isalpha():\\n                    dp[i][j] = (p[j-1] == s[i-1]) and dp[i-1][j-1]\\n                elif p[j-1] == \\'?\\':\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    dp[i][j] = dp[i-1][j] or dp[i][j-1]\\n        return dp[m][n]\\n```\\n\\nMethod 2: greedy solution with idea of DFS (56ms, beat 96.73%) [reference, tonygogogo\\'s comment](https://leetcode.com/problems/wildcard-matching/discuss/17810/Linear-runtime-and-constant-space-solution)\\n```\\nprev_star stores the position of the previous \\'*\\' in p\\nneed_to_match stores the position of the char in s after a \\'*\\' matched zero or more chars\\nExample:  s = \"acdscd\", p = \"*cd\",\\nAfter finding the first \\'*\\', prev_star = 0, need_to_match = 0, \\'*\\' matches nothing.\\ns[0] != p[1], the previous match \\'\\' of \\'*\\' (the first branch of DFS) is actually wrong,\\nthen reset j = prev_star + 1, increment need_to_match, set i = need_to_match, i.e. \\'*\\' matches \\'a\\'.\\nWhen we come to i = 3 and j = 3, we know that the previous match \\'a\\' of \\'*\\' is wrong,\\nthen reset j = prev_match + 1, increment need_to_match, set i = need_to_match, i.e. \\'*\\' matches \\'ac\\',\\n...\\nWhen we have prev_star = 0 and need_to_match = 4 (i.e. \\'*\\' matches \\'acds\\'), then get the right match. \\n```\\n```\\n    def isMatch(self, s, p):\\n        m, n = len(s), len(p)\\n        i, j = 0, 0\\n        prev_star, need_to_match = -1, -1\\n        while i < m:\\n            if j < n and (p[j] == s[i] or p[j] == \\'?\\'):\\n                i, j = i + 1, j + 1\\n            elif j < n and p[j] == \\'*\\':\\n                prev_star = j\\n                need_to_match = i   # initially let * match nothing\\n                j += 1\\n            elif prev_star != -1:\\n                j = prev_star + 1\\n\\t\\t\\t\\tneed_to_match += 1  # let * match one more character\\n                i = need_to_match\\n            else:\\n                return False\\n        while j < n and p[j] == \\'*\\':\\n            j += 1\\n        return j == n\\n```",
                "solutionTags": [],
                "code": "```\\nLet m = len(s), n = len(p), dp[i][j] = whether p[:j] matches s[:i] or not,\\nBase cases: \\ndp[0][0] = True\\ndp[i][0] = False, when i = 1, 2, ..., m\\ndp[0][j] = False if p[j-1] is \\'?\\' or a lowercase letter,  dp[0][j-1] if dp[j-1] == \\'*\\', when j = 1, 2, ..., n\\nRecursive relationship:  for i in range(1, m + 1), for j in range(1, n + 1)\\n(1) if p[j-1] is a lowercase letter, dp[i][j] = (p[j-1] == s[i-1]) and dp[i-1][j-1]\\n(2) if p[j-1] == \\'?\\', dp[i][j] = dp[i-1][j-1]\\n(3) if p[j-1] == \\'*\\', dp[i][j] =\\n        (i) \\'*\\' match nothing,  dp[i][j-1]\\n   or (ii) \\'*\\' match at least one character dp[i-1][j]\\n```\n```\\n    def isMatch(self, s, p):\\n        m, n = len(s), len(p)\\n        dp = [[False for _ in range(n + 1)] for _ in range(m + 1)]\\n        dp[0][0] = True\\n        for j in range(1, n + 1):\\n            if p[j-1].isalpha() or p[j-1] == \\'?\\':\\n                dp[0][j] = False\\n            else:\\n                dp[0][j] = dp[0][j-1]\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                if p[j-1].isalpha():\\n                    dp[i][j] = (p[j-1] == s[i-1]) and dp[i-1][j-1]\\n                elif p[j-1] == \\'?\\':\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    dp[i][j] = dp[i-1][j] or dp[i][j-1]\\n        return dp[m][n]\\n```\n```\\nprev_star stores the position of the previous \\'*\\' in p\\nneed_to_match stores the position of the char in s after a \\'*\\' matched zero or more chars\\nExample:  s = \"acdscd\", p = \"*cd\",\\nAfter finding the first \\'*\\', prev_star = 0, need_to_match = 0, \\'*\\' matches nothing.\\ns[0] != p[1], the previous match \\'\\' of \\'*\\' (the first branch of DFS) is actually wrong,\\nthen reset j = prev_star + 1, increment need_to_match, set i = need_to_match, i.e. \\'*\\' matches \\'a\\'.\\nWhen we come to i = 3 and j = 3, we know that the previous match \\'a\\' of \\'*\\' is wrong,\\nthen reset j = prev_match + 1, increment need_to_match, set i = need_to_match, i.e. \\'*\\' matches \\'ac\\',\\n...\\nWhen we have prev_star = 0 and need_to_match = 4 (i.e. \\'*\\' matches \\'acds\\'), then get the right match. \\n```\n```\\n    def isMatch(self, s, p):\\n        m, n = len(s), len(p)\\n        i, j = 0, 0\\n        prev_star, need_to_match = -1, -1\\n        while i < m:\\n            if j < n and (p[j] == s[i] or p[j] == \\'?\\'):\\n                i, j = i + 1, j + 1\\n            elif j < n and p[j] == \\'*\\':\\n                prev_star = j\\n                need_to_match = i   # initially let * match nothing\\n                j += 1\\n            elif prev_star != -1:\\n                j = prev_star + 1\\n\\t\\t\\t\\tneed_to_match += 1  # let * match one more character\\n                i = need_to_match\\n            else:\\n                return False\\n        while j < n and p[j] == \\'*\\':\\n            j += 1\\n        return j == n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1557406,
                "title": "c-simple-and-clean-solution-detailed-explanation",
                "content": "**Idea:**\\nWe use two pointers: `pi` for `p`, and `si` for `s`.\\nWe also keep variables: `star` for the index of the last `*`, and `count` for the substring we are matching for the `*`.\\nThese are the cases:\\n1. The pattern has a `*`: update `count` and `star`.\\n2. The letters in both s and p are equal, or the pattern has a `?`: Match! just advance pointers.\\n3. Otherwise, we try to append this letter to a substring matching a `*`.\\n4. If there was no star - return false.\\n\\nIf we have more stars at the end of `p`, we skip them, and then if we reached the end of the pattern - return true.\\n\\n```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        int pi = 0, si = 0, star = -1, count = 0;\\n        \\n        while (si < s.size()) {\\n            \\n            if (p[pi] == \\'*\\') {\\n                count = si;\\n                star = pi++;\\n            }\\n            \\n            else if (p[pi] == s[si] || p[pi] == \\'?\\') {\\n                pi++, si++;\\n            }\\n            \\n            else if (star >= 0){\\n                pi = star+1;\\n                si = ++count;\\n                \\n            }\\n            else return false;\\n        }\\n        \\n        while (pi < p.size() && p[pi] == \\'*\\') pi++;\\n        return pi == p.size();\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        int pi = 0, si = 0, star = -1, count = 0;\\n        \\n        while (si < s.size()) {\\n            \\n            if (p[pi] == \\'*\\') {\\n                count = si;\\n                star = pi++;\\n            }\\n            \\n            else if (p[pi] == s[si] || p[pi] == \\'?\\') {\\n                pi++, si++;\\n            }\\n            \\n            else if (star >= 0){\\n                pi = star+1;\\n                si = ++count;\\n                \\n            }\\n            else return false;\\n        }\\n        \\n        while (pi < p.size() && p[pi] == \\'*\\') pi++;\\n        return pi == p.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1216893,
                "title": "java-solution-with-explanation-beats-100-of-submissions",
                "content": "we will keep track of last index in s from which we started comparing with pattern if we encounter a * ( first we will consider * as 0 length )\\nIf we encounter a mismatch , then we will increase the last index(which means we are now considering 1 length in * ) \\nSimilarly we will continue until we reach the end of string .\\n```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        int i=0;\\n        int j=0;\\n        int starIdx=-1;\\n        int lastMatch=-1;\\n        \\n        while(i<s.length()){\\n            if(j<p.length() && (s.charAt(i)==p.charAt(j) || \\n              p.charAt(j)==\\'?\\')){\\n                i++;\\n                j++;\\n            }else if(j<p.length() && p.charAt(j)==\\'*\\'){\\n                starIdx=j;\\n                lastMatch=i;\\n                j++;\\n            }else if(starIdx!=-1){\\n            //there is a no match and there was a previous star, we will reset the j to indx after star_index\\n            //lastMatch will tell from which index we start comparing the string if we encounter * in pattern\\n                j=starIdx+1;\\n                lastMatch++; // we are saying we included more characters in * so we incremented the index \\n                i=lastMatch;\\n                \\n            }else{\\n                return false;\\n            }\\n        }\\n        \\n        while(j<p.length() && p.charAt(j)==\\'*\\') j++;\\n        \\n        if(i!=s.length() || j!=p.length()) return false;\\n        \\n        return true;\\n     \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        int i=0;\\n        int j=0;\\n        int starIdx=-1;\\n        int lastMatch=-1;\\n        \\n        while(i<s.length()){\\n            if(j<p.length() && (s.charAt(i)==p.charAt(j) || \\n              p.charAt(j)==\\'?\\')){\\n                i++;\\n                j++;\\n            }else if(j<p.length() && p.charAt(j)==\\'*\\'){\\n                starIdx=j;\\n                lastMatch=i;\\n                j++;\\n            }else if(starIdx!=-1){\\n            //there is a no match and there was a previous star, we will reset the j to indx after star_index\\n            //lastMatch will tell from which index we start comparing the string if we encounter * in pattern\\n                j=starIdx+1;\\n                lastMatch++; // we are saying we included more characters in * so we incremented the index \\n                i=lastMatch;\\n                \\n            }else{\\n                return false;\\n            }\\n        }\\n        \\n        while(j<p.length() && p.charAt(j)==\\'*\\') j++;\\n        \\n        if(i!=s.length() || j!=p.length()) return false;\\n        \\n        return true;\\n     \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 963049,
                "title": "0ms-runtime-3-golang-solutions-with-optimization-and-explaination-recursive-iterative-dp",
                "content": "This is a wonderful problem, and deserves serious study.\\n\\n1. Recursive solution.  It\\'s not complicated. \\n\\n```\\nfunc isMatch(s string, p string) bool {\\n    if len(p) == 0 {\\n        return len(s) == 0\\n    }\\n    if len(s) > 0 && (s[0] == p[0] || p[0] == \\'?\\') {\\n        return isMatch(s[1:], p[1:])\\n    } else if p[0] == \\'*\\' {\\n        return isMatch(s, p[1:]) || (len(s) > 0 && isMatch(s[1:], p))\\n    }\\n    return false\\n}\\n```\\nUnfortunately it is judged Time Limit Exceeded.  The test cases is specially designed  for recursive algorithms.\\n\\n<img src=\"https://assets.leetcode.com/users/images/de901b4d-393d-42e1-9a8c-c0c11a7218b6_1607409296.4703355.png\" width=\"450px\" />\\n\\nLet\\'s do some optimization works.\\n \\nOptimization 1: Pruning unnecessary recursive calls.\\nThinking about this testcase `assert.False(t, isMatch(\"bbc\", \"*b*a\"))`. Every time we match `*`, if the string can\\'t match the subsequent pattern, the recursive function will call itself two times, the call tree forks.\\n\\n```\\nisMatch(\"bbc\", \"*b*a\")         \\n  |\\n  |-isMatch(\"bbc\", \"b*a\")   \\n  |   |\\n  |   |-isMatch(\"bc\", \"*a\")    \\n  |       |\\n  |       |-isMatch(\"bc\", \"a\")\\n  |       |\\n  |       |-isMatch(\"c\", \"*a\")  // First fork\\n  |           |                 \\n  |           |-isMatch(\"c\", \"a\")\\n  |           |\\n  |           |-isMatch(\"\", \"*a\") // Second fork return false. This means that any suffix substring can\\'t match the sub pattern \\n  |                               // starts with the last `*`. \"c\",\"bc\",\"bbc\", none of them can match \"*a\". \\n  |                               // **AND OF COURCE** they can\\'t match any pattern ends with \"*a\", such as \"b*a\",\"*b*a\". This\\'s the untimate match.\\n  |\\n  |-isMatch(\"bc\", \"*b*a\")  // Third fork, This fork branch is unnecessary, because the result is \\n\\t  |                    // already known after calling isMatch(\"\", \"*a\").\\n      |\\n      |-isMatch(\"bc\", \"b*a\")\\n      |   |\\n      |   |-isMatch(\"c\", \"*a\")\\n      |....  \\n```\\nNow we know that after matching the pattern starts with the last `*`, any recursive call fork is unnecessary.\\nTo avoid alll the unnecessary recursive forks we only need to add a `lastStar` variant and set the `lastStar` to `true` after matching the pattern starts with the last `*`. \\nSo, here is the optimized solution:\\n\\n\\n\\n```\\nfunc isMatch(s string, p string) bool { \\n    var lastStar bool\\n    var helper func(s, p string) bool\\n    helper = func(s, p string) bool {\\n        if len(p) == 0 {\\n            return len(s) == 0\\n        }\\n        var matched bool\\n        if len(s) > 0 && (p[0] == \\'?\\' || s[0] == p[0]) {\\n            matched = helper(s[1:], p[1:])\\n        } else if p[0] == \\'*\\' {\\n            matched = len(p) == 1 || helper(s, p[1:]) // cut the pattern string first\\n            if !lastStar && !matched && len(s) > 0 {\\n                matched = helper(s[1:], p) // When running to this line for the first time, the pattern string must start with the last `*`, then cut the string.\\n                lastStar = true\\n            }\\n        }\\n        return matched\\n    }\\n    return helper(s, p)\\n}\\n```\\n\\nOptimization 2: Two directions match.\\nAbout this testcase `s=\"abababababababa\", p=\"*b*b*b*b*e\"`, the solution do many useless work with the prefix containing many `*`, but the last char \"a\" doesn\\'t match \"e\", and it\\'s easy to get. If matching in two directions, back to front and front to back, it can save some time.\\n\\n```go\\nfunc isMatch(s string, p string) bool {\\n    var lastStar, frontToBack bool\\n    var helper func(s, p string) bool\\n    helper = func(s, p string) bool {\\n        if len(p) == 0 {\\n            return len(s) == 0\\n        }\\n        var matched bool\\n        if frontToBack {\\n\\t\\t\\tif len(s) > 0 && (p[0] == \\'?\\' || s[0] == p[0]) {\\n\\t\\t\\t\\tmatched = helper(s[1:], p[1:])\\n\\t\\t\\t} else if p[0] == \\'*\\' {\\n\\t\\t\\t\\tmatched = len(p) == 1 || helper(s, p[1:])\\n\\t\\t\\t\\tif !lastStar && !matched && len(s) > 0 {\\n\\t\\t\\t\\t\\tmatched = helper(s[1:], p)\\n\\t\\t\\t\\t\\tlastStar = true\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n        } else {\\n            if len(s) > 0 && (p[len(p)-1] == \\'?\\' || s[len(s)-1] == p[len(p)-1]) {\\n                matched = helper(s[:len(s)-1], p[:len(p)-1])\\n            } else if p[len(p)-1] == \\'*\\' {\\n    \\t\\t\\tfrontToBack = true\\n                matched = len(p) == 1 || helper(s, p) //Matching from front to back\\n            }\\n\\t\\t}\\n        return matched\\n    }\\n    return helper(s, p)\\n}\\n```\\n\\n2. Iterative solution.\\nThis solution is based on the same idea of the optimized recursive solution. When matching `*`, first we compare the follow up chars, if it doesn\\'t match, we just backtrack to the last star. \\n\\n```go\\nfunc isMatch(s string, p string) bool {\\n\\tvar i, j, matched, lastStar int\\n    lastStar = -1\\n\\tfor i < len(s) {\\n\\t\\tif j < len(p) {\\n\\t\\t\\tif p[j] == \\'?\\' || s[i] == p[j] {\\n\\t\\t\\t\\ti, j = i+ 1, j+ 1\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tif p[j] == \\'*\\' {\\n\\t\\t\\t    matched, lastStar = i, j\\n                j++\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif lastStar < 0 {\\n\\t\\t    return false\\n        }\\n        matched++ // let s[i] matches \\'*\\'\\n        i, j = matched, lastStar+1\\n\\t}\\n\\t\\n\\tfor ; j < len(p); j++ {\\n\\t\\tif p[j] != \\'*\\' {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n```\\n\\nOptimization: Two directions match.\\n\\n```go\\nfunc isMatch(s string, p string) bool {\\n    var i, j, matched, lastStar, lastI, lastJ int\\n\\t//match from end to front until the last star\\n    for lastI, lastJ = len(s)-1, len(p)-1; lastI >= 0 && lastJ >= 0 &&  p[lastJ] != \\'*\\'; {\\n\\t    if p[lastJ] == \\'?\\' || s[lastI] == p[lastJ] {\\n            lastI, lastJ = lastI-1, lastJ-1\\n        } else {\\n            return false\\n        }\\n    }\\n    if lastJ < 0 {\\n        return lastI < 0\\n    }\\n    if lastI < 0 {\\n        for j=0; j<=lastJ; j++ {\\n            if p[j] != \\'*\\' {\\n                return false\\n            }\\n        }\\n        return true\\n    }\\n\\tlastStar = -1\\n\\t//match from front to end\\n    for i <= lastI {\\n        if j <= lastJ {\\n            if p[j] == \\'?\\' || s[i] == p[j] {\\n                i, j = i+1, j+1\\n                continue\\n            }\\n            if p[j] == \\'*\\' {\\n                matched, lastStar = i, j\\n                j++\\n                continue\\n            }\\n        }\\n        if lastStar < 0 {\\n            return false\\n        }\\n        matched++\\n        i, j = matched, lastStar+1\\n    }\\n\\n    for ; j <= lastJ; j++ {\\n        if p[j] != \\'*\\' {\\n            return false\\n        }\\n    }\\n    return true\\n}\\n```\\n\\nActually I think this solution is ugly. Bu it can get `0ms` running time.\\n<img src=\"https://assets.leetcode.com/users/images/dfb37fff-ed39-456b-95b1-be03e16e69fe_1607334056.0733168.png\" width=\"500px\" />\\n\\n3. DP solution.\\n\\n```\\nfunc isMatch(s string, p string) bool {\\n    if len(p) == 0 {\\n        return len(s) == 0\\n    }\\n    dp := make([][]bool, len(p) + 1)\\n    for i := 0; i < len(dp); i++ {\\n        dp[i] = make([]bool, len(s) + 1)\\n    }\\n    dp[0][0] = true\\n    for i:=1;i<=len(p);i++ {\\n        dp[i][0] = dp[i-1][0] && p[i-1] == \\'*\\'\\n        for j := 1; j <= len(s); j++ {\\n            switch p[i-1] {\\n            case \\'?\\':\\n                dp[i][j] = dp[i-1][j-1]\\n            case \\'*\\':\\n                dp[i][j] = dp[i-1][j] || dp[i][j-1]\\n            default:\\n                dp[i][j] = dp[i-1][j-1] && p[i-1] == s[j-1]\\n            }\\n        }\\n    }\\n    return dp[len(p)][len(s)]\\n}\\n```\\n\\nOptimization:\\n\\n1.About this testcase `s=\"abcdefghi\", p=\"*fghi\"`, after loop in which match `f`, the dp row is `[0,0,0,0,0,0,1,0,0,0]`, in the next loop which is to match `g`, we don\\'t need start from the beginning char `a`. We just start from `f` which is true correspondingly in dp array . So by saving the first matched position of last loop  to variant `firstMatch`, we can start from `firstMatch` directly in the next loop.  Also We don\\'t need match `gh` to pattern `f`, because all behind cells are False. So we can save the last matched position to `lastMatch`, if next pattern char isn\\'t `*`, in next loop, we can stop at `lastMatch + 1`.\\n2.About this testcase `s=\"ddddddddfdfdfd\", p=\"d*******d\"`,  the continuous `*` is exactly same as the pattern \"*\" with only one star. We can shrink the redundant `*`s to single `*` at the beginning. \\n3. By shrinking the pattern string, we can count the number of `non-*` chars. That can help to reduce loop length of matching `*`. In testcase `s=\"abcdefg\", p=\"*?*?*?`, there are 3 `non-*` chars, so in the first loop of matching `*`, we can just stop matching at char `d`, because there are 3 more `non-*` chars in the subsequent pattern.\\n4. About this testcase `s=\"ddddddddfdfdfd\", p=\"aaaaaaaaaaa\"`, we don\\'t need to run to the end to get the result from `dp[len(s)][len(p)]`.  After the first pattern `\\'a\\'` we already know the string doesn\\'t match the pattern. The subsequent runs are meaningless.\\n5. Space optimization using an arrays instead of 2-d arrays. Reduce space from len(s)\\\\*len(p)  to len(s). \\n```go\\n\\t...\\n\\tswitch p[i-1] {\\n\\tcase \\'?\\':\\n\\t\\tdp[i][j] = dp[i-1][j-1]\\n\\tcase \\'*\\':\\n\\t\\tdp[i][j] = dp[i-1][j] || dp[i][j-1]\\n\\t...\\n```\\nIn dp solution, determining a cell in the 2-d array need three cells which respectively are the left cell, the top cell and the left top cell.\\n|a|b|c|.|\\n|-|-|-|-|\\n|**d**|*e*|f|.|\\n|.|.|.|.|\\nIn the example in the table above, Determining cell `e` depends on `a`,`b` and `d`.  \\nTo optimize the space, We can use a temporary variant `dpCur` save the  temporary result of cell `e`, because cell `e` is needed in determing cell \\'f\\'. We can  put `dpcur` into cell `e` after determing cell `f`.\\n\\n```go\\nfunc isMatch(s string, p string) bool {\\n    if len(p) == 0 {\\n        return len(s) == 0\\n    }\\n    //shrink redundant `*`.\\n    var charCount int\\n    var b bytes.Buffer\\n    for i := 0; i < len(p); i++ {\\n        if p[i] != \\'*\\' || i == 0 || p[i] != p[i-1] {\\n            b.WriteByte(p[i])\\n            if p[i] != \\'*\\' {\\n                charCount++\\n            }\\n        }\\n    }\\n    if charCount > len(s) {\\n        return false\\n    }\\n    if b.Len() < len(p) {\\n        p = b.String()\\n    }\\n\\t\\n    var dp = make([]bool, len(s)+1)\\n    dp[0] = true\\n    var firstMatch,stopMatch, lastMatch,dpCur = 1,0,0,true\\n\\t\\n    for i := 1; i <= len(p); i++ {\\n        dpCur = dp[firstMatch-1] && p[i-1] == \\'*\\'\\n        matched := dpCur\\n        if p[i-1] == \\'*\\' {\\n            stopMatch = len(s) - charCount\\n        } else {\\n            charCount--\\n\\t\\t\\tstopMatch = lastMatch + 1\\n\\t\\t\\t// Don\\'t worry about overflow if `stopMatch > len(s)`. It won\\'t happen.\\n        }\\n        for j := firstMatch; j <= stopMatch; j++ {\\n            switch p[i-1] {\\n            case \\'?\\':\\n                dpCur, dp[j-1] = dp[j-1], dpCur\\n            case \\'*\\':\\n                dpCur, dp[j-1] = dpCur || dp[j], dpCur\\n            default:\\n                dpCur, dp[j-1] = dp[j-1] && p[i-1] == s[j-1], dpCur\\n            }\\n            if dpCur {\\n                if !matched {\\n                    firstMatch = j\\n                    matched = true\\n                }\\n                lastMatch = j\\n            }\\n        }\\n        if !matched {\\n            //we already know s[:j] doesn\\'t match p[:i]. So we don\\'t need more comparing.\\n            return false\\n        }\\n        dp[stopMatch] = dpCur\\n    }\\n    return dp[len(s)]\\n}\\n```\\n\\nI will be really surprised if someone can keep reading to here.",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nfunc isMatch(s string, p string) bool {\\n    if len(p) == 0 {\\n        return len(s) == 0\\n    }\\n    if len(s) > 0 && (s[0] == p[0] || p[0] == \\'?\\') {\\n        return isMatch(s[1:], p[1:])\\n    } else if p[0] == \\'*\\' {\\n        return isMatch(s, p[1:]) || (len(s) > 0 && isMatch(s[1:], p))\\n    }\\n    return false\\n}\\n```\n```\\nisMatch(\"bbc\", \"*b*a\")         \\n  |\\n  |-isMatch(\"bbc\", \"b*a\")   \\n  |   |\\n  |   |-isMatch(\"bc\", \"*a\")    \\n  |       |\\n  |       |-isMatch(\"bc\", \"a\")\\n  |       |\\n  |       |-isMatch(\"c\", \"*a\")  // First fork\\n  |           |                 \\n  |           |-isMatch(\"c\", \"a\")\\n  |           |\\n  |           |-isMatch(\"\", \"*a\") // Second fork return false. This means that any suffix substring can\\'t match the sub pattern \\n  |                               // starts with the last `*`. \"c\",\"bc\",\"bbc\", none of them can match \"*a\". \\n  |                               // **AND OF COURCE** they can\\'t match any pattern ends with \"*a\", such as \"b*a\",\"*b*a\". This\\'s the untimate match.\\n  |\\n  |-isMatch(\"bc\", \"*b*a\")  // Third fork, This fork branch is unnecessary, because the result is \\n\\t  |                    // already known after calling isMatch(\"\", \"*a\").\\n      |\\n      |-isMatch(\"bc\", \"b*a\")\\n      |   |\\n      |   |-isMatch(\"c\", \"*a\")\\n      |....  \\n```\n```\\nfunc isMatch(s string, p string) bool { \\n    var lastStar bool\\n    var helper func(s, p string) bool\\n    helper = func(s, p string) bool {\\n        if len(p) == 0 {\\n            return len(s) == 0\\n        }\\n        var matched bool\\n        if len(s) > 0 && (p[0] == \\'?\\' || s[0] == p[0]) {\\n            matched = helper(s[1:], p[1:])\\n        } else if p[0] == \\'*\\' {\\n            matched = len(p) == 1 || helper(s, p[1:]) // cut the pattern string first\\n            if !lastStar && !matched && len(s) > 0 {\\n                matched = helper(s[1:], p) // When running to this line for the first time, the pattern string must start with the last `*`, then cut the string.\\n                lastStar = true\\n            }\\n        }\\n        return matched\\n    }\\n    return helper(s, p)\\n}\\n```\n```go\\nfunc isMatch(s string, p string) bool {\\n    var lastStar, frontToBack bool\\n    var helper func(s, p string) bool\\n    helper = func(s, p string) bool {\\n        if len(p) == 0 {\\n            return len(s) == 0\\n        }\\n        var matched bool\\n        if frontToBack {\\n\\t\\t\\tif len(s) > 0 && (p[0] == \\'?\\' || s[0] == p[0]) {\\n\\t\\t\\t\\tmatched = helper(s[1:], p[1:])\\n\\t\\t\\t} else if p[0] == \\'*\\' {\\n\\t\\t\\t\\tmatched = len(p) == 1 || helper(s, p[1:])\\n\\t\\t\\t\\tif !lastStar && !matched && len(s) > 0 {\\n\\t\\t\\t\\t\\tmatched = helper(s[1:], p)\\n\\t\\t\\t\\t\\tlastStar = true\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n        } else {\\n            if len(s) > 0 && (p[len(p)-1] == \\'?\\' || s[len(s)-1] == p[len(p)-1]) {\\n                matched = helper(s[:len(s)-1], p[:len(p)-1])\\n            } else if p[len(p)-1] == \\'*\\' {\\n    \\t\\t\\tfrontToBack = true\\n                matched = len(p) == 1 || helper(s, p) //Matching from front to back\\n            }\\n\\t\\t}\\n        return matched\\n    }\\n    return helper(s, p)\\n}\\n```\n```go\\nfunc isMatch(s string, p string) bool {\\n\\tvar i, j, matched, lastStar int\\n    lastStar = -1\\n\\tfor i < len(s) {\\n\\t\\tif j < len(p) {\\n\\t\\t\\tif p[j] == \\'?\\' || s[i] == p[j] {\\n\\t\\t\\t\\ti, j = i+ 1, j+ 1\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tif p[j] == \\'*\\' {\\n\\t\\t\\t    matched, lastStar = i, j\\n                j++\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif lastStar < 0 {\\n\\t\\t    return false\\n        }\\n        matched++ // let s[i] matches \\'*\\'\\n        i, j = matched, lastStar+1\\n\\t}\\n\\t\\n\\tfor ; j < len(p); j++ {\\n\\t\\tif p[j] != \\'*\\' {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n```\n```go\\nfunc isMatch(s string, p string) bool {\\n    var i, j, matched, lastStar, lastI, lastJ int\\n\\t//match from end to front until the last star\\n    for lastI, lastJ = len(s)-1, len(p)-1; lastI >= 0 && lastJ >= 0 &&  p[lastJ] != \\'*\\'; {\\n\\t    if p[lastJ] == \\'?\\' || s[lastI] == p[lastJ] {\\n            lastI, lastJ = lastI-1, lastJ-1\\n        } else {\\n            return false\\n        }\\n    }\\n    if lastJ < 0 {\\n        return lastI < 0\\n    }\\n    if lastI < 0 {\\n        for j=0; j<=lastJ; j++ {\\n            if p[j] != \\'*\\' {\\n                return false\\n            }\\n        }\\n        return true\\n    }\\n\\tlastStar = -1\\n\\t//match from front to end\\n    for i <= lastI {\\n        if j <= lastJ {\\n            if p[j] == \\'?\\' || s[i] == p[j] {\\n                i, j = i+1, j+1\\n                continue\\n            }\\n            if p[j] == \\'*\\' {\\n                matched, lastStar = i, j\\n                j++\\n                continue\\n            }\\n        }\\n        if lastStar < 0 {\\n            return false\\n        }\\n        matched++\\n        i, j = matched, lastStar+1\\n    }\\n\\n    for ; j <= lastJ; j++ {\\n        if p[j] != \\'*\\' {\\n            return false\\n        }\\n    }\\n    return true\\n}\\n```\n```\\nfunc isMatch(s string, p string) bool {\\n    if len(p) == 0 {\\n        return len(s) == 0\\n    }\\n    dp := make([][]bool, len(p) + 1)\\n    for i := 0; i < len(dp); i++ {\\n        dp[i] = make([]bool, len(s) + 1)\\n    }\\n    dp[0][0] = true\\n    for i:=1;i<=len(p);i++ {\\n        dp[i][0] = dp[i-1][0] && p[i-1] == \\'*\\'\\n        for j := 1; j <= len(s); j++ {\\n            switch p[i-1] {\\n            case \\'?\\':\\n                dp[i][j] = dp[i-1][j-1]\\n            case \\'*\\':\\n                dp[i][j] = dp[i-1][j] || dp[i][j-1]\\n            default:\\n                dp[i][j] = dp[i-1][j-1] && p[i-1] == s[j-1]\\n            }\\n        }\\n    }\\n    return dp[len(p)][len(s)]\\n}\\n```\n```go\\n\\t...\\n\\tswitch p[i-1] {\\n\\tcase \\'?\\':\\n\\t\\tdp[i][j] = dp[i-1][j-1]\\n\\tcase \\'*\\':\\n\\t\\tdp[i][j] = dp[i-1][j] || dp[i][j-1]\\n\\t...\\n```\n```go\\nfunc isMatch(s string, p string) bool {\\n    if len(p) == 0 {\\n        return len(s) == 0\\n    }\\n    //shrink redundant `*`.\\n    var charCount int\\n    var b bytes.Buffer\\n    for i := 0; i < len(p); i++ {\\n        if p[i] != \\'*\\' || i == 0 || p[i] != p[i-1] {\\n            b.WriteByte(p[i])\\n            if p[i] != \\'*\\' {\\n                charCount++\\n            }\\n        }\\n    }\\n    if charCount > len(s) {\\n        return false\\n    }\\n    if b.Len() < len(p) {\\n        p = b.String()\\n    }\\n\\t\\n    var dp = make([]bool, len(s)+1)\\n    dp[0] = true\\n    var firstMatch,stopMatch, lastMatch,dpCur = 1,0,0,true\\n\\t\\n    for i := 1; i <= len(p); i++ {\\n        dpCur = dp[firstMatch-1] && p[i-1] == \\'*\\'\\n        matched := dpCur\\n        if p[i-1] == \\'*\\' {\\n            stopMatch = len(s) - charCount\\n        } else {\\n            charCount--\\n\\t\\t\\tstopMatch = lastMatch + 1\\n\\t\\t\\t// Don\\'t worry about overflow if `stopMatch > len(s)`. It won\\'t happen.\\n        }\\n        for j := firstMatch; j <= stopMatch; j++ {\\n            switch p[i-1] {\\n            case \\'?\\':\\n                dpCur, dp[j-1] = dp[j-1], dpCur\\n            case \\'*\\':\\n                dpCur, dp[j-1] = dpCur || dp[j], dpCur\\n            default:\\n                dpCur, dp[j-1] = dp[j-1] && p[i-1] == s[j-1], dpCur\\n            }\\n            if dpCur {\\n                if !matched {\\n                    firstMatch = j\\n                    matched = true\\n                }\\n                lastMatch = j\\n            }\\n        }\\n        if !matched {\\n            //we already know s[:j] doesn\\'t match p[:i]. So we don\\'t need more comparing.\\n            return false\\n        }\\n        dp[stopMatch] = dpCur\\n    }\\n    return dp[len(s)]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 17887,
                "title": "128ms-o-1-space-python-solution",
                "content": "    class Solution:\\n        # @param {string} s\\n        # @param {string} p\\n        # @return {boolean}\\n        def isMatch(self, s, p):\\n            if not p:\\n                return not s\\n    \\n            m, n = len(s), len(p)\\n            i = j = 0\\n            last_x = 0\\n            last_y = -1\\n            while i < m:\\n                if j < n and (p[j] == '?' or p[j] == s[i]):\\n                    i += 1\\n                    j += 1\\n                elif j < n and p[j] == '*':\\n                    last_x = i\\n                    last_y = j\\n                    j += 1\\n                elif last_y >= 0:\\n                    i = last_x + 1\\n                    last_x += 1\\n                    j = last_y\\n                else:\\n                    return False\\n            \\n            while j < n and p[j] == '*':\\n                j += 1\\n\\n            return j == n",
                "solutionTags": [],
                "code": "class Solution:\\n        # @param {string}",
                "codeTag": "Java"
            },
            {
                "id": 17958,
                "title": "my-java-dp-solution",
                "content": "a shorter version\\n\\npublic class Solution {\\n    \\n    public boolean isMatch(String s, String p) {\\n        if (p.replace(\"*\", \"\").length() > s.length())\\n            return false;\\n\\t\\tboolean[] d = new boolean[s.length() + 1];\\n\\t\\td[0] = true;\\n\\t\\tfor (int i = 1; i < s.length(); ++i) {\\n\\t\\t\\td[i] = false;\\n\\t\\t}\\n\\t\\tfor (int i = 1; i <= p.length(); ++i) {\\n\\t\\t\\tchar pchar = p.charAt(i - 1);\\n\\t\\t\\tif (pchar == '*') {\\n\\t\\t\\t\\tfor (int j = 1; j <= s.length(); ++j) {\\n\\t\\t\\t\\t\\td[j] = d[j - 1] || d[j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tfor (int j = s.length(); j >= 1; --j) {\\n\\t\\t\\t\\t\\td[j] = d[j - 1] && (pchar == '?' || pchar == s.charAt(j - 1));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\td[0] = d[0] && pchar == '*';\\n\\t\\t}\\n\\t\\treturn d[s.length()];\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n    public boolean isMatch(String s, String p) {\\n        if (p.replace(\"*\", \"\").length() > s.length())\\n            return false;\\n\\t\\tboolean[] d = new boolean[s.length() + 1];\\n\\t\\td[0] = true;\\n\\t\\tfor (int i = 1; i < s.length(); ++i) {\\n\\t\\t\\td[i] = false;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 17961,
                "title": "c-o-n-m-solution-using-kmp",
                "content": "    class Solution {\\n    public:\\n        void GetLut(const char *p, int posp, int len, vector<int> *lut) {\\n            (*lut)[0] = -1;\\n            int pos = -1;\\n            for (int i = 1; i < len; ++i) {\\n                while (pos > -1 && p[posp+pos+1] != p[posp + i] && p[posp+pos+1] != '?' && p[posp+i] != '?')\\n                    pos = (*lut)[pos];\\n                if (p[posp+pos+1] == p[posp+i] || p[posp+pos+1] == '?' || p[posp+i] == '?') {\\n                    (*lut)[i] = ++pos;\\n                } else {\\n                    (*lut)[i] = -1;\\n                }\\n            }\\n        }\\n        int MyStrStr(const char *s, int poss, int lens, const char *p, int posp, int len) {\\n            if (lens - poss < len - posp) return -1;\\n            vector<int> lut(len);\\n            GetLut(p, posp, len, &lut);\\n            int pos = -1;\\n            for (int i = 0; i < lens - poss; ++i) {\\n                while (pos > -1 && p[posp+pos+1] != s[poss + i] && p[posp+pos+1] != '?')\\n                    pos = lut[pos];\\n                if (p[posp+pos+1] == s[poss+i] || p[posp+pos+1] == '?') {\\n                    ++pos;\\n                    if (pos == len - 1) {\\n                        return poss + i - len + 1;    \\n                    }\\n                }\\n            }\\n            return -1;\\n        }\\n        bool isMatch(const char *s, const char *p) {\\n            int lens = 0;\\n            while (s[lens] != '\\\\0') ++lens;\\n            int lenp = 0;\\n            while (p[lenp] != '\\\\0') ++lenp;\\n            if (lens == 0 && lenp == 0) return true;\\n            if (lenp == 0) return false;\\n            vector<int> start;\\n            vector<int> len;\\n            int pos = 0;\\n            for (int i = 0; i < lenp; ++i) {\\n                if (p[i] != '*') {\\n                    if (i == 0 || p[i-1] == '*') {\\n                        pos = i;\\n                    }\\n                    if (i == lenp-1 || p[i+1] == '*') {\\n                        start.push_back(pos);\\n                        len.push_back(i - pos + 1);\\n                    }\\n                }\\n            }\\n            if (start.empty()) return true;\\n            if (lens == 0 && !start.empty()) return false;\\n            int poss = 0;\\n            for (int i = 0; i < start.size(); ++i) {\\n                int matchedpos = MyStrStr(s, poss, lens, p, start[i], len[i]);\\n                if (matchedpos == -1) return false;\\n                if (i ==  0 && p[0] != '*' && matchedpos > 0) return false;\\n                poss = matchedpos + len[i];\\n            }\\n            if (start.size() == 1 && p[lenp-1] != '*' && p[0] != '*') {\\n                if (lenp != lens) return false;\\n                return 0 == MyStrStr(s, 0, lens, p, 0, lenp);\\n            }\\n            if (p[lenp-1] != '*') {\\n                int matchedpos = MyStrStr(s, lens - len[len.size()-1], lens, p, start[start.size()-1], len[len.size()-1]);\\n                if (matchedpos == -1) return false;\\n            }\\n            return true;\\n        }\\n    };\\n\\nstring p can be divided into several substring by '\\\\*'. Match the first substring of p from starting point of string s, then second substring after the matchpoint of the first, and so on. If match is not found, return false. If the first element of p is not '*', the first match must be 0. If the last element of p is not '*', the last match must be at end of s. \\n\\ntime complexity is O(n + m) where n is length of s and m is length of p.\\n\\nWe are using a slightly change of KMP (for '?') to do string matching. For each substring of p, let's say we found a match in s, so the time for this search is O(matchedpos + len(substr of p)). For next substring of p, we do a KMP from the mathcedpos + len(prev substr of p)) in s. If we could match all substrings of p in s, the time will be O(len(s) + len(p)). We did some modifications at the end but it didnot change the time complexity.",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void GetLut(const char *p, int posp, int len, vector<int> *lut) {\\n            (*lut)[0] = -1;\\n            int pos = -1;\\n            for (int i = 1; i < len; ++i) {\\n                while (pos > -1 && p[posp+pos+1] != p[posp + i] && p[posp+pos+1] != '?' && p[posp+i] != '?')\\n                    pos = (*lut)[pos];\\n                if (p[posp+pos+1] == p[posp+i] || p[posp+pos+1] == '?' || p[posp+i] == '?') {\\n                    (*lut)[i] = ++pos;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2472083,
                "title": "python-dfs-memo-simple-with-comments",
                "content": "Simple DFS + memoization (via ```@cache```), beats 70%\\n\\n```\\n    def isMatch(self, s: str, p: str) -> bool:\\n        n, m = len(s), len(p)\\n\\n        # i is index in s, j is index in p\\n        @cache\\n        def dfs(i,j):\\n            # reached both string and pattern ends - matched\\n            if i >= n and j >= m:\\n                return True\\n\\n            # reached pattern end but not string end - not matched\\n            if j >= m:\\n                return False\\n\\n            # match characters under i and j indexes (plus additional check whether we reached end of string), move both indexes forward\\n            if i < n and (s[i] == p[j] or p[j] == \"?\"):\\n                return dfs(i + 1, j + 1)\\n\\n            # for wildcard there are two options:\\n            #   1) use it and move i forward (plus additional check whether we reached end of string)\\n            #   2) do not use it and move j forward\\n            if (p[j] == \"*\"):\\n                return (i < n and dfs(i + 1, j)) or dfs(i, j + 1)\\n\\n            # no wildcard and not matched (or reached end of string before reaching end of pattern)\\n            return False\\n\\n        return dfs(0,0)\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```@cache```\n```\\n    def isMatch(self, s: str, p: str) -> bool:\\n        n, m = len(s), len(p)\\n\\n        # i is index in s, j is index in p\\n        @cache\\n        def dfs(i,j):\\n            # reached both string and pattern ends - matched\\n            if i >= n and j >= m:\\n                return True\\n\\n            # reached pattern end but not string end - not matched\\n            if j >= m:\\n                return False\\n\\n            # match characters under i and j indexes (plus additional check whether we reached end of string), move both indexes forward\\n            if i < n and (s[i] == p[j] or p[j] == \"?\"):\\n                return dfs(i + 1, j + 1)\\n\\n            # for wildcard there are two options:\\n            #   1) use it and move i forward (plus additional check whether we reached end of string)\\n            #   2) do not use it and move j forward\\n            if (p[j] == \"*\"):\\n                return (i < n and dfs(i + 1, j)) or dfs(i, j + 1)\\n\\n            # no wildcard and not matched (or reached end of string before reaching end of pattern)\\n            return False\\n\\n        return dfs(0,0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 498316,
                "title": "dp-very-intuitive-with-no-bullshit-for-interviews-more-simpler-than-most-voted",
                "content": "\\tpublic boolean isMatch(String s, String p) {\\n\\t\\tboolean[][] dp = new boolean[s.length() + 1][p.length() + 1];\\n\\t\\tdp[0][0] = true;\\n\\n\\t\\tfor (int i = 1; i <= p.length(); i++) {\\n\\t\\t  if (p.charAt(i - 1) == \\'*\\') {\\n\\t\\t\\tdp[0][i] = dp[0][i - 1];\\n\\t\\t  }\\n\\t\\t}\\n\\n\\t\\tfor (int i = 1; i <= s.length(); i++) {\\n\\t\\t  for (int j = 1; j <= p.length(); j++) {\\n\\t\\t\\tchar sch = s.charAt(i - 1);\\n\\t\\t\\tchar pch = p.charAt(j - 1);\\n\\n\\t\\t\\tif (sch == pch || pch == \\'?\\') {\\n\\t\\t\\t  dp[i][j] = dp[i - 1][j - 1];\\n\\t\\t\\t} else if (pch == \\'*\\') {\\n\\t\\t\\t  dp[i][j] = dp[i - 1][j - 1] || dp[i][j - 1] || dp[i - 1][j];\\n\\t\\t\\t}\\n\\t\\t  }\\n\\t\\t}\\n\\n\\t\\treturn dp[s.length()][p.length()];\\n\\t  }",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "\\tpublic boolean isMatch(String s, String p) {\\n\\t\\tboolean[][] dp = new boolean[s.length() + 1][p.length() + 1];\\n\\t\\tdp[0][0] = true;\\n\\n\\t\\tfor (int i = 1; i <= p.length(); i++) {\\n\\t\\t  if (p.charAt(i - 1) == \\'*\\') {\\n\\t\\t\\tdp[0][i] = dp[0][i - 1];\\n\\t\\t  }\\n\\t\\t}\\n\\n\\t\\tfor (int i = 1; i <= s.length(); i++) {\\n\\t\\t  for (int j = 1; j <= p.length(); j++) {\\n\\t\\t\\tchar sch = s.charAt(i - 1);\\n\\t\\t\\tchar pch = p.charAt(j - 1);\\n\\n\\t\\t\\tif (sch == pch || pch == \\'?\\') {\\n\\t\\t\\t  dp[i][j] = dp[i - 1][j - 1];\\n\\t\\t\\t} else if (pch == \\'*\\') {\\n\\t\\t\\t  dp[i][j] = dp[i - 1][j - 1] || dp[i][j - 1] || dp[i - 1][j];\\n\\t\\t\\t}\\n\\t\\t  }\\n\\t\\t}\\n\\n\\t\\treturn dp[s.length()][p.length()];\\n\\t  }",
                "codeTag": "Unknown"
            },
            {
                "id": 17977,
                "title": "i-got-memory-limit-exceeded",
                "content": "Following is my code, I don't know what I got the Memory Limit Exceeded error.\\n\\n\\tpublic boolean isMatch(String s, String p) {\\n\\t\\tint lenS = s.length();\\n\\t\\tint lenP = p.length();\\n\\n\\t\\tboolean[][] dp = new boolean[lenS + 1][lenP + 1];\\n\\t\\tdp[0][0] = true;\\n\\t\\tfor (int i = 1; i <= lenS; i++) {\\n\\t\\t\\tfor (int j = 1; j <= lenP; j++) {\\n\\t\\t\\t\\tif (p.charAt(j - 1) == '*') {\\n\\t\\t\\t\\t\\tdp[i][j] = dp[i - 1][j] || dp[i][j - 1] || dp[i - 1][j - 1];\\n\\t\\t\\t\\t\\tif (j == lenP && dp[i][j]) {\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else if (s.charAt(i - 1) == p.charAt(j - 1)\\n\\t\\t\\t\\t\\t\\t|| p.charAt(j - 1) == '?') {\\n\\t\\t\\t\\t\\tdp[i][j] = dp[i - 1][j - 1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[lenS][lenP];\\n\\t}",
                "solutionTags": [],
                "code": "Following is my code, I don't know what I got the Memory Limit Exceeded error.\\n\\n\\tpublic boolean isMatch(String s, String p) {\\n\\t\\tint lenS = s.length();\\n\\t\\tint lenP = p.length();\\n\\n\\t\\tboolean[][] dp = new boolean[lenS + 1][lenP + 1];\\n\\t\\tdp[0][0] = true;\\n\\t\\tfor (int i = 1; i <= lenS; i++) {\\n\\t\\t\\tfor (int j = 1; j <= lenP; j++) {\\n\\t\\t\\t\\tif (p.charAt(j - 1) == '*') {\\n\\t\\t\\t\\t\\tdp[i][j] = dp[i - 1][j] || dp[i][j - 1] || dp[i - 1][j - 1];\\n\\t\\t\\t\\t\\tif (j == lenP && dp[i][j]) {\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else if (s.charAt(i - 1) == p.charAt(j - 1)\\n\\t\\t\\t\\t\\t\\t|| p.charAt(j - 1) == '?') {\\n\\t\\t\\t\\t\\tdp[i][j] = dp[i - 1][j - 1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[lenS][lenP];\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2276916,
                "title": "java-solution-memoization-tabulation-dp",
                "content": "Here I am both types of DP solution, Memoization and Tabulation.\\nYou will get TLE in memoization solution.\\n\\nIf you like the solution, then please UPVOTE it :)\\n\\nMemoization Solution\\n```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        int i = s.length();\\n        int j = p.length();\\n        if(j == 0 && i!= 0)\\n            return false;\\n        \\n        boolean[][] dp = new boolean[i][j];\\n        return match(s,p,i-1,j-1,dp);\\n    }\\n    \\n    public boolean match(String s , String p , int i , int j , boolean[][] dp)\\n    {\\n        if(i < 0 && j < 0)\\n            return true;\\n        \\n        if(i < 0){\\n            for(int k = 0 ; k <= j ; k++)\\n                if(p.charAt(k) != \\'*\\')\\n                    return false;\\n            \\n            return true;\\n        }\\n        \\n        if(j < 0)\\n        {\\n            return false;\\n        }\\n        \\n        if(dp[i][j])\\n            return dp[i][j];\\n        \\n        if(s.charAt(i) == p.charAt(j) || p.charAt(j) == \\'?\\') dp[i][j] = match(s,p,i-1,j-1,dp);\\n        else if(p.charAt(j) == \\'*\\') dp[i][j] = match(s,p,i-1,j,dp) | match(s,p,i,j-1,dp);\\n        \\n        return dp[i][j];\\n        \\n    }\\n}\\n```\\n\\nTabulation Solution\\n```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        int i = s.length();\\n        int j = p.length();\\n        \\n        boolean[][] dp = new boolean[i+1][j+1];\\n        \\n        dp[0][0] = true;\\n        \\n        for (int k = 1; k < j + 1; k++) {\\n            if (p.charAt(k - 1) == \\'*\\') {\\n                dp[0][k] = dp[0][k-1];\\n            }\\n        }\\n        \\n        \\n        for(int x = 1 ; x <= i ; x++)\\n        {\\n            for(int y = 1 ; y <= j ; y++){\\n                if(s.charAt(x-1) == p.charAt(y-1) || p.charAt(y-1) == \\'?\\')   \\n                    dp[x][y] = dp[x-1][y-1];\\n                else if(p.charAt(y-1) == \\'*\\')   \\n                    dp[x][y] = (dp[x-1][y] | dp[x][y-1]);\\n            }\\n        }\\n        \\n        return dp[i][j];\\n    }\\n}\\n```\\n\\nHaven\\'t UPVOTED yet, can do it now :)",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        int i = s.length();\\n        int j = p.length();\\n        if(j == 0 && i!= 0)\\n            return false;\\n        \\n        boolean[][] dp = new boolean[i][j];\\n        return match(s,p,i-1,j-1,dp);\\n    }\\n    \\n    public boolean match(String s , String p , int i , int j , boolean[][] dp)\\n    {\\n        if(i < 0 && j < 0)\\n            return true;\\n        \\n        if(i < 0){\\n            for(int k = 0 ; k <= j ; k++)\\n                if(p.charAt(k) != \\'*\\')\\n                    return false;\\n            \\n            return true;\\n        }\\n        \\n        if(j < 0)\\n        {\\n            return false;\\n        }\\n        \\n        if(dp[i][j])\\n            return dp[i][j];\\n        \\n        if(s.charAt(i) == p.charAt(j) || p.charAt(j) == \\'?\\') dp[i][j] = match(s,p,i-1,j-1,dp);\\n        else if(p.charAt(j) == \\'*\\') dp[i][j] = match(s,p,i-1,j,dp) | match(s,p,i,j-1,dp);\\n        \\n        return dp[i][j];\\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        int i = s.length();\\n        int j = p.length();\\n        \\n        boolean[][] dp = new boolean[i+1][j+1];\\n        \\n        dp[0][0] = true;\\n        \\n        for (int k = 1; k < j + 1; k++) {\\n            if (p.charAt(k - 1) == \\'*\\') {\\n                dp[0][k] = dp[0][k-1];\\n            }\\n        }\\n        \\n        \\n        for(int x = 1 ; x <= i ; x++)\\n        {\\n            for(int y = 1 ; y <= j ; y++){\\n                if(s.charAt(x-1) == p.charAt(y-1) || p.charAt(y-1) == \\'?\\')   \\n                    dp[x][y] = dp[x-1][y-1];\\n                else if(p.charAt(y-1) == \\'*\\')   \\n                    dp[x][y] = (dp[x-1][y] | dp[x][y-1]);\\n            }\\n        }\\n        \\n        return dp[i][j];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1604847,
                "title": "py3-py-simple-solution-using-recursion-w-comments",
                "content": "```\\nfrom functools import cache\\n\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n       \\n        # Init\\n        n = len(s)\\n        m = len(p)\\n       \\n        @cache # memoization\\n        def match(s_idx, p_idx) -> bool:\\n            \\n            # Wait for pattern to be exhausted\\n            if p_idx == m:\\n                return s_idx == n # string must be exhausted if it matches the pattern\\n            \\n            elif s_idx > n: # if string is exhausted before pattern is exhausted, return False\\n                return False\\n            \\n            else: # for all other scenarios\\n                \\n                # see if string matches the current pattern\\n                matched = ((s_idx < n) and (s[s_idx] == p[p_idx])) or (p[p_idx] in [\"*\", \"?\"])\\n                \\n                # if nothing matches, return false\\n                if not matched:\\n                    return False\\n                \\n                else: # in case of a match\\n                    \\n                    # check if pattern has \"*\"\\n                    if p[p_idx] == \"*\":\\n                        return (match(s_idx+1, p_idx) or # increment string index and stay at same pattern index\\n                                match(s_idx+1,p_idx+1) or # increment both string and patter index\\n                                match(s_idx, p_idx+1)) # increment pattern index and stay at the same string index\\n                    \\n                    else: # if pattern doesn\\'t have \"*\", then it either have \"?\" or same char as string\\n                        return match(s_idx+1, p_idx+1) # increment both string and pattern index\\n        \\n        return match(0,0)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Memoization"
                ],
                "code": "```\\nfrom functools import cache\\n\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n       \\n        # Init\\n        n = len(s)\\n        m = len(p)\\n       \\n        @cache # memoization\\n        def match(s_idx, p_idx) -> bool:\\n            \\n            # Wait for pattern to be exhausted\\n            if p_idx == m:\\n                return s_idx == n # string must be exhausted if it matches the pattern\\n            \\n            elif s_idx > n: # if string is exhausted before pattern is exhausted, return False\\n                return False\\n            \\n            else: # for all other scenarios\\n                \\n                # see if string matches the current pattern\\n                matched = ((s_idx < n) and (s[s_idx] == p[p_idx])) or (p[p_idx] in [\"*\", \"?\"])\\n                \\n                # if nothing matches, return false\\n                if not matched:\\n                    return False\\n                \\n                else: # in case of a match\\n                    \\n                    # check if pattern has \"*\"\\n                    if p[p_idx] == \"*\":\\n                        return (match(s_idx+1, p_idx) or # increment string index and stay at same pattern index\\n                                match(s_idx+1,p_idx+1) or # increment both string and patter index\\n                                match(s_idx, p_idx+1)) # increment pattern index and stay at the same string index\\n                    \\n                    else: # if pattern doesn\\'t have \"*\", then it either have \"?\" or same char as string\\n                        return match(s_idx+1, p_idx+1) # increment both string and pattern index\\n        \\n        return match(0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1016045,
                "title": "python-top-down-dynamic-programming",
                "content": "We track which character we are up to comparing between both strings, by using `s_idx` and `p_idx`\\n\\nThe recurrence relation is constructed from the following:\\n* If the current character of p is \"\\\\*\", we can...\\n\\t* Treat \\\\* as empty by skipping over it - `is_match(s, p, s_idx, p_idx + 1)`\\n\\t* Treat \\\\* as many characters - `is_match(s, p, s_idx + 1, p)`\\n\\t* Treat \\\\* as one character, so we increment both s_idx and p_idx by 1 - `is_match(s, p, s_idx + 1, p_idx + 1)`\\n* Otherwise, the current character is `?` or a letter, so...\\n    * For both `?` and letter, we simply advance the indexes by 1 - `is_match(s, p, s_idx + 1, p_idx + 1)`\\n\\n```\\nclass Solution:\\n    def is_match(self, s, p, s_idx, p_idx):\\n\\t    # reached end of both strings, it must have matched\\n        if s_idx >= len(s) and p_idx >= len(p):\\n            return True\\n  \\n\\t\\t# reached end of s, but there are still characters in p remaining\\n        if s_idx >= len(s) and p_idx < len(p):\\n\\t\\t    # if any character remaining in p, is not \"*\"\\n\\t\\t\\t# that means we have nothing in s to match, so return False\\n            for i in range(p_idx, len(p)):\\n                if p[i] != \"*\":\\n                    return False\\n            return True\\n        \\n\\t\\t# if we have reached end of p, but not end of s, this means\\n\\t\\t# we do not have sufficient characters in the pattern to match s\\n\\t\\t# return false\\n        if s_idx < len(s) and p_idx >= len(p):\\n            return False\\n        \\n        if (s_idx, p_idx) in self.dp:\\n            return self.dp[(s_idx, p_idx)]\\n        \\n        s_char = s[s_idx]\\n        p_char = p[p_idx]\\n        \\n        if p_char.isalpha() and s_char != p_char:\\n            return False\\n        \\n        if p_char == \"*\":\\n            skip_star = self.is_match(s, p, s_idx, p_idx + 1)\\n            use_star = self.is_match(s, p, s_idx + 1, p_idx)\\n            not_use_star = self.is_match(s, p, s_idx + 1, p_idx + 1)\\n            \\n            self.dp[(s_idx, p_idx)] = skip_star or use_star or not_use_star\\n            return self.dp[(s_idx, p_idx)]\\n        \\n        self.dp[(s_idx, p_idx)] = self.is_match(s, p, s_idx + 1, p_idx + 1)\\n        return self.dp[(s_idx, p_idx)]        \\n\\n\\n    def isMatch(self, s: str, p: str) -> bool:        \\n        self.dp = {}\\n        return self.is_match(s, p, 0, 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def is_match(self, s, p, s_idx, p_idx):\\n\\t    # reached end of both strings, it must have matched\\n        if s_idx >= len(s) and p_idx >= len(p):\\n            return True\\n  \\n\\t\\t# reached end of s, but there are still characters in p remaining\\n        if s_idx >= len(s) and p_idx < len(p):\\n\\t\\t    # if any character remaining in p, is not \"*\"\\n\\t\\t\\t# that means we have nothing in s to match, so return False\\n            for i in range(p_idx, len(p)):\\n                if p[i] != \"*\":\\n                    return False\\n            return True\\n        \\n\\t\\t# if we have reached end of p, but not end of s, this means\\n\\t\\t# we do not have sufficient characters in the pattern to match s\\n\\t\\t# return false\\n        if s_idx < len(s) and p_idx >= len(p):\\n            return False\\n        \\n        if (s_idx, p_idx) in self.dp:\\n            return self.dp[(s_idx, p_idx)]\\n        \\n        s_char = s[s_idx]\\n        p_char = p[p_idx]\\n        \\n        if p_char.isalpha() and s_char != p_char:\\n            return False\\n        \\n        if p_char == \"*\":\\n            skip_star = self.is_match(s, p, s_idx, p_idx + 1)\\n            use_star = self.is_match(s, p, s_idx + 1, p_idx)\\n            not_use_star = self.is_match(s, p, s_idx + 1, p_idx + 1)\\n            \\n            self.dp[(s_idx, p_idx)] = skip_star or use_star or not_use_star\\n            return self.dp[(s_idx, p_idx)]\\n        \\n        self.dp[(s_idx, p_idx)] = self.is_match(s, p, s_idx + 1, p_idx + 1)\\n        return self.dp[(s_idx, p_idx)]        \\n\\n\\n    def isMatch(self, s: str, p: str) -> bool:        \\n        self.dp = {}\\n        return self.is_match(s, p, 0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 155277,
                "title": "o-mn-time-o-mn-space-dp-solution-python-with-explanation",
                "content": "I probably could have combined some clauses, but it works.  The idea is that we need to go through all of the characters in the string, and the pattern and end up with true path at the end for it to return true.\\nThis means the current cell is true in the following cases:\\n1.  the current cell\\'s letters  i-1th letter from the string and j-1th letter from the string match and the dp[i-1][j-1] is true which means the previous two letter\\'s compared was true.\\n2.  if the current i-1th letter is * then we let all of the cases pass and the future cases pass so if dp[i-1][j] or dp[i][j-1] is true we mark dp[i][j] as true, this means all values ahead of this column will be marked as true\\n3.  if the current i-1th letter is ? then we just copy dp[i-1][j-1] (if the last letter matched was true)\\nThe branches are just to make sure we don\\'t have an out of range error since there\\'s a variety cases of i-1 and j-1s that can be less than 0 or that cases that we don\\'t have enough characters to get the i-1th or j-1th character, and probably can be cleaned up.\\nVisual Example:\\n```\\ns=\"adceb\"\\np=\"*a*b\"\\n     0       a       d    c         e     b\\n0  [true,  false,  false, false,  false, false]\\n*  [true,  true,   true,  true,   true,  true ]\\na  [false, true,   false, false,  false, false]\\n*  [false, true,   true,  true,   true,  true ]\\nb  [false,  false, false, false,  false, true ]\\n\\n```\\n```\\nclass Solution(object):\\n    def isMatch(self, s, p):\\n        N1 = len(p)\\n        N2 = len(s)\\n        dp = [[False for j in range(N2+1)] for i in range(N1+1)]\\n        for i in range(N1+1):\\n            for j in range(N2+1):\\n                if(i==0 and j==0):\\n                    dp[i][j]=True\\n                elif(j==0):\\n                    dp[i][j]= (N1>0 and i>0 and p[i-1]==\\'*\\' and (dp[i-1][j]));\\n                elif(i==0):\\n                    dp[i][j]= (N1>0 and i>0 and p[i-1]==\\'*\\' and (dp[i][j-1]));\\n                else:\\n                    dp[i][j]=((dp[i-1][j-1] and (N1>0 and N2>0 and p[i-1]==s[j-1]))or\\n                              (N1>0 and p[i-1]==\\'*\\' and (dp[i-1][j] or dp[i][j-1])) or \\n                              (N1>0 and p[i-1]==\\'?\\' and dp[i-1][j-1]))\\n        return dp[N1][N2]\\n```",
                "solutionTags": [],
                "code": "```\\ns=\"adceb\"\\np=\"*a*b\"\\n     0       a       d    c         e     b\\n0  [true,  false,  false, false,  false, false]\\n*  [true,  true,   true,  true,   true,  true ]\\na  [false, true,   false, false,  false, false]\\n*  [false, true,   true,  true,   true,  true ]\\nb  [false,  false, false, false,  false, true ]\\n\\n```\n```\\nclass Solution(object):\\n    def isMatch(self, s, p):\\n        N1 = len(p)\\n        N2 = len(s)\\n        dp = [[False for j in range(N2+1)] for i in range(N1+1)]\\n        for i in range(N1+1):\\n            for j in range(N2+1):\\n                if(i==0 and j==0):\\n                    dp[i][j]=True\\n                elif(j==0):\\n                    dp[i][j]= (N1>0 and i>0 and p[i-1]==\\'*\\' and (dp[i-1][j]));\\n                elif(i==0):\\n                    dp[i][j]= (N1>0 and i>0 and p[i-1]==\\'*\\' and (dp[i][j-1]));\\n                else:\\n                    dp[i][j]=((dp[i-1][j-1] and (N1>0 and N2>0 and p[i-1]==s[j-1]))or\\n                              (N1>0 and p[i-1]==\\'*\\' and (dp[i-1][j] or dp[i][j-1])) or \\n                              (N1>0 and p[i-1]==\\'?\\' and dp[i-1][j-1]))\\n        return dp[N1][N2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17878,
                "title": "brief-6ms-c-code",
                "content": "```\\nbool isMatch(char* s, char* p) {\\n    char *p0 = NULL, *s0 = NULL;\\n    while (*s) {\\n        if (*p == *s || *p == '?') {\\n            p++; \\n            s++;\\n        }else if (*p == '*') { // save\\n            p0 = ++p;\\n            s0 = s;\\n        }else if (p0 != NULL) { // load\\n            p = p0;\\n            s = ++s0;\\n        }else {\\n            return false;\\n        }\\n    }\\n    while (*p == '*') p++;\\n    return !*s && !*p;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool isMatch(char* s, char* p) {\\n    char *p0 = NULL, *s0 = NULL;\\n    while (*s) {\\n        if (*p == *s || *p == '?') {\\n            p++; \\n            s++;\\n        }else if (*p == '*') { // save\\n            p0 = ++p;\\n            s0 = s;\\n        }else if (p0 != NULL) { // load\\n            p = p0;\\n            s = ++s0;\\n        }else {\\n            return false;\\n        }\\n    }\\n    while (*p == '*') p++;\\n    return !*s && !*p;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3090375,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n     bool isMatch(string s, string p) {\\n        int m = s.size();\\n        int n = p.size();\\n        vector<vector<bool>> dp(m + 1, vector(n + 1, false));\\n        dp[0][0] = true;\\n        for (int j = 0; j < n && p[j] == \\'*\\'; j++) {\\n            dp[0][j + 1] = true;\\n        }\\n        \\n        for (int i = 1; i <= m; ++i) {\\n            for (int j = 1; j <= n; ++j) {\\n                if (p[j - 1] == \\'*\\') {\\n                    dp[i][j] = dp[i - 1][j] || dp[i][j - 1];\\n                } else if(s[i - 1] == p[j - 1] || p[j - 1] == \\'?\\') {\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n        // return f(s, p, 0, 0);    \\n    }\\n    bool f(string& s, string &p, int i, int j) {\\n        if(j == p.size())\\n        return i == s.size();\\n\\n        if(i == s.size())\\n        return p[j]==\\'*\\' && f(s, p, i, j+1);\\n\\n        if(p[j] == \\'*\\')\\n        return f(s, p, i, j+1) || f(s, p, i+1, j);\\n\\n        if(s[i] == p[j] || p[j] == \\'?\\')\\n        return f(s, p, i+1, j+1);\\n\\n        return false;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     bool isMatch(string s, string p) {\\n        int m = s.size();\\n        int n = p.size();\\n        vector<vector<bool>> dp(m + 1, vector(n + 1, false));\\n        dp[0][0] = true;\\n        for (int j = 0; j < n && p[j] == \\'*\\'; j++) {\\n            dp[0][j + 1] = true;\\n        }\\n        \\n        for (int i = 1; i <= m; ++i) {\\n            for (int j = 1; j <= n; ++j) {\\n                if (p[j - 1] == \\'*\\') {\\n                    dp[i][j] = dp[i - 1][j] || dp[i][j - 1];\\n                } else if(s[i - 1] == p[j - 1] || p[j - 1] == \\'?\\') {\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n        // return f(s, p, 0, 0);    \\n    }\\n    bool f(string& s, string &p, int i, int j) {\\n        if(j == p.size())\\n        return i == s.size();\\n\\n        if(i == s.size())\\n        return p[j]==\\'*\\' && f(s, p, i, j+1);\\n\\n        if(p[j] == \\'*\\')\\n        return f(s, p, i, j+1) || f(s, p, i+1, j);\\n\\n        if(s[i] == p[j] || p[j] == \\'?\\')\\n        return f(s, p, i+1, j+1);\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2580002,
                "title": "c-detailed-explaination-from-recursive-to-space-optimisation",
                "content": "## Approach:\\n\\n--> In this problem, we have to match `p` with `s` so here we can use string matching method in which we use 2 variables `i and j` and check for each character if they are matching or not.\\n\\n### If characters are matching:\\n\\nNow here we also have one extra condition which will be `if p[i] is \\'?\\'` and if it\\'s true then also we will consider it as match because `?` can match with any single character.\\n\\nSo for both of these conditions we will simply decrease both `i and j`.\\n\\n```cpp\\nif(p[i] == s[j] || p[i] == \\'?\\'){\\n\\treturn solve(i-1,j-1);\\n}\\n```\\n\\n### If p[i] is \\'*\\':\\n\\n--> now here we have 2 conditions:\\n\\n1. If we assume `\\'*\\'` as sequence of length 0 (means empty string)\\nthen we will simply decrease `i` and keep `j` as it is.\\n2. If we assume `\\'*\\'` as p[i]\\nthen we will decrease `j`.\\n\\n--> we have to do this for every character because `*` can have any length of subsequence so we will have check all possibilities:\\n\\nthis recursive tree will look like this:\\n\\n![image](https://assets.leetcode.com/users/images/c61364a5-4e1b-42ce-9435-65e3f00ccd20_1663254206.0240915.png)\\n\\n```cpp\\nif(p[i] == \\'*\\'){\\n\\treturn solve(i-1,j) || solve(i,j-1);\\n}\\n```\\n\\n### If p[i] and s[j] are not matching:\\n\\nthen we will simply return `false`\\n\\n## Base case:\\n\\n--> So in base case, there can be 2 possibilities:\\n\\n1. If we have traversed the p string means i is negative:\\n\\nthen we will check if `j is also negative` and if it is then we will return `true` because both strings got traversed and if `j is not negative` then we will return `false`.\\n\\n```cpp\\nif(i<0){\\n\\treturn j<0;\\n}\\n```\\n\\n2. If we have traversed the s string means j is negative:\\n\\nHere we can compare empty string with only one thing which is `\\'*\\'` so if p have all characters as `*` then we will return true otherwise we will return false.\\n\\n```cpp\\nif(j<0){\\n\\tfor(int k=0;k<=i;k++){\\n\\t\\tif(p[k] != \\'*\\'){\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\treturn true;\\n}\\n```\\n\\n## Recursive Code:\\n\\n```cpp\\n bool solve(int i,int j,string s,string p){\\n\\tif(i<0){\\n\\t\\treturn j<0;\\n\\t}\\n\\tif(j<0){\\n\\t\\tfor(int k=0;k<=i;k++){\\n\\t\\t\\tif(p[k] != \\'*\\'){\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\tif(p[i] == s[j] || p[i] == \\'?\\'){\\n\\t\\treturn solve(i-1,j-1,s,p);\\n\\t}\\n\\telse if(p[i] == \\'*\\'){\\n\\t\\treturn solve(i-1,j,s,p) || solve(i,j-1,s,p);\\n\\t}\\n\\t// if they are not matching\\n\\treturn false;\\n}\\nbool isMatch(string s, string p) {\\n\\treturn solve(p.size()-1,s.size()-1,s,p);\\n}\\n```\\n\\n## Memoization Code:\\n\\n```cpp\\nbool solve(int i,int j,string s,string p,vector<vector<int>>&dp){\\n\\tif(i<0){\\n\\t\\treturn j<0;\\n\\t}\\n\\tif(j<0){\\n\\t\\tfor(int k=0;k<=i;k++){\\n\\t\\t\\tif(p[k] != \\'*\\'){\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\tif(dp[i][j] != -1){\\n\\t\\treturn dp[i][j];\\n\\t}\\n\\tif(p[i] == s[j] || p[i] == \\'?\\'){\\n\\t\\treturn dp[i][j] = solve(i-1,j-1,s,p,dp);\\n\\t}\\n\\telse if(p[i] == \\'*\\'){\\n\\t\\treturn dp[i][j] = solve(i-1,j,s,p,dp) || solve(i,j-1,s,p,dp);\\n\\t}\\n\\t// if they are not matching\\n\\treturn dp[i][j] = false;\\n}\\nbool isMatch(string s, string p) {\\n\\tint n = p.size(),m = s.size();\\n\\tvector<vector<int>>dp(n+1,vector<int>(m,-1));\\n\\treturn solve(n-1,m-1,s,p,dp);\\n}\\n```\\n\\n## Tabulation Code:\\n\\n--> So in tabulation first we will write the base condition and also we have to change one thing which will ` we will use 1 based indexing` because in recursive code we are stopping at i or j becoming negative but we can\\'t do it here so we will use 1 based indexing.\\n\\nNow let\\'s see all base cases one by one:\\n\\n1. If i is 0 and j is also 0 then we will mark it as `true`\\n```cpp\\ndp[0][0] = true\\n```\\n\\n2. if i is 0 and j is greater than 0 then we will mark it as `false`.\\n\\n```cpp\\nfor(int j=1;j<=m;j++){\\n\\tdp[0][j] = false;\\n}\\n```\\n\\n3. if j is 0 then p must have all characters as `\\'*\\'` so that it can be matched with empty string.\\n\\n```cpp\\n// starting from 1 because it\\'s 1 based indexing.\\nfor(int i=1;i<=n;i++){\\n\\tbool flag = true;\\n\\tfor(int k=1;k<=i;k++){\\n\\t\\tif(p[k-1] != \\'*\\'){\\n\\t\\t\\tflag = false;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\tdp[i][0] = flag;\\n}\\n```\\n\\nNow after base case we will just have to run one loop from i from `1 to n` and one nested loop for j from `1 to m` and just copy paste the logic from recursion code:\\n\\n```cpp\\nbool isMatch(string s, string p) {\\n        int n = p.size(),m = s.size();\\n        vector<vector<bool>>dp(n+1,vector<bool>(m+1,false));\\n        // case 1\\n        dp[0][0] = true;\\n        // case 2\\n        for(int j=1;j<=m;j++){\\n            dp[0][j] = false;\\n        }\\n        // case 3\\n        for(int i=1;i<=n;i++){\\n            bool flag = true;\\n            for(int k=1;k<=i;k++){\\n                if(p[k-1] != \\'*\\'){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            dp[i][0] = flag;\\n        }\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(p[i-1] == s[j-1] || p[i-1] == \\'?\\'){\\n                    dp[i][j] = dp[i-1][j-1];\\n                }else if(p[i-1] == \\'*\\'){\\n                    dp[i][j] = dp[i][j-1] || dp[i-1][j];\\n                }else{\\n                    dp[i][j] = false;\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n```\\n\\n## Space optimisation:\\n\\n```cpp\\nbool isMatch(string s, string p) {\\n        int n = p.size(),m = s.size();\\n        vector<bool>prev(m+1,0),curr(m+1,0);\\n        // case 1\\n        prev[0] = true;\\n        // case 2\\n        for(int j=1;j<=m;j++){\\n            prev[j] = false;\\n        }\\n        for(int i=1;i<=n;i++){\\n\\t        // case 3\\n            bool flag = true;\\n            for(int k=1;k<=i;k++){\\n                if(p[k-1] != \\'*\\'){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            curr[0] = flag;\\n            for(int j=1;j<=m;j++){\\n                if(p[i-1] == s[j-1] || p[i-1] == \\'?\\'){\\n                    curr[j] = prev[j-1];\\n                }else if(p[i-1] == \\'*\\'){\\n                    curr[j] = curr[j-1] || prev[j];\\n                }else{\\n                    curr[j] = false;\\n                }\\n            }\\n            prev = curr;\\n        }\\n        return prev[m];\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String"
                ],
                "code": "```cpp\\nif(p[i] == s[j] || p[i] == \\'?\\'){\\n\\treturn solve(i-1,j-1);\\n}\\n```\n```cpp\\nif(p[i] == \\'*\\'){\\n\\treturn solve(i-1,j) || solve(i,j-1);\\n}\\n```\n```cpp\\nif(i<0){\\n\\treturn j<0;\\n}\\n```\n```cpp\\nif(j<0){\\n\\tfor(int k=0;k<=i;k++){\\n\\t\\tif(p[k] != \\'*\\'){\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\treturn true;\\n}\\n```\n```cpp\\n bool solve(int i,int j,string s,string p){\\n\\tif(i<0){\\n\\t\\treturn j<0;\\n\\t}\\n\\tif(j<0){\\n\\t\\tfor(int k=0;k<=i;k++){\\n\\t\\t\\tif(p[k] != \\'*\\'){\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\tif(p[i] == s[j] || p[i] == \\'?\\'){\\n\\t\\treturn solve(i-1,j-1,s,p);\\n\\t}\\n\\telse if(p[i] == \\'*\\'){\\n\\t\\treturn solve(i-1,j,s,p) || solve(i,j-1,s,p);\\n\\t}\\n\\t// if they are not matching\\n\\treturn false;\\n}\\nbool isMatch(string s, string p) {\\n\\treturn solve(p.size()-1,s.size()-1,s,p);\\n}\\n```\n```cpp\\nbool solve(int i,int j,string s,string p,vector<vector<int>>&dp){\\n\\tif(i<0){\\n\\t\\treturn j<0;\\n\\t}\\n\\tif(j<0){\\n\\t\\tfor(int k=0;k<=i;k++){\\n\\t\\t\\tif(p[k] != \\'*\\'){\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\tif(dp[i][j] != -1){\\n\\t\\treturn dp[i][j];\\n\\t}\\n\\tif(p[i] == s[j] || p[i] == \\'?\\'){\\n\\t\\treturn dp[i][j] = solve(i-1,j-1,s,p,dp);\\n\\t}\\n\\telse if(p[i] == \\'*\\'){\\n\\t\\treturn dp[i][j] = solve(i-1,j,s,p,dp) || solve(i,j-1,s,p,dp);\\n\\t}\\n\\t// if they are not matching\\n\\treturn dp[i][j] = false;\\n}\\nbool isMatch(string s, string p) {\\n\\tint n = p.size(),m = s.size();\\n\\tvector<vector<int>>dp(n+1,vector<int>(m,-1));\\n\\treturn solve(n-1,m-1,s,p,dp);\\n}\\n```\n```cpp\\ndp[0][0] = true\\n```\n```cpp\\nfor(int j=1;j<=m;j++){\\n\\tdp[0][j] = false;\\n}\\n```\n```cpp\\n// starting from 1 because it\\'s 1 based indexing.\\nfor(int i=1;i<=n;i++){\\n\\tbool flag = true;\\n\\tfor(int k=1;k<=i;k++){\\n\\t\\tif(p[k-1] != \\'*\\'){\\n\\t\\t\\tflag = false;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\tdp[i][0] = flag;\\n}\\n```\n```cpp\\nbool isMatch(string s, string p) {\\n        int n = p.size(),m = s.size();\\n        vector<vector<bool>>dp(n+1,vector<bool>(m+1,false));\\n        // case 1\\n        dp[0][0] = true;\\n        // case 2\\n        for(int j=1;j<=m;j++){\\n            dp[0][j] = false;\\n        }\\n        // case 3\\n        for(int i=1;i<=n;i++){\\n            bool flag = true;\\n            for(int k=1;k<=i;k++){\\n                if(p[k-1] != \\'*\\'){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            dp[i][0] = flag;\\n        }\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(p[i-1] == s[j-1] || p[i-1] == \\'?\\'){\\n                    dp[i][j] = dp[i-1][j-1];\\n                }else if(p[i-1] == \\'*\\'){\\n                    dp[i][j] = dp[i][j-1] || dp[i-1][j];\\n                }else{\\n                    dp[i][j] = false;\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n```\n```cpp\\nbool isMatch(string s, string p) {\\n        int n = p.size(),m = s.size();\\n        vector<bool>prev(m+1,0),curr(m+1,0);\\n        // case 1\\n        prev[0] = true;\\n        // case 2\\n        for(int j=1;j<=m;j++){\\n            prev[j] = false;\\n        }\\n        for(int i=1;i<=n;i++){\\n\\t        // case 3\\n            bool flag = true;\\n            for(int k=1;k<=i;k++){\\n                if(p[k-1] != \\'*\\'){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            curr[0] = flag;\\n            for(int j=1;j<=m;j++){\\n                if(p[i-1] == s[j-1] || p[i-1] == \\'?\\'){\\n                    curr[j] = prev[j-1];\\n                }else if(p[i-1] == \\'*\\'){\\n                    curr[j] = curr[j-1] || prev[j];\\n                }else{\\n                    curr[j] = false;\\n                }\\n            }\\n            prev = curr;\\n        }\\n        return prev[m];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1460303,
                "title": "c-easy-solution-with-explaination",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isMatch(string str, string pattern) {\\n        int m=pattern.size();\\n        int n=str.size();\\n\\n        bool dp[n+1][m+1];\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<m+1;j++){\\n                dp[i][j]=false;\\n            }\\n        }\\n        dp[0][0]=true;            //if both string and pattern are empty\\n\\n        for(int i=1;i<=m;i++){\\n           if(pattern[i-1]==\\'*\\')  //if pattern starts with \\'*\\' \\n           dp[0][i]=dp[0][i-1];\\n        }\\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<m+1;j++){\\n                if(str[i-1]==pattern[j-1] || pattern[j-1]==\\'?\\') //if the character matches or it a ? so we can replace it with any character, then answer depends on dp[i-1][j-1]\\n                dp[i][j]=dp[i-1][j-1];\\n                else if(pattern[j-1]==\\'*\\') //if it is a * then either we can skip 1 character of str or pattern\\n                dp[i][j]=dp[i-1][j] || dp[i][j-1];\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMatch(string str, string pattern) {\\n        int m=pattern.size();\\n        int n=str.size();\\n\\n        bool dp[n+1][m+1];\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<m+1;j++){\\n                dp[i][j]=false;\\n            }\\n        }\\n        dp[0][0]=true;            //if both string and pattern are empty\\n\\n        for(int i=1;i<=m;i++){\\n           if(pattern[i-1]==\\'*\\')  //if pattern starts with \\'*\\' \\n           dp[0][i]=dp[0][i-1];\\n        }\\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<m+1;j++){\\n                if(str[i-1]==pattern[j-1] || pattern[j-1]==\\'?\\') //if the character matches or it a ? so we can replace it with any character, then answer depends on dp[i-1][j-1]\\n                dp[i][j]=dp[i-1][j-1];\\n                else if(pattern[j-1]==\\'*\\') //if it is a * then either we can skip 1 character of str or pattern\\n                dp[i][j]=dp[i-1][j] || dp[i][j-1];\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1401330,
                "title": "c-dp-solution-with-comments-explaining-the-code",
                "content": "Scroll right to see the full comments\\n```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        int m = p.length() , n = s.length();\\n        vector<vector<int>> dp(m+1,vector<int>(n+1,0));\\n        dp[0][0] = 1; // Empty string matches empty string\\n        for(int i = 1 ; i <= m ; ++i)\\n        {\\n            if(p[i-1] == \\'*\\')\\n                dp[i][0] = dp[i-1][0]; // Any number of * matches empty string // E.g : ** and \\'\\'\\n        }\\n        // Note that we are using 0-based indexing for strings and in the dp table 0th positon indicates empty string hence we are checking for p[i-1] && s[j-1]\\n        for(int i = 1 ; i <= m ; ++i)\\n        {\\n            for(int j = 1 ; j <= n ; ++j)\\n            {\\n                if(p[i-1] == s[j-1] || p[i-1] == \\'?\\') // If the ith character of p and jth character of s is same or ith character of p is \\'?\\' then exclude ith and jth characters of p and s and check whether the rest of the strings upto (i-1)th in p and (j-1)th in s are matching E.g : ab and ab or ab and a?\\n                    dp[i][j] = dp[i-1][j-1];\\n                else // if p[i-1] != s[j-1]\\n                    if(p[i-1] == \\'*\\')\\n                    {\\n                        dp[i][j] = dp[i-1][j] || dp[i][j-1]; // If ith character of p is \\'*\\' then we have two choices : 1) make it null character in which case we check whether string upto (i-1)th character in p and upto jth character in s are matched E.g : ab and ab* 2) match the jth character in s in which case we check whether the string upto ith character in p and (j-1) th character in s are matched E.g : abcd and ab*\\n                    }\\n            }\\n        }\\n        return dp[m][n]; // If both the strings were fully matched\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        int m = p.length() , n = s.length();\\n        vector<vector<int>> dp(m+1,vector<int>(n+1,0));\\n        dp[0][0] = 1; // Empty string matches empty string\\n        for(int i = 1 ; i <= m ; ++i)\\n        {\\n            if(p[i-1] == \\'*\\')\\n                dp[i][0] = dp[i-1][0]; // Any number of * matches empty string // E.g : ** and \\'\\'\\n        }\\n        // Note that we are using 0-based indexing for strings and in the dp table 0th positon indicates empty string hence we are checking for p[i-1] && s[j-1]\\n        for(int i = 1 ; i <= m ; ++i)\\n        {\\n            for(int j = 1 ; j <= n ; ++j)\\n            {\\n                if(p[i-1] == s[j-1] || p[i-1] == \\'?\\') // If the ith character of p and jth character of s is same or ith character of p is \\'?\\' then exclude ith and jth characters of p and s and check whether the rest of the strings upto (i-1)th in p and (j-1)th in s are matching E.g : ab and ab or ab and a?\\n                    dp[i][j] = dp[i-1][j-1];\\n                else // if p[i-1] != s[j-1]\\n                    if(p[i-1] == \\'*\\')\\n                    {\\n                        dp[i][j] = dp[i-1][j] || dp[i][j-1]; // If ith character of p is \\'*\\' then we have two choices : 1) make it null character in which case we check whether string upto (i-1)th character in p and upto jth character in s are matched E.g : ab and ab* 2) match the jth character in s in which case we check whether the string upto ith character in p and (j-1) th character in s are matched E.g : abcd and ab*\\n                    }\\n            }\\n        }\\n        return dp[m][n]; // If both the strings were fully matched\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1365119,
                "title": "no-dp-60-ms-faster-than-87-73-of-python3-double-pointer-question",
                "content": "```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        i = j = 0  \\n        back_j = -1  \\n        match_i = 0   \\n        m = len(s)\\n        n = len(p)\\n        while i < m:\\n            if j < n and (s[i] == p[j] or p[j] == \\'?\\'):  \\n                i += 1\\n                j += 1\\n            elif j < n and p[j] == \\'*\\':  \\n                back_j = j  \\n                match_i = i  \\n                j += 1  \\n            elif back_j != -1:  \\n                j = back_j + 1\\n                match_i += 1  \\n                i = match_i\\n            else:  \\n                return False\\n            print(p[j:])\\n        return list(p[j:]).count(\\'*\\') == len(p[j:]) \\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        i = j = 0  \\n        back_j = -1  \\n        match_i = 0   \\n        m = len(s)\\n        n = len(p)\\n        while i < m:\\n            if j < n and (s[i] == p[j] or p[j] == \\'?\\'):  \\n                i += 1\\n                j += 1\\n            elif j < n and p[j] == \\'*\\':  \\n                back_j = j  \\n                match_i = i  \\n                j += 1  \\n            elif back_j != -1:  \\n                j = back_j + 1\\n                match_i += 1  \\n                i = match_i\\n            else:  \\n                return False\\n            print(p[j:])\\n        return list(p[j:]).count(\\'*\\') == len(p[j:]) \\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1228581,
                "title": "backtracking-97-faster-javascript-version-of-official-solution-es6",
                "content": "`Approach:` Backtracking\\n`Algorithm:`\\n- Initiate 3 pointers: \\n\\tpointer for pattern-index\\n\\tpointer for string-index\\n\\tpointer for temporary-index when we encounter \"*\" in pattern\\n- Initiate a variable for storing index-position of star \"*\"\\n- both string pointer and pattern pointer are moved forward by 1 step whenever:\\n\\tchars in string and pattern match OR\\n\\tchar in string matches with \"?\" in pattern\\n- Only pattern pointer is moved by a step when we encounter a \"*\"\\n- Only string pointer is moved when a char  doesn\\'t match with char in pattern\\n- The starIndex acts as a reference point during entire iteration\\n- The temp-index along with string-index are constantly updated when chars in pattern and string do not match. \\n\\n`Code:`\\n```\\nconst isMatch = function (string, pattern) {\\n  let s = 0, p = 0;\\n  let starIdx = -1, pointer = -1;\\n\\n  while (s < string.length) {\\n    if ((p < pattern.length && string[s] === pattern[p]) || pattern[p] === \"?\") {\\n      s++;\\n      p++;\\n    } \\n\\telse if (p < pattern.length && pattern[p] === \"*\") {\\n      starIdx = p;\\n      pointer = s;\\n      p++;\\n    } \\n\\telse if (starIdx === -1) return false;\\n    else {\\n      p = starIdx + 1;\\n      s = pointer + 1;\\n      pointer = s;\\n    }\\n  }\\n  for (let idx = p; idx < pattern.length; idx++) {\\n    if (pattern[idx] !== \"*\") return false;\\n  }\\n  return true;\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/c629aa14-6b86-48a5-a535-ff42e006c84e_1621887091.1771438.png)\\n",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\nconst isMatch = function (string, pattern) {\\n  let s = 0, p = 0;\\n  let starIdx = -1, pointer = -1;\\n\\n  while (s < string.length) {\\n    if ((p < pattern.length && string[s] === pattern[p]) || pattern[p] === \"?\") {\\n      s++;\\n      p++;\\n    } \\n\\telse if (p < pattern.length && pattern[p] === \"*\") {\\n      starIdx = p;\\n      pointer = s;\\n      p++;\\n    } \\n\\telse if (starIdx === -1) return false;\\n    else {\\n      p = starIdx + 1;\\n      s = pointer + 1;\\n      pointer = s;\\n    }\\n  }\\n  for (let idx = p; idx < pattern.length; idx++) {\\n    if (pattern[idx] !== \"*\") return false;\\n  }\\n  return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 799513,
                "title": "javascript-solutions",
                "content": "This is my original solution with help from [here](https://leetcode.com/problems/wildcard-matching/discuss/370736/Detailed-Intuition-From-Brute-force-to-Bottom-up-DP). It recursively goes through the two lists, and uses an object for memoization to help with performance.\\n\\n```\\nvar isMatch1 = function(s, p) {\\n    return helper(s, p, 0, 0, {})\\n};\\n\\nlet helper = function(s, p, sIndex, pIndex, memo) {\\n    if (\"S\" + sIndex + \"P\" + pIndex in memo) return memo[\"S\" + sIndex + \"P\" + pIndex]\\n    let res = false\\n    if (pIndex == p.length && sIndex == s.length) res = true\\n    else if (pIndex == p.length) res = false\\n    else if (sIndex == s.length) res = p[pIndex] == \"*\" && helper(s, p, sIndex, pIndex + 1, memo)\\n    else if (p[pIndex] == \"*\") res =  helper(s, p, sIndex, pIndex + 1, memo) || helper(s, p, sIndex + 1, pIndex, memo)\\n    else if (s[sIndex] == p[pIndex] || p[pIndex] == \"?\") res = helper(s, p, sIndex + 1, pIndex + 1, memo)\\n    else res = false\\n    memo[\"S\" + sIndex + \"P\" + pIndex] = res\\n    return res\\n}\\n\\nfunction allStars(input) {\\n    return input && input.split(\\'\\').every(char => char === \"*\");\\n}\\n```\\nThis is a javascript implmentation of [this solution](https://leetcode.com/problems/wildcard-matching/discuss/17810/Linear-runtime-and-constant-space-solution). It has the key insight that you only ever need to care about the most recent asterisk, and not every asterick. Thus we only need to keep track of that asterick, and reset whenever we hit a failure state.\\n```\\nvar isMatch2 = function(s, p) {\\n    let sIndex = 0, pIndex = 0, star, ss = sIndex\\n    while(sIndex < s.length) {\\n        console.log(sIndex, pIndex, star, ss)\\n        if (p[pIndex] == \"?\" || p[pIndex] == s[sIndex]) { sIndex++; pIndex++ }\\n        else if (p[pIndex] == \"*\") { star = pIndex++; ss = sIndex }\\n        else if (star != undefined) { pIndex = star + 1; sIndex = ++ss }\\n        else return false\\n    }\\n    while(p[pIndex] == \"*\") {pIndex++}\\n    return pIndex == p.length\\n}\\n```\\n\\nThis is a javascript implementation of [this solution](https://leetcode.com/problems/wildcard-matching/discuss/256025/Python-DP-with-illustration). It uses dp to keep track of which states are valid given the string/pattern seen up until that point.\\n\\n```\\nvar isMatch3 = function(s, p) {\\n    let dp = []\\n    for (let i = 0; i < s.length + 1; i++) {\\n        let arr = new Array(p.length + 1).fill(false)\\n        dp.push(arr)\\n    }\\n    dp[0][0] = true\\n    for (let i = 1; i < p.length + 1; i++) {\\n        if(p[i - 1] != \\'*\\') break\\n        else dp[0][i] = true\\n    }\\n    for (let i = 1; i < s.length + 1; i++) {\\n        for (let j = 1; j < p.length + 1; j++) {\\n            if (p[j - 1] == s[i - 1] || p[j - 1] == \"?\") {dp[i][j] = dp[i-1][j-1]}\\n            else if (p[j - 1] == \"*\") {dp[i][j] = dp[i-1][j] || dp[i][j-1]}\\n        }\\n    }\\n    return dp[s.length][p.length]\\n}\\n```\\n\\nHappy coding!\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isMatch1 = function(s, p) {\\n    return helper(s, p, 0, 0, {})\\n};\\n\\nlet helper = function(s, p, sIndex, pIndex, memo) {\\n    if (\"S\" + sIndex + \"P\" + pIndex in memo) return memo[\"S\" + sIndex + \"P\" + pIndex]\\n    let res = false\\n    if (pIndex == p.length && sIndex == s.length) res = true\\n    else if (pIndex == p.length) res = false\\n    else if (sIndex == s.length) res = p[pIndex] == \"*\" && helper(s, p, sIndex, pIndex + 1, memo)\\n    else if (p[pIndex] == \"*\") res =  helper(s, p, sIndex, pIndex + 1, memo) || helper(s, p, sIndex + 1, pIndex, memo)\\n    else if (s[sIndex] == p[pIndex] || p[pIndex] == \"?\") res = helper(s, p, sIndex + 1, pIndex + 1, memo)\\n    else res = false\\n    memo[\"S\" + sIndex + \"P\" + pIndex] = res\\n    return res\\n}\\n\\nfunction allStars(input) {\\n    return input && input.split(\\'\\').every(char => char === \"*\");\\n}\\n```\n```\\nvar isMatch2 = function(s, p) {\\n    let sIndex = 0, pIndex = 0, star, ss = sIndex\\n    while(sIndex < s.length) {\\n        console.log(sIndex, pIndex, star, ss)\\n        if (p[pIndex] == \"?\" || p[pIndex] == s[sIndex]) { sIndex++; pIndex++ }\\n        else if (p[pIndex] == \"*\") { star = pIndex++; ss = sIndex }\\n        else if (star != undefined) { pIndex = star + 1; sIndex = ++ss }\\n        else return false\\n    }\\n    while(p[pIndex] == \"*\") {pIndex++}\\n    return pIndex == p.length\\n}\\n```\n```\\nvar isMatch3 = function(s, p) {\\n    let dp = []\\n    for (let i = 0; i < s.length + 1; i++) {\\n        let arr = new Array(p.length + 1).fill(false)\\n        dp.push(arr)\\n    }\\n    dp[0][0] = true\\n    for (let i = 1; i < p.length + 1; i++) {\\n        if(p[i - 1] != \\'*\\') break\\n        else dp[0][i] = true\\n    }\\n    for (let i = 1; i < s.length + 1; i++) {\\n        for (let j = 1; j < p.length + 1; j++) {\\n            if (p[j - 1] == s[i - 1] || p[j - 1] == \"?\") {dp[i][j] = dp[i-1][j-1]}\\n            else if (p[j - 1] == \"*\") {dp[i][j] = dp[i-1][j] || dp[i][j-1]}\\n        }\\n    }\\n    return dp[s.length][p.length]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 314824,
                "title": "java-two-pointer-solution",
                "content": "```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        if (s.length() == 0 && p.length() == 0) return true;\\n        int i = 0;\\n        int j = 0;\\n        int star = -1;\\n        int match = 0;\\n        while (i < s.length()) {\\n            if (j < p.length() && (p.charAt(j) == s.charAt(i) || p.charAt(j) == \\'?\\')) {\\n                i++;\\n                j++;\\n            }else if (j < p.length() && p.charAt(j) == \\'*\\') {\\n                star = j;\\n                match = i;\\n                j++;\\n            }else if (star != -1) {\\n                j = star + 1;\\n                match++;\\n                i = match;\\n            }else return false;\\n        }\\n        while (j < p.length() && p.charAt(j) == \\'*\\') j++;\\n        return j == p.length();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        if (s.length() == 0 && p.length() == 0) return true;\\n        int i = 0;\\n        int j = 0;\\n        int star = -1;\\n        int match = 0;\\n        while (i < s.length()) {\\n            if (j < p.length() && (p.charAt(j) == s.charAt(i) || p.charAt(j) == \\'?\\')) {\\n                i++;\\n                j++;\\n            }else if (j < p.length() && p.charAt(j) == \\'*\\') {\\n                star = j;\\n                match = i;\\n                j++;\\n            }else if (star != -1) {\\n                j = star + 1;\\n                match++;\\n                i = match;\\n            }else return false;\\n        }\\n        while (j < p.length() && p.charAt(j) == \\'*\\') j++;\\n        return j == p.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17844,
                "title": "java-recursive-solution",
                "content": "```\\npublic class Solution {\\n    public boolean isMatch(String s, String p) {\\n        return helper(s.toCharArray(), p.toCharArray(), 0, 0, 0, -1);\\n    }\\n    \\n    private boolean helper(char[] s, char[] p, int i, int j, int lastS, int lastP) {\\n        if(i == s.length && j == p.length) return true;\\n        if(j < p.length) {\\n            if(i == s.length)\\n                return p[j] == '*' ? helper(s, p, i, j + 1, lastS, lastP) : false;\\n            if(p[j] == '?' || s[i] == p[j])\\n                return helper(s, p, i + 1, j + 1, lastS, lastP);\\n            if(p[j] == '*')\\n                return helper(s, p, i, j + 1, i, j);\\n        }\\n        if(lastP != -1) return helper(s, p, lastS + 1, lastP, lastS + 1, lastP);\\n        return false;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isMatch(String s, String p) {\\n        return helper(s.toCharArray(), p.toCharArray(), 0, 0, 0, -1);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 17900,
                "title": "beat-99-runtime-103-o-n-time-o-1-space",
                "content": "first approach works and run beats over 90%, second approach cannot work but wanna seek advice.\\n\\nLoop\\n\\n1. keep two pointers in S and P here i and j\\n\\n2. if S[i] == P[j] or P[j] == '?' we keep moving\\n3. if '*' exist in P then we mark the position in P as star and mark position in s as s_star\\n4. Loop over s until S[i] == P[star + 1]\\notherwise\\n  False\\n\\nnote that S = 'a' P = 'a*******' is still True\\nSo we need to loop over P to check this case  \\n\\n\\n \\nif we can compare p to the end that  means True\\n\\n    class Solution(object):\\n    def isMatch(self, s, p):\\n        \"\"\"\\n        :type s: str\\n        :type p: str\\n        :rtype: bool\\n        \"\"\"\\n        i = 0\\n        j = 0\\n        star = -1\\n        s_star = 0\\n        s_len = len(s)\\n        p_len = len(p)\\n        while i < s_len:\\n            if i < s_len and j < p_len and (s[i] == p[j] or p[j] == '?'):\\n                i += 1\\n                j += 1\\n            elif j < p_len and p[j] == '*':\\n                star = j\\n                s_star = i\\n                j += 1\\n            elif star != -1:\\n                j = star + 1\\n                s_star += 1\\n                i = s_star\\n            else:\\n                return False\\n        while j < p_len and p[j] == '*':\\n            j += 1\\n        return j == p_len\\n        \\nI have also Tried more traditional method with O(MN) space and Time but get LTE suggestions?\\n\\n\\n    class Solution(object):\\n    def isMatch(self, s, p):\\n        \"\"\"\\n        :type s: str\\n        :type p: str\\n        :rtype: bool\\n        \"\"\"\\n        s_len = len(s)\\n        p_len = len(p)\\n        dp = [[False for _ in range(p_len + 1)] for _ in range(s_len + 1)]\\n        dp[0][0] = True\\n        for col in range(1, p_len + 1):\\n            dp[0][col] = dp[0][col - 1] and p[col - 1] == '*'\\n        \\n        for row in range(1, s_len + 1):\\n            for col in range(1, p_len + 1):\\n                if p[col - 1] == '*':\\n                    dp[row][col] = dp[row][col - 1] or dp[row - 1][col - 1]\\n                else:\\n                    dp[row][col] = dp[row - 1][col - 1] and (s[row - 1] == p[col - 1] or p[col - 1] == '?')\\n        return dp[-1][-1]",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "first approach works and run beats over 90%, second approach cannot work but wanna seek advice.\\n\\nLoop\\n\\n1. keep two pointers in S and P here i and j\\n\\n2. if S[i] == P[j] or P[j] == '?' we keep moving\\n3. if '*' exist in P then we mark the position in P as star and mark position in s as s_star\\n4. Loop over s until S[i] == P[star + 1]\\notherwise\\n  False\\n\\nnote that S = 'a' P = 'a*******' is still True\\nSo we need to loop over P to check this case  \\n\\n\\n \\nif we can compare p to the end that  means True\\n\\n    class Solution(object):\\n    def isMatch(self, s, p):\\n        \"\"\"\\n        :type s: str\\n        :type p: str\\n        :rtype: bool\\n        \"\"\"\\n        i = 0\\n        j = 0\\n        star = -1\\n        s_star = 0\\n        s_len = len(s)\\n        p_len = len(p)\\n        while i < s_len:\\n            if i < s_len and j < p_len and (s[i] == p[j] or p[j] == '?'):\\n                i += 1\\n                j += 1\\n            elif j < p_len and p[j] == '*':\\n                star = j\\n                s_star = i\\n                j += 1\\n            elif star != -1:\\n                j = star + 1\\n                s_star += 1\\n                i = s_star\\n            else:\\n                return False\\n        while j < p_len and p[j] == '*':\\n            j += 1\\n        return j == p_len\\n        \\nI have also Tried more traditional method with O(MN) space and Time but get LTE suggestions?\\n\\n\\n    class Solution(object):\\n    def isMatch(self, s, p):\\n        \"\"\"\\n        :type s: str\\n        :type p: str\\n        :rtype: bool\\n        \"\"\"\\n        s_len = len(s)\\n        p_len = len(p)\\n        dp = [[False for _ in range(p_len + 1)] for _ in range(s_len + 1)]\\n        dp[0][0] = True\\n        for col in range(1, p_len + 1):\\n            dp[0][col] = dp[0][col - 1] and p[col - 1] == '*'\\n        \\n        for row in range(1, s_len + 1):\\n            for col in range(1, p_len + 1):\\n                if p[col - 1] == '*':\\n                    dp[row][col] = dp[row][col - 1] or dp[row - 1][col - 1]\\n                else:\\n                    dp[row][col] = dp[row - 1][col - 1] and (s[row - 1] == p[col - 1] or p[col - 1] == '?')\\n        return dp[-1][-1]",
                "codeTag": "Java"
            },
            {
                "id": 17946,
                "title": "share-my-straight-forward-dp-java-code-o-n-2-complexity",
                "content": "    class Solution {\\n        public boolean isMatch(String s, String p) {\\n            //little trick here to avoid checking some corner cases\\n            return _isMatch(\"a\" + s, \"a\" + p);\\n        }\\n        public boolean _isMatch(String s, String p) {\\n            boolean[][] valid = new boolean[p.length()][s.length()];\\n            valid[0][0] = true;\\n            for(int i = 1; i < p.length(); ++i){  \\t\\n                valid[i][0] = p.charAt(i) == '*' && valid[i-1][0];\\n            }\\n            for(int j = 1; j < s.length(); ++j){\\n                valid[0][j] = false;\\n            }\\n            for(int i = 1; i < p.length(); ++i){\\n                for(int j = 1; j < s.length(); ++j){\\n                    if(p.charAt(i) == '*'){\\n                        valid[i][j] = valid[i-1][j] || valid[i-1][j-1] || valid[i][j-1];\\n                    }else if( p.charAt(i) == '?'){\\n                        valid[i][j] = valid[i-1][j-1];\\n                    }else{\\n                        valid[i][j] = valid[i-1][j-1] && p.charAt(i) == s.charAt(j);\\n                    }\\n                }\\n            }\\n            return valid[p.length()-1][s.length()-1];\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean isMatch(String s, String p) {\\n            //little trick here to avoid checking some corner cases\\n            return _isMatch(\"a\" + s, \"a\" + p);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 17947,
                "title": "c-solution-in-string-parameters",
                "content": "    class Solution {\\n    public:\\n        bool isMatch(string s, string p) {\\n            if(s.compare(p)) return true;\\n            int ssize = (int) s.size();\\n            int psize = (int) p.size();\\n            int i=0,j=0,pi=0,pj=psize;\\n            while(i<ssize){\\n                if(s[i]==p[j]||p[j]=='?'){\\n                    i++;\\n                    j++;\\n                    continue;\\n                }\\n                if(p[j]=='*'){\\n                    pj = j++;\\n                    pi = i;\\n                    continue;\\n                }\\n                if(pj<psize){\\n                    j = pj + 1;\\n                    i = ++pi;\\n                    continue;\\n                }\\n                return false;\\n            }\\n           while(p[j]=='*'){\\n               j++;\\n           }\\n           return j==psize;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isMatch(string s, string p) {\\n            if(s.compare(p)) return true;\\n            int ssize = (int) s.size();\\n            int psize = (int) p.size();\\n            int i=0,j=0,pi=0,pj=psize;\\n            while(i<ssize){\\n                if(s[i]==p[j]||p[j]=='?'){\\n                    i++;\\n                    j++;\\n                    continue;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3613570,
                "title": "c-memization",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,int &a,int &b,string &s,string &p,vector<vector<int>> &dp){\\n        if(i==a && j==b)return 1;\\n        else if(i==a){\\n            while(j<b && p[j]==\\'*\\')j++;\\n            return j==b;\\n        }\\n        else if(i != a && j == b)return 0;\\n        if(dp[i][j] != -1)return dp[i][j];\\n        bool c = false;\\n        while(j<b && p[j]==\\'*\\'){j++;c = true;}\\n        \\n        if(c)j--;\\n        if(p[j]==\\'?\\'){\\n            dp[i][j] = solve(i+1,j+1,a,b,s,p,dp);\\n        }else if(p[j]==\\'*\\'){\\n            dp[i][j] = solve(i+1,j,a,b,s,p,dp)||solve(i,j+1,a,b,s,p,dp);\\n        }else{\\n            if(s[i]==p[j]){\\n                dp[i][j] = solve(i+1,j+1,a,b,s,p,dp);\\n            }else{\\n                dp[i][j] = 0;\\n            }\\n        }\\n        return dp[i][j];\\n    }\\n    bool isMatch(string s, string p) {\\n        int a = s.length(),b= p.length();\\n        vector<vector<int>> dp(a,vector<int>(b,-1));\\n        return solve(0,0,a,b,s,p,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,int &a,int &b,string &s,string &p,vector<vector<int>> &dp){\\n        if(i==a && j==b)return 1;\\n        else if(i==a){\\n            while(j<b && p[j]==\\'*\\')j++;\\n            return j==b;\\n        }\\n        else if(i != a && j == b)return 0;\\n        if(dp[i][j] != -1)return dp[i][j];\\n        bool c = false;\\n        while(j<b && p[j]==\\'*\\'){j++;c = true;}\\n        \\n        if(c)j--;\\n        if(p[j]==\\'?\\'){\\n            dp[i][j] = solve(i+1,j+1,a,b,s,p,dp);\\n        }else if(p[j]==\\'*\\'){\\n            dp[i][j] = solve(i+1,j,a,b,s,p,dp)||solve(i,j+1,a,b,s,p,dp);\\n        }else{\\n            if(s[i]==p[j]){\\n                dp[i][j] = solve(i+1,j+1,a,b,s,p,dp);\\n            }else{\\n                dp[i][j] = 0;\\n            }\\n        }\\n        return dp[i][j];\\n    }\\n    bool isMatch(string s, string p) {\\n        int a = s.length(),b= p.length();\\n        vector<vector<int>> dp(a,vector<int>(b,-1));\\n        return solve(0,0,a,b,s,p,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298717,
                "title": "python-bottom-up-dp-solution",
                "content": "\\n# Code\\n```\\n    def isMatch(self, s: str, p: str) -> bool:\\n        n = len(s);\\n        m = len(p);\\n        dp = [[0]*(m+1) for _ in range(0,n+1)]\\n\\n        dp[0][0] = 1\\n        for j in range(1,m+1):\\n            if(p[j-1] == \\'*\\' ): dp[0][j] = dp[0][j-1];\\n\\n        for i in range(1,n+1):\\n            for j in range(1,m+1):\\n                if(s[i-1] == p[j-1] or p[j-1] == \\'?\\' ): dp[i][j] = dp[i-1][j-1]\\n                elif( p[j-1] == \\'*\\' ):\\n                    # did we match without the chracter in s or did we match with the character before \\'*\\' in p\\n                    dp[i][j] = dp[i-1][j] or dp[i][j-1]\\n\\n        return dp[-1][-1]\\n    \\n               \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n    def isMatch(self, s: str, p: str) -> bool:\\n        n = len(s);\\n        m = len(p);\\n        dp = [[0]*(m+1) for _ in range(0,n+1)]\\n\\n        dp[0][0] = 1\\n        for j in range(1,m+1):\\n            if(p[j-1] == \\'*\\' ): dp[0][j] = dp[0][j-1];\\n\\n        for i in range(1,n+1):\\n            for j in range(1,m+1):\\n                if(s[i-1] == p[j-1] or p[j-1] == \\'?\\' ): dp[i][j] = dp[i-1][j-1]\\n                elif( p[j-1] == \\'*\\' ):\\n                    # did we match without the chracter in s or did we match with the character before \\'*\\' in p\\n                    dp[i][j] = dp[i-1][j] or dp[i][j-1]\\n\\n        return dp[-1][-1]\\n    \\n               \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2704132,
                "title": "memoization-to-tabulation",
                "content": "\\n# **Memoization:-**\\n\\nclass Solution {\\npublic:\\n    \\n    \\n    int helper(int i,int j,string s,string p,vector<vector<int>>& dp){\\n         \\n         if(i==0 && j==0 )    return true;\\n         \\n         if(i==0 || j==0 )    {\\n            \\n            if(i==0 && p[j-1]==\\'*\\') return helper(i,j-1,s,p,dp);  \\n            else                    return false;\\n             \\n         }\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n  \\n        if(p[j-1]==\\'*\\' || p[j-1]==\\'?\\' ){\\n            \\n         if(p[j-1]==\\'?\\') return dp[i][j]=helper(i-1,j-1,s,p,dp);\\n         else            return dp[i][j]=(helper(i-1,j,s,p,dp) || helper(i-1,j-1,s,p,dp) || helper(i,j-1,s,p,dp));\\n            \\n        }\\n        else {\\n            if(s[i-1]==p[j-1]) return dp[i][j]=helper(i-1,j-1,s,p,dp);\\n            else               return false;    \\n        }\\n    }\\n\\t\\n    bool isMatch(string s, string p) {\\n    \\n        int n1=s.size();\\n        int n2=p.size();\\n        \\n        vector<vector<int>> dp(n1+1,vector<int> (n2+1,-1));\\n        return helper(s.size(),p.size(),s,p,dp);\\n    }\\n};\\n\\nSaldy it didn\\'t work so i need to convert it to tabulator form\\n\\n# **Tabulation:-**\\n\\nclass Solution {\\npublic:\\n        \\n    bool isMatch(string s, string p) {\\n    \\n        int n1=s.size();\\n        int n2=p.size();\\n        \\n        vector<vector<bool>> dp(n1+1,vector<bool> (n2+1,false));\\n        \\n        for(int i=0;i<=n1;++i){\\n            \\n            for(int j=0;j<=n2;++j){\\n                \\n                if(i==0 && j==0) dp[i][j]=true;\\n                else if (i==0 || j==0){\\n                    \\n\\t\\t\\t\\t\\t if(i==0 && p[j-1]==\\'*\\') dp[i][j]=dp[i][j-1];  \\n\\t\\t\\t\\t\\t else                    dp[i][j]=false;  \\n\\t\\t\\t\\t\\t \\n                }\\n               else if(p[j-1]==\\'*\\' || p[j-1]==\\'?\\' ){\\n\\t\\t\\t   \\n                 if (p[j-1]==\\'?\\') dp[i][j]=dp[i-1][j-1];\\n                 else             dp[i][j]=dp[i-1][j] + dp[i-1][j-1] + dp[i][j-1];\\n              \\n\\t\\t\\t  }\\n            else{\\n                if(s[i-1]==p[j-1]) dp[i][j]=dp[i-1][j-1];\\n                else               dp[i][j]=false;  \\n              }    \\n           }           \\n        }\\n        return dp[n1][n2];  \\n    }\\n};\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    \\n    int helper(int i,int j,string s,string p,vector<vector<int>>& dp){\\n         \\n         if(i==0 && j==0 )    return true;\\n         \\n         if(i==0 || j==0 )    {\\n            \\n            if(i==0 && p[j-1]==\\'*\\') return helper(i,j-1,s,p,dp);  \\n            else                    return false;\\n             \\n         }",
                "codeTag": "Java"
            },
            {
                "id": 2686738,
                "title": "why-has-leetcode-started-blocking-recursive-approaches",
                "content": "i used a bottom up dp ,\\nwent from calculating from 0 , 0  to n - 1 , m  - 1 \\nbut the solution resulted in TLE ,  i was doubting my time complexity , but the same solution passed in GFG \\nNot sure why leetcode has started blocking recursive solutions",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1992492,
                "title": "greatly-explained-two-methods-dfs-memo-dp-in-python-very-easy-to-understand",
                "content": "**Very classical question** that could be solved using **DFS + Memo** & **DP**!\\n\\n**General View:**\\nThe challenge part is * .\\nIt could match any number of characters.\\nSo how to deal with * is **the key**!\\n\\n**Take an example:**\\nIf we match * with every possible number of characters, then the divisions in each level could be many\\n```\\n\\t\\t  (*ab, abc)\\n\\t  /     |       \\\\     \\\\\\n(ab, abc) (ab, bc) (ab, c) (ab, \\'\\')\\n```\\nIf we give match only two options, not match or match (* will stay for next level), the the divisions in each level is two.\\n```\\n\\t(*ab, abc)\\n\\t  /   \\\\\\n(ab, ab)  (*ab, b)\\t  \\n```\\nIt is obvious that **the latter one is better**! That is how we will deal with * .\\n\\n**Method 1:**\\n**DFS + Memoization**\\n\\nWhenever will come across a * , we will generate two paths, either **not match any** or **match**.\\nHowever, that is not enough, since we might have duplicate states when we have ***continuing*** * .\\n**For example:**\\n```\\n       (**, abc)\\n\\t    /   \\\\\\n\\t(*, abc)  (**, bc)\\n\\t/      \\\\     /   \\\\\\n(\\'\\', abc) (*, bc) (**, c)\\n```\\nThe state (* , bc) will be reached from different paths. Meaning that we could use **memoization**!\\nThe time will be reduced from O(2 ^ n) to O(m * n).\\n\\nWe will use index of the string as the signature of each state. Every state reached will be stored in the memo hash.\\n\\n**Time:** O(m * n), m is the length of string s, n is the length of string p\\n**Space:** O(m * n)\\n\\n```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        memo = {}\\n        s_index, p_index = 0, 0\\n        return self.memo_dfs(s, s_index, p, p_index, memo)\\n    \\n    def memo_dfs(self, s, i, p, j, memo): \\n        \\n        if len(p) == j:\\n            return len(s) == i\\n        \\n        if len(s) == i:\\n            for index in range(j, len(p)):\\n                if p[index] != \\'*\\':\\n                    return False\\n            return True\\n        \\n        if (i, j) in memo:\\n            return memo[(i, j)]\\n\\n        if p[j] != \\'*\\':\\n            matched =  (s[i] == p[j] or p[j] == \\'?\\') and self.memo_dfs(s, i + 1, p, j + 1, memo)\\n        else:  # matched & not matched\\n            matched = self.memo_dfs(s, i + 1, p, j, memo) or self.memo_dfs(s, i, p, j + 1, memo)\\n        \\n        memo[(i, j)] = matched\\n        \\n        return matched\\n```\\n\\n**Method 2:**\\n**DP**\\n\\nThe idea is very similar, **dp[i][j]** means that by index i of s and by index j of p, whether there is a matching.\\n\\n**Time:** O(m * n), m is the length of string s, n is the length of string p\\n**Space:** O(m * n)\\n\\n```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        if s is None or p is None:\\n            return False\\n        \\n        m, n = len(s), len(p)\\n        \\n        dp = [[False] * (n + 1) for _ in range(2)]\\n        \\n        dp[0][0] = True\\n        for i in range(1, n + 1): # the case that p starts with some *\\n            dp[0][i] = dp[0][i - 1] and p[i - 1] == \\'*\\'\\n        \\n        for i in range(1, m + 1):\\n            dp[i % 2][0] = False # Note that: we might miss this!\\n            for j in range(1, n + 1):\\n                if p[j - 1] == \\'*\\': # match & no match \\n                    dp[i % 2][j] = dp[(i - 1) % 2][j] or dp[i % 2][j - 1]\\n                else:\\n                    dp[i % 2][j] = dp[(i - 1) % 2][j - 1] and (\\n                        s[i - 1] == p[j - 1] or p[j - 1] == \\'?\\')\\n        \\n        return dp[m % 2][n]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\n\\t\\t  (*ab, abc)\\n\\t  /     |       \\\\     \\\\\\n(ab, abc) (ab, bc) (ab, c) (ab, \\'\\')\\n```\n```\\n\\t(*ab, abc)\\n\\t  /   \\\\\\n(ab, ab)  (*ab, b)\\t  \\n```\n```\\n       (**, abc)\\n\\t    /   \\\\\\n\\t(*, abc)  (**, bc)\\n\\t/      \\\\     /   \\\\\\n(\\'\\', abc) (*, bc) (**, c)\\n```\n```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        memo = {}\\n        s_index, p_index = 0, 0\\n        return self.memo_dfs(s, s_index, p, p_index, memo)\\n    \\n    def memo_dfs(self, s, i, p, j, memo): \\n        \\n        if len(p) == j:\\n            return len(s) == i\\n        \\n        if len(s) == i:\\n            for index in range(j, len(p)):\\n                if p[index] != \\'*\\':\\n                    return False\\n            return True\\n        \\n        if (i, j) in memo:\\n            return memo[(i, j)]\\n\\n        if p[j] != \\'*\\':\\n            matched =  (s[i] == p[j] or p[j] == \\'?\\') and self.memo_dfs(s, i + 1, p, j + 1, memo)\\n        else:  # matched & not matched\\n            matched = self.memo_dfs(s, i + 1, p, j, memo) or self.memo_dfs(s, i, p, j + 1, memo)\\n        \\n        memo[(i, j)] = matched\\n        \\n        return matched\\n```\n```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        if s is None or p is None:\\n            return False\\n        \\n        m, n = len(s), len(p)\\n        \\n        dp = [[False] * (n + 1) for _ in range(2)]\\n        \\n        dp[0][0] = True\\n        for i in range(1, n + 1): # the case that p starts with some *\\n            dp[0][i] = dp[0][i - 1] and p[i - 1] == \\'*\\'\\n        \\n        for i in range(1, m + 1):\\n            dp[i % 2][0] = False # Note that: we might miss this!\\n            for j in range(1, n + 1):\\n                if p[j - 1] == \\'*\\': # match & no match \\n                    dp[i % 2][j] = dp[(i - 1) % 2][j] or dp[i % 2][j - 1]\\n                else:\\n                    dp[i % 2][j] = dp[(i - 1) % 2][j - 1] and (\\n                        s[i - 1] == p[j - 1] or p[j - 1] == \\'?\\')\\n        \\n        return dp[m % 2][n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1434132,
                "title": "python3-top-down-bottom-up-dp-solutions",
                "content": "**Time Complexity:** O(m*n)\\n**Space Complexity:** O(m*n)\\n\\n**Some tips I use to become better at Top-down DP (feel free to give suggestions):**\\n1. When thinking in top-down DP manner, always begin with termination conditions. (What happens when i reaches the end or when j reaches the end?)\\n2. What happens when we encounter a special condition? (e.g. What happens when p[j-1] == \\'*\\'?)\\n3. In a top-down manner, since the **final** result will only be available when we hit the termination condition, when we increment i or j, it means that we can \\'omit\\' either one or both of them. For instance, when p[j] and s[i] matches or when p[j] equals to the \"match everything\" special character, we can increment both i and j (by \\'omitting\\' them and only consider characters after i and after j)\\n4. Always think recursively. Memoization can be as simple as one line (which can be achieved by the cache decorator in Python)\\n5. Practice and practice. Good luck!\\n\\n**Steps I follow when I do bottom-up DP (suggestions are welcome):**\\n1. Start with base condition (e.g. What if both strings are empty? i.e. dp[0][0] = True. What if one string is empty and another is not? Pre-populate those values)\\n2. When we say dp[i][j] = dp[i-1][j-1], it means we can \\'increment\\' i and j, similar to top-down manner. This is because we can omit calculation for current string and simply \"bridge the cap\" with the previous results. (Not sure if this makes sense)\\n\\nHope this helps. When I first started, I remember I was really bad at DP. But as I practice more I\\'m getting better every day. Never give up -- I\\'m sure you will get there soon.\\n\\n**Solution 1: Top-down DP (memoization)**\\n```python\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n\\t\\t@cache\\n\\t\\tdef dp(i, j):\\n\\t\\t\\tif j >= len(p):\\n\\t\\t\\t\\treturn i == len(s)\\n\\t\\t\\t# When s reaches the end, p must be empty or contains only * (since * can also be used to represent empty string)\\n\\t\\t\\tif i >= len(s):\\n\\t\\t\\t\\treturn not p[j:] or p[j:] == \\'*\\'*len(p[j:])\\n\\t\\t\\t# Since \\'*\\' can be used to represent any sequence of characters including empty string, we can either increment i or j.\\n\\t\\t\\tif p[j] == \\'*\\':\\n\\t\\t\\t\\treturn dp(i+1, j) or dp(i, j+1)\\n\\t\\t\\tif p[j] in {s[i], \\'?\\'}:\\n\\t\\t\\t\\treturn dp(i+1, j+1)\\n\\t\\t\\treturn False\\n\\t\\treturn dp(0, 0)\\n```\\n\\n**Solution 2: Bottom up DP**\\n```python\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        m, n = len(s), len(p)\\n        dp = [[False]*(n+1) for _ in range(m+1)]\\n        # When s and p are both empty, they must match.\\n        dp[0][0] = True\\n        \\n        for j in range(1, n+1):\\n            if p[j-1] != \\'*\\':\\n                break\\n            dp[0][j] = True\\n        \\n        for i in range(1, m+1):\\n            for j in range(1, n+1):\\n                if p[j-1] in {s[i-1], \\'?\\'}:\\n                    dp[i][j] = dp[i-1][j-1]\\n                elif p[j-1] == \\'*\\':\\n                    dp[i][j] = dp[i-1][j] or dp[i][j-1]\\n        return dp[-1][-1]\\n```\\n\\nEdit: \\n**Solution 1 (no slicing)**\\n```python\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        @cache\\n        def dp(i, j):\\n            if j >= len(p):\\n                return i == len(s)\\n            if i < len(s) and p[j] in {s[i], \\'?\\'}:\\n                return dp(i+1, j+1)\\n            if p[j] == \\'*\\':\\n                if i < len(s):\\n                    return dp(i+1, j) or dp(i, j+1)\\n                return dp(i, j+1)\\n        return dp(0, 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n\\t\\t@cache\\n\\t\\tdef dp(i, j):\\n\\t\\t\\tif j >= len(p):\\n\\t\\t\\t\\treturn i == len(s)\\n\\t\\t\\t# When s reaches the end, p must be empty or contains only * (since * can also be used to represent empty string)\\n\\t\\t\\tif i >= len(s):\\n\\t\\t\\t\\treturn not p[j:] or p[j:] == \\'*\\'*len(p[j:])\\n\\t\\t\\t# Since \\'*\\' can be used to represent any sequence of characters including empty string, we can either increment i or j.\\n\\t\\t\\tif p[j] == \\'*\\':\\n\\t\\t\\t\\treturn dp(i+1, j) or dp(i, j+1)\\n\\t\\t\\tif p[j] in {s[i], \\'?\\'}:\\n\\t\\t\\t\\treturn dp(i+1, j+1)\\n\\t\\t\\treturn False\\n\\t\\treturn dp(0, 0)\\n```\n```python\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        m, n = len(s), len(p)\\n        dp = [[False]*(n+1) for _ in range(m+1)]\\n        # When s and p are both empty, they must match.\\n        dp[0][0] = True\\n        \\n        for j in range(1, n+1):\\n            if p[j-1] != \\'*\\':\\n                break\\n            dp[0][j] = True\\n        \\n        for i in range(1, m+1):\\n            for j in range(1, n+1):\\n                if p[j-1] in {s[i-1], \\'?\\'}:\\n                    dp[i][j] = dp[i-1][j-1]\\n                elif p[j-1] == \\'*\\':\\n                    dp[i][j] = dp[i-1][j] or dp[i][j-1]\\n        return dp[-1][-1]\\n```\n```python\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        @cache\\n        def dp(i, j):\\n            if j >= len(p):\\n                return i == len(s)\\n            if i < len(s) and p[j] in {s[i], \\'?\\'}:\\n                return dp(i+1, j+1)\\n            if p[j] == \\'*\\':\\n                if i < len(s):\\n                    return dp(i+1, j) or dp(i, j+1)\\n                return dp(i, j+1)\\n        return dp(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1321336,
                "title": "recursion-memorization-explanation-with-comments-in-code-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    /*\\n        dp[i][j]==(-1) means dp[i][j] not calculated yet\\n        dp[i][j]==  1 means answer is true\\n        dp[i][j]==  0 means answer is false\\n    */\\n    \\n    bool search(string &s,string &pattern,int i,int j,vector<vector<int>>&dp){\\n        // i correspond to index in s\\n        //and j correspond to index in pattern\\n\\n        if(i==s.size()&&j==pattern.size()){// both substrings are empty\\n            return true;\\n        }\\n        \\n        //We have reched at last character of pattern and it is *, then answer is true\\n        if(j==pattern.size()-1&&pattern[j]==\\'*\\'){\\n            return true;\\n        }\\n\\n        //Either of them is empty but not both,then pattern can\\'t be matched\\n        if(i==s.size()||j==pattern.size()){\\n            return false;\\n        }\\n        \\n        //Already calculated,then return value directly\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        \\n        /*\\n         current character in pattern is lowercase letter,\\n        then if both characters are matching then make function call with both indices incremented, otherwise if they are not matching return false\\n        \\n        if current character in pattern is \\'?\\', then make function call with both indices incremented\\n        \\n        otherwise current character is *. In that case, * can replace subsequence of any  length in original string.\\n        Therefore check for all possibilities of * \\n        \\n        */\\n        \\n        if(pattern[j]!=\\'*\\'&&pattern[j]!=\\'?\\'){\\n            if(pattern[j]!=s[i]){\\n                return false;\\n            }\\n            return dp[i][j]=search(s,pattern,i+1,j+1,dp);\\n        }else if(pattern[j]==\\'?\\'){\\n            return dp[i][j]=search(s,pattern,i+1,j+1,dp);\\n        }else{\\n            bool ans=false;\\n            for(int k=i;k<=s.size();k++){\\n                ans=search(s,pattern,k,j+1,dp);\\n                if(ans){\\n                    break;\\n                }\\n            }\\n            return dp[i][j]=ans;\\n        }\\n    }\\n    \\n    bool isMatch(string s, string p) {\\n        string pattern;\\n        // consecutive sequence of * can be replaced with single *\\n        // Thereofre pattern will not have any consecutive *\\n        for(int i=0;i<p.size();i++){\\n            if(pattern.back()==\\'*\\'&&p[i]==\\'*\\'){\\n                continue;\\n            }\\n            pattern.push_back(p[i]);\\n        }\\n        vector<vector<int>>dp(s.size()+1,vector<int>(pattern.size()+1,-1));\\n        return search(s,pattern,0,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /*\\n        dp[i][j]==(-1) means dp[i][j] not calculated yet\\n        dp[i][j]==  1 means answer is true\\n        dp[i][j]==  0 means answer is false\\n    */\\n    \\n    bool search(string &s,string &pattern,int i,int j,vector<vector<int>>&dp){\\n        // i correspond to index in s\\n        //and j correspond to index in pattern\\n\\n        if(i==s.size()&&j==pattern.size()){// both substrings are empty\\n            return true;\\n        }\\n        \\n        //We have reched at last character of pattern and it is *, then answer is true\\n        if(j==pattern.size()-1&&pattern[j]==\\'*\\'){\\n            return true;\\n        }\\n\\n        //Either of them is empty but not both,then pattern can\\'t be matched\\n        if(i==s.size()||j==pattern.size()){\\n            return false;\\n        }\\n        \\n        //Already calculated,then return value directly\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        \\n        /*\\n         current character in pattern is lowercase letter,\\n        then if both characters are matching then make function call with both indices incremented, otherwise if they are not matching return false\\n        \\n        if current character in pattern is \\'?\\', then make function call with both indices incremented\\n        \\n        otherwise current character is *. In that case, * can replace subsequence of any  length in original string.\\n        Therefore check for all possibilities of * \\n        \\n        */\\n        \\n        if(pattern[j]!=\\'*\\'&&pattern[j]!=\\'?\\'){\\n            if(pattern[j]!=s[i]){\\n                return false;\\n            }\\n            return dp[i][j]=search(s,pattern,i+1,j+1,dp);\\n        }else if(pattern[j]==\\'?\\'){\\n            return dp[i][j]=search(s,pattern,i+1,j+1,dp);\\n        }else{\\n            bool ans=false;\\n            for(int k=i;k<=s.size();k++){\\n                ans=search(s,pattern,k,j+1,dp);\\n                if(ans){\\n                    break;\\n                }\\n            }\\n            return dp[i][j]=ans;\\n        }\\n    }\\n    \\n    bool isMatch(string s, string p) {\\n        string pattern;\\n        // consecutive sequence of * can be replaced with single *\\n        // Thereofre pattern will not have any consecutive *\\n        for(int i=0;i<p.size();i++){\\n            if(pattern.back()==\\'*\\'&&p[i]==\\'*\\'){\\n                continue;\\n            }\\n            pattern.push_back(p[i]);\\n        }\\n        vector<vector<int>>dp(s.size()+1,vector<int>(pattern.size()+1,-1));\\n        return search(s,pattern,0,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1165389,
                "title": "python3-with-explanation",
                "content": "```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        sPos, pPos = 0, 0\\n        starPos, wildPos = -1, -1\\n        while (sPos < len(s)):\\n            if pPos < len(p) and p[pPos] in (\\'?\\', s[sPos]): #match one char in p\\n                pPos += 1\\n                sPos += 1\\n            elif pPos < len(p) and p[pPos] == \\'*\\': #match * begin\\n                starPos, wildPos = pPos, sPos # record the start position and the wildcard beginning position\\n                pPos += 1\\n            else:\\n                # not match, backtrack use *\\n                if (starPos < 0): return False\\n                pPos = starPos + 1 # p position reset to the next one after recorded star\\n                sPos = wildPos + 1 # s position set to next one from the wildcard pos\\n                wildPos += 1 # use the * to match one more\\n            \\n        \\n        while pPos < len(p) and p[pPos] == \\'*\\':\\n               pPos += 1 # skip the remaining * in p\\n        return pPos == len(p)\\n    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        sPos, pPos = 0, 0\\n        starPos, wildPos = -1, -1\\n        while (sPos < len(s)):\\n            if pPos < len(p) and p[pPos] in (\\'?\\', s[sPos]): #match one char in p\\n                pPos += 1\\n                sPos += 1\\n            elif pPos < len(p) and p[pPos] == \\'*\\': #match * begin\\n                starPos, wildPos = pPos, sPos # record the start position and the wildcard beginning position\\n                pPos += 1\\n            else:\\n                # not match, backtrack use *\\n                if (starPos < 0): return False\\n                pPos = starPos + 1 # p position reset to the next one after recorded star\\n                sPos = wildPos + 1 # s position set to next one from the wildcard pos\\n                wildPos += 1 # use the * to match one more\\n            \\n        \\n        while pPos < len(p) and p[pPos] == \\'*\\':\\n               pPos += 1 # skip the remaining * in p\\n        return pPos == len(p)\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 957748,
                "title": "python-non-deterministic-finite-automaton-nfa",
                "content": "```\\nimport collections\\n\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        if not p: return False if s else True\\n        \\n        delta = collections.defaultdict(int)\\n        delta[(0, \\'*\\')] = 0\\n        state = 1\\n        for c in p:\\n            if c == \\'*\\':\\n                delta[(state, \\'*\\')] = state\\n                continue\\n                \\n            delta[(state, c)] = state + 1\\n            state += 1\\n        \\n        accept_state = state\\n        cur_states = set([1])\\n        i = 0\\n        while i < len(s):\\n            next_states = set()\\n            cur_char = s[i]\\n            for cur_state in cur_states:\\n                if (cur_state, \\'*\\') in delta:\\n                    next_states.add(delta[(cur_state, \\'*\\')])\\n                    \\n                if (cur_state, \\'?\\') in delta:\\n                    next_states.add(delta[(cur_state, \\'?\\')])\\n                else:\\n                    next_states.add(delta[(cur_state, cur_char)])\\n            \\n            cur_states = next_states\\n            i += 1\\n        \\n        return accept_state in cur_states and i == len(s) \\n```\\n\\nIf you have taken a class on finite automata then this solution should be really simple to understand, otherwise it might feel cryptic. Hopfully this provides a different perspective than other solutions.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport collections\\n\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        if not p: return False if s else True\\n        \\n        delta = collections.defaultdict(int)\\n        delta[(0, \\'*\\')] = 0\\n        state = 1\\n        for c in p:\\n            if c == \\'*\\':\\n                delta[(state, \\'*\\')] = state\\n                continue\\n                \\n            delta[(state, c)] = state + 1\\n            state += 1\\n        \\n        accept_state = state\\n        cur_states = set([1])\\n        i = 0\\n        while i < len(s):\\n            next_states = set()\\n            cur_char = s[i]\\n            for cur_state in cur_states:\\n                if (cur_state, \\'*\\') in delta:\\n                    next_states.add(delta[(cur_state, \\'*\\')])\\n                    \\n                if (cur_state, \\'?\\') in delta:\\n                    next_states.add(delta[(cur_state, \\'?\\')])\\n                else:\\n                    next_states.add(delta[(cur_state, cur_char)])\\n            \\n            cur_states = next_states\\n            i += 1\\n        \\n        return accept_state in cur_states and i == len(s) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 644094,
                "title": "java-fast-memoization-dp-with-comments",
                "content": "```\\nclass Solution {\\n    \\n    int[][] memo; // 0 indicates haven\\'t found, -1 is not possible, 1 is possible!\\n    \\n    public boolean isMatch(String s, String p) {\\n        memo = new int[s.length() + 1][p.length() + 1];\\n        return dfs(s, p, 0, 0);\\n    }\\n    \\n    public boolean dfs(String s, String p, int p1, int p2) {\\n        \\n        // let\\'s check if \\n        if (p1 == s.length()) {\\n            \\n            // keep advancing the star characters!\\n            while (p2 < p.length() && p.charAt(p2) == \\'*\\')\\n                p2++;\\n            \\n            // did we get to the end?\\n            if (p2 == p.length()) {\\n                memo[p1][p2] = 1;\\n                return true;\\n            }\\n            \\n            memo[p1][p2] = -1;\\n            return false;\\n        // still have characters left!\\n        } else if (p2 == p.length()) {\\n            memo[p1][p2] = -1;\\n            return false;\\n        }\\n        \\n        if (memo[p1][p2] == -1)\\n            return false;\\n        \\n        if (memo[p1][p2] == 1)\\n            return true;\\n        \\n        boolean possible = false;\\n        \\n        if (p.charAt(p2) == \\'?\\')\\n            possible = dfs(s, p, p1 + 1, p2 + 1);\\n        else if (p.charAt(p2) == \\'*\\') {\\n            // useless starting * (match zero), matches more than one character character, matches this exact character\\n            possible = dfs(s, p, p1, p2 + 1) || dfs(s, p, p1 + 1, p2) || dfs(s, p, p1 + 1, p2 + 1);\\n        }     \\n        else\\n            if (s.charAt(p1) == p.charAt(p2))\\n                possible = dfs(s, p, p1 + 1, p2 + 1);\\n        \\n        memo[p1][p2] = possible ? 1 : -1;\\n        return possible;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\n    \\n    int[][] memo; // 0 indicates haven\\'t found, -1 is not possible, 1 is possible!\\n    \\n    public boolean isMatch(String s, String p) {\\n        memo = new int[s.length() + 1][p.length() + 1];\\n        return dfs(s, p, 0, 0);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 487431,
                "title": "python-dp-top-down-similar-to-regex-matching",
                "content": "```\\ndef isMatch(self, s: str, p: str) -> bool:\\n    dp = [[False for i in range(len(p)+1)] for j in range(len(s)+1)]\\n    dp[0][0]= True\\n    for i in range(1,len(p)+1):\\n        if p[i-1]==\\'*\\':\\n            dp[0][i] = dp[0][i-1]\\n    for i in range(1, len(s)+1):\\n        for j in range(1, len(p)+1):\\n            if s[i-1]==p[j-1] or p[j-1]==\\'?\\':\\n                dp[i][j] = dp[i-1][j-1]\\n            elif p[j-1]==\\'*\\':\\n                dp[i][j] = dp[i-1][j] | dp[i][j-1]\\n    \\n    return dp[-1][-1]\\n```",
                "solutionTags": [],
                "code": "```\\ndef isMatch(self, s: str, p: str) -> bool:\\n    dp = [[False for i in range(len(p)+1)] for j in range(len(s)+1)]\\n    dp[0][0]= True\\n    for i in range(1,len(p)+1):\\n        if p[i-1]==\\'*\\':\\n            dp[0][i] = dp[0][i-1]\\n    for i in range(1, len(s)+1):\\n        for j in range(1, len(p)+1):\\n            if s[i-1]==p[j-1] or p[j-1]==\\'?\\':\\n                dp[i][j] = dp[i-1][j-1]\\n            elif p[j-1]==\\'*\\':\\n                dp[i][j] = dp[i-1][j] | dp[i][j-1]\\n    \\n    return dp[-1][-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 443606,
                "title": "easy-java-dp",
                "content": "&nbsp; | \\'\\' | * | a | * |b\\n:-: | :-: | :-: | :-: | :-: | :-:\\n\\'\\' | T | T | F | F | F \\na | F | T | T | T | F\\nd | F | T | F | T | F\\nc | F | T | F | T | F\\ne | F | T | F | T | F\\nb | F | T | F | T | T\\n\\n``` java\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        boolean[][] dp = new boolean[s.length() + 1][p.length() + 1];\\n        dp[0][0] = true;\\n        for (int i = 0; i < p.length(); i++) {\\n            if(p.charAt(i) == \\'*\\' && dp[0][i]){\\n                dp[0][i+1] = true;\\n            }\\n        }\\n        for (int i = 0; i < s.length(); i++) {\\n            for (int j = 0; j < p.length(); j++) {\\n                if(s.charAt(i) == p.charAt(j) || p.charAt(j) == \\'?\\'){\\n                    dp[i+1][j+1] = dp[i][j];\\n                }\\n                if(p.charAt(j) == \\'*\\'){\\n                    dp[i + 1][j + 1] = dp[i][j + 1] || dp[i + 1][j];\\n                }\\n            }\\n        }\\n        return dp[s.length()][p.length()];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "``` java\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        boolean[][] dp = new boolean[s.length() + 1][p.length() + 1];\\n        dp[0][0] = true;\\n        for (int i = 0; i < p.length(); i++) {\\n            if(p.charAt(i) == \\'*\\' && dp[0][i]){\\n                dp[0][i+1] = true;\\n            }\\n        }\\n        for (int i = 0; i < s.length(); i++) {\\n            for (int j = 0; j < p.length(); j++) {\\n                if(s.charAt(i) == p.charAt(j) || p.charAt(j) == \\'?\\'){\\n                    dp[i+1][j+1] = dp[i][j];\\n                }\\n                if(p.charAt(j) == \\'*\\'){\\n                    dp[i + 1][j + 1] = dp[i][j + 1] || dp[i + 1][j];\\n                }\\n            }\\n        }\\n        return dp[s.length()][p.length()];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 428646,
                "title": "javascript-levenshtein-recursion-solution",
                "content": "#### The Idea - Levenshtein Distance Algorithm (Edit Distance)\\n1. Apply lavenshtein distance algorithm. More [here](https://leetcode.com/problems/edit-distance/discuss/428527/JavaScript-Solution).\\n2. Build a matrix where each cell represents whether the string and input are matching, up to the current position\\n3. For every cell, it\\'s trying to be the best matching possible, meaning it\\'s trying to hit a `true`, we have 3 conditions, if the patten is `*`, then we can either look up or left, if the two characters are the same or patten is `?`, then we inherit the result from previous `dp[i-1][j-1]`, other wise, it is a `false`.\\n```\\nvar isMatch = function(s, p) {\\n    let dp = Array(s.length+1).fill(null).map(()=>Array(p.length+1).fill(false));\\n    dp[0][0] = true;\\n\\n    // initialize first column (string)\\n    for (let i=1;i<=s.length;i++) {\\n        dp[i][0] = false;\\n    }\\n\\n    // initialize first row (pattern) \\n    for (let i=1;i<=p.length;i++) {\\n        dp[0][i] = dp[0][i-1] && p[i-1] == \"*\";\\n    }\\n    \\n    for (let i=1;i<=s.length;i++) {\\n        for (let j=1;j<=p.length;j++) {\\n            if (p[j-1]==\\'*\\') {\\n                dp[i][j] = dp[i-1][j] || dp[i][j-1]; // look top or left\\n            } else if (s[i-1] == p[j-1] || p[j-1]==\\'?\\') {\\n                dp[i][j] = dp[i-1][j-1]; // inherit from previous result\\n            }\\n        }\\n    }\\n    return dp[s.length][p.length]\\n}\\n```\\n\\n#### The Idea - Recursion\\n1. If two strings are equal (`s==p`), or only `*` left in pattern, it\\'s `true`\\n2. If only one of the string is empty, it\\'s `false`\\n3. If two characters are the same (`p[0]==s[0]`) or pattern is `?`, recursivly check the rest\\n4. if see a `*`, we can remove 1 character or we can remove 0 character and move to the next pattern.\\n``` javascript\\nvar isMatchRecursion = function(s, p) {\\n    let dp = {};\\n\\n    var recur = function(s, p) {\\n        if (!dp[s]) dp[s] = {};\\n        if (dp[s][p]!=null) return dp[s][p];\\n\\n        if ( s == p || (p.includes(\\'*\\') && !p.replace(/\\\\*/g, \\'\\'))) {\\n            dp[s][p] = true;\\n        } else if (s.length == 0 || p.length == 0) {\\n            dp[s][p] = false;\\n        } else if (p[0] == \\'?\\' || p[0] == s[0]) {\\n            dp[s][p] = recur(s.slice(1), p.slice(1));\\n        } else if (p[0] == \\'*\\') {\\n            dp[s][p] = recur(s.slice(1), p) || recur(s, p.slice(1));\\n        } else {\\n            dp[s][p] = false;\\n        }\\n\\n        return dp[s][p];\\n    }\\n\\n    return recur(s, p);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isMatch = function(s, p) {\\n    let dp = Array(s.length+1).fill(null).map(()=>Array(p.length+1).fill(false));\\n    dp[0][0] = true;\\n\\n    // initialize first column (string)\\n    for (let i=1;i<=s.length;i++) {\\n        dp[i][0] = false;\\n    }\\n\\n    // initialize first row (pattern) \\n    for (let i=1;i<=p.length;i++) {\\n        dp[0][i] = dp[0][i-1] && p[i-1] == \"*\";\\n    }\\n    \\n    for (let i=1;i<=s.length;i++) {\\n        for (let j=1;j<=p.length;j++) {\\n            if (p[j-1]==\\'*\\') {\\n                dp[i][j] = dp[i-1][j] || dp[i][j-1]; // look top or left\\n            } else if (s[i-1] == p[j-1] || p[j-1]==\\'?\\') {\\n                dp[i][j] = dp[i-1][j-1]; // inherit from previous result\\n            }\\n        }\\n    }\\n    return dp[s.length][p.length]\\n}\\n```\n``` javascript\\nvar isMatchRecursion = function(s, p) {\\n    let dp = {};\\n\\n    var recur = function(s, p) {\\n        if (!dp[s]) dp[s] = {};\\n        if (dp[s][p]!=null) return dp[s][p];\\n\\n        if ( s == p || (p.includes(\\'*\\') && !p.replace(/\\\\*/g, \\'\\'))) {\\n            dp[s][p] = true;\\n        } else if (s.length == 0 || p.length == 0) {\\n            dp[s][p] = false;\\n        } else if (p[0] == \\'?\\' || p[0] == s[0]) {\\n            dp[s][p] = recur(s.slice(1), p.slice(1));\\n        } else if (p[0] == \\'*\\') {\\n            dp[s][p] = recur(s.slice(1), p) || recur(s, p.slice(1));\\n        } else {\\n            dp[s][p] = false;\\n        }\\n\\n        return dp[s][p];\\n    }\\n\\n    return recur(s, p);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 396742,
                "title": "java-recursion-and-dp",
                "content": "Fristly, the recursive solution is pretty easy: \\n```\\nclass Solution \\n{\\n    public boolean isMatch(String s, String p) \\n    {\\n        return match(s, 0, p, 0);\\n    }\\n    \\n    boolean match(String s, int i, String p, int j)\\n    {\\n        if (i == s.length() && j == p.length()) return true;\\n        if (j == p.length()) return false;\\n        if (i == s.length())\\n        {\\n            // the remaining in p are *\\n            for (int k = j; k < p.length(); ++k) if (p.charAt(k) != \\'*\\') return false;\\n            return true;\\n        }\\n        \\n        if (p.charAt(j) == \\'*\\')\\n        {\\n            // the * could match 0+ chars in s\\n            return match(s, i + 1, p, j) || match(s, i, p, j + 1);\\n        }\\n        else\\n        {\\n            if (p.charAt(j) == \\'?\\' || s.charAt(i) == p.charAt(j))\\n            {\\n                return match(s, i + 1, p, j + 1);\\n            }\\n            return false;\\n        }\\n    }\\n}\\n```\\n\\nAfter that, rewrite it to DP:\\n```\\nclass Solution \\n{\\n    public boolean isMatch(String s, String p) \\n    {   \\n        // init base cases\\n        int m = s.length(), n = p.length();\\n        boolean[][] f = new boolean[m + 1][n + 1];\\n        f[m][n] = true;\\n        for (int j = n - 1; j >= 0; --j) if (p.charAt(j) == \\'*\\') f[m][j] = true; else break;\\n        \\n        // DP\\n        for (int i = m - 1; i >= 0; --i)\\n        {\\n            for (int j = n - 1; j >= 0; --j)\\n            {\\n                if (p.charAt(j) == \\'*\\') f[i][j] = f[i][j + 1] || f[i + 1][j];\\n                else if (p.charAt(j) == \\'?\\' || s.charAt(i) == p.charAt(j)) f[i][j] = f[i + 1][j + 1];\\n            }\\n        }\\n        \\n        return f[0][0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public boolean isMatch(String s, String p) \\n    {\\n        return match(s, 0, p, 0);\\n    }\\n    \\n    boolean match(String s, int i, String p, int j)\\n    {\\n        if (i == s.length() && j == p.length()) return true;\\n        if (j == p.length()) return false;\\n        if (i == s.length())\\n        {\\n            // the remaining in p are *\\n            for (int k = j; k < p.length(); ++k) if (p.charAt(k) != \\'*\\') return false;\\n            return true;\\n        }\\n        \\n        if (p.charAt(j) == \\'*\\')\\n        {\\n            // the * could match 0+ chars in s\\n            return match(s, i + 1, p, j) || match(s, i, p, j + 1);\\n        }\\n        else\\n        {\\n            if (p.charAt(j) == \\'?\\' || s.charAt(i) == p.charAt(j))\\n            {\\n                return match(s, i + 1, p, j + 1);\\n            }\\n            return false;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution \\n{\\n    public boolean isMatch(String s, String p) \\n    {   \\n        // init base cases\\n        int m = s.length(), n = p.length();\\n        boolean[][] f = new boolean[m + 1][n + 1];\\n        f[m][n] = true;\\n        for (int j = n - 1; j >= 0; --j) if (p.charAt(j) == \\'*\\') f[m][j] = true; else break;\\n        \\n        // DP\\n        for (int i = m - 1; i >= 0; --i)\\n        {\\n            for (int j = n - 1; j >= 0; --j)\\n            {\\n                if (p.charAt(j) == \\'*\\') f[i][j] = f[i][j + 1] || f[i + 1][j];\\n                else if (p.charAt(j) == \\'?\\' || s.charAt(i) == p.charAt(j)) f[i][j] = f[i + 1][j + 1];\\n            }\\n        }\\n        \\n        return f[0][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 348362,
                "title": "c-4ms-98-solution-w-explanation",
                "content": "This is basically an optimized DFS approach, that aims to greedily minimize the amount of characters that each ```*``` matches. The overall run-time is ```O(p*s)```, which is same as the DP approach, but it is much faster.\\n\\n**What makes this approach different from normal DFS**\\n\\nThe main difference is that we are _greedily cutting branches that would normally be explored in DFS_. In a normal DFS approach, we would try out different numbers of characters to skip in ```*```. In this approach, for any string in the form ```s1*s2*s3```, we would look for the _least number of characters to put in the first ```*``` such that we can match ```s1*s2```_. And that is the end for the first ```*```. The position for the first ```*``` is now set in stone. We proceed to look for the least number of characters in the second ```*``` such that we can match ```s1*s2*s3```, etc.\\n\\nIllustration:\\n\\nSay we have ```p = aba*ab```, s = ```abaababaab```\\n\\nWe first match ```aba```. Thus, we have remaining:\\n\\n```p = _*ab```\\n```s = _abaabaab```\\n\\nWe try to match 0 characters to ```*```. We end up with:\\n\\n```p  = _ab```\\n```s = _abaabaab```\\n\\nWe match ```ab```. This doesn\\'t work, since we need to match the whole string. This implies that we need ```*``` to take more characters.\\nEventually, we get ```ab``` to match the last two characters in ```s```, and we complete the match.\\n\\n**Why this optimization works (how do we know we will get a match if a match exists)**\\n\\nAssume we have string ```s = s1*s2*s3```, and it matches some pattern. Let\\'s say the first index of the matching position of ```s3``` is ```j```, and the last index of the _latest_ matching position of ```s2``` is ```i```. Because ```s2``` is before ```s1```, and ```*``` between them implies there are 0 or more characters between them, we can see that ```i < j```. Assume there is an earlier match of ```s2```, ending at index ```k```. It is easy to see here that ```k < i < j```, which directly implies ```k < j```. Thus, by _greedily_ looking for the minimum number of characters to fit into ```*``` to get a match, we will get a solution if there is _any_ other combinations in which we put more characters to into ```*``` that also results in a match.\\n\\nThus, for every string ```s = s1*s2*s3...*sn(*)```, we get ```s1```, minimize the number of characters for ```*s2```, and then ```*s3```, ... until the last ```*```. At this point, we  simply need to check if ```sn``` matches the end of the pattern, or we have ```*``` at the end, and we can get any match and put the rest in ```*```.\\n\\n**Potential Improvement**\\n\\nThis solution is simple, but it may actually be possible to improve the run-time to ```O(s+p)``` by applying KMP to match ```s1*s2*s3...*sn-1```.\\nOnce we are at ```*sn(*)```, we can either return true if there is any match if there is ```*``` at the end, or simply match ```sn``` to the same size segment at end of ```s``` if there is no ```*``` at the end.\\n\\n\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n     bool isMatch(const string &s, const string &p) {\\n        int sizeS = s.size(), sizeP = p.size(), lps = -1, lss = -1, i = 0, j = 0;\\n        while(j < sizeS) {\\n            if(i < sizeP && p[i] == \\'*\\') {\\n                lps = ++i;\\n                lss = j;\\n            }\\n            else if(i < sizeP && p[i] == s[j] || p[i] == \\'?\\') {++i; ++j;}\\n            else {\\n                if(lps == -1) return false;\\n                j = ++lss;\\n                i = lps;\\n            }\\n        }\\n        while(p[i] == \\'*\\') ++i;\\n        return i == sizeP;\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "solutionTags": [],
                "code": "```*```\n```O(p*s)```\n```*```\n```s1*s2*s3```\n```*```\n```s1*s2```\n```*```\n```*```\n```*```\n```s1*s2*s3```\n```p = aba*ab```\n```abaababaab```\n```aba```\n```p = _*ab```\n```s = _abaabaab```\n```*```\n```p  = _ab```\n```s = _abaabaab```\n```ab```\n```*```\n```ab```\n```s```\n```s = s1*s2*s3```\n```s3```\n```j```\n```s2```\n```i```\n```s2```\n```s1```\n```*```\n```i < j```\n```s2```\n```k```\n```k < i < j```\n```k < j```\n```*```\n```*```\n```s = s1*s2*s3...*sn(*)```\n```s1```\n```*s2```\n```*s3```\n```*```\n```sn```\n```*```\n```*```\n```O(s+p)```\n```s1*s2*s3...*sn-1```\n```*sn(*)```\n```*```\n```sn```\n```s```\n```*```\n```\\nclass Solution {\\npublic:\\n     bool isMatch(const string &s, const string &p) {\\n        int sizeS = s.size(), sizeP = p.size(), lps = -1, lss = -1, i = 0, j = 0;\\n        while(j < sizeS) {\\n            if(i < sizeP && p[i] == \\'*\\') {\\n                lps = ++i;\\n                lss = j;\\n            }\\n            else if(i < sizeP && p[i] == s[j] || p[i] == \\'?\\') {++i; ++j;}\\n            else {\\n                if(lps == -1) return false;\\n                j = ++lss;\\n                i = lps;\\n            }\\n        }\\n        while(p[i] == \\'*\\') ++i;\\n        return i == sizeP;\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "codeTag": "C++"
            },
            {
                "id": 338080,
                "title": "python-simple-dp",
                "content": "[Similar problem: 10. Regular Expression Matching with Explanation](https://leetcode.com/problems/regular-expression-matching/discuss/336345/python-simple-dp/308355)\\n```python\\n    # DP\\n    def isMatch(self, s: str, p: str) -> bool:\\n        dp = [[False]*(len(p)+1) for i in range(len(s)+1)]\\n        dp[0][0] = True\\n        for j in range(1,len(p)+1):\\n            if p[j-1] == \\'*\\':\\n                dp[0][j] = dp[0][j-1]\\n        \\n        for i in range(1,len(s)+1):\\n            for j in range(1,len(p)+1):\\n                dp[i][j] = (p[j-1] in [s[i-1],\\'?\\',\\'*\\'] and dp[i-1][j-1]) or (p[j-1] == \\'*\\' and (dp[i][j-1] or dp[i-1][j]))\\n  \\n        return dp[len(s)][len(p)]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```python\\n    # DP\\n    def isMatch(self, s: str, p: str) -> bool:\\n        dp = [[False]*(len(p)+1) for i in range(len(s)+1)]\\n        dp[0][0] = True\\n        for j in range(1,len(p)+1):\\n            if p[j-1] == \\'*\\':\\n                dp[0][j] = dp[0][j-1]\\n        \\n        for i in range(1,len(s)+1):\\n            for j in range(1,len(p)+1):\\n                dp[i][j] = (p[j-1] in [s[i-1],\\'?\\',\\'*\\'] and dp[i-1][j-1]) or (p[j-1] == \\'*\\' and (dp[i][j-1] or dp[i-1][j]))\\n  \\n        return dp[len(s)][len(p)]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 335162,
                "title": "c-concise-dp",
                "content": "```cpp\\nbool isMatch(string s, string p) {\\n\\tvector<vector<int>> memo(p.size() + 1, vector<int>(s.size() + 1));\\n\\tmemo[0][0] = 1;\\n\\tfor(int i = 1; i <= p.size(); i++)\\n\\t\\tmemo[i][0] = p[i - 1] == \\'*\\' && memo[i - 1][0];\\n\\n\\tfor(int i = 1; i <= p.size(); i++) {\\n\\t\\tfor(int j = 1; j <= s.size(); j++) {\\n\\t\\t\\tif(p[i - 1] == \\'*\\')\\n\\t\\t\\t\\tmemo[i][j] = memo[i - 1][j] || memo[i][j - 1];\\n\\t\\t\\telse if(p[i - 1] == \\'?\\' || p[i - 1] == s[j - 1])\\n\\t\\t\\t\\tmemo[i][j] = memo[i - 1][j - 1];\\n\\t\\t}\\n\\t}\\n\\n\\treturn memo.back().back();\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nbool isMatch(string s, string p) {\\n\\tvector<vector<int>> memo(p.size() + 1, vector<int>(s.size() + 1));\\n\\tmemo[0][0] = 1;\\n\\tfor(int i = 1; i <= p.size(); i++)\\n\\t\\tmemo[i][0] = p[i - 1] == \\'*\\' && memo[i - 1][0];\\n\\n\\tfor(int i = 1; i <= p.size(); i++) {\\n\\t\\tfor(int j = 1; j <= s.size(); j++) {\\n\\t\\t\\tif(p[i - 1] == \\'*\\')\\n\\t\\t\\t\\tmemo[i][j] = memo[i - 1][j] || memo[i][j - 1];\\n\\t\\t\\telse if(p[i - 1] == \\'?\\' || p[i - 1] == s[j - 1])\\n\\t\\t\\t\\tmemo[i][j] = memo[i - 1][j - 1];\\n\\t\\t}\\n\\t}\\n\\n\\treturn memo.back().back();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 180538,
                "title": "short-and-easy-to-understand-solution-based-on-nfa-nondeterministic-finite-automaton",
                "content": "Just save a set of current states and from every current state try to advance with one character from the pattern to a next state.\\nThe state is an integer representing the current index in the string s. The length of the string s is a finite state.\\nAfter we process the whole pattern check whether we have arrived to a finite state.\\n\\n```\\n bool isMatch(string s, string p) {\\n    unordered_set<int> states;\\n    // We start from the first characher of s.\\n    states.insert(0);\\n\\n    for (char ch : p) {\\n       unordered_set<int> nextStates;\\n       for (int state : states) {\\n          if (ch == \\'*\\') {\\n             // If we reach a Kleene star we can process from 0 character to\\n             // the whole string so we insert all the states from the current state to\\n             // the end of the string.\\n             for (int i = state; i <= s.size(); ++i) {\\n                nextStates.insert(i);\\n             }\\n          }\\n          \\n          // We cannot go anywhere from a finite state if the current char from pattern is not\\n          // a star.\\n          if (state >= s.size()) continue;\\n          \\n          // We advance 1 move if the char matches of if it is a question mark.\\n          if (s[state] == ch || ch == \\'?\\') {\\n             nextStates.insert(state + 1);\\n          }\\n       }\\n       // Proceed from the new set of states.\\n       states = nextStates;\\n    }\\n    for (int state : states)\\n       if (state == s.size()) return true;\\n\\n    // We haven\\'t reached an end state.\\n    return false;\\n }\\n```",
                "solutionTags": [],
                "code": "```\\n bool isMatch(string s, string p) {\\n    unordered_set<int> states;\\n    // We start from the first characher of s.\\n    states.insert(0);\\n\\n    for (char ch : p) {\\n       unordered_set<int> nextStates;\\n       for (int state : states) {\\n          if (ch == \\'*\\') {\\n             // If we reach a Kleene star we can process from 0 character to\\n             // the whole string so we insert all the states from the current state to\\n             // the end of the string.\\n             for (int i = state; i <= s.size(); ++i) {\\n                nextStates.insert(i);\\n             }\\n          }\\n          \\n          // We cannot go anywhere from a finite state if the current char from pattern is not\\n          // a star.\\n          if (state >= s.size()) continue;\\n          \\n          // We advance 1 move if the char matches of if it is a question mark.\\n          if (s[state] == ch || ch == \\'?\\') {\\n             nextStates.insert(state + 1);\\n          }\\n       }\\n       // Proceed from the new set of states.\\n       states = nextStates;\\n    }\\n    for (int state : states)\\n       if (state == s.size()) return true;\\n\\n    // We haven\\'t reached an end state.\\n    return false;\\n }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 126185,
                "title": "java-dp-solution-with-o-n-space-with-detailed-explaination",
                "content": "This is a DP O(n) space solution optimized from DP O(mn) space solution\\n\\nThe optimization is based on Zero-One backpack algorithm and Complete backpack algorithm.\\nSo after the optimization, this problem looks more like a mixed backpack problem.\\n\\n```\\n    public boolean isMatch(String s, String p) {\\n        boolean[] dp = new boolean[s.length()+1];   // dp[i] maps to dp[i][j], where i is the length of s, j is the length of j\\n        char[] sStr = s.toCharArray();\\n        char[] pStr = p.toCharArray();\\n        dp[0] = true;   // before we started any iteration, dp[0] is equal to dp[0][0], meaning both s and p are EMPTY\\n        for (int j=1; j<=pStr.length; j++) {\\n            char pChr = pStr[j-1];\\n            if (pChr == \\'*\\') {\\n                // same optimization as complete backpack problem\\n                // we scan from 1 to s.length, so that dp[i] = dp[i] || dp[i-1]\\n                // just thinking like every time we iterating dp[i], the dp[i][j] we referenced is actually previous iteration\\'s result. so dp[i-1] is actually dp[i-1][j] from previous step of current i-loop for string s, dp[i] is actually dp[i][j-1] from previous j-loop for string p\\n                // it\\'s relatively easy to understand that before the dp[i]\\'s value is updated, dp[i] refers to dp[i][j-1] \\n                // the hard to understand part may be why dp[i-1] equals to dp[i-1][j]. Notice dp[i-1]\\'s value was updated in previous step\\'s update (we update dp[i-1] in dp[i-2]\\'s step), so dp[i-1] is equal to dp[i-1][j]\\n                for (int i=1; i<=sStr.length; i++) {\\n                    dp[i] = dp[i] || dp[i-1];\\n                }\\n            } else {\\n                // same optimization as zero-one backpack\\n                // dp[i-1] means dp[i-1][j-1]\\n                for (int i=sStr.length; i>=1; i--) {\\n                    if (sStr[i-1] == pChr || pChr == \\'?\\') {\\n                        dp[i] = dp[i-1];\\n                    } else {\\n                        dp[i] = false;\\n                    }\\n                }\\n                // now, after we see the first non-\\'*\\' character, as dp[0] means dp[i][0] where i>=1, dp[i][0] it\\'s definite false (matching empty p with non-empty s)\\n                // we want to set that value to false\\n                dp[0] = false;\\n            }\\n        }\\n        return dp[sStr.length];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean isMatch(String s, String p) {\\n        boolean[] dp = new boolean[s.length()+1];   // dp[i] maps to dp[i][j], where i is the length of s, j is the length of j\\n        char[] sStr = s.toCharArray();\\n        char[] pStr = p.toCharArray();\\n        dp[0] = true;   // before we started any iteration, dp[0] is equal to dp[0][0], meaning both s and p are EMPTY\\n        for (int j=1; j<=pStr.length; j++) {\\n            char pChr = pStr[j-1];\\n            if (pChr == \\'*\\') {\\n                // same optimization as complete backpack problem\\n                // we scan from 1 to s.length, so that dp[i] = dp[i] || dp[i-1]\\n                // just thinking like every time we iterating dp[i], the dp[i][j] we referenced is actually previous iteration\\'s result. so dp[i-1] is actually dp[i-1][j] from previous step of current i-loop for string s, dp[i] is actually dp[i][j-1] from previous j-loop for string p\\n                // it\\'s relatively easy to understand that before the dp[i]\\'s value is updated, dp[i] refers to dp[i][j-1] \\n                // the hard to understand part may be why dp[i-1] equals to dp[i-1][j]. Notice dp[i-1]\\'s value was updated in previous step\\'s update (we update dp[i-1] in dp[i-2]\\'s step), so dp[i-1] is equal to dp[i-1][j]\\n                for (int i=1; i<=sStr.length; i++) {\\n                    dp[i] = dp[i] || dp[i-1];\\n                }\\n            } else {\\n                // same optimization as zero-one backpack\\n                // dp[i-1] means dp[i-1][j-1]\\n                for (int i=sStr.length; i>=1; i--) {\\n                    if (sStr[i-1] == pChr || pChr == \\'?\\') {\\n                        dp[i] = dp[i-1];\\n                    } else {\\n                        dp[i] = false;\\n                    }\\n                }\\n                // now, after we see the first non-\\'*\\' character, as dp[0] means dp[i][0] where i>=1, dp[i][0] it\\'s definite false (matching empty p with non-empty s)\\n                // we want to set that value to false\\n                dp[0] = false;\\n            }\\n        }\\n        return dp[sStr.length];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 17880,
                "title": "c-code-9ms-beats-100-persons",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        int n=s.length(), m=p.length();\\n        int pid=0, sid=0;\\n        int pidp=-1, sidp=-1;\\n        while(sid<n){\\n            if(p[pid]==s[sid] || p[pid]=='?'){\\n                pid++; sid++;\\n            }else if(p[pid]=='*'){\\n                pidp=pid++; sidp=sid;\\n            }else{\\n                if(pidp>-1){\\n                    pid=pidp+1; sid=++sidp;\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        while(p[pid]=='*') pid++;\\n        return pid==m;\\n    }\\n};\\n````",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        int n=s.length(), m=p.length();\\n        int pid=0, sid=0;\\n        int pidp=-1, sidp=-1;\\n        while(sid<n){\\n            if(p[pid]==s[sid] || p[pid]=='?'){\\n                pid++; sid++;\\n            }else if(p[pid]=='*'){\\n                pidp=pid++; sidp=sid;\\n            }else{\\n                if(pidp>-1){\\n                    pid=pidp+1; sid=++sidp;\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        while(p[pid]=='*') pid++;\\n        return pid==m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17888,
                "title": "simple-greedy-python-with-regexes",
                "content": "For example if the pattern is `'ab*cd*e?*gh'`:\\n1. Turn that into `['ab', 'cd', 'e.', 'gh']` (turn `?` into `.` and split on `*`).\\n2. Check that the start of the string matches `'ab'` (and chop it off the string).\\n3. Check that the end of the string matches `'gh'` (and chop it off the string).\\n4. Check that `'cd'` and `'e.'` are matched somewhere in the string in that order. Just be greedy, always use the first occurrence.\\n\\n\\n    def isMatch(self, s, p):\\n        parts = p.replace('?', '.').split('*')\\n        if len(parts) == 1:\\n            return bool(re.match(parts[0] + '$', s))\\n        if not re.match(parts[0], s):\\n            return False\\n        s = s[len(parts.pop(0)):]\\n        if not re.search(parts[-1] + '$', s):\\n            return False\\n        s = s[:len(s) - len(parts.pop())]\\n        for part in parts:\\n            m = re.search(part, s)\\n            if not m:\\n                return False\\n            s = s[m.end():]\\n        return True",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "For example if the pattern is `'ab*cd*e?*gh'`:\\n1. Turn that into `['ab', 'cd', 'e.', 'gh']` (turn `?` into `.` and split on `*`).\\n2. Check that the start of the string matches `'ab'` (and chop it off the string).\\n3. Check that the end of the string matches `'gh'` (and chop it off the string).\\n4. Check that `'cd'` and `'e.'` are matched somewhere in the string in that order. Just be greedy, always use the first occurrence.\\n\\n\\n    def isMatch(self, s, p):\\n        parts = p.replace('?', '.').split('*')\\n        if len(parts) == 1:\\n            return bool(re.match(parts[0] + '$', s))\\n        if not re.match(parts[0], s):\\n            return False\\n        s = s[len(parts.pop(0)):]\\n        if not re.search(parts[-1] + '$', s):\\n            return False\\n        s = s[:len(s) - len(parts.pop())]\\n        for part in parts:\\n            m = re.search(part, s)\\n            if not m:\\n                return False\\n            s = s[m.end():]\\n        return True",
                "codeTag": "Python3"
            },
            {
                "id": 17975,
                "title": "32-ms-c-ac-code-after-34-submission-with-main-idea-explained-in-commet-o-1-in-space",
                "content": "    class Solution {\\n    public:\\n    \\tbool isMatch(const char* s, const char* p){\\n    // main idea:\\n    // before '*' appears, everything is trivial\\n    // just move forward the pointer s and p\\n    // after '*' shows up, \\n    // I separate the pattern p into some subpatterns, spaced by '*'\\n    // for those subpatterns between '*', to check if s fit the\\n    // first subpattern is equvalent to check if\\n    // that subpattern exist in s\\n    // because '*' can be any char including empty char\\n    // I then find the first substring of s\\n    // that satisfies the first subpattern, update s and go on\\n    // searching for the following subpatterns until the\\n    // last subpattern (here I used KMP algorithm which is\\n    // not quite necessary, I just wanted to have a practice to\\n    // impletment that algorithm)\\n    // At that time I know that the searched substring s\\n    // fits the searched subpattern of p and if I move forward\\n    // pointer s, the fitting still holds (because of *)\\n    // what I want is to make s and p go to '\\\\0' together at the\\n    // same time. For that purpose, I need to keep moving forward\\n    // s and check if s exactly fit the last subpattern of p\\n    // and after that, the problem is solved\\n    // I'm not very sure about the time complexity\\n    // but the KMP algorithm take nearly O(N + M) where N and M\\n    // are the length of s and p correspondingly\\n    // and the last step searching should be O(N + M) so I guess\\n    // the time complexity should be O(N + M)\\n    // the space complexity is O(1)\\n    \\t\\tconst char* lastS = nullptr;\\n    \\t\\tconst char* lastP = nullptr;\\n    \\t\\tbool star = false;\\n    \\t\\twhile(*s != '\\\\0'){\\n    \\t\\t\\tif(!star){\\n    \\t\\t\\t\\tif(*p == '?' || *p == *s){\\n    \\t\\t\\t\\t\\tp++;\\n    \\t\\t\\t\\t\\ts++;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\telse if(*p == '*'){\\n    \\t\\t\\t\\t\\tstar = true;\\n    \\t\\t\\t\\t\\twhile(*p == '*') p++;\\n    \\t\\t\\t\\t\\tif(*p == '\\\\0') return true;\\n    \\t\\t\\t\\t\\tlastS = s;\\n    \\t\\t\\t\\t\\tlastP = p;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\telse return false;\\n    \\t\\t\\t}\\n    \\t\\t\\telse{\\n    \\t\\t\\t\\tif(*p == '*'){\\n    \\t\\t\\t\\t\\twhile(*p == '*') p++;\\n    \\t\\t\\t\\t\\tif(*p == '\\\\0') return true;\\n    \\t\\t\\t\\t\\tlastS = s;\\n    \\t\\t\\t\\t\\tlastP = p;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\telse if(*p == '?'){\\n    \\t\\t\\t\\t\\ts++;\\n    \\t\\t\\t\\t\\tp++;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\telse if(*p != '\\\\0'){\\n    \\t\\t\\t\\t\\tint n = 0;\\n    \\t\\t\\t\\t\\tconst char* itr = p;\\n    \\t\\t\\t\\t\\twhile(*itr != '\\\\0' && *itr != '*' && *itr != '?'){\\n    \\t\\t\\t\\t\\t\\titr++;\\n    \\t\\t\\t\\t\\t\\tn++;\\n    \\t\\t\\t\\t\\t}\\n    \\t\\t\\t\\t\\tif(!help(s, p, n)) return false;\\n    \\t\\t\\t\\t\\ts += n;\\n    \\t\\t\\t\\t\\tp += n;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\telse{\\n    \\t\\t\\t\\t\\tif(*lastP != '\\\\0'){\\n    \\t\\t\\t\\t\\t\\tlastS++;\\n    \\t\\t\\t\\t\\t\\ts = lastS;\\n    \\t\\t\\t\\t\\t\\tp = lastP;\\n    \\t\\t\\t\\t\\t}\\n    \\t\\t\\t\\t\\telse return false;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\twhile(*p == '*') p++;\\n    \\t\\treturn *p == '\\\\0';\\n    \\t}\\n    \\tbool help(const char*& s, const char*& p, int n){\\n    \\t// KMP algorithm\\n    \\t\\tvector<int> table(n, 0);\\n    \\t\\tbuildPartialSeparationTable(p, n, table);\\n    \\t\\tint idx = 0;// number of chars that match\\n    \\t\\twhile(1){\\n    \\t\\t\\tif(idx == n) return true;\\n    \\t\\t\\tif(*(s + idx) == '\\\\0') return false;\\n    \\t\\t\\tif(*(s + idx) == *(p + idx)){\\n    \\t\\t\\t\\tidx++;\\n    \\t\\t\\t}\\n    \\t\\t\\telse{\\n    \\t\\t\\t\\tif(idx == 0) s++;\\n    \\t\\t\\t\\telse{\\n    \\t\\t\\t\\t\\ts += idx - table[idx - 1];\\n    \\t\\t\\t\\t\\tidx = 0;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    \\tvoid buildPartialSeparationTable(const char* p, int n, vector<int>& table){\\n    \\t// a help function for KMP algorithm\\n    \\t\\ttable.resize(n);\\n    \\t\\tint longgestPre = 0;\\n    \\t\\tfor(int i = 1; i < n; i++){\\n    \\t\\t\\twhile(longgestPre > 0 && p[longgestPre] != p[i]){\\n    \\t\\t\\t\\tlonggestPre = table[longgestPre - 1];\\n    \\t\\t\\t}\\n    \\t\\t\\tif(p[longgestPre] == p[i]){\\n    \\t\\t\\t\\ttable[i] = table[i - 1] + 1;\\n    \\t\\t\\t\\tlonggestPre = table[i];\\n    \\t\\t\\t}\\n    \\t\\t\\telse table[i] = 0;\\n    \\t\\t}\\n    \\t}\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    \\tbool isMatch(const char* s, const char* p){\\n    // main idea:\\n    // before '*' appears, everything is trivial\\n    // just move forward the pointer s and p\\n    // after '*' shows up, \\n    // I separate the pattern p into some subpatterns, spaced by '*'\\n    // for those subpatterns between '*', to check if s fit the\\n    // first subpattern is equvalent to check if\\n    // that subpattern exist in s\\n    // because '*' can be any char including empty char\\n    // I then find the first substring of s\\n    // that satisfies the first subpattern, update s and go on\\n    // searching for the following subpatterns until the\\n    // last subpattern (here I used KMP algorithm which is\\n    // not quite necessary, I just wanted to have a practice to\\n    // impletment that algorithm)\\n    // At that time I know that the searched substring s\\n    // fits the searched subpattern of p and if I move forward\\n    // pointer s, the fitting still holds (because of *)\\n    // what I want is to make s and p go to '\\\\0' together at the\\n    // same time. For that purpose, I need to keep moving forward\\n    // s and check if s exactly fit the last subpattern of p\\n    // and after that, the problem is solved\\n    // I'm not very sure about the time complexity\\n    // but the KMP algorithm take nearly O(N + M) where N and M\\n    // are the length of s and p correspondingly\\n    // and the last step searching should be O(N + M) so I guess\\n    // the time complexity should be O(N + M)\\n    // the space complexity is O(1)\\n    \\t\\tconst char* lastS = nullptr;\\n    \\t\\tconst char* lastP = nullptr;\\n    \\t\\tbool star = false;\\n    \\t\\twhile(*s != '\\\\0'){\\n    \\t\\t\\tif(!star){\\n    \\t\\t\\t\\tif(*p == '?' || *p == *s){\\n    \\t\\t\\t\\t\\tp++;\\n    \\t\\t\\t\\t\\ts++;\\n    \\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3731092,
                "title": "simple-c-memoization",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool solve(string &s,string &p,int i,int j,vector<vector<int>> &dp){\\n\\n        if(i<0 && j<0){\\n            return 1;\\n        }\\n\\n        if(i>=0  && j<0) return 0;\\n     \\n        \\n        if(i<0 && j>=0) {\\n            while(j>=0) {\\n                if(p[j]!=\\'*\\') return 0;\\n                j--;\\n            }\\n            return 1;\\n        };\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        if(p[j]==s[i] || p[j]==\\'?\\'){\\n           return dp[i][j]=solve(s,p,i-1,j-1,dp);\\n\\n        }\\n\\n\\n\\n        if(p[j]==\\'*\\'){\\n            int t=solve(s,p,i-1,j,dp);\\n            \\n            int neglect=solve(s,p,i,j-1,dp);\\n            return dp[i][j]=t||neglect;\\n        }\\n        return dp[i][j]=0;\\n    }\\n    bool isMatch(string &s, string &p) {\\n     \\n        int n=s.size();\\n        int m=p.size();\\n       \\n\\n        vector<vector<int>> dp(n,vector<int>(m,-1));\\n       \\n        return solve(s,p,n-1,m-1,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool solve(string &s,string &p,int i,int j,vector<vector<int>> &dp){\\n\\n        if(i<0 && j<0){\\n            return 1;\\n        }\\n\\n        if(i>=0  && j<0) return 0;\\n     \\n        \\n        if(i<0 && j>=0) {\\n            while(j>=0) {\\n                if(p[j]!=\\'*\\') return 0;\\n                j--;\\n            }\\n            return 1;\\n        };\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        if(p[j]==s[i] || p[j]==\\'?\\'){\\n           return dp[i][j]=solve(s,p,i-1,j-1,dp);\\n\\n        }\\n\\n\\n\\n        if(p[j]==\\'*\\'){\\n            int t=solve(s,p,i-1,j,dp);\\n            \\n            int neglect=solve(s,p,i,j-1,dp);\\n            return dp[i][j]=t||neglect;\\n        }\\n        return dp[i][j]=0;\\n    }\\n    bool isMatch(string &s, string &p) {\\n     \\n        int n=s.size();\\n        int m=p.size();\\n       \\n\\n        vector<vector<int>> dp(n,vector<int>(m,-1));\\n       \\n        return solve(s,p,n-1,m-1,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490512,
                "title": "java-solution-for-wildcard-matching-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this approach is to use two pointers i and j to traverse the string s and the pattern p, respectively. We also use two variables starIndex and iIndex to keep track of the index of the last * character in p and the index of the last character in s that matched the * character, respectively. If the current character in p matches the current character in s, we move both pointers i and j to the next index. If the current character in p is a ? or a non-* character that does not match the current character in s, we return false. If the current character in p is a *, we update the starIndex and iIndex variables to the current indices of j and i, respectively, and move j to the next index. If we encounter a mismatch between p and s and there is a * character in p, we reset j to starIndex+1, i to iIndex+1, and iIndex to the next index of i. We repeat this process until we reach the end of s. Finally, we check if there are any remaining * characters in p. If so, we return false. Otherwise, we return true.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Initialize two pointers i and j to 0 to traverse the string s and the pattern p, respectively.\\n- Initialize two variables starIndex and iIndex to -1 to keep track of the index of the last * character in p and the index of the last character in s that matched the * character, respectively.\\n- Traverse the string s from left to right for each index i from 0 to the length of s minus 1.\\n- If the current character in p matches the current character in s, move both pointers i and j to the next index.\\n- If the current character in p is a ? or a non-* character that does not match the current character in s, return false.\\n- If the current character in p is a *, update the starIndex and iIndex variables to the current indices of j and i, respectively, and move j to the next index.\\n- If we encounter a mismatch between p and s and there is a * character in p, reset j to starIndex+1, i to iIndex+1, and iIndex to the next index of i.\\n- Repeat steps 4-7 until the end of s is reached.\\n- Traverse the pattern p from the current index j to the end of the pattern.\\n- If the current character in p is a *, move j to the next index.\\n- If there are any remaining characters in p, return false. Otherwise, return true.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n), where n is the length of the input string s. The algorithm iterates through the string s once and performs constant-time operations for each character.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1), as the algorithm uses only constant extra space to store the variables i, j, starIndex, and iIndex.\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public boolean isMatch(String s, String p) \\n    {\\n        int i = 0;\\n        int j = 0;\\n        int starIndex = -1;\\n        int iIndex = -1;\\n        while (i < s.length()) \\n        {\\n            if (j < p.length() && (p.charAt(j) == \\'?\\' || p.charAt(j) == s.charAt(i)))\\n            {\\n                ++i;\\n                ++j;\\n            }\\n            else if (j < p.length() && p.charAt(j) == \\'*\\') \\n            {\\n                starIndex = j;\\n                iIndex = i;\\n                j++;\\n            }\\n            else if (starIndex != -1) \\n            {\\n                j = starIndex + 1;\\n                i = iIndex+1;\\n                iIndex++;\\n            }\\n            else \\n            {\\n                return false;\\n            }\\n        }\\n        while (j < p.length() && p.charAt(j) == \\'*\\') \\n        {\\n            ++j;\\n        }\\n        return j == p.length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public boolean isMatch(String s, String p) \\n    {\\n        int i = 0;\\n        int j = 0;\\n        int starIndex = -1;\\n        int iIndex = -1;\\n        while (i < s.length()) \\n        {\\n            if (j < p.length() && (p.charAt(j) == \\'?\\' || p.charAt(j) == s.charAt(i)))\\n            {\\n                ++i;\\n                ++j;\\n            }\\n            else if (j < p.length() && p.charAt(j) == \\'*\\') \\n            {\\n                starIndex = j;\\n                iIndex = i;\\n                j++;\\n            }\\n            else if (starIndex != -1) \\n            {\\n                j = starIndex + 1;\\n                i = iIndex+1;\\n                iIndex++;\\n            }\\n            else \\n            {\\n                return false;\\n            }\\n        }\\n        while (j < p.length() && p.charAt(j) == \\'*\\') \\n        {\\n            ++j;\\n        }\\n        return j == p.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3217667,
                "title": "wildcard-matching-c-solution",
                "content": "C# Solution:\\r\\n\\r\\n# Code\\r\\n```C#\\r\\npublic class Solution\\r\\n{\\r\\n    public bool IsMatch(string s, string p)\\r\\n    {\\r\\n        var i = 0;\\r\\n        var j = 0;\\r\\n        var star = -1;\\r\\n        var m = -1;\\r\\n\\r\\n        while (i < s.Length)\\r\\n        {\\r\\n            if (j < p.Length && (p[j] == \\'?\\' || p[j] == s[i]))\\r\\n            {\\r\\n                i++;\\r\\n                j++;\\r\\n\\r\\n                continue;\\r\\n            }\\r\\n\\r\\n            if (j < p.Length && p[j] == \\'*\\')\\r\\n            {\\r\\n                star = j++;\\r\\n                m = i;\\r\\n\\r\\n                continue;\\r\\n            }\\r\\n\\r\\n            if (star >= 0)\\r\\n            {\\r\\n                j = star + 1;\\r\\n                i = ++m;\\r\\n\\r\\n                continue;\\r\\n            }\\r\\n\\r\\n            return false;\\r\\n        }\\r\\n\\r\\n        while (j < p.Length && p[j] == \\'*\\')\\r\\n        {\\r\\n            j++;\\r\\n        }\\r\\n\\r\\n        return j == p.Length;\\r\\n    }\\r\\n}\\r\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```C#\\r\\npublic class Solution\\r\\n{\\r\\n    public bool IsMatch(string s, string p)\\r\\n    {\\r\\n        var i = 0;\\r\\n        var j = 0;\\r\\n        var star = -1;\\r\\n        var m = -1;\\r\\n\\r\\n        while (i < s.Length)\\r\\n        {\\r\\n            if (j < p.Length && (p[j] == \\'?\\' || p[j] == s[i]))\\r\\n            {\\r\\n                i++;\\r\\n                j++;\\r\\n\\r\\n                continue;\\r\\n            }\\r\\n\\r\\n            if (j < p.Length && p[j] == \\'*\\')\\r\\n            {\\r\\n                star = j++;\\r\\n                m = i;\\r\\n\\r\\n                continue;\\r\\n            }\\r\\n\\r\\n            if (star >= 0)\\r\\n            {\\r\\n                j = star + 1;\\r\\n                i = ++m;\\r\\n\\r\\n                continue;\\r\\n            }\\r\\n\\r\\n            return false;\\r\\n        }\\r\\n\\r\\n        while (j < p.Length && p[j] == \\'*\\')\\r\\n        {\\r\\n            j++;\\r\\n        }\\r\\n\\r\\n        return j == p.Length;\\r\\n    }\\r\\n}\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3160732,
                "title": "wildcard-matching-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Initialize a 2D boolean array dp with m + 1 rows and n + 1 columns, where m is the length of string s and n is the length of string p.\\n2. Set dp[0][0] to True, which means an empty string matches an empty pattern.\\n3. For each column in the first row, if the corresponding character in p is \\'*\\', set the value in the same column of the first row to the value in the previous column. This is because \\'*\\' matches any sequence of characters.\\n4. For each row from 1 to m, and each column from 1 to n:\\nIf the corresponding character in p is \\'*\\', set the value in dp[i][j] to the OR of the values in dp[i][j - 1] and dp[i - 1][j]. This means \\'*\\' matches any sequence of characters, including the empty sequence.\\nIf the corresponding character in p is \\'?\\' or the same as the corresponding character in s, set the value in dp[i][j] to the value in dp[i - 1][j - 1]. This means \\'?\\' matches any single character, and a character in s matches the same character in p.\\n5. Return dp[m][n], which is the result of matching the entire input string s with the entire pattern p.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        m, n = len(s), len(p)\\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\\n        dp[0][0] = True\\n        for j in range(1, n + 1):\\n            if p[j - 1] == \\'*\\':\\n                dp[0][j] = dp[0][j - 1]\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                if p[j - 1] == \\'*\\':\\n                    dp[i][j] = dp[i][j - 1] or dp[i - 1][j]\\n                elif p[j - 1] == \\'?\\' or s[i - 1] == p[j - 1]:\\n                    dp[i][j] = dp[i - 1][j - 1]\\n        return dp[m][n]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        m, n = len(s), len(p)\\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\\n        dp[0][0] = True\\n        for j in range(1, n + 1):\\n            if p[j - 1] == \\'*\\':\\n                dp[0][j] = dp[0][j - 1]\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                if p[j - 1] == \\'*\\':\\n                    dp[i][j] = dp[i][j - 1] or dp[i - 1][j]\\n                elif p[j - 1] == \\'?\\' or s[i - 1] == p[j - 1]:\\n                    dp[i][j] = dp[i - 1][j - 1]\\n        return dp[m][n]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3006399,
                "title": "most-simple-method",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        vector<vector<bool>> dp(s.size() + 1, vector(p.size() + 1, false));\\n        dp[0][0] = true;\\n        for (int j = 0; j < p.size() && p[j] == \\'*\\'; ++j) {\\n            dp[0][j + 1] = true;\\n        }\\n        \\n        for (int i = 1; i <= s.size(); ++i) {\\n            for (int j = 1; j <= p.size(); ++j) {\\n                if (p[j - 1] == \\'*\\') {\\n                    dp[i][j] = dp[i - 1][j] || dp[i][j - 1];\\n                } else {\\n                    dp[i][j] = (s[i - 1] == p[j - 1] || p[j - 1] == \\'?\\') && dp[i - 1][j - 1];\\n                }\\n            }\\n        }\\n\\n        return dp[s.size()][p.size()];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        vector<vector<bool>> dp(s.size() + 1, vector(p.size() + 1, false));\\n        dp[0][0] = true;\\n        for (int j = 0; j < p.size() && p[j] == \\'*\\'; ++j) {\\n            dp[0][j + 1] = true;\\n        }\\n        \\n        for (int i = 1; i <= s.size(); ++i) {\\n            for (int j = 1; j <= p.size(); ++j) {\\n                if (p[j - 1] == \\'*\\') {\\n                    dp[i][j] = dp[i - 1][j] || dp[i][j - 1];\\n                } else {\\n                    dp[i][j] = (s[i - 1] == p[j - 1] || p[j - 1] == \\'?\\') && dp[i - 1][j - 1];\\n                }\\n            }\\n        }\\n\\n        return dp[s.size()][p.size()];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3004512,
                "title": "c-striver-solution-recursion-memoisation",
                "content": "\\n# Approach\\nThis problem can be thought of as a recursion problem which can later be converted to dynamic programming using memoisation because it involves trying out all ways.\\n\\n# Complexity\\n- Time complexity:\\nO(n*m)\\n\\n- Space complexity:\\nO(n*m)+O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool solve(int ind1,int ind2,string &s,string &p,vector<vector<int>> &dp){\\n        if(ind1<0 && ind2<0) return true;\\n        if(ind2<0) return false;\\n        if(ind1<0){\\n            for(int i=0;i<=ind2;i++){\\n                if(p[i]!=\\'*\\') return false;\\n            }\\n            return true;\\n        }\\n        if(dp[ind1][ind2]!=-1) return dp[ind1][ind2];\\n        if(s[ind1]==p[ind2] || p[ind2]==\\'?\\') return dp[ind1][ind2]=solve(ind1-1,ind2-1,s,p,dp);\\n        else if(p[ind2]==\\'*\\'){\\n            return dp[ind1][ind2]=solve(ind1-1,ind2,s,p,dp) || solve(ind1,ind2-1,s,p,dp);\\n        }\\n        return dp[ind1][ind2]=false;\\n    }\\n    bool isMatch(string s, string p) {\\n        int n=s.length();\\n        int m=p.length();\\n        vector<vector<int>> dp(n,vector<int>(m,-1));\\n        return solve(n-1,m-1,s,p,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(int ind1,int ind2,string &s,string &p,vector<vector<int>> &dp){\\n        if(ind1<0 && ind2<0) return true;\\n        if(ind2<0) return false;\\n        if(ind1<0){\\n            for(int i=0;i<=ind2;i++){\\n                if(p[i]!=\\'*\\') return false;\\n            }\\n            return true;\\n        }\\n        if(dp[ind1][ind2]!=-1) return dp[ind1][ind2];\\n        if(s[ind1]==p[ind2] || p[ind2]==\\'?\\') return dp[ind1][ind2]=solve(ind1-1,ind2-1,s,p,dp);\\n        else if(p[ind2]==\\'*\\'){\\n            return dp[ind1][ind2]=solve(ind1-1,ind2,s,p,dp) || solve(ind1,ind2-1,s,p,dp);\\n        }\\n        return dp[ind1][ind2]=false;\\n    }\\n    bool isMatch(string s, string p) {\\n        int n=s.length();\\n        int m=p.length();\\n        vector<vector<int>> dp(n,vector<int>(m,-1));\\n        return solve(n-1,m-1,s,p,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2769545,
                "title": "python-dp-o-m-n",
                "content": "```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        m,n=len(s),len(p)\\n        dp=[[0 for i in range(m+1)] for j in range(n+1)]\\n        dp[0][0]=1\\n        for i in range(1,n + 1):\\n            if(p[i - 1] == \\'*\\'):\\n                dp[i][0] = True\\n            else:\\n                break\\n        for i in range(1,n+1):\\n            for j in range(1,m+1):\\n                if s[j-1]==p[i-1] or p[i-1]==\\'?\\':\\n                    dp[i][j]=dp[i-1][j-1]\\n                elif p[i-1]==\\'*\\':\\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1])\\n        return dp[n][m]\\n```\\n\\n**Please Upvote If You Like The Solution**",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        m,n=len(s),len(p)\\n        dp=[[0 for i in range(m+1)] for j in range(n+1)]\\n        dp[0][0]=1\\n        for i in range(1,n + 1):\\n            if(p[i - 1] == \\'*\\'):\\n                dp[i][0] = True\\n            else:\\n                break\\n        for i in range(1,n+1):\\n            for j in range(1,m+1):\\n                if s[j-1]==p[i-1] or p[i-1]==\\'?\\':\\n                    dp[i][j]=dp[i-1][j-1]\\n                elif p[i-1]==\\'*\\':\\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1])\\n        return dp[n][m]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2489651,
                "title": "c-recursion-memoization-tabulation-spaceoptimization",
                "content": "# Method - 1 [Recursion] \\n![image](https://assets.leetcode.com/users/images/51e10645-e2f4-4b78-b2bd-7880beb409cb_1661582208.273855.png)\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool f(int i,int j,string& p,string& s){\\n\\t\\t\\tif(i<0 && j<0) return true;\\n\\t\\t\\tif(i<0 && j>=0) return false;\\n\\t\\t\\tif(j<0 && i>=0){\\n\\t\\t\\t\\tfor(int k=i;k>=0;k--){\\n\\t\\t\\t\\t\\tif(p[k]!=\\'*\\') return false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t//      Match \\n\\t\\t\\tif(p[i]==s[j] || p[i]==\\'?\\') return f(i-1,j-1,p,s);\\n\\t\\t\\tif(p[i]==\\'*\\') return f(i-1,j,p,s) || f(i,j-1,p,s);\\n\\t//      NotMatch\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tbool isMatch(string s, string p) {\\n\\t\\t\\tint n=p.size();\\n\\t\\t\\tint m=s.size();\\n\\t\\t\\treturn f(n-1,m-1,p,s);\\n\\t\\t}\\n\\t};\\n\\t\\n# Method - 2 [Memoization]\\t\\n![image](https://assets.leetcode.com/users/images/49215323-5577-4559-90a2-e8d8ec335fcc_1661582342.8689756.png)\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool f(int i,int j,string& p,string& s,vector<vector<int>>& dp){\\n\\t\\t\\tif(i<0 && j<0) return true;\\n\\t\\t\\tif(i<0 && j>=0) return false;\\n\\t\\t\\tif(j<0 && i>=0){\\n\\t\\t\\t\\tfor(int k=i;k>=0;k--){\\n\\t\\t\\t\\t\\tif(p[k]!=\\'*\\') return false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\tif(dp[i][j]!=-1) return dp[i][j];\\n\\t//      Match \\n\\t\\t\\tif(p[i]==s[j] || p[i]==\\'?\\') return dp[i][j]=f(i-1,j-1,p,s,dp);\\n\\t\\t\\tif(p[i]==\\'*\\') return dp[i][j]=f(i-1,j,p,s,dp) || f(i,j-1,p,s,dp);\\n\\t//      NotMatch\\n\\t\\t\\treturn dp[i][j]=false;\\n\\t\\t}\\n\\n\\t\\tbool isMatch(string s, string p) {\\n\\t\\t\\tint n=p.size();\\n\\t\\t\\tint m=s.size();\\n\\t\\t\\tvector<vector<int>> dp(n,vector<int>(m,-1));\\n\\t\\t\\treturn f(n-1,m-1,p,s,dp);\\n\\t\\t}\\n\\t};\\n\\n# Method - 3 [Tabulation]\\n\\n![image](https://assets.leetcode.com/users/images/de78b6e7-c220-4b83-8fb3-2b9031909db2_1661593846.1921206.png)\\n\\n**T->O(mn) && S->O(mn)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool isMatch(string s, string p) {\\n\\t\\t\\tint n=p.size();\\n\\t\\t\\tint m=s.size();\\n\\t\\t\\tvector<vector<bool>> dp(n+1,vector<bool>(m+1,false));\\n\\t\\t\\tdp[0][0]=true;\\n\\t\\t\\tfor(int j=1;j<=m;j++) dp[0][j]=false;\\n\\t\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\t\\tbool flag=true;\\n\\t\\t\\t\\tfor(int k=1;k<=i;k++){\\n\\t\\t\\t\\t\\tif(p[k-1]!=\\'*\\'){\\n\\t\\t\\t\\t\\t\\tflag=false;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdp[i][0]=flag;\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\t\\tfor(int j=1;j<=m;j++){\\n\\t\\t\\t\\t\\tif(p[i-1]==s[j-1] || p[i-1]==\\'?\\') dp[i][j]=dp[i-1][j-1];\\n\\t\\t\\t\\t\\telse if(p[i-1]==\\'*\\') dp[i][j]=dp[i-1][j] || dp[i][j-1];\\n\\t\\t\\t\\t\\telse dp[i][j]=false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[n][m];\\n\\t\\t}\\n\\t};\\n\\t\\n# Method - 4 [SpaceOptimization]\\n\\n![image](https://assets.leetcode.com/users/images/d723d4e6-b015-489c-8bed-ef95f203be68_1661594465.8915417.png)\\n\\n**T->O(nm) && S->O(m)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool isMatch(string s, string p) {\\n\\t\\t\\tint n=p.size();\\n\\t\\t\\tint m=s.size();\\n\\t\\t\\tvector<bool> prev(m+1,false),curr(m+1,false);\\n\\t\\t\\tprev[0]=true;\\n\\t\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\t\\tbool flag=true;\\n\\t\\t\\t\\tfor(int k=1;k<=i;k++){\\n\\t\\t\\t\\t\\tif(p[k-1]!=\\'*\\'){\\n\\t\\t\\t\\t\\t\\tflag=false;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcurr[0]=flag;\\n\\t\\t\\t\\tfor(int j=1;j<=m;j++){\\n\\t\\t\\t\\t\\tif(p[i-1]==s[j-1] || p[i-1]==\\'?\\') curr[j]=prev[j-1];\\n\\t\\t\\t\\t\\telse if(p[i-1]==\\'*\\') curr[j]=prev[j] || curr[j-1];\\n\\t\\t\\t\\t\\telse curr[j]=false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tprev=curr;\\n\\t\\t\\t}\\n\\t\\t\\treturn prev[m];\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool f(int i,int j,string& p,string& s){\\n\\t\\t\\tif(i<0 && j<0) return true;\\n\\t\\t\\tif(i<0 && j>=0) return false;\\n\\t\\t\\tif(j<0 && i>=0){\\n\\t\\t\\t\\tfor(int k=i;k>=0;k--){\\n\\t\\t\\t\\t\\tif(p[k]!=\\'*\\') return false;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2443955,
                "title": "simple-java-solution-using-dp",
                "content": "```\\nclass Solution {\\n    public boolean isMatch(String s, String p) \\n    {\\n        if(s==null || p==null)\\n            return s.equals(p);\\n        \\n        int m= s.length();\\n        int n= p.length();\\n        \\n        boolean[][] dp = new boolean[m+1][n+1];\\n        \\n        dp[0][0] = true;\\n        \\n        for(int i=0; i< n ;i++)\\n        {\\n            if(p.charAt(i) == \\'*\\')\\n                dp[0][i+1] = dp[0][i];\\n        }\\n        \\n        for(int i=1; i<m+1; i++)\\n        {\\n            for(int j=1; j<n+1; j++)\\n            {\\n                if(s.charAt(i-1) == p.charAt(j-1) || p.charAt(j-1) == \\'?\\')\\n                    dp[i][j] = dp[i-1][j-1];\\n                \\n                else if(p.charAt(j-1) == \\'*\\')\\n                    dp[i][j] = dp[i-1][j] || dp[i][j-1];\\n            }\\n        }\\n        \\n        return dp[m][n];\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isMatch(String s, String p) \\n    {\\n        if(s==null || p==null)\\n            return s.equals(p);\\n        \\n        int m= s.length();\\n        int n= p.length();\\n        \\n        boolean[][] dp = new boolean[m+1][n+1];\\n        \\n        dp[0][0] = true;\\n        \\n        for(int i=0; i< n ;i++)\\n        {\\n            if(p.charAt(i) == \\'*\\')\\n                dp[0][i+1] = dp[0][i];\\n        }\\n        \\n        for(int i=1; i<m+1; i++)\\n        {\\n            for(int j=1; j<n+1; j++)\\n            {\\n                if(s.charAt(i-1) == p.charAt(j-1) || p.charAt(j-1) == \\'?\\')\\n                    dp[i][j] = dp[i-1][j-1];\\n                \\n                else if(p.charAt(j-1) == \\'*\\')\\n                    dp[i][j] = dp[i-1][j] || dp[i][j-1];\\n            }\\n        }\\n        \\n        return dp[m][n];\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1950430,
                "title": "php-100-100-regex-solution",
                "content": "Used Regex, found that PHP/PCRE was faster than Python matching.\\nReplaced \"?\" with \".\", and \"*\" with \".\\\\*\".\\n```\\nclass Solution {\\n\\n    /**\\n     * @param String $s\\n     * @param String $p\\n     * @return Boolean\\n     */\\n    function isMatch($s, $p) {\\n        return preg_match(\"/^\" . preg_replace(\"/\\\\*+/\", \".*\" ,str_replace(\"?\", \".\", $p)) . \"$/U\", $s);\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param String $s\\n     * @param String $p\\n     * @return Boolean\\n     */\\n    function isMatch($s, $p) {\\n        return preg_match(\"/^\" . preg_replace(\"/\\\\*+/\", \".*\" ,str_replace(\"?\", \".\", $p)) . \"$/U\", $s);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1731886,
                "title": "c-dp-easy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) \\n    {\\n        int m = s.length(),n=p.length();\\n        vector<vector<bool>> vec(m+1,vector<bool>(n+1,false));\\n        vec[0][0] = true;\\n        //For first row\\n        //For matching sequence like **** etc.\\n        for(int i=1;i<=n;i++)\\n        {\\n            vec[0][i] = p[i-1] == \\'*\\' && vec[0][i-1];\\n        }\\n        \\n        for(int i=1;i<=m;i++)\\n        {\\n            for(int j=1;j<=n;j++)\\n            {\\n                if(p[j-1] != \\'*\\')\\n                {\\n                    vec[i][j] = (s[i-1] == p[j-1] || p[j-1] == \\'?\\') && vec[i-1][j-1];\\n                }\\n                else\\n                {\\n                    vec[i][j] = vec[i][j-1] || vec[i-1][j];\\n                }\\n            }\\n        }\\n        return vec[m][n];\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool isMatch(string s, string p) \\n    {\\n        int m = s.length(),n=p.length();\\n        vector<vector<bool>> vec(m+1,vector<bool>(n+1,false));\\n        vec[0][0] = true;\\n        //For first row\\n        //For matching sequence like **** etc.\\n        for(int i=1;i<=n;i++)\\n        {\\n            vec[0][i] = p[i-1] == \\'*\\' && vec[0][i-1];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1723986,
                "title": "getting-tle-on-memoization-do-this",
                "content": "I tried doing memoization, but got TLE so i checked the discussion section, many others were facing the same issue. So I did a small changes in my memoization which is, I passed the strings by reference instead of passing by value and voila! submission got accepted xD.\\nMy solution.\\n*Upvote if helpful*\\n```\\nclass Solution {\\npublic:\\n    bool recursive_engine(string &s, string &p,int i,int j,vector<vector<int>> &dp){\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        bool output;\\n        if(i==s.length()){\\n            output= ((j==p.length()) || (p[j]==\\'*\\' && recursive_engine(s,p,i,j+1,dp)));\\n            \\n        }\\n        else if(p[j]==\\'*\\'){\\n            output= recursive_engine(s,p,i+1,j,dp) || recursive_engine(s,p,i,j+1,dp);\\n        }\\n        else{\\n            if(s[i]==p[j] || p[j]==\\'?\\'){\\n                output= recursive_engine(s,p,i+1,j+1,dp);\\n            }\\n            else output= false;\\n        }\\n        dp[i][j]=output;\\n        return output;\\n    }\\n    bool isMatch(string s, string p) {\\n        vector<vector<int>> dp(s.length()+1,vector<int>(p.length()+1,-1));\\n        return recursive_engine(s,p,0,0,dp);\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool recursive_engine(string &s, string &p,int i,int j,vector<vector<int>> &dp){\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        bool output;\\n        if(i==s.length()){\\n            output= ((j==p.length()) || (p[j]==\\'*\\' && recursive_engine(s,p,i,j+1,dp)));\\n            \\n        }\\n        else if(p[j]==\\'*\\'){\\n            output= recursive_engine(s,p,i+1,j,dp) || recursive_engine(s,p,i,j+1,dp);\\n        }\\n        else{\\n            if(s[i]==p[j] || p[j]==\\'?\\'){\\n                output= recursive_engine(s,p,i+1,j+1,dp);\\n            }\\n            else output= false;\\n        }\\n        dp[i][j]=output;\\n        return output;\\n    }\\n    bool isMatch(string s, string p) {\\n        vector<vector<int>> dp(s.length()+1,vector<int>(p.length()+1,-1));\\n        return recursive_engine(s,p,0,0,dp);\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1231816,
                "title": "two-sol-intution-from-recursion-to-dp-two-pointer-solution",
                "content": "**Intution from recursion to DP**\\nSo question is to match the two string where one contain some special character having some meaning ,\\nok let\\'s start thinking from basic if have two string to comapre what we can do:-\\n* compare first letter from both if equal then recursively compare for next letter , if not equal then simply return false.\\n* Base conditions:  \\n1. * if both string exhaust return true.    \\n1. * if one string exhaust and one is still , return false.\\n\\nNow come to our question we have two special char.\\n1. \\'?\\' replacable by any single letter\\n2. \\'*\\' replaceable by 0 or more letters.\\n\\nThus we need to consider three cases :-\\n1. when we encouter \\'*\\' in our pattern string , so we will recursively take all possibility like from empty string to the whole remaining string in our string .\\n2. when we encounter \\'? in our pattern string , simply we insert the same char which is present in our string, thus we move for the next.\\n3. same as normal check if current char are equal && recursively call for next char.\\n\\n#### **Here is sample code for it.**\\n\\n```\\n bool rec(string s, string p,int i,int j){\\n        if(s.length() == i && p.length() == j) return true;\\n        if(s.length() == i) {\\n            while(j != p.length()){\\n                if(p[j] != \\'*\\') return false;\\n                j++;\\n            }\\n            return true;\\n        }\\n        if(p.length() == j) return false;\\n        \\n        if(p[j] == \\'*\\'){ \\n            int k = i;\\n            bool ans = false;\\n            while(s.length() >= k){\\n                ans = ans  | rec(s,p,k,j+1);\\n                k++;\\n            }\\n            return ans;\\n        }\\n        else if(p[j] == \\'?\\'){\\n            return rec(s,p,i+1,j+1);\\n        }\\n        else{\\n           return s[i] == p[j] && rec(s,p,i+1,j+1);\\n        }\\n    }\\n```\\n\\nBut In this question it give TLE for the provided input , so we need to go for DP\\nIn Dp intialision part will be like if string length 0 so only if pattern contains * then true otherwise false,\\nand if pattern length 0 ,not possible so always false.\\nif encounter \\'*\\' look for one less in first || one less in seocond , \\'?\\' look for one less in both\\notherwise normally comapre and look for one less in both.\\n\\n### **Here is DP working code**\\n\\n```\\n   bool isMatch(string s, string p) {\\n        int n = s.length();\\n        int m = p.length();\\n        \\n        bool dp[n+1][m+1];\\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<=m;j++){\\n                //initalisation\\n                if(i == 0 && j == 0) dp[i][j] = true;\\n                if(i == 0 && j > 0){\\n                    dp[i][j] = (p[j-1] == \\'*\\') && dp[i][j-1];\\n                }\\n                if(i > 0 && j == 0) dp[i][j] = false;\\n                if(i > 0 && j > 0){\\n                    if(p[j-1] == \\'*\\'){\\n                        dp[i][j] = dp[i-1][j] || dp[i][j-1];\\n                    }\\n                    else if(p[j-1] == \\'?\\'){\\n                        dp[i][j] = dp[i-1][j-1];\\n                    }\\n                    else{\\n                        dp[i][j] = dp[i-1][j-1] && (s[i-1] == p[j-1]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n   }\\n```\\n\\nBut if we consider complexity of solution it\\'s like :-\\n1. Time Comlexity O(n*m)\\n2. space Comlexity O(n*m)\\n\\nWe can do better ? using two pointer approach.\\n[Explanation](https://leetcode.com/problems/wildcard-matching/discuss/17811/My-three-C%2B%2B-solutions-(iterative-(16ms)-and-DP-(180ms)-and-modified-recursion-(88ms)))\\n\\n```\\n  bool isMatch(string s, string p) {\\n        int  n = s.size();\\n        int  m = p.size();\\n        int k =-1,jEnc=-1;\\n        int i=0,j=0;\\n        while(i < n){\\n            if(p[j]==\\'*\\'){ \\n                k   = i;\\n                jEnc = j;\\n                i--;\\n            }\\n            else{ \\n                if(p[j] != s[i] && p[j] != \\'?\\'){\\n                    if(k >=0){\\n                        i = k;\\n                        j = jEnc;\\n                        k++;\\n                    }\\n                    else return false; \\n                }\\n            }\\n            ++i;\\n            ++j;\\n        }\\n        \\n        while(p[j]==\\'*\\') ++j;\\n        return j == m;\\n    }\\n```\\n\\ncredit to [Lejas](https://leetcode.com/LeJas/) for explaining two pointer solution in [this post.](https://leetcode.com/problems/wildcard-matching/discuss/17811/My-three-C%2B%2B-solutions-(iterative-(16ms)-and-DP-(180ms)-and-modified-recursion-(88ms)))\\n\\n",
                "solutionTags": [],
                "code": "```\\n bool rec(string s, string p,int i,int j){\\n        if(s.length() == i && p.length() == j) return true;\\n        if(s.length() == i) {\\n            while(j != p.length()){\\n                if(p[j] != \\'*\\') return false;\\n                j++;\\n            }\\n            return true;\\n        }\\n        if(p.length() == j) return false;\\n        \\n        if(p[j] == \\'*\\'){ \\n            int k = i;\\n            bool ans = false;\\n            while(s.length() >= k){\\n                ans = ans  | rec(s,p,k,j+1);\\n                k++;\\n            }\\n            return ans;\\n        }\\n        else if(p[j] == \\'?\\'){\\n            return rec(s,p,i+1,j+1);\\n        }\\n        else{\\n           return s[i] == p[j] && rec(s,p,i+1,j+1);\\n        }\\n    }\\n```\n```\\n   bool isMatch(string s, string p) {\\n        int n = s.length();\\n        int m = p.length();\\n        \\n        bool dp[n+1][m+1];\\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<=m;j++){\\n                //initalisation\\n                if(i == 0 && j == 0) dp[i][j] = true;\\n                if(i == 0 && j > 0){\\n                    dp[i][j] = (p[j-1] == \\'*\\') && dp[i][j-1];\\n                }\\n                if(i > 0 && j == 0) dp[i][j] = false;\\n                if(i > 0 && j > 0){\\n                    if(p[j-1] == \\'*\\'){\\n                        dp[i][j] = dp[i-1][j] || dp[i][j-1];\\n                    }\\n                    else if(p[j-1] == \\'?\\'){\\n                        dp[i][j] = dp[i-1][j-1];\\n                    }\\n                    else{\\n                        dp[i][j] = dp[i-1][j-1] && (s[i-1] == p[j-1]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n   }\\n```\n```\\n  bool isMatch(string s, string p) {\\n        int  n = s.size();\\n        int  m = p.size();\\n        int k =-1,jEnc=-1;\\n        int i=0,j=0;\\n        while(i < n){\\n            if(p[j]==\\'*\\'){ \\n                k   = i;\\n                jEnc = j;\\n                i--;\\n            }\\n            else{ \\n                if(p[j] != s[i] && p[j] != \\'?\\'){\\n                    if(k >=0){\\n                        i = k;\\n                        j = jEnc;\\n                        k++;\\n                    }\\n                    else return false; \\n                }\\n            }\\n            ++i;\\n            ++j;\\n        }\\n        \\n        while(p[j]==\\'*\\') ++j;\\n        return j == m;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1218483,
                "title": "python-solution-using-dp",
                "content": "\\tclass Solution:\\n\\t\\tdef isMatch(self, s: str, p: str) -> bool:\\n\\t\\t\\tm = len(p)                    # Length of the pattern\\n\\t\\t\\tn = len(s)                    # Length of the string\\n\\n\\t\\t\\t# Creating a 2D list of size n x m, with initial values to True\\n\\t\\t\\tdp = [[True for i in range(m+1)] for j in range(n+1)]\\n\\n\\t\\t\\t# Get the First row values of \\'dp\\'\\n\\t\\t\\ti = 0\\n\\t\\t\\tfor j in range(m+1):\\n\\t\\t\\t\\tif j == 0:\\n\\t\\t\\t\\t\\tdp[i][j] = True\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tif p[j-1] == \\'*\\':\\n\\t\\t\\t\\t\\t\\tdp[i][j] = dp[i][j-1]\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tdp[i][j] = False\\n\\n\\t\\t\\t# Initialize the First column\\'s values of \\'dp\\' to False\\n\\t\\t\\tfor j in range(1, n+1):\\n\\t\\t\\t\\tdp[j][0] = False\\n\\n\\t\\t\\t# Get all the index values of \\'dp\\'\\n\\t\\t\\tfor i in range(1, n+1):\\n\\t\\t\\t\\tfor j in range(1, m+1):\\n\\t\\t\\t\\t\\t# If (i-1)th char of \\'s\\' and (j-1)th of \\'p\\' char are same or (j-1)th char of \\'p\\' is \\'?\\'\\n\\t\\t\\t\\t\\tif s[i-1] == p[j-1] or p[j-1] == \\'?\\':\\n\\t\\t\\t\\t\\t\\tdp[i][j] = dp[i-1][j-1]  # Set [i, j] index value to the previous diagonal value\\n\\n\\t\\t\\t\\t\\t# If (j-1)th char of \\'p\\' is \\'*\\'\\n\\t\\t\\t\\t\\telif p[j-1] == \\'*\\':\\n\\t\\t\\t\\t\\t\\t# If any of [i-1, j]th or [i, j-1]th index value is True\\n\\t\\t\\t\\t\\t\\tif dp[i-1][j] == True or dp[i][j-1] == True:\\n\\t\\t\\t\\t\\t\\t\\tdp[i][j] = True     # Set [i, j]th index value to True\\n\\t\\t\\t\\t\\t\\t# Else\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\tdp[i][j] = False    # Set [i, j]th index value to False\\n\\n\\t\\t\\t\\t\\t# If [i-1]th char of \\'s\\' and [j-1]th char of \\'p\\' are not the same\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tdp[i][j] = False        # Set [i, j]th index value to False\\n\\t\\t\\t\\t# End Inner For Loop\\n\\t\\t\\t# End Outer For Loop\\n\\n\\t\\t\\t# Return the [n, m]th index value of \\'dp\\' as the answer\\n\\t\\t\\treturn dp[n][m]\\n\\n\\t\\'\\'\\'\\n\\t** Manual Tracing: An example\\n\\t\\t  0 1 2 3 4          0 1 2 3\\n\\ts =   a d c e b ;   p =  * a * b ;     m = len(p) = 4;  n = len(s) = 5\\n\\ti < n+1 = 6 ;  j < m+1 = 5\\n\\t  i = 1:         j = 1: s[0] == p[0] or p[0] == \\'?\\' ?= NO ; p[0] == \\'*\\' ?= YES: d[1][1] =   d[0][1] || d[1][0]   = T \\\\\\n\\t\\t\\t\\t\\t j = 2; s[0] == p[1] or p[1] == \\'?\\' ?=                     YES: d[1][2] =   d[i-1][j-1]=d[0][1]  = T \\\\\\n\\t\\t\\t\\t\\t j = 3; s[0] == p[2] or p[2] == \\'?\\' ?= NO ; p[2] == \\'*\\' ?= YES: d[1][3] =   d[0][3] || d[1][2]   = T \\\\\\n\\t\\t\\t\\t\\t j = 4; s[0] == p[3] or p[3] == \\'?\\' ?= NO ; p[3] == \\'*\\' ?= NO : d[1][3] =                        = F \\\\\\n\\n\\t  i = 2:         j = 1: s[1] == p[0] or p[0] == \\'?\\' ?= NO ; p[0] == \\'*\\' ?= YES: d[2][1] =   d[1][1] || d[2][0]   = T \\\\\\n\\t\\t\\t\\t\\t j = 2; s[1] == p[1] or p[1] == \\'?\\' ?= NO ; p[1] == \\'*\\' ?= NO : d[2][2] =                        = F \\\\\\n\\t\\t\\t\\t\\t j = 3; s[1] == p[2] or p[2] == \\'?\\' ?= NO ; p[2] == \\'*\\' ?= YES: d[2][3] =   d[1][3] || d[2][2]   = T \\\\\\n\\t\\t\\t\\t\\t j = 4; s[1] == p[3] or p[3] == \\'?\\' ?= NO ; p[3] == \\'*\\' ?= NO : d[2][3] =                        = F \\\\\\n\\n\\t  i = 3:         j = 1: s[2] == p[0] or p[0] == \\'?\\' ?= NO ; p[0] == \\'*\\' ?= YES: d[3][1] =   d[2][1] || d[3][0]   = T \\\\\\n\\t\\t\\t\\t\\t j = 2; s[2] == p[1] or p[1] == \\'?\\' ?= NO ; p[1] == \\'*\\' ?= NO : d[3][2] =                        = F \\\\\\n\\t\\t\\t\\t\\t j = 3; s[2] == p[2] or p[2] == \\'?\\' ?= NO ; p[2] == \\'*\\' ?= YES: d[3][3] =   d[2][3] || d[3][2]   = T \\\\\\n\\t\\t\\t\\t\\t j = 4; s[2] == p[3] or p[3] == \\'?\\' ?= NO ; p[3] == \\'*\\' ?= NO : d[3][3] =                        = F \\\\\\n\\n\\t  i = 4:         j = 1: s[3] == p[0] or p[0] == \\'?\\' ?= NO ; p[0] == \\'*\\' ?= YES: d[4][1] =   d[3][1] || d[4][0]   = T \\\\\\n\\t\\t\\t\\t\\t j = 2; s[3] == p[1] or p[1] == \\'?\\' ?= NO ; p[1] == \\'*\\' ?= NO : d[4][2] =                        = F \\\\\\n\\t\\t\\t\\t\\t j = 3; s[3] == p[2] or p[2] == \\'?\\' ?= NO ; p[2] == \\'*\\' ?= YES: d[4][3] =   d[3][3] || d[4][2]   = T \\\\\\n\\t\\t\\t\\t\\t j = 4; s[3] == p[3] or p[3] == \\'?\\' ?= NO ; p[3] == \\'*\\' ?= NO : d[4][3] =                        = F \\\\\\n\\n\\t  i = 5:         j = 1: s[4] == p[0] or p[0] == \\'?\\' ?= NO ; p[0] == \\'*\\' ?= YES: d[5][1] =   d[4][1] || d[5][0]   = T \\\\\\n\\t\\t\\t\\t\\t j = 2; s[4] == p[1] or p[1] == \\'?\\' ?= NO ; p[1] == \\'*\\' ?= NO : d[5][2] =                        = F \\\\\\n\\t\\t\\t\\t\\t j = 3; s[4] == p[2] or p[2] == \\'?\\' ?= NO ; p[2] == \\'*\\' ?= YES: d[5][3] =   d[4][3] || d[5][2]   = T \\\\\\n\\t\\t\\t\\t\\t j = 4; s[4] == p[3] or p[3] == \\'?\\' ?=                     YES: d[5][4] =   d[i-1][j-1]=d[4][3]  = T \\\\\\n\\n\\t\\tdp: \\n\\n\\t\\t\\t   |---|---|---|---|---|\\n\\t\\t\\t   | 0 | 1 | 2 | 3 | 4 |\\n\\t\\t\\t   |---|---|---|---|---|\\n\\t\\t\\t   |\\' \\'| * | a | * | b----> Pattern\\n\\t   |---|---|---|---|---|---|---|\\n\\t   | 0 |\\' \\'| T | T | T | T | F |\\n\\t   |---|---|---|---|---|---|---|\\n\\t   | 1 | a | F | T | F | T | F |\\n\\t   |---|---|---|---|---|---|---|\\n\\t   | 2 | d | F | T | F | T | F |\\n\\t   |---|---|---|---|---|---|---|\\n\\t   | 3 | c | F | T | F | T | F |\\n\\t   |---|---|---|---|---|---|---|\\n\\t   | 4 | e | F | T | F | T | F |\\n\\t   |---|---|---|---|---|---|---|\\n\\t   | 5 | b | F | T | F | T | T----> Answer\\n\\t   |---|-|-|---|---|---|---|---|\\n\\t\\t\\t |\\n\\t\\t\\t \\'--> String\\n\\t\\'\\'\\'",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef isMatch(self, s: str, p: str) -> bool:\\n\\t\\t\\tm = len(p)                    # Length of the pattern\\n\\t\\t\\tn = len(s)                    # Length of the string\\n\\n\\t\\t\\t# Creating a 2D list of size n x m, with initial values to True\\n\\t\\t\\tdp = [[True for i in range(m+1)] for j in range(n+1)]\\n\\n\\t\\t\\t# Get the First row values of \\'dp\\'\\n\\t\\t\\ti = 0\\n\\t\\t\\tfor j in range(m+1):\\n\\t\\t\\t\\tif j == 0:\\n\\t\\t\\t\\t\\tdp[i][j] = True\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tif p[j-1] == \\'*\\':\\n\\t\\t\\t\\t\\t\\tdp[i][j] = dp[i][j-1]\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tdp[i][j] = False\\n\\n\\t\\t\\t# Initialize the First column\\'s values of \\'dp\\' to False\\n\\t\\t\\tfor j in range(1, n+1):\\n\\t\\t\\t\\tdp[j][0] = False\\n\\n\\t\\t\\t# Get all the index values of \\'dp\\'\\n\\t\\t\\tfor i in range(1, n+1):\\n\\t\\t\\t\\tfor j in range(1, m+1):\\n\\t\\t\\t\\t\\t# If (i-1)th char of \\'s\\' and (j-1)th of \\'p\\' char are same or (j-1)th char of \\'p\\' is \\'?\\'\\n\\t\\t\\t\\t\\tif s[i-1] == p[j-1] or p[j-1] == \\'?\\':\\n\\t\\t\\t\\t\\t\\tdp[i][j] = dp[i-1][j-1]  # Set [i, j] index value to the previous diagonal value\\n\\n\\t\\t\\t\\t\\t# If (j-1)th char of \\'p\\' is \\'*\\'\\n\\t\\t\\t\\t\\telif p[j-1] == \\'*\\':\\n\\t\\t\\t\\t\\t\\t# If any of [i-1, j]th or [i, j-1]th index value is True\\n\\t\\t\\t\\t\\t\\tif dp[i-1][j] == True or dp[i][j-1] == True:\\n\\t\\t\\t\\t\\t\\t\\tdp[i][j] = True     # Set [i, j]th index value to True\\n\\t\\t\\t\\t\\t\\t# Else\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\tdp[i][j] = False    # Set [i, j]th index value to False\\n\\n\\t\\t\\t\\t\\t# If [i-1]th char of \\'s\\' and [j-1]th char of \\'p\\' are not the same\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tdp[i][j] = False        # Set [i, j]th index value to False\\n\\t\\t\\t\\t# End Inner For Loop\\n\\t\\t\\t# End Outer For Loop\\n\\n\\t\\t\\t# Return the [n, m]th index value of \\'dp\\' as the answer\\n\\t\\t\\treturn dp[n][m]\\n\\n\\t\\'\\'\\'\\n\\t** Manual Tracing: An example\\n\\t\\t  0 1 2 3 4          0 1 2 3\\n\\ts =   a d c e b ;   p =  * a * b ;     m = len(p) = 4;  n = len(s) = 5\\n\\ti < n+1 = 6 ;  j < m+1 = 5\\n\\t  i = 1:         j = 1: s[0] == p[0] or p[0] == \\'?\\' ?= NO ; p[0] == \\'*\\' ?= YES: d[1][1] =   d[0][1] || d[1][0]   = T \\\\\\n\\t\\t\\t\\t\\t j = 2; s[0] == p[1] or p[1] == \\'?\\' ?=                     YES: d[1][2] =   d[i-1][j-1]=d[0][1]  = T \\\\\\n\\t\\t\\t\\t\\t j = 3; s[0] == p[2] or p[2] == \\'?\\' ?= NO ; p[2] == \\'*\\' ?= YES: d[1][3] =   d[0][3] || d[1][2]   = T \\\\\\n\\t\\t\\t\\t\\t j = 4; s[0] == p[3] or p[3] == \\'?\\' ?= NO ; p[3] == \\'*\\' ?= NO : d[1][3] =                        = F \\\\\\n\\n\\t  i = 2:         j = 1: s[1] == p[0] or p[0] == \\'?\\' ?= NO ; p[0] == \\'*\\' ?= YES: d[2][1] =   d[1][1] || d[2][0]   = T \\\\\\n\\t\\t\\t\\t\\t j = 2; s[1] == p[1] or p[1] == \\'?\\' ?= NO ; p[1] == \\'*\\' ?= NO : d[2][2] =                        = F \\\\\\n\\t\\t\\t\\t\\t j = 3; s[1] == p[2] or p[2] == \\'?\\' ?= NO ; p[2] == \\'*\\' ?= YES: d[2][3] =   d[1][3] || d[2][2]   = T \\\\\\n\\t\\t\\t\\t\\t j = 4; s[1] == p[3] or p[3] == \\'?\\' ?= NO ; p[3] == \\'*\\' ?= NO : d[2][3] =                        = F \\\\\\n\\n\\t  i = 3:         j = 1: s[2] == p[0] or p[0] == \\'?\\' ?= NO ; p[0] == \\'*\\' ?= YES: d[3][1] =   d[2][1] || d[3][0]   = T \\\\\\n\\t\\t\\t\\t\\t j = 2; s[2] == p[1] or p[1] == \\'?\\' ?= NO ; p[1] == \\'*\\' ?= NO : d[3][2] =                        = F \\\\\\n\\t\\t\\t\\t\\t j = 3; s[2] == p[2] or p[2] == \\'?\\' ?= NO ; p[2] == \\'*\\' ?= YES: d[3][3] =   d[2][3] || d[3][2]   = T \\\\\\n\\t\\t\\t\\t\\t j = 4; s[2] == p[3] or p[3] == \\'?\\' ?= NO ; p[3] == \\'*\\' ?= NO : d[3][3] =                        = F \\\\\\n\\n\\t  i = 4:         j = 1: s[3] == p[0] or p[0] == \\'?\\' ?= NO ; p[0] == \\'*\\' ?= YES: d[4][1] =   d[3][1] || d[4][0]   = T \\\\\\n\\t\\t\\t\\t\\t j = 2; s[3] == p[1] or p[1] == \\'?\\' ?= NO ; p[1] == \\'*\\' ?= NO : d[4][2] =                        = F \\\\\\n\\t\\t\\t\\t\\t j = 3; s[3] == p[2] or p[2] == \\'?\\' ?= NO ; p[2] == \\'*\\' ?= YES: d[4][3] =   d[3][3] || d[4][2]   = T \\\\\\n\\t\\t\\t\\t\\t j = 4; s[3] == p[3] or p[3] == \\'?\\' ?= NO ; p[3] == \\'*\\' ?= NO : d[4][3] =                        = F \\\\\\n\\n\\t  i = 5:         j = 1: s[4] == p[0] or p[0] == \\'?\\' ?= NO ; p[0] == \\'*\\' ?= YES: d[5][1] =   d[4][1] || d[5][0]   = T \\\\\\n\\t\\t\\t\\t\\t j = 2; s[4] == p[1] or p[1] == \\'?\\' ?= NO ; p[1] == \\'*\\' ?= NO : d[5][2] =                        = F \\\\\\n\\t\\t\\t\\t\\t j = 3; s[4] == p[2] or p[2] == \\'?\\' ?= NO ; p[2] == \\'*\\' ?= YES: d[5][3] =   d[4][3] || d[5][2]   = T \\\\\\n\\t\\t\\t\\t\\t j = 4; s[4] == p[3] or p[3] == \\'?\\' ?=                     YES: d[5][4] =   d[i-1][j-1]=d[4][3]  = T \\\\\\n\\n\\t\\tdp: \\n\\n\\t\\t\\t   |---|---|---|---|---|\\n\\t\\t\\t   | 0 | 1 | 2 | 3 | 4 |\\n\\t\\t\\t   |---|---|---|---|---|\\n\\t\\t\\t   |\\' \\'| * | a | * | b----> Pattern\\n\\t   |---|---|---|---|---|---|---|\\n\\t   | 0 |\\' \\'| T | T | T | T | F |\\n\\t   |---|---|---|---|---|---|---|\\n\\t   | 1 | a | F | T | F | T | F |\\n\\t   |---|---|---|---|---|---|---|\\n\\t   | 2 | d | F | T | F | T | F |\\n\\t   |---|---|---|---|---|---|---|\\n\\t   | 3 | c | F | T | F | T | F |\\n\\t   |---|---|---|---|---|---|---|\\n\\t   | 4 | e | F | T | F | T | F |\\n\\t   |---|---|---|---|---|---|---|\\n\\t   | 5 | b | F | T | F | T | T----> Answer\\n\\t   |---|-|-|---|---|---|---|---|\\n\\t\\t\\t |\\n\\t\\t\\t \\'--> String\\n\\t\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 1210412,
                "title": "python-o-m-n-top-down-dp-solution",
                "content": "```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        m, n = len(s), len(p)\\n        dp = [[False for i in range(m + 1)] for i in range(n + 1)]\\n        \\n        dp[0][0] = True\\n        for i in range(1,n + 1):\\n            if(p[i - 1] == \\'*\\'):\\n                dp[i][0] = True\\n            else:\\n                break\\n        for i in range(1, n + 1):\\n            for j in range(1, m + 1):\\n                if s[j - 1] == p[i - 1] or p[i - 1] == \\'?\\':\\n                    dp[i][j] = dp[i - 1][j - 1]\\n                elif p[i - 1] == \\'*\\':\\n                    dp[i][j] = dp[i][j - 1] or dp[i - 1][j]\\n        return dp[n][m]\\n```\\n**PS: Please upvote if you liked the solution.**",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        m, n = len(s), len(p)\\n        dp = [[False for i in range(m + 1)] for i in range(n + 1)]\\n        \\n        dp[0][0] = True\\n        for i in range(1,n + 1):\\n            if(p[i - 1] == \\'*\\'):\\n                dp[i][0] = True\\n            else:\\n                break\\n        for i in range(1, n + 1):\\n            for j in range(1, m + 1):\\n                if s[j - 1] == p[i - 1] or p[i - 1] == \\'?\\':\\n                    dp[i][j] = dp[i - 1][j - 1]\\n                elif p[i - 1] == \\'*\\':\\n                    dp[i][j] = dp[i][j - 1] or dp[i - 1][j]\\n        return dp[n][m]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206824,
                "title": "python3-dp-think-removing",
                "content": "```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        \"\"\"dynamic programming, think \"removing\"\\n\\n        dp[i][j] == T/F if char match between s[i] and p[j]\\n\\n        1) if s[i] == p[j] or p[j] == \"?\"\\n\\n        - effectively the same as *removing* both characters, and thus resulting\\n          evaluation based on previous subproblem: dp[i][j] = dp[i-1][j-1]\\n\\n        2) if p[j] == \"*\"\\n\\n        - one possibility is the empty sequence, so effectively same as\\n          *removing* the star character and thus evaluation based on previous\\n          subproblem: dp[i][j] = dp[i][j-1]\\n\\n        - another possibility is matching against one or more characters, in\\n          which case effectively same as *removing* character from s[i], and\\n          thus evaluation based on previous subproblem: dp[i][j] = dp[i-1][j]\\n\\n              * c d\\n            0 1 2 3\\n          0 T T F F\\n        a 1 F T F F\\n        b 2 F T F F\\n        c 3 F T T F\\n        d 4 F T F T <- corresponds to matching pattern\\n\\n              a * d\\n            0 1 2 3\\n          0 T F F F\\n        a 1 F T T F\\n        b 2 F F T F\\n        c 3 F F T F\\n        d 4 F F T T\\n\\n              z * d\\n            0 1 2 3\\n          0 T F F F\\n        a 1 F F F F\\n        b 2 F F F F\\n        c 3 F F F F\\n        d 4 F F F F\\n\\n        Notably, when initializing the table of subproblems dp, we need to\\n        correctly set the first row per defined rules above.\\n\\n        O(MN) time and space; MN corresponds to lengths of input s / p\\n        \"\"\"\\n        ls, lp = len(s), len(p)\\n        dp = [[False for _ in range(lp+1)] for __ in range(ls+1)]\\n        dp[0][0] = True\\n\\n        for j in range(1, lp+1):\\n            if p[j-1] == \"*\":\\n                dp[0][j] = dp[0][j-1]\\n\\n        for i in range(1, ls+1):\\n            for j in range(1, lp+1):\\n                if s[i-1] == p[j-1] or p[j-1] == \"?\":\\n                    dp[i][j] = dp[i-1][j-1]\\n                if p[j-1] == \"*\":\\n                    opt1 = dp[i][j-1]\\n                    opt2 = dp[i-1][j]\\n                    dp[i][j] = opt1 or opt2\\n\\n        return dp[-1][-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        \"\"\"dynamic programming, think \"removing\"\\n\\n        dp[i][j] == T/F if char match between s[i] and p[j]\\n\\n        1) if s[i] == p[j] or p[j] == \"?\"\\n\\n        - effectively the same as *removing* both characters, and thus resulting\\n          evaluation based on previous subproblem: dp[i][j] = dp[i-1][j-1]\\n\\n        2) if p[j] == \"*\"\\n\\n        - one possibility is the empty sequence, so effectively same as\\n          *removing* the star character and thus evaluation based on previous\\n          subproblem: dp[i][j] = dp[i][j-1]\\n\\n        - another possibility is matching against one or more characters, in\\n          which case effectively same as *removing* character from s[i], and\\n          thus evaluation based on previous subproblem: dp[i][j] = dp[i-1][j]\\n\\n              * c d\\n            0 1 2 3\\n          0 T T F F\\n        a 1 F T F F\\n        b 2 F T F F\\n        c 3 F T T F\\n        d 4 F T F T <- corresponds to matching pattern\\n\\n              a * d\\n            0 1 2 3\\n          0 T F F F\\n        a 1 F T T F\\n        b 2 F F T F\\n        c 3 F F T F\\n        d 4 F F T T\\n\\n              z * d\\n            0 1 2 3\\n          0 T F F F\\n        a 1 F F F F\\n        b 2 F F F F\\n        c 3 F F F F\\n        d 4 F F F F\\n\\n        Notably, when initializing the table of subproblems dp, we need to\\n        correctly set the first row per defined rules above.\\n\\n        O(MN) time and space; MN corresponds to lengths of input s / p\\n        \"\"\"\\n        ls, lp = len(s), len(p)\\n        dp = [[False for _ in range(lp+1)] for __ in range(ls+1)]\\n        dp[0][0] = True\\n\\n        for j in range(1, lp+1):\\n            if p[j-1] == \"*\":\\n                dp[0][j] = dp[0][j-1]\\n\\n        for i in range(1, ls+1):\\n            for j in range(1, lp+1):\\n                if s[i-1] == p[j-1] or p[j-1] == \"?\":\\n                    dp[i][j] = dp[i-1][j-1]\\n                if p[j-1] == \"*\":\\n                    opt1 = dp[i][j-1]\\n                    opt2 = dp[i-1][j]\\n                    dp[i][j] = opt1 or opt2\\n\\n        return dp[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 988649,
                "title": "python-dynamic-programming-approach-o-m-n",
                "content": "**Easy to understand python3 solution**\\n```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        # fisrt we make a clear pattern \\n        # i.e *****a****b***c** is same as *a*b*c*\\n        def clear_pattern(p):\\n            ans = []\\n            for i in range(len(p)):\\n                if p[i] != \\'*\\':\\n                    ans.append(p[i])\\n                else:\\n                    if ans and ans[-1] == \\'*\\':\\n                        continue\\n                    else:\\n                        ans.append(p[i])\\n            p = \\'\\'.join(ans)\\n            return p\\n        p = clear_pattern(p)\\n        \\n        # now we apply dynamic programming approach to solve the problem\\n        dp = [[False for j in range(len(p) + 1)] for i in range(len(s) + 1)]\\n        # null string is always same as null string\\n        dp[0][0] = True\\n        \\n        if p and p[0] == \\'*\\':\\n            dp[0][1] = True\\n            \\n        for i in range(1, len(s) + 1):\\n            for j in range(1, len(p) + 1):\\n                \\'\\'\\'\\n                if both the characters are equal or pattern has ? then we need to check\\n                for the string if it is matched till previous charcters length\\n                \\'\\'\\'\\n                if s[i - 1] == p[j - 1] or p[j - 1] == \\'?\\':\\n                    dp[i][j] = dp[i - 1][j - 1]\\n                elif p[j - 1] == \\'*\\':\\n                    dp[i][j] = dp[i - 1][j] or dp[i][j - 1]\\n        return dp[len(s)][len(p)]\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        # fisrt we make a clear pattern \\n        # i.e *****a****b***c** is same as *a*b*c*\\n        def clear_pattern(p):\\n            ans = []\\n            for i in range(len(p)):\\n                if p[i] != \\'*\\':\\n                    ans.append(p[i])\\n                else:\\n                    if ans and ans[-1] == \\'*\\':\\n                        continue\\n                    else:\\n                        ans.append(p[i])\\n            p = \\'\\'.join(ans)\\n            return p\\n        p = clear_pattern(p)\\n        \\n        # now we apply dynamic programming approach to solve the problem\\n        dp = [[False for j in range(len(p) + 1)] for i in range(len(s) + 1)]\\n        # null string is always same as null string\\n        dp[0][0] = True\\n        \\n        if p and p[0] == \\'*\\':\\n            dp[0][1] = True\\n            \\n        for i in range(1, len(s) + 1):\\n            for j in range(1, len(p) + 1):\\n                \\'\\'\\'\\n                if both the characters are equal or pattern has ? then we need to check\\n                for the string if it is matched till previous charcters length\\n                \\'\\'\\'\\n                if s[i - 1] == p[j - 1] or p[j - 1] == \\'?\\':\\n                    dp[i][j] = dp[i - 1][j - 1]\\n                elif p[j - 1] == \\'*\\':\\n                    dp[i][j] = dp[i - 1][j] or dp[i][j - 1]\\n        return dp[len(s)][len(p)]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 824268,
                "title": "java-evolve-to-dp-solution-all-4-approaches",
                "content": "```\\n\\n/**\\n * General Idea: Credit: https://leetcode.com/problems/wildcard-matching/discuss/370736/Detailed-Intuition-From-Brute-force-to-Bottom-up-DP \\n * The idea is pretty straightforward : scan S and P while there is a match between the current character of S and the current character of P. \\n * If we reach the end of both strings while there is still a match, return True, otherwise return False. \\n * The scan is done by having a pointer in S and a pointer in P.\\n\\n\\tExample: S=\"code\"\\n\\tThe character \\'c\\' of S matches the first character of P if the first character of P is:\\n\\n\\t\\'c\\'\\n\\t\\'?\\'\\n\\t\\'*\\'\\n\\n\\tCase 1:\\n\\t\\tWhen the first character of P is a lowercase letter different from \\'c\\', return False.\\n\\tCase 2:\\n\\t\\tIf the first character of P is \\'c\\' or \\'?\\', we move both pointers one step to the right.\\n\\tCase 3:\\n\\t\\tIf the first character of P is \\'*\\', we have 2 possibilities:\\n\\n\\t\\t\\t- \\'*\\' matches 0 character : in this case we move the pointer in P one step, ie will ignore the whole pattern\\n\\t\\t\\t- \\'*\\' matches 1 or more characters : in this case we move the pointer in S one step, ie we consider pattern\\n\\tAnd we continue like this for each two positions taken by the two pointers.\\n\\n\\t- If we reach the end of P but there is still characters from S, simply return .. False !\\n\\t- If we reach the end of S and there is still characters from P, the only case when there is a match is that all the remaining characters in P are \\'*\\', \\n\\t  in this case these stars will be matched with the empty string.\\n ****/\\n\\n/*******************\\n * Approach 1: TLE: using recursion\\n * \\n * Time Complexity : \\n * \\n * Space Complexity : O(M^2+N^2)\\n **********************************/\\n\\npublic boolean isMatchApproach1(String text, String pattern) {\\n\\treturn isMatchApproach1Helper(0, 0, text, pattern);\\n}\\n\\npublic boolean isMatchApproach1Helper(int tIdx, int pIdx, String text, String pattern) {\\n\\n\\t// reached the end of both S and P\\n\\tif (tIdx == text.length() && pIdx == pattern.length()) {\\n\\t\\treturn true;\\n\\t}\\n\\t// there are still characters in S => there is no match\\n\\telse if (pIdx == pattern.length()) {\\n\\t\\treturn false; // Can\\'t have a non-empty s match an empty p.\\n\\t}\\n\\t// if we reached end of text and pattern is still left. \\n\\t// Try to see if p at or after this stage is only * or ** or *** etc. Only way to match an empty text.\\n\\telse if (tIdx == text.length()) {\\n\\t\\treturn pattern.charAt(pIdx) == \\'*\\' && isMatchApproach1Helper(tIdx, pIdx + 1, text, pattern);\\n\\t}\\n\\t// Here cuz text & pattern match atleast a char\\n\\telse if (text.charAt(tIdx) == pattern.charAt(pIdx) || pattern.charAt(pIdx) == \\'?\\') {\\n\\n\\t\\t// Match here if strs from next index onward also are a match. Delegate job to recursive func for latter.\\n\\t\\treturn isMatchApproach1Helper(tIdx + 1, pIdx + 1, text, pattern);\\n\\n\\t}\\n\\t// star either matches 0 or >=1 character\\n\\telse if (pattern.charAt(pIdx) == \\'*\\') {\\n\\t\\t// 1: When * matches an empty seq, it\\'s work is done. Hence, the next stage to check match for is w/o *.\\n\\t\\t// \\t  Also, there could be *s in line. So, consuming this *, could exhibit new p with next fresh *.\\n\\t\\t// 2: \\'*\\' can match seq of chars. Hence, * kept. Further rec stages could use it to match more chars/empty.\\n\\t\\treturn isMatchApproach1Helper(tIdx, pIdx + 1, text, pattern)\\n\\t\\t\\t\\t|| isMatchApproach1Helper(tIdx + 1, pIdx, text, pattern);\\n\\t}\\n\\n\\treturn false;\\n}\\n\\n/*******************\\n * Approach 2: Top Down Memoization + Recursion\\n * Top-down the smallest problem is (len(s), len(p)),\\n * \\n * Time Complexity : O(m * n)\\n * \\n * Space Complexity : O(m * n)\\n **********************************/\\nBoolean[][] memo;\\n\\npublic boolean isMatchApproach2(String text, String pattern) {\\n\\tmemo = new Boolean[text.length() + 1][pattern.length() + 1];\\n\\treturn dpMemo(0, 0, text, pattern);\\n}\\n\\npublic boolean dpMemo(int tIdx, int pIdx, String text, String pattern) {\\n\\tif (memo[tIdx][pIdx] != null) {\\n\\t\\treturn memo[tIdx][pIdx];\\n\\t}\\n\\tboolean match = false; // False picked up in memo @ end for else case when chars don\\'t match.\\n\\n\\t// reached the end of both S and P\\n\\tif (tIdx == text.length() && pIdx == pattern.length()) {\\n\\t\\tmatch = true;\\n\\n\\t}\\n\\t// there are still characters in S => there is no match\\n\\telse if (pIdx == pattern.length()) {\\n\\n\\t\\tmatch = false; // Can\\'t have a non-empty s match an empty p.\\n\\t}\\n\\t// if we reached end of text and pattern is still left. \\n\\t// Try to see if p at or after this stage is only * or ** or *** etc. Only way to match an empty text.\\n\\telse if (tIdx == text.length()) {\\n\\t\\tmatch = pattern.charAt(pIdx) == \\'*\\' && dpMemo(tIdx, pIdx + 1, text, pattern);\\n\\n\\t}\\n\\t//  Here cuz text & pattern match atleast a char\\n\\telse if (text.charAt(tIdx) == pattern.charAt(pIdx) || pattern.charAt(pIdx) == \\'?\\') {\\n\\n\\t\\t// Match here if strs from next index onward also are a match. Delegate job to recursive func for latter.\\n\\t\\tmatch = dpMemo(tIdx + 1, pIdx + 1, text, pattern);\\n\\n\\t} \\n\\t// star either matches 0 or >=1 character\\n\\telse if (pattern.charAt(pIdx) == \\'*\\') {\\n\\t\\t// 1: When * matches an empty seq, it\\'s work is done. Hence, the next stage to check match for is w/o *.\\n\\t\\t// \\t  Also, there could be *s in line. So, consuming this *, could exhibit new p with next fresh *.\\n\\t\\t// 2: \\'*\\' can match seq of chars. Hence, * kept. Further rec stages could use it to match more chars/empty.\\n\\t\\tmatch = dpMemo(tIdx, pIdx + 1, text, pattern) || dpMemo(tIdx + 1, pIdx, text, pattern);\\n\\t}\\n\\n\\treturn memo[tIdx][pIdx] = match;\\n}\\n\\n/*******************\\n * Approach 3: Bottom Up Tabulation: https://www.youtube.com/watch?v=3ZDZ-N0EPV0\\n * Bottom-up the smallest is (0, 0)\\n * \\n * \\t\\t\\t\\t|\\tdp[i-1][j-1]  if str[i] == pattern[j] || pattern[j] == \\'?\\'\\n * \\t\\t\\t\\t|\\t\\t\\t\\t\\t\\n * \\t\\t\\t\\t|\\tif pattern[j-1] == \\'*\\'\\n * dp[i][j] = \\t|\\t\\tdp[i][j-1] || dp[i-1][j]\\n * \\t\\t\\t\\t|\\t\\t\\t\\t\\t\\n * \\t\\t\\t\\t|\\tFalse\\n * \\n * Time Complexity : O(m * n)\\n * Space Complexity : O(m * n)\\n **********************************/\\n\\npublic boolean isMatchApproach3(String text, String pattern) {\\n\\n\\tint m = text.length();\\n\\tint n = pattern.length();\\n\\tboolean[][] dp = new boolean[m + 1][n + 1];\\n\\n\\tfor (int tIdx = 0; tIdx <= m; tIdx++) {\\n\\t\\tfor (int pIdx = 0; pIdx <= n; pIdx++) {\\n\\n\\t\\t\\t// empty strings match\\n\\t\\t\\tif (tIdx == 0 && pIdx == 0)\\n\\t\\t\\t\\tdp[tIdx][pIdx] = true;\\n\\n\\t\\t\\t// fill first row, empty text can match all * pattern\\n\\t\\t\\telse if (tIdx == 0)\\n\\t\\t\\t\\tdp[tIdx][pIdx] = pattern.charAt(pIdx - 1) == \\'*\\' && dp[tIdx][pIdx - 1] == true;\\n\\n\\t\\t\\t// Can\\'t have a non-empty text match an empty pattern.\\n\\t\\t\\telse if (pIdx == 0)\\n\\t\\t\\t\\tdp[tIdx][pIdx] = false;\\n\\n\\t\\t\\t// star either matches 0 or >=1 character\\n\\t\\t\\telse if (pattern.charAt(pIdx - 1) == \\'*\\')\\n\\t\\t\\t\\tdp[tIdx][pIdx] = dp[tIdx][pIdx - 1] || dp[tIdx - 1][pIdx];\\n\\n\\t\\t\\t//  Here cuz text & pattern match atleast a char\\n\\t\\t\\telse if (text.charAt(tIdx - 1) == pattern.charAt(pIdx - 1) || pattern.charAt(pIdx - 1) == \\'?\\')\\n\\t\\t\\t\\tdp[tIdx][pIdx] = dp[tIdx - 1][pIdx - 1];\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[m][n];\\n}\\n\\n/*\\n * Approach 4: Linear: Very tricky: https://leetcode.com/problems/wildcard-matching/discuss/17810/Linear-runtime-and-constant-space-solution\\n */\\npublic boolean isMatchApproach4(String text, String pattern) {\\n\\tint tIdx = 0, pIdx = 0, match = 0, starIdx = -1;\\n\\n\\twhile (tIdx < text.length()) {\\n\\t\\t// advancing both pointers\\n\\t\\tif (pIdx < pattern.length() && (pattern.charAt(pIdx) == \\'?\\' || text.charAt(tIdx) == pattern.charAt(pIdx))) {\\n\\t\\t\\ttIdx++;\\n\\t\\t\\tpIdx++;\\n\\t\\t}\\n\\t\\t// \\'*\\' found, only advancing pattern pointer\\n\\t\\telse if (pIdx < pattern.length() && pattern.charAt(pIdx) == \\'*\\') {\\n\\t\\t\\tstarIdx = pIdx;\\n\\t\\t\\tmatch = tIdx;\\n\\t\\t\\tpIdx++;\\n\\t\\t}\\n\\t\\t// last pattern pointer was *, advancing string pointer\\n\\t\\telse if (starIdx != -1) {\\n\\t\\t\\tpIdx = starIdx + 1;\\n\\t\\t\\tmatch++;\\n\\t\\t\\ttIdx = match;\\n\\t\\t}\\n\\t\\t//current pattern pointer is not star, last patter pointer was not *\\n\\t\\t//characters do not match\\n\\t\\telse\\n\\t\\t\\treturn false;\\n\\t}\\n\\n\\t//check for remaining characters in pattern\\n\\twhile (pIdx < pattern.length() && pattern.charAt(pIdx) == \\'*\\')\\n\\t\\tpIdx++;\\n\\n\\treturn pIdx == pattern.length();\\n}",
                "solutionTags": [],
                "code": "```\\n\\n/**\\n * General Idea: Credit: https://leetcode.com/problems/wildcard-matching/discuss/370736/Detailed-Intuition-From-Brute-force-to-Bottom-up-DP \\n * The idea is pretty straightforward : scan S and P while there is a match between the current character of S and the current character of P. \\n * If we reach the end of both strings while there is still a match, return True, otherwise return False. \\n * The scan is done by having a pointer in S and a pointer in P.\\n\\n\\tExample: S=\"code\"\\n\\tThe character \\'c\\' of S matches the first character of P if the first character of P is:\\n\\n\\t\\'c\\'\\n\\t\\'?\\'\\n\\t\\'*\\'\\n\\n\\tCase 1:\\n\\t\\tWhen the first character of P is a lowercase letter different from \\'c\\', return False.\\n\\tCase 2:\\n\\t\\tIf the first character of P is \\'c\\' or \\'?\\', we move both pointers one step to the right.\\n\\tCase 3:\\n\\t\\tIf the first character of P is \\'*\\', we have 2 possibilities:\\n\\n\\t\\t\\t- \\'*\\' matches 0 character : in this case we move the pointer in P one step, ie will ignore the whole pattern\\n\\t\\t\\t- \\'*\\' matches 1 or more characters : in this case we move the pointer in S one step, ie we consider pattern\\n\\tAnd we continue like this for each two positions taken by the two pointers.\\n\\n\\t- If we reach the end of P but there is still characters from S, simply return .. False !\\n\\t- If we reach the end of S and there is still characters from P, the only case when there is a match is that all the remaining characters in P are \\'*\\', \\n\\t  in this case these stars will be matched with the empty string.\\n ****/\\n\\n/*******************\\n * Approach 1: TLE: using recursion\\n * \\n * Time Complexity : \\n * \\n * Space Complexity : O(M^2+N^2)\\n **********************************/\\n\\npublic boolean isMatchApproach1(String text, String pattern) {\\n\\treturn isMatchApproach1Helper(0, 0, text, pattern);\\n}\\n\\npublic boolean isMatchApproach1Helper(int tIdx, int pIdx, String text, String pattern) {\\n\\n\\t// reached the end of both S and P\\n\\tif (tIdx == text.length() && pIdx == pattern.length()) {\\n\\t\\treturn true;\\n\\t}\\n\\t// there are still characters in S => there is no match\\n\\telse if (pIdx == pattern.length()) {\\n\\t\\treturn false; // Can\\'t have a non-empty s match an empty p.\\n\\t}\\n\\t// if we reached end of text and pattern is still left. \\n\\t// Try to see if p at or after this stage is only * or ** or *** etc. Only way to match an empty text.\\n\\telse if (tIdx == text.length()) {\\n\\t\\treturn pattern.charAt(pIdx) == \\'*\\' && isMatchApproach1Helper(tIdx, pIdx + 1, text, pattern);\\n\\t}\\n\\t// Here cuz text & pattern match atleast a char\\n\\telse if (text.charAt(tIdx) == pattern.charAt(pIdx) || pattern.charAt(pIdx) == \\'?\\') {\\n\\n\\t\\t// Match here if strs from next index onward also are a match. Delegate job to recursive func for latter.\\n\\t\\treturn isMatchApproach1Helper(tIdx + 1, pIdx + 1, text, pattern);\\n\\n\\t}\\n\\t// star either matches 0 or >=1 character\\n\\telse if (pattern.charAt(pIdx) == \\'*\\') {\\n\\t\\t// 1: When * matches an empty seq, it\\'s work is done. Hence, the next stage to check match for is w/o *.\\n\\t\\t// \\t  Also, there could be *s in line. So, consuming this *, could exhibit new p with next fresh *.\\n\\t\\t// 2: \\'*\\' can match seq of chars. Hence, * kept. Further rec stages could use it to match more chars/empty.\\n\\t\\treturn isMatchApproach1Helper(tIdx, pIdx + 1, text, pattern)\\n\\t\\t\\t\\t|| isMatchApproach1Helper(tIdx + 1, pIdx, text, pattern);\\n\\t}\\n\\n\\treturn false;\\n}\\n\\n/*******************\\n * Approach 2: Top Down Memoization + Recursion\\n * Top-down the smallest problem is (len(s), len(p)),\\n * \\n * Time Complexity : O(m * n)\\n * \\n * Space Complexity : O(m * n)\\n **********************************/\\nBoolean[][] memo;\\n\\npublic boolean isMatchApproach2(String text, String pattern) {\\n\\tmemo = new Boolean[text.length() + 1][pattern.length() + 1];\\n\\treturn dpMemo(0, 0, text, pattern);\\n}\\n\\npublic boolean dpMemo(int tIdx, int pIdx, String text, String pattern) {\\n\\tif (memo[tIdx][pIdx] != null) {\\n\\t\\treturn memo[tIdx][pIdx];\\n\\t}\\n\\tboolean match = false; // False picked up in memo @ end for else case when chars don\\'t match.\\n\\n\\t// reached the end of both S and P\\n\\tif (tIdx == text.length() && pIdx == pattern.length()) {\\n\\t\\tmatch = true;\\n\\n\\t}\\n\\t// there are still characters in S => there is no match\\n\\telse if (pIdx == pattern.length()) {\\n\\n\\t\\tmatch = false; // Can\\'t have a non-empty s match an empty p.\\n\\t}\\n\\t// if we reached end of text and pattern is still left. \\n\\t// Try to see if p at or after this stage is only * or ** or *** etc. Only way to match an empty text.\\n\\telse if (tIdx == text.length()) {\\n\\t\\tmatch = pattern.charAt(pIdx) == \\'*\\' && dpMemo(tIdx, pIdx + 1, text, pattern);\\n\\n\\t}\\n\\t//  Here cuz text & pattern match atleast a char\\n\\telse if (text.charAt(tIdx) == pattern.charAt(pIdx) || pattern.charAt(pIdx) == \\'?\\') {\\n\\n\\t\\t// Match here if strs from next index onward also are a match. Delegate job to recursive func for latter.\\n\\t\\tmatch = dpMemo(tIdx + 1, pIdx + 1, text, pattern);\\n\\n\\t} \\n\\t// star either matches 0 or >=1 character\\n\\telse if (pattern.charAt(pIdx) == \\'*\\') {\\n\\t\\t// 1: When * matches an empty seq, it\\'s work is done. Hence, the next stage to check match for is w/o *.\\n\\t\\t// \\t  Also, there could be *s in line. So, consuming this *, could exhibit new p with next fresh *.\\n\\t\\t// 2: \\'*\\' can match seq of chars. Hence, * kept. Further rec stages could use it to match more chars/empty.\\n\\t\\tmatch = dpMemo(tIdx, pIdx + 1, text, pattern) || dpMemo(tIdx + 1, pIdx, text, pattern);\\n\\t}\\n\\n\\treturn memo[tIdx][pIdx] = match;\\n}\\n\\n/*******************\\n * Approach 3: Bottom Up Tabulation: https://www.youtube.com/watch?v=3ZDZ-N0EPV0\\n * Bottom-up the smallest is (0, 0)\\n * \\n * \\t\\t\\t\\t|\\tdp[i-1][j-1]  if str[i] == pattern[j] || pattern[j] == \\'?\\'\\n * \\t\\t\\t\\t|\\t\\t\\t\\t\\t\\n * \\t\\t\\t\\t|\\tif pattern[j-1] == \\'*\\'\\n * dp[i][j] = \\t|\\t\\tdp[i][j-1] || dp[i-1][j]\\n * \\t\\t\\t\\t|\\t\\t\\t\\t\\t\\n * \\t\\t\\t\\t|\\tFalse\\n * \\n * Time Complexity : O(m * n)\\n * Space Complexity : O(m * n)\\n **********************************/\\n\\npublic boolean isMatchApproach3(String text, String pattern) {\\n\\n\\tint m = text.length();\\n\\tint n = pattern.length();\\n\\tboolean[][] dp = new boolean[m + 1][n + 1];\\n\\n\\tfor (int tIdx = 0; tIdx <= m; tIdx++) {\\n\\t\\tfor (int pIdx = 0; pIdx <= n; pIdx++) {\\n\\n\\t\\t\\t// empty strings match\\n\\t\\t\\tif (tIdx == 0 && pIdx == 0)\\n\\t\\t\\t\\tdp[tIdx][pIdx] = true;\\n\\n\\t\\t\\t// fill first row, empty text can match all * pattern\\n\\t\\t\\telse if (tIdx == 0)\\n\\t\\t\\t\\tdp[tIdx][pIdx] = pattern.charAt(pIdx - 1) == \\'*\\' && dp[tIdx][pIdx - 1] == true;\\n\\n\\t\\t\\t// Can\\'t have a non-empty text match an empty pattern.\\n\\t\\t\\telse if (pIdx == 0)\\n\\t\\t\\t\\tdp[tIdx][pIdx] = false;\\n\\n\\t\\t\\t// star either matches 0 or >=1 character\\n\\t\\t\\telse if (pattern.charAt(pIdx - 1) == \\'*\\')\\n\\t\\t\\t\\tdp[tIdx][pIdx] = dp[tIdx][pIdx - 1] || dp[tIdx - 1][pIdx];\\n\\n\\t\\t\\t//  Here cuz text & pattern match atleast a char\\n\\t\\t\\telse if (text.charAt(tIdx - 1) == pattern.charAt(pIdx - 1) || pattern.charAt(pIdx - 1) == \\'?\\')\\n\\t\\t\\t\\tdp[tIdx][pIdx] = dp[tIdx - 1][pIdx - 1];\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[m][n];\\n}\\n\\n/*\\n * Approach 4: Linear: Very tricky: https://leetcode.com/problems/wildcard-matching/discuss/17810/Linear-runtime-and-constant-space-solution\\n */\\npublic boolean isMatchApproach4(String text, String pattern) {\\n\\tint tIdx = 0, pIdx = 0, match = 0, starIdx = -1;\\n\\n\\twhile (tIdx < text.length()) {\\n\\t\\t// advancing both pointers\\n\\t\\tif (pIdx < pattern.length() && (pattern.charAt(pIdx) == \\'?\\' || text.charAt(tIdx) == pattern.charAt(pIdx))) {\\n\\t\\t\\ttIdx++;\\n\\t\\t\\tpIdx++;\\n\\t\\t}\\n\\t\\t// \\'*\\' found, only advancing pattern pointer\\n\\t\\telse if (pIdx < pattern.length() && pattern.charAt(pIdx) == \\'*\\') {\\n\\t\\t\\tstarIdx = pIdx;\\n\\t\\t\\tmatch = tIdx;\\n\\t\\t\\tpIdx++;\\n\\t\\t}\\n\\t\\t// last pattern pointer was *, advancing string pointer\\n\\t\\telse if (starIdx != -1) {\\n\\t\\t\\tpIdx = starIdx + 1;\\n\\t\\t\\tmatch++;\\n\\t\\t\\ttIdx = match;\\n\\t\\t}\\n\\t\\t//current pattern pointer is not star, last patter pointer was not *\\n\\t\\t//characters do not match\\n\\t\\telse\\n\\t\\t\\treturn false;\\n\\t}\\n\\n\\t//check for remaining characters in pattern\\n\\twhile (pIdx < pattern.length() && pattern.charAt(pIdx) == \\'*\\')\\n\\t\\tpIdx++;\\n\\n\\treturn pIdx == pattern.length();\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 667143,
                "title": "python3-top-down-dp",
                "content": "\\n```\\nfrom functools import lru_cache \\n\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        \\n        @lru_cache(None)\\n        def fn(i, j): \\n            \"\"\"Return True if s[i:] matches p[j:]\"\"\"\\n            if j == len(p): return i == len(s)\\n            if i < len(s) and (s[i] == p[j] or p[j] == \"?\"): return fn(i+1, j+1)\\n            if p[j] == \"*\": return fn(i, j+1) or i < len(s) and fn(i+1, j)\\n            return False \\n        \\n        return fn(0, 0)\\n```\\n\\nThis is similar to but easier than [10. Regular Expression Matching](https://leetcode.com/problems/regular-expression-matching/discuss/652563/Python3-top-down-dp).",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nfrom functools import lru_cache \\n\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        \\n        @lru_cache(None)\\n        def fn(i, j): \\n            \"\"\"Return True if s[i:] matches p[j:]\"\"\"\\n            if j == len(p): return i == len(s)\\n            if i < len(s) and (s[i] == p[j] or p[j] == \"?\"): return fn(i+1, j+1)\\n            if p[j] == \"*\": return fn(i, j+1) or i < len(s) and fn(i+1, j)\\n            return False \\n        \\n        return fn(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 617975,
                "title": "java-python-dp",
                "content": "```\\n    public boolean isMatch(String s, String p) {\\n        if (s == null || p == null) return false;\\n        int m = s.length(), n = p.length();\\n        if (n == 0) return m == 0;\\n        boolean[][] dp = new boolean[m + 1][n + 1];\\n        dp[0][0] = true;\\n        for (int i = 0; i < n; i++) {\\n            if (p.charAt(i) != \\'*\\') break;\\n            dp[0][i + 1] = true;\\n        }\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (p.charAt(j) == \\'?\\' || p.charAt(j) == s.charAt(i)) {\\n                    dp[i+1][j+1] = dp[i][j];\\n                } else if (p.charAt(j) == \\'*\\') {\\n                    dp[i+1][j+1] = dp[i+1][j] || dp[i][j+1];\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n```\\n\\n```\\nclass Solution(object):\\n    def isMatch(self, s, p):\\n        \"\"\"\\n        :type s: str\\n        :type p: str\\n        :rtype: bool\\n        \"\"\"\\n        ls = len(s)\\n        lp = len(p)\\n        if lp == 0: return ls == 0\\n        ss = i = j = 0\\n        star = -1\\n        while i < ls:\\n            if j < lp:\\n                if s[i] == p[j] or p[j] == \"?\":\\n                    i+=1\\n                    j+=1\\n                    continue\\n                elif p[j] == \"*\":\\n                    star = j\\n                    j = star +1\\n                    ss = i\\n                    continue\\n            if star != -1:\\n                j = star +1\\n                ss +=1\\n                i = ss\\n                continue\\n            return False\\n        while j < lp and p[j] == \"*\":\\n            j +=1\\n        return j == lp\\n            \\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean isMatch(String s, String p) {\\n        if (s == null || p == null) return false;\\n        int m = s.length(), n = p.length();\\n        if (n == 0) return m == 0;\\n        boolean[][] dp = new boolean[m + 1][n + 1];\\n        dp[0][0] = true;\\n        for (int i = 0; i < n; i++) {\\n            if (p.charAt(i) != \\'*\\') break;\\n            dp[0][i + 1] = true;\\n        }\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (p.charAt(j) == \\'?\\' || p.charAt(j) == s.charAt(i)) {\\n                    dp[i+1][j+1] = dp[i][j];\\n                } else if (p.charAt(j) == \\'*\\') {\\n                    dp[i+1][j+1] = dp[i+1][j] || dp[i][j+1];\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n```\n```\\nclass Solution(object):\\n    def isMatch(self, s, p):\\n        \"\"\"\\n        :type s: str\\n        :type p: str\\n        :rtype: bool\\n        \"\"\"\\n        ls = len(s)\\n        lp = len(p)\\n        if lp == 0: return ls == 0\\n        ss = i = j = 0\\n        star = -1\\n        while i < ls:\\n            if j < lp:\\n                if s[i] == p[j] or p[j] == \"?\":\\n                    i+=1\\n                    j+=1\\n                    continue\\n                elif p[j] == \"*\":\\n                    star = j\\n                    j = star +1\\n                    ss = i\\n                    continue\\n            if star != -1:\\n                j = star +1\\n                ss +=1\\n                i = ss\\n                continue\\n            return False\\n        while j < lp and p[j] == \"*\":\\n            j +=1\\n        return j == lp\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 534681,
                "title": "python-three-solutions-1-recursion-with-momerize-2-dp-3-finate-state-machine",
                "content": "I met a simpler version of this problem during Mircrosoft on-site interview. During the on-site, there is only one wildcard \\'?\\' and \\'?\\' means zero or one arbitrary charecter. I solved this simpler wildcard matching problem using recursion. Then I came to Leetcode to find the wildcard matching problem and I found this problem #44.\\n\\nHere I provide my three solutions\\n1. **Recursion with memorization**. Without memorization and some other pruning techniques, there will be Time Limit Exceeded. My memorization is inspired from this [post](https://leetcode.com/problems/wildcard-matching/discuss/17811/My-three-C%2B%2B-solutions-(iterative-(16ms)-and-DP-(180ms)-and-modified-recursion-(88ms))). The key is to notice the following. Let *s_sub* be a substring of *s*, and let *p_sub* be a substring of *p*. If *s_sub* and *p_sub* doesn\\'t match, then *s* and *p* doesn\\'t match.\\n2. **Dynamic programming**. My first attemp failed because I had issue defining the subproblem.  Bad definition: let dp[i][j] be {0, 1, 2, 3, 4, ...}, the longest length of substring that s[1, ..., i ] match p[1, ..., j ]. I stuggled a lot with this subproblem definition. Then I looked at the discussion and fixed the difinition. Good definition: let dp[i][j] be {0, 1}, where {0} means s[1, ..., i ] doesn\\'t match p[1, ..., j ], and {1} means s[1, ..., i ] match p[1, ..., j ]. Under this definition, I solve the problem.\\n3. **Finite state machine**. This is the most elegant solution. I like this solution the most. I am inspired from this [post](https://leetcode.com/problems/wildcard-matching/discuss/138878/Finite-state-machine-with-Python-and-dictionary.-13-lines-O(p%2Bs)-time). First build a finate state machine using the pattern p, then run the machine with the input string s.\\n\\n\\n```\\n\\nclass Solution:\\n    \\'\\'\\'Recursion solution -- with memorization. \\n\\t   Time beat 86%.\\n    \\'\\'\\'\\n    def __init__(self):\\n        self.memorize = []  # memorize the smaller substrings s[i:] and p[j:] that doesn\\'t match\\n\\n    def update_memorize(self, s, i, p, j):\\n        s_no_match_new = len(s) - i  # the last s_no_match charecters of s\\n        p_no_match_new = len(p) - j  # the last p_no_match charecters of p\\n        new_memorize = []\\n        keep_new = True\\n        for s_no_match_old, p_no_match_old in self.memorize:\\n            if s_no_match_old < s_no_match_new or p_no_match_old < p_no_match_new:\\n                new_memorize.append((s_no_match_old, p_no_match_old))\\n            if s_no_match_old < s_no_match_new and p_no_match_old < p_no_match_new:\\n                keep_new = False\\n        if keep_new:\\n            new_memorize.append((s_no_match_new, p_no_match_new))\\n        self.memorize = new_memorize\\n\\n    def check_memorize(self, s, i, p, j):\\n        prune = False\\n        s_sub_len = len(s) - i\\n        p_sub_len = len(p) - j\\n        for s_no_match, p_no_match in self.memorize:\\n            if s_sub_len >= s_no_match and p_sub_len >= p_no_match:\\n                prune = True  # when two smaller substrings of s[i:] and p[j:] don\\'t match, s[i:] and p[j:] is guaranteed not to match, so prune it\\n                break         # the  two smaller substrings here are the last s_no_match charecters of s and the last p_no_match charecters of p\\n        return prune\\n\\n    def isMatch_helper(self, s: str, p: str) -> bool:\\n        if len(s) == 0 and len(p) == 0:  # both match to the end\\n            return True\\n        if len(s) == 0 or len(p) == 0:   # one comes to the end but the other not\\n            return False\\n        if s[0] == p[0] or p[0] == \\'?\\':  # match\\n            return self.isMatch_helper(s[1:], p[1:])\\n        if s[0] != p[0] and p[0] == \\'*\\':\\n            i, j = 0, 0\\n            while j < len(p):            # j points to the first char that is not \\'*\\'\\n                if p[j] != \\'*\\':\\n                    break\\n                j += 1\\n            counter = 0\\n            for k in range(j+1, len(p)): # for pruning the search space for i\\n                if p[k] != \\'*\\':\\n                    counter += 1\\n            while i < len(s)-counter and j < len(p):\\n                if s[i] == p[j] or (s[i] != p[j] and p[j] == \\'?\\'):\\n                    if self.check_memorize(s, i, p, j):\\n                        return False\\n                    if self.isMatch_helper(s[i:], p[j:]):\\n                        return True\\n                    else:\\n                        self.update_memorize(s, i, p, j)\\n                i += 1\\n        return False                     # case for s[0] != p[0] and p[0] is not a wildcard:\\n\\n    def isMatch(self, s: str, p: str) -> bool:\\n        s = s + \\'1\\'\\n        p = p + \\'1\\'  # so that the last charecter is not \\'*\\'. Of course there are other ways to deal with it.\\n        return self.isMatch_helper(s, p)\\n\\n\\nclass Solution2:\\n    \\'\\'\\'DP solution, nice solution. First I defined the subproblem so that dp[i][j] are {0, 1, 2, 3...}, this way is somewhat hard, so failed\\n       The right way of defining the subproblem is that dp[i][j] is {True,False}.\\n\\t   Time beat 15%.\\n    \\'\\'\\'\\n    def isMatch(self, s: str, p: str) -> bool:\\n        m, n = len(s), len(p)\\n        dp = [[0 for _ in range(n+1)] for _ in range(m+1)]\\n        dp[0][0] = 1\\n        j = 1\\n        while j-1 < len(p):\\n            if p[j-1] != \\'*\\':\\n                break\\n            dp[0][j] = 1\\n            j += 1\\n        for i in range(1, m+1):\\n            for j in range(1, n+1):\\n                if s[i-1] == p[j-1] or p[j-1] == \\'?\\':\\n                    if dp[i-1][j-1]:              #  precise match\\n                        dp[i][j] = 1\\n                if s[i-1] != p[j-1] and p[j-1] == \\'*\\':\\n                    if dp[i][j-1] or dp[i-1][j]:  # \\'*\\' either {skip} or {matching more charecters}\\n                        dp[i][j] = 1\\n        return dp[m][n]\\n\\n\\nclass Solution3:\\n    \\'\\'\\'Finite state machine (FSM) solution. elegant\\n       reference: https://leetcode.com/problems/wildcard-matching/discuss/138878/Finite-state-machine-with-Python-and-dictionary.-13-lines-O(p%2Bs)-time\\n\\t   Time beat 77%.\\n    \\'\\'\\'\\n    def isMatch(self, s: str, p: str) -> bool:\\n        # step 1: build a FSM: 1) state 2) transition\\n        state = 0\\n        transition = {}\\n        for char in p:\\n            if char != \\'*\\':\\n                transition[(state, char)] = state + 1\\n                state += 1\\n            else:\\n                transition[(state, char)] = state\\n        final_state = state\\n        # step 2: start running the FSM\\n        states = set([0])\\n        for char in s:\\n            new_states = set()\\n            for state in states:\\n                for token in [char, \\'*\\', \\'?\\']:\\n                    next_state = transition.get((state, token))\\n                    if next_state is not None:\\n                        new_states.add(next_state)\\n            states = new_states\\n        return final_state in states\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution:\\n    \\'\\'\\'Recursion solution -- with memorization. \\n\\t   Time beat 86%.\\n    \\'\\'\\'\\n    def __init__(self):\\n        self.memorize = []  # memorize the smaller substrings s[i:] and p[j:] that doesn\\'t match\\n\\n    def update_memorize(self, s, i, p, j):\\n        s_no_match_new = len(s) - i  # the last s_no_match charecters of s\\n        p_no_match_new = len(p) - j  # the last p_no_match charecters of p\\n        new_memorize = []\\n        keep_new = True\\n        for s_no_match_old, p_no_match_old in self.memorize:\\n            if s_no_match_old < s_no_match_new or p_no_match_old < p_no_match_new:\\n                new_memorize.append((s_no_match_old, p_no_match_old))\\n            if s_no_match_old < s_no_match_new and p_no_match_old < p_no_match_new:\\n                keep_new = False\\n        if keep_new:\\n            new_memorize.append((s_no_match_new, p_no_match_new))\\n        self.memorize = new_memorize\\n\\n    def check_memorize(self, s, i, p, j):\\n        prune = False\\n        s_sub_len = len(s) - i\\n        p_sub_len = len(p) - j\\n        for s_no_match, p_no_match in self.memorize:\\n            if s_sub_len >= s_no_match and p_sub_len >= p_no_match:\\n                prune = True  # when two smaller substrings of s[i:] and p[j:] don\\'t match, s[i:] and p[j:] is guaranteed not to match, so prune it\\n                break         # the  two smaller substrings here are the last s_no_match charecters of s and the last p_no_match charecters of p\\n        return prune\\n\\n    def isMatch_helper(self, s: str, p: str) -> bool:\\n        if len(s) == 0 and len(p) == 0:  # both match to the end\\n            return True\\n        if len(s) == 0 or len(p) == 0:   # one comes to the end but the other not\\n            return False\\n        if s[0] == p[0] or p[0] == \\'?\\':  # match\\n            return self.isMatch_helper(s[1:], p[1:])\\n        if s[0] != p[0] and p[0] == \\'*\\':\\n            i, j = 0, 0\\n            while j < len(p):            # j points to the first char that is not \\'*\\'\\n                if p[j] != \\'*\\':\\n                    break\\n                j += 1\\n            counter = 0\\n            for k in range(j+1, len(p)): # for pruning the search space for i\\n                if p[k] != \\'*\\':\\n                    counter += 1\\n            while i < len(s)-counter and j < len(p):\\n                if s[i] == p[j] or (s[i] != p[j] and p[j] == \\'?\\'):\\n                    if self.check_memorize(s, i, p, j):\\n                        return False\\n                    if self.isMatch_helper(s[i:], p[j:]):\\n                        return True\\n                    else:\\n                        self.update_memorize(s, i, p, j)\\n                i += 1\\n        return False                     # case for s[0] != p[0] and p[0] is not a wildcard:\\n\\n    def isMatch(self, s: str, p: str) -> bool:\\n        s = s + \\'1\\'\\n        p = p + \\'1\\'  # so that the last charecter is not \\'*\\'. Of course there are other ways to deal with it.\\n        return self.isMatch_helper(s, p)\\n\\n\\nclass Solution2:\\n    \\'\\'\\'DP solution, nice solution. First I defined the subproblem so that dp[i][j] are {0, 1, 2, 3...}, this way is somewhat hard, so failed\\n       The right way of defining the subproblem is that dp[i][j] is {True,False}.\\n\\t   Time beat 15%.\\n    \\'\\'\\'\\n    def isMatch(self, s: str, p: str) -> bool:\\n        m, n = len(s), len(p)\\n        dp = [[0 for _ in range(n+1)] for _ in range(m+1)]\\n        dp[0][0] = 1\\n        j = 1\\n        while j-1 < len(p):\\n            if p[j-1] != \\'*\\':\\n                break\\n            dp[0][j] = 1\\n            j += 1\\n        for i in range(1, m+1):\\n            for j in range(1, n+1):\\n                if s[i-1] == p[j-1] or p[j-1] == \\'?\\':\\n                    if dp[i-1][j-1]:              #  precise match\\n                        dp[i][j] = 1\\n                if s[i-1] != p[j-1] and p[j-1] == \\'*\\':\\n                    if dp[i][j-1] or dp[i-1][j]:  # \\'*\\' either {skip} or {matching more charecters}\\n                        dp[i][j] = 1\\n        return dp[m][n]\\n\\n\\nclass Solution3:\\n    \\'\\'\\'Finite state machine (FSM) solution. elegant\\n       reference: https://leetcode.com/problems/wildcard-matching/discuss/138878/Finite-state-machine-with-Python-and-dictionary.-13-lines-O(p%2Bs)-time\\n\\t   Time beat 77%.\\n    \\'\\'\\'\\n    def isMatch(self, s: str, p: str) -> bool:\\n        # step 1: build a FSM: 1) state 2) transition\\n        state = 0\\n        transition = {}\\n        for char in p:\\n            if char != \\'*\\':\\n                transition[(state, char)] = state + 1\\n                state += 1\\n            else:\\n                transition[(state, char)] = state\\n        final_state = state\\n        # step 2: start running the FSM\\n        states = set([0])\\n        for char in s:\\n            new_states = set()\\n            for state in states:\\n                for token in [char, \\'*\\', \\'?\\']:\\n                    next_state = transition.get((state, token))\\n                    if next_state is not None:\\n                        new_states.add(next_state)\\n            states = new_states\\n        return final_state in states\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 316258,
                "title": "c-greedy-solutiuon-beats-99-51-with-o-1-space-chinese-detailed-comment",
                "content": "```\\n//Greedy Solution 20190621\\nclass Solution\\n{\\npublic:\\n\\tbool isMatch(string s,string p)\\n\\t{\\n\\t\\tint m = s.size();\\n\\t\\tint n = p.size();\\n\\t\\tint i = 0,j=0;\\n\\t\\tint matchI = -1,starJ = -1;\\n\\t\\t//\\u4F7F\\u7528\\u8D2A\\u5A6A\\u7B97\\u6CD5 *\\u5148\\u5339\\u914D0\\u4E2A\\u5B57\\u7B26\\uFF0C\\u4E0D\\u884C\\u518D\\u5339\\u914D1\\u4E2A\\u5B57\\u7B26\\uFF0C2\\u4E2A\\u5B57\\u7B26...\\n\\t\\twhile(i<m)\\n\\t\\t{\\n\\t\\t\\tif(j<n && p[j]==\\'*\\')\\n\\t\\t\\t{//\\u5982\\u679Cp\\u7684\\u5F53\\u524D\\u5B57\\u7B26\\u662F*,\\u5219*\\u5339\\u914D0\\u4E2A\\u5B57\\u7B26\\n\\t\\t\\t\\tmatchI = i;\\n\\t\\t\\t\\tstarJ = j;\\n\\t\\t\\t\\tj++;//*\\u5339\\u914D0\\u4E2A\\u5B57\\u7B26\\uFF0Cj\\u540E\\u79FB\\u4E0E\\u5F53\\u524Di\\u5339\\u914D\\n\\n\\t\\t\\t}\\n\\t\\t\\telse if(j<n &&(p[j] == \\'?\\' || p[j] == s[i]))\\n\\t\\t\\t{//\\u5982\\u679C\\u5F53\\u524D\\u5B57\\u7B26\\u5339\\u914D\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t\\telse if(starJ >-1)\\n\\t\\t\\t{//\\u5982\\u679Cp\\u5F53\\u524D\\u5B57\\u7B26\\u65E2\\u4E0D\\u662F*\\u4E5F\\u4E0D\\u5339\\u914D\\uFF0C\\u5219i j \\u56DE\\u9000\\u5230\\u4E0A\\u4E00\\u6B21\\u5339\\u914D\\u7684\\u4F4D\\u7F6E\\u7684\\u4E0B\\u4E00\\u4F4D\\u7F6E\\n\\t\\t\\t //\\u8FD9\\u91CCmatchI\\u8981+1\\uFF0C\\u8868\\u793A\\u5982\\u679C\\u4E0B\\u6B21\\u518D\\u8FDB\\u5165\\u8BE5\\u5206\\u652F\\u65F6,*\\u591A\\u5339\\u914D\\u4E00\\u4E2A\\u5B57\\u7B26\\uFF08\\u4F8B\\u5982\\u5F53\\u524D\\u5C1D\\u8BD5*\\u5339\\u914D\\u4E00\\u4E2A\\u5B57\\u7B26\\u4E0D\\u884C\\uFF0C\\u5219\\u540E\\u9762\\u5C1D\\u8BD5*\\u5339\\u914D\\u4E24\\u4E2A\\u5B57\\u7B26\\uFF09\\n\\t\\t\\t\\ti = matchI+1;\\n\\t\\t\\t\\tj = starJ+1;\\n\\t\\t\\t\\tmatchI++;//*\\u591A\\u5339\\u914D\\u4E00\\u4E2A\\u5B57\\u7B26\\n\\n\\t\\t\\t}\\n\\t\\t\\telse return false;\\n\\t\\t}\\n\\t\\t//\\u904D\\u5386\\u5269\\u4F59\\u7684p\\u4E2D\\u7684*\\u5B57\\u7B26\\n\\t\\twhile(j<n && p[j] == \\'*\\') j++;\\n\\n\\t\\t//p\\u540E\\u9762\\u5269\\u4F59\\u7684\\u5B57\\u7B26\\u662F\\u5426\\u5168\\u662F*\\n\\t\\treturn j ==n;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Greedy Solution 20190621\\nclass Solution\\n{\\npublic:\\n\\tbool isMatch(string s,string p)\\n\\t{\\n\\t\\tint m = s.size();\\n\\t\\tint n = p.size();\\n\\t\\tint i = 0,j=0;\\n\\t\\tint matchI = -1,starJ = -1;\\n\\t\\t//\\u4F7F\\u7528\\u8D2A\\u5A6A\\u7B97\\u6CD5 *\\u5148\\u5339\\u914D0\\u4E2A\\u5B57\\u7B26\\uFF0C\\u4E0D\\u884C\\u518D\\u5339\\u914D1\\u4E2A\\u5B57\\u7B26\\uFF0C2\\u4E2A\\u5B57\\u7B26...\\n\\t\\twhile(i<m)\\n\\t\\t{\\n\\t\\t\\tif(j<n && p[j]==\\'*\\')\\n\\t\\t\\t{//\\u5982\\u679Cp\\u7684\\u5F53\\u524D\\u5B57\\u7B26\\u662F*,\\u5219*\\u5339\\u914D0\\u4E2A\\u5B57\\u7B26\\n\\t\\t\\t\\tmatchI = i;\\n\\t\\t\\t\\tstarJ = j;\\n\\t\\t\\t\\tj++;//*\\u5339\\u914D0\\u4E2A\\u5B57\\u7B26\\uFF0Cj\\u540E\\u79FB\\u4E0E\\u5F53\\u524Di\\u5339\\u914D\\n\\n\\t\\t\\t}\\n\\t\\t\\telse if(j<n &&(p[j] == \\'?\\' || p[j] == s[i]))\\n\\t\\t\\t{//\\u5982\\u679C\\u5F53\\u524D\\u5B57\\u7B26\\u5339\\u914D\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t\\telse if(starJ >-1)\\n\\t\\t\\t{//\\u5982\\u679Cp\\u5F53\\u524D\\u5B57\\u7B26\\u65E2\\u4E0D\\u662F*\\u4E5F\\u4E0D\\u5339\\u914D\\uFF0C\\u5219i j \\u56DE\\u9000\\u5230\\u4E0A\\u4E00\\u6B21\\u5339\\u914D\\u7684\\u4F4D\\u7F6E\\u7684\\u4E0B\\u4E00\\u4F4D\\u7F6E\\n\\t\\t\\t //\\u8FD9\\u91CCmatchI\\u8981+1\\uFF0C\\u8868\\u793A\\u5982\\u679C\\u4E0B\\u6B21\\u518D\\u8FDB\\u5165\\u8BE5\\u5206\\u652F\\u65F6,*\\u591A\\u5339\\u914D\\u4E00\\u4E2A\\u5B57\\u7B26\\uFF08\\u4F8B\\u5982\\u5F53\\u524D\\u5C1D\\u8BD5*\\u5339\\u914D\\u4E00\\u4E2A\\u5B57\\u7B26\\u4E0D\\u884C\\uFF0C\\u5219\\u540E\\u9762\\u5C1D\\u8BD5*\\u5339\\u914D\\u4E24\\u4E2A\\u5B57\\u7B26\\uFF09\\n\\t\\t\\t\\ti = matchI+1;\\n\\t\\t\\t\\tj = starJ+1;\\n\\t\\t\\t\\tmatchI++;//*\\u591A\\u5339\\u914D\\u4E00\\u4E2A\\u5B57\\u7B26\\n\\n\\t\\t\\t}\\n\\t\\t\\telse return false;\\n\\t\\t}\\n\\t\\t//\\u904D\\u5386\\u5269\\u4F59\\u7684p\\u4E2D\\u7684*\\u5B57\\u7B26\\n\\t\\twhile(j<n && p[j] == \\'*\\') j++;\\n\\n\\t\\t//p\\u540E\\u9762\\u5269\\u4F59\\u7684\\u5B57\\u7B26\\u662F\\u5426\\u5168\\u662F*\\n\\t\\treturn j ==n;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 231702,
                "title": "java-clean-top-down-w-memo",
                "content": "`O(M*N)`\\n```\\nclass Solution {\\n    Boolean[][] memo;\\n   \\n    public boolean isMatch(String s, String p) {\\n        int M = s.length();\\n        int N = p.length();\\n        memo = new Boolean[M+1][N+1];\\n        return match(s, p, 0, 0);\\n    }\\n    \\n    private boolean match(String s, String p, int i, int j) {\\n        if (memo[i][j] != null) return memo[i][j];\\n        if (j == p.length()) {\\n            memo[i][j] = i == s.length();\\n            return memo[i][j];\\n        }\\n        \\n        char c = p.charAt(j);\\n        if (c == \\'*\\') {\\n            boolean skipStar = match(s, p, i, j+1);\\n            boolean useStar = i < s.length() && match(s, p, i+1, j);\\n            memo[i][j] = skipStar || useStar;\\n        } else if (c == \\'?\\') {\\n            memo[i][j] = i < s.length() && match(s, p, i+1, j+1);\\n        } else {\\n            memo[i][j] = i < s.length() && (s.charAt(i) == c) && match(s, p, i+1, j+1);\\n        }\\n        \\n        return memo[i][j];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Boolean[][] memo;\\n   \\n    public boolean isMatch(String s, String p) {\\n        int M = s.length();\\n        int N = p.length();\\n        memo = new Boolean[M+1][N+1];\\n        return match(s, p, 0, 0);\\n    }\\n    \\n    private boolean match(String s, String p, int i, int j) {\\n        if (memo[i][j] != null) return memo[i][j];\\n        if (j == p.length()) {\\n            memo[i][j] = i == s.length();\\n            return memo[i][j];\\n        }\\n        \\n        char c = p.charAt(j);\\n        if (c == \\'*\\') {\\n            boolean skipStar = match(s, p, i, j+1);\\n            boolean useStar = i < s.length() && match(s, p, i+1, j);\\n            memo[i][j] = skipStar || useStar;\\n        } else if (c == \\'?\\') {\\n            memo[i][j] = i < s.length() && match(s, p, i+1, j+1);\\n        } else {\\n            memo[i][j] = i < s.length() && (s.charAt(i) == c) && match(s, p, i+1, j+1);\\n        }\\n        \\n        return memo[i][j];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 209623,
                "title": "python-solutions-brute-force-bottom-up-top-down-backward-and-forward",
                "content": "##### Recurrence\\n```\\nT[i][j] = T[i-1][j-1] if s[i] == p[j] or p[j] == \\'?\\'\\nT[i][j] = T[i-1][j] || T[i][j-1] if p[j] == \\'*\\'\\nT[i][j] = False\\n```\\n##### Naive Recursive(Brute Force TLE)\\n```\\nclass Solution:\\n    def isMatch(self, s, p):\\n        if not p:\\n            return not s \\n        if not s:\\n            return p.count(\\'*\\') == len(p) \\n        if s[-1] == p[-1] or p[-1] == \\'?\\':\\n            return self.isMatch(s[:-1], p[:-1])\\n        if p[-1] == \\'*\\':\\n            return self.isMatch(s[:-1], p) or self.isMatch(s, p[:-1]) \\n        \\n        return False\\n```\\n\\n##### Bottom Up\\n```\\nclass Solution:\\n    def isMatch(self, s, p):\\n        m, n = len(s), len(p)\\n        dp = [[False] * (n+1) for _ in range(m+1)]\\n        dp[0][0] = True       \\n        for j in range(1, n+1):\\n            if p[j-1] == \\'*\\' and dp[0][j-1]:\\n                dp[0][j] = True\\n\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                if s[i-1] == p[j-1] or p[j-1] == \\'?\\':\\n                    dp[i][j] = dp[i-1][j-1]\\n                elif p[j-1] == \\'*\\':\\n                    dp[i][j] = dp[i][j-1] or dp[i-1][j]\\n        return dp[-1][-1]      \\n```\\n\\n##### Top Down\\n```\\nclass Solution:\\n    def isMatch(self, s, p):\\n        memo = {} \\n        def dfs(i, j):\\n            if (i, j) in memo: return memo[i, j]\\n            if j == len(p): return i == len(s) \\n            if i == len(s): return p[j:].count(\\'*\\') == j\\n            \\n            memo[i, j] = False\\n            if s[i] == p[j] or p[j] == \\'?\\':\\n                memo[i, j] = dfs(i+1, j+1)\\n            elif p[j] == \\'*\\':    \\n                memo[i, j] = dfs(i, j+1) or dfs(i+1, j)\\n            return memo[i, j]    \\n        return dfs(0, 0)\\n```\\n##### Another Top Down (Backwards)\\n```\\nclass Solution:\\n    def isMatch(self, s, p):\\n        memo = {} \\n        def dfs(l, r):\\n            if (l, r) in memo: return memo[l, r]\\n            if not r: return not l  \\n            if not l: return p[:r].count(\\'*\\') == r \\n            \\n            memo[l, r] = False\\n            if p[r-1] == \\'*\\':\\n                memo[l, r] = dfs(l-1, r) or dfs(l, r-1)    \\n            elif s[l-1] == p[r-1] or p[r-1] == \\'?\\':\\n                memo[l, r] = dfs(l-1, r-1)\\n            return memo[l, r] \\n        return dfs(len(s), len(p))\\n```\\n\\n##### Linear Time\\n```\\nclass Solution:\\n    def isMatch(self, s, p):\\n        si, pi = 0, 0\\n        last_si, last_pi = None, None\\n\\n        while si < len(s):\\n            if pi < len(p) and (s[si] == p[pi] or p[pi] == \\'?\\'):\\n                si += 1\\n                pi += 1\\n            elif pi < len(p) and p[pi] == \\'*\\':\\n                last_si = si + 1\\n                last_pi = pi + 1\\n                pi += 1\\n            elif last_pi:\\n                pi = last_pi\\n                si = last_si\\n                last_si += 1\\n            else:\\n                return False\\n\\n        return p[pi:].count(\\'*\\') == len(p) - pi\\n```",
                "solutionTags": [],
                "code": "```\\nT[i][j] = T[i-1][j-1] if s[i] == p[j] or p[j] == \\'?\\'\\nT[i][j] = T[i-1][j] || T[i][j-1] if p[j] == \\'*\\'\\nT[i][j] = False\\n```\n```\\nclass Solution:\\n    def isMatch(self, s, p):\\n        if not p:\\n            return not s \\n        if not s:\\n            return p.count(\\'*\\') == len(p) \\n        if s[-1] == p[-1] or p[-1] == \\'?\\':\\n            return self.isMatch(s[:-1], p[:-1])\\n        if p[-1] == \\'*\\':\\n            return self.isMatch(s[:-1], p) or self.isMatch(s, p[:-1]) \\n        \\n        return False\\n```\n```\\nclass Solution:\\n    def isMatch(self, s, p):\\n        m, n = len(s), len(p)\\n        dp = [[False] * (n+1) for _ in range(m+1)]\\n        dp[0][0] = True       \\n        for j in range(1, n+1):\\n            if p[j-1] == \\'*\\' and dp[0][j-1]:\\n                dp[0][j] = True\\n\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                if s[i-1] == p[j-1] or p[j-1] == \\'?\\':\\n                    dp[i][j] = dp[i-1][j-1]\\n                elif p[j-1] == \\'*\\':\\n                    dp[i][j] = dp[i][j-1] or dp[i-1][j]\\n        return dp[-1][-1]      \\n```\n```\\nclass Solution:\\n    def isMatch(self, s, p):\\n        memo = {} \\n        def dfs(i, j):\\n            if (i, j) in memo: return memo[i, j]\\n            if j == len(p): return i == len(s) \\n            if i == len(s): return p[j:].count(\\'*\\') == j\\n            \\n            memo[i, j] = False\\n            if s[i] == p[j] or p[j] == \\'?\\':\\n                memo[i, j] = dfs(i+1, j+1)\\n            elif p[j] == \\'*\\':    \\n                memo[i, j] = dfs(i, j+1) or dfs(i+1, j)\\n            return memo[i, j]    \\n        return dfs(0, 0)\\n```\n```\\nclass Solution:\\n    def isMatch(self, s, p):\\n        memo = {} \\n        def dfs(l, r):\\n            if (l, r) in memo: return memo[l, r]\\n            if not r: return not l  \\n            if not l: return p[:r].count(\\'*\\') == r \\n            \\n            memo[l, r] = False\\n            if p[r-1] == \\'*\\':\\n                memo[l, r] = dfs(l-1, r) or dfs(l, r-1)    \\n            elif s[l-1] == p[r-1] or p[r-1] == \\'?\\':\\n                memo[l, r] = dfs(l-1, r-1)\\n            return memo[l, r] \\n        return dfs(len(s), len(p))\\n```\n```\\nclass Solution:\\n    def isMatch(self, s, p):\\n        si, pi = 0, 0\\n        last_si, last_pi = None, None\\n\\n        while si < len(s):\\n            if pi < len(p) and (s[si] == p[pi] or p[pi] == \\'?\\'):\\n                si += 1\\n                pi += 1\\n            elif pi < len(p) and p[pi] == \\'*\\':\\n                last_si = si + 1\\n                last_pi = pi + 1\\n                pi += 1\\n            elif last_pi:\\n                pi = last_pi\\n                si = last_si\\n                last_si += 1\\n            else:\\n                return False\\n\\n        return p[pi:].count(\\'*\\') == len(p) - pi\\n```",
                "codeTag": "Java"
            },
            {
                "id": 198794,
                "title": "dp-ruby-and-compiled-explanation-with-example-from-leetcode-forum",
                "content": "```ruby\\n# @param {String} s\\n# @param {String} p\\n# @return {Boolean}\\ndef is_match(s, p)\\n    m, n = s.length, p.length\\n    dp = Array.new(m + 1) { Array.new(n + 1, false) }\\n    dp[0][0] = true\\n\\n    1.upto(n) do |j|\\n        dp[0][j] = dp[0][j - 1] if p[j - 1] == \\'*\\'\\n    end\\n\\n    1.upto(m) do |i|\\n        1.upto(n) do |j|\\n            dp[i][j] = dp[i - 1][j - 1] if p[j - 1] == s[i - 1] || p[j - 1] == \\'?\\'\\n            dp[i][j] = dp[i - 1][j] || dp[i][j - 1] if p[j - 1] == \\'*\\'\\n        end\\n    end\\n\\n    dp[m][n]\\nend\\n\\n# 44. Wildcard Matching\\n# https://leetcode.com/problems/wildcard-matching/\\n\\n# 1. dp[i][j]: represents a match between s[0 to i - 1] (len i) and p[0 to j - 1] (len j)\\n# 2. Base case:\\n#     - origin: dp[0][0]: they do match, so dp[0][0] = true\\n#     - first row: dp[0][j]: except for String p starts with *, otherwise all false\\n#     - first col: dp[i][0]: can\\'t match when p is empty. All false.\\n# 3. Recursion:\\n#     - Iterate through every dp[i][j]\\n#     - dp[i][j] = true:\\n#         - if (s[i - 1] == p[j - 1] || p[j - 1] == \\'?\\') && dp[i - 1][j - 1] == true\\n#         - elif p[j - 1] == \\'*\\' && (dp[i-1][j] == true || dp[i][j-1] == true)\\n\\n# dp[i-1][j] represents the match between s[0 to i - 2] (len i - 1) and p[0 to j - 1] (len j) [1 less char in s]\\n# dp[i][j-1] represents the match between s[0 to i - 1] (len i) and p[0 to j - 2] (len j - 1) [1 less char in p]\\n\\n# Example:\\n# S: xxx\\n# P: xx*\\n#   \\'\\' x x *\\n# \\'\\' T F F F\\n#  x F T F F\\n#  x F F T T\\n#  x F F F T\\n\\n# For i=3, j=3: s[i] is x, p[i] is *\\n# dp[3][3] = dp[2][3] || dp[3][2]\\n# dp[2][3] means we use the match from s: xx and p: xx* (notice 1 less char in s)\\n# dp[3][2] means we use the match from s: xxx and p: xx (notice 1 less char in p)\\n# dp[2][3] is true hence this ends up being a match\\n\\n# Time: O(m * n)\\n# Space: O(m * n)\\n\\nrequire \\'test/unit\\'\\nextend Test::Unit::Assertions\\n\\nassert_equal(is_match(\\'aa\\', \\'a\\'), false)\\nassert_equal(is_match(\\'ab\\', \\'*\\'), true)\\nassert_equal(is_match(\\'abcd\\', \\'*\\'), true)\\nassert_equal(is_match(\\'adceb\\', \\'*a*b\\'), true)\\nassert_equal(is_match(\\'acdcb\\', \\'a*c?b\\'), false)\\nassert_equal(is_match(\\'xb\\', \\'xa*\\'), false)\\nassert_equal(is_match(\\'xa\\', \\'xa*\\'), true)\\n```",
                "solutionTags": [],
                "code": "```ruby\\n# @param {String} s\\n# @param {String} p\\n# @return {Boolean}\\ndef is_match(s, p)\\n    m, n = s.length, p.length\\n    dp = Array.new(m + 1) { Array.new(n + 1, false) }\\n    dp[0][0] = true\\n\\n    1.upto(n) do |j|\\n        dp[0][j] = dp[0][j - 1] if p[j - 1] == \\'*\\'\\n    end\\n\\n    1.upto(m) do |i|\\n        1.upto(n) do |j|\\n            dp[i][j] = dp[i - 1][j - 1] if p[j - 1] == s[i - 1] || p[j - 1] == \\'?\\'\\n            dp[i][j] = dp[i - 1][j] || dp[i][j - 1] if p[j - 1] == \\'*\\'\\n        end\\n    end\\n\\n    dp[m][n]\\nend\\n\\n# 44. Wildcard Matching\\n# https://leetcode.com/problems/wildcard-matching/\\n\\n# 1. dp[i][j]: represents a match between s[0 to i - 1] (len i) and p[0 to j - 1] (len j)\\n# 2. Base case:\\n#     - origin: dp[0][0]: they do match, so dp[0][0] = true\\n#     - first row: dp[0][j]: except for String p starts with *, otherwise all false\\n#     - first col: dp[i][0]: can\\'t match when p is empty. All false.\\n# 3. Recursion:\\n#     - Iterate through every dp[i][j]\\n#     - dp[i][j] = true:\\n#         - if (s[i - 1] == p[j - 1] || p[j - 1] == \\'?\\') && dp[i - 1][j - 1] == true\\n#         - elif p[j - 1] == \\'*\\' && (dp[i-1][j] == true || dp[i][j-1] == true)\\n\\n# dp[i-1][j] represents the match between s[0 to i - 2] (len i - 1) and p[0 to j - 1] (len j) [1 less char in s]\\n# dp[i][j-1] represents the match between s[0 to i - 1] (len i) and p[0 to j - 2] (len j - 1) [1 less char in p]\\n\\n# Example:\\n# S: xxx\\n# P: xx*\\n#   \\'\\' x x *\\n# \\'\\' T F F F\\n#  x F T F F\\n#  x F F T T\\n#  x F F F T\\n\\n# For i=3, j=3: s[i] is x, p[i] is *\\n# dp[3][3] = dp[2][3] || dp[3][2]\\n# dp[2][3] means we use the match from s: xx and p: xx* (notice 1 less char in s)\\n# dp[3][2] means we use the match from s: xxx and p: xx (notice 1 less char in p)\\n# dp[2][3] is true hence this ends up being a match\\n\\n# Time: O(m * n)\\n# Space: O(m * n)\\n\\nrequire \\'test/unit\\'\\nextend Test::Unit::Assertions\\n\\nassert_equal(is_match(\\'aa\\', \\'a\\'), false)\\nassert_equal(is_match(\\'ab\\', \\'*\\'), true)\\nassert_equal(is_match(\\'abcd\\', \\'*\\'), true)\\nassert_equal(is_match(\\'adceb\\', \\'*a*b\\'), true)\\nassert_equal(is_match(\\'acdcb\\', \\'a*c?b\\'), false)\\nassert_equal(is_match(\\'xb\\', \\'xa*\\'), false)\\nassert_equal(is_match(\\'xa\\', \\'xa*\\'), true)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 186283,
                "title": "o-mn-simple-dp-python-with-explanation",
                "content": "Almost same problem is 10 Regular Expression Matching. \\nIdea: Each entry in the dp table represents if the pattern (p) up to j matches the string (s) up to i. \\nInitialize with an extra e in front to represent the empty string. \\n\\t1. if p empty, then everything except s == \"\" doesn\\'t work so leave False\\n\\t2. if s empty, then p == \"\" so only empty string and \\'\\'s work\\nMain body:\\n\\t1. if s[i] == p[j] or the \\'?\\', then the current character is equal to the boolean in the diagonal top left. Why? its like ur peeling the outer char\\n\\t\\t\\tEx. s = \\'ab\\' p = \\'ab\\'. Then when i and j are 1 and have same char, it is only true if \\n\\t\\t\\t       s= \\'a\\' and p = \\'a\\'. Only true if previous string and pattern matched\\n 2. if p[j] == \\'\\', Then you can do OR of diagonal, left or top.\\n     - left handles when u add one more char for the * to hold\\n\\t\\t - diagonal is same as before\\n\\t\\t - top because * can be empty string and maybe it isn\\'t even counted\\n```\\ndef isMatch(self, s, p):\\n        \"\"\"\\n        :type s: str\\n        :type p: str\\n        :rtype: bool\\n        \"\"\"\\n        s,p = \\'e\\' + s, \\'e\\' + p    # e is for empty string\\n        n = len(s)\\n        m = len(p)\\n        dp = [[False] * m for _ in range(n)]\\n        dp[0][0] = True\\n        \\n        # initialize the first row.\\n        for j in range(1, m):\\n            if p[j] == \\'*\\':\\n                dp[0][j] = dp[0][j-1] \\n                \\n        # First column is already all False \\n        \\n        for i in range(1,n):\\n            for j in range(1,m):\\n                if s[i] == p[j] or p[j] == \\'?\\':\\n                    dp[i][j] = dp[i-1][j-1]\\n                elif p[j] == \\'*\\':\\n                    dp[i][j] = dp[i-1][j-1] or dp[i][j-1] or dp[i-1][j]\\n        return dp[-1][-1]\\n\\t\\t\\t\\t````",
                "solutionTags": [],
                "code": "```\\ndef isMatch(self, s, p):\\n        \"\"\"\\n        :type s: str\\n        :type p: str\\n        :rtype: bool\\n        \"\"\"\\n        s,p = \\'e\\' + s, \\'e\\' + p    # e is for empty string\\n        n = len(s)\\n        m = len(p)\\n        dp = [[False] * m for _ in range(n)]\\n        dp[0][0] = True\\n        \\n        # initialize the first row.\\n        for j in range(1, m):\\n            if p[j] == \\'*\\':\\n                dp[0][j] = dp[0][j-1] \\n                \\n        # First column is already all False \\n        \\n        for i in range(1,n):\\n            for j in range(1,m):\\n                if s[i] == p[j] or p[j] == \\'?\\':\\n                    dp[i][j] = dp[i-1][j-1]\\n                elif p[j] == \\'*\\':\\n                    dp[i][j] = dp[i-1][j-1] or dp[i][j-1] or dp[i-1][j]\\n        return dp[-1][-1]\\n\\t\\t\\t\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 149826,
                "title": "why-you-don-t-need-to-backtrack-to-an-earlier-asterisk-if-you-find-a-later-asterisk",
                "content": "```\\nclass Solution {\\npublic:\\n    bool matchForward(string& s, string& p, int s_i, int p_i, int& star) {\\n        while(s_i < s.size() && p_i < p.size() && (s[s_i] == p[p_i] || p[p_i] == \\'?\\'))\\n            s_i++, p_i++;\\n        if(p_i >= p.size() && s_i >= s.size())\\n            return true;\\n        if(p_i < p.size() && p[p_i] == \\'*\\') {\\n            star = p_i;\\n            while(s_i <= s.size()) {\\n                if(matchForward(s, p, s_i, p_i+1, star))\\n                    return true;\\n                if(star > p_i)\\n                    return false;\\n                s_i++;\\n            }\\n        }\\n        return false;\\n    }\\n    bool isMatch(string s, string p) {\\n        if(p.empty()) {\\n            if(s.empty())\\n                return true;\\n            else\\n                return false;\\n        }\\n        int star = -1;\\n        return matchForward(s, p, 0, 0, star);\\n    }\\n};\\n```\\n\\nYou can solve wildcard matching iteratively or recursively. They\\'re basically the same, but how you visualize the problem MIGHT be a little different. The solution above uses recursion and backtracks to the furthest found asterisk * character.\\n\\nObjective:\\nBasically, you have two strings. You have string s, which is any possible string, and you also have string p, which based on the rules of wildcard matching, may match with string s. This is the objective of the problem, using the rules of wildcard matching, does your \"pattern string\" p match with the string s.\\n\\nHow the solution works:\\nFor this particular solution, you want to match characters in string p with the characters in string s. You iterate through both strings, starting from the first position of both strings, and match the characters one by one. When the characters match, you look at the next characters of both p and s and see if they match. The \\'?\\' in string p will match with any character in s, you can basically treat it as if characters in p and s match. If you find two characters that don\\'t match, then basically the two strings don\\'t match. So you would immediately return false. If you find that all the previous characters matched, and you have no more characters of p or s to match, then that means p matches with s.\\n\\nBut there is the special case where you may come across an asterisk, or the * character. This could stand for any number of characters in s while only standing for a single character in p (the asterisk). So how do you handle this case? Say you come across an asterisk in p. Record the current positions of s and p, in case you have to go back. To start, basically start with matching the asterisk in p to none of the characters in s, in other words, just skip the asterisk, and continue matching the characters of s and p. If you find a character of p, and it doesn\\'t match with s, then go back to those previously recorded positions, and now match one more character of s to the asterisk in p than you did before (so the recorded position of s is now one position further than it was before), and test if the remaining characters of s, and the characters in p after the asterisk match. Again, if we find that there\\'s a single character in p that doesn\\'t match with s later in the algorithm, then we go back to the position of the asterisk and match one more character in s than we did previously. We keep doing this until either all subsequent characters in p match with s (if they all match, return true), or we run out of characters in s to match with the rest of the characters in p. We may possibly match all the characters in p to s, and not have enough characters in p left to cover the rest of s, but if p has just one asterisk, this doesn\\'t happen since we will end up eventually matching all the remaining characters of s with the asterisk in p, and if there are any remaining characters in p, then we know that p cannot match with s.\\n\\n**But, here\\'s the tricky part.** What if there\\'s more than one asterisk in p? If we come to another asterisk in p, and we find that the matching fails, do we need to go all the way back to the previous asterisk and try again? How about if there are multiple asterisks? Do we need to keep trying every previous asterisk?\\n\\nWell, the trick is, you only need to worry about the latest asterisk that you encounter. If you find that p does not match with s using the latest asterisk, then there\\'s no need to check the previous ones. This is simply because the latest asterisk we found can match any number of characters in s, and we only need to worry about matching the remaining characters in p *after* the latest asterisk we have just found. There\\'s no way using a previous asterisk in p to match more characters in s is going to help, because that decreases the number of characters in s available that p can match with, it\\'s better to match more characters of p and use the last asterisk we find, because then we only need to worry about a fewer number of characters in p that we need to match with s. **If you backtrack to all previous asterisk characters of p, then you will get TLE because by backtracking to previous asterisks, the complexity tends to be more polynomial in the number of asterisk.**\\n\\nThis solution is O(nxm) where n is the size of s and m is the size of p. To understand why, we need to imagine a string s and string p that makes our algorithm run in the longest possible way. That would basically be having a single asterisk in the beginning of p, and having the pattern after the asterisk in p *almost* match with s. That could be as follows:\\n\\ns = qqqqqqqqqqq\\np = *qqqm\\n\\nThis is going to be O(nxm) because, that asterisk in the beginning of string p is going to be matched with all the characters of s, eventually. That asterisk will first stand for no characters, and we will iterate through all characters of p (matching them with characters of s) until we see the \\'m\\' character, which will cause the algorithm to come all the way back to the asterisk (because \\'m\\' cannot match with any character in string s, and it\\'s at the very end of string p). When we come back to the asterisk, the algorithm will match one of the \\'q\\' characters in s, and again try to match the remaining characters of s and p. Then we will again match all the characters in p to s until we get to the \\'m\\' character again, then have to go all the way back again to the asterisk and match two of the \\'q\\' in s with the asterisk in p. So we iterate through all the characters of p every time we match another \\'q\\' in s with the asterisk in p. So, for every character in s, we iterate through all the characters of p, and this works out to O(nxm).",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool matchForward(string& s, string& p, int s_i, int p_i, int& star) {\\n        while(s_i < s.size() && p_i < p.size() && (s[s_i] == p[p_i] || p[p_i] == \\'?\\'))\\n            s_i++, p_i++;\\n        if(p_i >= p.size() && s_i >= s.size())\\n            return true;\\n        if(p_i < p.size() && p[p_i] == \\'*\\') {\\n            star = p_i;\\n            while(s_i <= s.size()) {\\n                if(matchForward(s, p, s_i, p_i+1, star))\\n                    return true;\\n                if(star > p_i)\\n                    return false;\\n                s_i++;\\n            }\\n        }\\n        return false;\\n    }\\n    bool isMatch(string s, string p) {\\n        if(p.empty()) {\\n            if(s.empty())\\n                return true;\\n            else\\n                return false;\\n        }\\n        int star = -1;\\n        return matchForward(s, p, 0, 0, star);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 145515,
                "title": "python-backtracking-beat-100",
                "content": "```\\ndef isMatch(s,p):\\n    i,j,s_star,p_star = 0,0,0,-1\\n    while i<len(s):\\n        if j<len(p) and (s[i]==p[j] or p[j]==\\'?\\'):\\n            i,j = i+1,j+1\\n        elif j<len(p) and p[j]==\\'*\\':\\n            s_star,p_star = i,j\\n            j+=1\\n        elif p_star!=-1:\\n            s_star +=1\\n            i,j = s_star,p_star+1\\n        else:\\n            return False\\n    \\n    \\n    while j<len(p) and p[j]==\\'*\\':\\n        j+=1\\n    return True if j==len(p) else False\\n\\n```\\ncredit to http://yucoding.blogspot.com/2013/02/leetcode-question-123-wildcard-matching.html",
                "solutionTags": [],
                "code": "```\\ndef isMatch(s,p):\\n    i,j,s_star,p_star = 0,0,0,-1\\n    while i<len(s):\\n        if j<len(p) and (s[i]==p[j] or p[j]==\\'?\\'):\\n            i,j = i+1,j+1\\n        elif j<len(p) and p[j]==\\'*\\':\\n            s_star,p_star = i,j\\n            j+=1\\n        elif p_star!=-1:\\n            s_star +=1\\n            i,j = s_star,p_star+1\\n        else:\\n            return False\\n    \\n    \\n    while j<len(p) and p[j]==\\'*\\':\\n        j+=1\\n    return True if j==len(p) else False\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 17838,
                "title": "from-normal-dp-solution-to-an-optimised-and-then-the-best-in-c",
                "content": "    //AC - 112ms - a typical DP solution;\\n    bool isMatch(char* s, char* p)\\n    {\\n        int sLen=strlen(s), pLen=strlen(p);\\n        sLen++, pLen++;\\n        bool **match = (bool**)malloc(sizeof(bool*)*sLen);\\n        for(int i = 0; i < sLen; i++)\\n            match[i] = (bool*)malloc(sizeof(bool)*pLen);\\n        match[sLen-1][pLen-1] = true;\\n        for(int i = pLen-2; i > -1; i--)\\n            if(p[i] != '*')\\n                break;\\n            else\\n                match[sLen-1][i] = true;\\n        for(int i = sLen-2; i > -1; i--)\\n            for(int j = pLen-2; j > -1; j--)\\n            {\\n                if(s[i]==p[j] || p[j]=='?')\\n                    match[i][j] = match[i+1][j+1];\\n                else if(p[j] == '*')\\n                    match[i][j] = match[i+1][j] || match[i][j+1];\\n                else\\n                    match[i][j] = false;\\n            }\\n        return **match; \\n    }\\n\\n\\n----------\\n\\nAn optimised DP\\n\\n\\n----------\\n\\n    //AC - 28ms - DP solution;\\n    bool isMatch(char* s, char* p)\\n    {\\n        int sLen=strlen(s), pLen=strlen(p);\\n        int count = 0;\\n        for(int i = 0; i < pLen; i++)\\n            if(p[i] == '*') count++;\\n        if((count==0 && pLen!=sLen) || (pLen-count>sLen)) return false;\\n        bool *match = (bool*)malloc(sizeof(bool)*(sLen+1));\\n        memset(match, 0, sizeof(bool)*(sLen+1));\\n        match[0] = true;\\n        for(int i = 0; i < pLen; i++)\\n        {\\n            if(p[i] == '*')\\n            {\\n                for(int j = 1; j <= sLen; j++)\\n                    match[j] = match[j-1] || match[j];\\n            }\\n            else\\n            {\\n                for(int j = sLen; j > 0; j--)\\n                    match[j] = (p[i] == '?' || p[i] == s[j-1]) && match[j-1];\\n                match[0] = false;\\n            }\\n        }\\n        return match[sLen];\\n    }\\n\\n\\n----------\\n\\n> The BEST\\n\\n\\n----------\\n\\n    bool isMatch(char* s, char* p)\\n    {\\n        const char *pA = NULL, *sA = NULL;\\n        while(*s)\\n        {\\n            if(*p=='?' || *s==*p){p++, s++; continue;}\\n            if(*p=='*'){pA=p++, sA=s; continue;}\\n            if(pA){p=pA+1, s=++sA; continue;}\\n            return false;\\n        }\\n        while(*p=='*') p++;\\n        return !*p;\\n    }",
                "solutionTags": [],
                "code": "    //AC - 112ms - a typical DP solution;\\n    bool isMatch(char* s, char* p)\\n    {\\n        int sLen=strlen(s), pLen=strlen(p);\\n        sLen++, pLen++;\\n        bool **match = (bool**)malloc(sizeof(bool*)*sLen);\\n        for(int i = 0; i < sLen; i++)\\n            match[i] = (bool*)malloc(sizeof(bool)*pLen);\\n        match[sLen-1][pLen-1] = true;\\n        for(int i = pLen-2; i > -1; i--)\\n            if(p[i] != '*')\\n                break;\\n            else\\n                match[sLen-1][i] = true;\\n        for(int i = sLen-2; i > -1; i--)\\n            for(int j = pLen-2; j > -1; j--)\\n            {\\n                if(s[i]==p[j] || p[j]=='?')\\n                    match[i][j] = match[i+1][j+1];\\n                else if(p[j] == '*')\\n                    match[i][j] = match[i+1][j] || match[i][j+1];\\n                else\\n                    match[i][j] = false;\\n            }\\n        return **match; \\n    }\\n\\n\\n----------\\n\\nAn optimised DP\\n\\n\\n----------\\n\\n    //AC - 28ms - DP solution;\\n    bool isMatch(char* s, char* p)\\n    {\\n        int sLen=strlen(s), pLen=strlen(p);\\n        int count = 0;\\n        for(int i = 0; i < pLen; i++)\\n            if(p[i] == '*') count++;\\n        if((count==0 && pLen!=sLen) || (pLen-count>sLen)) return false;\\n        bool *match = (bool*)malloc(sizeof(bool)*(sLen+1));\\n        memset(match, 0, sizeof(bool)*(sLen+1));\\n        match[0] = true;\\n        for(int i = 0; i < pLen; i++)\\n        {\\n            if(p[i] == '*')\\n            {\\n                for(int j = 1; j <= sLen; j++)\\n                    match[j] = match[j-1] || match[j];\\n            }\\n            else\\n            {\\n                for(int j = sLen; j > 0; j--)\\n                    match[j] = (p[i] == '?' || p[i] == s[j-1]) && match[j-1];\\n                match[0] = false;\\n            }\\n        }\\n        return match[sLen];\\n    }\\n\\n\\n----------\\n\\n> The BEST\\n\\n\\n----------\\n\\n    bool isMatch(char* s, char* p)\\n    {\\n        const char *pA = NULL, *sA = NULL;\\n        while(*s)\\n        {\\n            if(*p=='?' || *s==*p){p++, s++; continue;}\\n            if(*p=='*'){pA=p++, sA=s; continue;}\\n            if(pA){p=pA+1, s=++sA; continue;}\\n            return false;\\n        }\\n        while(*p=='*') p++;\\n        return !*p;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 17897,
                "title": "14-line-python-solution-beats-78-82",
                "content": "    def isMatch(self, s, p):\\n        i, j, star_match_pos, last_star_pos, len_s, len_p = 0, 0, 0, -1, len(s), len(p)\\n        while i < len_s:\\n            if j < len_p and p[j] in (s[i], '?'):\\n                i, j = i + 1, j + 1\\n            # when meet a '*', first assume it will match 0 character in s\\n            elif j < len_p and p[j] == '*':\\n                star_match_pos, last_star_pos = i, j\\n                j += 1\\n            # now p[j] is not ?, not *, can't match s[i], we can only use the last '*'\\n            elif last_star_pos > -1:\\n                i, star_match_pos = star_match_pos + 1, star_match_pos + 1\\n                j = last_star_pos + 1\\n            else:\\n                return False\\n        while j < len_p and p[j] == '*': j += 1\\n        return j == len_p",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def isMatch(self, s, p):\\n        i, j, star_match_pos, last_star_pos, len_s, len_p = 0, 0, 0, -1, len(s), len(p)\\n        while i < len_s:\\n            if j < len_p and p[j] in (s[i], '?'):\\n                i, j = i + 1, j + 1\\n            # when meet a '*', first assume it will match 0 character in s\\n            elif j < len_p and p[j] == '*':\\n                star_match_pos, last_star_pos = i, j\\n                j += 1\\n            # now p[j] is not ?, not *, can't match s[i], we can only use the last '*'\\n            elif last_star_pos > -1:\\n                i, star_match_pos = star_match_pos + 1, star_match_pos + 1\\n                j = last_star_pos + 1\\n            else:\\n                return False\\n        while j < len_p and p[j] == '*': j += 1\\n        return j == len_p",
                "codeTag": "Python3"
            },
            {
                "id": 17917,
                "title": "python-dp-solution-avoid-tle-o-m-n-time-o-n-space",
                "content": "    class Solution(object):\\n    def isMatch(self, s, p):\\n        m, n = len(s), len(p)\\n        if n - p.count('*') > m:   #avoid TLE\\n            return False\\n        dp = [False] * (n + 1)\\n        for i in xrange(m + 1):\\n            pre, dp[0] = dp[0], i == 0\\n            for j in xrange(1, n + 1):\\n                temp = dp[j]\\n                if p[j-1] == '*':\\n                    dp[j] = pre or dp[j-1] or dp[j]\\n                else:\\n                    dp[j] = pre and (p[j-1] in [s[i-1], '?'] ) \\n                pre = temp\\n        return dp[-1]",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "    class Solution(object):\\n    def isMatch(self, s, p):\\n        m, n = len(s), len(p)\\n        if n - p.count('*') > m:   #avoid TLE\\n            return False\\n        dp = [False] * (n + 1)\\n        for i in xrange(m + 1):\\n            pre, dp[0] = dp[0], i == 0\\n            for j in xrange(1, n + 1):\\n                temp = dp[j]\\n                if p[j-1] == '*':\\n                    dp[j] = pre or dp[j-1] or dp[j]\\n                else:\\n                    dp[j] = pre and (p[j-1] in [s[i-1], '?'] ) \\n                pre = temp\\n        return dp[-1]",
                "codeTag": "Java"
            },
            {
                "id": 17916,
                "title": "java-dfa-solution-with-better-structure-and-easy-understand",
                "content": "    public boolean isMatch(String s, String p) {return matchHere(s,p,0,0);\\n    }\\n\\n    private boolean matchHere(String s, String p, int indexS, int indexP){\\n        if(indexS>=s.length()){\\n            return isPatternTailingMatch(p,indexP);\\n        }\\n        if(indexP>=p.length()){\\n            return isPatternEndWithWildCard(p);\\n        }\\n        if(s.charAt(indexS)==p.charAt(indexP)||p.charAt(indexP)=='?'){\\n            return matchHere(s,p,indexS+1,indexP+1);\\n        }\\n        else if(p.charAt(indexP)=='*'){\\n            return matchWildCard(s,p,++indexS,indexP+1);\\n        }\\n        return false;\\n    }\\n    private boolean isPatternTailingMatch(String p, int indexP){\\n        for(int index=indexP; index<p.length();index++){\\n            if(p.charAt(index)!='*'){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    private boolean isPatternEndWithWildCard(String p){\\n        return p.endsWith(\"*\");\\n    }\\n    private boolean matchWildCard(String s, String p, int indexS, int indexP){\\n        for(int index=indexS;index<s.length();index++){\\n            if(matchHere(s,p,index,indexP)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public boolean isMatch(String s, String p) {return matchHere(s,p,0,0);\\n    }\\n\\n    private boolean matchHere(String s, String p, int indexS, int indexP){\\n        if(indexS>=s.length()){\\n            return isPatternTailingMatch(p,indexP);\\n        }\\n        if(indexP>=p.length()){\\n            return isPatternEndWithWildCard(p);\\n        }\\n        if(s.charAt(indexS)==p.charAt(indexP)||p.charAt(indexP)=='?'){\\n            return matchHere(s,p,indexS+1,indexP+1);\\n        }\\n        else if(p.charAt(indexP)=='*'){\\n            return matchWildCard(s,p,++indexS,indexP+1);\\n        }\\n        return false;\\n    }\\n    private boolean isPatternTailingMatch(String p, int indexP){\\n        for(int index=indexP; index<p.length();index++){\\n            if(p.charAt(index)!='*'){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    private boolean isPatternEndWithWildCard(String p){\\n        return p.endsWith(\"*\");\\n    }\\n    private boolean matchWildCard(String s, String p, int indexS, int indexP){\\n        for(int index=indexS;index<s.length();index++){\\n            if(matchHere(s,p,index,indexP)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3827509,
                "title": "0-n-space-solution-with-all-solutions",
                "content": "# **PLS UPVOTE MY SOLUTION IF YOPU LIKE AND COMMENT FOR ANY DISCUSSION**\\n\\n# Approach\\nsolvetab Function: This function uses the tabulation technique to find if the string s matches the wildcard pattern p. It initializes two vectors, prev and curr, of size p.length() + 1. These vectors are used to represent the DP table.\\n\\nBase Case Initialization: It sets prev[0] to true, representing an empty string matching an empty pattern.\\n\\nHandling the \\'\\' Characters at the Start of Pattern: It checks if the pattern starts with multiple \\'\\' characters. For each character in p from 1 to p.length(), it sets prev[j] to true if the pattern contains only \\'*\\' characters from the start.\\n\\nFilling DP Table: It iterates through each character in s and each character in p, starting from 1 to s.length() and 1 to p.length(). For each character, it checks two conditions:\\n\\nIf the characters are the same or if the pattern has a \\'?\\', it propagates the result from the previous diagonal position (prev[j-1]) to the current position (curr[j]).\\nIf the pattern has a \\'\\', it propagates the result from the previous row (prev[j]) or the previous column (curr[j-1]) to the current position (curr[j]), indicating that the \\'\\' can match either a single character in s or a sequence of characters.\\nFinal Result: After filling the DP table, the function returns the value at prev[p.length()], which indicates if the entire string s matches the entire wildcard pattern p.\\n\\nisMatch Function: This function serves as an interface to call the solvetab function. It takes the input strings s and p and calls solvetab(s, p) to find if s matches p\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(M*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n```\\n\\n# **TABULATION**\\n\\n# Approach\\nsolvetab Function: This function uses a tabulation (bottom-up) dynamic programming approach to find if s matches the wildcard pattern p. It initializes a 2D DP table dp of size (s.length() + 1) x (p.length() + 1) with all elements initialized to 0.\\n\\nBase Cases: It sets dp[0][0] to true, as an empty string matches an empty pattern. Then, it handles the case where the pattern starts with multiple \\'\\' characters. For each character in p from 1 to p.length(), it sets dp[0][j] to true if the pattern contains only \\'\\' characters from the start.\\n\\nFilling DP Table: It iterates through each character in s and each character in p, starting from 1 to s.length() and 1 to p.length(). For each character, it checks three conditions:\\n\\nIf the characters are the same or if the pattern has a \\'?\\', it propagates the result from the previous position (dp[i-1][j-1]) to the current position (dp[i][j]).\\nIf the pattern has a \\'\\', it propagates the result from the previous row (dp[i-1][j]) or the previous column (dp[i][j-1]) to the current position (dp[i][j]), indicating that the \\'\\' can match either a single character or a sequence of characters.\\nIf none of the above conditions match, it sets dp[i][j] to false, as the characters do not match.\\nFinal Result: After filling the DP table, the function returns the value at dp[s.length()][p.length()], which indicates if the entire string s matches the entire wildcard pattern p.\\n\\nisMatch Function: This function serves as an interface to call the solvetab function. It takes the input strings s and p and calls solvetab(s, p) to find if s matches p.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N*M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(N*M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n```\\nclass Solution {\\npublic:\\n\\nbool solvetab(string s, string p)\\n{\\n    vector<vector<int>>dp(s.length()+1,vector<int>(p.length()+1,0));\\n    dp[0][0]=true;\\n    for(int j=1;j<=p.length();j++)\\n    {\\n    bool flag= true;\\n        for(int k =1;k<=j;k++)\\n        {\\n            if(p[k-1]!=\\'*\\')\\n            {\\n                flag=false;\\n                break;\\n            }\\n        }\\n        dp[0][j]=flag;\\n    }\\n    for(int i =1;i<=s.length();i++)\\n    {\\n        for(int j =1;j<=p.length();j++)\\n        {\\n            if(p[j-1]==\\'?\\' || p[j-1]==s[i-1])\\n            {\\n                dp[i][j]=dp[i-1][j-1];\\n            }\\n            else if(p[j-1]==\\'*\\')\\n            {\\n              dp[i][j]=dp[i-1][j] || dp[i][j-1];\\n            }\\n            else\\n            {\\n                  dp[i][j]=false;\\n            }\\n        }\\n    }\\n    return dp[s.length()][p.length()];\\n}\\n\\n\\n\\n\\n    bool isMatch(string s, string p)\\n    {\\n       \\n        // return solve(s,p,s.length()-1,p.length()-1,dp);\\nreturn solvetab(s,p);\\n    }\\n};\\n```\\n\\n\\n# **MEMOIZATION**\\n# Approach\\nsolve Function: This recursive function is used to check if a substring of str starting from the first character to index i matches a substring of pattern starting from the first character to index j. The function takes the string str, the pattern pattern, the indices i and j, and a memoization table dp as input.\\n\\nBase Cases: The function first checks for base cases:\\n\\nIf both i and j are less than 0, it means both str and pattern are empty, so it returns true.\\nIf i is greater than or equal to 0 but j is less than 0, it means pattern is empty, so it returns false.\\nIf j is greater than or equal to 0 but i is less than 0, it checks if the remaining characters in pattern (from index 0 to j) are all \\'*\\' characters. If yes, it returns true; otherwise, it returns false.\\nMemoization: Before proceeding with the recursive calls, the function checks if the result for the current i and j has already been computed and stored in the memoization table dp. If so, it directly returns the precomputed value to avoid redundant calculations.\\n\\nRecursive Calls: If the base cases are not satisfied, the function checks for the following conditions:\\n\\nIf the current characters in str and pattern match (either the same character or \\'?\\' in the pattern), it makes a recursive call to solve with indices i-1 and j-1 to check the remaining substrings.\\nIf the current character in pattern is \\'*\\', it makes two recursive calls to solve:\\nOne with index i-1 and the same index j to check if the \\'*\\' matches a single character in str.\\nAnother with the same index i and index j-1 to check if the \\'*\\' matches a sequence of characters in str.\\nIf none of the above conditions match, it returns false, as the characters do not match.\\nMemoization Update: After the recursive calls, the function updates the memoization table dp with the result for the current i and j and returns the result.\\n\\nisMatch Function: This function serves as an interface to call the solve function with the appropriate arguments. It initializes the memoization table dp, calls solve with s.length()-1, p.length()-1, and returns the result.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N*M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(N*M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n```\\nclass Solution {\\npublic:\\n\\nbool solve(string& str,string& pattern , int i , int j, vector<vector<int>>&dp)\\n{\\n    if(i<0 && j<0)\\n    {\\n        return true;\\n    }\\n    if(i>=0 && j<0)\\n    {\\n        return false;\\n    }\\n    if(j>=0 && i<0)\\n    {\\n        for(int k =0;k<=j;k++)\\n        {\\n            if(pattern[k]!=\\'*\\')\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    if(dp[i][j]!=-1)\\n    {\\n        return dp[i][j];\\n    }\\n    if(pattern[j]==\\'?\\' || pattern[j]==str[i])\\n    {\\n        return dp[i][j]=solve(str,pattern, i-1,j-1,dp);\\n    }\\n    else if(pattern[j]==\\'*\\')\\n    {\\n       return dp[i][j]=solve(str,pattern, i-1,j,dp) || solve(str,pattern, i,j-1,dp);\\n    }\\n    else\\n    {\\n        return false;\\n    }\\n}\\n    bool isMatch(string s, string p)\\n    {\\n        vector<vector<int>>dp(s.length(),vector<int>(p.length(),-1));\\n        return solve(s,p,s.length()-1,p.length()-1,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n\\n```\n```\\nclass Solution {\\npublic:\\n\\nbool solvetab(string s, string p)\\n{\\n    vector<vector<int>>dp(s.length()+1,vector<int>(p.length()+1,0));\\n    dp[0][0]=true;\\n    for(int j=1;j<=p.length();j++)\\n    {\\n    bool flag= true;\\n        for(int k =1;k<=j;k++)\\n        {\\n            if(p[k-1]!=\\'*\\')\\n            {\\n                flag=false;\\n                break;\\n            }\\n        }\\n        dp[0][j]=flag;\\n    }\\n    for(int i =1;i<=s.length();i++)\\n    {\\n        for(int j =1;j<=p.length();j++)\\n        {\\n            if(p[j-1]==\\'?\\' || p[j-1]==s[i-1])\\n            {\\n                dp[i][j]=dp[i-1][j-1];\\n            }\\n            else if(p[j-1]==\\'*\\')\\n            {\\n              dp[i][j]=dp[i-1][j] || dp[i][j-1];\\n            }\\n            else\\n            {\\n                  dp[i][j]=false;\\n            }\\n        }\\n    }\\n    return dp[s.length()][p.length()];\\n}\\n\\n\\n\\n\\n    bool isMatch(string s, string p)\\n    {\\n       \\n        // return solve(s,p,s.length()-1,p.length()-1,dp);\\nreturn solvetab(s,p);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\nbool solve(string& str,string& pattern , int i , int j, vector<vector<int>>&dp)\\n{\\n    if(i<0 && j<0)\\n    {\\n        return true;\\n    }\\n    if(i>=0 && j<0)\\n    {\\n        return false;\\n    }\\n    if(j>=0 && i<0)\\n    {\\n        for(int k =0;k<=j;k++)\\n        {\\n            if(pattern[k]!=\\'*\\')\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    if(dp[i][j]!=-1)\\n    {\\n        return dp[i][j];\\n    }\\n    if(pattern[j]==\\'?\\' || pattern[j]==str[i])\\n    {\\n        return dp[i][j]=solve(str,pattern, i-1,j-1,dp);\\n    }\\n    else if(pattern[j]==\\'*\\')\\n    {\\n       return dp[i][j]=solve(str,pattern, i-1,j,dp) || solve(str,pattern, i,j-1,dp);\\n    }\\n    else\\n    {\\n        return false;\\n    }\\n}\\n    bool isMatch(string s, string p)\\n    {\\n        vector<vector<int>>dp(s.length(),vector<int>(p.length(),-1));\\n        return solve(s,p,s.length()-1,p.length()-1,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788484,
                "title": "c-dp-memoization-tabulation",
                "content": "# Memoization\\n```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        int n = s.size(), m = p.size(); \\n        vector<vector<short>> memo(n, vector<short>(m, -1));\\n        return dp(s, p, n-1, m-1, memo);\\n    }\\n\\nprivate:\\n    bool dp(string& s, string& p, int i, int j, vector<vector<short>>& memo) {\\n        if (i < 0) {\\n            while (j >= 0)\\n                if (p[j--] != \\'*\\') return false;\\n            return true;\\n        }\\n        if (j < 0) return false;\\n        if (memo[i][j] != -1) return memo[i][j];\\n\\n        if (s[i] == p[j] || p[j] == \\'?\\') return memo[i][j] = dp(s, p, i-1, j-1, memo);\\n        if (p[j] == \\'*\\') return memo[i][j] = dp(s, p, i-1, j, memo) || dp(s, p, i, j-1, memo);\\n\\n        return memo[i][j] = false;\\n    }\\n};\\n```\\n\\n# Tabulation\\n```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        int n = s.size(), m = p.size(); \\n        vector<vector<bool>> dp(n + 1, vector<bool>(m + 1, false));\\n        dp[0][0] = true;\\n\\n        for (int j = 1; p[j-1] == \\'*\\'; j++) dp[0][j] = true;\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= m; j++) {\\n                if (s[i-1] == p[j-1] || p[j-1] == \\'?\\') dp[i][j] = dp[i-1][j-1]; \\n                else if (p[j-1] == \\'*\\') dp[i][j] = dp[i-1][j] || dp[i][j-1];\\n                else dp[i][j] = false;\\n            }\\n        }\\n\\n        return dp[n][m];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        int n = s.size(), m = p.size(); \\n        vector<vector<short>> memo(n, vector<short>(m, -1));\\n        return dp(s, p, n-1, m-1, memo);\\n    }\\n\\nprivate:\\n    bool dp(string& s, string& p, int i, int j, vector<vector<short>>& memo) {\\n        if (i < 0) {\\n            while (j >= 0)\\n                if (p[j--] != \\'*\\') return false;\\n            return true;\\n        }\\n        if (j < 0) return false;\\n        if (memo[i][j] != -1) return memo[i][j];\\n\\n        if (s[i] == p[j] || p[j] == \\'?\\') return memo[i][j] = dp(s, p, i-1, j-1, memo);\\n        if (p[j] == \\'*\\') return memo[i][j] = dp(s, p, i-1, j, memo) || dp(s, p, i, j-1, memo);\\n\\n        return memo[i][j] = false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        int n = s.size(), m = p.size(); \\n        vector<vector<bool>> dp(n + 1, vector<bool>(m + 1, false));\\n        dp[0][0] = true;\\n\\n        for (int j = 1; p[j-1] == \\'*\\'; j++) dp[0][j] = true;\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= m; j++) {\\n                if (s[i-1] == p[j-1] || p[j-1] == \\'?\\') dp[i][j] = dp[i-1][j-1]; \\n                else if (p[j-1] == \\'*\\') dp[i][j] = dp[i-1][j] || dp[i][j-1];\\n                else dp[i][j] = false;\\n            }\\n        }\\n\\n        return dp[n][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773695,
                "title": "c-90-fast-recursive-memoization-tabulation-space-optimised",
                "content": "# Intuition\\nWhatever conditions are given in the question, just keep calling indices according to them.\\n\\n# Approach\\nJust handle the base cases carefully here.\\n\\nIf both the strings end at the same time, *return **true***\\nif string p is finished, and s isn\\'t, *return **false***\\nif s is finshed, then check if all the remaining elements in p are \\'*\\', *return true else return **false***\\n\\nTo understaand the last point, think about the case where \\ns = \"\"\\np = \"***\"\\n\\n\\n# Complexity\\n    n = s.size()\\n    m = p.size()\\n\\n- Time complexity:\\nO(n * m)\\n\\n- Space complexity:\\nO(m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool solve(int i, int j, string &s, string &p){\\n        if(i >= s.size() && j >= p.size()) return 1;\\n        if(j >= p.size()) return 0;\\n        if(i >= s.size()){\\n            for(int k = j; k < p.size(); k++){\\n                if(p[k] != \\'*\\') return 0;\\n            }\\n            return 1;\\n        }\\n\\n        bool ans = 0;\\n        if(p[j] == \\'?\\' || s[i] == p[j]){\\n            ans = solve(i+1, j+1, s, p);\\n        }\\n        else if(p[j] == \\'*\\'){\\n            for(int k = i; k <= s.size(); k++){\\n                ans = ans || solve(k, j+1, s, p);\\n            }\\n\\n            // OR\\n            // ans = solve(i, j+1, s, p) || solve(i+1, j, s, p);\\n        }\\n\\n        return ans;\\n    }\\n\\n    bool solveMem(int i, int j, string &s, string &p, vector<vector<int>> &DP){\\n        if(i >= s.size() && j >= p.size()) return 1;\\n        if(j >= p.size()) return 0;\\n        if(i >= s.size()){\\n            for(int k = j; k < p.size(); k++){\\n                if(p[k] != \\'*\\') return 0;\\n            }\\n            return 1;\\n        }\\n\\n        if(DP[i][j] != -1) return DP[i][j];\\n\\n        bool ans = 0;\\n        if(p[j] == \\'?\\' || s[i] == p[j]){\\n            ans = solveMem(i+1, j+1, s, p, DP);\\n        }\\n        else if(p[j] == \\'*\\'){\\n            for(int k = i; k <= s.size(); k++){\\n                ans = ans || solveMem(k, j+1, s, p, DP);\\n            }\\n            \\n            // OR we can use\\n            // ans = solveMem(i, j+1, s, p, DP) || solveMem(i+1, j, s, p, DP);\\n        }\\n\\n        return DP[i][j] = ans;\\n    }\\n\\n    bool solveTab(string &s, string &p){\\n        vector<vector<int>> DP(s.size()+1, vector<int>(p.size()+1, 0));\\n        DP[s.size()][p.size()] = 1;\\n        for(int i=p.size()-1; i>=0; i--){\\n            if(p[i] == \\'*\\'){\\n                DP[s.size()][i] = DP[s.size()][i+1];\\n            }\\n            else{\\n                DP[s.size()][i] = 0;\\n            }\\n        }\\n\\n        for(int i=s.size()-1; i>=0; i--){\\n            for(int j=p.size()-1; j>=0; j--){\\n                bool ans = 0;\\n                if(p[j] == \\'?\\' || s[i] == p[j]){\\n                    ans = DP[i+1][j+1];\\n                }\\n                else if(p[j] == \\'*\\'){\\n                    ans = DP[i][j+1] || DP[i+1][j];\\n                }\\n\\n                DP[i][j] = ans;\\n            }\\n        }\\n\\n        return DP[0][0];\\n    }\\n\\n    bool solveSO(string &s, string &p){\\n        vector<int> curr(p.size()+1, 0), next(p.size()+1, 0);\\n\\n        // Modify our DP arrays according to the base cases\\n        next[p.size()] = 1;\\n        for(int i=p.size()-1; i>=0; i--){\\n            if(p[i] == \\'*\\'){\\n                next[i] = next[i+1];\\n            }\\n            else{\\n                next[i] = 0;\\n            }\\n        }\\n\\n        for(int i=s.size()-1; i>=0; i--){\\n            for(int j=p.size()-1; j>=0; j--){\\n                bool ans = 0;\\n                if(p[j] == \\'?\\' || s[i] == p[j]){\\n                    ans = next[j+1];\\n                }\\n                else if(p[j] == \\'*\\'){\\n                    ans = curr[j+1] || next[j];\\n                }\\n\\n                curr[j] = ans;\\n            }\\n\\n            next = curr;\\n        }\\n\\n        return next[0];\\n    }\\n\\n    bool isMatch(string s, string p) {\\n        // vector<vector<int>> DP(s.size(), vector<int>(p.size(), -1));\\n        // return solveMem(0, 0, s, p, DP);\\n\\n        return solveSO(s, p);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(int i, int j, string &s, string &p){\\n        if(i >= s.size() && j >= p.size()) return 1;\\n        if(j >= p.size()) return 0;\\n        if(i >= s.size()){\\n            for(int k = j; k < p.size(); k++){\\n                if(p[k] != \\'*\\') return 0;\\n            }\\n            return 1;\\n        }\\n\\n        bool ans = 0;\\n        if(p[j] == \\'?\\' || s[i] == p[j]){\\n            ans = solve(i+1, j+1, s, p);\\n        }\\n        else if(p[j] == \\'*\\'){\\n            for(int k = i; k <= s.size(); k++){\\n                ans = ans || solve(k, j+1, s, p);\\n            }\\n\\n            // OR\\n            // ans = solve(i, j+1, s, p) || solve(i+1, j, s, p);\\n        }\\n\\n        return ans;\\n    }\\n\\n    bool solveMem(int i, int j, string &s, string &p, vector<vector<int>> &DP){\\n        if(i >= s.size() && j >= p.size()) return 1;\\n        if(j >= p.size()) return 0;\\n        if(i >= s.size()){\\n            for(int k = j; k < p.size(); k++){\\n                if(p[k] != \\'*\\') return 0;\\n            }\\n            return 1;\\n        }\\n\\n        if(DP[i][j] != -1) return DP[i][j];\\n\\n        bool ans = 0;\\n        if(p[j] == \\'?\\' || s[i] == p[j]){\\n            ans = solveMem(i+1, j+1, s, p, DP);\\n        }\\n        else if(p[j] == \\'*\\'){\\n            for(int k = i; k <= s.size(); k++){\\n                ans = ans || solveMem(k, j+1, s, p, DP);\\n            }\\n            \\n            // OR we can use\\n            // ans = solveMem(i, j+1, s, p, DP) || solveMem(i+1, j, s, p, DP);\\n        }\\n\\n        return DP[i][j] = ans;\\n    }\\n\\n    bool solveTab(string &s, string &p){\\n        vector<vector<int>> DP(s.size()+1, vector<int>(p.size()+1, 0));\\n        DP[s.size()][p.size()] = 1;\\n        for(int i=p.size()-1; i>=0; i--){\\n            if(p[i] == \\'*\\'){\\n                DP[s.size()][i] = DP[s.size()][i+1];\\n            }\\n            else{\\n                DP[s.size()][i] = 0;\\n            }\\n        }\\n\\n        for(int i=s.size()-1; i>=0; i--){\\n            for(int j=p.size()-1; j>=0; j--){\\n                bool ans = 0;\\n                if(p[j] == \\'?\\' || s[i] == p[j]){\\n                    ans = DP[i+1][j+1];\\n                }\\n                else if(p[j] == \\'*\\'){\\n                    ans = DP[i][j+1] || DP[i+1][j];\\n                }\\n\\n                DP[i][j] = ans;\\n            }\\n        }\\n\\n        return DP[0][0];\\n    }\\n\\n    bool solveSO(string &s, string &p){\\n        vector<int> curr(p.size()+1, 0), next(p.size()+1, 0);\\n\\n        // Modify our DP arrays according to the base cases\\n        next[p.size()] = 1;\\n        for(int i=p.size()-1; i>=0; i--){\\n            if(p[i] == \\'*\\'){\\n                next[i] = next[i+1];\\n            }\\n            else{\\n                next[i] = 0;\\n            }\\n        }\\n\\n        for(int i=s.size()-1; i>=0; i--){\\n            for(int j=p.size()-1; j>=0; j--){\\n                bool ans = 0;\\n                if(p[j] == \\'?\\' || s[i] == p[j]){\\n                    ans = next[j+1];\\n                }\\n                else if(p[j] == \\'*\\'){\\n                    ans = curr[j+1] || next[j];\\n                }\\n\\n                curr[j] = ans;\\n            }\\n\\n            next = curr;\\n        }\\n\\n        return next[0];\\n    }\\n\\n    bool isMatch(string s, string p) {\\n        // vector<vector<int>> DP(s.size(), vector<int>(p.size(), -1));\\n        // return solveMem(0, 0, s, p, DP);\\n\\n        return solveSO(s, p);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555561,
                "title": "approach1-recursion-with-memoisation",
                "content": "# Intuition\\nThere are two cases we can encounter\\n- pattern[i]==string[j] or pattern[i]==\\'?\\' this is normal case and we can just move onto next index\\n- pattern[i]==\\'\\\\*\\' when it is \\'\\\\*\\' we need to further check two other cases\\n   - \\'*\\'can mean it matches with nothing\\n   - or it matches whith a sequence\\n- The two cases can be calculated recursively as \\n```helper(s,p,dp,si,pi-1)|| helper(s,p,dp,si-1,pi);```\\n- Here when it matches with nothing the index of string remains the same and pattern is reduced as it matches nothing\\n- In second case we keep the pattern index at the same position (\\'*\\')\\nand reduce the string index as we need to check if it matches further and this recursio covers all cases\\n- Ther recursion values are stored in a vector(memoisation) which improves the time complexity\\n- Further a cleanup function was created to remove multiple \\'*\\' placed together in the pattern as \\'ab\\\\***cd\\' pattern is same as \\'ab\\\\*cd\\' which reduces calculation time\\n        \\n# Approach\\n- cleanup function created which removes duplicate * and returns cleaned pattern\\n- BASE CASES\\n    - ```if(pi<0 && si<0)```: return true as both patten and word is empty\\n    - ```else if(pi<0 &&si>=0)```: returns fasle as pattern is empty but word is not\\n    - ```else if(pi<0 &&si>=0)```: if pattern is empty further checks if pattern contains \\'*\\' only or not. If not then return false\\n- ```else if (dp[pi][si]!=-1)```: checks if dp has calculated the recursion call or not\\n- ```else if(p[pi]==s[si] || p[pi]==\\'?\\')```: Case 1 where we reduce both indexes by ```helper(s,p,dp,si-1,pi-1);```\\n- ```else if(p[pi]==\\'*\\')```: checks both cases as mentioned in the intuition by ```helper(s,p,dp,si,pi-1)|| helper(s,p,dp,si-1,pi);```\\n\\n# Complexity\\n- Time complexity:\\nO(M*N) M,N is the length of string and pattern \\n\\n- Space complexity:\\nO(M*N)+O(M+N) .O(M+N) is the auxillary stack space\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string cleanup(string p) {\\n        string cleaned_str = \"\";\\n        for (int i = 0; i < p.size(); i++) {\\n            if (cleaned_str.empty() || p[i] != \\'*\\') {\\n                cleaned_str.append(1, p[i]);\\n            } else if (i >= 1 && cleaned_str[cleaned_str.size() - 1] != \\'*\\') {\\n                cleaned_str.append(1, p[i]);\\n            }\\n        }\\n        return cleaned_str;\\n    }\\n\\n    bool helper(string &s, string &p, vector<vector<int>>&dp,int si,int pi) {\\n        if(pi<0 && si<0){\\n            return true;\\n        }\\n        else if(pi<0 &&si>=0){\\n            return false;\\n        }\\n        else if(pi>=0 && si<0){\\n            for(int k=0;k<=pi;k++){\\n                if(p[k]!=\\'*\\') return false;\\n            }\\n            return true;\\n        }\\n        else if (dp[pi][si]!=-1) {\\n            return dp[pi][si];\\n        }\\n        else if(p[pi]==s[si] || p[pi]==\\'?\\'){\\n            return dp[pi][si]=helper(s,p,dp,si-1,pi-1);\\n        }\\n        else if(p[pi]==\\'*\\'){\\n            return dp[pi][si]= helper(s,p,dp,si,pi-1)|| helper(s,p,dp,si-1,pi);\\n        }\\n\\n        return dp[pi][si]=false;\\n    }\\n\\n    bool isMatch(string s, string p) {\\n        if (p != \"\") {\\n            p = cleanup(p);\\n        }\\n        int m=s.size();\\n        int n=p.size();\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        return helper(s, p, dp,m-1,n-1);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```helper(s,p,dp,si,pi-1)|| helper(s,p,dp,si-1,pi);```\n```if(pi<0 && si<0)```\n```else if(pi<0 &&si>=0)```\n```else if(pi<0 &&si>=0)```\n```else if (dp[pi][si]!=-1)```\n```else if(p[pi]==s[si] || p[pi]==\\'?\\')```\n```helper(s,p,dp,si-1,pi-1);```\n```else if(p[pi]==\\'*\\')```\n```helper(s,p,dp,si,pi-1)|| helper(s,p,dp,si-1,pi);```\n```\\nclass Solution {\\npublic:\\n    string cleanup(string p) {\\n        string cleaned_str = \"\";\\n        for (int i = 0; i < p.size(); i++) {\\n            if (cleaned_str.empty() || p[i] != \\'*\\') {\\n                cleaned_str.append(1, p[i]);\\n            } else if (i >= 1 && cleaned_str[cleaned_str.size() - 1] != \\'*\\') {\\n                cleaned_str.append(1, p[i]);\\n            }\\n        }\\n        return cleaned_str;\\n    }\\n\\n    bool helper(string &s, string &p, vector<vector<int>>&dp,int si,int pi) {\\n        if(pi<0 && si<0){\\n            return true;\\n        }\\n        else if(pi<0 &&si>=0){\\n            return false;\\n        }\\n        else if(pi>=0 && si<0){\\n            for(int k=0;k<=pi;k++){\\n                if(p[k]!=\\'*\\') return false;\\n            }\\n            return true;\\n        }\\n        else if (dp[pi][si]!=-1) {\\n            return dp[pi][si];\\n        }\\n        else if(p[pi]==s[si] || p[pi]==\\'?\\'){\\n            return dp[pi][si]=helper(s,p,dp,si-1,pi-1);\\n        }\\n        else if(p[pi]==\\'*\\'){\\n            return dp[pi][si]= helper(s,p,dp,si,pi-1)|| helper(s,p,dp,si-1,pi);\\n        }\\n\\n        return dp[pi][si]=false;\\n    }\\n\\n    bool isMatch(string s, string p) {\\n        if (p != \"\") {\\n            p = cleanup(p);\\n        }\\n        int m=s.size();\\n        int n=p.size();\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        return helper(s, p, dp,m-1,n-1);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3118356,
                "title": "c-two-approaches-recursive-memoization-tabulation",
                "content": "**Explanation**\\n\\n\\tabbacbaa\\n\\tab*?a\\n\\t* -> matches : bacb \\n\\t? -> matches : a\\n        \\n    abdejced\\n    ab*c?d\\n    * matches with empty, j, je, jed than the string is matched\\n\\n**Recursive**\\n```\\nbool helper(int i, int j, string& s, string& p){\\n        if(i <= -1 && j <= -1)return true;\\n        if(i <= -1){\\n            for(int k = 0 ; k <= j ; k++)\\n                if(p[k] != \\'*\\')return false;\\n            return true;\\n        }\\n        if(j <= -1 && i != -1)return false;\\n        \\n        // Matching case \\n        // If string and pattern matches or the pattern contains a question mark\\n        if(s[i] == p[j] || ((s[i] != p[j]) && p[j] == \\'?\\'))return helper(i - 1, j - 1, s, p);\\n\\t\\t\\n        // For star pattern (Two Approaches for checking for star pattern)\\n        // if(p[j] == \\'*\\')return helper(i - 1, j, s, p) || helper(i, j - 1, s, p);\\n        if(p[j] == \\'*\\'){\\n            for(int m = 0 ; m <= i + 1 ; m++){\\n                bool f = helper(i - m, j - 1, s, p);\\n                if(f)return true;\\n            }\\n        }\\n        // Not Matching Case \\n        return false;\\n        \\n    }\\n    bool isMatch(string s, string p) {\\n        return helper(s.size() - 1, p.size() - 1, s, p);\\n    }\\n};\\n```\\n**Memoization**\\n\\n```\\nbool helper(int i, int j, string& s, string& p, vector<vector<int>>&dp){\\n        if(i == 0 && j == 0)return true;\\n        if(i == 0){\\n            for(int k = 0 ; k <= j - 1 ; k++)\\n                if(p[k] != \\'*\\')return false;\\n            return true;\\n        }\\n        if(j == 0 && i != 0)return false;\\n        if(dp[i][j] != -1)return dp[i][j];\\n\\t\\t\\n        // Matching case \\n        // If string and pattern matches or the pattern contains a question mark\\n        if(s[i - 1] == p[j - 1] || p[j - 1] == \\'?\\')return dp[i][j] = helper(i - 1, j - 1, s, p, dp);\\n        \\n        // For star pattern\\n        if(p[j - 1] == \\'*\\')return dp[i][j] = helper(i - 1, j, s, p, dp) || helper(i, j - 1, s, p, dp);\\n        \\n        // Not Matching Case \\n        return dp[i][j] = false;\\n        \\n    }\\n    bool isMatch(string s, string p) {\\n        vector<vector<int>>dp(s.size() + 1, vector<int>(p.size() + 1, -1));\\n        return helper(s.size(), p.size(), s, p, dp);\\n    }\\n};\\n\\n```\\n\\n**Tabulation**\\n\\n```\\n    bool isMatch(string s, string p) {\\n        int n = s.size(), m = p.size();\\n        vector<vector<bool>> dp(n + 1, vector<bool> (m + 1, false));\\n        \\n        dp[0][0] = true;\\n        for(int i = 1; i<= n ; i++)dp[i][0] = false;\\n        for(int j = 1 ; j <= m;j ++)dp[0][j] = valid(p, j);\\n        \\n        for(int i = 1 ; i <= n;i++){\\n            for(int j= 1 ; j <= m ; j++){\\n                if(s[i - 1] == p[j - 1] || p[j - 1] == \\'?\\')dp[i][j] = dp[i - 1 ][j - 1];\\n                else if(p[j - 1] == \\'*\\')dp[i][j]=dp[i-1][j] | dp[i][j-1];\\n                else dp[i][j]=false;\\n            }\\n        }\\n        return dp[n][m];      \\n    }\\n};\\n```\\n\\n**Tabulation**\\n\\n```cpp\\nbool isMatch(string s, string p) {\\n    int n = s.size(), m = p.size();\\n    vector<vector<bool>> dp(n + 1, vector<bool>(m + 1));\\n    \\n    // Base case coversion\\n    dp[0][0] = true;\\n    for (int i = 1; i <= n; i++)dp[i][0] = false;\\n\\n    bool flag = true;\\n    for (int i = 1; i <= m; i++) {\\n        if (p[i - 1] != \\'*\\') {\\n            flag = false;\\n        }\\n        dp[0][i] = flag;\\n    }\\n\\n    // Recursive relation conversion\\n    for (int i = 1 ; i <= n ; i++) {\\n        for (int j = 1 ; j <= m ; j++) {\\n            if (s[i - 1] == p[j - 1] || p[j - 1] == \\'?\\'){\\n                dp[i][j] = dp[i - 1][j - 1];\\n            }else if (p[j - 1] == \\'*\\'){\\n                dp[i][j] = dp[i - 1][j] || dp[i][j - 1];\\n            }else{\\n                dp[i][j] = false;\\n            }\\n        }\\n    }\\n\\n    return dp[n][m];\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nbool helper(int i, int j, string& s, string& p){\\n        if(i <= -1 && j <= -1)return true;\\n        if(i <= -1){\\n            for(int k = 0 ; k <= j ; k++)\\n                if(p[k] != \\'*\\')return false;\\n            return true;\\n        }\\n        if(j <= -1 && i != -1)return false;\\n        \\n        // Matching case \\n        // If string and pattern matches or the pattern contains a question mark\\n        if(s[i] == p[j] || ((s[i] != p[j]) && p[j] == \\'?\\'))return helper(i - 1, j - 1, s, p);\\n\\t\\t\\n        // For star pattern (Two Approaches for checking for star pattern)\\n        // if(p[j] == \\'*\\')return helper(i - 1, j, s, p) || helper(i, j - 1, s, p);\\n        if(p[j] == \\'*\\'){\\n            for(int m = 0 ; m <= i + 1 ; m++){\\n                bool f = helper(i - m, j - 1, s, p);\\n                if(f)return true;\\n            }\\n        }\\n        // Not Matching Case \\n        return false;\\n        \\n    }\\n    bool isMatch(string s, string p) {\\n        return helper(s.size() - 1, p.size() - 1, s, p);\\n    }\\n};\\n```\n```\\nbool helper(int i, int j, string& s, string& p, vector<vector<int>>&dp){\\n        if(i == 0 && j == 0)return true;\\n        if(i == 0){\\n            for(int k = 0 ; k <= j - 1 ; k++)\\n                if(p[k] != \\'*\\')return false;\\n            return true;\\n        }\\n        if(j == 0 && i != 0)return false;\\n        if(dp[i][j] != -1)return dp[i][j];\\n\\t\\t\\n        // Matching case \\n        // If string and pattern matches or the pattern contains a question mark\\n        if(s[i - 1] == p[j - 1] || p[j - 1] == \\'?\\')return dp[i][j] = helper(i - 1, j - 1, s, p, dp);\\n        \\n        // For star pattern\\n        if(p[j - 1] == \\'*\\')return dp[i][j] = helper(i - 1, j, s, p, dp) || helper(i, j - 1, s, p, dp);\\n        \\n        // Not Matching Case \\n        return dp[i][j] = false;\\n        \\n    }\\n    bool isMatch(string s, string p) {\\n        vector<vector<int>>dp(s.size() + 1, vector<int>(p.size() + 1, -1));\\n        return helper(s.size(), p.size(), s, p, dp);\\n    }\\n};\\n\\n```\n```\\n    bool isMatch(string s, string p) {\\n        int n = s.size(), m = p.size();\\n        vector<vector<bool>> dp(n + 1, vector<bool> (m + 1, false));\\n        \\n        dp[0][0] = true;\\n        for(int i = 1; i<= n ; i++)dp[i][0] = false;\\n        for(int j = 1 ; j <= m;j ++)dp[0][j] = valid(p, j);\\n        \\n        for(int i = 1 ; i <= n;i++){\\n            for(int j= 1 ; j <= m ; j++){\\n                if(s[i - 1] == p[j - 1] || p[j - 1] == \\'?\\')dp[i][j] = dp[i - 1 ][j - 1];\\n                else if(p[j - 1] == \\'*\\')dp[i][j]=dp[i-1][j] | dp[i][j-1];\\n                else dp[i][j]=false;\\n            }\\n        }\\n        return dp[n][m];      \\n    }\\n};\\n```\n```cpp\\nbool isMatch(string s, string p) {\\n    int n = s.size(), m = p.size();\\n    vector<vector<bool>> dp(n + 1, vector<bool>(m + 1));\\n    \\n    // Base case coversion\\n    dp[0][0] = true;\\n    for (int i = 1; i <= n; i++)dp[i][0] = false;\\n\\n    bool flag = true;\\n    for (int i = 1; i <= m; i++) {\\n        if (p[i - 1] != \\'*\\') {\\n            flag = false;\\n        }\\n        dp[0][i] = flag;\\n    }\\n\\n    // Recursive relation conversion\\n    for (int i = 1 ; i <= n ; i++) {\\n        for (int j = 1 ; j <= m ; j++) {\\n            if (s[i - 1] == p[j - 1] || p[j - 1] == \\'?\\'){\\n                dp[i][j] = dp[i - 1][j - 1];\\n            }else if (p[j - 1] == \\'*\\'){\\n                dp[i][j] = dp[i - 1][j] || dp[i][j - 1];\\n            }else{\\n                dp[i][j] = false;\\n            }\\n        }\\n    }\\n\\n    return dp[n][m];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3115049,
                "title": "python-solution-one-linear-using-fnmatch",
                "content": "```\\nimport fnmatch\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        return fnmatch.fnmatch(s,p)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport fnmatch\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        return fnmatch.fnmatch(s,p)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107865,
                "title": "beats-100-tabulation-simple-and-easy-to-understand-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n// //// TABULATION\\n    bool isMatch(string str, string p) {\\n        string s = p , t = str;\\n        int m = s.size() , n = t.size(); ///  string t is pattern string\\n        vector<vector<bool>> dp(m+1,vector<bool>(n+1,0));\\n        dp[0][0] = true;\\n        for(int j=1;j<=n;j++) dp[0][j] =false;\\n        for(int i=1;i<=m;i++){\\n            bool temp = true;\\n            for(int ii=1;ii<=i;ii++){\\n                if(s[ii-1] != \\'*\\'){\\n                    temp = false;\\n                    break;\\n                }\\n            }\\n            dp[i][0] = temp;\\n        }\\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n                if(s[i-1] == t[j-1] || s[i-1] == \\'?\\'){\\n                    dp[i][j] = dp[i-1][j-1];\\n                }\\n                else if(s[i-1] == \\'*\\'){\\n                    dp[i][j] = dp[i-1][j] | dp[i][j-1];\\n                }\\n                else{\\n                    dp[i][j] = false;\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n// //// TABULATION\\n    bool isMatch(string str, string p) {\\n        string s = p , t = str;\\n        int m = s.size() , n = t.size(); ///  string t is pattern string\\n        vector<vector<bool>> dp(m+1,vector<bool>(n+1,0));\\n        dp[0][0] = true;\\n        for(int j=1;j<=n;j++) dp[0][j] =false;\\n        for(int i=1;i<=m;i++){\\n            bool temp = true;\\n            for(int ii=1;ii<=i;ii++){\\n                if(s[ii-1] != \\'*\\'){\\n                    temp = false;\\n                    break;\\n                }\\n            }\\n            dp[i][0] = temp;\\n        }\\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n                if(s[i-1] == t[j-1] || s[i-1] == \\'?\\'){\\n                    dp[i][j] = dp[i-1][j-1];\\n                }\\n                else if(s[i-1] == \\'*\\'){\\n                    dp[i][j] = dp[i-1][j] | dp[i][j-1];\\n                }\\n                else{\\n                    dp[i][j] = false;\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3076936,
                "title": "c-easy-solution-memoization-tabulation",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool f(int i,int j, string s,string p,vector<vector<int>>&dp){\\n        if(i==0 && j==0) return true;\\n        if(i>0 && j==0) return false;\\n        if(i==0 && j>0){\\n            for(int k=1;k<=j;k++){\\n                if(p[k-1]!=\\'*\\'){\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        if(s[i-1]==p[j-1] || p[j-1]==\\'?\\')\\n            return dp[i][j]=f(i-1,j-1,s,p,dp);\\n        if(p[j-1]==\\'*\\'){\\n            return dp[i][j]=f(i-1,j,s,p,dp) | f(i,j-1,s,p,dp);\\n        }\\n        return dp[i][j]=false;\\n    }\\n    bool x(string p,int j){\\n        for(int k=1;k<=j;k++){\\n                if(p[k-1]!=\\'*\\'){\\n                    return false;\\n                }\\n            }\\n            return true;\\n    }\\n    bool isMatch(string s, string p) {\\n        int n=s.length();\\n        int m=p.length();\\n        vector<vector<bool>>dp(n+1,vector<bool>(m+1,false));\\n        dp[0][0]=true;\\n        for(int i=1;i<=n;i++) dp[i][0]=false;\\n        for(int j=1;j<=m;j++) {\\n            dp[0][j]=x(p,j);\\n        }\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(s[i-1]==p[j-1] || p[j-1]==\\'?\\')\\n                 dp[i][j]=dp[i-1][j-1];\\n            else {if(p[j-1]==\\'*\\'){\\n                dp[i][j]=dp[i-1][j] | dp[i][j-1];\\n            }\\n            else\\n                dp[i][j]=false;}\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool f(int i,int j, string s,string p,vector<vector<int>>&dp){\\n        if(i==0 && j==0) return true;\\n        if(i>0 && j==0) return false;\\n        if(i==0 && j>0){\\n            for(int k=1;k<=j;k++){\\n                if(p[k-1]!=\\'*\\'){\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        if(s[i-1]==p[j-1] || p[j-1]==\\'?\\')\\n            return dp[i][j]=f(i-1,j-1,s,p,dp);\\n        if(p[j-1]==\\'*\\'){\\n            return dp[i][j]=f(i-1,j,s,p,dp) | f(i,j-1,s,p,dp);\\n        }\\n        return dp[i][j]=false;\\n    }\\n    bool x(string p,int j){\\n        for(int k=1;k<=j;k++){\\n                if(p[k-1]!=\\'*\\'){\\n                    return false;\\n                }\\n            }\\n            return true;\\n    }\\n    bool isMatch(string s, string p) {\\n        int n=s.length();\\n        int m=p.length();\\n        vector<vector<bool>>dp(n+1,vector<bool>(m+1,false));\\n        dp[0][0]=true;\\n        for(int i=1;i<=n;i++) dp[i][0]=false;\\n        for(int j=1;j<=m;j++) {\\n            dp[0][j]=x(p,j);\\n        }\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(s[i-1]==p[j-1] || p[j-1]==\\'?\\')\\n                 dp[i][j]=dp[i-1][j-1];\\n            else {if(p[j-1]==\\'*\\'){\\n                dp[i][j]=dp[i-1][j] | dp[i][j-1];\\n            }\\n            else\\n                dp[i][j]=false;}\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2270748,
                "title": "c-easy-simple-solution-wildcard-matching",
                "content": "class Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        bool dp[p.size() + 1][s.size() + 1];\\n        \\n        for(int i = p.size(); i >= 0; i--) {\\n            for(int j = s.size(); j >= 0; j--) {\\n                 if(i == p.size()&& j == s.size()) {\\n                     dp[i][j] = true;\\n                 }\\n                 else if(i == p.size()) {\\n                       dp[i][j] = false;\\n                 }\\n                 else if(j == s.size()) {\\n                       if(p[i] == \\'*\\') {\\n                             dp[i][j] = dp[i+1][j];\\n                       }\\n                     else {\\n                         dp[i][j] = false;\\n                     }\\n                 }\\n                 else {\\n                     if(p[i] == \\'*\\') {\\n                         dp[i][j] = dp[i+1][j] || dp[i][j+1];\\n                     }\\n                     else if(p[i] == \\'?\\') {\\n                         dp[i][j] = dp[i+1][j+1];\\n                     }\\n                     else {\\n                         if(p[i] == s[j]) dp[i][j] = dp[i+1][j+1];\\n                         else dp[i][j] = false;\\n                     }\\n                 }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        bool dp[p.size() + 1][s.size() + 1];\\n        \\n        for(int i = p.size(); i >= 0; i--) {\\n            for(int j = s.size(); j >= 0; j--) {\\n                 if(i == p.size()&& j == s.size()) {\\n                     dp[i][j] = true;\\n                 }",
                "codeTag": "Java"
            },
            {
                "id": 2217760,
                "title": "working-solution-100-python",
                "content": "Here i am having a recursive solution in python. \\n\\n> Lets understand the complexity of the problem and where we are not able to pass the cases.\\n\\nIn this problem we need to  match two string char by char the problem while doing is the REGEX  <bold>* </bold> and<bold> ?</bold> which creates confusion. Genralization comes with equating the length of the char  as we encounter the <bold> * </bold> and <bol> ? </bold> following are the cases that we need to follow:\\n\\n> 1. text = \\'xyz\\'  and  pattern = \\'*\\' -> In this we can directly return true as \\'*\\' can match anylength of sequence without any issue.\\n> 2. text = \\'xyz\\' and pattern = \\'x?z\\' -> Here, also we can return true as \\'?\\' can match with length 1 char which will give true as result.\\n> 3. text = \\'xyylmnz\\' and pattern = x <bold>* </bold>m?z -> Now a little confusing part here we need to match the text as much as possible so we will match \\'yyl\\' with  \\'<bold>* </bold>\\' and then \\'n\\' with \\'?\\'  and so we will get all char matched with text.\\n\\nApart from the above cases we might encounter a case where we don\\'t have \\'*\\' and \\'?\\' in the string and that is simple case of string matching where we don\\'t need to worry about REGEX patterns.\\n\\nPYTHON CODE :\\n\\n```\\n def isMatchRecursive(self, s, p ,p1, p2):\\n \\n \\'\\'\\'   if all char in pattern is checked then return by checking \\n       whether text is equal to iterated position value \\'\\'\\'\\n        if p2 == len(p):\\n            return len(s) == p1    \\n       \\n\\t   \\'\\'\\' If * then try to match maximum char in pattern and if \\'?\\' is found\\n\\t      match it with one char else recursively call the function with increased \\n\\t\\t  position values \\'\\'\\'\\n\\t\\t  \\n        if p[p2] != \\'*\\':\\n            if p1 < len(s) and (s[p1] == p[p2] or p[p2] == \\'?\\'):\\n                return self.isMatchRecursive(s, p,p1+1,p2+1)\\n            else:\\n                return False\\n\\t\\t\\'\\'\\' This else condition is for maching \\'*\\' int the pattern like we \\n\\t\\thave 3 \\'*\\' so we need to bypass all the \\'*\\'. \\'\\'\\'\\n\\t\\t\\n        else: \\n            while p2< len(p)-1 and p[p2+1] == \\'*\\':\\n                p2 += 1\\n            p1 -= 1\\n\\n            \\'\\'\\' This loop recursively calls the function with next chars in the pattern by incrementing the poistions in the pattern and text strings\\'\\'\\'\\n            while p1< len(s):\\n                if self.isMatchRecursive(s,p,p1+1, p2+1):\\n                    return True\\n\\n                p1 += 1\\n\\n        return False\\n\\ndef isMatch(self, s, p):\\n\\n\\treturn self.isMatchRecursive(s, p, 0 , 0)\\n```",
                "solutionTags": [
                    "Python",
                    "String",
                    "Recursion"
                ],
                "code": "```\\n def isMatchRecursive(self, s, p ,p1, p2):\\n \\n \\'\\'\\'   if all char in pattern is checked then return by checking \\n       whether text is equal to iterated position value \\'\\'\\'\\n        if p2 == len(p):\\n            return len(s) == p1    \\n       \\n\\t   \\'\\'\\' If * then try to match maximum char in pattern and if \\'?\\' is found\\n\\t      match it with one char else recursively call the function with increased \\n\\t\\t  position values \\'\\'\\'\\n\\t\\t  \\n        if p[p2] != \\'*\\':\\n            if p1 < len(s) and (s[p1] == p[p2] or p[p2] == \\'?\\'):\\n                return self.isMatchRecursive(s, p,p1+1,p2+1)\\n            else:\\n                return False\\n\\t\\t\\'\\'\\' This else condition is for maching \\'*\\' int the pattern like we \\n\\t\\thave 3 \\'*\\' so we need to bypass all the \\'*\\'. \\'\\'\\'\\n\\t\\t\\n        else: \\n            while p2< len(p)-1 and p[p2+1] == \\'*\\':\\n                p2 += 1\\n            p1 -= 1\\n\\n            \\'\\'\\' This loop recursively calls the function with next chars in the pattern by incrementing the poistions in the pattern and text strings\\'\\'\\'\\n            while p1< len(s):\\n                if self.isMatchRecursive(s,p,p1+1, p2+1):\\n                    return True\\n\\n                p1 += 1\\n\\n        return False\\n\\ndef isMatch(self, s, p):\\n\\n\\treturn self.isMatchRecursive(s, p, 0 , 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2152788,
                "title": "c-solution-using-dynamic-programming",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isMatch(string text, string pattern) {\\n       int n = pattern.size();\\n       int m = text.size();\\n        if(m==0 && n==0)\\n        {return true;}\\n        if(n==0)\\n        {return false;}\\n        if(m==0 && pattern[0] == \\'?\\') return false;\\n        \\n       vector<vector<bool>> dp(m+1, vector<bool> (n+1, false));\\n        dp[0][0] = true;\\n       for(int i=1;i<=n;++i)\\n       {\\n           if( pattern[i-1] != \\'*\\') \\n           {\\n               break;\\n           }\\n           else \\n           {\\n               dp[0][i] = true;\\n           }\\n       }\\n       \\n       \\n\\n       for(int i=1;i<=m;++i)\\n       {\\n        for(int j=1;j<=n;++j)\\n        {\\n         \\n         if(text[i-1] == pattern[j-1])\\n         {\\n          dp[i][j] = dp[i-1][j-1];\\n         }\\n         else\\n         {\\n           if(pattern[j-1] == \\'?\\')\\n           {\\n              dp[i][j] = dp[i-1][j-1];\\n           }\\n           else if(pattern[j-1] == \\'*\\')\\n           {\\n              dp[i][j] = dp[i][j-1] | dp[i-1][j] | dp[i-1][j-1];\\n           }\\n           else\\n           {\\n            dp[i][j] = false;\\n           }\\n         }\\n\\n        }\\n       }\\n\\n       return dp[m][n];\\n    }\\n};\\n```\\n\\n**Kindly upvote if you got the solution**.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMatch(string text, string pattern) {\\n       int n = pattern.size();\\n       int m = text.size();\\n        if(m==0 && n==0)\\n        {return true;}\\n        if(n==0)\\n        {return false;}\\n        if(m==0 && pattern[0] == \\'?\\') return false;\\n        \\n       vector<vector<bool>> dp(m+1, vector<bool> (n+1, false));\\n        dp[0][0] = true;\\n       for(int i=1;i<=n;++i)\\n       {\\n           if( pattern[i-1] != \\'*\\') \\n           {\\n               break;\\n           }\\n           else \\n           {\\n               dp[0][i] = true;\\n           }\\n       }\\n       \\n       \\n\\n       for(int i=1;i<=m;++i)\\n       {\\n        for(int j=1;j<=n;++j)\\n        {\\n         \\n         if(text[i-1] == pattern[j-1])\\n         {\\n          dp[i][j] = dp[i-1][j-1];\\n         }\\n         else\\n         {\\n           if(pattern[j-1] == \\'?\\')\\n           {\\n              dp[i][j] = dp[i-1][j-1];\\n           }\\n           else if(pattern[j-1] == \\'*\\')\\n           {\\n              dp[i][j] = dp[i][j-1] | dp[i-1][j] | dp[i-1][j-1];\\n           }\\n           else\\n           {\\n            dp[i][j] = false;\\n           }\\n         }\\n\\n        }\\n       }\\n\\n       return dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2146926,
                "title": "c-easy-solution-memoiazation-tabulation",
                "content": "**Method 1: Memoiazation**\\n\\n\\n```\\n//Memoiazation\\nbool f(int i,int j,string &pattern,string &text,vector<vector<int>>&dp)\\n{\\n    // Base Cases\\n    if(i<0 && j<0) return true;\\n    if(i<0 && j>=0) return false;\\n    if(i>=0 && j<0) {\\n    for(int k=0;k<=i;k++) \\n      if(pattern[k]!=\\'*\\') return false; \\n      return true;  \\n    }\\n    if(dp[i][j]!=-1) return dp[i][j];\\n    if(pattern[i]==text[j] || pattern[i]==\\'?\\') \\n    return dp[i][j] = f(i-1,j-1,pattern,text,dp);\\n    else if(pattern[i] ==\\'*\\') \\n    return dp[i][j]=f(i-1,j,pattern,text,dp) || f(i,j-1,pattern,text,dp);\\n    else return dp[i][j] = false;\\n}\\nbool isMatch(string s, string p) \\n{\\n    int m = p.length();\\n    int n = s.length();\\n    vector<vector<int>>dp(m,vector<int>(n,-1));\\n    return f(m-1,n-1,p,s,dp);\\n}\\n```\\n\\n**Method: Tabulation**\\n\\n```\\n// Tabulation \\nbool isMatch(string text, string pattern) \\n{\\n    int m = pattern.length();\\n    int n = text.length();\\n    vector<vector<bool>>dp(m+1,vector<bool>(n+1,false));\\n  \\n    // Base Cases\\n    dp[0][0] = true;\\n    for(int j=1;j<=n;j++) dp[0][j] = false;\\n    \\n    for(int i=1;i<=m;i++)\\n    {\\n      bool flag = true;\\n     for(int k=1;k<=i;k++){\\n      if(pattern[k-1]!=\\'*\\'){\\n           flag = false;\\n           break;\\n      }         \\n    }\\n     return dp[i][0] = flag; \\n    }\\n    \\n    // Main Operation\\n    for(int i=1;i<=m;i++)\\n    {\\n        for(int j=1;j<=n;j++)\\n        {\\n          if(pattern[i-1]==text[j-1] || pattern[i-1]==\\'?\\') \\n          dp[i][j] = dp[i-1][j-1]; \\n            \\n          else if(pattern[i-1] ==\\'*\\') \\n          dp[i][j]= dp[i-1][j] | dp[i][j-1];\\n            \\n          else dp[i][j] = false;\\n        }\\n    }\\n    return dp[m][n];\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n//Memoiazation\\nbool f(int i,int j,string &pattern,string &text,vector<vector<int>>&dp)\\n{\\n    // Base Cases\\n    if(i<0 && j<0) return true;\\n    if(i<0 && j>=0) return false;\\n    if(i>=0 && j<0) {\\n    for(int k=0;k<=i;k++) \\n      if(pattern[k]!=\\'*\\') return false; \\n      return true;  \\n    }\\n    if(dp[i][j]!=-1) return dp[i][j];\\n    if(pattern[i]==text[j] || pattern[i]==\\'?\\') \\n    return dp[i][j] = f(i-1,j-1,pattern,text,dp);\\n    else if(pattern[i] ==\\'*\\') \\n    return dp[i][j]=f(i-1,j,pattern,text,dp) || f(i,j-1,pattern,text,dp);\\n    else return dp[i][j] = false;\\n}\\nbool isMatch(string s, string p) \\n{\\n    int m = p.length();\\n    int n = s.length();\\n    vector<vector<int>>dp(m,vector<int>(n,-1));\\n    return f(m-1,n-1,p,s,dp);\\n}\\n```\n```\\n// Tabulation \\nbool isMatch(string text, string pattern) \\n{\\n    int m = pattern.length();\\n    int n = text.length();\\n    vector<vector<bool>>dp(m+1,vector<bool>(n+1,false));\\n  \\n    // Base Cases\\n    dp[0][0] = true;\\n    for(int j=1;j<=n;j++) dp[0][j] = false;\\n    \\n    for(int i=1;i<=m;i++)\\n    {\\n      bool flag = true;\\n     for(int k=1;k<=i;k++){\\n      if(pattern[k-1]!=\\'*\\'){\\n           flag = false;\\n           break;\\n      }         \\n    }\\n     return dp[i][0] = flag; \\n    }\\n    \\n    // Main Operation\\n    for(int i=1;i<=m;i++)\\n    {\\n        for(int j=1;j<=n;j++)\\n        {\\n          if(pattern[i-1]==text[j-1] || pattern[i-1]==\\'?\\') \\n          dp[i][j] = dp[i-1][j-1]; \\n            \\n          else if(pattern[i-1] ==\\'*\\') \\n          dp[i][j]= dp[i-1][j] | dp[i][j-1];\\n            \\n          else dp[i][j] = false;\\n        }\\n    }\\n    return dp[m][n];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2051554,
                "title": "java-2ms-solution-beat-99",
                "content": "\\n\\n\\tclass Solution {\\n\\t\\tpublic boolean isMatch(String s, String p) {\\n\\t\\t\\tif (p == null || p.length() == 0) return (s == null | s.length() == 0);\\n\\n\\t\\t\\tif (p == \"*\") return true;\\n\\n\\t\\t\\tint ls = s.length(), lp = p.length();\\n\\t\\t\\tint i = 0, j = 0;\\n\\t\\t\\tint star = -1, match = 0;\\n\\n\\t\\t\\twhile (i < ls){\\n\\n\\t\\t\\t\\tif(j < lp && (s.charAt(i) == p.charAt(j) || p.charAt(j) == \\'?\\')){\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t}else if (j < lp &&p.charAt(j) == \\'*\\'){\\n\\t\\t\\t\\t\\tstar = j;\\n\\t\\t\\t\\t\\tmatch = i;\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t}else if (star != -1){\\n\\t\\t\\t\\t\\ti = ++match;\\n\\t\\t\\t\\t\\tj = star+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse return false;\\n\\t\\t\\t}\\n\\n\\t\\t\\twhile (j < lp){\\n\\t\\t\\t\\tif (p.charAt(j) != \\'*\\') return false;\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn j == lp;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic boolean isMatch(String s, String p) {\\n\\t\\t\\tif (p == null || p.length() == 0) return (s == null | s.length() == 0);\\n\\n\\t\\t\\tif (p == \"*\") return true;\\n\\n\\t\\t\\tint ls = s.length(), lp = p.length();\\n\\t\\t\\tint i = 0, j = 0;\\n\\t\\t\\tint star = -1, match = 0;\\n\\n\\t\\t\\twhile (i < ls){\\n\\n\\t\\t\\t\\tif(j < lp && (s.charAt(i) == p.charAt(j) || p.charAt(j) == \\'?\\')){\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2043900,
                "title": "java-solution-for-wildcard-matching",
                "content": "## Approach\\n\\n  We start with the first character of the pattern.\\n  If the first character of the pattern is a match, we move to the next character of the pattern and the next character of the string.\\n  If the first character of the pattern is not a match, we check if there is a star in the pattern.\\n  If there is a star in the pattern, we move to the next character of the pattern and the next character of the string.\\n  If there is no star in the pattern, we return false.\\n  If the first character of the pattern is a star, we move to the next character of the pattern.\\n  We check if the next character of the pattern is a match.\\n  If the next character of the pattern is a match, we move to the next character of the pattern and the next character of the string.\\n  If the next character of the pattern is not a match, we check if there is a star in the pattern.\\n  If there is a star in the pattern, we move to the next character of the pattern and the next character of the string.\\n  If there is no star in the pattern, we return false.\\n  If the first character of the pattern is not a match and there is no star in the pattern, we return false.\\n \\n  **`Time: O(n)`**\\n  \\n  ---\\n\\n## Solution\\n\\n```java\\n// Time: O(n)\\nclass Solution {\\n  public static boolean isMatch(String s, String p) {\\n    // Edge case\\n    if (s == null || p == null) {\\n      return false;\\n    }\\n\\n    // Initialize the variables\\n    int sIndex = 0;\\n    int pIndex = 0;\\n    int starIndex = -1;\\n    int match = 0;\\n\\n    // Loop through the pattern\\n\\n    while (sIndex < s.length()) {\\n      // If the current pattern is a match\\n      if (pIndex < p.length() && (s.charAt(sIndex) == p.charAt(pIndex) || p.charAt(pIndex) == \\'?\\')) {\\n        sIndex++;\\n        pIndex++;\\n      }\\n      // If the current pattern is a star\\n      else if (pIndex < p.length() && p.charAt(pIndex) == \\'*\\') {\\n        starIndex = pIndex;\\n        match = sIndex;\\n        pIndex++;\\n      }\\n      // If the current pattern is not a match and there is no star\\n      else if (starIndex == -1) {\\n        return false;\\n      }\\n      // If the current pattern is not a match and there is a star\\n      else {\\n        pIndex = starIndex + 1;\\n        sIndex = match + 1;\\n        match++;\\n      }\\n    }\\n\\n    // Check if the pattern is a match\\n    while (pIndex < p.length() && p.charAt(pIndex) == \\'*\\') {\\n      pIndex++;\\n    }\\n\\n    return pIndex == p.length();\\n  }\\n\\n  public static void main(String[] args) {\\n    System.out.println(isMatch(\"aa\", \"a\"));\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\n// Time: O(n)\\nclass Solution {\\n  public static boolean isMatch(String s, String p) {\\n    // Edge case\\n    if (s == null || p == null) {\\n      return false;\\n    }\\n\\n    // Initialize the variables\\n    int sIndex = 0;\\n    int pIndex = 0;\\n    int starIndex = -1;\\n    int match = 0;\\n\\n    // Loop through the pattern\\n\\n    while (sIndex < s.length()) {\\n      // If the current pattern is a match\\n      if (pIndex < p.length() && (s.charAt(sIndex) == p.charAt(pIndex) || p.charAt(pIndex) == \\'?\\')) {\\n        sIndex++;\\n        pIndex++;\\n      }\\n      // If the current pattern is a star\\n      else if (pIndex < p.length() && p.charAt(pIndex) == \\'*\\') {\\n        starIndex = pIndex;\\n        match = sIndex;\\n        pIndex++;\\n      }\\n      // If the current pattern is not a match and there is no star\\n      else if (starIndex == -1) {\\n        return false;\\n      }\\n      // If the current pattern is not a match and there is a star\\n      else {\\n        pIndex = starIndex + 1;\\n        sIndex = match + 1;\\n        match++;\\n      }\\n    }\\n\\n    // Check if the pattern is a match\\n    while (pIndex < p.length() && p.charAt(pIndex) == \\'*\\') {\\n      pIndex++;\\n    }\\n\\n    return pIndex == p.length();\\n  }\\n\\n  public static void main(String[] args) {\\n    System.out.println(isMatch(\"aa\", \"a\"));\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1961308,
                "title": "simple-java-dp-memoization",
                "content": "```\\n Boolean[][] dp;\\n    \\n    public boolean func(String s,String p,int n,int m){\\n        if(n==-1&&m==-1){\\n            return true;\\n        }\\n        if(n<0){\\n            for(int i=0;i<=m;i++){\\n                if(p.charAt(i)!=\\'*\\'){\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n        if(m<0){\\n            return false;\\n        }\\n        if(dp[n][m]!=null){\\n            return dp[n][m];\\n        }\\n        if(p.charAt(m)==\\'?\\'||(p.charAt(m)==s.charAt(n))){\\n            return dp[n][m]=func(s,p,n-1,m-1);\\n        }\\n        if(p.charAt(m)==\\'*\\'){\\n            return dp[n][m]=func(s,p,n-1,m)||func(s,p,n,m-1);\\n        }\\n        \\n        return dp[n][m]=false;\\n    }\\n    \\n    public boolean isMatch(String s, String p) {\\n        dp=new Boolean[s.length()][p.length()];\\n        return func(s,p,s.length()-1,p.length()-1);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n Boolean[][] dp;\\n    \\n    public boolean func(String s,String p,int n,int m){\\n        if(n==-1&&m==-1){\\n            return true;\\n        }\\n        if(n<0){\\n            for(int i=0;i<=m;i++){\\n                if(p.charAt(i)!=\\'*\\'){\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n        if(m<0){\\n            return false;\\n        }\\n        if(dp[n][m]!=null){\\n            return dp[n][m];\\n        }\\n        if(p.charAt(m)==\\'?\\'||(p.charAt(m)==s.charAt(n))){\\n            return dp[n][m]=func(s,p,n-1,m-1);\\n        }\\n        if(p.charAt(m)==\\'*\\'){\\n            return dp[n][m]=func(s,p,n-1,m)||func(s,p,n,m-1);\\n        }\\n        \\n        return dp[n][m]=false;\\n    }\\n    \\n    public boolean isMatch(String s, String p) {\\n        dp=new Boolean[s.length()][p.length()];\\n        return func(s,p,s.length()-1,p.length()-1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1945937,
                "title": "java-solution-tc-o-n-2-sc-o-n-2",
                "content": "\\t\\tpublic boolean isMatch(String s, String p) \\n\\t\\t{   \\n\\t\\t\\tint m = p.length(),n = s.length();\\n\\t\\t\\tboolean dp[][] = new boolean[m+1][n+1];\\n\\t\\t\\tdp[m][n] = true;\\n\\n\\t\\t\\tfor(int i=m-1;i>=0;i--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(p.charAt(i)==\\'*\\')\\n\\t\\t\\t\\t\\tdp[i][n] = dp[i+1][n];\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(int i=m-1;i>=0;i--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int j=n-1;j>=0;j--)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(p.charAt(i)==\\'?\\' || p.charAt(i)==s.charAt(j))\\n\\t\\t\\t\\t\\t\\tdp[i][j] = dp[i+1][j+1];\\n\\t\\t\\t\\t\\telse if(p.charAt(i)==\\'*\\')\\n\\t\\t\\t\\t\\t\\tdp[i][j] = (dp[i+1][j]||dp[i+1][j+1])||dp[i][j+1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn dp[0][0];\\n\\t\\t}",
                "solutionTags": [
                    "Java",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "\\t\\tpublic boolean isMatch(String s, String p) \\n\\t\\t{   \\n\\t\\t\\tint m = p.length(),n = s.length();\\n\\t\\t\\tboolean dp[][] = new boolean[m+1][n+1];\\n\\t\\t\\tdp[m][n] = true;\\n\\n\\t\\t\\tfor(int i=m-1;i>=0;i--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(p.charAt(i)==\\'*\\')\\n\\t\\t\\t\\t\\tdp[i][n] = dp[i+1][n];\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(int i=m-1;i>=0;i--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int j=n-1;j>=0;j--)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(p.charAt(i)==\\'?\\' || p.charAt(i)==s.charAt(j))\\n\\t\\t\\t\\t\\t\\tdp[i][j] = dp[i+1][j+1];\\n\\t\\t\\t\\t\\telse if(p.charAt(i)==\\'*\\')\\n\\t\\t\\t\\t\\t\\tdp[i][j] = (dp[i+1][j]||dp[i+1][j+1])||dp[i][j+1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn dp[0][0];\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1945845,
                "title": "c-dp-lcs",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        int m = p.length();\\n        int n = s.length();\\n        \\n        vector<vector<bool>> dp(m+1, vector<bool>(n+1, false));\\n        dp[0][0] = true;\\n        \\n        int st = 0;\\n        while(st < m && p[st] == \\'*\\')\\n            dp[++st][0] = true;\\n        \\n        for(int i = 1; i <= m; i++) {\\n            for(int j = 1; j <= n; j++) {\\n                if(p[i-1] == s[j-1] || p[i-1] == \\'?\\')\\n                    dp[i][j] = dp[i-1][j-1];\\n                else if(p[i-1] == \\'*\\')\\n                    dp[i][j] = dp[i][j-1] || dp[i-1][j];\\n                else \\n                    dp[i][j] = false;\\n            }\\n        }\\n        \\n        \\n        // for(int i = 0; i <= m; i++) {\\n        //     for(int j = 0; j <= n; j++)\\n        //         cout << dp[i][j] << \" \";\\n        //     cout << endl;\\n        // }\\n        \\n        return dp[m][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        int m = p.length();\\n        int n = s.length();\\n        \\n        vector<vector<bool>> dp(m+1, vector<bool>(n+1, false));\\n        dp[0][0] = true;\\n        \\n        int st = 0;\\n        while(st < m && p[st] == \\'*\\')\\n            dp[++st][0] = true;\\n        \\n        for(int i = 1; i <= m; i++) {\\n            for(int j = 1; j <= n; j++) {\\n                if(p[i-1] == s[j-1] || p[i-1] == \\'?\\')\\n                    dp[i][j] = dp[i-1][j-1];\\n                else if(p[i-1] == \\'*\\')\\n                    dp[i][j] = dp[i][j-1] || dp[i-1][j];\\n                else \\n                    dp[i][j] = false;\\n            }\\n        }\\n        \\n        \\n        // for(int i = 0; i <= m; i++) {\\n        //     for(int j = 0; j <= n; j++)\\n        //         cout << dp[i][j] << \" \";\\n        //     cout << endl;\\n        // }\\n        \\n        return dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1636756,
                "title": "python-short-top-down-dp",
                "content": "```\\nclass Solution:\\n    @cache\\n    def isMatch(self, s: str, p: str) -> bool:\\n        if not p: return not s\\n        if p[0]==\"*\": \\n            return self.isMatch(s,p[1:]) or (s and self.isMatch(s[1:],p))\\n        else:\\n            return s and p[0] in (s[0],\\'?\\') and self.isMatch(s[1:],p[1:])",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    @cache\\n    def isMatch(self, s: str, p: str) -> bool:\\n        if not p: return not s\\n        if p[0]==\"*\": \\n            return self.isMatch(s,p[1:]) or (s and self.isMatch(s[1:],p))\\n        else:\\n            return s and p[0] in (s[0],\\'?\\') and self.isMatch(s[1:],p[1:])",
                "codeTag": "Java"
            },
            {
                "id": 1545924,
                "title": "c-tabulation-dp-ac-recursive-memo-tle-t-c-o-n-m",
                "content": "**Tabulation DP**\\n```\\nclass Solution {\\npublic:\\n    bool isMatch(string &s, string &p) {\\n        int is=s.size(), ip=p.size();\\n        bool dp[is+1][ip+1];\\n\\n        for(int i=0;i<=is;++i){\\n            for(int j=0;j<=ip;++j){\\n                if(i==0 and j==0){\\n                    dp[i][j] = true;\\n                }else if(i==0){\\n                    if(p[j-1]==\\'*\\') dp[i][j] = dp[i][j-1];\\n                    else dp[i][j] = false;\\n                }else if(j==0){\\n                    dp[i][j] = false;\\n                }else{\\n                    char curS = s[i-1], curP = p[j-1];\\n                    if(curS==curP){\\n                        dp[i][j] = dp[i-1][j-1];\\n                    }else if(curP==\\'?\\'){\\n                        dp[i][j] = dp[i-1][j-1];\\n                    }else if(curP==\\'*\\'){\\n                        dp[i][j] = (dp[i][j-1] or dp[i-1][j-1] or dp[i-1][j]);\\n                    }else{\\n                        dp[i][j] = false;\\n                    }\\n                }\\n            }\\n        }\\n        return dp[is][ip];\\n    }\\n};\\n```\\n\\n**Recursive+memoization  = TLE**\\n```\\nclass Solution {\\npublic:\\n    \\n    int dp[2004][2004];\\n    bool solve(string &s, string &p, int is, int ip){\\n        if(ip==0 and is==0) return true;\\n        else if(is==0){\\n            if(p[ip-1]==\\'*\\') return dp[is][ip] = solve(s,p,is,ip-1);\\n            return false;\\n        }else if(ip==0) return false;\\n        if(dp[is][ip]!=-1) return dp[is][ip];\\n        char curS = s[is-1], curP = p[ip-1];\\n        if(curS==curP or curP==\\'?\\'){  \\n            return dp[is][ip] = solve(s,p,is-1,ip-1);\\n        }else if(curP==\\'*\\'){\\n            bool empty = solve(s,p,is,ip-1);\\n            bool ele1 = solve(s,p,is-1,ip-1);\\n            bool eleN = solve(s,p,is-1,ip);\\n            return dp[is][ip] = (empty or ele1 or eleN);\\n        }else{\\n            return dp[is][ip] = false;\\n        }\\n    }\\n    \\n    bool isMatch(string s, string p) {\\n        memset(dp,-1,sizeof(dp));\\n        int is=s.size(), ip=p.size();\\n        return solve(s,p,is,ip);\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMatch(string &s, string &p) {\\n        int is=s.size(), ip=p.size();\\n        bool dp[is+1][ip+1];\\n\\n        for(int i=0;i<=is;++i){\\n            for(int j=0;j<=ip;++j){\\n                if(i==0 and j==0){\\n                    dp[i][j] = true;\\n                }else if(i==0){\\n                    if(p[j-1]==\\'*\\') dp[i][j] = dp[i][j-1];\\n                    else dp[i][j] = false;\\n                }else if(j==0){\\n                    dp[i][j] = false;\\n                }else{\\n                    char curS = s[i-1], curP = p[j-1];\\n                    if(curS==curP){\\n                        dp[i][j] = dp[i-1][j-1];\\n                    }else if(curP==\\'?\\'){\\n                        dp[i][j] = dp[i-1][j-1];\\n                    }else if(curP==\\'*\\'){\\n                        dp[i][j] = (dp[i][j-1] or dp[i-1][j-1] or dp[i-1][j]);\\n                    }else{\\n                        dp[i][j] = false;\\n                    }\\n                }\\n            }\\n        }\\n        return dp[is][ip];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int dp[2004][2004];\\n    bool solve(string &s, string &p, int is, int ip){\\n        if(ip==0 and is==0) return true;\\n        else if(is==0){\\n            if(p[ip-1]==\\'*\\') return dp[is][ip] = solve(s,p,is,ip-1);\\n            return false;\\n        }else if(ip==0) return false;\\n        if(dp[is][ip]!=-1) return dp[is][ip];\\n        char curS = s[is-1], curP = p[ip-1];\\n        if(curS==curP or curP==\\'?\\'){  \\n            return dp[is][ip] = solve(s,p,is-1,ip-1);\\n        }else if(curP==\\'*\\'){\\n            bool empty = solve(s,p,is,ip-1);\\n            bool ele1 = solve(s,p,is-1,ip-1);\\n            bool eleN = solve(s,p,is-1,ip);\\n            return dp[is][ip] = (empty or ele1 or eleN);\\n        }else{\\n            return dp[is][ip] = false;\\n        }\\n    }\\n    \\n    bool isMatch(string s, string p) {\\n        memset(dp,-1,sizeof(dp));\\n        int is=s.size(), ip=p.size();\\n        return solve(s,p,is,ip);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1311503,
                "title": "recursion-with-memoization-c",
                "content": "```cpp\\nclass Solution {\\npublic:\\n\\n    bool solve(string &s, string &p, int i, int j, vector<vector<int> > &dp)\\n    {\\n        if(i==s.size() && j==p.size()) return true;\\n        if(j==p.size()) return false;\\n        \\n        if(dp[i][j]!=-1) \\n            return dp[i][j];\\n        \\n        if(i==s.size())\\n        {\\n            int jj = j;\\n            while( (j<p.size()) && (p[j] == \\'*\\') ) j++;\\n            dp[i][j] = (j==p.size());\\n            return dp[i][jj] = dp[i][j];\\n        }\\n        \\n        if((s[i]==p[j]) || (p[j] == \\'?\\')) \\n            return dp[i][j] = solve(s, p, i+1, j+1, dp);\\n        if(p[j] == \\'*\\')\\n            return dp[i][j] = (solve(s, p, i, j+1, dp) || solve(s, p, i+1, j, dp) || solve(s, p, i+1, j+1, dp));\\n        \\n        return dp[i][j] = false;\\n    }\\n    bool isMatch(string s, string p) {\\n         vector<vector<int>> dp(s.size()+1, vector<int>(p.size()+1, -1));\\n        return solve(s, p, 0, 0, dp);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n\\n    bool solve(string &s, string &p, int i, int j, vector<vector<int> > &dp)\\n    {\\n        if(i==s.size() && j==p.size()) return true;\\n        if(j==p.size()) return false;\\n        \\n        if(dp[i][j]!=-1) \\n            return dp[i][j];\\n        \\n        if(i==s.size())\\n        {\\n            int jj = j;\\n            while( (j<p.size()) && (p[j] == \\'*\\') ) j++;\\n            dp[i][j] = (j==p.size());\\n            return dp[i][jj] = dp[i][j];\\n        }\\n        \\n        if((s[i]==p[j]) || (p[j] == \\'?\\')) \\n            return dp[i][j] = solve(s, p, i+1, j+1, dp);\\n        if(p[j] == \\'*\\')\\n            return dp[i][j] = (solve(s, p, i, j+1, dp) || solve(s, p, i+1, j, dp) || solve(s, p, i+1, j+1, dp));\\n        \\n        return dp[i][j] = false;\\n    }\\n    bool isMatch(string s, string p) {\\n         vector<vector<int>> dp(s.size()+1, vector<int>(p.size()+1, -1));\\n        return solve(s, p, 0, 0, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1248251,
                "title": "c-easy-bottom-up-dp",
                "content": "```\\n bool isMatch(string s, string p) \\n    {\\n        int n = s.size();\\n        int m = p.size();\\n        \\n        bool t[n + 1][m + 1];\\n        memset(t, 0, sizeof(t));\\n        t[0][0] = 1;\\n        \\n        for(int i = 1; i <= m; i++)\\n        {\\n            if(p[i - 1] == \\'*\\')\\n                t[0][i] = t[0][i - 1];\\n        }\\n        for(int i = 1; i <= n; i++)\\n        {\\n            for(int j = 1; j <= m; j++)\\n            {\\n                if(p[j - 1] == \\'*\\')\\n                    t[i][j] = t[i - 1][j] || t[i][j - 1];\\n               else\\n                   t[i][j] = ((s[i - 1] == p[j - 1] || p[j - 1]==\\'?\\') && t[i - 1][j - 1]);\\n            }\\n        }\\n       return (t[n][m]);\\n  }\\n```\\n\\n\\n```\\n//for loop can also be written as:\\n    for(int i = 1; i <= n; i++)\\n        {\\n            for(int j = 1; j <= m; j++)\\n            {\\n                if(pattern[j - 1] == \\'*\\')\\n                    t[i][j] = t[i - 1][j] || t[i][j - 1];\\n        \\n                else if(pattern[j - 1] == \\'?\\' || pattern[j - 1] == str[i - 1])\\n                        t[i][j] = t[i - 1][j - 1];\\n                else t[i][j] = 0;\\n                    \\n            }\\n        } \\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n bool isMatch(string s, string p) \\n    {\\n        int n = s.size();\\n        int m = p.size();\\n        \\n        bool t[n + 1][m + 1];\\n        memset(t, 0, sizeof(t));\\n        t[0][0] = 1;\\n        \\n        for(int i = 1; i <= m; i++)\\n        {\\n            if(p[i - 1] == \\'*\\')\\n                t[0][i] = t[0][i - 1];\\n        }\\n        for(int i = 1; i <= n; i++)\\n        {\\n            for(int j = 1; j <= m; j++)\\n            {\\n                if(p[j - 1] == \\'*\\')\\n                    t[i][j] = t[i - 1][j] || t[i][j - 1];\\n               else\\n                   t[i][j] = ((s[i - 1] == p[j - 1] || p[j - 1]==\\'?\\') && t[i - 1][j - 1]);\\n            }\\n        }\\n       return (t[n][m]);\\n  }\\n```\n```\\n//for loop can also be written as:\\n    for(int i = 1; i <= n; i++)\\n        {\\n            for(int j = 1; j <= m; j++)\\n            {\\n                if(pattern[j - 1] == \\'*\\')\\n                    t[i][j] = t[i - 1][j] || t[i][j - 1];\\n        \\n                else if(pattern[j - 1] == \\'?\\' || pattern[j - 1] == str[i - 1])\\n                        t[i][j] = t[i - 1][j - 1];\\n                else t[i][j] = 0;\\n                    \\n            }\\n        } \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1103091,
                "title": "java-share-my-3ms-solution-not-dp-easy-to-understand",
                "content": "My idea is to split pattern into multiple sub-patterns by \\'*\\'.\\nFor example:\\n```\\np        sub-patterns\\n\"\"    -> []\\n\"a\"   -> [\"a\"]\\n\"a*b\" -> [\"a\", \"b\"]\\n\"*a\"  -> [\"\", \"a\"]\\n\"a*\"  -> [\"a\", \"\"]\\n\"*a*\" -> [\"\", \"a\", \"\"]\\n\"*\"   -> [\"\", \"\"]\\n\"**\"  -> [\"\", \"\", \"\"]\\n```\\nThen search those sub-patterns in the string. String is matched when:\\n```text\\nif (sub-patterns == []) only empty string can be matched.\\nif (sub-patterns.size() == 1) string must be strictly matched.\\nif (sub-patterns.size() >= 2) {\\n    string must match the fist sub-pattern from start. &&\\n\\tstring must match the last sub-pattern at end. &&\\n\\tmiddle sub-patterns can be matched by order.\\n}\\n```\\nComplexity:\\n```\\nspace: O(p.length)\\n time: O(s.length * p.length) for worst scenario\\n```\\nShow code:\\n```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        int slen = s.length();\\n        List<String> parts = split(p.toCharArray());\\n        if (parts.isEmpty()) return slen == 0;\\n        \\n        // handle first\\n        String firstP = parts.get(0);\\n        if (!match(s, 0, firstP)) return false;\\n        if (parts.size() == 1) return slen == firstP.length();\\n        \\n        int si = firstP.length();\\n        \\n        // handle middle\\n        FOR_PARTS:\\n        for (int i = 1; i < parts.size() - 1; ++i) {\\n            String currP = parts.get(i);\\n            while (si <= slen) {\\n                if (match(s, si, currP)) {\\n                    si += currP.length();\\n                    continue FOR_PARTS;\\n                }\\n                ++si;\\n            }\\n            return false;\\n        }\\n            \\n        // handle last\\n        String lastP = parts.get(parts.size()-1);\\n        int lastSlen = slen - si;\\n        if (lastSlen < lastP.length()) return false;\\n        si = slen - lastP.length();\\n        return match(s, si, lastP);\\n    }\\n    \\n    private boolean match(String s, int si, String p) {\\n        int plen = p.length();\\n        int slen = s.length() - si;\\n        if (plen == 0) return true;\\n        if (slen < plen) return false;\\n        for (int i = 0; i < plen; ++i) {\\n            if (p.charAt(i) == \\'?\\') continue;\\n            if (s.charAt(si+i) != p.charAt(i)) return false;\\n        }\\n        return true;\\n    }\\n    \\n    // [] -> p is empty\\n    // [\"s1\"] -> p has no \\'*\\'\\n    // [\"s1\", \"s2\"] -> p has one \\'*\\'\\n    // [\"\", \"s1\"] -> p has \\'*\\' ahead\\n    // [\"s1\", \"\"] -> p has \\'*\\' at end\\n    // [\"\", \"\"] -> p == \\'*\\'\\n    private List<String> split(char[] p) {\\n        List<String> parts = new ArrayList<>();\\n        if (p.length > 0) {\\n            StringBuilder sb = new StringBuilder();\\n            for (char c : p) {\\n                if (c != \\'*\\') {\\n                    sb.append(c);\\n                } else {\\n                    parts.add(sb.toString());\\n                    sb = new StringBuilder();\\n                }\\n            }\\n            parts.add(sb.toString());\\n        }\\n        return parts;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\np        sub-patterns\\n\"\"    -> []\\n\"a\"   -> [\"a\"]\\n\"a*b\" -> [\"a\", \"b\"]\\n\"*a\"  -> [\"\", \"a\"]\\n\"a*\"  -> [\"a\", \"\"]\\n\"*a*\" -> [\"\", \"a\", \"\"]\\n\"*\"   -> [\"\", \"\"]\\n\"**\"  -> [\"\", \"\", \"\"]\\n```\n```text\\nif (sub-patterns == []) only empty string can be matched.\\nif (sub-patterns.size() == 1) string must be strictly matched.\\nif (sub-patterns.size() >= 2) {\\n    string must match the fist sub-pattern from start. &&\\n\\tstring must match the last sub-pattern at end. &&\\n\\tmiddle sub-patterns can be matched by order.\\n}\\n```\n```\\nspace: O(p.length)\\n time: O(s.length * p.length) for worst scenario\\n```\n```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        int slen = s.length();\\n        List<String> parts = split(p.toCharArray());\\n        if (parts.isEmpty()) return slen == 0;\\n        \\n        // handle first\\n        String firstP = parts.get(0);\\n        if (!match(s, 0, firstP)) return false;\\n        if (parts.size() == 1) return slen == firstP.length();\\n        \\n        int si = firstP.length();\\n        \\n        // handle middle\\n        FOR_PARTS:\\n        for (int i = 1; i < parts.size() - 1; ++i) {\\n            String currP = parts.get(i);\\n            while (si <= slen) {\\n                if (match(s, si, currP)) {\\n                    si += currP.length();\\n                    continue FOR_PARTS;\\n                }\\n                ++si;\\n            }\\n            return false;\\n        }\\n            \\n        // handle last\\n        String lastP = parts.get(parts.size()-1);\\n        int lastSlen = slen - si;\\n        if (lastSlen < lastP.length()) return false;\\n        si = slen - lastP.length();\\n        return match(s, si, lastP);\\n    }\\n    \\n    private boolean match(String s, int si, String p) {\\n        int plen = p.length();\\n        int slen = s.length() - si;\\n        if (plen == 0) return true;\\n        if (slen < plen) return false;\\n        for (int i = 0; i < plen; ++i) {\\n            if (p.charAt(i) == \\'?\\') continue;\\n            if (s.charAt(si+i) != p.charAt(i)) return false;\\n        }\\n        return true;\\n    }\\n    \\n    // [] -> p is empty\\n    // [\"s1\"] -> p has no \\'*\\'\\n    // [\"s1\", \"s2\"] -> p has one \\'*\\'\\n    // [\"\", \"s1\"] -> p has \\'*\\' ahead\\n    // [\"s1\", \"\"] -> p has \\'*\\' at end\\n    // [\"\", \"\"] -> p == \\'*\\'\\n    private List<String> split(char[] p) {\\n        List<String> parts = new ArrayList<>();\\n        if (p.length > 0) {\\n            StringBuilder sb = new StringBuilder();\\n            for (char c : p) {\\n                if (c != \\'*\\') {\\n                    sb.append(c);\\n                } else {\\n                    parts.add(sb.toString());\\n                    sb = new StringBuilder();\\n                }\\n            }\\n            parts.add(sb.toString());\\n        }\\n        return parts;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1032324,
                "title": "javascript-easy-to-read-dynamic-programming-solution-with-drawing",
                "content": "For this problem, it\\'s important to remember a few things:\\n1. `?` can map to any **character** (can not be a space, must be a-z)\\n2. `*` is the most versatile, since it can be a sequence of numbers or blank (`\"\"`)\\n\\nFirst, we create a DP array (text.length + 1) by (text2.length + 1). We do plus once because we make room for the blank string (\" \").\\n\\n**Setup**\\n1. We know that blank to blank is true, because they are equal strings. \\n2. If we have a `*` in our text2, we take the previous value in our DP array. This is evident in going from blank (\" \") to \"*\".  \\n\\n**Using Subproblems to make up the entire problem**\\n1. We know if the two letters are equal to each other or text2 === \"?\", our value for dp[row][col] is the same as dp[row - 1][col - 1]. Why? Let\\'s look at `acdeb` to `*a*b`. If we were to drop the `b`s in both of these, we would have `acde` and `*a*`. These two are equivalent, so we just take the solution of `acde` and `*a*` and put it into the square for  `acdeb` to `*a*b`\\n2. If text2[index] is a `*`, we can look at the cell above or the cell to the left. Why? Look at `ac` compared to `*a*`. If we drop the c, our solution will be the same as `a` compared to `*a*`. If that\\'s true, dp[row][col] is true. Notice though if we look at `*a` compared to `ac`, it is false. That is okay because the `*` makes things more flexible, and we take the `OR` of the top or left cell.\\n\\n![image](https://assets.leetcode.com/users/images/b032ec12-edc2-4cb2-9dd6-00cf0df8e8c8_1611468211.9012723.png)\\n\\nThis is a hard problem, and I **did not get it on my first try**. I had to look at the solution and make sense of it. I am going to try to make a video to better understand it myself hopefully. If you have any questions, please let me know.\\n\\n```\\nconst isMatch = (text1, text2) => {\\n\\tlet dp = [...new Array(text1.length + 1)].map(() =>\\n\\t\\tArray(text2.length + 1).fill(false)\\n\\t);\\n\\n    // blank to blank always true\\n    dp[0][0] = true;\\n    \\n\\t// Only text2 will have `*` or `?`\\n    for (var col = 1; col <= dp[0].length; col ++) {\\n        if (text2[col - 1] === \\'*\\') {\\n            dp[0][col] = dp[0][col - 1];\\n        }\\n    }\\n\\n\\tfor (let row = 1; row < dp.length; row++) {\\n\\t\\tfor (let col = 1; col < dp[0].length; col++) {\\n\\t\\t\\tlet text1Letter = text1[row - 1],\\n\\t\\t\\t\\ttext2Letter = text2[col - 1];\\n\\n\\t\\t\\tif (text1Letter == text2Letter || text2Letter == \\'?\\')\\n\\t\\t\\t\\tdp[row][col] = dp[row - 1][col - 1];\\n\\t\\t\\telse if (text2Letter == \\'*\\')\\n\\t\\t\\t\\tdp[row][col] = dp[row][col - 1] || dp[row - 1][col];\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[text1.length][text2.length];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nconst isMatch = (text1, text2) => {\\n\\tlet dp = [...new Array(text1.length + 1)].map(() =>\\n\\t\\tArray(text2.length + 1).fill(false)\\n\\t);\\n\\n    // blank to blank always true\\n    dp[0][0] = true;\\n    \\n\\t// Only text2 will have `*` or `?`\\n    for (var col = 1; col <= dp[0].length; col ++) {\\n        if (text2[col - 1] === \\'*\\') {\\n            dp[0][col] = dp[0][col - 1];\\n        }\\n    }\\n\\n\\tfor (let row = 1; row < dp.length; row++) {\\n\\t\\tfor (let col = 1; col < dp[0].length; col++) {\\n\\t\\t\\tlet text1Letter = text1[row - 1],\\n\\t\\t\\t\\ttext2Letter = text2[col - 1];\\n\\n\\t\\t\\tif (text1Letter == text2Letter || text2Letter == \\'?\\')\\n\\t\\t\\t\\tdp[row][col] = dp[row - 1][col - 1];\\n\\t\\t\\telse if (text2Letter == \\'*\\')\\n\\t\\t\\t\\tdp[row][col] = dp[row][col - 1] || dp[row - 1][col];\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[text1.length][text2.length];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 991061,
                "title": "easy-python-dp-solution",
                "content": "```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        dp = [[0 for i in range(len(s)+1)] for j in range(len(p)+1)] \\n        \\n        dp[0][0] = 1\\n        i=0\\n        while i<len(p) and p[i]==\"*\":\\n            dp[i+1][0]=1\\n            i+=1\\n        for i in range(1,len(p)+1):\\n            for j in range(1,len(s)+1):\\n                if p[i-1]==s[j-1] or p[i-1]==\"?\":\\n                    dp[i][j] = dp[i-1][j-1]\\n                elif p[i-1]==\"*\":\\n                    dp[i][j] = dp[i-1][j]|dp[i][j-1]\\n                else:\\n                    dp[i][j] = 0\\n                    \\n        return dp[len(p)][len(s)]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        dp = [[0 for i in range(len(s)+1)] for j in range(len(p)+1)] \\n        \\n        dp[0][0] = 1\\n        i=0\\n        while i<len(p) and p[i]==\"*\":\\n            dp[i+1][0]=1\\n            i+=1\\n        for i in range(1,len(p)+1):\\n            for j in range(1,len(s)+1):\\n                if p[i-1]==s[j-1] or p[i-1]==\"?\":\\n                    dp[i][j] = dp[i-1][j-1]\\n                elif p[i-1]==\"*\":\\n                    dp[i][j] = dp[i-1][j]|dp[i][j-1]\\n                else:\\n                    dp[i][j] = 0\\n                    \\n        return dp[len(p)][len(s)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 903975,
                "title": "simple-dp-solution-any-language",
                "content": "Please refer below link and then code for proper understanding. Please upvote if you find it useful.\\nhttps://www.youtube.com/watch?v=3ZDZ-N0EPV0 - tushar roy\\n```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        int n = s.size();\\n        int m = p.size();\\n        bool dp[n+1][m+1];\\n        dp[0][0]=true;\\n        for(int i=1;i<=n;i++)dp[i][0]=false;\\n        int flag=1;\\n        for(int j=0;j<m;j++){ \\n            if(p[j]==\\'*\\'&&flag)dp[0][j+1]=true;  // if p string starts with * like (***a?b or *aa) then we have true value for corresponding empty s string as *** in ***a?b will be considered empty.\\n            else{\\n                flag=0;\\n                dp[0][j+1]=false;\\n            }\\n        }\\n        \\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(s[i-1]==p[j-1]||p[j-1]==\\'?\\')dp[i][j]=dp[i-1][j-1];\\n                else if(p[j-1]==\\'*\\')dp[i][j]=dp[i-1][j]||dp[i][j-1];\\n                else dp[i][j]=false;\\n            }\\n        }\\n        \\n        return dp[n][m];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        int n = s.size();\\n        int m = p.size();\\n        bool dp[n+1][m+1];\\n        dp[0][0]=true;\\n        for(int i=1;i<=n;i++)dp[i][0]=false;\\n        int flag=1;\\n        for(int j=0;j<m;j++){ \\n            if(p[j]==\\'*\\'&&flag)dp[0][j+1]=true;  // if p string starts with * like (***a?b or *aa) then we have true value for corresponding empty s string as *** in ***a?b will be considered empty.\\n            else{\\n                flag=0;\\n                dp[0][j+1]=false;\\n            }\\n        }\\n        \\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(s[i-1]==p[j-1]||p[j-1]==\\'?\\')dp[i][j]=dp[i-1][j-1];\\n                else if(p[j-1]==\\'*\\')dp[i][j]=dp[i-1][j]||dp[i][j-1];\\n                else dp[i][j]=false;\\n            }\\n        }\\n        \\n        return dp[n][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 816048,
                "title": "java-top-down-solution",
                "content": "class Solution {\\n\\n    public boolean isMatch(String s, String p) {\\n        return isMatchTDhelper(s, p, new int[s.length()][p.length()]);\\n    }\\n\\n\\tpublic static boolean isMatchTDhelper(String s, String p, int[][] memo) {\\n\\n\\t\\tif (s.length() == 0 && p.length() == 0)\\n\\t\\t\\treturn true;\\n\\n\\t\\tif (s.length() == 0 && p.length() != 0) {\\n\\t\\t\\tfor (char ch : p.toCharArray()) {\\n\\t\\t\\t\\tif (ch != \\'*\\')\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\tif (s.length() != 0 && p.length() == 0)\\n\\t\\t\\treturn false;\\n\\n\\t\\tif (memo[s.length() - 1][p.length() - 1] != 0)\\n\\t\\t\\treturn (memo[s.length() - 1][p.length() - 1]) == 2 ? true : false;\\n\\n\\t\\tchar ch1 = s.charAt(0);\\n\\t\\tchar ch2 = p.charAt(0);\\n\\n\\t\\tboolean ans = false;\\n\\n\\t\\tString ros1 = s.substring(1);\\n\\t\\tString ros2 = p.substring(1);\\n\\n\\t\\tif (ch2 == \\'?\\')\\n\\t\\t\\tans = isMatchTDhelper(ros1, ros2, memo);\\n\\n\\t\\telse if (ch2 == \\'*\\') {\\n\\t\\t\\tans = isMatchTDhelper(s, ros2, memo);\\n\\t\\t\\tans = ans || isMatchTDhelper(ros1, p, memo);\\n\\t\\t}\\n\\n\\t\\telse\\n\\t\\t\\tans = (ch1 == ch2) ? isMatchTDhelper(ros1, ros2, memo) : false;\\n\\n\\t\\tmemo[s.length() - 1][p.length() - 1] = (ans) ? 2 : 1;\\n\\t\\treturn ans;\\n\\t}\\n    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public boolean isMatch(String s, String p) {\\n        return isMatchTDhelper(s, p, new int[s.length()][p.length()]);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 726474,
                "title": "c-two-pointers-o-n-2-and-o-1-space-beats-98-95",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        return isMatchHelper(s.c_str(), p.c_str());\\n    }\\nprivate:\\n    bool isMatchHelper(const char *s, const char *p) {\\n        bool star = false;\\n        const char *str;\\n        const char *ptr;\\n        for (str = s, ptr = p; *str != \\'\\\\0\\'; str++, ptr++) {\\n            switch(*ptr) {\\n                case \\'?\\' :\\n                    break; // str step for 1, ptr step for 1\\n                case \\'*\\' :\\n                    star = true;\\n                    s = str;\\n                    p = ptr;\\n                    while (*p == \\'*\\') p++; // skip continuous \\'*\\'\\n                    if (*p == \\'\\\\0\\') return true;\\n                    str = s-1;\\n                    ptr = p-1;\\n                    break;\\n                default:\\n                    if (*str != *ptr) {\\n                        if (!star) return false;\\n                        s++;\\n                        str = s - 1;\\n                        ptr = p - 1;\\n                    }\\n            }\\n        }\\n        while (*ptr == \\'*\\') ptr++;\\n        return (*ptr == \\'\\\\0\\');\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        return isMatchHelper(s.c_str(), p.c_str());\\n    }\\nprivate:\\n    bool isMatchHelper(const char *s, const char *p) {\\n        bool star = false;\\n        const char *str;\\n        const char *ptr;\\n        for (str = s, ptr = p; *str != \\'\\\\0\\'; str++, ptr++) {\\n            switch(*ptr) {\\n                case \\'?\\' :\\n                    break; // str step for 1, ptr step for 1\\n                case \\'*\\' :\\n                    star = true;\\n                    s = str;\\n                    p = ptr;\\n                    while (*p == \\'*\\') p++; // skip continuous \\'*\\'\\n                    if (*p == \\'\\\\0\\') return true;\\n                    str = s-1;\\n                    ptr = p-1;\\n                    break;\\n                default:\\n                    if (*str != *ptr) {\\n                        if (!star) return false;\\n                        s++;\\n                        str = s - 1;\\n                        ptr = p - 1;\\n                    }\\n            }\\n        }\\n        while (*ptr == \\'*\\') ptr++;\\n        return (*ptr == \\'\\\\0\\');\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 665179,
                "title": "python-96-66",
                "content": "```\\nclass Solution:\\n    def isMatch(self, string: str, pattern: str) -> bool:\\n        \\n        s = 0\\n        p = 0\\n        match = 0\\n        starIdx = -1\\n        \\n        # while we have not gone through all characters in the string\\n        while s < len(string):\\n            \\n            # if there are characters left in the pattern and string and pattern match 1-1, increment both\\n            if p < len(pattern) and (pattern[p] == \\'?\\' or string[s] == pattern[p]):\\n                s += 1\\n                p += 1\\n            \\n            # if there are characters left in the pattern and the current pattern character is *, \\n            # save the star index, save the match index, and increment the pattern\\n            elif p < len(pattern) and pattern[p] == \\'*\\':\\n                starIdx = p\\n                match = s\\n                p += 1\\n            \\n            # if the last char was *, increment match and assign to s\\n            elif starIdx != -1:\\n                p = starIdx + 1\\n                match += 1\\n                s = match\\n            \\n            else:\\n                return False\\n        \\n        # make sure remaining chars are all *\\n        while p < len(pattern) and pattern[p] == \\'*\\':\\n            p += 1\\n\\n        return p == len(pattern)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isMatch(self, string: str, pattern: str) -> bool:\\n        \\n        s = 0\\n        p = 0\\n        match = 0\\n        starIdx = -1\\n        \\n        # while we have not gone through all characters in the string\\n        while s < len(string):\\n            \\n            # if there are characters left in the pattern and string and pattern match 1-1, increment both\\n            if p < len(pattern) and (pattern[p] == \\'?\\' or string[s] == pattern[p]):\\n                s += 1\\n                p += 1\\n            \\n            # if there are characters left in the pattern and the current pattern character is *, \\n            # save the star index, save the match index, and increment the pattern\\n            elif p < len(pattern) and pattern[p] == \\'*\\':\\n                starIdx = p\\n                match = s\\n                p += 1\\n            \\n            # if the last char was *, increment match and assign to s\\n            elif starIdx != -1:\\n                p = starIdx + 1\\n                match += 1\\n                s = match\\n            \\n            else:\\n                return False\\n        \\n        # make sure remaining chars are all *\\n        while p < len(pattern) and pattern[p] == \\'*\\':\\n            p += 1\\n\\n        return p == len(pattern)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 565256,
                "title": "java-dfs-memo-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        return dfs(s, p, 0, 0);\\n    }\\n    \\n    HashMap<String, Boolean> memo = new HashMap<>();\\n    public boolean dfs(String s, String p, int idx1, int idx2) {\\n        if (idx1 == s.length() && idx2 == p.length()) {\\n            return true;\\n        }\\n        \\n        if (!s.equals(\"\") && !(idx2 < p.length() && p.charAt(idx2) == \\'*\\') && ((idx1 == s.length() && idx2 != p.length()) || (idx1 != s.length() && idx2 == p.length()))) {\\n            return false;\\n        }\\n        \\n        String key = \"\"+idx1+\",\"+idx2;\\n        if (memo.containsKey(key)) {\\n            return memo.get(key);\\n        }\\n        \\n        boolean result = false;\\n        if (idx2 < p.length() && p.charAt(idx2) == \\'?\\') {\\n            result = dfs(s, p, idx1+1, idx2+1);\\n        } else if (idx2 < p.length() && p.charAt(idx2) == \\'*\\') {\\n            for (int i = idx1; i <= s.length(); i++) {\\n                if (dfs(s, p, i, idx2+1)) {\\n                    result = true;\\n                    break;\\n                }\\n            }\\n        } else if (idx2 < p.length() && idx1 < s.length() && p.charAt(idx2) == s.charAt(idx1)) {\\n            result = dfs(s, p, idx1+1, idx2+1);\\n        }\\n        \\n        memo.put(key, result);\\n        return result;\\n    }\\n}\\n```\\n\\nUpdate : Cleaned up version\\n\\n```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        if (s.equals(p)) return true;\\n        \\n        return dfs(s, p, 0, 0);\\n    }\\n    HashMap<String, Boolean> memo = new HashMap<>();\\n    public boolean dfs(String s, String p, int idx1, int idx2) {\\n        if (idx1 >= s.length() && (idx2 >= p.length() || (idx2 == p.length()-1 && p.charAt(idx2) == \\'*\\'))) {\\n            return true;\\n        }\\n        if (idx1 >= s.length() && idx2 >= p.length()) return false;\\n        String key = \"\"+idx1+\",\"+idx2;\\n        if (memo.containsKey(key)) {\\n            return memo.get(key);\\n        }\\n        \\n        char ch1 = (idx1 >= s.length())? \\' \\' : s.charAt(idx1);\\n        char ch2 = (idx2 >= p.length())? \\':\\' : p.charAt(idx2);\\n        boolean result = false;\\n        if (ch1 == ch2 || (ch2 == \\'?\\' && ch1 != \\' \\')) {\\n            result = dfs(s, p, idx1+1, idx2+1);\\n        } else if (ch2 == \\'*\\') {\\n            if (idx1 >= s.length()) return dfs(s, p, idx1, idx2+1);\\n            for (int i = idx1; i <= s.length(); i++) {\\n                if (dfs(s, p, i, idx2+1)) {\\n                    result = true;\\n                    break;\\n                }\\n            }\\n        }\\n        memo.put(key, result);\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        return dfs(s, p, 0, 0);\\n    }\\n    \\n    HashMap<String, Boolean> memo = new HashMap<>();\\n    public boolean dfs(String s, String p, int idx1, int idx2) {\\n        if (idx1 == s.length() && idx2 == p.length()) {\\n            return true;\\n        }\\n        \\n        if (!s.equals(\"\") && !(idx2 < p.length() && p.charAt(idx2) == \\'*\\') && ((idx1 == s.length() && idx2 != p.length()) || (idx1 != s.length() && idx2 == p.length()))) {\\n            return false;\\n        }\\n        \\n        String key = \"\"+idx1+\",\"+idx2;\\n        if (memo.containsKey(key)) {\\n            return memo.get(key);\\n        }\\n        \\n        boolean result = false;\\n        if (idx2 < p.length() && p.charAt(idx2) == \\'?\\') {\\n            result = dfs(s, p, idx1+1, idx2+1);\\n        } else if (idx2 < p.length() && p.charAt(idx2) == \\'*\\') {\\n            for (int i = idx1; i <= s.length(); i++) {\\n                if (dfs(s, p, i, idx2+1)) {\\n                    result = true;\\n                    break;\\n                }\\n            }\\n        } else if (idx2 < p.length() && idx1 < s.length() && p.charAt(idx2) == s.charAt(idx1)) {\\n            result = dfs(s, p, idx1+1, idx2+1);\\n        }\\n        \\n        memo.put(key, result);\\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        if (s.equals(p)) return true;\\n        \\n        return dfs(s, p, 0, 0);\\n    }\\n    HashMap<String, Boolean> memo = new HashMap<>();\\n    public boolean dfs(String s, String p, int idx1, int idx2) {\\n        if (idx1 >= s.length() && (idx2 >= p.length() || (idx2 == p.length()-1 && p.charAt(idx2) == \\'*\\'))) {\\n            return true;\\n        }\\n        if (idx1 >= s.length() && idx2 >= p.length()) return false;\\n        String key = \"\"+idx1+\",\"+idx2;\\n        if (memo.containsKey(key)) {\\n            return memo.get(key);\\n        }\\n        \\n        char ch1 = (idx1 >= s.length())? \\' \\' : s.charAt(idx1);\\n        char ch2 = (idx2 >= p.length())? \\':\\' : p.charAt(idx2);\\n        boolean result = false;\\n        if (ch1 == ch2 || (ch2 == \\'?\\' && ch1 != \\' \\')) {\\n            result = dfs(s, p, idx1+1, idx2+1);\\n        } else if (ch2 == \\'*\\') {\\n            if (idx1 >= s.length()) return dfs(s, p, idx1, idx2+1);\\n            for (int i = idx1; i <= s.length(); i++) {\\n                if (dfs(s, p, i, idx2+1)) {\\n                    result = true;\\n                    break;\\n                }\\n            }\\n        }\\n        memo.put(key, result);\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 491219,
                "title": "c-o-mn-memoization-and-tabular-solution-detailed-explanation",
                "content": "**Tabular Solution**\\n```\\n// TC: O(MN), SC: O(MN)\\nbool regexMatchTabular(string& s, string& p) {\\n\\tvector<vector<int>> dp(s.size() + 1, vector<int>(p.size() + 1, 1));\\n\\n\\t// when source string is zero, pattern is only allowed to have *\\n\\tfor(int i = 1; i <= p.size(); i++)\\n\\t\\tdp[0][i] = p[i-1] == \\'*\\' && i-2 >= 0 ? dp[0][i-2] : 0;\\n\\t// when pattern length is zero\\n\\tfor(int i = 1; i <= s.size(); i++)\\n\\t\\tdp[i][0] = 0;\\n\\n\\tfor(int i = 1; i <= s.size(); i++) {\\n\\t\\tfor(int j = 1; j <= p.size(); j++) {\\n\\t\\t\\t// if the chars are same \\n\\t\\t\\tif(s[i-1] == p[j-1])\\n\\t\\t\\t\\tdp[i][j] = dp[i-1][j-1];\\n\\t\\t\\telse {\\n\\t\\t\\t\\t// different chars are allowed only incase of wilcard chars\\n\\t\\t\\t\\tif(p[j-1] == \\'.\\')\\n\\t\\t\\t\\t\\tdp[i][j] = dp[i-1][j-1];\\n\\t\\t\\t\\t// when *\\n\\t\\t\\t\\telse if(p[j-1] == \\'*\\') {\\n\\t\\t\\t\\t\\t// we have two choices, either use * or don\\'t use\\n\\t\\t\\t\\t\\tint with_star = (j - 2 >= 0) ? (p[j-2] == \\'.\\' || s[i-1] == p[j-2]) && dp[i-1][j] : 0;\\n\\t\\t\\t\\t\\tint without_star = (j - 2 >= 0) ? dp[i][j-2] : 0;\\n\\t\\t\\t\\t\\tdp[i][j] = with_star || without_star;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// when chars are diff\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tdp[i][j] = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[s.size()][p.size()];\\n}  \\n\\nbool isMatch(string s, string p) {\\n\\t//return regexMatchDriver(s, p);\\n\\treturn regexMatchTabular(s, p);\\n}\\n```\\n\\n**Using Memoization**\\n```\\n// TC: O(MN), SC: O(MN)\\nint regexMatch(vector<vector<int>>& dp, string& s, string& p, \\n\\t\\t\\t   int i, int j) {\\n\\tif(j < 0)\\n\\t\\treturn 0;\\n\\tif(i == 0 && j == 0)\\n\\t\\treturn dp[i][j] = 1;\\n\\t// if the length of any string has become 0\\n\\t// then it is not a match except if the char in pattern is *\\n\\tif(i == 0 && j > 0)\\n\\t\\treturn dp[i][j] = p[j-1] == \\'*\\' && regexMatch(dp, s, p, i, j-1);\\n\\t// pattern has finished but not the source\\n\\tif(i != 0 && j == 0)\\n\\t\\treturn dp[i][j] = 0;\\n\\n\\tif(dp[i][j] == -1) {\\n\\t\\t// initially mark it true\\n\\t\\tdp[i][j] = 1;\\n\\t\\t// if the chars are same\\n\\t\\tif(s[i-1] == p[j-1])\\n\\t\\t\\tdp[i][j] = regexMatch(dp, s, p, i-1, j-1);\\n\\t\\telse {\\n\\t\\t\\t// when chars are different, then only if the pattern contains \\'.\\'\\n\\t\\t\\t// or \\'*\\' matching the string s then it is valid\\n\\t\\t\\tif(p[j-1] == \\'?\\')\\n\\t\\t\\t\\tdp[i][j] = regexMatch(dp, s, p, i-1, j-1);\\n\\t\\t\\telse if(p[j-1] == \\'*\\') {\\n\\t\\t\\t\\t// With * we can either try using it or not use it \\n\\t\\t\\t\\tint with_star = 0, without_star = 0;\\n\\t\\t\\t\\t// USE *\\n\\t\\t\\t\\t// if the pattern char match the * char of string source\\n\\t\\t\\t\\t// check for the previous char of source\\n\\t\\t\\t\\twith_star = regexMatch(dp, s, p, i-1, j);\\n\\n\\t\\t\\t\\t// DON\\'T USE * \\n\\t\\t\\t\\t// also covers the case when current pattern char is wildcard * and doesn\\'t match\\n\\t\\t\\t\\t// the char of source, try the char before \\'*\\' of pattern\\n\\t\\t\\t\\twithout_star = regexMatch(dp, s, p, i, j-1);\\n\\t\\t\\t\\tdp[i][j] = with_star || without_star;\\n\\t\\t\\t}\\n\\t\\t\\t// chars don\\'t match\\n\\t\\t\\telse \\n\\t\\t\\t\\tdp[i][j] = 0;\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[i][j];\\n}\\n\\n// driver memoization function\\nbool regexMatchDriver(string& s, string& p) {\\n\\tvector<vector<int>> dp(s.size() + 1, vector<int>(p.size() + 1, -1));\\n\\tregexMatch(dp, s, p, s.size(), p.size());\\n\\treturn dp[s.size()][p.size()];\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n// TC: O(MN), SC: O(MN)\\nbool regexMatchTabular(string& s, string& p) {\\n\\tvector<vector<int>> dp(s.size() + 1, vector<int>(p.size() + 1, 1));\\n\\n\\t// when source string is zero, pattern is only allowed to have *\\n\\tfor(int i = 1; i <= p.size(); i++)\\n\\t\\tdp[0][i] = p[i-1] == \\'*\\' && i-2 >= 0 ? dp[0][i-2] : 0;\\n\\t// when pattern length is zero\\n\\tfor(int i = 1; i <= s.size(); i++)\\n\\t\\tdp[i][0] = 0;\\n\\n\\tfor(int i = 1; i <= s.size(); i++) {\\n\\t\\tfor(int j = 1; j <= p.size(); j++) {\\n\\t\\t\\t// if the chars are same \\n\\t\\t\\tif(s[i-1] == p[j-1])\\n\\t\\t\\t\\tdp[i][j] = dp[i-1][j-1];\\n\\t\\t\\telse {\\n\\t\\t\\t\\t// different chars are allowed only incase of wilcard chars\\n\\t\\t\\t\\tif(p[j-1] == \\'.\\')\\n\\t\\t\\t\\t\\tdp[i][j] = dp[i-1][j-1];\\n\\t\\t\\t\\t// when *\\n\\t\\t\\t\\telse if(p[j-1] == \\'*\\') {\\n\\t\\t\\t\\t\\t// we have two choices, either use * or don\\'t use\\n\\t\\t\\t\\t\\tint with_star = (j - 2 >= 0) ? (p[j-2] == \\'.\\' || s[i-1] == p[j-2]) && dp[i-1][j] : 0;\\n\\t\\t\\t\\t\\tint without_star = (j - 2 >= 0) ? dp[i][j-2] : 0;\\n\\t\\t\\t\\t\\tdp[i][j] = with_star || without_star;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// when chars are diff\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tdp[i][j] = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[s.size()][p.size()];\\n}  \\n\\nbool isMatch(string s, string p) {\\n\\t//return regexMatchDriver(s, p);\\n\\treturn regexMatchTabular(s, p);\\n}\\n```\n```\\n// TC: O(MN), SC: O(MN)\\nint regexMatch(vector<vector<int>>& dp, string& s, string& p, \\n\\t\\t\\t   int i, int j) {\\n\\tif(j < 0)\\n\\t\\treturn 0;\\n\\tif(i == 0 && j == 0)\\n\\t\\treturn dp[i][j] = 1;\\n\\t// if the length of any string has become 0\\n\\t// then it is not a match except if the char in pattern is *\\n\\tif(i == 0 && j > 0)\\n\\t\\treturn dp[i][j] = p[j-1] == \\'*\\' && regexMatch(dp, s, p, i, j-1);\\n\\t// pattern has finished but not the source\\n\\tif(i != 0 && j == 0)\\n\\t\\treturn dp[i][j] = 0;\\n\\n\\tif(dp[i][j] == -1) {\\n\\t\\t// initially mark it true\\n\\t\\tdp[i][j] = 1;\\n\\t\\t// if the chars are same\\n\\t\\tif(s[i-1] == p[j-1])\\n\\t\\t\\tdp[i][j] = regexMatch(dp, s, p, i-1, j-1);\\n\\t\\telse {\\n\\t\\t\\t// when chars are different, then only if the pattern contains \\'.\\'\\n\\t\\t\\t// or \\'*\\' matching the string s then it is valid\\n\\t\\t\\tif(p[j-1] == \\'?\\')\\n\\t\\t\\t\\tdp[i][j] = regexMatch(dp, s, p, i-1, j-1);\\n\\t\\t\\telse if(p[j-1] == \\'*\\') {\\n\\t\\t\\t\\t// With * we can either try using it or not use it \\n\\t\\t\\t\\tint with_star = 0, without_star = 0;\\n\\t\\t\\t\\t// USE *\\n\\t\\t\\t\\t// if the pattern char match the * char of string source\\n\\t\\t\\t\\t// check for the previous char of source\\n\\t\\t\\t\\twith_star = regexMatch(dp, s, p, i-1, j);\\n\\n\\t\\t\\t\\t// DON\\'T USE * \\n\\t\\t\\t\\t// also covers the case when current pattern char is wildcard * and doesn\\'t match\\n\\t\\t\\t\\t// the char of source, try the char before \\'*\\' of pattern\\n\\t\\t\\t\\twithout_star = regexMatch(dp, s, p, i, j-1);\\n\\t\\t\\t\\tdp[i][j] = with_star || without_star;\\n\\t\\t\\t}\\n\\t\\t\\t// chars don\\'t match\\n\\t\\t\\telse \\n\\t\\t\\t\\tdp[i][j] = 0;\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[i][j];\\n}\\n\\n// driver memoization function\\nbool regexMatchDriver(string& s, string& p) {\\n\\tvector<vector<int>> dp(s.size() + 1, vector<int>(p.size() + 1, -1));\\n\\tregexMatch(dp, s, p, s.size(), p.size());\\n\\treturn dp[s.size()][p.size()];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 371094,
                "title": "c-dp-solution-with-formula-attached",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        \\n        /**\\n         * dp[i][j]: Whether the substring of s ending at the index i can\\n         *           be matched by the subpattern of p ending at the index j.\\n         *\\n         *            | if s[i] == p[j] || p[j] == \\'?\\', dp[i - 1][j - 1]\\n         * dp[i][j] = | if p[j] == \\'*\\'                , dp[i - 1][j] || dp[i][j- 1]\\n         *            | otherwise                     , false\\n         */\\n        \\n        int len_s = s.length();\\n        int len_p = p.length();\\n        \\n        std::vector<std::vector<int>> \\n            dp(len_s + 1, std::vector<int>(len_p + 1, false));\\n        dp[0][0] = true;\\n        \\n        for (int i = 1 ; i <= len_p ; ++i) {\\n            if (p[i - 1] != \\'*\\') {\\n                break;\\n            }\\n            dp[0][i] = true;\\n        }\\n        \\n        for (int i = 1 ; i <= len_s ; ++i) {\\n            for (int j = 1 ; j <= len_p ; ++j) {\\n                if (s[i - 1] == p[j - 1] || p[j - 1] == \\'?\\') {\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                } else if (p[j - 1] == \\'*\\') {\\n                    dp[i][j] = dp[i][j - 1] || dp[i - 1][j];\\n                }\\n            }\\n        }\\n        \\n        return dp[len_s][len_p];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        \\n        /**\\n         * dp[i][j]: Whether the substring of s ending at the index i can\\n         *           be matched by the subpattern of p ending at the index j.\\n         *\\n         *            | if s[i] == p[j] || p[j] == \\'?\\', dp[i - 1][j - 1]\\n         * dp[i][j] = | if p[j] == \\'*\\'                , dp[i - 1][j] || dp[i][j- 1]\\n         *            | otherwise                     , false\\n         */\\n        \\n        int len_s = s.length();\\n        int len_p = p.length();\\n        \\n        std::vector<std::vector<int>> \\n            dp(len_s + 1, std::vector<int>(len_p + 1, false));\\n        dp[0][0] = true;\\n        \\n        for (int i = 1 ; i <= len_p ; ++i) {\\n            if (p[i - 1] != \\'*\\') {\\n                break;\\n            }\\n            dp[0][i] = true;\\n        }\\n        \\n        for (int i = 1 ; i <= len_s ; ++i) {\\n            for (int j = 1 ; j <= len_p ; ++j) {\\n                if (s[i - 1] == p[j - 1] || p[j - 1] == \\'?\\') {\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                } else if (p[j - 1] == \\'*\\') {\\n                    dp[i][j] = dp[i][j - 1] || dp[i - 1][j];\\n                }\\n            }\\n        }\\n        \\n        return dp[len_s][len_p];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 347267,
                "title": "go-8ms-dp-solution",
                "content": "```\\nfunc isMatch(s string, p string) bool {\\n    // mem[i][j] means isMatch(s[:i], p[:j])\\n    mem := make([][]bool, len(s)+1)\\n    for i := range mem {\\n        mem[i] = make([]bool, len(p)+1)\\n    }\\n\\t\\n\\t// init bound, mem[n][0] is false while n > 0\\n    mem[0][0] = true\\n    for j := 1; j <= len(p); j++ {\\n        if p[j-1] == \\'*\\' {\\n            mem[0][j] = mem[0][j-1]\\n        }\\n    }\\n    \\n    for i := 1; i <= len(s); i++ {\\n        for j := 1; j <= len(p); j++ {\\n            if p[j-1] == \\'*\\' {\\n                mem[i][j] = mem[i][j-1] || mem[i-1][j]\\n            } else if p[j-1] == \\'?\\' || p[j-1] == s[i-1] {\\n                mem[i][j] = mem[i-1][j-1]\\n            }\\n        }\\n    }\\n    \\n    return mem[len(s)][len(p)]\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc isMatch(s string, p string) bool {\\n    // mem[i][j] means isMatch(s[:i], p[:j])\\n    mem := make([][]bool, len(s)+1)\\n    for i := range mem {\\n        mem[i] = make([]bool, len(p)+1)\\n    }\\n\\t\\n\\t// init bound, mem[n][0] is false while n > 0\\n    mem[0][0] = true\\n    for j := 1; j <= len(p); j++ {\\n        if p[j-1] == \\'*\\' {\\n            mem[0][j] = mem[0][j-1]\\n        }\\n    }\\n    \\n    for i := 1; i <= len(s); i++ {\\n        for j := 1; j <= len(p); j++ {\\n            if p[j-1] == \\'*\\' {\\n                mem[i][j] = mem[i][j-1] || mem[i-1][j]\\n            } else if p[j-1] == \\'?\\' || p[j-1] == s[i-1] {\\n                mem[i][j] = mem[i-1][j-1]\\n            }\\n        }\\n    }\\n    \\n    return mem[len(s)][len(p)]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 304264,
                "title": "c-dynamic-o-n-p-quadratic-complexity-80-beatings",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isMatch(string pStr, string pPat) {\\n        \\n        int aStrLen = pStr.length();\\n        int aPatLen = pPat.length();\\n        \\n        int s = 0;\\n        int p = 0;\\n        \\n        int aGrid[aStrLen + 1][aPatLen + 1];\\n        \\n        memset(aGrid, 0, sizeof(aGrid));\\n        \\n        aGrid[0][0] = 1;\\n        \\n        if (pPat.size() > 0 && pPat[0] == \\'*\\') {\\n            for (s=0;s<pStr.size();s++) {\\n                aGrid[s + 1][0] = 1;\\n            }\\n            \\n            p = 0;\\n            while (p < pPat.size() && pPat[p] == \\'*\\') {\\n                aGrid[0][p + 1] = 1;\\n                ++p;\\n            }\\n        }\\n        \\n        for (p=1;p<=pPat.size();p++) {\\n            \\n            bool aNextStar = (p < (pPat.size()) && pPat[p] == \\'*\\');\\n            for (s=1;s<=pStr.size();s++) {\\n                if (((pPat[p-1] == pStr[s-1]) || (pPat[p-1] == \\'?\\')) && aGrid[s - 1][p - 1] == 1) {\\n                    aGrid[s][p] = 1;\\n                }\\n                \\n                if (pPat[p-1] == \\'*\\') {\\n                    if ((aGrid[s][p - 1] == 1)) {\\n                        aGrid[s][p] = 1;\\n                    }\\n                    if ((aGrid[s - 1][p] == 1)) {\\n                        aGrid[s][p] = 1;\\n                    }\\n                }\\n            }\\n        }   \\n        return aGrid[aStrLen][aPatLen] == 1;\\n    }\\n};\\n```\\n\\nThis solution was mainly arrived at by analyzing the grid of subproblems. To me, it is not intuitive why a \\'*\\' would have us search both up and left. It makes more sense after testing out some example problems. It\\'s entirely possible that a more efficient solution exists.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMatch(string pStr, string pPat) {\\n        \\n        int aStrLen = pStr.length();\\n        int aPatLen = pPat.length();\\n        \\n        int s = 0;\\n        int p = 0;\\n        \\n        int aGrid[aStrLen + 1][aPatLen + 1];\\n        \\n        memset(aGrid, 0, sizeof(aGrid));\\n        \\n        aGrid[0][0] = 1;\\n        \\n        if (pPat.size() > 0 && pPat[0] == \\'*\\') {\\n            for (s=0;s<pStr.size();s++) {\\n                aGrid[s + 1][0] = 1;\\n            }\\n            \\n            p = 0;\\n            while (p < pPat.size() && pPat[p] == \\'*\\') {\\n                aGrid[0][p + 1] = 1;\\n                ++p;\\n            }\\n        }\\n        \\n        for (p=1;p<=pPat.size();p++) {\\n            \\n            bool aNextStar = (p < (pPat.size()) && pPat[p] == \\'*\\');\\n            for (s=1;s<=pStr.size();s++) {\\n                if (((pPat[p-1] == pStr[s-1]) || (pPat[p-1] == \\'?\\')) && aGrid[s - 1][p - 1] == 1) {\\n                    aGrid[s][p] = 1;\\n                }\\n                \\n                if (pPat[p-1] == \\'*\\') {\\n                    if ((aGrid[s][p - 1] == 1)) {\\n                        aGrid[s][p] = 1;\\n                    }\\n                    if ((aGrid[s - 1][p] == 1)) {\\n                        aGrid[s][p] = 1;\\n                    }\\n                }\\n            }\\n        }   \\n        return aGrid[aStrLen][aPatLen] == 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 273339,
                "title": "easy-to-read-java-dp-solution-by-adding-an-extra-character-to-string-head",
                "content": "This is a regular O(N^2) DP solution, but we do a trick by adding a character \"#\" to the head of both expressions s and p (or add any other character as long as it\\'s not in the given char set). Then, we don\\'t need to worry about edge cases where p[0] = \\'*\\' or \\'?\\', etc.\\n\\nRuntime: 9 ms, faster than 95.15% of Java online submissions for Wildcard Matching.\\n\\n```\\npublic boolean isMatch(String s, String p) {\\n\\ts = \"#\" + s;\\n\\tp = \"#\" + p;\\n\\tint sn = s.length(), pn = p.length();\\n\\tboolean[][] dp = new boolean[pn][sn];\\n\\n\\tdp[0][0] = true;\\n\\tfor (int i = 1; i < pn; i++) {\\n\\t\\tif (p.charAt(i) == \\'*\\') {\\n\\t\\t\\tfor (int j = 0; j < sn; j++) {\\n\\t\\t\\t\\tif (dp[i-1][j]) {\\n\\t\\t\\t\\t\\tfor (int k = j; k < sn; k++) {\\n\\t\\t\\t\\t\\t\\tdp[i][k] = true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tfor (int j = 1; j < sn; j++) {\\n\\t\\t\\t\\tif (dp[i-1][j-1]) {\\n\\t\\t\\t\\t\\tdp[i][j] = (p.charAt(i) == \\'?\\' || p.charAt(i) == s.charAt(j));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[pn - 1][sn - 1];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean isMatch(String s, String p) {\\n\\ts = \"#\" + s;\\n\\tp = \"#\" + p;\\n\\tint sn = s.length(), pn = p.length();\\n\\tboolean[][] dp = new boolean[pn][sn];\\n\\n\\tdp[0][0] = true;\\n\\tfor (int i = 1; i < pn; i++) {\\n\\t\\tif (p.charAt(i) == \\'*\\') {\\n\\t\\t\\tfor (int j = 0; j < sn; j++) {\\n\\t\\t\\t\\tif (dp[i-1][j]) {\\n\\t\\t\\t\\t\\tfor (int k = j; k < sn; k++) {\\n\\t\\t\\t\\t\\t\\tdp[i][k] = true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tfor (int j = 1; j < sn; j++) {\\n\\t\\t\\t\\tif (dp[i-1][j-1]) {\\n\\t\\t\\t\\t\\tdp[i][j] = (p.charAt(i) == \\'?\\' || p.charAt(i) == s.charAt(j));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[pn - 1][sn - 1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 199127,
                "title": "python-recursive-top-down",
                "content": "\\t\\tmemo = {}\\n        def helper(i, j):\\n            if j == len(p): return i == len(s)\\n            if i == len(s): return len(p[j:]) == p[j:].count(\"*\")\\n            \\n            if (i, j) in memo:\\n                return memo[i, j]\\n            \\n            if p[j] != \"*\":\\n                first_match = i < len(s) and p[j] in {s[i], \\'?\\'}\\n                ans = first_match and helper(i+1, j+1)\\n            \\n            else:\\n                ans = helper(i, j+1) or helper(i+1, j)\\n            \\n            memo[i, j] = ans\\n            return ans\\n        \\n        return helper(0, 0)\\n\\nUsing the idea from the 10: Regular Expression Matching. If p[j] is not *, compare the first character. If p[j] is *, either skip this pattern or skip the string character",
                "solutionTags": [],
                "code": "\\t\\tmemo = {}\\n        def helper(i, j):\\n            if j == len(p): return i == len(s)\\n            if i == len(s): return len(p[j:]) == p[j:].count(\"*\")\\n            \\n            if (i, j) in memo:\\n                return memo[i, j]\\n            \\n            if p[j] != \"*\":\\n                first_match = i < len(s) and p[j] in {s[i], \\'?\\'}\\n                ans = first_match and helper(i+1, j+1)\\n            \\n            else:\\n                ans = helper(i, j+1) or helper(i+1, j)\\n            \\n            memo[i, j] = ans\\n            return ans\\n        \\n        return helper(0, 0)\\n\\nUsing the idea from the 10: Regular Expression Matching. If p[j] is not *, compare the first character. If p[j] is *, either skip this pattern or skip the string character",
                "codeTag": "Python3"
            },
            {
                "id": 195140,
                "title": "java-dp-solutions-with-o-n-2-first-and-then-optimized-to-o-n-space-with-explanation",
                "content": "We can either match the strings by starting to compare first character of S to first character of P \\nOR\\nWe can start by comparing last character of S with last character of P and work our way backwards.\\nWe use the second approach as its easy to understand \\nLet \\ndp[i][j]  = true if substring of P ending at i-1 and S ending at j-1 matches.\\ndp[0][0] = true     Both P and S are empty.\\ndp[i][0] = dp[i-1][0] AND P[i-1]  = * , This means sequence of \\\\*\\'s will match the empty string.\\ndp[i][j] = dp[i-1][j-1]  if P[i-1] == S[j-1]  OR P[i-1] = \\'?\\'   \\ndp[i][j] = dp[i-1][j] | dp[i][j-1]   if P[i-1] = \\'\\\\*\\'\\n\\nUsing this recursive formula our program looks like.\\n```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        boolean[][] dp = new boolean[p.length()+1][s.length()+1];\\n        dp[0][0]=true;\\n        for(int i=1;i<=p.length();i++){\\n            if(p.charAt(i-1) == \\'*\\' && dp[i-1][0]){\\n                dp[i][0]=true;\\n            }\\n        }\\n        for(int i=1;i<=p.length();i++){\\n             for(int j=1;j<=s.length();j++){\\n                if(s.charAt(j-1) == p.charAt(i-1) || p.charAt(i-1) == \\'?\\'){\\n                    dp[i][j]=dp[i-1][j-1];\\n                }else if(p.charAt(i-1) == \\'*\\'){\\n                    dp[i][j]=dp[i-1][j]||dp[i][j-1];\\n                }\\n             } \\n        }\\n        return dp[p.length()][s.length()];\\n    }\\n}\\n```\\n\\nWe note that value of  dp[i][j] depends on \\ndp[i-1][j]  Previous row same column \\ndp[i][j-1]  Same row previous column\\nd[i-1][j-1] Previous row , previous column.\\nBecause the current value only depends on previous values we can just use 1D array to store the values and an additional variable to store the dp[i-1][j-1] value.\\n\\n\\n```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        boolean[] dp = new boolean[s.length()+1];\\n        dp[0]=true;\\n        for(int i=1;i<=p.length();i++){\\n            boolean prev;\\n            boolean prevPrev = true;\\n             for(int j=0;j<=s.length();j++){\\n                prev = dp[j];\\n                if(j == 0){\\n                    dp[j]&= p.charAt(i-1) == \\'*\\';\\n                }else{\\n                    if(s.charAt(j-1) == p.charAt(i-1) || p.charAt(i-1) == \\'?\\'){\\n                        dp[j]=prevPrev;\\n                    }else if(p.charAt(i-1) == \\'*\\'){\\n                        dp[j]|=dp[j-1];\\n                    }else{\\n                        dp[j]=false;\\n                    }\\n                }\\n                prevPrev = prev; \\n             } \\n        }\\n        return dp[s.length()];\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        boolean[][] dp = new boolean[p.length()+1][s.length()+1];\\n        dp[0][0]=true;\\n        for(int i=1;i<=p.length();i++){\\n            if(p.charAt(i-1) == \\'*\\' && dp[i-1][0]){\\n                dp[i][0]=true;\\n            }\\n        }\\n        for(int i=1;i<=p.length();i++){\\n             for(int j=1;j<=s.length();j++){\\n                if(s.charAt(j-1) == p.charAt(i-1) || p.charAt(i-1) == \\'?\\'){\\n                    dp[i][j]=dp[i-1][j-1];\\n                }else if(p.charAt(i-1) == \\'*\\'){\\n                    dp[i][j]=dp[i-1][j]||dp[i][j-1];\\n                }\\n             } \\n        }\\n        return dp[p.length()][s.length()];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        boolean[] dp = new boolean[s.length()+1];\\n        dp[0]=true;\\n        for(int i=1;i<=p.length();i++){\\n            boolean prev;\\n            boolean prevPrev = true;\\n             for(int j=0;j<=s.length();j++){\\n                prev = dp[j];\\n                if(j == 0){\\n                    dp[j]&= p.charAt(i-1) == \\'*\\';\\n                }else{\\n                    if(s.charAt(j-1) == p.charAt(i-1) || p.charAt(i-1) == \\'?\\'){\\n                        dp[j]=prevPrev;\\n                    }else if(p.charAt(i-1) == \\'*\\'){\\n                        dp[j]|=dp[j-1];\\n                    }else{\\n                        dp[j]=false;\\n                    }\\n                }\\n                prevPrev = prev; \\n             } \\n        }\\n        return dp[s.length()];\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564889,
                "content": [
                    {
                        "username": "Imory2020",
                        "content": "I've figured out what the difference is, but would like to raise a question here in case others might also wonder it in the future. For reference, [Regular Expression Matching][1].\\n\\n\\n  [1]: https://oj.leetcode.com/problems/regular-expression-matching/"
                    },
                    {
                        "username": "stridemann",
                        "content": "Yes, the solution from REM problem could be a bit fixed/simplified and will do this job.\nI did REM using backtracking using recursion (and it was working there), but in this problem I got a timeouts with this approach. \nWe will also get timeouts if we use Regex way (on C#) (some cases takes 3min to process).\nI'm sure the \"DP table\" should be used in both this problems. It will simplify code many times.\n\nUPD. Dp table did it job, but slow as hell :) (no timeouts)"
                    },
                    {
                        "username": "et169tkm",
                        "content": "[@pradeepsinghjaroliya](/pradeepsinghjaroliya) Sounds like we can translate the input in this question to a regular expression, then use the previous solution to match it...."
                    },
                    {
                        "username": "practice_90",
                        "content": "[@fengli738](/fengli738) * in regular expression matches zero or more previous character. Here * can match any character any number of times"
                    },
                    {
                        "username": "pradeepsinghjaroliya",
                        "content": "[@fengli738](/fengli738) \nIn that question \na* means it can be \"\" or \"a\" or \"aa\" or \"aa.....\". (i.e. Matches zero or more of the preceding element.)\na* cant be \"ab\" it can only have zero or more preceding element in this case will be 'a';\n' * ' is not independent character consider (a*) as together.\n In this case ,it is independent.\nExample: \"aa*\"\nin this question it can be- \"aa\",\"aaa\",\"aaa....a\",\"aab\",\"aabb\",\"aaba\"\nAnd in that question it can be-\n \"a\",\"aa\",\"aaa\",\"aaaa...aa\"\n(Notice in that question it can be \"a\" but here it can't be \"aa\" is the compulsary part.)\n(Hope it help, was confused in both , sorry for my bad wording)"
                    },
                    {
                        "username": "fengli738",
                        "content": "what is the difference between this problem and https://leetcode.com/problems/regular-expression-matching/description/"
                    },
                    {
                        "username": "ArpitDhamija",
                        "content": "So, I just gave my Tech Round in a startup, applied offcampus.\\n\\nI have not done this question earlier. So just imagine my situation\\n\\nInterviewer asked me this as the 2nd ques. 1st ques was also hard but I know the solution of that.\\n\\nIn this, I somehow able to get to the recurssive solution with some of the hints given by interviewer. Its hell difficult according to me to get to the optimal solution for this question in an interview if you haven\\'t done that earlier. \\nLike I get to the recurssive solution. And time got over. As in 1 hr, 2 hard questions were asked and I have to code that also. \\n\\nThats all about this. \\n\\n"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "[@nushk_23](/nushk_23) this was asked in adobe to someone I know"
                    },
                    {
                        "username": "nushk_23",
                        "content": "which company though?"
                    },
                    {
                        "username": "iZERWAS",
                        "content": "ah tough luck man"
                    },
                    {
                        "username": "zdi561",
                        "content": "\"aa\" \"a\" is false but \"abcabczzzde\", \"*abc???de*\" is true , they are contradictory"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "[@DarkMatter71](/DarkMatter71)  Indeed its false.. I think you are mistaken the pattern which is *abc???de*"
                    },
                    {
                        "username": "tanmaytaran",
                        "content": "\\'*\\' matches 0 or more characters but \\'?\\' matches exactly 1 character.\\nSo, for string \"aa\" and pattern \"a\", its false, which is correct. Now for string \"aa\" and any pattern like \"*\" || \"a*\" || \"*a\" || \"?*\" || \"*?\", etc. all are correct.\\n\\nNow if we look at string \"abcabczzzde\" with pattern \"abc???de\", \\n\\'abc\\' in pattern matches and leaves us with \"abczzzde\". Now 3 \\'?\\' need to match exactly 3 characters. So the next abc gets matched, hence we are now left with \"zzzde\" and in pattern \"de\". Thats why this is false."
                    },
                    {
                        "username": "DarkMatter71",
                        "content": "\"abcabczzzde\", \"abc???de\" is not true"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "this question having contradictory testcase.\n\"adceb\"   \"* a* b\" this is true why?\n\"a*c?b\"   \"acdcb\" then why tis is false?\n"
                    },
                    {
                        "username": "danielrrv",
                        "content": "[@Moonbeam8773](/Moonbeam8773) Doesn't make sense at all. \"The The first * must match an empty string\" There's no empty string at the beginning unless that the tester supposes it. Machines don't understand assumptions. The empty string is not there, then  it is not there. \nThe only way to pass this case in my opinion is assuming*(in software assumptions are risky) that the letters have priority over * because the * in first place makes the entire string fulfills the pattern."
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "\\* matches any character, including 0-length string. For \"\\*a\\*b\", the first \\* must match an empty string in order to have the \"a\" match up.  This leaves \"a\\*b\" to match \"adceb\". The first and last characters of the pattern and string match, so we remove them. This leaves the single \\* in the middle to match \"dce\", which it does. Therefore true.\n\n\"a\\*c?b\" start and end has to be \"a\" and \"b\" respectively. Which means we need to have \"\\*c?\" match \"cdc\". If the last \"?\" must match one character, that leaves \"\\*c\" to match \"cd\". Both last characters don't match, therefore it's false."
                    },
                    {
                        "username": "gargsaksham57",
                        "content": "could anybody explain why recursion+memoisation is giving tle"
                    },
                    {
                        "username": "raistar702614",
                        "content": "if you get a tle then most of the time this trick worls...declare the variable as unsigned int AND while passing the strings in the function pass them by reference.\\n\\nfor this qustion i tried memoization it passed 1774/1811\\n\\ni made the type as unsigned then it passed 1809/1811\\n\\ni passed the string by reference ...passed all cases with ahead of 85% in time and 15% in space "
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "I've written the Memoised version and it works.\nPlz check this - https://leetcode.com/problems/wildcard-matching/solutions/3230627/dp-memoization/?orderBy=most_votes"
                    },
                    {
                        "username": "user4523qT",
                        "content": "recursion is slow because of the nature of recursion. iterative solution is the fastest way"
                    },
                    {
                        "username": "c3lEsTIaL",
                        "content": "I can\\'t think about a greedy strategy that works here. Most solutions posted seemed like Brute Force or DP."
                    },
                    {
                        "username": "abhishek_kumar_12140040",
                        "content": "I am Trying t solve it by recursion + memorisation but on the last test case I am exceeding the memory limit. Is there any other method for this?"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "[@mahdichaben47](/mahdichaben47) pass the strings by reference"
                    },
                    {
                        "username": "mahdichaben47",
                        "content": "same problem they dont give me any test case but Memory Limit Exceeded"
                    },
                    {
                        "username": "sakshitiwari_01",
                        "content": "asked in Myanatomy in campus recruitment "
                    },
                    {
                        "username": "sevxin",
                        "content": "I submitted my code, and the result shows wrong when it applied on testcase:\"acdcb\", \"ac?b\". However, when I ran it in playground, I get the correct answer. What should I do? Could someone help me out?"
                    },
                    {
                        "username": "Okpatu",
                        "content": "C is not matched "
                    },
                    {
                        "username": "Ayush379",
                        "content": "I think that should give false, since ? means 1 character, but there are 2 needed. "
                    },
                    {
                        "username": "hzzyyy",
                        "content": "The highest voted solution is based on:\\nhttp://yucoding.blogspot.com/2013/02/leetcode-question-123-wildcard-matching.html\\n\\nIf it is not very obvious for you, I will try to explain the following two reasons why it works:\\n\\n**1. Greedy matching works, there is no need to backtrack more than once.** \\n\\nObviously, we need to use backtrack, but why Yu's solution didn't use a stack? The reason is, we only need to backtrack once to go back to the most recent '\\\\*'. Let me explain why. Given a string s and a pattern p, Consider the pattern string is divided into two substrings, p1 and p2, each of which starts with a '\\\\*'. With greedy matching, which is the case in Yu's solution, suppose p1 matches the *shortest head substring* of s, namely s1. Let's name its complement as s2, then we have s = s1 + s2 and p = p1+p2.\\n\\nThe statement is: \\n    *If p2 doesn't match s2 then p doesn't match s.* \\n\\nThe proof is the following:\\nIf s1 is the only head substring of s matching p1, then we don't have alternative matches for p1, then the only case is checked. \\nIf there is another head substring of s matching p1, namely s1' which must be longer than s1, then its complement, name s2' must be a tail substring of s2.  We know that p2 doesn't match s2, and p2 starts with '\\\\*', then we know p2 doesn't match any tail substring of s2, so p2 doesn't match s2' either.  To illustrate, consider:\\n\\n* p2 = \"*z\"\\n* s2 = \"abcd\"\\n\\np2 doesn't match s2, and p2 doesn't match any of \"bcd\", \"cd\", or \"d\". This is because in eyes of '\\\\*' \"abc\" \"bc\" \"c\" and \"\" are all the same. \\n\\n**2. C string all ends with a null char '\\\\0'.** \\nThis actually makes his problem easier to solve with C string, and if the inputs are std::string, the best way to do it is to use their c_str() to solve it. \\n\\nThe convenience is that when the pointer of pattern string p is at the end, pointing to '\\\\0', matching attempt with any char of string s (not including its end '\\\\0') will result in failure. This is equivalent to the following behavior:\\n   \\n*When characters in pattern string p are all matched but there are still characters remaining in string s, this matching attempt is a failure.*\\n\\nIf such logic is implemented in std::string, we need to use either the size of string or its end iterator."
                    }
                ]
            },
            {
                "id": 1566677,
                "content": [
                    {
                        "username": "Imory2020",
                        "content": "I've figured out what the difference is, but would like to raise a question here in case others might also wonder it in the future. For reference, [Regular Expression Matching][1].\\n\\n\\n  [1]: https://oj.leetcode.com/problems/regular-expression-matching/"
                    },
                    {
                        "username": "stridemann",
                        "content": "Yes, the solution from REM problem could be a bit fixed/simplified and will do this job.\nI did REM using backtracking using recursion (and it was working there), but in this problem I got a timeouts with this approach. \nWe will also get timeouts if we use Regex way (on C#) (some cases takes 3min to process).\nI'm sure the \"DP table\" should be used in both this problems. It will simplify code many times.\n\nUPD. Dp table did it job, but slow as hell :) (no timeouts)"
                    },
                    {
                        "username": "et169tkm",
                        "content": "[@pradeepsinghjaroliya](/pradeepsinghjaroliya) Sounds like we can translate the input in this question to a regular expression, then use the previous solution to match it...."
                    },
                    {
                        "username": "practice_90",
                        "content": "[@fengli738](/fengli738) * in regular expression matches zero or more previous character. Here * can match any character any number of times"
                    },
                    {
                        "username": "pradeepsinghjaroliya",
                        "content": "[@fengli738](/fengli738) \nIn that question \na* means it can be \"\" or \"a\" or \"aa\" or \"aa.....\". (i.e. Matches zero or more of the preceding element.)\na* cant be \"ab\" it can only have zero or more preceding element in this case will be 'a';\n' * ' is not independent character consider (a*) as together.\n In this case ,it is independent.\nExample: \"aa*\"\nin this question it can be- \"aa\",\"aaa\",\"aaa....a\",\"aab\",\"aabb\",\"aaba\"\nAnd in that question it can be-\n \"a\",\"aa\",\"aaa\",\"aaaa...aa\"\n(Notice in that question it can be \"a\" but here it can't be \"aa\" is the compulsary part.)\n(Hope it help, was confused in both , sorry for my bad wording)"
                    },
                    {
                        "username": "fengli738",
                        "content": "what is the difference between this problem and https://leetcode.com/problems/regular-expression-matching/description/"
                    },
                    {
                        "username": "ArpitDhamija",
                        "content": "So, I just gave my Tech Round in a startup, applied offcampus.\\n\\nI have not done this question earlier. So just imagine my situation\\n\\nInterviewer asked me this as the 2nd ques. 1st ques was also hard but I know the solution of that.\\n\\nIn this, I somehow able to get to the recurssive solution with some of the hints given by interviewer. Its hell difficult according to me to get to the optimal solution for this question in an interview if you haven\\'t done that earlier. \\nLike I get to the recurssive solution. And time got over. As in 1 hr, 2 hard questions were asked and I have to code that also. \\n\\nThats all about this. \\n\\n"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "[@nushk_23](/nushk_23) this was asked in adobe to someone I know"
                    },
                    {
                        "username": "nushk_23",
                        "content": "which company though?"
                    },
                    {
                        "username": "iZERWAS",
                        "content": "ah tough luck man"
                    },
                    {
                        "username": "zdi561",
                        "content": "\"aa\" \"a\" is false but \"abcabczzzde\", \"*abc???de*\" is true , they are contradictory"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "[@DarkMatter71](/DarkMatter71)  Indeed its false.. I think you are mistaken the pattern which is *abc???de*"
                    },
                    {
                        "username": "tanmaytaran",
                        "content": "\\'*\\' matches 0 or more characters but \\'?\\' matches exactly 1 character.\\nSo, for string \"aa\" and pattern \"a\", its false, which is correct. Now for string \"aa\" and any pattern like \"*\" || \"a*\" || \"*a\" || \"?*\" || \"*?\", etc. all are correct.\\n\\nNow if we look at string \"abcabczzzde\" with pattern \"abc???de\", \\n\\'abc\\' in pattern matches and leaves us with \"abczzzde\". Now 3 \\'?\\' need to match exactly 3 characters. So the next abc gets matched, hence we are now left with \"zzzde\" and in pattern \"de\". Thats why this is false."
                    },
                    {
                        "username": "DarkMatter71",
                        "content": "\"abcabczzzde\", \"abc???de\" is not true"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "this question having contradictory testcase.\n\"adceb\"   \"* a* b\" this is true why?\n\"a*c?b\"   \"acdcb\" then why tis is false?\n"
                    },
                    {
                        "username": "danielrrv",
                        "content": "[@Moonbeam8773](/Moonbeam8773) Doesn't make sense at all. \"The The first * must match an empty string\" There's no empty string at the beginning unless that the tester supposes it. Machines don't understand assumptions. The empty string is not there, then  it is not there. \nThe only way to pass this case in my opinion is assuming*(in software assumptions are risky) that the letters have priority over * because the * in first place makes the entire string fulfills the pattern."
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "\\* matches any character, including 0-length string. For \"\\*a\\*b\", the first \\* must match an empty string in order to have the \"a\" match up.  This leaves \"a\\*b\" to match \"adceb\". The first and last characters of the pattern and string match, so we remove them. This leaves the single \\* in the middle to match \"dce\", which it does. Therefore true.\n\n\"a\\*c?b\" start and end has to be \"a\" and \"b\" respectively. Which means we need to have \"\\*c?\" match \"cdc\". If the last \"?\" must match one character, that leaves \"\\*c\" to match \"cd\". Both last characters don't match, therefore it's false."
                    },
                    {
                        "username": "gargsaksham57",
                        "content": "could anybody explain why recursion+memoisation is giving tle"
                    },
                    {
                        "username": "raistar702614",
                        "content": "if you get a tle then most of the time this trick worls...declare the variable as unsigned int AND while passing the strings in the function pass them by reference.\\n\\nfor this qustion i tried memoization it passed 1774/1811\\n\\ni made the type as unsigned then it passed 1809/1811\\n\\ni passed the string by reference ...passed all cases with ahead of 85% in time and 15% in space "
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "I've written the Memoised version and it works.\nPlz check this - https://leetcode.com/problems/wildcard-matching/solutions/3230627/dp-memoization/?orderBy=most_votes"
                    },
                    {
                        "username": "user4523qT",
                        "content": "recursion is slow because of the nature of recursion. iterative solution is the fastest way"
                    },
                    {
                        "username": "c3lEsTIaL",
                        "content": "I can\\'t think about a greedy strategy that works here. Most solutions posted seemed like Brute Force or DP."
                    },
                    {
                        "username": "abhishek_kumar_12140040",
                        "content": "I am Trying t solve it by recursion + memorisation but on the last test case I am exceeding the memory limit. Is there any other method for this?"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "[@mahdichaben47](/mahdichaben47) pass the strings by reference"
                    },
                    {
                        "username": "mahdichaben47",
                        "content": "same problem they dont give me any test case but Memory Limit Exceeded"
                    },
                    {
                        "username": "sakshitiwari_01",
                        "content": "asked in Myanatomy in campus recruitment "
                    },
                    {
                        "username": "sevxin",
                        "content": "I submitted my code, and the result shows wrong when it applied on testcase:\"acdcb\", \"ac?b\". However, when I ran it in playground, I get the correct answer. What should I do? Could someone help me out?"
                    },
                    {
                        "username": "Okpatu",
                        "content": "C is not matched "
                    },
                    {
                        "username": "Ayush379",
                        "content": "I think that should give false, since ? means 1 character, but there are 2 needed. "
                    },
                    {
                        "username": "hzzyyy",
                        "content": "The highest voted solution is based on:\\nhttp://yucoding.blogspot.com/2013/02/leetcode-question-123-wildcard-matching.html\\n\\nIf it is not very obvious for you, I will try to explain the following two reasons why it works:\\n\\n**1. Greedy matching works, there is no need to backtrack more than once.** \\n\\nObviously, we need to use backtrack, but why Yu's solution didn't use a stack? The reason is, we only need to backtrack once to go back to the most recent '\\\\*'. Let me explain why. Given a string s and a pattern p, Consider the pattern string is divided into two substrings, p1 and p2, each of which starts with a '\\\\*'. With greedy matching, which is the case in Yu's solution, suppose p1 matches the *shortest head substring* of s, namely s1. Let's name its complement as s2, then we have s = s1 + s2 and p = p1+p2.\\n\\nThe statement is: \\n    *If p2 doesn't match s2 then p doesn't match s.* \\n\\nThe proof is the following:\\nIf s1 is the only head substring of s matching p1, then we don't have alternative matches for p1, then the only case is checked. \\nIf there is another head substring of s matching p1, namely s1' which must be longer than s1, then its complement, name s2' must be a tail substring of s2.  We know that p2 doesn't match s2, and p2 starts with '\\\\*', then we know p2 doesn't match any tail substring of s2, so p2 doesn't match s2' either.  To illustrate, consider:\\n\\n* p2 = \"*z\"\\n* s2 = \"abcd\"\\n\\np2 doesn't match s2, and p2 doesn't match any of \"bcd\", \"cd\", or \"d\". This is because in eyes of '\\\\*' \"abc\" \"bc\" \"c\" and \"\" are all the same. \\n\\n**2. C string all ends with a null char '\\\\0'.** \\nThis actually makes his problem easier to solve with C string, and if the inputs are std::string, the best way to do it is to use their c_str() to solve it. \\n\\nThe convenience is that when the pointer of pattern string p is at the end, pointing to '\\\\0', matching attempt with any char of string s (not including its end '\\\\0') will result in failure. This is equivalent to the following behavior:\\n   \\n*When characters in pattern string p are all matched but there are still characters remaining in string s, this matching attempt is a failure.*\\n\\nIf such logic is implemented in std::string, we need to use either the size of string or its end iterator."
                    }
                ]
            },
            {
                "id": 1570522,
                "content": [
                    {
                        "username": "Imory2020",
                        "content": "I've figured out what the difference is, but would like to raise a question here in case others might also wonder it in the future. For reference, [Regular Expression Matching][1].\\n\\n\\n  [1]: https://oj.leetcode.com/problems/regular-expression-matching/"
                    },
                    {
                        "username": "stridemann",
                        "content": "Yes, the solution from REM problem could be a bit fixed/simplified and will do this job.\nI did REM using backtracking using recursion (and it was working there), but in this problem I got a timeouts with this approach. \nWe will also get timeouts if we use Regex way (on C#) (some cases takes 3min to process).\nI'm sure the \"DP table\" should be used in both this problems. It will simplify code many times.\n\nUPD. Dp table did it job, but slow as hell :) (no timeouts)"
                    },
                    {
                        "username": "et169tkm",
                        "content": "[@pradeepsinghjaroliya](/pradeepsinghjaroliya) Sounds like we can translate the input in this question to a regular expression, then use the previous solution to match it...."
                    },
                    {
                        "username": "practice_90",
                        "content": "[@fengli738](/fengli738) * in regular expression matches zero or more previous character. Here * can match any character any number of times"
                    },
                    {
                        "username": "pradeepsinghjaroliya",
                        "content": "[@fengli738](/fengli738) \nIn that question \na* means it can be \"\" or \"a\" or \"aa\" or \"aa.....\". (i.e. Matches zero or more of the preceding element.)\na* cant be \"ab\" it can only have zero or more preceding element in this case will be 'a';\n' * ' is not independent character consider (a*) as together.\n In this case ,it is independent.\nExample: \"aa*\"\nin this question it can be- \"aa\",\"aaa\",\"aaa....a\",\"aab\",\"aabb\",\"aaba\"\nAnd in that question it can be-\n \"a\",\"aa\",\"aaa\",\"aaaa...aa\"\n(Notice in that question it can be \"a\" but here it can't be \"aa\" is the compulsary part.)\n(Hope it help, was confused in both , sorry for my bad wording)"
                    },
                    {
                        "username": "fengli738",
                        "content": "what is the difference between this problem and https://leetcode.com/problems/regular-expression-matching/description/"
                    },
                    {
                        "username": "ArpitDhamija",
                        "content": "So, I just gave my Tech Round in a startup, applied offcampus.\\n\\nI have not done this question earlier. So just imagine my situation\\n\\nInterviewer asked me this as the 2nd ques. 1st ques was also hard but I know the solution of that.\\n\\nIn this, I somehow able to get to the recurssive solution with some of the hints given by interviewer. Its hell difficult according to me to get to the optimal solution for this question in an interview if you haven\\'t done that earlier. \\nLike I get to the recurssive solution. And time got over. As in 1 hr, 2 hard questions were asked and I have to code that also. \\n\\nThats all about this. \\n\\n"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "[@nushk_23](/nushk_23) this was asked in adobe to someone I know"
                    },
                    {
                        "username": "nushk_23",
                        "content": "which company though?"
                    },
                    {
                        "username": "iZERWAS",
                        "content": "ah tough luck man"
                    },
                    {
                        "username": "zdi561",
                        "content": "\"aa\" \"a\" is false but \"abcabczzzde\", \"*abc???de*\" is true , they are contradictory"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "[@DarkMatter71](/DarkMatter71)  Indeed its false.. I think you are mistaken the pattern which is *abc???de*"
                    },
                    {
                        "username": "tanmaytaran",
                        "content": "\\'*\\' matches 0 or more characters but \\'?\\' matches exactly 1 character.\\nSo, for string \"aa\" and pattern \"a\", its false, which is correct. Now for string \"aa\" and any pattern like \"*\" || \"a*\" || \"*a\" || \"?*\" || \"*?\", etc. all are correct.\\n\\nNow if we look at string \"abcabczzzde\" with pattern \"abc???de\", \\n\\'abc\\' in pattern matches and leaves us with \"abczzzde\". Now 3 \\'?\\' need to match exactly 3 characters. So the next abc gets matched, hence we are now left with \"zzzde\" and in pattern \"de\". Thats why this is false."
                    },
                    {
                        "username": "DarkMatter71",
                        "content": "\"abcabczzzde\", \"abc???de\" is not true"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "this question having contradictory testcase.\n\"adceb\"   \"* a* b\" this is true why?\n\"a*c?b\"   \"acdcb\" then why tis is false?\n"
                    },
                    {
                        "username": "danielrrv",
                        "content": "[@Moonbeam8773](/Moonbeam8773) Doesn't make sense at all. \"The The first * must match an empty string\" There's no empty string at the beginning unless that the tester supposes it. Machines don't understand assumptions. The empty string is not there, then  it is not there. \nThe only way to pass this case in my opinion is assuming*(in software assumptions are risky) that the letters have priority over * because the * in first place makes the entire string fulfills the pattern."
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "\\* matches any character, including 0-length string. For \"\\*a\\*b\", the first \\* must match an empty string in order to have the \"a\" match up.  This leaves \"a\\*b\" to match \"adceb\". The first and last characters of the pattern and string match, so we remove them. This leaves the single \\* in the middle to match \"dce\", which it does. Therefore true.\n\n\"a\\*c?b\" start and end has to be \"a\" and \"b\" respectively. Which means we need to have \"\\*c?\" match \"cdc\". If the last \"?\" must match one character, that leaves \"\\*c\" to match \"cd\". Both last characters don't match, therefore it's false."
                    },
                    {
                        "username": "gargsaksham57",
                        "content": "could anybody explain why recursion+memoisation is giving tle"
                    },
                    {
                        "username": "raistar702614",
                        "content": "if you get a tle then most of the time this trick worls...declare the variable as unsigned int AND while passing the strings in the function pass them by reference.\\n\\nfor this qustion i tried memoization it passed 1774/1811\\n\\ni made the type as unsigned then it passed 1809/1811\\n\\ni passed the string by reference ...passed all cases with ahead of 85% in time and 15% in space "
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "I've written the Memoised version and it works.\nPlz check this - https://leetcode.com/problems/wildcard-matching/solutions/3230627/dp-memoization/?orderBy=most_votes"
                    },
                    {
                        "username": "user4523qT",
                        "content": "recursion is slow because of the nature of recursion. iterative solution is the fastest way"
                    },
                    {
                        "username": "c3lEsTIaL",
                        "content": "I can\\'t think about a greedy strategy that works here. Most solutions posted seemed like Brute Force or DP."
                    },
                    {
                        "username": "abhishek_kumar_12140040",
                        "content": "I am Trying t solve it by recursion + memorisation but on the last test case I am exceeding the memory limit. Is there any other method for this?"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "[@mahdichaben47](/mahdichaben47) pass the strings by reference"
                    },
                    {
                        "username": "mahdichaben47",
                        "content": "same problem they dont give me any test case but Memory Limit Exceeded"
                    },
                    {
                        "username": "sakshitiwari_01",
                        "content": "asked in Myanatomy in campus recruitment "
                    },
                    {
                        "username": "sevxin",
                        "content": "I submitted my code, and the result shows wrong when it applied on testcase:\"acdcb\", \"ac?b\". However, when I ran it in playground, I get the correct answer. What should I do? Could someone help me out?"
                    },
                    {
                        "username": "Okpatu",
                        "content": "C is not matched "
                    },
                    {
                        "username": "Ayush379",
                        "content": "I think that should give false, since ? means 1 character, but there are 2 needed. "
                    },
                    {
                        "username": "hzzyyy",
                        "content": "The highest voted solution is based on:\\nhttp://yucoding.blogspot.com/2013/02/leetcode-question-123-wildcard-matching.html\\n\\nIf it is not very obvious for you, I will try to explain the following two reasons why it works:\\n\\n**1. Greedy matching works, there is no need to backtrack more than once.** \\n\\nObviously, we need to use backtrack, but why Yu's solution didn't use a stack? The reason is, we only need to backtrack once to go back to the most recent '\\\\*'. Let me explain why. Given a string s and a pattern p, Consider the pattern string is divided into two substrings, p1 and p2, each of which starts with a '\\\\*'. With greedy matching, which is the case in Yu's solution, suppose p1 matches the *shortest head substring* of s, namely s1. Let's name its complement as s2, then we have s = s1 + s2 and p = p1+p2.\\n\\nThe statement is: \\n    *If p2 doesn't match s2 then p doesn't match s.* \\n\\nThe proof is the following:\\nIf s1 is the only head substring of s matching p1, then we don't have alternative matches for p1, then the only case is checked. \\nIf there is another head substring of s matching p1, namely s1' which must be longer than s1, then its complement, name s2' must be a tail substring of s2.  We know that p2 doesn't match s2, and p2 starts with '\\\\*', then we know p2 doesn't match any tail substring of s2, so p2 doesn't match s2' either.  To illustrate, consider:\\n\\n* p2 = \"*z\"\\n* s2 = \"abcd\"\\n\\np2 doesn't match s2, and p2 doesn't match any of \"bcd\", \"cd\", or \"d\". This is because in eyes of '\\\\*' \"abc\" \"bc\" \"c\" and \"\" are all the same. \\n\\n**2. C string all ends with a null char '\\\\0'.** \\nThis actually makes his problem easier to solve with C string, and if the inputs are std::string, the best way to do it is to use their c_str() to solve it. \\n\\nThe convenience is that when the pointer of pattern string p is at the end, pointing to '\\\\0', matching attempt with any char of string s (not including its end '\\\\0') will result in failure. This is equivalent to the following behavior:\\n   \\n*When characters in pattern string p are all matched but there are still characters remaining in string s, this matching attempt is a failure.*\\n\\nIf such logic is implemented in std::string, we need to use either the size of string or its end iterator."
                    }
                ]
            },
            {
                "id": 1723420,
                "content": [
                    {
                        "username": "Imory2020",
                        "content": "I've figured out what the difference is, but would like to raise a question here in case others might also wonder it in the future. For reference, [Regular Expression Matching][1].\\n\\n\\n  [1]: https://oj.leetcode.com/problems/regular-expression-matching/"
                    },
                    {
                        "username": "stridemann",
                        "content": "Yes, the solution from REM problem could be a bit fixed/simplified and will do this job.\nI did REM using backtracking using recursion (and it was working there), but in this problem I got a timeouts with this approach. \nWe will also get timeouts if we use Regex way (on C#) (some cases takes 3min to process).\nI'm sure the \"DP table\" should be used in both this problems. It will simplify code many times.\n\nUPD. Dp table did it job, but slow as hell :) (no timeouts)"
                    },
                    {
                        "username": "et169tkm",
                        "content": "[@pradeepsinghjaroliya](/pradeepsinghjaroliya) Sounds like we can translate the input in this question to a regular expression, then use the previous solution to match it...."
                    },
                    {
                        "username": "practice_90",
                        "content": "[@fengli738](/fengli738) * in regular expression matches zero or more previous character. Here * can match any character any number of times"
                    },
                    {
                        "username": "pradeepsinghjaroliya",
                        "content": "[@fengli738](/fengli738) \nIn that question \na* means it can be \"\" or \"a\" or \"aa\" or \"aa.....\". (i.e. Matches zero or more of the preceding element.)\na* cant be \"ab\" it can only have zero or more preceding element in this case will be 'a';\n' * ' is not independent character consider (a*) as together.\n In this case ,it is independent.\nExample: \"aa*\"\nin this question it can be- \"aa\",\"aaa\",\"aaa....a\",\"aab\",\"aabb\",\"aaba\"\nAnd in that question it can be-\n \"a\",\"aa\",\"aaa\",\"aaaa...aa\"\n(Notice in that question it can be \"a\" but here it can't be \"aa\" is the compulsary part.)\n(Hope it help, was confused in both , sorry for my bad wording)"
                    },
                    {
                        "username": "fengli738",
                        "content": "what is the difference between this problem and https://leetcode.com/problems/regular-expression-matching/description/"
                    },
                    {
                        "username": "ArpitDhamija",
                        "content": "So, I just gave my Tech Round in a startup, applied offcampus.\\n\\nI have not done this question earlier. So just imagine my situation\\n\\nInterviewer asked me this as the 2nd ques. 1st ques was also hard but I know the solution of that.\\n\\nIn this, I somehow able to get to the recurssive solution with some of the hints given by interviewer. Its hell difficult according to me to get to the optimal solution for this question in an interview if you haven\\'t done that earlier. \\nLike I get to the recurssive solution. And time got over. As in 1 hr, 2 hard questions were asked and I have to code that also. \\n\\nThats all about this. \\n\\n"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "[@nushk_23](/nushk_23) this was asked in adobe to someone I know"
                    },
                    {
                        "username": "nushk_23",
                        "content": "which company though?"
                    },
                    {
                        "username": "iZERWAS",
                        "content": "ah tough luck man"
                    },
                    {
                        "username": "zdi561",
                        "content": "\"aa\" \"a\" is false but \"abcabczzzde\", \"*abc???de*\" is true , they are contradictory"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "[@DarkMatter71](/DarkMatter71)  Indeed its false.. I think you are mistaken the pattern which is *abc???de*"
                    },
                    {
                        "username": "tanmaytaran",
                        "content": "\\'*\\' matches 0 or more characters but \\'?\\' matches exactly 1 character.\\nSo, for string \"aa\" and pattern \"a\", its false, which is correct. Now for string \"aa\" and any pattern like \"*\" || \"a*\" || \"*a\" || \"?*\" || \"*?\", etc. all are correct.\\n\\nNow if we look at string \"abcabczzzde\" with pattern \"abc???de\", \\n\\'abc\\' in pattern matches and leaves us with \"abczzzde\". Now 3 \\'?\\' need to match exactly 3 characters. So the next abc gets matched, hence we are now left with \"zzzde\" and in pattern \"de\". Thats why this is false."
                    },
                    {
                        "username": "DarkMatter71",
                        "content": "\"abcabczzzde\", \"abc???de\" is not true"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "this question having contradictory testcase.\n\"adceb\"   \"* a* b\" this is true why?\n\"a*c?b\"   \"acdcb\" then why tis is false?\n"
                    },
                    {
                        "username": "danielrrv",
                        "content": "[@Moonbeam8773](/Moonbeam8773) Doesn't make sense at all. \"The The first * must match an empty string\" There's no empty string at the beginning unless that the tester supposes it. Machines don't understand assumptions. The empty string is not there, then  it is not there. \nThe only way to pass this case in my opinion is assuming*(in software assumptions are risky) that the letters have priority over * because the * in first place makes the entire string fulfills the pattern."
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "\\* matches any character, including 0-length string. For \"\\*a\\*b\", the first \\* must match an empty string in order to have the \"a\" match up.  This leaves \"a\\*b\" to match \"adceb\". The first and last characters of the pattern and string match, so we remove them. This leaves the single \\* in the middle to match \"dce\", which it does. Therefore true.\n\n\"a\\*c?b\" start and end has to be \"a\" and \"b\" respectively. Which means we need to have \"\\*c?\" match \"cdc\". If the last \"?\" must match one character, that leaves \"\\*c\" to match \"cd\". Both last characters don't match, therefore it's false."
                    },
                    {
                        "username": "gargsaksham57",
                        "content": "could anybody explain why recursion+memoisation is giving tle"
                    },
                    {
                        "username": "raistar702614",
                        "content": "if you get a tle then most of the time this trick worls...declare the variable as unsigned int AND while passing the strings in the function pass them by reference.\\n\\nfor this qustion i tried memoization it passed 1774/1811\\n\\ni made the type as unsigned then it passed 1809/1811\\n\\ni passed the string by reference ...passed all cases with ahead of 85% in time and 15% in space "
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "I've written the Memoised version and it works.\nPlz check this - https://leetcode.com/problems/wildcard-matching/solutions/3230627/dp-memoization/?orderBy=most_votes"
                    },
                    {
                        "username": "user4523qT",
                        "content": "recursion is slow because of the nature of recursion. iterative solution is the fastest way"
                    },
                    {
                        "username": "c3lEsTIaL",
                        "content": "I can\\'t think about a greedy strategy that works here. Most solutions posted seemed like Brute Force or DP."
                    },
                    {
                        "username": "abhishek_kumar_12140040",
                        "content": "I am Trying t solve it by recursion + memorisation but on the last test case I am exceeding the memory limit. Is there any other method for this?"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "[@mahdichaben47](/mahdichaben47) pass the strings by reference"
                    },
                    {
                        "username": "mahdichaben47",
                        "content": "same problem they dont give me any test case but Memory Limit Exceeded"
                    },
                    {
                        "username": "sakshitiwari_01",
                        "content": "asked in Myanatomy in campus recruitment "
                    },
                    {
                        "username": "sevxin",
                        "content": "I submitted my code, and the result shows wrong when it applied on testcase:\"acdcb\", \"ac?b\". However, when I ran it in playground, I get the correct answer. What should I do? Could someone help me out?"
                    },
                    {
                        "username": "Okpatu",
                        "content": "C is not matched "
                    },
                    {
                        "username": "Ayush379",
                        "content": "I think that should give false, since ? means 1 character, but there are 2 needed. "
                    },
                    {
                        "username": "hzzyyy",
                        "content": "The highest voted solution is based on:\\nhttp://yucoding.blogspot.com/2013/02/leetcode-question-123-wildcard-matching.html\\n\\nIf it is not very obvious for you, I will try to explain the following two reasons why it works:\\n\\n**1. Greedy matching works, there is no need to backtrack more than once.** \\n\\nObviously, we need to use backtrack, but why Yu's solution didn't use a stack? The reason is, we only need to backtrack once to go back to the most recent '\\\\*'. Let me explain why. Given a string s and a pattern p, Consider the pattern string is divided into two substrings, p1 and p2, each of which starts with a '\\\\*'. With greedy matching, which is the case in Yu's solution, suppose p1 matches the *shortest head substring* of s, namely s1. Let's name its complement as s2, then we have s = s1 + s2 and p = p1+p2.\\n\\nThe statement is: \\n    *If p2 doesn't match s2 then p doesn't match s.* \\n\\nThe proof is the following:\\nIf s1 is the only head substring of s matching p1, then we don't have alternative matches for p1, then the only case is checked. \\nIf there is another head substring of s matching p1, namely s1' which must be longer than s1, then its complement, name s2' must be a tail substring of s2.  We know that p2 doesn't match s2, and p2 starts with '\\\\*', then we know p2 doesn't match any tail substring of s2, so p2 doesn't match s2' either.  To illustrate, consider:\\n\\n* p2 = \"*z\"\\n* s2 = \"abcd\"\\n\\np2 doesn't match s2, and p2 doesn't match any of \"bcd\", \"cd\", or \"d\". This is because in eyes of '\\\\*' \"abc\" \"bc\" \"c\" and \"\" are all the same. \\n\\n**2. C string all ends with a null char '\\\\0'.** \\nThis actually makes his problem easier to solve with C string, and if the inputs are std::string, the best way to do it is to use their c_str() to solve it. \\n\\nThe convenience is that when the pointer of pattern string p is at the end, pointing to '\\\\0', matching attempt with any char of string s (not including its end '\\\\0') will result in failure. This is equivalent to the following behavior:\\n   \\n*When characters in pattern string p are all matched but there are still characters remaining in string s, this matching attempt is a failure.*\\n\\nIf such logic is implemented in std::string, we need to use either the size of string or its end iterator."
                    }
                ]
            },
            {
                "id": 1570407,
                "content": [
                    {
                        "username": "Imory2020",
                        "content": "I've figured out what the difference is, but would like to raise a question here in case others might also wonder it in the future. For reference, [Regular Expression Matching][1].\\n\\n\\n  [1]: https://oj.leetcode.com/problems/regular-expression-matching/"
                    },
                    {
                        "username": "stridemann",
                        "content": "Yes, the solution from REM problem could be a bit fixed/simplified and will do this job.\nI did REM using backtracking using recursion (and it was working there), but in this problem I got a timeouts with this approach. \nWe will also get timeouts if we use Regex way (on C#) (some cases takes 3min to process).\nI'm sure the \"DP table\" should be used in both this problems. It will simplify code many times.\n\nUPD. Dp table did it job, but slow as hell :) (no timeouts)"
                    },
                    {
                        "username": "et169tkm",
                        "content": "[@pradeepsinghjaroliya](/pradeepsinghjaroliya) Sounds like we can translate the input in this question to a regular expression, then use the previous solution to match it...."
                    },
                    {
                        "username": "practice_90",
                        "content": "[@fengli738](/fengli738) * in regular expression matches zero or more previous character. Here * can match any character any number of times"
                    },
                    {
                        "username": "pradeepsinghjaroliya",
                        "content": "[@fengli738](/fengli738) \nIn that question \na* means it can be \"\" or \"a\" or \"aa\" or \"aa.....\". (i.e. Matches zero or more of the preceding element.)\na* cant be \"ab\" it can only have zero or more preceding element in this case will be 'a';\n' * ' is not independent character consider (a*) as together.\n In this case ,it is independent.\nExample: \"aa*\"\nin this question it can be- \"aa\",\"aaa\",\"aaa....a\",\"aab\",\"aabb\",\"aaba\"\nAnd in that question it can be-\n \"a\",\"aa\",\"aaa\",\"aaaa...aa\"\n(Notice in that question it can be \"a\" but here it can't be \"aa\" is the compulsary part.)\n(Hope it help, was confused in both , sorry for my bad wording)"
                    },
                    {
                        "username": "fengli738",
                        "content": "what is the difference between this problem and https://leetcode.com/problems/regular-expression-matching/description/"
                    },
                    {
                        "username": "ArpitDhamija",
                        "content": "So, I just gave my Tech Round in a startup, applied offcampus.\\n\\nI have not done this question earlier. So just imagine my situation\\n\\nInterviewer asked me this as the 2nd ques. 1st ques was also hard but I know the solution of that.\\n\\nIn this, I somehow able to get to the recurssive solution with some of the hints given by interviewer. Its hell difficult according to me to get to the optimal solution for this question in an interview if you haven\\'t done that earlier. \\nLike I get to the recurssive solution. And time got over. As in 1 hr, 2 hard questions were asked and I have to code that also. \\n\\nThats all about this. \\n\\n"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "[@nushk_23](/nushk_23) this was asked in adobe to someone I know"
                    },
                    {
                        "username": "nushk_23",
                        "content": "which company though?"
                    },
                    {
                        "username": "iZERWAS",
                        "content": "ah tough luck man"
                    },
                    {
                        "username": "zdi561",
                        "content": "\"aa\" \"a\" is false but \"abcabczzzde\", \"*abc???de*\" is true , they are contradictory"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "[@DarkMatter71](/DarkMatter71)  Indeed its false.. I think you are mistaken the pattern which is *abc???de*"
                    },
                    {
                        "username": "tanmaytaran",
                        "content": "\\'*\\' matches 0 or more characters but \\'?\\' matches exactly 1 character.\\nSo, for string \"aa\" and pattern \"a\", its false, which is correct. Now for string \"aa\" and any pattern like \"*\" || \"a*\" || \"*a\" || \"?*\" || \"*?\", etc. all are correct.\\n\\nNow if we look at string \"abcabczzzde\" with pattern \"abc???de\", \\n\\'abc\\' in pattern matches and leaves us with \"abczzzde\". Now 3 \\'?\\' need to match exactly 3 characters. So the next abc gets matched, hence we are now left with \"zzzde\" and in pattern \"de\". Thats why this is false."
                    },
                    {
                        "username": "DarkMatter71",
                        "content": "\"abcabczzzde\", \"abc???de\" is not true"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "this question having contradictory testcase.\n\"adceb\"   \"* a* b\" this is true why?\n\"a*c?b\"   \"acdcb\" then why tis is false?\n"
                    },
                    {
                        "username": "danielrrv",
                        "content": "[@Moonbeam8773](/Moonbeam8773) Doesn't make sense at all. \"The The first * must match an empty string\" There's no empty string at the beginning unless that the tester supposes it. Machines don't understand assumptions. The empty string is not there, then  it is not there. \nThe only way to pass this case in my opinion is assuming*(in software assumptions are risky) that the letters have priority over * because the * in first place makes the entire string fulfills the pattern."
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "\\* matches any character, including 0-length string. For \"\\*a\\*b\", the first \\* must match an empty string in order to have the \"a\" match up.  This leaves \"a\\*b\" to match \"adceb\". The first and last characters of the pattern and string match, so we remove them. This leaves the single \\* in the middle to match \"dce\", which it does. Therefore true.\n\n\"a\\*c?b\" start and end has to be \"a\" and \"b\" respectively. Which means we need to have \"\\*c?\" match \"cdc\". If the last \"?\" must match one character, that leaves \"\\*c\" to match \"cd\". Both last characters don't match, therefore it's false."
                    },
                    {
                        "username": "gargsaksham57",
                        "content": "could anybody explain why recursion+memoisation is giving tle"
                    },
                    {
                        "username": "raistar702614",
                        "content": "if you get a tle then most of the time this trick worls...declare the variable as unsigned int AND while passing the strings in the function pass them by reference.\\n\\nfor this qustion i tried memoization it passed 1774/1811\\n\\ni made the type as unsigned then it passed 1809/1811\\n\\ni passed the string by reference ...passed all cases with ahead of 85% in time and 15% in space "
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "I've written the Memoised version and it works.\nPlz check this - https://leetcode.com/problems/wildcard-matching/solutions/3230627/dp-memoization/?orderBy=most_votes"
                    },
                    {
                        "username": "user4523qT",
                        "content": "recursion is slow because of the nature of recursion. iterative solution is the fastest way"
                    },
                    {
                        "username": "c3lEsTIaL",
                        "content": "I can\\'t think about a greedy strategy that works here. Most solutions posted seemed like Brute Force or DP."
                    },
                    {
                        "username": "abhishek_kumar_12140040",
                        "content": "I am Trying t solve it by recursion + memorisation but on the last test case I am exceeding the memory limit. Is there any other method for this?"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "[@mahdichaben47](/mahdichaben47) pass the strings by reference"
                    },
                    {
                        "username": "mahdichaben47",
                        "content": "same problem they dont give me any test case but Memory Limit Exceeded"
                    },
                    {
                        "username": "sakshitiwari_01",
                        "content": "asked in Myanatomy in campus recruitment "
                    },
                    {
                        "username": "sevxin",
                        "content": "I submitted my code, and the result shows wrong when it applied on testcase:\"acdcb\", \"ac?b\". However, when I ran it in playground, I get the correct answer. What should I do? Could someone help me out?"
                    },
                    {
                        "username": "Okpatu",
                        "content": "C is not matched "
                    },
                    {
                        "username": "Ayush379",
                        "content": "I think that should give false, since ? means 1 character, but there are 2 needed. "
                    },
                    {
                        "username": "hzzyyy",
                        "content": "The highest voted solution is based on:\\nhttp://yucoding.blogspot.com/2013/02/leetcode-question-123-wildcard-matching.html\\n\\nIf it is not very obvious for you, I will try to explain the following two reasons why it works:\\n\\n**1. Greedy matching works, there is no need to backtrack more than once.** \\n\\nObviously, we need to use backtrack, but why Yu's solution didn't use a stack? The reason is, we only need to backtrack once to go back to the most recent '\\\\*'. Let me explain why. Given a string s and a pattern p, Consider the pattern string is divided into two substrings, p1 and p2, each of which starts with a '\\\\*'. With greedy matching, which is the case in Yu's solution, suppose p1 matches the *shortest head substring* of s, namely s1. Let's name its complement as s2, then we have s = s1 + s2 and p = p1+p2.\\n\\nThe statement is: \\n    *If p2 doesn't match s2 then p doesn't match s.* \\n\\nThe proof is the following:\\nIf s1 is the only head substring of s matching p1, then we don't have alternative matches for p1, then the only case is checked. \\nIf there is another head substring of s matching p1, namely s1' which must be longer than s1, then its complement, name s2' must be a tail substring of s2.  We know that p2 doesn't match s2, and p2 starts with '\\\\*', then we know p2 doesn't match any tail substring of s2, so p2 doesn't match s2' either.  To illustrate, consider:\\n\\n* p2 = \"*z\"\\n* s2 = \"abcd\"\\n\\np2 doesn't match s2, and p2 doesn't match any of \"bcd\", \"cd\", or \"d\". This is because in eyes of '\\\\*' \"abc\" \"bc\" \"c\" and \"\" are all the same. \\n\\n**2. C string all ends with a null char '\\\\0'.** \\nThis actually makes his problem easier to solve with C string, and if the inputs are std::string, the best way to do it is to use their c_str() to solve it. \\n\\nThe convenience is that when the pointer of pattern string p is at the end, pointing to '\\\\0', matching attempt with any char of string s (not including its end '\\\\0') will result in failure. This is equivalent to the following behavior:\\n   \\n*When characters in pattern string p are all matched but there are still characters remaining in string s, this matching attempt is a failure.*\\n\\nIf such logic is implemented in std::string, we need to use either the size of string or its end iterator."
                    }
                ]
            },
            {
                "id": 1568429,
                "content": [
                    {
                        "username": "Imory2020",
                        "content": "I've figured out what the difference is, but would like to raise a question here in case others might also wonder it in the future. For reference, [Regular Expression Matching][1].\\n\\n\\n  [1]: https://oj.leetcode.com/problems/regular-expression-matching/"
                    },
                    {
                        "username": "stridemann",
                        "content": "Yes, the solution from REM problem could be a bit fixed/simplified and will do this job.\nI did REM using backtracking using recursion (and it was working there), but in this problem I got a timeouts with this approach. \nWe will also get timeouts if we use Regex way (on C#) (some cases takes 3min to process).\nI'm sure the \"DP table\" should be used in both this problems. It will simplify code many times.\n\nUPD. Dp table did it job, but slow as hell :) (no timeouts)"
                    },
                    {
                        "username": "et169tkm",
                        "content": "[@pradeepsinghjaroliya](/pradeepsinghjaroliya) Sounds like we can translate the input in this question to a regular expression, then use the previous solution to match it...."
                    },
                    {
                        "username": "practice_90",
                        "content": "[@fengli738](/fengli738) * in regular expression matches zero or more previous character. Here * can match any character any number of times"
                    },
                    {
                        "username": "pradeepsinghjaroliya",
                        "content": "[@fengli738](/fengli738) \nIn that question \na* means it can be \"\" or \"a\" or \"aa\" or \"aa.....\". (i.e. Matches zero or more of the preceding element.)\na* cant be \"ab\" it can only have zero or more preceding element in this case will be 'a';\n' * ' is not independent character consider (a*) as together.\n In this case ,it is independent.\nExample: \"aa*\"\nin this question it can be- \"aa\",\"aaa\",\"aaa....a\",\"aab\",\"aabb\",\"aaba\"\nAnd in that question it can be-\n \"a\",\"aa\",\"aaa\",\"aaaa...aa\"\n(Notice in that question it can be \"a\" but here it can't be \"aa\" is the compulsary part.)\n(Hope it help, was confused in both , sorry for my bad wording)"
                    },
                    {
                        "username": "fengli738",
                        "content": "what is the difference between this problem and https://leetcode.com/problems/regular-expression-matching/description/"
                    },
                    {
                        "username": "ArpitDhamija",
                        "content": "So, I just gave my Tech Round in a startup, applied offcampus.\\n\\nI have not done this question earlier. So just imagine my situation\\n\\nInterviewer asked me this as the 2nd ques. 1st ques was also hard but I know the solution of that.\\n\\nIn this, I somehow able to get to the recurssive solution with some of the hints given by interviewer. Its hell difficult according to me to get to the optimal solution for this question in an interview if you haven\\'t done that earlier. \\nLike I get to the recurssive solution. And time got over. As in 1 hr, 2 hard questions were asked and I have to code that also. \\n\\nThats all about this. \\n\\n"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "[@nushk_23](/nushk_23) this was asked in adobe to someone I know"
                    },
                    {
                        "username": "nushk_23",
                        "content": "which company though?"
                    },
                    {
                        "username": "iZERWAS",
                        "content": "ah tough luck man"
                    },
                    {
                        "username": "zdi561",
                        "content": "\"aa\" \"a\" is false but \"abcabczzzde\", \"*abc???de*\" is true , they are contradictory"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "[@DarkMatter71](/DarkMatter71)  Indeed its false.. I think you are mistaken the pattern which is *abc???de*"
                    },
                    {
                        "username": "tanmaytaran",
                        "content": "\\'*\\' matches 0 or more characters but \\'?\\' matches exactly 1 character.\\nSo, for string \"aa\" and pattern \"a\", its false, which is correct. Now for string \"aa\" and any pattern like \"*\" || \"a*\" || \"*a\" || \"?*\" || \"*?\", etc. all are correct.\\n\\nNow if we look at string \"abcabczzzde\" with pattern \"abc???de\", \\n\\'abc\\' in pattern matches and leaves us with \"abczzzde\". Now 3 \\'?\\' need to match exactly 3 characters. So the next abc gets matched, hence we are now left with \"zzzde\" and in pattern \"de\". Thats why this is false."
                    },
                    {
                        "username": "DarkMatter71",
                        "content": "\"abcabczzzde\", \"abc???de\" is not true"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "this question having contradictory testcase.\n\"adceb\"   \"* a* b\" this is true why?\n\"a*c?b\"   \"acdcb\" then why tis is false?\n"
                    },
                    {
                        "username": "danielrrv",
                        "content": "[@Moonbeam8773](/Moonbeam8773) Doesn't make sense at all. \"The The first * must match an empty string\" There's no empty string at the beginning unless that the tester supposes it. Machines don't understand assumptions. The empty string is not there, then  it is not there. \nThe only way to pass this case in my opinion is assuming*(in software assumptions are risky) that the letters have priority over * because the * in first place makes the entire string fulfills the pattern."
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "\\* matches any character, including 0-length string. For \"\\*a\\*b\", the first \\* must match an empty string in order to have the \"a\" match up.  This leaves \"a\\*b\" to match \"adceb\". The first and last characters of the pattern and string match, so we remove them. This leaves the single \\* in the middle to match \"dce\", which it does. Therefore true.\n\n\"a\\*c?b\" start and end has to be \"a\" and \"b\" respectively. Which means we need to have \"\\*c?\" match \"cdc\". If the last \"?\" must match one character, that leaves \"\\*c\" to match \"cd\". Both last characters don't match, therefore it's false."
                    },
                    {
                        "username": "gargsaksham57",
                        "content": "could anybody explain why recursion+memoisation is giving tle"
                    },
                    {
                        "username": "raistar702614",
                        "content": "if you get a tle then most of the time this trick worls...declare the variable as unsigned int AND while passing the strings in the function pass them by reference.\\n\\nfor this qustion i tried memoization it passed 1774/1811\\n\\ni made the type as unsigned then it passed 1809/1811\\n\\ni passed the string by reference ...passed all cases with ahead of 85% in time and 15% in space "
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "I've written the Memoised version and it works.\nPlz check this - https://leetcode.com/problems/wildcard-matching/solutions/3230627/dp-memoization/?orderBy=most_votes"
                    },
                    {
                        "username": "user4523qT",
                        "content": "recursion is slow because of the nature of recursion. iterative solution is the fastest way"
                    },
                    {
                        "username": "c3lEsTIaL",
                        "content": "I can\\'t think about a greedy strategy that works here. Most solutions posted seemed like Brute Force or DP."
                    },
                    {
                        "username": "abhishek_kumar_12140040",
                        "content": "I am Trying t solve it by recursion + memorisation but on the last test case I am exceeding the memory limit. Is there any other method for this?"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "[@mahdichaben47](/mahdichaben47) pass the strings by reference"
                    },
                    {
                        "username": "mahdichaben47",
                        "content": "same problem they dont give me any test case but Memory Limit Exceeded"
                    },
                    {
                        "username": "sakshitiwari_01",
                        "content": "asked in Myanatomy in campus recruitment "
                    },
                    {
                        "username": "sevxin",
                        "content": "I submitted my code, and the result shows wrong when it applied on testcase:\"acdcb\", \"ac?b\". However, when I ran it in playground, I get the correct answer. What should I do? Could someone help me out?"
                    },
                    {
                        "username": "Okpatu",
                        "content": "C is not matched "
                    },
                    {
                        "username": "Ayush379",
                        "content": "I think that should give false, since ? means 1 character, but there are 2 needed. "
                    },
                    {
                        "username": "hzzyyy",
                        "content": "The highest voted solution is based on:\\nhttp://yucoding.blogspot.com/2013/02/leetcode-question-123-wildcard-matching.html\\n\\nIf it is not very obvious for you, I will try to explain the following two reasons why it works:\\n\\n**1. Greedy matching works, there is no need to backtrack more than once.** \\n\\nObviously, we need to use backtrack, but why Yu's solution didn't use a stack? The reason is, we only need to backtrack once to go back to the most recent '\\\\*'. Let me explain why. Given a string s and a pattern p, Consider the pattern string is divided into two substrings, p1 and p2, each of which starts with a '\\\\*'. With greedy matching, which is the case in Yu's solution, suppose p1 matches the *shortest head substring* of s, namely s1. Let's name its complement as s2, then we have s = s1 + s2 and p = p1+p2.\\n\\nThe statement is: \\n    *If p2 doesn't match s2 then p doesn't match s.* \\n\\nThe proof is the following:\\nIf s1 is the only head substring of s matching p1, then we don't have alternative matches for p1, then the only case is checked. \\nIf there is another head substring of s matching p1, namely s1' which must be longer than s1, then its complement, name s2' must be a tail substring of s2.  We know that p2 doesn't match s2, and p2 starts with '\\\\*', then we know p2 doesn't match any tail substring of s2, so p2 doesn't match s2' either.  To illustrate, consider:\\n\\n* p2 = \"*z\"\\n* s2 = \"abcd\"\\n\\np2 doesn't match s2, and p2 doesn't match any of \"bcd\", \"cd\", or \"d\". This is because in eyes of '\\\\*' \"abc\" \"bc\" \"c\" and \"\" are all the same. \\n\\n**2. C string all ends with a null char '\\\\0'.** \\nThis actually makes his problem easier to solve with C string, and if the inputs are std::string, the best way to do it is to use their c_str() to solve it. \\n\\nThe convenience is that when the pointer of pattern string p is at the end, pointing to '\\\\0', matching attempt with any char of string s (not including its end '\\\\0') will result in failure. This is equivalent to the following behavior:\\n   \\n*When characters in pattern string p are all matched but there are still characters remaining in string s, this matching attempt is a failure.*\\n\\nIf such logic is implemented in std::string, we need to use either the size of string or its end iterator."
                    }
                ]
            },
            {
                "id": 1972353,
                "content": [
                    {
                        "username": "Imory2020",
                        "content": "I've figured out what the difference is, but would like to raise a question here in case others might also wonder it in the future. For reference, [Regular Expression Matching][1].\\n\\n\\n  [1]: https://oj.leetcode.com/problems/regular-expression-matching/"
                    },
                    {
                        "username": "stridemann",
                        "content": "Yes, the solution from REM problem could be a bit fixed/simplified and will do this job.\nI did REM using backtracking using recursion (and it was working there), but in this problem I got a timeouts with this approach. \nWe will also get timeouts if we use Regex way (on C#) (some cases takes 3min to process).\nI'm sure the \"DP table\" should be used in both this problems. It will simplify code many times.\n\nUPD. Dp table did it job, but slow as hell :) (no timeouts)"
                    },
                    {
                        "username": "et169tkm",
                        "content": "[@pradeepsinghjaroliya](/pradeepsinghjaroliya) Sounds like we can translate the input in this question to a regular expression, then use the previous solution to match it...."
                    },
                    {
                        "username": "practice_90",
                        "content": "[@fengli738](/fengli738) * in regular expression matches zero or more previous character. Here * can match any character any number of times"
                    },
                    {
                        "username": "pradeepsinghjaroliya",
                        "content": "[@fengli738](/fengli738) \nIn that question \na* means it can be \"\" or \"a\" or \"aa\" or \"aa.....\". (i.e. Matches zero or more of the preceding element.)\na* cant be \"ab\" it can only have zero or more preceding element in this case will be 'a';\n' * ' is not independent character consider (a*) as together.\n In this case ,it is independent.\nExample: \"aa*\"\nin this question it can be- \"aa\",\"aaa\",\"aaa....a\",\"aab\",\"aabb\",\"aaba\"\nAnd in that question it can be-\n \"a\",\"aa\",\"aaa\",\"aaaa...aa\"\n(Notice in that question it can be \"a\" but here it can't be \"aa\" is the compulsary part.)\n(Hope it help, was confused in both , sorry for my bad wording)"
                    },
                    {
                        "username": "fengli738",
                        "content": "what is the difference between this problem and https://leetcode.com/problems/regular-expression-matching/description/"
                    },
                    {
                        "username": "ArpitDhamija",
                        "content": "So, I just gave my Tech Round in a startup, applied offcampus.\\n\\nI have not done this question earlier. So just imagine my situation\\n\\nInterviewer asked me this as the 2nd ques. 1st ques was also hard but I know the solution of that.\\n\\nIn this, I somehow able to get to the recurssive solution with some of the hints given by interviewer. Its hell difficult according to me to get to the optimal solution for this question in an interview if you haven\\'t done that earlier. \\nLike I get to the recurssive solution. And time got over. As in 1 hr, 2 hard questions were asked and I have to code that also. \\n\\nThats all about this. \\n\\n"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "[@nushk_23](/nushk_23) this was asked in adobe to someone I know"
                    },
                    {
                        "username": "nushk_23",
                        "content": "which company though?"
                    },
                    {
                        "username": "iZERWAS",
                        "content": "ah tough luck man"
                    },
                    {
                        "username": "zdi561",
                        "content": "\"aa\" \"a\" is false but \"abcabczzzde\", \"*abc???de*\" is true , they are contradictory"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "[@DarkMatter71](/DarkMatter71)  Indeed its false.. I think you are mistaken the pattern which is *abc???de*"
                    },
                    {
                        "username": "tanmaytaran",
                        "content": "\\'*\\' matches 0 or more characters but \\'?\\' matches exactly 1 character.\\nSo, for string \"aa\" and pattern \"a\", its false, which is correct. Now for string \"aa\" and any pattern like \"*\" || \"a*\" || \"*a\" || \"?*\" || \"*?\", etc. all are correct.\\n\\nNow if we look at string \"abcabczzzde\" with pattern \"abc???de\", \\n\\'abc\\' in pattern matches and leaves us with \"abczzzde\". Now 3 \\'?\\' need to match exactly 3 characters. So the next abc gets matched, hence we are now left with \"zzzde\" and in pattern \"de\". Thats why this is false."
                    },
                    {
                        "username": "DarkMatter71",
                        "content": "\"abcabczzzde\", \"abc???de\" is not true"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "this question having contradictory testcase.\n\"adceb\"   \"* a* b\" this is true why?\n\"a*c?b\"   \"acdcb\" then why tis is false?\n"
                    },
                    {
                        "username": "danielrrv",
                        "content": "[@Moonbeam8773](/Moonbeam8773) Doesn't make sense at all. \"The The first * must match an empty string\" There's no empty string at the beginning unless that the tester supposes it. Machines don't understand assumptions. The empty string is not there, then  it is not there. \nThe only way to pass this case in my opinion is assuming*(in software assumptions are risky) that the letters have priority over * because the * in first place makes the entire string fulfills the pattern."
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "\\* matches any character, including 0-length string. For \"\\*a\\*b\", the first \\* must match an empty string in order to have the \"a\" match up.  This leaves \"a\\*b\" to match \"adceb\". The first and last characters of the pattern and string match, so we remove them. This leaves the single \\* in the middle to match \"dce\", which it does. Therefore true.\n\n\"a\\*c?b\" start and end has to be \"a\" and \"b\" respectively. Which means we need to have \"\\*c?\" match \"cdc\". If the last \"?\" must match one character, that leaves \"\\*c\" to match \"cd\". Both last characters don't match, therefore it's false."
                    },
                    {
                        "username": "gargsaksham57",
                        "content": "could anybody explain why recursion+memoisation is giving tle"
                    },
                    {
                        "username": "raistar702614",
                        "content": "if you get a tle then most of the time this trick worls...declare the variable as unsigned int AND while passing the strings in the function pass them by reference.\\n\\nfor this qustion i tried memoization it passed 1774/1811\\n\\ni made the type as unsigned then it passed 1809/1811\\n\\ni passed the string by reference ...passed all cases with ahead of 85% in time and 15% in space "
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "I've written the Memoised version and it works.\nPlz check this - https://leetcode.com/problems/wildcard-matching/solutions/3230627/dp-memoization/?orderBy=most_votes"
                    },
                    {
                        "username": "user4523qT",
                        "content": "recursion is slow because of the nature of recursion. iterative solution is the fastest way"
                    },
                    {
                        "username": "c3lEsTIaL",
                        "content": "I can\\'t think about a greedy strategy that works here. Most solutions posted seemed like Brute Force or DP."
                    },
                    {
                        "username": "abhishek_kumar_12140040",
                        "content": "I am Trying t solve it by recursion + memorisation but on the last test case I am exceeding the memory limit. Is there any other method for this?"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "[@mahdichaben47](/mahdichaben47) pass the strings by reference"
                    },
                    {
                        "username": "mahdichaben47",
                        "content": "same problem they dont give me any test case but Memory Limit Exceeded"
                    },
                    {
                        "username": "sakshitiwari_01",
                        "content": "asked in Myanatomy in campus recruitment "
                    },
                    {
                        "username": "sevxin",
                        "content": "I submitted my code, and the result shows wrong when it applied on testcase:\"acdcb\", \"ac?b\". However, when I ran it in playground, I get the correct answer. What should I do? Could someone help me out?"
                    },
                    {
                        "username": "Okpatu",
                        "content": "C is not matched "
                    },
                    {
                        "username": "Ayush379",
                        "content": "I think that should give false, since ? means 1 character, but there are 2 needed. "
                    },
                    {
                        "username": "hzzyyy",
                        "content": "The highest voted solution is based on:\\nhttp://yucoding.blogspot.com/2013/02/leetcode-question-123-wildcard-matching.html\\n\\nIf it is not very obvious for you, I will try to explain the following two reasons why it works:\\n\\n**1. Greedy matching works, there is no need to backtrack more than once.** \\n\\nObviously, we need to use backtrack, but why Yu's solution didn't use a stack? The reason is, we only need to backtrack once to go back to the most recent '\\\\*'. Let me explain why. Given a string s and a pattern p, Consider the pattern string is divided into two substrings, p1 and p2, each of which starts with a '\\\\*'. With greedy matching, which is the case in Yu's solution, suppose p1 matches the *shortest head substring* of s, namely s1. Let's name its complement as s2, then we have s = s1 + s2 and p = p1+p2.\\n\\nThe statement is: \\n    *If p2 doesn't match s2 then p doesn't match s.* \\n\\nThe proof is the following:\\nIf s1 is the only head substring of s matching p1, then we don't have alternative matches for p1, then the only case is checked. \\nIf there is another head substring of s matching p1, namely s1' which must be longer than s1, then its complement, name s2' must be a tail substring of s2.  We know that p2 doesn't match s2, and p2 starts with '\\\\*', then we know p2 doesn't match any tail substring of s2, so p2 doesn't match s2' either.  To illustrate, consider:\\n\\n* p2 = \"*z\"\\n* s2 = \"abcd\"\\n\\np2 doesn't match s2, and p2 doesn't match any of \"bcd\", \"cd\", or \"d\". This is because in eyes of '\\\\*' \"abc\" \"bc\" \"c\" and \"\" are all the same. \\n\\n**2. C string all ends with a null char '\\\\0'.** \\nThis actually makes his problem easier to solve with C string, and if the inputs are std::string, the best way to do it is to use their c_str() to solve it. \\n\\nThe convenience is that when the pointer of pattern string p is at the end, pointing to '\\\\0', matching attempt with any char of string s (not including its end '\\\\0') will result in failure. This is equivalent to the following behavior:\\n   \\n*When characters in pattern string p are all matched but there are still characters remaining in string s, this matching attempt is a failure.*\\n\\nIf such logic is implemented in std::string, we need to use either the size of string or its end iterator."
                    }
                ]
            },
            {
                "id": 1868299,
                "content": [
                    {
                        "username": "Imory2020",
                        "content": "I've figured out what the difference is, but would like to raise a question here in case others might also wonder it in the future. For reference, [Regular Expression Matching][1].\\n\\n\\n  [1]: https://oj.leetcode.com/problems/regular-expression-matching/"
                    },
                    {
                        "username": "stridemann",
                        "content": "Yes, the solution from REM problem could be a bit fixed/simplified and will do this job.\nI did REM using backtracking using recursion (and it was working there), but in this problem I got a timeouts with this approach. \nWe will also get timeouts if we use Regex way (on C#) (some cases takes 3min to process).\nI'm sure the \"DP table\" should be used in both this problems. It will simplify code many times.\n\nUPD. Dp table did it job, but slow as hell :) (no timeouts)"
                    },
                    {
                        "username": "et169tkm",
                        "content": "[@pradeepsinghjaroliya](/pradeepsinghjaroliya) Sounds like we can translate the input in this question to a regular expression, then use the previous solution to match it...."
                    },
                    {
                        "username": "practice_90",
                        "content": "[@fengli738](/fengli738) * in regular expression matches zero or more previous character. Here * can match any character any number of times"
                    },
                    {
                        "username": "pradeepsinghjaroliya",
                        "content": "[@fengli738](/fengli738) \nIn that question \na* means it can be \"\" or \"a\" or \"aa\" or \"aa.....\". (i.e. Matches zero or more of the preceding element.)\na* cant be \"ab\" it can only have zero or more preceding element in this case will be 'a';\n' * ' is not independent character consider (a*) as together.\n In this case ,it is independent.\nExample: \"aa*\"\nin this question it can be- \"aa\",\"aaa\",\"aaa....a\",\"aab\",\"aabb\",\"aaba\"\nAnd in that question it can be-\n \"a\",\"aa\",\"aaa\",\"aaaa...aa\"\n(Notice in that question it can be \"a\" but here it can't be \"aa\" is the compulsary part.)\n(Hope it help, was confused in both , sorry for my bad wording)"
                    },
                    {
                        "username": "fengli738",
                        "content": "what is the difference between this problem and https://leetcode.com/problems/regular-expression-matching/description/"
                    },
                    {
                        "username": "ArpitDhamija",
                        "content": "So, I just gave my Tech Round in a startup, applied offcampus.\\n\\nI have not done this question earlier. So just imagine my situation\\n\\nInterviewer asked me this as the 2nd ques. 1st ques was also hard but I know the solution of that.\\n\\nIn this, I somehow able to get to the recurssive solution with some of the hints given by interviewer. Its hell difficult according to me to get to the optimal solution for this question in an interview if you haven\\'t done that earlier. \\nLike I get to the recurssive solution. And time got over. As in 1 hr, 2 hard questions were asked and I have to code that also. \\n\\nThats all about this. \\n\\n"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "[@nushk_23](/nushk_23) this was asked in adobe to someone I know"
                    },
                    {
                        "username": "nushk_23",
                        "content": "which company though?"
                    },
                    {
                        "username": "iZERWAS",
                        "content": "ah tough luck man"
                    },
                    {
                        "username": "zdi561",
                        "content": "\"aa\" \"a\" is false but \"abcabczzzde\", \"*abc???de*\" is true , they are contradictory"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "[@DarkMatter71](/DarkMatter71)  Indeed its false.. I think you are mistaken the pattern which is *abc???de*"
                    },
                    {
                        "username": "tanmaytaran",
                        "content": "\\'*\\' matches 0 or more characters but \\'?\\' matches exactly 1 character.\\nSo, for string \"aa\" and pattern \"a\", its false, which is correct. Now for string \"aa\" and any pattern like \"*\" || \"a*\" || \"*a\" || \"?*\" || \"*?\", etc. all are correct.\\n\\nNow if we look at string \"abcabczzzde\" with pattern \"abc???de\", \\n\\'abc\\' in pattern matches and leaves us with \"abczzzde\". Now 3 \\'?\\' need to match exactly 3 characters. So the next abc gets matched, hence we are now left with \"zzzde\" and in pattern \"de\". Thats why this is false."
                    },
                    {
                        "username": "DarkMatter71",
                        "content": "\"abcabczzzde\", \"abc???de\" is not true"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "this question having contradictory testcase.\n\"adceb\"   \"* a* b\" this is true why?\n\"a*c?b\"   \"acdcb\" then why tis is false?\n"
                    },
                    {
                        "username": "danielrrv",
                        "content": "[@Moonbeam8773](/Moonbeam8773) Doesn't make sense at all. \"The The first * must match an empty string\" There's no empty string at the beginning unless that the tester supposes it. Machines don't understand assumptions. The empty string is not there, then  it is not there. \nThe only way to pass this case in my opinion is assuming*(in software assumptions are risky) that the letters have priority over * because the * in first place makes the entire string fulfills the pattern."
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "\\* matches any character, including 0-length string. For \"\\*a\\*b\", the first \\* must match an empty string in order to have the \"a\" match up.  This leaves \"a\\*b\" to match \"adceb\". The first and last characters of the pattern and string match, so we remove them. This leaves the single \\* in the middle to match \"dce\", which it does. Therefore true.\n\n\"a\\*c?b\" start and end has to be \"a\" and \"b\" respectively. Which means we need to have \"\\*c?\" match \"cdc\". If the last \"?\" must match one character, that leaves \"\\*c\" to match \"cd\". Both last characters don't match, therefore it's false."
                    },
                    {
                        "username": "gargsaksham57",
                        "content": "could anybody explain why recursion+memoisation is giving tle"
                    },
                    {
                        "username": "raistar702614",
                        "content": "if you get a tle then most of the time this trick worls...declare the variable as unsigned int AND while passing the strings in the function pass them by reference.\\n\\nfor this qustion i tried memoization it passed 1774/1811\\n\\ni made the type as unsigned then it passed 1809/1811\\n\\ni passed the string by reference ...passed all cases with ahead of 85% in time and 15% in space "
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "I've written the Memoised version and it works.\nPlz check this - https://leetcode.com/problems/wildcard-matching/solutions/3230627/dp-memoization/?orderBy=most_votes"
                    },
                    {
                        "username": "user4523qT",
                        "content": "recursion is slow because of the nature of recursion. iterative solution is the fastest way"
                    },
                    {
                        "username": "c3lEsTIaL",
                        "content": "I can\\'t think about a greedy strategy that works here. Most solutions posted seemed like Brute Force or DP."
                    },
                    {
                        "username": "abhishek_kumar_12140040",
                        "content": "I am Trying t solve it by recursion + memorisation but on the last test case I am exceeding the memory limit. Is there any other method for this?"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "[@mahdichaben47](/mahdichaben47) pass the strings by reference"
                    },
                    {
                        "username": "mahdichaben47",
                        "content": "same problem they dont give me any test case but Memory Limit Exceeded"
                    },
                    {
                        "username": "sakshitiwari_01",
                        "content": "asked in Myanatomy in campus recruitment "
                    },
                    {
                        "username": "sevxin",
                        "content": "I submitted my code, and the result shows wrong when it applied on testcase:\"acdcb\", \"ac?b\". However, when I ran it in playground, I get the correct answer. What should I do? Could someone help me out?"
                    },
                    {
                        "username": "Okpatu",
                        "content": "C is not matched "
                    },
                    {
                        "username": "Ayush379",
                        "content": "I think that should give false, since ? means 1 character, but there are 2 needed. "
                    },
                    {
                        "username": "hzzyyy",
                        "content": "The highest voted solution is based on:\\nhttp://yucoding.blogspot.com/2013/02/leetcode-question-123-wildcard-matching.html\\n\\nIf it is not very obvious for you, I will try to explain the following two reasons why it works:\\n\\n**1. Greedy matching works, there is no need to backtrack more than once.** \\n\\nObviously, we need to use backtrack, but why Yu's solution didn't use a stack? The reason is, we only need to backtrack once to go back to the most recent '\\\\*'. Let me explain why. Given a string s and a pattern p, Consider the pattern string is divided into two substrings, p1 and p2, each of which starts with a '\\\\*'. With greedy matching, which is the case in Yu's solution, suppose p1 matches the *shortest head substring* of s, namely s1. Let's name its complement as s2, then we have s = s1 + s2 and p = p1+p2.\\n\\nThe statement is: \\n    *If p2 doesn't match s2 then p doesn't match s.* \\n\\nThe proof is the following:\\nIf s1 is the only head substring of s matching p1, then we don't have alternative matches for p1, then the only case is checked. \\nIf there is another head substring of s matching p1, namely s1' which must be longer than s1, then its complement, name s2' must be a tail substring of s2.  We know that p2 doesn't match s2, and p2 starts with '\\\\*', then we know p2 doesn't match any tail substring of s2, so p2 doesn't match s2' either.  To illustrate, consider:\\n\\n* p2 = \"*z\"\\n* s2 = \"abcd\"\\n\\np2 doesn't match s2, and p2 doesn't match any of \"bcd\", \"cd\", or \"d\". This is because in eyes of '\\\\*' \"abc\" \"bc\" \"c\" and \"\" are all the same. \\n\\n**2. C string all ends with a null char '\\\\0'.** \\nThis actually makes his problem easier to solve with C string, and if the inputs are std::string, the best way to do it is to use their c_str() to solve it. \\n\\nThe convenience is that when the pointer of pattern string p is at the end, pointing to '\\\\0', matching attempt with any char of string s (not including its end '\\\\0') will result in failure. This is equivalent to the following behavior:\\n   \\n*When characters in pattern string p are all matched but there are still characters remaining in string s, this matching attempt is a failure.*\\n\\nIf such logic is implemented in std::string, we need to use either the size of string or its end iterator."
                    }
                ]
            },
            {
                "id": 1572611,
                "content": [
                    {
                        "username": "Imory2020",
                        "content": "I've figured out what the difference is, but would like to raise a question here in case others might also wonder it in the future. For reference, [Regular Expression Matching][1].\\n\\n\\n  [1]: https://oj.leetcode.com/problems/regular-expression-matching/"
                    },
                    {
                        "username": "stridemann",
                        "content": "Yes, the solution from REM problem could be a bit fixed/simplified and will do this job.\nI did REM using backtracking using recursion (and it was working there), but in this problem I got a timeouts with this approach. \nWe will also get timeouts if we use Regex way (on C#) (some cases takes 3min to process).\nI'm sure the \"DP table\" should be used in both this problems. It will simplify code many times.\n\nUPD. Dp table did it job, but slow as hell :) (no timeouts)"
                    },
                    {
                        "username": "et169tkm",
                        "content": "[@pradeepsinghjaroliya](/pradeepsinghjaroliya) Sounds like we can translate the input in this question to a regular expression, then use the previous solution to match it...."
                    },
                    {
                        "username": "practice_90",
                        "content": "[@fengli738](/fengli738) * in regular expression matches zero or more previous character. Here * can match any character any number of times"
                    },
                    {
                        "username": "pradeepsinghjaroliya",
                        "content": "[@fengli738](/fengli738) \nIn that question \na* means it can be \"\" or \"a\" or \"aa\" or \"aa.....\". (i.e. Matches zero or more of the preceding element.)\na* cant be \"ab\" it can only have zero or more preceding element in this case will be 'a';\n' * ' is not independent character consider (a*) as together.\n In this case ,it is independent.\nExample: \"aa*\"\nin this question it can be- \"aa\",\"aaa\",\"aaa....a\",\"aab\",\"aabb\",\"aaba\"\nAnd in that question it can be-\n \"a\",\"aa\",\"aaa\",\"aaaa...aa\"\n(Notice in that question it can be \"a\" but here it can't be \"aa\" is the compulsary part.)\n(Hope it help, was confused in both , sorry for my bad wording)"
                    },
                    {
                        "username": "fengli738",
                        "content": "what is the difference between this problem and https://leetcode.com/problems/regular-expression-matching/description/"
                    },
                    {
                        "username": "ArpitDhamija",
                        "content": "So, I just gave my Tech Round in a startup, applied offcampus.\\n\\nI have not done this question earlier. So just imagine my situation\\n\\nInterviewer asked me this as the 2nd ques. 1st ques was also hard but I know the solution of that.\\n\\nIn this, I somehow able to get to the recurssive solution with some of the hints given by interviewer. Its hell difficult according to me to get to the optimal solution for this question in an interview if you haven\\'t done that earlier. \\nLike I get to the recurssive solution. And time got over. As in 1 hr, 2 hard questions were asked and I have to code that also. \\n\\nThats all about this. \\n\\n"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "[@nushk_23](/nushk_23) this was asked in adobe to someone I know"
                    },
                    {
                        "username": "nushk_23",
                        "content": "which company though?"
                    },
                    {
                        "username": "iZERWAS",
                        "content": "ah tough luck man"
                    },
                    {
                        "username": "zdi561",
                        "content": "\"aa\" \"a\" is false but \"abcabczzzde\", \"*abc???de*\" is true , they are contradictory"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "[@DarkMatter71](/DarkMatter71)  Indeed its false.. I think you are mistaken the pattern which is *abc???de*"
                    },
                    {
                        "username": "tanmaytaran",
                        "content": "\\'*\\' matches 0 or more characters but \\'?\\' matches exactly 1 character.\\nSo, for string \"aa\" and pattern \"a\", its false, which is correct. Now for string \"aa\" and any pattern like \"*\" || \"a*\" || \"*a\" || \"?*\" || \"*?\", etc. all are correct.\\n\\nNow if we look at string \"abcabczzzde\" with pattern \"abc???de\", \\n\\'abc\\' in pattern matches and leaves us with \"abczzzde\". Now 3 \\'?\\' need to match exactly 3 characters. So the next abc gets matched, hence we are now left with \"zzzde\" and in pattern \"de\". Thats why this is false."
                    },
                    {
                        "username": "DarkMatter71",
                        "content": "\"abcabczzzde\", \"abc???de\" is not true"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "this question having contradictory testcase.\n\"adceb\"   \"* a* b\" this is true why?\n\"a*c?b\"   \"acdcb\" then why tis is false?\n"
                    },
                    {
                        "username": "danielrrv",
                        "content": "[@Moonbeam8773](/Moonbeam8773) Doesn't make sense at all. \"The The first * must match an empty string\" There's no empty string at the beginning unless that the tester supposes it. Machines don't understand assumptions. The empty string is not there, then  it is not there. \nThe only way to pass this case in my opinion is assuming*(in software assumptions are risky) that the letters have priority over * because the * in first place makes the entire string fulfills the pattern."
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "\\* matches any character, including 0-length string. For \"\\*a\\*b\", the first \\* must match an empty string in order to have the \"a\" match up.  This leaves \"a\\*b\" to match \"adceb\". The first and last characters of the pattern and string match, so we remove them. This leaves the single \\* in the middle to match \"dce\", which it does. Therefore true.\n\n\"a\\*c?b\" start and end has to be \"a\" and \"b\" respectively. Which means we need to have \"\\*c?\" match \"cdc\". If the last \"?\" must match one character, that leaves \"\\*c\" to match \"cd\". Both last characters don't match, therefore it's false."
                    },
                    {
                        "username": "gargsaksham57",
                        "content": "could anybody explain why recursion+memoisation is giving tle"
                    },
                    {
                        "username": "raistar702614",
                        "content": "if you get a tle then most of the time this trick worls...declare the variable as unsigned int AND while passing the strings in the function pass them by reference.\\n\\nfor this qustion i tried memoization it passed 1774/1811\\n\\ni made the type as unsigned then it passed 1809/1811\\n\\ni passed the string by reference ...passed all cases with ahead of 85% in time and 15% in space "
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "I've written the Memoised version and it works.\nPlz check this - https://leetcode.com/problems/wildcard-matching/solutions/3230627/dp-memoization/?orderBy=most_votes"
                    },
                    {
                        "username": "user4523qT",
                        "content": "recursion is slow because of the nature of recursion. iterative solution is the fastest way"
                    },
                    {
                        "username": "c3lEsTIaL",
                        "content": "I can\\'t think about a greedy strategy that works here. Most solutions posted seemed like Brute Force or DP."
                    },
                    {
                        "username": "abhishek_kumar_12140040",
                        "content": "I am Trying t solve it by recursion + memorisation but on the last test case I am exceeding the memory limit. Is there any other method for this?"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "[@mahdichaben47](/mahdichaben47) pass the strings by reference"
                    },
                    {
                        "username": "mahdichaben47",
                        "content": "same problem they dont give me any test case but Memory Limit Exceeded"
                    },
                    {
                        "username": "sakshitiwari_01",
                        "content": "asked in Myanatomy in campus recruitment "
                    },
                    {
                        "username": "sevxin",
                        "content": "I submitted my code, and the result shows wrong when it applied on testcase:\"acdcb\", \"ac?b\". However, when I ran it in playground, I get the correct answer. What should I do? Could someone help me out?"
                    },
                    {
                        "username": "Okpatu",
                        "content": "C is not matched "
                    },
                    {
                        "username": "Ayush379",
                        "content": "I think that should give false, since ? means 1 character, but there are 2 needed. "
                    },
                    {
                        "username": "hzzyyy",
                        "content": "The highest voted solution is based on:\\nhttp://yucoding.blogspot.com/2013/02/leetcode-question-123-wildcard-matching.html\\n\\nIf it is not very obvious for you, I will try to explain the following two reasons why it works:\\n\\n**1. Greedy matching works, there is no need to backtrack more than once.** \\n\\nObviously, we need to use backtrack, but why Yu's solution didn't use a stack? The reason is, we only need to backtrack once to go back to the most recent '\\\\*'. Let me explain why. Given a string s and a pattern p, Consider the pattern string is divided into two substrings, p1 and p2, each of which starts with a '\\\\*'. With greedy matching, which is the case in Yu's solution, suppose p1 matches the *shortest head substring* of s, namely s1. Let's name its complement as s2, then we have s = s1 + s2 and p = p1+p2.\\n\\nThe statement is: \\n    *If p2 doesn't match s2 then p doesn't match s.* \\n\\nThe proof is the following:\\nIf s1 is the only head substring of s matching p1, then we don't have alternative matches for p1, then the only case is checked. \\nIf there is another head substring of s matching p1, namely s1' which must be longer than s1, then its complement, name s2' must be a tail substring of s2.  We know that p2 doesn't match s2, and p2 starts with '\\\\*', then we know p2 doesn't match any tail substring of s2, so p2 doesn't match s2' either.  To illustrate, consider:\\n\\n* p2 = \"*z\"\\n* s2 = \"abcd\"\\n\\np2 doesn't match s2, and p2 doesn't match any of \"bcd\", \"cd\", or \"d\". This is because in eyes of '\\\\*' \"abc\" \"bc\" \"c\" and \"\" are all the same. \\n\\n**2. C string all ends with a null char '\\\\0'.** \\nThis actually makes his problem easier to solve with C string, and if the inputs are std::string, the best way to do it is to use their c_str() to solve it. \\n\\nThe convenience is that when the pointer of pattern string p is at the end, pointing to '\\\\0', matching attempt with any char of string s (not including its end '\\\\0') will result in failure. This is equivalent to the following behavior:\\n   \\n*When characters in pattern string p are all matched but there are still characters remaining in string s, this matching attempt is a failure.*\\n\\nIf such logic is implemented in std::string, we need to use either the size of string or its end iterator."
                    }
                ]
            },
            {
                "id": 1571107,
                "content": [
                    {
                        "username": "Imory2020",
                        "content": "I've figured out what the difference is, but would like to raise a question here in case others might also wonder it in the future. For reference, [Regular Expression Matching][1].\\n\\n\\n  [1]: https://oj.leetcode.com/problems/regular-expression-matching/"
                    },
                    {
                        "username": "stridemann",
                        "content": "Yes, the solution from REM problem could be a bit fixed/simplified and will do this job.\nI did REM using backtracking using recursion (and it was working there), but in this problem I got a timeouts with this approach. \nWe will also get timeouts if we use Regex way (on C#) (some cases takes 3min to process).\nI'm sure the \"DP table\" should be used in both this problems. It will simplify code many times.\n\nUPD. Dp table did it job, but slow as hell :) (no timeouts)"
                    },
                    {
                        "username": "et169tkm",
                        "content": "[@pradeepsinghjaroliya](/pradeepsinghjaroliya) Sounds like we can translate the input in this question to a regular expression, then use the previous solution to match it...."
                    },
                    {
                        "username": "practice_90",
                        "content": "[@fengli738](/fengli738) * in regular expression matches zero or more previous character. Here * can match any character any number of times"
                    },
                    {
                        "username": "pradeepsinghjaroliya",
                        "content": "[@fengli738](/fengli738) \nIn that question \na* means it can be \"\" or \"a\" or \"aa\" or \"aa.....\". (i.e. Matches zero or more of the preceding element.)\na* cant be \"ab\" it can only have zero or more preceding element in this case will be 'a';\n' * ' is not independent character consider (a*) as together.\n In this case ,it is independent.\nExample: \"aa*\"\nin this question it can be- \"aa\",\"aaa\",\"aaa....a\",\"aab\",\"aabb\",\"aaba\"\nAnd in that question it can be-\n \"a\",\"aa\",\"aaa\",\"aaaa...aa\"\n(Notice in that question it can be \"a\" but here it can't be \"aa\" is the compulsary part.)\n(Hope it help, was confused in both , sorry for my bad wording)"
                    },
                    {
                        "username": "fengli738",
                        "content": "what is the difference between this problem and https://leetcode.com/problems/regular-expression-matching/description/"
                    },
                    {
                        "username": "ArpitDhamija",
                        "content": "So, I just gave my Tech Round in a startup, applied offcampus.\\n\\nI have not done this question earlier. So just imagine my situation\\n\\nInterviewer asked me this as the 2nd ques. 1st ques was also hard but I know the solution of that.\\n\\nIn this, I somehow able to get to the recurssive solution with some of the hints given by interviewer. Its hell difficult according to me to get to the optimal solution for this question in an interview if you haven\\'t done that earlier. \\nLike I get to the recurssive solution. And time got over. As in 1 hr, 2 hard questions were asked and I have to code that also. \\n\\nThats all about this. \\n\\n"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "[@nushk_23](/nushk_23) this was asked in adobe to someone I know"
                    },
                    {
                        "username": "nushk_23",
                        "content": "which company though?"
                    },
                    {
                        "username": "iZERWAS",
                        "content": "ah tough luck man"
                    },
                    {
                        "username": "zdi561",
                        "content": "\"aa\" \"a\" is false but \"abcabczzzde\", \"*abc???de*\" is true , they are contradictory"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "[@DarkMatter71](/DarkMatter71)  Indeed its false.. I think you are mistaken the pattern which is *abc???de*"
                    },
                    {
                        "username": "tanmaytaran",
                        "content": "\\'*\\' matches 0 or more characters but \\'?\\' matches exactly 1 character.\\nSo, for string \"aa\" and pattern \"a\", its false, which is correct. Now for string \"aa\" and any pattern like \"*\" || \"a*\" || \"*a\" || \"?*\" || \"*?\", etc. all are correct.\\n\\nNow if we look at string \"abcabczzzde\" with pattern \"abc???de\", \\n\\'abc\\' in pattern matches and leaves us with \"abczzzde\". Now 3 \\'?\\' need to match exactly 3 characters. So the next abc gets matched, hence we are now left with \"zzzde\" and in pattern \"de\". Thats why this is false."
                    },
                    {
                        "username": "DarkMatter71",
                        "content": "\"abcabczzzde\", \"abc???de\" is not true"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "this question having contradictory testcase.\n\"adceb\"   \"* a* b\" this is true why?\n\"a*c?b\"   \"acdcb\" then why tis is false?\n"
                    },
                    {
                        "username": "danielrrv",
                        "content": "[@Moonbeam8773](/Moonbeam8773) Doesn't make sense at all. \"The The first * must match an empty string\" There's no empty string at the beginning unless that the tester supposes it. Machines don't understand assumptions. The empty string is not there, then  it is not there. \nThe only way to pass this case in my opinion is assuming*(in software assumptions are risky) that the letters have priority over * because the * in first place makes the entire string fulfills the pattern."
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "\\* matches any character, including 0-length string. For \"\\*a\\*b\", the first \\* must match an empty string in order to have the \"a\" match up.  This leaves \"a\\*b\" to match \"adceb\". The first and last characters of the pattern and string match, so we remove them. This leaves the single \\* in the middle to match \"dce\", which it does. Therefore true.\n\n\"a\\*c?b\" start and end has to be \"a\" and \"b\" respectively. Which means we need to have \"\\*c?\" match \"cdc\". If the last \"?\" must match one character, that leaves \"\\*c\" to match \"cd\". Both last characters don't match, therefore it's false."
                    },
                    {
                        "username": "gargsaksham57",
                        "content": "could anybody explain why recursion+memoisation is giving tle"
                    },
                    {
                        "username": "raistar702614",
                        "content": "if you get a tle then most of the time this trick worls...declare the variable as unsigned int AND while passing the strings in the function pass them by reference.\\n\\nfor this qustion i tried memoization it passed 1774/1811\\n\\ni made the type as unsigned then it passed 1809/1811\\n\\ni passed the string by reference ...passed all cases with ahead of 85% in time and 15% in space "
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "I've written the Memoised version and it works.\nPlz check this - https://leetcode.com/problems/wildcard-matching/solutions/3230627/dp-memoization/?orderBy=most_votes"
                    },
                    {
                        "username": "user4523qT",
                        "content": "recursion is slow because of the nature of recursion. iterative solution is the fastest way"
                    },
                    {
                        "username": "c3lEsTIaL",
                        "content": "I can\\'t think about a greedy strategy that works here. Most solutions posted seemed like Brute Force or DP."
                    },
                    {
                        "username": "abhishek_kumar_12140040",
                        "content": "I am Trying t solve it by recursion + memorisation but on the last test case I am exceeding the memory limit. Is there any other method for this?"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "[@mahdichaben47](/mahdichaben47) pass the strings by reference"
                    },
                    {
                        "username": "mahdichaben47",
                        "content": "same problem they dont give me any test case but Memory Limit Exceeded"
                    },
                    {
                        "username": "sakshitiwari_01",
                        "content": "asked in Myanatomy in campus recruitment "
                    },
                    {
                        "username": "sevxin",
                        "content": "I submitted my code, and the result shows wrong when it applied on testcase:\"acdcb\", \"ac?b\". However, when I ran it in playground, I get the correct answer. What should I do? Could someone help me out?"
                    },
                    {
                        "username": "Okpatu",
                        "content": "C is not matched "
                    },
                    {
                        "username": "Ayush379",
                        "content": "I think that should give false, since ? means 1 character, but there are 2 needed. "
                    },
                    {
                        "username": "hzzyyy",
                        "content": "The highest voted solution is based on:\\nhttp://yucoding.blogspot.com/2013/02/leetcode-question-123-wildcard-matching.html\\n\\nIf it is not very obvious for you, I will try to explain the following two reasons why it works:\\n\\n**1. Greedy matching works, there is no need to backtrack more than once.** \\n\\nObviously, we need to use backtrack, but why Yu's solution didn't use a stack? The reason is, we only need to backtrack once to go back to the most recent '\\\\*'. Let me explain why. Given a string s and a pattern p, Consider the pattern string is divided into two substrings, p1 and p2, each of which starts with a '\\\\*'. With greedy matching, which is the case in Yu's solution, suppose p1 matches the *shortest head substring* of s, namely s1. Let's name its complement as s2, then we have s = s1 + s2 and p = p1+p2.\\n\\nThe statement is: \\n    *If p2 doesn't match s2 then p doesn't match s.* \\n\\nThe proof is the following:\\nIf s1 is the only head substring of s matching p1, then we don't have alternative matches for p1, then the only case is checked. \\nIf there is another head substring of s matching p1, namely s1' which must be longer than s1, then its complement, name s2' must be a tail substring of s2.  We know that p2 doesn't match s2, and p2 starts with '\\\\*', then we know p2 doesn't match any tail substring of s2, so p2 doesn't match s2' either.  To illustrate, consider:\\n\\n* p2 = \"*z\"\\n* s2 = \"abcd\"\\n\\np2 doesn't match s2, and p2 doesn't match any of \"bcd\", \"cd\", or \"d\". This is because in eyes of '\\\\*' \"abc\" \"bc\" \"c\" and \"\" are all the same. \\n\\n**2. C string all ends with a null char '\\\\0'.** \\nThis actually makes his problem easier to solve with C string, and if the inputs are std::string, the best way to do it is to use their c_str() to solve it. \\n\\nThe convenience is that when the pointer of pattern string p is at the end, pointing to '\\\\0', matching attempt with any char of string s (not including its end '\\\\0') will result in failure. This is equivalent to the following behavior:\\n   \\n*When characters in pattern string p are all matched but there are still characters remaining in string s, this matching attempt is a failure.*\\n\\nIf such logic is implemented in std::string, we need to use either the size of string or its end iterator."
                    }
                ]
            },
            {
                "id": 1564889,
                "content": [
                    {
                        "username": "Imory2020",
                        "content": "I've figured out what the difference is, but would like to raise a question here in case others might also wonder it in the future. For reference, [Regular Expression Matching][1].\\n\\n\\n  [1]: https://oj.leetcode.com/problems/regular-expression-matching/"
                    },
                    {
                        "username": "stridemann",
                        "content": "Yes, the solution from REM problem could be a bit fixed/simplified and will do this job.\nI did REM using backtracking using recursion (and it was working there), but in this problem I got a timeouts with this approach. \nWe will also get timeouts if we use Regex way (on C#) (some cases takes 3min to process).\nI'm sure the \"DP table\" should be used in both this problems. It will simplify code many times.\n\nUPD. Dp table did it job, but slow as hell :) (no timeouts)"
                    },
                    {
                        "username": "et169tkm",
                        "content": "[@pradeepsinghjaroliya](/pradeepsinghjaroliya) Sounds like we can translate the input in this question to a regular expression, then use the previous solution to match it...."
                    },
                    {
                        "username": "practice_90",
                        "content": "[@fengli738](/fengli738) * in regular expression matches zero or more previous character. Here * can match any character any number of times"
                    },
                    {
                        "username": "pradeepsinghjaroliya",
                        "content": "[@fengli738](/fengli738) \nIn that question \na* means it can be \"\" or \"a\" or \"aa\" or \"aa.....\". (i.e. Matches zero or more of the preceding element.)\na* cant be \"ab\" it can only have zero or more preceding element in this case will be 'a';\n' * ' is not independent character consider (a*) as together.\n In this case ,it is independent.\nExample: \"aa*\"\nin this question it can be- \"aa\",\"aaa\",\"aaa....a\",\"aab\",\"aabb\",\"aaba\"\nAnd in that question it can be-\n \"a\",\"aa\",\"aaa\",\"aaaa...aa\"\n(Notice in that question it can be \"a\" but here it can't be \"aa\" is the compulsary part.)\n(Hope it help, was confused in both , sorry for my bad wording)"
                    },
                    {
                        "username": "fengli738",
                        "content": "what is the difference between this problem and https://leetcode.com/problems/regular-expression-matching/description/"
                    },
                    {
                        "username": "ArpitDhamija",
                        "content": "So, I just gave my Tech Round in a startup, applied offcampus.\\n\\nI have not done this question earlier. So just imagine my situation\\n\\nInterviewer asked me this as the 2nd ques. 1st ques was also hard but I know the solution of that.\\n\\nIn this, I somehow able to get to the recurssive solution with some of the hints given by interviewer. Its hell difficult according to me to get to the optimal solution for this question in an interview if you haven\\'t done that earlier. \\nLike I get to the recurssive solution. And time got over. As in 1 hr, 2 hard questions were asked and I have to code that also. \\n\\nThats all about this. \\n\\n"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "[@nushk_23](/nushk_23) this was asked in adobe to someone I know"
                    },
                    {
                        "username": "nushk_23",
                        "content": "which company though?"
                    },
                    {
                        "username": "iZERWAS",
                        "content": "ah tough luck man"
                    },
                    {
                        "username": "zdi561",
                        "content": "\"aa\" \"a\" is false but \"abcabczzzde\", \"*abc???de*\" is true , they are contradictory"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "[@DarkMatter71](/DarkMatter71)  Indeed its false.. I think you are mistaken the pattern which is *abc???de*"
                    },
                    {
                        "username": "tanmaytaran",
                        "content": "\\'*\\' matches 0 or more characters but \\'?\\' matches exactly 1 character.\\nSo, for string \"aa\" and pattern \"a\", its false, which is correct. Now for string \"aa\" and any pattern like \"*\" || \"a*\" || \"*a\" || \"?*\" || \"*?\", etc. all are correct.\\n\\nNow if we look at string \"abcabczzzde\" with pattern \"abc???de\", \\n\\'abc\\' in pattern matches and leaves us with \"abczzzde\". Now 3 \\'?\\' need to match exactly 3 characters. So the next abc gets matched, hence we are now left with \"zzzde\" and in pattern \"de\". Thats why this is false."
                    },
                    {
                        "username": "DarkMatter71",
                        "content": "\"abcabczzzde\", \"abc???de\" is not true"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "this question having contradictory testcase.\n\"adceb\"   \"* a* b\" this is true why?\n\"a*c?b\"   \"acdcb\" then why tis is false?\n"
                    },
                    {
                        "username": "danielrrv",
                        "content": "[@Moonbeam8773](/Moonbeam8773) Doesn't make sense at all. \"The The first * must match an empty string\" There's no empty string at the beginning unless that the tester supposes it. Machines don't understand assumptions. The empty string is not there, then  it is not there. \nThe only way to pass this case in my opinion is assuming*(in software assumptions are risky) that the letters have priority over * because the * in first place makes the entire string fulfills the pattern."
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "\\* matches any character, including 0-length string. For \"\\*a\\*b\", the first \\* must match an empty string in order to have the \"a\" match up.  This leaves \"a\\*b\" to match \"adceb\". The first and last characters of the pattern and string match, so we remove them. This leaves the single \\* in the middle to match \"dce\", which it does. Therefore true.\n\n\"a\\*c?b\" start and end has to be \"a\" and \"b\" respectively. Which means we need to have \"\\*c?\" match \"cdc\". If the last \"?\" must match one character, that leaves \"\\*c\" to match \"cd\". Both last characters don't match, therefore it's false."
                    },
                    {
                        "username": "gargsaksham57",
                        "content": "could anybody explain why recursion+memoisation is giving tle"
                    },
                    {
                        "username": "raistar702614",
                        "content": "if you get a tle then most of the time this trick worls...declare the variable as unsigned int AND while passing the strings in the function pass them by reference.\\n\\nfor this qustion i tried memoization it passed 1774/1811\\n\\ni made the type as unsigned then it passed 1809/1811\\n\\ni passed the string by reference ...passed all cases with ahead of 85% in time and 15% in space "
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "I've written the Memoised version and it works.\nPlz check this - https://leetcode.com/problems/wildcard-matching/solutions/3230627/dp-memoization/?orderBy=most_votes"
                    },
                    {
                        "username": "user4523qT",
                        "content": "recursion is slow because of the nature of recursion. iterative solution is the fastest way"
                    },
                    {
                        "username": "c3lEsTIaL",
                        "content": "I can\\'t think about a greedy strategy that works here. Most solutions posted seemed like Brute Force or DP."
                    },
                    {
                        "username": "abhishek_kumar_12140040",
                        "content": "I am Trying t solve it by recursion + memorisation but on the last test case I am exceeding the memory limit. Is there any other method for this?"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "[@mahdichaben47](/mahdichaben47) pass the strings by reference"
                    },
                    {
                        "username": "mahdichaben47",
                        "content": "same problem they dont give me any test case but Memory Limit Exceeded"
                    },
                    {
                        "username": "sakshitiwari_01",
                        "content": "asked in Myanatomy in campus recruitment "
                    },
                    {
                        "username": "sevxin",
                        "content": "I submitted my code, and the result shows wrong when it applied on testcase:\"acdcb\", \"ac?b\". However, when I ran it in playground, I get the correct answer. What should I do? Could someone help me out?"
                    },
                    {
                        "username": "Okpatu",
                        "content": "C is not matched "
                    },
                    {
                        "username": "Ayush379",
                        "content": "I think that should give false, since ? means 1 character, but there are 2 needed. "
                    },
                    {
                        "username": "hzzyyy",
                        "content": "The highest voted solution is based on:\\nhttp://yucoding.blogspot.com/2013/02/leetcode-question-123-wildcard-matching.html\\n\\nIf it is not very obvious for you, I will try to explain the following two reasons why it works:\\n\\n**1. Greedy matching works, there is no need to backtrack more than once.** \\n\\nObviously, we need to use backtrack, but why Yu's solution didn't use a stack? The reason is, we only need to backtrack once to go back to the most recent '\\\\*'. Let me explain why. Given a string s and a pattern p, Consider the pattern string is divided into two substrings, p1 and p2, each of which starts with a '\\\\*'. With greedy matching, which is the case in Yu's solution, suppose p1 matches the *shortest head substring* of s, namely s1. Let's name its complement as s2, then we have s = s1 + s2 and p = p1+p2.\\n\\nThe statement is: \\n    *If p2 doesn't match s2 then p doesn't match s.* \\n\\nThe proof is the following:\\nIf s1 is the only head substring of s matching p1, then we don't have alternative matches for p1, then the only case is checked. \\nIf there is another head substring of s matching p1, namely s1' which must be longer than s1, then its complement, name s2' must be a tail substring of s2.  We know that p2 doesn't match s2, and p2 starts with '\\\\*', then we know p2 doesn't match any tail substring of s2, so p2 doesn't match s2' either.  To illustrate, consider:\\n\\n* p2 = \"*z\"\\n* s2 = \"abcd\"\\n\\np2 doesn't match s2, and p2 doesn't match any of \"bcd\", \"cd\", or \"d\". This is because in eyes of '\\\\*' \"abc\" \"bc\" \"c\" and \"\" are all the same. \\n\\n**2. C string all ends with a null char '\\\\0'.** \\nThis actually makes his problem easier to solve with C string, and if the inputs are std::string, the best way to do it is to use their c_str() to solve it. \\n\\nThe convenience is that when the pointer of pattern string p is at the end, pointing to '\\\\0', matching attempt with any char of string s (not including its end '\\\\0') will result in failure. This is equivalent to the following behavior:\\n   \\n*When characters in pattern string p are all matched but there are still characters remaining in string s, this matching attempt is a failure.*\\n\\nIf such logic is implemented in std::string, we need to use either the size of string or its end iterator."
                    }
                ]
            },
            {
                "id": 1566677,
                "content": [
                    {
                        "username": "Imory2020",
                        "content": "I've figured out what the difference is, but would like to raise a question here in case others might also wonder it in the future. For reference, [Regular Expression Matching][1].\\n\\n\\n  [1]: https://oj.leetcode.com/problems/regular-expression-matching/"
                    },
                    {
                        "username": "stridemann",
                        "content": "Yes, the solution from REM problem could be a bit fixed/simplified and will do this job.\nI did REM using backtracking using recursion (and it was working there), but in this problem I got a timeouts with this approach. \nWe will also get timeouts if we use Regex way (on C#) (some cases takes 3min to process).\nI'm sure the \"DP table\" should be used in both this problems. It will simplify code many times.\n\nUPD. Dp table did it job, but slow as hell :) (no timeouts)"
                    },
                    {
                        "username": "et169tkm",
                        "content": "[@pradeepsinghjaroliya](/pradeepsinghjaroliya) Sounds like we can translate the input in this question to a regular expression, then use the previous solution to match it...."
                    },
                    {
                        "username": "practice_90",
                        "content": "[@fengli738](/fengli738) * in regular expression matches zero or more previous character. Here * can match any character any number of times"
                    },
                    {
                        "username": "pradeepsinghjaroliya",
                        "content": "[@fengli738](/fengli738) \nIn that question \na* means it can be \"\" or \"a\" or \"aa\" or \"aa.....\". (i.e. Matches zero or more of the preceding element.)\na* cant be \"ab\" it can only have zero or more preceding element in this case will be 'a';\n' * ' is not independent character consider (a*) as together.\n In this case ,it is independent.\nExample: \"aa*\"\nin this question it can be- \"aa\",\"aaa\",\"aaa....a\",\"aab\",\"aabb\",\"aaba\"\nAnd in that question it can be-\n \"a\",\"aa\",\"aaa\",\"aaaa...aa\"\n(Notice in that question it can be \"a\" but here it can't be \"aa\" is the compulsary part.)\n(Hope it help, was confused in both , sorry for my bad wording)"
                    },
                    {
                        "username": "fengli738",
                        "content": "what is the difference between this problem and https://leetcode.com/problems/regular-expression-matching/description/"
                    },
                    {
                        "username": "ArpitDhamija",
                        "content": "So, I just gave my Tech Round in a startup, applied offcampus.\\n\\nI have not done this question earlier. So just imagine my situation\\n\\nInterviewer asked me this as the 2nd ques. 1st ques was also hard but I know the solution of that.\\n\\nIn this, I somehow able to get to the recurssive solution with some of the hints given by interviewer. Its hell difficult according to me to get to the optimal solution for this question in an interview if you haven\\'t done that earlier. \\nLike I get to the recurssive solution. And time got over. As in 1 hr, 2 hard questions were asked and I have to code that also. \\n\\nThats all about this. \\n\\n"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "[@nushk_23](/nushk_23) this was asked in adobe to someone I know"
                    },
                    {
                        "username": "nushk_23",
                        "content": "which company though?"
                    },
                    {
                        "username": "iZERWAS",
                        "content": "ah tough luck man"
                    },
                    {
                        "username": "zdi561",
                        "content": "\"aa\" \"a\" is false but \"abcabczzzde\", \"*abc???de*\" is true , they are contradictory"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "[@DarkMatter71](/DarkMatter71)  Indeed its false.. I think you are mistaken the pattern which is *abc???de*"
                    },
                    {
                        "username": "tanmaytaran",
                        "content": "\\'*\\' matches 0 or more characters but \\'?\\' matches exactly 1 character.\\nSo, for string \"aa\" and pattern \"a\", its false, which is correct. Now for string \"aa\" and any pattern like \"*\" || \"a*\" || \"*a\" || \"?*\" || \"*?\", etc. all are correct.\\n\\nNow if we look at string \"abcabczzzde\" with pattern \"abc???de\", \\n\\'abc\\' in pattern matches and leaves us with \"abczzzde\". Now 3 \\'?\\' need to match exactly 3 characters. So the next abc gets matched, hence we are now left with \"zzzde\" and in pattern \"de\". Thats why this is false."
                    },
                    {
                        "username": "DarkMatter71",
                        "content": "\"abcabczzzde\", \"abc???de\" is not true"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "this question having contradictory testcase.\n\"adceb\"   \"* a* b\" this is true why?\n\"a*c?b\"   \"acdcb\" then why tis is false?\n"
                    },
                    {
                        "username": "danielrrv",
                        "content": "[@Moonbeam8773](/Moonbeam8773) Doesn't make sense at all. \"The The first * must match an empty string\" There's no empty string at the beginning unless that the tester supposes it. Machines don't understand assumptions. The empty string is not there, then  it is not there. \nThe only way to pass this case in my opinion is assuming*(in software assumptions are risky) that the letters have priority over * because the * in first place makes the entire string fulfills the pattern."
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "\\* matches any character, including 0-length string. For \"\\*a\\*b\", the first \\* must match an empty string in order to have the \"a\" match up.  This leaves \"a\\*b\" to match \"adceb\". The first and last characters of the pattern and string match, so we remove them. This leaves the single \\* in the middle to match \"dce\", which it does. Therefore true.\n\n\"a\\*c?b\" start and end has to be \"a\" and \"b\" respectively. Which means we need to have \"\\*c?\" match \"cdc\". If the last \"?\" must match one character, that leaves \"\\*c\" to match \"cd\". Both last characters don't match, therefore it's false."
                    },
                    {
                        "username": "gargsaksham57",
                        "content": "could anybody explain why recursion+memoisation is giving tle"
                    },
                    {
                        "username": "raistar702614",
                        "content": "if you get a tle then most of the time this trick worls...declare the variable as unsigned int AND while passing the strings in the function pass them by reference.\\n\\nfor this qustion i tried memoization it passed 1774/1811\\n\\ni made the type as unsigned then it passed 1809/1811\\n\\ni passed the string by reference ...passed all cases with ahead of 85% in time and 15% in space "
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "I've written the Memoised version and it works.\nPlz check this - https://leetcode.com/problems/wildcard-matching/solutions/3230627/dp-memoization/?orderBy=most_votes"
                    },
                    {
                        "username": "user4523qT",
                        "content": "recursion is slow because of the nature of recursion. iterative solution is the fastest way"
                    },
                    {
                        "username": "c3lEsTIaL",
                        "content": "I can\\'t think about a greedy strategy that works here. Most solutions posted seemed like Brute Force or DP."
                    },
                    {
                        "username": "abhishek_kumar_12140040",
                        "content": "I am Trying t solve it by recursion + memorisation but on the last test case I am exceeding the memory limit. Is there any other method for this?"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "[@mahdichaben47](/mahdichaben47) pass the strings by reference"
                    },
                    {
                        "username": "mahdichaben47",
                        "content": "same problem they dont give me any test case but Memory Limit Exceeded"
                    },
                    {
                        "username": "sakshitiwari_01",
                        "content": "asked in Myanatomy in campus recruitment "
                    },
                    {
                        "username": "sevxin",
                        "content": "I submitted my code, and the result shows wrong when it applied on testcase:\"acdcb\", \"ac?b\". However, when I ran it in playground, I get the correct answer. What should I do? Could someone help me out?"
                    },
                    {
                        "username": "Okpatu",
                        "content": "C is not matched "
                    },
                    {
                        "username": "Ayush379",
                        "content": "I think that should give false, since ? means 1 character, but there are 2 needed. "
                    },
                    {
                        "username": "hzzyyy",
                        "content": "The highest voted solution is based on:\\nhttp://yucoding.blogspot.com/2013/02/leetcode-question-123-wildcard-matching.html\\n\\nIf it is not very obvious for you, I will try to explain the following two reasons why it works:\\n\\n**1. Greedy matching works, there is no need to backtrack more than once.** \\n\\nObviously, we need to use backtrack, but why Yu's solution didn't use a stack? The reason is, we only need to backtrack once to go back to the most recent '\\\\*'. Let me explain why. Given a string s and a pattern p, Consider the pattern string is divided into two substrings, p1 and p2, each of which starts with a '\\\\*'. With greedy matching, which is the case in Yu's solution, suppose p1 matches the *shortest head substring* of s, namely s1. Let's name its complement as s2, then we have s = s1 + s2 and p = p1+p2.\\n\\nThe statement is: \\n    *If p2 doesn't match s2 then p doesn't match s.* \\n\\nThe proof is the following:\\nIf s1 is the only head substring of s matching p1, then we don't have alternative matches for p1, then the only case is checked. \\nIf there is another head substring of s matching p1, namely s1' which must be longer than s1, then its complement, name s2' must be a tail substring of s2.  We know that p2 doesn't match s2, and p2 starts with '\\\\*', then we know p2 doesn't match any tail substring of s2, so p2 doesn't match s2' either.  To illustrate, consider:\\n\\n* p2 = \"*z\"\\n* s2 = \"abcd\"\\n\\np2 doesn't match s2, and p2 doesn't match any of \"bcd\", \"cd\", or \"d\". This is because in eyes of '\\\\*' \"abc\" \"bc\" \"c\" and \"\" are all the same. \\n\\n**2. C string all ends with a null char '\\\\0'.** \\nThis actually makes his problem easier to solve with C string, and if the inputs are std::string, the best way to do it is to use their c_str() to solve it. \\n\\nThe convenience is that when the pointer of pattern string p is at the end, pointing to '\\\\0', matching attempt with any char of string s (not including its end '\\\\0') will result in failure. This is equivalent to the following behavior:\\n   \\n*When characters in pattern string p are all matched but there are still characters remaining in string s, this matching attempt is a failure.*\\n\\nIf such logic is implemented in std::string, we need to use either the size of string or its end iterator."
                    }
                ]
            },
            {
                "id": 1570522,
                "content": [
                    {
                        "username": "Imory2020",
                        "content": "I've figured out what the difference is, but would like to raise a question here in case others might also wonder it in the future. For reference, [Regular Expression Matching][1].\\n\\n\\n  [1]: https://oj.leetcode.com/problems/regular-expression-matching/"
                    },
                    {
                        "username": "stridemann",
                        "content": "Yes, the solution from REM problem could be a bit fixed/simplified and will do this job.\nI did REM using backtracking using recursion (and it was working there), but in this problem I got a timeouts with this approach. \nWe will also get timeouts if we use Regex way (on C#) (some cases takes 3min to process).\nI'm sure the \"DP table\" should be used in both this problems. It will simplify code many times.\n\nUPD. Dp table did it job, but slow as hell :) (no timeouts)"
                    },
                    {
                        "username": "et169tkm",
                        "content": "[@pradeepsinghjaroliya](/pradeepsinghjaroliya) Sounds like we can translate the input in this question to a regular expression, then use the previous solution to match it...."
                    },
                    {
                        "username": "practice_90",
                        "content": "[@fengli738](/fengli738) * in regular expression matches zero or more previous character. Here * can match any character any number of times"
                    },
                    {
                        "username": "pradeepsinghjaroliya",
                        "content": "[@fengli738](/fengli738) \nIn that question \na* means it can be \"\" or \"a\" or \"aa\" or \"aa.....\". (i.e. Matches zero or more of the preceding element.)\na* cant be \"ab\" it can only have zero or more preceding element in this case will be 'a';\n' * ' is not independent character consider (a*) as together.\n In this case ,it is independent.\nExample: \"aa*\"\nin this question it can be- \"aa\",\"aaa\",\"aaa....a\",\"aab\",\"aabb\",\"aaba\"\nAnd in that question it can be-\n \"a\",\"aa\",\"aaa\",\"aaaa...aa\"\n(Notice in that question it can be \"a\" but here it can't be \"aa\" is the compulsary part.)\n(Hope it help, was confused in both , sorry for my bad wording)"
                    },
                    {
                        "username": "fengli738",
                        "content": "what is the difference between this problem and https://leetcode.com/problems/regular-expression-matching/description/"
                    },
                    {
                        "username": "ArpitDhamija",
                        "content": "So, I just gave my Tech Round in a startup, applied offcampus.\\n\\nI have not done this question earlier. So just imagine my situation\\n\\nInterviewer asked me this as the 2nd ques. 1st ques was also hard but I know the solution of that.\\n\\nIn this, I somehow able to get to the recurssive solution with some of the hints given by interviewer. Its hell difficult according to me to get to the optimal solution for this question in an interview if you haven\\'t done that earlier. \\nLike I get to the recurssive solution. And time got over. As in 1 hr, 2 hard questions were asked and I have to code that also. \\n\\nThats all about this. \\n\\n"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "[@nushk_23](/nushk_23) this was asked in adobe to someone I know"
                    },
                    {
                        "username": "nushk_23",
                        "content": "which company though?"
                    },
                    {
                        "username": "iZERWAS",
                        "content": "ah tough luck man"
                    },
                    {
                        "username": "zdi561",
                        "content": "\"aa\" \"a\" is false but \"abcabczzzde\", \"*abc???de*\" is true , they are contradictory"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "[@DarkMatter71](/DarkMatter71)  Indeed its false.. I think you are mistaken the pattern which is *abc???de*"
                    },
                    {
                        "username": "tanmaytaran",
                        "content": "\\'*\\' matches 0 or more characters but \\'?\\' matches exactly 1 character.\\nSo, for string \"aa\" and pattern \"a\", its false, which is correct. Now for string \"aa\" and any pattern like \"*\" || \"a*\" || \"*a\" || \"?*\" || \"*?\", etc. all are correct.\\n\\nNow if we look at string \"abcabczzzde\" with pattern \"abc???de\", \\n\\'abc\\' in pattern matches and leaves us with \"abczzzde\". Now 3 \\'?\\' need to match exactly 3 characters. So the next abc gets matched, hence we are now left with \"zzzde\" and in pattern \"de\". Thats why this is false."
                    },
                    {
                        "username": "DarkMatter71",
                        "content": "\"abcabczzzde\", \"abc???de\" is not true"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "this question having contradictory testcase.\n\"adceb\"   \"* a* b\" this is true why?\n\"a*c?b\"   \"acdcb\" then why tis is false?\n"
                    },
                    {
                        "username": "danielrrv",
                        "content": "[@Moonbeam8773](/Moonbeam8773) Doesn't make sense at all. \"The The first * must match an empty string\" There's no empty string at the beginning unless that the tester supposes it. Machines don't understand assumptions. The empty string is not there, then  it is not there. \nThe only way to pass this case in my opinion is assuming*(in software assumptions are risky) that the letters have priority over * because the * in first place makes the entire string fulfills the pattern."
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "\\* matches any character, including 0-length string. For \"\\*a\\*b\", the first \\* must match an empty string in order to have the \"a\" match up.  This leaves \"a\\*b\" to match \"adceb\". The first and last characters of the pattern and string match, so we remove them. This leaves the single \\* in the middle to match \"dce\", which it does. Therefore true.\n\n\"a\\*c?b\" start and end has to be \"a\" and \"b\" respectively. Which means we need to have \"\\*c?\" match \"cdc\". If the last \"?\" must match one character, that leaves \"\\*c\" to match \"cd\". Both last characters don't match, therefore it's false."
                    },
                    {
                        "username": "gargsaksham57",
                        "content": "could anybody explain why recursion+memoisation is giving tle"
                    },
                    {
                        "username": "raistar702614",
                        "content": "if you get a tle then most of the time this trick worls...declare the variable as unsigned int AND while passing the strings in the function pass them by reference.\\n\\nfor this qustion i tried memoization it passed 1774/1811\\n\\ni made the type as unsigned then it passed 1809/1811\\n\\ni passed the string by reference ...passed all cases with ahead of 85% in time and 15% in space "
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "I've written the Memoised version and it works.\nPlz check this - https://leetcode.com/problems/wildcard-matching/solutions/3230627/dp-memoization/?orderBy=most_votes"
                    },
                    {
                        "username": "user4523qT",
                        "content": "recursion is slow because of the nature of recursion. iterative solution is the fastest way"
                    },
                    {
                        "username": "c3lEsTIaL",
                        "content": "I can\\'t think about a greedy strategy that works here. Most solutions posted seemed like Brute Force or DP."
                    },
                    {
                        "username": "abhishek_kumar_12140040",
                        "content": "I am Trying t solve it by recursion + memorisation but on the last test case I am exceeding the memory limit. Is there any other method for this?"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "[@mahdichaben47](/mahdichaben47) pass the strings by reference"
                    },
                    {
                        "username": "mahdichaben47",
                        "content": "same problem they dont give me any test case but Memory Limit Exceeded"
                    },
                    {
                        "username": "sakshitiwari_01",
                        "content": "asked in Myanatomy in campus recruitment "
                    },
                    {
                        "username": "sevxin",
                        "content": "I submitted my code, and the result shows wrong when it applied on testcase:\"acdcb\", \"ac?b\". However, when I ran it in playground, I get the correct answer. What should I do? Could someone help me out?"
                    },
                    {
                        "username": "Okpatu",
                        "content": "C is not matched "
                    },
                    {
                        "username": "Ayush379",
                        "content": "I think that should give false, since ? means 1 character, but there are 2 needed. "
                    },
                    {
                        "username": "hzzyyy",
                        "content": "The highest voted solution is based on:\\nhttp://yucoding.blogspot.com/2013/02/leetcode-question-123-wildcard-matching.html\\n\\nIf it is not very obvious for you, I will try to explain the following two reasons why it works:\\n\\n**1. Greedy matching works, there is no need to backtrack more than once.** \\n\\nObviously, we need to use backtrack, but why Yu's solution didn't use a stack? The reason is, we only need to backtrack once to go back to the most recent '\\\\*'. Let me explain why. Given a string s and a pattern p, Consider the pattern string is divided into two substrings, p1 and p2, each of which starts with a '\\\\*'. With greedy matching, which is the case in Yu's solution, suppose p1 matches the *shortest head substring* of s, namely s1. Let's name its complement as s2, then we have s = s1 + s2 and p = p1+p2.\\n\\nThe statement is: \\n    *If p2 doesn't match s2 then p doesn't match s.* \\n\\nThe proof is the following:\\nIf s1 is the only head substring of s matching p1, then we don't have alternative matches for p1, then the only case is checked. \\nIf there is another head substring of s matching p1, namely s1' which must be longer than s1, then its complement, name s2' must be a tail substring of s2.  We know that p2 doesn't match s2, and p2 starts with '\\\\*', then we know p2 doesn't match any tail substring of s2, so p2 doesn't match s2' either.  To illustrate, consider:\\n\\n* p2 = \"*z\"\\n* s2 = \"abcd\"\\n\\np2 doesn't match s2, and p2 doesn't match any of \"bcd\", \"cd\", or \"d\". This is because in eyes of '\\\\*' \"abc\" \"bc\" \"c\" and \"\" are all the same. \\n\\n**2. C string all ends with a null char '\\\\0'.** \\nThis actually makes his problem easier to solve with C string, and if the inputs are std::string, the best way to do it is to use their c_str() to solve it. \\n\\nThe convenience is that when the pointer of pattern string p is at the end, pointing to '\\\\0', matching attempt with any char of string s (not including its end '\\\\0') will result in failure. This is equivalent to the following behavior:\\n   \\n*When characters in pattern string p are all matched but there are still characters remaining in string s, this matching attempt is a failure.*\\n\\nIf such logic is implemented in std::string, we need to use either the size of string or its end iterator."
                    }
                ]
            },
            {
                "id": 1723420,
                "content": [
                    {
                        "username": "Imory2020",
                        "content": "I've figured out what the difference is, but would like to raise a question here in case others might also wonder it in the future. For reference, [Regular Expression Matching][1].\\n\\n\\n  [1]: https://oj.leetcode.com/problems/regular-expression-matching/"
                    },
                    {
                        "username": "stridemann",
                        "content": "Yes, the solution from REM problem could be a bit fixed/simplified and will do this job.\nI did REM using backtracking using recursion (and it was working there), but in this problem I got a timeouts with this approach. \nWe will also get timeouts if we use Regex way (on C#) (some cases takes 3min to process).\nI'm sure the \"DP table\" should be used in both this problems. It will simplify code many times.\n\nUPD. Dp table did it job, but slow as hell :) (no timeouts)"
                    },
                    {
                        "username": "et169tkm",
                        "content": "[@pradeepsinghjaroliya](/pradeepsinghjaroliya) Sounds like we can translate the input in this question to a regular expression, then use the previous solution to match it...."
                    },
                    {
                        "username": "practice_90",
                        "content": "[@fengli738](/fengli738) * in regular expression matches zero or more previous character. Here * can match any character any number of times"
                    },
                    {
                        "username": "pradeepsinghjaroliya",
                        "content": "[@fengli738](/fengli738) \nIn that question \na* means it can be \"\" or \"a\" or \"aa\" or \"aa.....\". (i.e. Matches zero or more of the preceding element.)\na* cant be \"ab\" it can only have zero or more preceding element in this case will be 'a';\n' * ' is not independent character consider (a*) as together.\n In this case ,it is independent.\nExample: \"aa*\"\nin this question it can be- \"aa\",\"aaa\",\"aaa....a\",\"aab\",\"aabb\",\"aaba\"\nAnd in that question it can be-\n \"a\",\"aa\",\"aaa\",\"aaaa...aa\"\n(Notice in that question it can be \"a\" but here it can't be \"aa\" is the compulsary part.)\n(Hope it help, was confused in both , sorry for my bad wording)"
                    },
                    {
                        "username": "fengli738",
                        "content": "what is the difference between this problem and https://leetcode.com/problems/regular-expression-matching/description/"
                    },
                    {
                        "username": "ArpitDhamija",
                        "content": "So, I just gave my Tech Round in a startup, applied offcampus.\\n\\nI have not done this question earlier. So just imagine my situation\\n\\nInterviewer asked me this as the 2nd ques. 1st ques was also hard but I know the solution of that.\\n\\nIn this, I somehow able to get to the recurssive solution with some of the hints given by interviewer. Its hell difficult according to me to get to the optimal solution for this question in an interview if you haven\\'t done that earlier. \\nLike I get to the recurssive solution. And time got over. As in 1 hr, 2 hard questions were asked and I have to code that also. \\n\\nThats all about this. \\n\\n"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "[@nushk_23](/nushk_23) this was asked in adobe to someone I know"
                    },
                    {
                        "username": "nushk_23",
                        "content": "which company though?"
                    },
                    {
                        "username": "iZERWAS",
                        "content": "ah tough luck man"
                    },
                    {
                        "username": "zdi561",
                        "content": "\"aa\" \"a\" is false but \"abcabczzzde\", \"*abc???de*\" is true , they are contradictory"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "[@DarkMatter71](/DarkMatter71)  Indeed its false.. I think you are mistaken the pattern which is *abc???de*"
                    },
                    {
                        "username": "tanmaytaran",
                        "content": "\\'*\\' matches 0 or more characters but \\'?\\' matches exactly 1 character.\\nSo, for string \"aa\" and pattern \"a\", its false, which is correct. Now for string \"aa\" and any pattern like \"*\" || \"a*\" || \"*a\" || \"?*\" || \"*?\", etc. all are correct.\\n\\nNow if we look at string \"abcabczzzde\" with pattern \"abc???de\", \\n\\'abc\\' in pattern matches and leaves us with \"abczzzde\". Now 3 \\'?\\' need to match exactly 3 characters. So the next abc gets matched, hence we are now left with \"zzzde\" and in pattern \"de\". Thats why this is false."
                    },
                    {
                        "username": "DarkMatter71",
                        "content": "\"abcabczzzde\", \"abc???de\" is not true"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "this question having contradictory testcase.\n\"adceb\"   \"* a* b\" this is true why?\n\"a*c?b\"   \"acdcb\" then why tis is false?\n"
                    },
                    {
                        "username": "danielrrv",
                        "content": "[@Moonbeam8773](/Moonbeam8773) Doesn't make sense at all. \"The The first * must match an empty string\" There's no empty string at the beginning unless that the tester supposes it. Machines don't understand assumptions. The empty string is not there, then  it is not there. \nThe only way to pass this case in my opinion is assuming*(in software assumptions are risky) that the letters have priority over * because the * in first place makes the entire string fulfills the pattern."
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "\\* matches any character, including 0-length string. For \"\\*a\\*b\", the first \\* must match an empty string in order to have the \"a\" match up.  This leaves \"a\\*b\" to match \"adceb\". The first and last characters of the pattern and string match, so we remove them. This leaves the single \\* in the middle to match \"dce\", which it does. Therefore true.\n\n\"a\\*c?b\" start and end has to be \"a\" and \"b\" respectively. Which means we need to have \"\\*c?\" match \"cdc\". If the last \"?\" must match one character, that leaves \"\\*c\" to match \"cd\". Both last characters don't match, therefore it's false."
                    },
                    {
                        "username": "gargsaksham57",
                        "content": "could anybody explain why recursion+memoisation is giving tle"
                    },
                    {
                        "username": "raistar702614",
                        "content": "if you get a tle then most of the time this trick worls...declare the variable as unsigned int AND while passing the strings in the function pass them by reference.\\n\\nfor this qustion i tried memoization it passed 1774/1811\\n\\ni made the type as unsigned then it passed 1809/1811\\n\\ni passed the string by reference ...passed all cases with ahead of 85% in time and 15% in space "
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "I've written the Memoised version and it works.\nPlz check this - https://leetcode.com/problems/wildcard-matching/solutions/3230627/dp-memoization/?orderBy=most_votes"
                    },
                    {
                        "username": "user4523qT",
                        "content": "recursion is slow because of the nature of recursion. iterative solution is the fastest way"
                    },
                    {
                        "username": "c3lEsTIaL",
                        "content": "I can\\'t think about a greedy strategy that works here. Most solutions posted seemed like Brute Force or DP."
                    },
                    {
                        "username": "abhishek_kumar_12140040",
                        "content": "I am Trying t solve it by recursion + memorisation but on the last test case I am exceeding the memory limit. Is there any other method for this?"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "[@mahdichaben47](/mahdichaben47) pass the strings by reference"
                    },
                    {
                        "username": "mahdichaben47",
                        "content": "same problem they dont give me any test case but Memory Limit Exceeded"
                    },
                    {
                        "username": "sakshitiwari_01",
                        "content": "asked in Myanatomy in campus recruitment "
                    },
                    {
                        "username": "sevxin",
                        "content": "I submitted my code, and the result shows wrong when it applied on testcase:\"acdcb\", \"ac?b\". However, when I ran it in playground, I get the correct answer. What should I do? Could someone help me out?"
                    },
                    {
                        "username": "Okpatu",
                        "content": "C is not matched "
                    },
                    {
                        "username": "Ayush379",
                        "content": "I think that should give false, since ? means 1 character, but there are 2 needed. "
                    },
                    {
                        "username": "hzzyyy",
                        "content": "The highest voted solution is based on:\\nhttp://yucoding.blogspot.com/2013/02/leetcode-question-123-wildcard-matching.html\\n\\nIf it is not very obvious for you, I will try to explain the following two reasons why it works:\\n\\n**1. Greedy matching works, there is no need to backtrack more than once.** \\n\\nObviously, we need to use backtrack, but why Yu's solution didn't use a stack? The reason is, we only need to backtrack once to go back to the most recent '\\\\*'. Let me explain why. Given a string s and a pattern p, Consider the pattern string is divided into two substrings, p1 and p2, each of which starts with a '\\\\*'. With greedy matching, which is the case in Yu's solution, suppose p1 matches the *shortest head substring* of s, namely s1. Let's name its complement as s2, then we have s = s1 + s2 and p = p1+p2.\\n\\nThe statement is: \\n    *If p2 doesn't match s2 then p doesn't match s.* \\n\\nThe proof is the following:\\nIf s1 is the only head substring of s matching p1, then we don't have alternative matches for p1, then the only case is checked. \\nIf there is another head substring of s matching p1, namely s1' which must be longer than s1, then its complement, name s2' must be a tail substring of s2.  We know that p2 doesn't match s2, and p2 starts with '\\\\*', then we know p2 doesn't match any tail substring of s2, so p2 doesn't match s2' either.  To illustrate, consider:\\n\\n* p2 = \"*z\"\\n* s2 = \"abcd\"\\n\\np2 doesn't match s2, and p2 doesn't match any of \"bcd\", \"cd\", or \"d\". This is because in eyes of '\\\\*' \"abc\" \"bc\" \"c\" and \"\" are all the same. \\n\\n**2. C string all ends with a null char '\\\\0'.** \\nThis actually makes his problem easier to solve with C string, and if the inputs are std::string, the best way to do it is to use their c_str() to solve it. \\n\\nThe convenience is that when the pointer of pattern string p is at the end, pointing to '\\\\0', matching attempt with any char of string s (not including its end '\\\\0') will result in failure. This is equivalent to the following behavior:\\n   \\n*When characters in pattern string p are all matched but there are still characters remaining in string s, this matching attempt is a failure.*\\n\\nIf such logic is implemented in std::string, we need to use either the size of string or its end iterator."
                    }
                ]
            },
            {
                "id": 1570407,
                "content": [
                    {
                        "username": "Imory2020",
                        "content": "I've figured out what the difference is, but would like to raise a question here in case others might also wonder it in the future. For reference, [Regular Expression Matching][1].\\n\\n\\n  [1]: https://oj.leetcode.com/problems/regular-expression-matching/"
                    },
                    {
                        "username": "stridemann",
                        "content": "Yes, the solution from REM problem could be a bit fixed/simplified and will do this job.\nI did REM using backtracking using recursion (and it was working there), but in this problem I got a timeouts with this approach. \nWe will also get timeouts if we use Regex way (on C#) (some cases takes 3min to process).\nI'm sure the \"DP table\" should be used in both this problems. It will simplify code many times.\n\nUPD. Dp table did it job, but slow as hell :) (no timeouts)"
                    },
                    {
                        "username": "et169tkm",
                        "content": "[@pradeepsinghjaroliya](/pradeepsinghjaroliya) Sounds like we can translate the input in this question to a regular expression, then use the previous solution to match it...."
                    },
                    {
                        "username": "practice_90",
                        "content": "[@fengli738](/fengli738) * in regular expression matches zero or more previous character. Here * can match any character any number of times"
                    },
                    {
                        "username": "pradeepsinghjaroliya",
                        "content": "[@fengli738](/fengli738) \nIn that question \na* means it can be \"\" or \"a\" or \"aa\" or \"aa.....\". (i.e. Matches zero or more of the preceding element.)\na* cant be \"ab\" it can only have zero or more preceding element in this case will be 'a';\n' * ' is not independent character consider (a*) as together.\n In this case ,it is independent.\nExample: \"aa*\"\nin this question it can be- \"aa\",\"aaa\",\"aaa....a\",\"aab\",\"aabb\",\"aaba\"\nAnd in that question it can be-\n \"a\",\"aa\",\"aaa\",\"aaaa...aa\"\n(Notice in that question it can be \"a\" but here it can't be \"aa\" is the compulsary part.)\n(Hope it help, was confused in both , sorry for my bad wording)"
                    },
                    {
                        "username": "fengli738",
                        "content": "what is the difference between this problem and https://leetcode.com/problems/regular-expression-matching/description/"
                    },
                    {
                        "username": "ArpitDhamija",
                        "content": "So, I just gave my Tech Round in a startup, applied offcampus.\\n\\nI have not done this question earlier. So just imagine my situation\\n\\nInterviewer asked me this as the 2nd ques. 1st ques was also hard but I know the solution of that.\\n\\nIn this, I somehow able to get to the recurssive solution with some of the hints given by interviewer. Its hell difficult according to me to get to the optimal solution for this question in an interview if you haven\\'t done that earlier. \\nLike I get to the recurssive solution. And time got over. As in 1 hr, 2 hard questions were asked and I have to code that also. \\n\\nThats all about this. \\n\\n"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "[@nushk_23](/nushk_23) this was asked in adobe to someone I know"
                    },
                    {
                        "username": "nushk_23",
                        "content": "which company though?"
                    },
                    {
                        "username": "iZERWAS",
                        "content": "ah tough luck man"
                    },
                    {
                        "username": "zdi561",
                        "content": "\"aa\" \"a\" is false but \"abcabczzzde\", \"*abc???de*\" is true , they are contradictory"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "[@DarkMatter71](/DarkMatter71)  Indeed its false.. I think you are mistaken the pattern which is *abc???de*"
                    },
                    {
                        "username": "tanmaytaran",
                        "content": "\\'*\\' matches 0 or more characters but \\'?\\' matches exactly 1 character.\\nSo, for string \"aa\" and pattern \"a\", its false, which is correct. Now for string \"aa\" and any pattern like \"*\" || \"a*\" || \"*a\" || \"?*\" || \"*?\", etc. all are correct.\\n\\nNow if we look at string \"abcabczzzde\" with pattern \"abc???de\", \\n\\'abc\\' in pattern matches and leaves us with \"abczzzde\". Now 3 \\'?\\' need to match exactly 3 characters. So the next abc gets matched, hence we are now left with \"zzzde\" and in pattern \"de\". Thats why this is false."
                    },
                    {
                        "username": "DarkMatter71",
                        "content": "\"abcabczzzde\", \"abc???de\" is not true"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "this question having contradictory testcase.\n\"adceb\"   \"* a* b\" this is true why?\n\"a*c?b\"   \"acdcb\" then why tis is false?\n"
                    },
                    {
                        "username": "danielrrv",
                        "content": "[@Moonbeam8773](/Moonbeam8773) Doesn't make sense at all. \"The The first * must match an empty string\" There's no empty string at the beginning unless that the tester supposes it. Machines don't understand assumptions. The empty string is not there, then  it is not there. \nThe only way to pass this case in my opinion is assuming*(in software assumptions are risky) that the letters have priority over * because the * in first place makes the entire string fulfills the pattern."
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "\\* matches any character, including 0-length string. For \"\\*a\\*b\", the first \\* must match an empty string in order to have the \"a\" match up.  This leaves \"a\\*b\" to match \"adceb\". The first and last characters of the pattern and string match, so we remove them. This leaves the single \\* in the middle to match \"dce\", which it does. Therefore true.\n\n\"a\\*c?b\" start and end has to be \"a\" and \"b\" respectively. Which means we need to have \"\\*c?\" match \"cdc\". If the last \"?\" must match one character, that leaves \"\\*c\" to match \"cd\". Both last characters don't match, therefore it's false."
                    },
                    {
                        "username": "gargsaksham57",
                        "content": "could anybody explain why recursion+memoisation is giving tle"
                    },
                    {
                        "username": "raistar702614",
                        "content": "if you get a tle then most of the time this trick worls...declare the variable as unsigned int AND while passing the strings in the function pass them by reference.\\n\\nfor this qustion i tried memoization it passed 1774/1811\\n\\ni made the type as unsigned then it passed 1809/1811\\n\\ni passed the string by reference ...passed all cases with ahead of 85% in time and 15% in space "
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "I've written the Memoised version and it works.\nPlz check this - https://leetcode.com/problems/wildcard-matching/solutions/3230627/dp-memoization/?orderBy=most_votes"
                    },
                    {
                        "username": "user4523qT",
                        "content": "recursion is slow because of the nature of recursion. iterative solution is the fastest way"
                    },
                    {
                        "username": "c3lEsTIaL",
                        "content": "I can\\'t think about a greedy strategy that works here. Most solutions posted seemed like Brute Force or DP."
                    },
                    {
                        "username": "abhishek_kumar_12140040",
                        "content": "I am Trying t solve it by recursion + memorisation but on the last test case I am exceeding the memory limit. Is there any other method for this?"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "[@mahdichaben47](/mahdichaben47) pass the strings by reference"
                    },
                    {
                        "username": "mahdichaben47",
                        "content": "same problem they dont give me any test case but Memory Limit Exceeded"
                    },
                    {
                        "username": "sakshitiwari_01",
                        "content": "asked in Myanatomy in campus recruitment "
                    },
                    {
                        "username": "sevxin",
                        "content": "I submitted my code, and the result shows wrong when it applied on testcase:\"acdcb\", \"ac?b\". However, when I ran it in playground, I get the correct answer. What should I do? Could someone help me out?"
                    },
                    {
                        "username": "Okpatu",
                        "content": "C is not matched "
                    },
                    {
                        "username": "Ayush379",
                        "content": "I think that should give false, since ? means 1 character, but there are 2 needed. "
                    },
                    {
                        "username": "hzzyyy",
                        "content": "The highest voted solution is based on:\\nhttp://yucoding.blogspot.com/2013/02/leetcode-question-123-wildcard-matching.html\\n\\nIf it is not very obvious for you, I will try to explain the following two reasons why it works:\\n\\n**1. Greedy matching works, there is no need to backtrack more than once.** \\n\\nObviously, we need to use backtrack, but why Yu's solution didn't use a stack? The reason is, we only need to backtrack once to go back to the most recent '\\\\*'. Let me explain why. Given a string s and a pattern p, Consider the pattern string is divided into two substrings, p1 and p2, each of which starts with a '\\\\*'. With greedy matching, which is the case in Yu's solution, suppose p1 matches the *shortest head substring* of s, namely s1. Let's name its complement as s2, then we have s = s1 + s2 and p = p1+p2.\\n\\nThe statement is: \\n    *If p2 doesn't match s2 then p doesn't match s.* \\n\\nThe proof is the following:\\nIf s1 is the only head substring of s matching p1, then we don't have alternative matches for p1, then the only case is checked. \\nIf there is another head substring of s matching p1, namely s1' which must be longer than s1, then its complement, name s2' must be a tail substring of s2.  We know that p2 doesn't match s2, and p2 starts with '\\\\*', then we know p2 doesn't match any tail substring of s2, so p2 doesn't match s2' either.  To illustrate, consider:\\n\\n* p2 = \"*z\"\\n* s2 = \"abcd\"\\n\\np2 doesn't match s2, and p2 doesn't match any of \"bcd\", \"cd\", or \"d\". This is because in eyes of '\\\\*' \"abc\" \"bc\" \"c\" and \"\" are all the same. \\n\\n**2. C string all ends with a null char '\\\\0'.** \\nThis actually makes his problem easier to solve with C string, and if the inputs are std::string, the best way to do it is to use their c_str() to solve it. \\n\\nThe convenience is that when the pointer of pattern string p is at the end, pointing to '\\\\0', matching attempt with any char of string s (not including its end '\\\\0') will result in failure. This is equivalent to the following behavior:\\n   \\n*When characters in pattern string p are all matched but there are still characters remaining in string s, this matching attempt is a failure.*\\n\\nIf such logic is implemented in std::string, we need to use either the size of string or its end iterator."
                    }
                ]
            },
            {
                "id": 1568429,
                "content": [
                    {
                        "username": "Imory2020",
                        "content": "I've figured out what the difference is, but would like to raise a question here in case others might also wonder it in the future. For reference, [Regular Expression Matching][1].\\n\\n\\n  [1]: https://oj.leetcode.com/problems/regular-expression-matching/"
                    },
                    {
                        "username": "stridemann",
                        "content": "Yes, the solution from REM problem could be a bit fixed/simplified and will do this job.\nI did REM using backtracking using recursion (and it was working there), but in this problem I got a timeouts with this approach. \nWe will also get timeouts if we use Regex way (on C#) (some cases takes 3min to process).\nI'm sure the \"DP table\" should be used in both this problems. It will simplify code many times.\n\nUPD. Dp table did it job, but slow as hell :) (no timeouts)"
                    },
                    {
                        "username": "et169tkm",
                        "content": "[@pradeepsinghjaroliya](/pradeepsinghjaroliya) Sounds like we can translate the input in this question to a regular expression, then use the previous solution to match it...."
                    },
                    {
                        "username": "practice_90",
                        "content": "[@fengli738](/fengli738) * in regular expression matches zero or more previous character. Here * can match any character any number of times"
                    },
                    {
                        "username": "pradeepsinghjaroliya",
                        "content": "[@fengli738](/fengli738) \nIn that question \na* means it can be \"\" or \"a\" or \"aa\" or \"aa.....\". (i.e. Matches zero or more of the preceding element.)\na* cant be \"ab\" it can only have zero or more preceding element in this case will be 'a';\n' * ' is not independent character consider (a*) as together.\n In this case ,it is independent.\nExample: \"aa*\"\nin this question it can be- \"aa\",\"aaa\",\"aaa....a\",\"aab\",\"aabb\",\"aaba\"\nAnd in that question it can be-\n \"a\",\"aa\",\"aaa\",\"aaaa...aa\"\n(Notice in that question it can be \"a\" but here it can't be \"aa\" is the compulsary part.)\n(Hope it help, was confused in both , sorry for my bad wording)"
                    },
                    {
                        "username": "fengli738",
                        "content": "what is the difference between this problem and https://leetcode.com/problems/regular-expression-matching/description/"
                    },
                    {
                        "username": "ArpitDhamija",
                        "content": "So, I just gave my Tech Round in a startup, applied offcampus.\\n\\nI have not done this question earlier. So just imagine my situation\\n\\nInterviewer asked me this as the 2nd ques. 1st ques was also hard but I know the solution of that.\\n\\nIn this, I somehow able to get to the recurssive solution with some of the hints given by interviewer. Its hell difficult according to me to get to the optimal solution for this question in an interview if you haven\\'t done that earlier. \\nLike I get to the recurssive solution. And time got over. As in 1 hr, 2 hard questions were asked and I have to code that also. \\n\\nThats all about this. \\n\\n"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "[@nushk_23](/nushk_23) this was asked in adobe to someone I know"
                    },
                    {
                        "username": "nushk_23",
                        "content": "which company though?"
                    },
                    {
                        "username": "iZERWAS",
                        "content": "ah tough luck man"
                    },
                    {
                        "username": "zdi561",
                        "content": "\"aa\" \"a\" is false but \"abcabczzzde\", \"*abc???de*\" is true , they are contradictory"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "[@DarkMatter71](/DarkMatter71)  Indeed its false.. I think you are mistaken the pattern which is *abc???de*"
                    },
                    {
                        "username": "tanmaytaran",
                        "content": "\\'*\\' matches 0 or more characters but \\'?\\' matches exactly 1 character.\\nSo, for string \"aa\" and pattern \"a\", its false, which is correct. Now for string \"aa\" and any pattern like \"*\" || \"a*\" || \"*a\" || \"?*\" || \"*?\", etc. all are correct.\\n\\nNow if we look at string \"abcabczzzde\" with pattern \"abc???de\", \\n\\'abc\\' in pattern matches and leaves us with \"abczzzde\". Now 3 \\'?\\' need to match exactly 3 characters. So the next abc gets matched, hence we are now left with \"zzzde\" and in pattern \"de\". Thats why this is false."
                    },
                    {
                        "username": "DarkMatter71",
                        "content": "\"abcabczzzde\", \"abc???de\" is not true"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "this question having contradictory testcase.\n\"adceb\"   \"* a* b\" this is true why?\n\"a*c?b\"   \"acdcb\" then why tis is false?\n"
                    },
                    {
                        "username": "danielrrv",
                        "content": "[@Moonbeam8773](/Moonbeam8773) Doesn't make sense at all. \"The The first * must match an empty string\" There's no empty string at the beginning unless that the tester supposes it. Machines don't understand assumptions. The empty string is not there, then  it is not there. \nThe only way to pass this case in my opinion is assuming*(in software assumptions are risky) that the letters have priority over * because the * in first place makes the entire string fulfills the pattern."
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "\\* matches any character, including 0-length string. For \"\\*a\\*b\", the first \\* must match an empty string in order to have the \"a\" match up.  This leaves \"a\\*b\" to match \"adceb\". The first and last characters of the pattern and string match, so we remove them. This leaves the single \\* in the middle to match \"dce\", which it does. Therefore true.\n\n\"a\\*c?b\" start and end has to be \"a\" and \"b\" respectively. Which means we need to have \"\\*c?\" match \"cdc\". If the last \"?\" must match one character, that leaves \"\\*c\" to match \"cd\". Both last characters don't match, therefore it's false."
                    },
                    {
                        "username": "gargsaksham57",
                        "content": "could anybody explain why recursion+memoisation is giving tle"
                    },
                    {
                        "username": "raistar702614",
                        "content": "if you get a tle then most of the time this trick worls...declare the variable as unsigned int AND while passing the strings in the function pass them by reference.\\n\\nfor this qustion i tried memoization it passed 1774/1811\\n\\ni made the type as unsigned then it passed 1809/1811\\n\\ni passed the string by reference ...passed all cases with ahead of 85% in time and 15% in space "
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "I've written the Memoised version and it works.\nPlz check this - https://leetcode.com/problems/wildcard-matching/solutions/3230627/dp-memoization/?orderBy=most_votes"
                    },
                    {
                        "username": "user4523qT",
                        "content": "recursion is slow because of the nature of recursion. iterative solution is the fastest way"
                    },
                    {
                        "username": "c3lEsTIaL",
                        "content": "I can\\'t think about a greedy strategy that works here. Most solutions posted seemed like Brute Force or DP."
                    },
                    {
                        "username": "abhishek_kumar_12140040",
                        "content": "I am Trying t solve it by recursion + memorisation but on the last test case I am exceeding the memory limit. Is there any other method for this?"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "[@mahdichaben47](/mahdichaben47) pass the strings by reference"
                    },
                    {
                        "username": "mahdichaben47",
                        "content": "same problem they dont give me any test case but Memory Limit Exceeded"
                    },
                    {
                        "username": "sakshitiwari_01",
                        "content": "asked in Myanatomy in campus recruitment "
                    },
                    {
                        "username": "sevxin",
                        "content": "I submitted my code, and the result shows wrong when it applied on testcase:\"acdcb\", \"ac?b\". However, when I ran it in playground, I get the correct answer. What should I do? Could someone help me out?"
                    },
                    {
                        "username": "Okpatu",
                        "content": "C is not matched "
                    },
                    {
                        "username": "Ayush379",
                        "content": "I think that should give false, since ? means 1 character, but there are 2 needed. "
                    },
                    {
                        "username": "hzzyyy",
                        "content": "The highest voted solution is based on:\\nhttp://yucoding.blogspot.com/2013/02/leetcode-question-123-wildcard-matching.html\\n\\nIf it is not very obvious for you, I will try to explain the following two reasons why it works:\\n\\n**1. Greedy matching works, there is no need to backtrack more than once.** \\n\\nObviously, we need to use backtrack, but why Yu's solution didn't use a stack? The reason is, we only need to backtrack once to go back to the most recent '\\\\*'. Let me explain why. Given a string s and a pattern p, Consider the pattern string is divided into two substrings, p1 and p2, each of which starts with a '\\\\*'. With greedy matching, which is the case in Yu's solution, suppose p1 matches the *shortest head substring* of s, namely s1. Let's name its complement as s2, then we have s = s1 + s2 and p = p1+p2.\\n\\nThe statement is: \\n    *If p2 doesn't match s2 then p doesn't match s.* \\n\\nThe proof is the following:\\nIf s1 is the only head substring of s matching p1, then we don't have alternative matches for p1, then the only case is checked. \\nIf there is another head substring of s matching p1, namely s1' which must be longer than s1, then its complement, name s2' must be a tail substring of s2.  We know that p2 doesn't match s2, and p2 starts with '\\\\*', then we know p2 doesn't match any tail substring of s2, so p2 doesn't match s2' either.  To illustrate, consider:\\n\\n* p2 = \"*z\"\\n* s2 = \"abcd\"\\n\\np2 doesn't match s2, and p2 doesn't match any of \"bcd\", \"cd\", or \"d\". This is because in eyes of '\\\\*' \"abc\" \"bc\" \"c\" and \"\" are all the same. \\n\\n**2. C string all ends with a null char '\\\\0'.** \\nThis actually makes his problem easier to solve with C string, and if the inputs are std::string, the best way to do it is to use their c_str() to solve it. \\n\\nThe convenience is that when the pointer of pattern string p is at the end, pointing to '\\\\0', matching attempt with any char of string s (not including its end '\\\\0') will result in failure. This is equivalent to the following behavior:\\n   \\n*When characters in pattern string p are all matched but there are still characters remaining in string s, this matching attempt is a failure.*\\n\\nIf such logic is implemented in std::string, we need to use either the size of string or its end iterator."
                    }
                ]
            },
            {
                "id": 1972353,
                "content": [
                    {
                        "username": "Imory2020",
                        "content": "I've figured out what the difference is, but would like to raise a question here in case others might also wonder it in the future. For reference, [Regular Expression Matching][1].\\n\\n\\n  [1]: https://oj.leetcode.com/problems/regular-expression-matching/"
                    },
                    {
                        "username": "stridemann",
                        "content": "Yes, the solution from REM problem could be a bit fixed/simplified and will do this job.\nI did REM using backtracking using recursion (and it was working there), but in this problem I got a timeouts with this approach. \nWe will also get timeouts if we use Regex way (on C#) (some cases takes 3min to process).\nI'm sure the \"DP table\" should be used in both this problems. It will simplify code many times.\n\nUPD. Dp table did it job, but slow as hell :) (no timeouts)"
                    },
                    {
                        "username": "et169tkm",
                        "content": "[@pradeepsinghjaroliya](/pradeepsinghjaroliya) Sounds like we can translate the input in this question to a regular expression, then use the previous solution to match it...."
                    },
                    {
                        "username": "practice_90",
                        "content": "[@fengli738](/fengli738) * in regular expression matches zero or more previous character. Here * can match any character any number of times"
                    },
                    {
                        "username": "pradeepsinghjaroliya",
                        "content": "[@fengli738](/fengli738) \nIn that question \na* means it can be \"\" or \"a\" or \"aa\" or \"aa.....\". (i.e. Matches zero or more of the preceding element.)\na* cant be \"ab\" it can only have zero or more preceding element in this case will be 'a';\n' * ' is not independent character consider (a*) as together.\n In this case ,it is independent.\nExample: \"aa*\"\nin this question it can be- \"aa\",\"aaa\",\"aaa....a\",\"aab\",\"aabb\",\"aaba\"\nAnd in that question it can be-\n \"a\",\"aa\",\"aaa\",\"aaaa...aa\"\n(Notice in that question it can be \"a\" but here it can't be \"aa\" is the compulsary part.)\n(Hope it help, was confused in both , sorry for my bad wording)"
                    },
                    {
                        "username": "fengli738",
                        "content": "what is the difference between this problem and https://leetcode.com/problems/regular-expression-matching/description/"
                    },
                    {
                        "username": "ArpitDhamija",
                        "content": "So, I just gave my Tech Round in a startup, applied offcampus.\\n\\nI have not done this question earlier. So just imagine my situation\\n\\nInterviewer asked me this as the 2nd ques. 1st ques was also hard but I know the solution of that.\\n\\nIn this, I somehow able to get to the recurssive solution with some of the hints given by interviewer. Its hell difficult according to me to get to the optimal solution for this question in an interview if you haven\\'t done that earlier. \\nLike I get to the recurssive solution. And time got over. As in 1 hr, 2 hard questions were asked and I have to code that also. \\n\\nThats all about this. \\n\\n"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "[@nushk_23](/nushk_23) this was asked in adobe to someone I know"
                    },
                    {
                        "username": "nushk_23",
                        "content": "which company though?"
                    },
                    {
                        "username": "iZERWAS",
                        "content": "ah tough luck man"
                    },
                    {
                        "username": "zdi561",
                        "content": "\"aa\" \"a\" is false but \"abcabczzzde\", \"*abc???de*\" is true , they are contradictory"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "[@DarkMatter71](/DarkMatter71)  Indeed its false.. I think you are mistaken the pattern which is *abc???de*"
                    },
                    {
                        "username": "tanmaytaran",
                        "content": "\\'*\\' matches 0 or more characters but \\'?\\' matches exactly 1 character.\\nSo, for string \"aa\" and pattern \"a\", its false, which is correct. Now for string \"aa\" and any pattern like \"*\" || \"a*\" || \"*a\" || \"?*\" || \"*?\", etc. all are correct.\\n\\nNow if we look at string \"abcabczzzde\" with pattern \"abc???de\", \\n\\'abc\\' in pattern matches and leaves us with \"abczzzde\". Now 3 \\'?\\' need to match exactly 3 characters. So the next abc gets matched, hence we are now left with \"zzzde\" and in pattern \"de\". Thats why this is false."
                    },
                    {
                        "username": "DarkMatter71",
                        "content": "\"abcabczzzde\", \"abc???de\" is not true"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "this question having contradictory testcase.\n\"adceb\"   \"* a* b\" this is true why?\n\"a*c?b\"   \"acdcb\" then why tis is false?\n"
                    },
                    {
                        "username": "danielrrv",
                        "content": "[@Moonbeam8773](/Moonbeam8773) Doesn't make sense at all. \"The The first * must match an empty string\" There's no empty string at the beginning unless that the tester supposes it. Machines don't understand assumptions. The empty string is not there, then  it is not there. \nThe only way to pass this case in my opinion is assuming*(in software assumptions are risky) that the letters have priority over * because the * in first place makes the entire string fulfills the pattern."
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "\\* matches any character, including 0-length string. For \"\\*a\\*b\", the first \\* must match an empty string in order to have the \"a\" match up.  This leaves \"a\\*b\" to match \"adceb\". The first and last characters of the pattern and string match, so we remove them. This leaves the single \\* in the middle to match \"dce\", which it does. Therefore true.\n\n\"a\\*c?b\" start and end has to be \"a\" and \"b\" respectively. Which means we need to have \"\\*c?\" match \"cdc\". If the last \"?\" must match one character, that leaves \"\\*c\" to match \"cd\". Both last characters don't match, therefore it's false."
                    },
                    {
                        "username": "gargsaksham57",
                        "content": "could anybody explain why recursion+memoisation is giving tle"
                    },
                    {
                        "username": "raistar702614",
                        "content": "if you get a tle then most of the time this trick worls...declare the variable as unsigned int AND while passing the strings in the function pass them by reference.\\n\\nfor this qustion i tried memoization it passed 1774/1811\\n\\ni made the type as unsigned then it passed 1809/1811\\n\\ni passed the string by reference ...passed all cases with ahead of 85% in time and 15% in space "
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "I've written the Memoised version and it works.\nPlz check this - https://leetcode.com/problems/wildcard-matching/solutions/3230627/dp-memoization/?orderBy=most_votes"
                    },
                    {
                        "username": "user4523qT",
                        "content": "recursion is slow because of the nature of recursion. iterative solution is the fastest way"
                    },
                    {
                        "username": "c3lEsTIaL",
                        "content": "I can\\'t think about a greedy strategy that works here. Most solutions posted seemed like Brute Force or DP."
                    },
                    {
                        "username": "abhishek_kumar_12140040",
                        "content": "I am Trying t solve it by recursion + memorisation but on the last test case I am exceeding the memory limit. Is there any other method for this?"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "[@mahdichaben47](/mahdichaben47) pass the strings by reference"
                    },
                    {
                        "username": "mahdichaben47",
                        "content": "same problem they dont give me any test case but Memory Limit Exceeded"
                    },
                    {
                        "username": "sakshitiwari_01",
                        "content": "asked in Myanatomy in campus recruitment "
                    },
                    {
                        "username": "sevxin",
                        "content": "I submitted my code, and the result shows wrong when it applied on testcase:\"acdcb\", \"ac?b\". However, when I ran it in playground, I get the correct answer. What should I do? Could someone help me out?"
                    },
                    {
                        "username": "Okpatu",
                        "content": "C is not matched "
                    },
                    {
                        "username": "Ayush379",
                        "content": "I think that should give false, since ? means 1 character, but there are 2 needed. "
                    },
                    {
                        "username": "hzzyyy",
                        "content": "The highest voted solution is based on:\\nhttp://yucoding.blogspot.com/2013/02/leetcode-question-123-wildcard-matching.html\\n\\nIf it is not very obvious for you, I will try to explain the following two reasons why it works:\\n\\n**1. Greedy matching works, there is no need to backtrack more than once.** \\n\\nObviously, we need to use backtrack, but why Yu's solution didn't use a stack? The reason is, we only need to backtrack once to go back to the most recent '\\\\*'. Let me explain why. Given a string s and a pattern p, Consider the pattern string is divided into two substrings, p1 and p2, each of which starts with a '\\\\*'. With greedy matching, which is the case in Yu's solution, suppose p1 matches the *shortest head substring* of s, namely s1. Let's name its complement as s2, then we have s = s1 + s2 and p = p1+p2.\\n\\nThe statement is: \\n    *If p2 doesn't match s2 then p doesn't match s.* \\n\\nThe proof is the following:\\nIf s1 is the only head substring of s matching p1, then we don't have alternative matches for p1, then the only case is checked. \\nIf there is another head substring of s matching p1, namely s1' which must be longer than s1, then its complement, name s2' must be a tail substring of s2.  We know that p2 doesn't match s2, and p2 starts with '\\\\*', then we know p2 doesn't match any tail substring of s2, so p2 doesn't match s2' either.  To illustrate, consider:\\n\\n* p2 = \"*z\"\\n* s2 = \"abcd\"\\n\\np2 doesn't match s2, and p2 doesn't match any of \"bcd\", \"cd\", or \"d\". This is because in eyes of '\\\\*' \"abc\" \"bc\" \"c\" and \"\" are all the same. \\n\\n**2. C string all ends with a null char '\\\\0'.** \\nThis actually makes his problem easier to solve with C string, and if the inputs are std::string, the best way to do it is to use their c_str() to solve it. \\n\\nThe convenience is that when the pointer of pattern string p is at the end, pointing to '\\\\0', matching attempt with any char of string s (not including its end '\\\\0') will result in failure. This is equivalent to the following behavior:\\n   \\n*When characters in pattern string p are all matched but there are still characters remaining in string s, this matching attempt is a failure.*\\n\\nIf such logic is implemented in std::string, we need to use either the size of string or its end iterator."
                    }
                ]
            },
            {
                "id": 1868299,
                "content": [
                    {
                        "username": "Imory2020",
                        "content": "I've figured out what the difference is, but would like to raise a question here in case others might also wonder it in the future. For reference, [Regular Expression Matching][1].\\n\\n\\n  [1]: https://oj.leetcode.com/problems/regular-expression-matching/"
                    },
                    {
                        "username": "stridemann",
                        "content": "Yes, the solution from REM problem could be a bit fixed/simplified and will do this job.\nI did REM using backtracking using recursion (and it was working there), but in this problem I got a timeouts with this approach. \nWe will also get timeouts if we use Regex way (on C#) (some cases takes 3min to process).\nI'm sure the \"DP table\" should be used in both this problems. It will simplify code many times.\n\nUPD. Dp table did it job, but slow as hell :) (no timeouts)"
                    },
                    {
                        "username": "et169tkm",
                        "content": "[@pradeepsinghjaroliya](/pradeepsinghjaroliya) Sounds like we can translate the input in this question to a regular expression, then use the previous solution to match it...."
                    },
                    {
                        "username": "practice_90",
                        "content": "[@fengli738](/fengli738) * in regular expression matches zero or more previous character. Here * can match any character any number of times"
                    },
                    {
                        "username": "pradeepsinghjaroliya",
                        "content": "[@fengli738](/fengli738) \nIn that question \na* means it can be \"\" or \"a\" or \"aa\" or \"aa.....\". (i.e. Matches zero or more of the preceding element.)\na* cant be \"ab\" it can only have zero or more preceding element in this case will be 'a';\n' * ' is not independent character consider (a*) as together.\n In this case ,it is independent.\nExample: \"aa*\"\nin this question it can be- \"aa\",\"aaa\",\"aaa....a\",\"aab\",\"aabb\",\"aaba\"\nAnd in that question it can be-\n \"a\",\"aa\",\"aaa\",\"aaaa...aa\"\n(Notice in that question it can be \"a\" but here it can't be \"aa\" is the compulsary part.)\n(Hope it help, was confused in both , sorry for my bad wording)"
                    },
                    {
                        "username": "fengli738",
                        "content": "what is the difference between this problem and https://leetcode.com/problems/regular-expression-matching/description/"
                    },
                    {
                        "username": "ArpitDhamija",
                        "content": "So, I just gave my Tech Round in a startup, applied offcampus.\\n\\nI have not done this question earlier. So just imagine my situation\\n\\nInterviewer asked me this as the 2nd ques. 1st ques was also hard but I know the solution of that.\\n\\nIn this, I somehow able to get to the recurssive solution with some of the hints given by interviewer. Its hell difficult according to me to get to the optimal solution for this question in an interview if you haven\\'t done that earlier. \\nLike I get to the recurssive solution. And time got over. As in 1 hr, 2 hard questions were asked and I have to code that also. \\n\\nThats all about this. \\n\\n"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "[@nushk_23](/nushk_23) this was asked in adobe to someone I know"
                    },
                    {
                        "username": "nushk_23",
                        "content": "which company though?"
                    },
                    {
                        "username": "iZERWAS",
                        "content": "ah tough luck man"
                    },
                    {
                        "username": "zdi561",
                        "content": "\"aa\" \"a\" is false but \"abcabczzzde\", \"*abc???de*\" is true , they are contradictory"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "[@DarkMatter71](/DarkMatter71)  Indeed its false.. I think you are mistaken the pattern which is *abc???de*"
                    },
                    {
                        "username": "tanmaytaran",
                        "content": "\\'*\\' matches 0 or more characters but \\'?\\' matches exactly 1 character.\\nSo, for string \"aa\" and pattern \"a\", its false, which is correct. Now for string \"aa\" and any pattern like \"*\" || \"a*\" || \"*a\" || \"?*\" || \"*?\", etc. all are correct.\\n\\nNow if we look at string \"abcabczzzde\" with pattern \"abc???de\", \\n\\'abc\\' in pattern matches and leaves us with \"abczzzde\". Now 3 \\'?\\' need to match exactly 3 characters. So the next abc gets matched, hence we are now left with \"zzzde\" and in pattern \"de\". Thats why this is false."
                    },
                    {
                        "username": "DarkMatter71",
                        "content": "\"abcabczzzde\", \"abc???de\" is not true"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "this question having contradictory testcase.\n\"adceb\"   \"* a* b\" this is true why?\n\"a*c?b\"   \"acdcb\" then why tis is false?\n"
                    },
                    {
                        "username": "danielrrv",
                        "content": "[@Moonbeam8773](/Moonbeam8773) Doesn't make sense at all. \"The The first * must match an empty string\" There's no empty string at the beginning unless that the tester supposes it. Machines don't understand assumptions. The empty string is not there, then  it is not there. \nThe only way to pass this case in my opinion is assuming*(in software assumptions are risky) that the letters have priority over * because the * in first place makes the entire string fulfills the pattern."
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "\\* matches any character, including 0-length string. For \"\\*a\\*b\", the first \\* must match an empty string in order to have the \"a\" match up.  This leaves \"a\\*b\" to match \"adceb\". The first and last characters of the pattern and string match, so we remove them. This leaves the single \\* in the middle to match \"dce\", which it does. Therefore true.\n\n\"a\\*c?b\" start and end has to be \"a\" and \"b\" respectively. Which means we need to have \"\\*c?\" match \"cdc\". If the last \"?\" must match one character, that leaves \"\\*c\" to match \"cd\". Both last characters don't match, therefore it's false."
                    },
                    {
                        "username": "gargsaksham57",
                        "content": "could anybody explain why recursion+memoisation is giving tle"
                    },
                    {
                        "username": "raistar702614",
                        "content": "if you get a tle then most of the time this trick worls...declare the variable as unsigned int AND while passing the strings in the function pass them by reference.\\n\\nfor this qustion i tried memoization it passed 1774/1811\\n\\ni made the type as unsigned then it passed 1809/1811\\n\\ni passed the string by reference ...passed all cases with ahead of 85% in time and 15% in space "
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "I've written the Memoised version and it works.\nPlz check this - https://leetcode.com/problems/wildcard-matching/solutions/3230627/dp-memoization/?orderBy=most_votes"
                    },
                    {
                        "username": "user4523qT",
                        "content": "recursion is slow because of the nature of recursion. iterative solution is the fastest way"
                    },
                    {
                        "username": "c3lEsTIaL",
                        "content": "I can\\'t think about a greedy strategy that works here. Most solutions posted seemed like Brute Force or DP."
                    },
                    {
                        "username": "abhishek_kumar_12140040",
                        "content": "I am Trying t solve it by recursion + memorisation but on the last test case I am exceeding the memory limit. Is there any other method for this?"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "[@mahdichaben47](/mahdichaben47) pass the strings by reference"
                    },
                    {
                        "username": "mahdichaben47",
                        "content": "same problem they dont give me any test case but Memory Limit Exceeded"
                    },
                    {
                        "username": "sakshitiwari_01",
                        "content": "asked in Myanatomy in campus recruitment "
                    },
                    {
                        "username": "sevxin",
                        "content": "I submitted my code, and the result shows wrong when it applied on testcase:\"acdcb\", \"ac?b\". However, when I ran it in playground, I get the correct answer. What should I do? Could someone help me out?"
                    },
                    {
                        "username": "Okpatu",
                        "content": "C is not matched "
                    },
                    {
                        "username": "Ayush379",
                        "content": "I think that should give false, since ? means 1 character, but there are 2 needed. "
                    },
                    {
                        "username": "hzzyyy",
                        "content": "The highest voted solution is based on:\\nhttp://yucoding.blogspot.com/2013/02/leetcode-question-123-wildcard-matching.html\\n\\nIf it is not very obvious for you, I will try to explain the following two reasons why it works:\\n\\n**1. Greedy matching works, there is no need to backtrack more than once.** \\n\\nObviously, we need to use backtrack, but why Yu's solution didn't use a stack? The reason is, we only need to backtrack once to go back to the most recent '\\\\*'. Let me explain why. Given a string s and a pattern p, Consider the pattern string is divided into two substrings, p1 and p2, each of which starts with a '\\\\*'. With greedy matching, which is the case in Yu's solution, suppose p1 matches the *shortest head substring* of s, namely s1. Let's name its complement as s2, then we have s = s1 + s2 and p = p1+p2.\\n\\nThe statement is: \\n    *If p2 doesn't match s2 then p doesn't match s.* \\n\\nThe proof is the following:\\nIf s1 is the only head substring of s matching p1, then we don't have alternative matches for p1, then the only case is checked. \\nIf there is another head substring of s matching p1, namely s1' which must be longer than s1, then its complement, name s2' must be a tail substring of s2.  We know that p2 doesn't match s2, and p2 starts with '\\\\*', then we know p2 doesn't match any tail substring of s2, so p2 doesn't match s2' either.  To illustrate, consider:\\n\\n* p2 = \"*z\"\\n* s2 = \"abcd\"\\n\\np2 doesn't match s2, and p2 doesn't match any of \"bcd\", \"cd\", or \"d\". This is because in eyes of '\\\\*' \"abc\" \"bc\" \"c\" and \"\" are all the same. \\n\\n**2. C string all ends with a null char '\\\\0'.** \\nThis actually makes his problem easier to solve with C string, and if the inputs are std::string, the best way to do it is to use their c_str() to solve it. \\n\\nThe convenience is that when the pointer of pattern string p is at the end, pointing to '\\\\0', matching attempt with any char of string s (not including its end '\\\\0') will result in failure. This is equivalent to the following behavior:\\n   \\n*When characters in pattern string p are all matched but there are still characters remaining in string s, this matching attempt is a failure.*\\n\\nIf such logic is implemented in std::string, we need to use either the size of string or its end iterator."
                    }
                ]
            },
            {
                "id": 1572611,
                "content": [
                    {
                        "username": "Imory2020",
                        "content": "I've figured out what the difference is, but would like to raise a question here in case others might also wonder it in the future. For reference, [Regular Expression Matching][1].\\n\\n\\n  [1]: https://oj.leetcode.com/problems/regular-expression-matching/"
                    },
                    {
                        "username": "stridemann",
                        "content": "Yes, the solution from REM problem could be a bit fixed/simplified and will do this job.\nI did REM using backtracking using recursion (and it was working there), but in this problem I got a timeouts with this approach. \nWe will also get timeouts if we use Regex way (on C#) (some cases takes 3min to process).\nI'm sure the \"DP table\" should be used in both this problems. It will simplify code many times.\n\nUPD. Dp table did it job, but slow as hell :) (no timeouts)"
                    },
                    {
                        "username": "et169tkm",
                        "content": "[@pradeepsinghjaroliya](/pradeepsinghjaroliya) Sounds like we can translate the input in this question to a regular expression, then use the previous solution to match it...."
                    },
                    {
                        "username": "practice_90",
                        "content": "[@fengli738](/fengli738) * in regular expression matches zero or more previous character. Here * can match any character any number of times"
                    },
                    {
                        "username": "pradeepsinghjaroliya",
                        "content": "[@fengli738](/fengli738) \nIn that question \na* means it can be \"\" or \"a\" or \"aa\" or \"aa.....\". (i.e. Matches zero or more of the preceding element.)\na* cant be \"ab\" it can only have zero or more preceding element in this case will be 'a';\n' * ' is not independent character consider (a*) as together.\n In this case ,it is independent.\nExample: \"aa*\"\nin this question it can be- \"aa\",\"aaa\",\"aaa....a\",\"aab\",\"aabb\",\"aaba\"\nAnd in that question it can be-\n \"a\",\"aa\",\"aaa\",\"aaaa...aa\"\n(Notice in that question it can be \"a\" but here it can't be \"aa\" is the compulsary part.)\n(Hope it help, was confused in both , sorry for my bad wording)"
                    },
                    {
                        "username": "fengli738",
                        "content": "what is the difference between this problem and https://leetcode.com/problems/regular-expression-matching/description/"
                    },
                    {
                        "username": "ArpitDhamija",
                        "content": "So, I just gave my Tech Round in a startup, applied offcampus.\\n\\nI have not done this question earlier. So just imagine my situation\\n\\nInterviewer asked me this as the 2nd ques. 1st ques was also hard but I know the solution of that.\\n\\nIn this, I somehow able to get to the recurssive solution with some of the hints given by interviewer. Its hell difficult according to me to get to the optimal solution for this question in an interview if you haven\\'t done that earlier. \\nLike I get to the recurssive solution. And time got over. As in 1 hr, 2 hard questions were asked and I have to code that also. \\n\\nThats all about this. \\n\\n"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "[@nushk_23](/nushk_23) this was asked in adobe to someone I know"
                    },
                    {
                        "username": "nushk_23",
                        "content": "which company though?"
                    },
                    {
                        "username": "iZERWAS",
                        "content": "ah tough luck man"
                    },
                    {
                        "username": "zdi561",
                        "content": "\"aa\" \"a\" is false but \"abcabczzzde\", \"*abc???de*\" is true , they are contradictory"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "[@DarkMatter71](/DarkMatter71)  Indeed its false.. I think you are mistaken the pattern which is *abc???de*"
                    },
                    {
                        "username": "tanmaytaran",
                        "content": "\\'*\\' matches 0 or more characters but \\'?\\' matches exactly 1 character.\\nSo, for string \"aa\" and pattern \"a\", its false, which is correct. Now for string \"aa\" and any pattern like \"*\" || \"a*\" || \"*a\" || \"?*\" || \"*?\", etc. all are correct.\\n\\nNow if we look at string \"abcabczzzde\" with pattern \"abc???de\", \\n\\'abc\\' in pattern matches and leaves us with \"abczzzde\". Now 3 \\'?\\' need to match exactly 3 characters. So the next abc gets matched, hence we are now left with \"zzzde\" and in pattern \"de\". Thats why this is false."
                    },
                    {
                        "username": "DarkMatter71",
                        "content": "\"abcabczzzde\", \"abc???de\" is not true"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "this question having contradictory testcase.\n\"adceb\"   \"* a* b\" this is true why?\n\"a*c?b\"   \"acdcb\" then why tis is false?\n"
                    },
                    {
                        "username": "danielrrv",
                        "content": "[@Moonbeam8773](/Moonbeam8773) Doesn't make sense at all. \"The The first * must match an empty string\" There's no empty string at the beginning unless that the tester supposes it. Machines don't understand assumptions. The empty string is not there, then  it is not there. \nThe only way to pass this case in my opinion is assuming*(in software assumptions are risky) that the letters have priority over * because the * in first place makes the entire string fulfills the pattern."
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "\\* matches any character, including 0-length string. For \"\\*a\\*b\", the first \\* must match an empty string in order to have the \"a\" match up.  This leaves \"a\\*b\" to match \"adceb\". The first and last characters of the pattern and string match, so we remove them. This leaves the single \\* in the middle to match \"dce\", which it does. Therefore true.\n\n\"a\\*c?b\" start and end has to be \"a\" and \"b\" respectively. Which means we need to have \"\\*c?\" match \"cdc\". If the last \"?\" must match one character, that leaves \"\\*c\" to match \"cd\". Both last characters don't match, therefore it's false."
                    },
                    {
                        "username": "gargsaksham57",
                        "content": "could anybody explain why recursion+memoisation is giving tle"
                    },
                    {
                        "username": "raistar702614",
                        "content": "if you get a tle then most of the time this trick worls...declare the variable as unsigned int AND while passing the strings in the function pass them by reference.\\n\\nfor this qustion i tried memoization it passed 1774/1811\\n\\ni made the type as unsigned then it passed 1809/1811\\n\\ni passed the string by reference ...passed all cases with ahead of 85% in time and 15% in space "
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "I've written the Memoised version and it works.\nPlz check this - https://leetcode.com/problems/wildcard-matching/solutions/3230627/dp-memoization/?orderBy=most_votes"
                    },
                    {
                        "username": "user4523qT",
                        "content": "recursion is slow because of the nature of recursion. iterative solution is the fastest way"
                    },
                    {
                        "username": "c3lEsTIaL",
                        "content": "I can\\'t think about a greedy strategy that works here. Most solutions posted seemed like Brute Force or DP."
                    },
                    {
                        "username": "abhishek_kumar_12140040",
                        "content": "I am Trying t solve it by recursion + memorisation but on the last test case I am exceeding the memory limit. Is there any other method for this?"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "[@mahdichaben47](/mahdichaben47) pass the strings by reference"
                    },
                    {
                        "username": "mahdichaben47",
                        "content": "same problem they dont give me any test case but Memory Limit Exceeded"
                    },
                    {
                        "username": "sakshitiwari_01",
                        "content": "asked in Myanatomy in campus recruitment "
                    },
                    {
                        "username": "sevxin",
                        "content": "I submitted my code, and the result shows wrong when it applied on testcase:\"acdcb\", \"ac?b\". However, when I ran it in playground, I get the correct answer. What should I do? Could someone help me out?"
                    },
                    {
                        "username": "Okpatu",
                        "content": "C is not matched "
                    },
                    {
                        "username": "Ayush379",
                        "content": "I think that should give false, since ? means 1 character, but there are 2 needed. "
                    },
                    {
                        "username": "hzzyyy",
                        "content": "The highest voted solution is based on:\\nhttp://yucoding.blogspot.com/2013/02/leetcode-question-123-wildcard-matching.html\\n\\nIf it is not very obvious for you, I will try to explain the following two reasons why it works:\\n\\n**1. Greedy matching works, there is no need to backtrack more than once.** \\n\\nObviously, we need to use backtrack, but why Yu's solution didn't use a stack? The reason is, we only need to backtrack once to go back to the most recent '\\\\*'. Let me explain why. Given a string s and a pattern p, Consider the pattern string is divided into two substrings, p1 and p2, each of which starts with a '\\\\*'. With greedy matching, which is the case in Yu's solution, suppose p1 matches the *shortest head substring* of s, namely s1. Let's name its complement as s2, then we have s = s1 + s2 and p = p1+p2.\\n\\nThe statement is: \\n    *If p2 doesn't match s2 then p doesn't match s.* \\n\\nThe proof is the following:\\nIf s1 is the only head substring of s matching p1, then we don't have alternative matches for p1, then the only case is checked. \\nIf there is another head substring of s matching p1, namely s1' which must be longer than s1, then its complement, name s2' must be a tail substring of s2.  We know that p2 doesn't match s2, and p2 starts with '\\\\*', then we know p2 doesn't match any tail substring of s2, so p2 doesn't match s2' either.  To illustrate, consider:\\n\\n* p2 = \"*z\"\\n* s2 = \"abcd\"\\n\\np2 doesn't match s2, and p2 doesn't match any of \"bcd\", \"cd\", or \"d\". This is because in eyes of '\\\\*' \"abc\" \"bc\" \"c\" and \"\" are all the same. \\n\\n**2. C string all ends with a null char '\\\\0'.** \\nThis actually makes his problem easier to solve with C string, and if the inputs are std::string, the best way to do it is to use their c_str() to solve it. \\n\\nThe convenience is that when the pointer of pattern string p is at the end, pointing to '\\\\0', matching attempt with any char of string s (not including its end '\\\\0') will result in failure. This is equivalent to the following behavior:\\n   \\n*When characters in pattern string p are all matched but there are still characters remaining in string s, this matching attempt is a failure.*\\n\\nIf such logic is implemented in std::string, we need to use either the size of string or its end iterator."
                    }
                ]
            },
            {
                "id": 1571107,
                "content": [
                    {
                        "username": "Imory2020",
                        "content": "I've figured out what the difference is, but would like to raise a question here in case others might also wonder it in the future. For reference, [Regular Expression Matching][1].\\n\\n\\n  [1]: https://oj.leetcode.com/problems/regular-expression-matching/"
                    },
                    {
                        "username": "stridemann",
                        "content": "Yes, the solution from REM problem could be a bit fixed/simplified and will do this job.\nI did REM using backtracking using recursion (and it was working there), but in this problem I got a timeouts with this approach. \nWe will also get timeouts if we use Regex way (on C#) (some cases takes 3min to process).\nI'm sure the \"DP table\" should be used in both this problems. It will simplify code many times.\n\nUPD. Dp table did it job, but slow as hell :) (no timeouts)"
                    },
                    {
                        "username": "et169tkm",
                        "content": "[@pradeepsinghjaroliya](/pradeepsinghjaroliya) Sounds like we can translate the input in this question to a regular expression, then use the previous solution to match it...."
                    },
                    {
                        "username": "practice_90",
                        "content": "[@fengli738](/fengli738) * in regular expression matches zero or more previous character. Here * can match any character any number of times"
                    },
                    {
                        "username": "pradeepsinghjaroliya",
                        "content": "[@fengli738](/fengli738) \nIn that question \na* means it can be \"\" or \"a\" or \"aa\" or \"aa.....\". (i.e. Matches zero or more of the preceding element.)\na* cant be \"ab\" it can only have zero or more preceding element in this case will be 'a';\n' * ' is not independent character consider (a*) as together.\n In this case ,it is independent.\nExample: \"aa*\"\nin this question it can be- \"aa\",\"aaa\",\"aaa....a\",\"aab\",\"aabb\",\"aaba\"\nAnd in that question it can be-\n \"a\",\"aa\",\"aaa\",\"aaaa...aa\"\n(Notice in that question it can be \"a\" but here it can't be \"aa\" is the compulsary part.)\n(Hope it help, was confused in both , sorry for my bad wording)"
                    },
                    {
                        "username": "fengli738",
                        "content": "what is the difference between this problem and https://leetcode.com/problems/regular-expression-matching/description/"
                    },
                    {
                        "username": "ArpitDhamija",
                        "content": "So, I just gave my Tech Round in a startup, applied offcampus.\\n\\nI have not done this question earlier. So just imagine my situation\\n\\nInterviewer asked me this as the 2nd ques. 1st ques was also hard but I know the solution of that.\\n\\nIn this, I somehow able to get to the recurssive solution with some of the hints given by interviewer. Its hell difficult according to me to get to the optimal solution for this question in an interview if you haven\\'t done that earlier. \\nLike I get to the recurssive solution. And time got over. As in 1 hr, 2 hard questions were asked and I have to code that also. \\n\\nThats all about this. \\n\\n"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "[@nushk_23](/nushk_23) this was asked in adobe to someone I know"
                    },
                    {
                        "username": "nushk_23",
                        "content": "which company though?"
                    },
                    {
                        "username": "iZERWAS",
                        "content": "ah tough luck man"
                    },
                    {
                        "username": "zdi561",
                        "content": "\"aa\" \"a\" is false but \"abcabczzzde\", \"*abc???de*\" is true , they are contradictory"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "[@DarkMatter71](/DarkMatter71)  Indeed its false.. I think you are mistaken the pattern which is *abc???de*"
                    },
                    {
                        "username": "tanmaytaran",
                        "content": "\\'*\\' matches 0 or more characters but \\'?\\' matches exactly 1 character.\\nSo, for string \"aa\" and pattern \"a\", its false, which is correct. Now for string \"aa\" and any pattern like \"*\" || \"a*\" || \"*a\" || \"?*\" || \"*?\", etc. all are correct.\\n\\nNow if we look at string \"abcabczzzde\" with pattern \"abc???de\", \\n\\'abc\\' in pattern matches and leaves us with \"abczzzde\". Now 3 \\'?\\' need to match exactly 3 characters. So the next abc gets matched, hence we are now left with \"zzzde\" and in pattern \"de\". Thats why this is false."
                    },
                    {
                        "username": "DarkMatter71",
                        "content": "\"abcabczzzde\", \"abc???de\" is not true"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "this question having contradictory testcase.\n\"adceb\"   \"* a* b\" this is true why?\n\"a*c?b\"   \"acdcb\" then why tis is false?\n"
                    },
                    {
                        "username": "danielrrv",
                        "content": "[@Moonbeam8773](/Moonbeam8773) Doesn't make sense at all. \"The The first * must match an empty string\" There's no empty string at the beginning unless that the tester supposes it. Machines don't understand assumptions. The empty string is not there, then  it is not there. \nThe only way to pass this case in my opinion is assuming*(in software assumptions are risky) that the letters have priority over * because the * in first place makes the entire string fulfills the pattern."
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "\\* matches any character, including 0-length string. For \"\\*a\\*b\", the first \\* must match an empty string in order to have the \"a\" match up.  This leaves \"a\\*b\" to match \"adceb\". The first and last characters of the pattern and string match, so we remove them. This leaves the single \\* in the middle to match \"dce\", which it does. Therefore true.\n\n\"a\\*c?b\" start and end has to be \"a\" and \"b\" respectively. Which means we need to have \"\\*c?\" match \"cdc\". If the last \"?\" must match one character, that leaves \"\\*c\" to match \"cd\". Both last characters don't match, therefore it's false."
                    },
                    {
                        "username": "gargsaksham57",
                        "content": "could anybody explain why recursion+memoisation is giving tle"
                    },
                    {
                        "username": "raistar702614",
                        "content": "if you get a tle then most of the time this trick worls...declare the variable as unsigned int AND while passing the strings in the function pass them by reference.\\n\\nfor this qustion i tried memoization it passed 1774/1811\\n\\ni made the type as unsigned then it passed 1809/1811\\n\\ni passed the string by reference ...passed all cases with ahead of 85% in time and 15% in space "
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "I've written the Memoised version and it works.\nPlz check this - https://leetcode.com/problems/wildcard-matching/solutions/3230627/dp-memoization/?orderBy=most_votes"
                    },
                    {
                        "username": "user4523qT",
                        "content": "recursion is slow because of the nature of recursion. iterative solution is the fastest way"
                    },
                    {
                        "username": "c3lEsTIaL",
                        "content": "I can\\'t think about a greedy strategy that works here. Most solutions posted seemed like Brute Force or DP."
                    },
                    {
                        "username": "abhishek_kumar_12140040",
                        "content": "I am Trying t solve it by recursion + memorisation but on the last test case I am exceeding the memory limit. Is there any other method for this?"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "[@mahdichaben47](/mahdichaben47) pass the strings by reference"
                    },
                    {
                        "username": "mahdichaben47",
                        "content": "same problem they dont give me any test case but Memory Limit Exceeded"
                    },
                    {
                        "username": "sakshitiwari_01",
                        "content": "asked in Myanatomy in campus recruitment "
                    },
                    {
                        "username": "sevxin",
                        "content": "I submitted my code, and the result shows wrong when it applied on testcase:\"acdcb\", \"ac?b\". However, when I ran it in playground, I get the correct answer. What should I do? Could someone help me out?"
                    },
                    {
                        "username": "Okpatu",
                        "content": "C is not matched "
                    },
                    {
                        "username": "Ayush379",
                        "content": "I think that should give false, since ? means 1 character, but there are 2 needed. "
                    },
                    {
                        "username": "hzzyyy",
                        "content": "The highest voted solution is based on:\\nhttp://yucoding.blogspot.com/2013/02/leetcode-question-123-wildcard-matching.html\\n\\nIf it is not very obvious for you, I will try to explain the following two reasons why it works:\\n\\n**1. Greedy matching works, there is no need to backtrack more than once.** \\n\\nObviously, we need to use backtrack, but why Yu's solution didn't use a stack? The reason is, we only need to backtrack once to go back to the most recent '\\\\*'. Let me explain why. Given a string s and a pattern p, Consider the pattern string is divided into two substrings, p1 and p2, each of which starts with a '\\\\*'. With greedy matching, which is the case in Yu's solution, suppose p1 matches the *shortest head substring* of s, namely s1. Let's name its complement as s2, then we have s = s1 + s2 and p = p1+p2.\\n\\nThe statement is: \\n    *If p2 doesn't match s2 then p doesn't match s.* \\n\\nThe proof is the following:\\nIf s1 is the only head substring of s matching p1, then we don't have alternative matches for p1, then the only case is checked. \\nIf there is another head substring of s matching p1, namely s1' which must be longer than s1, then its complement, name s2' must be a tail substring of s2.  We know that p2 doesn't match s2, and p2 starts with '\\\\*', then we know p2 doesn't match any tail substring of s2, so p2 doesn't match s2' either.  To illustrate, consider:\\n\\n* p2 = \"*z\"\\n* s2 = \"abcd\"\\n\\np2 doesn't match s2, and p2 doesn't match any of \"bcd\", \"cd\", or \"d\". This is because in eyes of '\\\\*' \"abc\" \"bc\" \"c\" and \"\" are all the same. \\n\\n**2. C string all ends with a null char '\\\\0'.** \\nThis actually makes his problem easier to solve with C string, and if the inputs are std::string, the best way to do it is to use their c_str() to solve it. \\n\\nThe convenience is that when the pointer of pattern string p is at the end, pointing to '\\\\0', matching attempt with any char of string s (not including its end '\\\\0') will result in failure. This is equivalent to the following behavior:\\n   \\n*When characters in pattern string p are all matched but there are still characters remaining in string s, this matching attempt is a failure.*\\n\\nIf such logic is implemented in std::string, we need to use either the size of string or its end iterator."
                    }
                ]
            },
            {
                "id": 1732359,
                "content": [
                    {
                        "username": "aaks-ctrl",
                        "content": "Can someone help me figure this out ? \\n\\nwhile doing memoization , when declaring the dp as a global variable , I am getting TLE, but when passing that same dp by reference in the function call, it is getting passed, what could be the reason for this?"
                    },
                    {
                        "username": "BestluckJW",
                        "content": "These 2 are almost the same."
                    },
                    {
                        "username": "kranga",
                        "content": "Since the * character is different in this problem from the regular expression * (which operates on the previous character), this problem can be decomposed into a simple pattern easily. Here is the intuition for the problem:\\n\\n1. If the pattern is just * (assuming a pattern like a** b will presented), then the answer is trivially true for any input.\\n2. There are one of 4 types of patterns you can encounter. Taking the example of input pattern adceb, you can have patterns where (a) the first character is not * , (b) the last character is not * , (c) first and last is not * but we will just consider that to be pattern a and finally (d) both end points are *.\\n\\n(a) Take input pattern a * b. You can start matching adceb from the left until you encounter the first * . So then you are left with * b and dceb in the input. This becomes case (b)\\n\\n(b) Take the incput pattern * a * b  You can start matching from the right until you encounter the first * and you are left with adce with pattern * a * \\n\\n(c) Take input a * b - as shown above this becomes case (b) easily.\\n\\n(d) * ce * as pattern \\n\\nThe ? character is not optional and therefore a non * char. \\nEssentially by working off non-* characters we are left with a pattern of * on both ends. We now make a single pass through the pattern and create sequences of contiguous non-* characters. \\n\\nExample pattern * a * be? * ac * has three sub-sequences of a, be? and ac.\\nSimple scan the input from left to right to see if these subsequences can be matched. An input for the above pattern of\\ndeabexdefacde would match\\nde (a) (bex) def (ac) de and therefore would return true. \\n\\n"
                    },
                    {
                        "username": "KeerthanaJetty",
                        "content": "https://www.geeksforgeeks.org/wildcard-pattern-matching/ "
                    },
                    {
                        "username": "teddyyyy",
                        "content": "I think I saw pretty much the same code with many peoples' answers, basically DP, with 2 rows of storage.\\n\\nmany people reported timing out on the large case of s= \"a\" x 32316  , p = \"*\" + \"a\"x 32317 + \"*\"\\n\\n\\nI really can't figure out how it could be reduced further. on eclipse the input does come back in about 2 seconds"
                    },
                    {
                        "username": "mythjill",
                        "content": "I tried the following, and could not understand why\\n\\ntest case 121*  121*?, result is false\\n\\ntest case  1211 121*?, result is true\\n\\nany comment?"
                    },
                    {
                        "username": "fscyhcyh",
                        "content": "Could someone please explain why there are duplicate checks in recursion approach, so that we need memo? It took me for a while but I still don\\'t get it. Thank you"
                    },
                    {
                        "username": "satendra_04",
                        "content": " confuse ,if in second string we got * then why there is need to check further ...we can directly return true?\\n"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "so they want us to write a finite automata"
                    },
                    {
                        "username": "user4488fC",
                        "content": "Examples are not good. "
                    }
                ]
            },
            {
                "id": 1572947,
                "content": [
                    {
                        "username": "aaks-ctrl",
                        "content": "Can someone help me figure this out ? \\n\\nwhile doing memoization , when declaring the dp as a global variable , I am getting TLE, but when passing that same dp by reference in the function call, it is getting passed, what could be the reason for this?"
                    },
                    {
                        "username": "BestluckJW",
                        "content": "These 2 are almost the same."
                    },
                    {
                        "username": "kranga",
                        "content": "Since the * character is different in this problem from the regular expression * (which operates on the previous character), this problem can be decomposed into a simple pattern easily. Here is the intuition for the problem:\\n\\n1. If the pattern is just * (assuming a pattern like a** b will presented), then the answer is trivially true for any input.\\n2. There are one of 4 types of patterns you can encounter. Taking the example of input pattern adceb, you can have patterns where (a) the first character is not * , (b) the last character is not * , (c) first and last is not * but we will just consider that to be pattern a and finally (d) both end points are *.\\n\\n(a) Take input pattern a * b. You can start matching adceb from the left until you encounter the first * . So then you are left with * b and dceb in the input. This becomes case (b)\\n\\n(b) Take the incput pattern * a * b  You can start matching from the right until you encounter the first * and you are left with adce with pattern * a * \\n\\n(c) Take input a * b - as shown above this becomes case (b) easily.\\n\\n(d) * ce * as pattern \\n\\nThe ? character is not optional and therefore a non * char. \\nEssentially by working off non-* characters we are left with a pattern of * on both ends. We now make a single pass through the pattern and create sequences of contiguous non-* characters. \\n\\nExample pattern * a * be? * ac * has three sub-sequences of a, be? and ac.\\nSimple scan the input from left to right to see if these subsequences can be matched. An input for the above pattern of\\ndeabexdefacde would match\\nde (a) (bex) def (ac) de and therefore would return true. \\n\\n"
                    },
                    {
                        "username": "KeerthanaJetty",
                        "content": "https://www.geeksforgeeks.org/wildcard-pattern-matching/ "
                    },
                    {
                        "username": "teddyyyy",
                        "content": "I think I saw pretty much the same code with many peoples' answers, basically DP, with 2 rows of storage.\\n\\nmany people reported timing out on the large case of s= \"a\" x 32316  , p = \"*\" + \"a\"x 32317 + \"*\"\\n\\n\\nI really can't figure out how it could be reduced further. on eclipse the input does come back in about 2 seconds"
                    },
                    {
                        "username": "mythjill",
                        "content": "I tried the following, and could not understand why\\n\\ntest case 121*  121*?, result is false\\n\\ntest case  1211 121*?, result is true\\n\\nany comment?"
                    },
                    {
                        "username": "fscyhcyh",
                        "content": "Could someone please explain why there are duplicate checks in recursion approach, so that we need memo? It took me for a while but I still don\\'t get it. Thank you"
                    },
                    {
                        "username": "satendra_04",
                        "content": " confuse ,if in second string we got * then why there is need to check further ...we can directly return true?\\n"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "so they want us to write a finite automata"
                    },
                    {
                        "username": "user4488fC",
                        "content": "Examples are not good. "
                    }
                ]
            },
            {
                "id": 1572275,
                "content": [
                    {
                        "username": "aaks-ctrl",
                        "content": "Can someone help me figure this out ? \\n\\nwhile doing memoization , when declaring the dp as a global variable , I am getting TLE, but when passing that same dp by reference in the function call, it is getting passed, what could be the reason for this?"
                    },
                    {
                        "username": "BestluckJW",
                        "content": "These 2 are almost the same."
                    },
                    {
                        "username": "kranga",
                        "content": "Since the * character is different in this problem from the regular expression * (which operates on the previous character), this problem can be decomposed into a simple pattern easily. Here is the intuition for the problem:\\n\\n1. If the pattern is just * (assuming a pattern like a** b will presented), then the answer is trivially true for any input.\\n2. There are one of 4 types of patterns you can encounter. Taking the example of input pattern adceb, you can have patterns where (a) the first character is not * , (b) the last character is not * , (c) first and last is not * but we will just consider that to be pattern a and finally (d) both end points are *.\\n\\n(a) Take input pattern a * b. You can start matching adceb from the left until you encounter the first * . So then you are left with * b and dceb in the input. This becomes case (b)\\n\\n(b) Take the incput pattern * a * b  You can start matching from the right until you encounter the first * and you are left with adce with pattern * a * \\n\\n(c) Take input a * b - as shown above this becomes case (b) easily.\\n\\n(d) * ce * as pattern \\n\\nThe ? character is not optional and therefore a non * char. \\nEssentially by working off non-* characters we are left with a pattern of * on both ends. We now make a single pass through the pattern and create sequences of contiguous non-* characters. \\n\\nExample pattern * a * be? * ac * has three sub-sequences of a, be? and ac.\\nSimple scan the input from left to right to see if these subsequences can be matched. An input for the above pattern of\\ndeabexdefacde would match\\nde (a) (bex) def (ac) de and therefore would return true. \\n\\n"
                    },
                    {
                        "username": "KeerthanaJetty",
                        "content": "https://www.geeksforgeeks.org/wildcard-pattern-matching/ "
                    },
                    {
                        "username": "teddyyyy",
                        "content": "I think I saw pretty much the same code with many peoples' answers, basically DP, with 2 rows of storage.\\n\\nmany people reported timing out on the large case of s= \"a\" x 32316  , p = \"*\" + \"a\"x 32317 + \"*\"\\n\\n\\nI really can't figure out how it could be reduced further. on eclipse the input does come back in about 2 seconds"
                    },
                    {
                        "username": "mythjill",
                        "content": "I tried the following, and could not understand why\\n\\ntest case 121*  121*?, result is false\\n\\ntest case  1211 121*?, result is true\\n\\nany comment?"
                    },
                    {
                        "username": "fscyhcyh",
                        "content": "Could someone please explain why there are duplicate checks in recursion approach, so that we need memo? It took me for a while but I still don\\'t get it. Thank you"
                    },
                    {
                        "username": "satendra_04",
                        "content": " confuse ,if in second string we got * then why there is need to check further ...we can directly return true?\\n"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "so they want us to write a finite automata"
                    },
                    {
                        "username": "user4488fC",
                        "content": "Examples are not good. "
                    }
                ]
            },
            {
                "id": 1572186,
                "content": [
                    {
                        "username": "aaks-ctrl",
                        "content": "Can someone help me figure this out ? \\n\\nwhile doing memoization , when declaring the dp as a global variable , I am getting TLE, but when passing that same dp by reference in the function call, it is getting passed, what could be the reason for this?"
                    },
                    {
                        "username": "BestluckJW",
                        "content": "These 2 are almost the same."
                    },
                    {
                        "username": "kranga",
                        "content": "Since the * character is different in this problem from the regular expression * (which operates on the previous character), this problem can be decomposed into a simple pattern easily. Here is the intuition for the problem:\\n\\n1. If the pattern is just * (assuming a pattern like a** b will presented), then the answer is trivially true for any input.\\n2. There are one of 4 types of patterns you can encounter. Taking the example of input pattern adceb, you can have patterns where (a) the first character is not * , (b) the last character is not * , (c) first and last is not * but we will just consider that to be pattern a and finally (d) both end points are *.\\n\\n(a) Take input pattern a * b. You can start matching adceb from the left until you encounter the first * . So then you are left with * b and dceb in the input. This becomes case (b)\\n\\n(b) Take the incput pattern * a * b  You can start matching from the right until you encounter the first * and you are left with adce with pattern * a * \\n\\n(c) Take input a * b - as shown above this becomes case (b) easily.\\n\\n(d) * ce * as pattern \\n\\nThe ? character is not optional and therefore a non * char. \\nEssentially by working off non-* characters we are left with a pattern of * on both ends. We now make a single pass through the pattern and create sequences of contiguous non-* characters. \\n\\nExample pattern * a * be? * ac * has three sub-sequences of a, be? and ac.\\nSimple scan the input from left to right to see if these subsequences can be matched. An input for the above pattern of\\ndeabexdefacde would match\\nde (a) (bex) def (ac) de and therefore would return true. \\n\\n"
                    },
                    {
                        "username": "KeerthanaJetty",
                        "content": "https://www.geeksforgeeks.org/wildcard-pattern-matching/ "
                    },
                    {
                        "username": "teddyyyy",
                        "content": "I think I saw pretty much the same code with many peoples' answers, basically DP, with 2 rows of storage.\\n\\nmany people reported timing out on the large case of s= \"a\" x 32316  , p = \"*\" + \"a\"x 32317 + \"*\"\\n\\n\\nI really can't figure out how it could be reduced further. on eclipse the input does come back in about 2 seconds"
                    },
                    {
                        "username": "mythjill",
                        "content": "I tried the following, and could not understand why\\n\\ntest case 121*  121*?, result is false\\n\\ntest case  1211 121*?, result is true\\n\\nany comment?"
                    },
                    {
                        "username": "fscyhcyh",
                        "content": "Could someone please explain why there are duplicate checks in recursion approach, so that we need memo? It took me for a while but I still don\\'t get it. Thank you"
                    },
                    {
                        "username": "satendra_04",
                        "content": " confuse ,if in second string we got * then why there is need to check further ...we can directly return true?\\n"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "so they want us to write a finite automata"
                    },
                    {
                        "username": "user4488fC",
                        "content": "Examples are not good. "
                    }
                ]
            },
            {
                "id": 1571108,
                "content": [
                    {
                        "username": "aaks-ctrl",
                        "content": "Can someone help me figure this out ? \\n\\nwhile doing memoization , when declaring the dp as a global variable , I am getting TLE, but when passing that same dp by reference in the function call, it is getting passed, what could be the reason for this?"
                    },
                    {
                        "username": "BestluckJW",
                        "content": "These 2 are almost the same."
                    },
                    {
                        "username": "kranga",
                        "content": "Since the * character is different in this problem from the regular expression * (which operates on the previous character), this problem can be decomposed into a simple pattern easily. Here is the intuition for the problem:\\n\\n1. If the pattern is just * (assuming a pattern like a** b will presented), then the answer is trivially true for any input.\\n2. There are one of 4 types of patterns you can encounter. Taking the example of input pattern adceb, you can have patterns where (a) the first character is not * , (b) the last character is not * , (c) first and last is not * but we will just consider that to be pattern a and finally (d) both end points are *.\\n\\n(a) Take input pattern a * b. You can start matching adceb from the left until you encounter the first * . So then you are left with * b and dceb in the input. This becomes case (b)\\n\\n(b) Take the incput pattern * a * b  You can start matching from the right until you encounter the first * and you are left with adce with pattern * a * \\n\\n(c) Take input a * b - as shown above this becomes case (b) easily.\\n\\n(d) * ce * as pattern \\n\\nThe ? character is not optional and therefore a non * char. \\nEssentially by working off non-* characters we are left with a pattern of * on both ends. We now make a single pass through the pattern and create sequences of contiguous non-* characters. \\n\\nExample pattern * a * be? * ac * has three sub-sequences of a, be? and ac.\\nSimple scan the input from left to right to see if these subsequences can be matched. An input for the above pattern of\\ndeabexdefacde would match\\nde (a) (bex) def (ac) de and therefore would return true. \\n\\n"
                    },
                    {
                        "username": "KeerthanaJetty",
                        "content": "https://www.geeksforgeeks.org/wildcard-pattern-matching/ "
                    },
                    {
                        "username": "teddyyyy",
                        "content": "I think I saw pretty much the same code with many peoples' answers, basically DP, with 2 rows of storage.\\n\\nmany people reported timing out on the large case of s= \"a\" x 32316  , p = \"*\" + \"a\"x 32317 + \"*\"\\n\\n\\nI really can't figure out how it could be reduced further. on eclipse the input does come back in about 2 seconds"
                    },
                    {
                        "username": "mythjill",
                        "content": "I tried the following, and could not understand why\\n\\ntest case 121*  121*?, result is false\\n\\ntest case  1211 121*?, result is true\\n\\nany comment?"
                    },
                    {
                        "username": "fscyhcyh",
                        "content": "Could someone please explain why there are duplicate checks in recursion approach, so that we need memo? It took me for a while but I still don\\'t get it. Thank you"
                    },
                    {
                        "username": "satendra_04",
                        "content": " confuse ,if in second string we got * then why there is need to check further ...we can directly return true?\\n"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "so they want us to write a finite automata"
                    },
                    {
                        "username": "user4488fC",
                        "content": "Examples are not good. "
                    }
                ]
            },
            {
                "id": 1568869,
                "content": [
                    {
                        "username": "aaks-ctrl",
                        "content": "Can someone help me figure this out ? \\n\\nwhile doing memoization , when declaring the dp as a global variable , I am getting TLE, but when passing that same dp by reference in the function call, it is getting passed, what could be the reason for this?"
                    },
                    {
                        "username": "BestluckJW",
                        "content": "These 2 are almost the same."
                    },
                    {
                        "username": "kranga",
                        "content": "Since the * character is different in this problem from the regular expression * (which operates on the previous character), this problem can be decomposed into a simple pattern easily. Here is the intuition for the problem:\\n\\n1. If the pattern is just * (assuming a pattern like a** b will presented), then the answer is trivially true for any input.\\n2. There are one of 4 types of patterns you can encounter. Taking the example of input pattern adceb, you can have patterns where (a) the first character is not * , (b) the last character is not * , (c) first and last is not * but we will just consider that to be pattern a and finally (d) both end points are *.\\n\\n(a) Take input pattern a * b. You can start matching adceb from the left until you encounter the first * . So then you are left with * b and dceb in the input. This becomes case (b)\\n\\n(b) Take the incput pattern * a * b  You can start matching from the right until you encounter the first * and you are left with adce with pattern * a * \\n\\n(c) Take input a * b - as shown above this becomes case (b) easily.\\n\\n(d) * ce * as pattern \\n\\nThe ? character is not optional and therefore a non * char. \\nEssentially by working off non-* characters we are left with a pattern of * on both ends. We now make a single pass through the pattern and create sequences of contiguous non-* characters. \\n\\nExample pattern * a * be? * ac * has three sub-sequences of a, be? and ac.\\nSimple scan the input from left to right to see if these subsequences can be matched. An input for the above pattern of\\ndeabexdefacde would match\\nde (a) (bex) def (ac) de and therefore would return true. \\n\\n"
                    },
                    {
                        "username": "KeerthanaJetty",
                        "content": "https://www.geeksforgeeks.org/wildcard-pattern-matching/ "
                    },
                    {
                        "username": "teddyyyy",
                        "content": "I think I saw pretty much the same code with many peoples' answers, basically DP, with 2 rows of storage.\\n\\nmany people reported timing out on the large case of s= \"a\" x 32316  , p = \"*\" + \"a\"x 32317 + \"*\"\\n\\n\\nI really can't figure out how it could be reduced further. on eclipse the input does come back in about 2 seconds"
                    },
                    {
                        "username": "mythjill",
                        "content": "I tried the following, and could not understand why\\n\\ntest case 121*  121*?, result is false\\n\\ntest case  1211 121*?, result is true\\n\\nany comment?"
                    },
                    {
                        "username": "fscyhcyh",
                        "content": "Could someone please explain why there are duplicate checks in recursion approach, so that we need memo? It took me for a while but I still don\\'t get it. Thank you"
                    },
                    {
                        "username": "satendra_04",
                        "content": " confuse ,if in second string we got * then why there is need to check further ...we can directly return true?\\n"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "so they want us to write a finite automata"
                    },
                    {
                        "username": "user4488fC",
                        "content": "Examples are not good. "
                    }
                ]
            },
            {
                "id": 1575021,
                "content": [
                    {
                        "username": "aaks-ctrl",
                        "content": "Can someone help me figure this out ? \\n\\nwhile doing memoization , when declaring the dp as a global variable , I am getting TLE, but when passing that same dp by reference in the function call, it is getting passed, what could be the reason for this?"
                    },
                    {
                        "username": "BestluckJW",
                        "content": "These 2 are almost the same."
                    },
                    {
                        "username": "kranga",
                        "content": "Since the * character is different in this problem from the regular expression * (which operates on the previous character), this problem can be decomposed into a simple pattern easily. Here is the intuition for the problem:\\n\\n1. If the pattern is just * (assuming a pattern like a** b will presented), then the answer is trivially true for any input.\\n2. There are one of 4 types of patterns you can encounter. Taking the example of input pattern adceb, you can have patterns where (a) the first character is not * , (b) the last character is not * , (c) first and last is not * but we will just consider that to be pattern a and finally (d) both end points are *.\\n\\n(a) Take input pattern a * b. You can start matching adceb from the left until you encounter the first * . So then you are left with * b and dceb in the input. This becomes case (b)\\n\\n(b) Take the incput pattern * a * b  You can start matching from the right until you encounter the first * and you are left with adce with pattern * a * \\n\\n(c) Take input a * b - as shown above this becomes case (b) easily.\\n\\n(d) * ce * as pattern \\n\\nThe ? character is not optional and therefore a non * char. \\nEssentially by working off non-* characters we are left with a pattern of * on both ends. We now make a single pass through the pattern and create sequences of contiguous non-* characters. \\n\\nExample pattern * a * be? * ac * has three sub-sequences of a, be? and ac.\\nSimple scan the input from left to right to see if these subsequences can be matched. An input for the above pattern of\\ndeabexdefacde would match\\nde (a) (bex) def (ac) de and therefore would return true. \\n\\n"
                    },
                    {
                        "username": "KeerthanaJetty",
                        "content": "https://www.geeksforgeeks.org/wildcard-pattern-matching/ "
                    },
                    {
                        "username": "teddyyyy",
                        "content": "I think I saw pretty much the same code with many peoples' answers, basically DP, with 2 rows of storage.\\n\\nmany people reported timing out on the large case of s= \"a\" x 32316  , p = \"*\" + \"a\"x 32317 + \"*\"\\n\\n\\nI really can't figure out how it could be reduced further. on eclipse the input does come back in about 2 seconds"
                    },
                    {
                        "username": "mythjill",
                        "content": "I tried the following, and could not understand why\\n\\ntest case 121*  121*?, result is false\\n\\ntest case  1211 121*?, result is true\\n\\nany comment?"
                    },
                    {
                        "username": "fscyhcyh",
                        "content": "Could someone please explain why there are duplicate checks in recursion approach, so that we need memo? It took me for a while but I still don\\'t get it. Thank you"
                    },
                    {
                        "username": "satendra_04",
                        "content": " confuse ,if in second string we got * then why there is need to check further ...we can directly return true?\\n"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "so they want us to write a finite automata"
                    },
                    {
                        "username": "user4488fC",
                        "content": "Examples are not good. "
                    }
                ]
            },
            {
                "id": 2074503,
                "content": [
                    {
                        "username": "aaks-ctrl",
                        "content": "Can someone help me figure this out ? \\n\\nwhile doing memoization , when declaring the dp as a global variable , I am getting TLE, but when passing that same dp by reference in the function call, it is getting passed, what could be the reason for this?"
                    },
                    {
                        "username": "BestluckJW",
                        "content": "These 2 are almost the same."
                    },
                    {
                        "username": "kranga",
                        "content": "Since the * character is different in this problem from the regular expression * (which operates on the previous character), this problem can be decomposed into a simple pattern easily. Here is the intuition for the problem:\\n\\n1. If the pattern is just * (assuming a pattern like a** b will presented), then the answer is trivially true for any input.\\n2. There are one of 4 types of patterns you can encounter. Taking the example of input pattern adceb, you can have patterns where (a) the first character is not * , (b) the last character is not * , (c) first and last is not * but we will just consider that to be pattern a and finally (d) both end points are *.\\n\\n(a) Take input pattern a * b. You can start matching adceb from the left until you encounter the first * . So then you are left with * b and dceb in the input. This becomes case (b)\\n\\n(b) Take the incput pattern * a * b  You can start matching from the right until you encounter the first * and you are left with adce with pattern * a * \\n\\n(c) Take input a * b - as shown above this becomes case (b) easily.\\n\\n(d) * ce * as pattern \\n\\nThe ? character is not optional and therefore a non * char. \\nEssentially by working off non-* characters we are left with a pattern of * on both ends. We now make a single pass through the pattern and create sequences of contiguous non-* characters. \\n\\nExample pattern * a * be? * ac * has three sub-sequences of a, be? and ac.\\nSimple scan the input from left to right to see if these subsequences can be matched. An input for the above pattern of\\ndeabexdefacde would match\\nde (a) (bex) def (ac) de and therefore would return true. \\n\\n"
                    },
                    {
                        "username": "KeerthanaJetty",
                        "content": "https://www.geeksforgeeks.org/wildcard-pattern-matching/ "
                    },
                    {
                        "username": "teddyyyy",
                        "content": "I think I saw pretty much the same code with many peoples' answers, basically DP, with 2 rows of storage.\\n\\nmany people reported timing out on the large case of s= \"a\" x 32316  , p = \"*\" + \"a\"x 32317 + \"*\"\\n\\n\\nI really can't figure out how it could be reduced further. on eclipse the input does come back in about 2 seconds"
                    },
                    {
                        "username": "mythjill",
                        "content": "I tried the following, and could not understand why\\n\\ntest case 121*  121*?, result is false\\n\\ntest case  1211 121*?, result is true\\n\\nany comment?"
                    },
                    {
                        "username": "fscyhcyh",
                        "content": "Could someone please explain why there are duplicate checks in recursion approach, so that we need memo? It took me for a while but I still don\\'t get it. Thank you"
                    },
                    {
                        "username": "satendra_04",
                        "content": " confuse ,if in second string we got * then why there is need to check further ...we can directly return true?\\n"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "so they want us to write a finite automata"
                    },
                    {
                        "username": "user4488fC",
                        "content": "Examples are not good. "
                    }
                ]
            },
            {
                "id": 2072054,
                "content": [
                    {
                        "username": "aaks-ctrl",
                        "content": "Can someone help me figure this out ? \\n\\nwhile doing memoization , when declaring the dp as a global variable , I am getting TLE, but when passing that same dp by reference in the function call, it is getting passed, what could be the reason for this?"
                    },
                    {
                        "username": "BestluckJW",
                        "content": "These 2 are almost the same."
                    },
                    {
                        "username": "kranga",
                        "content": "Since the * character is different in this problem from the regular expression * (which operates on the previous character), this problem can be decomposed into a simple pattern easily. Here is the intuition for the problem:\\n\\n1. If the pattern is just * (assuming a pattern like a** b will presented), then the answer is trivially true for any input.\\n2. There are one of 4 types of patterns you can encounter. Taking the example of input pattern adceb, you can have patterns where (a) the first character is not * , (b) the last character is not * , (c) first and last is not * but we will just consider that to be pattern a and finally (d) both end points are *.\\n\\n(a) Take input pattern a * b. You can start matching adceb from the left until you encounter the first * . So then you are left with * b and dceb in the input. This becomes case (b)\\n\\n(b) Take the incput pattern * a * b  You can start matching from the right until you encounter the first * and you are left with adce with pattern * a * \\n\\n(c) Take input a * b - as shown above this becomes case (b) easily.\\n\\n(d) * ce * as pattern \\n\\nThe ? character is not optional and therefore a non * char. \\nEssentially by working off non-* characters we are left with a pattern of * on both ends. We now make a single pass through the pattern and create sequences of contiguous non-* characters. \\n\\nExample pattern * a * be? * ac * has three sub-sequences of a, be? and ac.\\nSimple scan the input from left to right to see if these subsequences can be matched. An input for the above pattern of\\ndeabexdefacde would match\\nde (a) (bex) def (ac) de and therefore would return true. \\n\\n"
                    },
                    {
                        "username": "KeerthanaJetty",
                        "content": "https://www.geeksforgeeks.org/wildcard-pattern-matching/ "
                    },
                    {
                        "username": "teddyyyy",
                        "content": "I think I saw pretty much the same code with many peoples' answers, basically DP, with 2 rows of storage.\\n\\nmany people reported timing out on the large case of s= \"a\" x 32316  , p = \"*\" + \"a\"x 32317 + \"*\"\\n\\n\\nI really can't figure out how it could be reduced further. on eclipse the input does come back in about 2 seconds"
                    },
                    {
                        "username": "mythjill",
                        "content": "I tried the following, and could not understand why\\n\\ntest case 121*  121*?, result is false\\n\\ntest case  1211 121*?, result is true\\n\\nany comment?"
                    },
                    {
                        "username": "fscyhcyh",
                        "content": "Could someone please explain why there are duplicate checks in recursion approach, so that we need memo? It took me for a while but I still don\\'t get it. Thank you"
                    },
                    {
                        "username": "satendra_04",
                        "content": " confuse ,if in second string we got * then why there is need to check further ...we can directly return true?\\n"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "so they want us to write a finite automata"
                    },
                    {
                        "username": "user4488fC",
                        "content": "Examples are not good. "
                    }
                ]
            },
            {
                "id": 2068402,
                "content": [
                    {
                        "username": "aaks-ctrl",
                        "content": "Can someone help me figure this out ? \\n\\nwhile doing memoization , when declaring the dp as a global variable , I am getting TLE, but when passing that same dp by reference in the function call, it is getting passed, what could be the reason for this?"
                    },
                    {
                        "username": "BestluckJW",
                        "content": "These 2 are almost the same."
                    },
                    {
                        "username": "kranga",
                        "content": "Since the * character is different in this problem from the regular expression * (which operates on the previous character), this problem can be decomposed into a simple pattern easily. Here is the intuition for the problem:\\n\\n1. If the pattern is just * (assuming a pattern like a** b will presented), then the answer is trivially true for any input.\\n2. There are one of 4 types of patterns you can encounter. Taking the example of input pattern adceb, you can have patterns where (a) the first character is not * , (b) the last character is not * , (c) first and last is not * but we will just consider that to be pattern a and finally (d) both end points are *.\\n\\n(a) Take input pattern a * b. You can start matching adceb from the left until you encounter the first * . So then you are left with * b and dceb in the input. This becomes case (b)\\n\\n(b) Take the incput pattern * a * b  You can start matching from the right until you encounter the first * and you are left with adce with pattern * a * \\n\\n(c) Take input a * b - as shown above this becomes case (b) easily.\\n\\n(d) * ce * as pattern \\n\\nThe ? character is not optional and therefore a non * char. \\nEssentially by working off non-* characters we are left with a pattern of * on both ends. We now make a single pass through the pattern and create sequences of contiguous non-* characters. \\n\\nExample pattern * a * be? * ac * has three sub-sequences of a, be? and ac.\\nSimple scan the input from left to right to see if these subsequences can be matched. An input for the above pattern of\\ndeabexdefacde would match\\nde (a) (bex) def (ac) de and therefore would return true. \\n\\n"
                    },
                    {
                        "username": "KeerthanaJetty",
                        "content": "https://www.geeksforgeeks.org/wildcard-pattern-matching/ "
                    },
                    {
                        "username": "teddyyyy",
                        "content": "I think I saw pretty much the same code with many peoples' answers, basically DP, with 2 rows of storage.\\n\\nmany people reported timing out on the large case of s= \"a\" x 32316  , p = \"*\" + \"a\"x 32317 + \"*\"\\n\\n\\nI really can't figure out how it could be reduced further. on eclipse the input does come back in about 2 seconds"
                    },
                    {
                        "username": "mythjill",
                        "content": "I tried the following, and could not understand why\\n\\ntest case 121*  121*?, result is false\\n\\ntest case  1211 121*?, result is true\\n\\nany comment?"
                    },
                    {
                        "username": "fscyhcyh",
                        "content": "Could someone please explain why there are duplicate checks in recursion approach, so that we need memo? It took me for a while but I still don\\'t get it. Thank you"
                    },
                    {
                        "username": "satendra_04",
                        "content": " confuse ,if in second string we got * then why there is need to check further ...we can directly return true?\\n"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "so they want us to write a finite automata"
                    },
                    {
                        "username": "user4488fC",
                        "content": "Examples are not good. "
                    }
                ]
            },
            {
                "id": 2047390,
                "content": [
                    {
                        "username": "scarletspeedster2",
                        "content": "Pattern needs pre-processing, remove consecutive \"*\"  from pattern "
                    },
                    {
                        "username": "vansh22559",
                        "content": "Aah faced 7 wrong submissions but still got bit of dopamine when it got passed on 8th attempt.\\nProblem had many edge cases, definitely a difficult one to solve but that\\'s where the fun is."
                    },
                    {
                        "username": "user8272RT",
                        "content": "Got here after doing [10. Regular Expression Matching](https://leetcode.com/problems/regular-expression-matching/), so this was solvable."
                    },
                    {
                        "username": "dvakar",
                        "content": "1. s =  `\"aab\"`, p =  `\"c*a*b\"`\n2. s =  `\"adceb\"`, p =  `\"*a*b\"`\n3. s =  `\"abbabbbaabaaabbbbbabbabbabbbabbaaabbbababbabaaabbab\"`, p =  `\"*aabb***aa**a******aa*\"`"
                    },
                    {
                        "username": "dmigalin",
                        "content": "What is wrong with 983 testcase?\\n\\ns = \"acdcb\"\\np = \"a*c?b\"\\n\\nMy answer is True, because p contains \"*\" -  the symbol that matches any sequence.\\nExpected answer is False.\\n\\nWhats wrong?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "`*` matches any sequence, it's true. but it doesn't mean you can return true as soon as you meet `*`\n\nexample -> \nafter `*` in the pattern there is a character, \"c\". so this \"c\" must match with one \"c\" from the check string.\nif \"c\" in the pattern matches the first \"c\" in the check string, we have:\n  \"a\" = \"a\"\n  `*` = \"\" (empty)\n  \"c\" = \"c\"\n  -> then \"?b\" must match \"dcb\" -> not possible\nif \"c\" in the pattern matches the second \"c\" in the check string:\n  \"a\" = \"a\"\n  `*` = \"cd\"\n  \"c\" = \"c\"\n  -> then \"?b\" must match \"b\" -> not possible, too\n\ntherefore, expected answer is false"
                    },
                    {
                        "username": "aq41",
                        "content": "so dumbass. why the hell * should be equal to empty string"
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "leetcode please provide some solid example input"
                    },
                    {
                        "username": "dpvidyasagar",
                        "content": "Hi,\\nPlease help! this code is failing in last test case, I don\\'t know why \\nclass Solution {\\nprivate:\\n    bool find(int i,int j,string s,string p,vector<vector<int>>& dp){\\n        if(i<0 || j<0){\\n            if(i<0 && j<0) return true;\\n            if(i>=0 && j<0) return false;\\n            if(i<0 && j>=0){\\n                while(j>=0){\\n                    if(p[j--]!= \\'*\\') return false;\\n                }\\n                return true;\\n            }\\n            return false;\\n        }\\n        if(dp[i][j] != -1) return dp[i][j];\\n        if(s[i] == p[j] || p[j] == \\'?\\') return dp[i][j] = find(i-1,j-1,s,p,dp);\\n        if(p[j] == \\'*\\') return dp[i][j] = find(i,j-1,s,p,dp) || find(i-1,j,s,p,dp);\\n        return dp[i][j] = false;\\n    }\\npublic:\\n    bool isMatch(string s, string p) {\\n        int n = s.size(),m = p.size();\\n        if(n == 0 && m == 0) return true;\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        return find(n-1,m-1,s,p,dp);\\n    }\\n};\\n"
                    },
                    {
                        "username": "simply_arko",
                        "content": "[Pic](https://drive.google.com/file/d/1VdNsh1Pi9KF7ITzvl-ImFqjDS08dcOrQ/view?usp=drive_link)\\nHuhhhh!.....What is this test case???"
                    },
                    {
                        "username": "asmithey",
                        "content": "I have no idea, but I\\'ve seen this before on other test cases. Has anyone been able to solve it recently, or is the problem just broken?"
                    },
                    {
                        "username": "pratikshaw8",
                        "content": "Same question. WTH is this?\\n"
                    },
                    {
                        "username": "khibach2004",
                        "content": "little hint for u guys this is exactly the same to regular expression matching the only different is the condition if that\\'s it\\nai ng Vi\\u1EC7t th\\xEC \\u0111\\u1ECDc kh\\xFAc n\\xE0y nha: c\\xE1i b\\xE0i n\\xE0y y chang b\\xE0i 10 leetcode n\\xF3 ch\\u1EC9 kh\\xE1c m\\u1ED7i \\u0111\\xECu ki\\u1EC7n ch\\u1ED7 if thoi c\\xF2n l\\u1EA1i y h\\u1EC7t"
                    }
                ]
            },
            {
                "id": 2038477,
                "content": [
                    {
                        "username": "scarletspeedster2",
                        "content": "Pattern needs pre-processing, remove consecutive \"*\"  from pattern "
                    },
                    {
                        "username": "vansh22559",
                        "content": "Aah faced 7 wrong submissions but still got bit of dopamine when it got passed on 8th attempt.\\nProblem had many edge cases, definitely a difficult one to solve but that\\'s where the fun is."
                    },
                    {
                        "username": "user8272RT",
                        "content": "Got here after doing [10. Regular Expression Matching](https://leetcode.com/problems/regular-expression-matching/), so this was solvable."
                    },
                    {
                        "username": "dvakar",
                        "content": "1. s =  `\"aab\"`, p =  `\"c*a*b\"`\n2. s =  `\"adceb\"`, p =  `\"*a*b\"`\n3. s =  `\"abbabbbaabaaabbbbbabbabbabbbabbaaabbbababbabaaabbab\"`, p =  `\"*aabb***aa**a******aa*\"`"
                    },
                    {
                        "username": "dmigalin",
                        "content": "What is wrong with 983 testcase?\\n\\ns = \"acdcb\"\\np = \"a*c?b\"\\n\\nMy answer is True, because p contains \"*\" -  the symbol that matches any sequence.\\nExpected answer is False.\\n\\nWhats wrong?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "`*` matches any sequence, it's true. but it doesn't mean you can return true as soon as you meet `*`\n\nexample -> \nafter `*` in the pattern there is a character, \"c\". so this \"c\" must match with one \"c\" from the check string.\nif \"c\" in the pattern matches the first \"c\" in the check string, we have:\n  \"a\" = \"a\"\n  `*` = \"\" (empty)\n  \"c\" = \"c\"\n  -> then \"?b\" must match \"dcb\" -> not possible\nif \"c\" in the pattern matches the second \"c\" in the check string:\n  \"a\" = \"a\"\n  `*` = \"cd\"\n  \"c\" = \"c\"\n  -> then \"?b\" must match \"b\" -> not possible, too\n\ntherefore, expected answer is false"
                    },
                    {
                        "username": "aq41",
                        "content": "so dumbass. why the hell * should be equal to empty string"
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "leetcode please provide some solid example input"
                    },
                    {
                        "username": "dpvidyasagar",
                        "content": "Hi,\\nPlease help! this code is failing in last test case, I don\\'t know why \\nclass Solution {\\nprivate:\\n    bool find(int i,int j,string s,string p,vector<vector<int>>& dp){\\n        if(i<0 || j<0){\\n            if(i<0 && j<0) return true;\\n            if(i>=0 && j<0) return false;\\n            if(i<0 && j>=0){\\n                while(j>=0){\\n                    if(p[j--]!= \\'*\\') return false;\\n                }\\n                return true;\\n            }\\n            return false;\\n        }\\n        if(dp[i][j] != -1) return dp[i][j];\\n        if(s[i] == p[j] || p[j] == \\'?\\') return dp[i][j] = find(i-1,j-1,s,p,dp);\\n        if(p[j] == \\'*\\') return dp[i][j] = find(i,j-1,s,p,dp) || find(i-1,j,s,p,dp);\\n        return dp[i][j] = false;\\n    }\\npublic:\\n    bool isMatch(string s, string p) {\\n        int n = s.size(),m = p.size();\\n        if(n == 0 && m == 0) return true;\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        return find(n-1,m-1,s,p,dp);\\n    }\\n};\\n"
                    },
                    {
                        "username": "simply_arko",
                        "content": "[Pic](https://drive.google.com/file/d/1VdNsh1Pi9KF7ITzvl-ImFqjDS08dcOrQ/view?usp=drive_link)\\nHuhhhh!.....What is this test case???"
                    },
                    {
                        "username": "asmithey",
                        "content": "I have no idea, but I\\'ve seen this before on other test cases. Has anyone been able to solve it recently, or is the problem just broken?"
                    },
                    {
                        "username": "pratikshaw8",
                        "content": "Same question. WTH is this?\\n"
                    },
                    {
                        "username": "khibach2004",
                        "content": "little hint for u guys this is exactly the same to regular expression matching the only different is the condition if that\\'s it\\nai ng Vi\\u1EC7t th\\xEC \\u0111\\u1ECDc kh\\xFAc n\\xE0y nha: c\\xE1i b\\xE0i n\\xE0y y chang b\\xE0i 10 leetcode n\\xF3 ch\\u1EC9 kh\\xE1c m\\u1ED7i \\u0111\\xECu ki\\u1EC7n ch\\u1ED7 if thoi c\\xF2n l\\u1EA1i y h\\u1EC7t"
                    }
                ]
            },
            {
                "id": 2025544,
                "content": [
                    {
                        "username": "scarletspeedster2",
                        "content": "Pattern needs pre-processing, remove consecutive \"*\"  from pattern "
                    },
                    {
                        "username": "vansh22559",
                        "content": "Aah faced 7 wrong submissions but still got bit of dopamine when it got passed on 8th attempt.\\nProblem had many edge cases, definitely a difficult one to solve but that\\'s where the fun is."
                    },
                    {
                        "username": "user8272RT",
                        "content": "Got here after doing [10. Regular Expression Matching](https://leetcode.com/problems/regular-expression-matching/), so this was solvable."
                    },
                    {
                        "username": "dvakar",
                        "content": "1. s =  `\"aab\"`, p =  `\"c*a*b\"`\n2. s =  `\"adceb\"`, p =  `\"*a*b\"`\n3. s =  `\"abbabbbaabaaabbbbbabbabbabbbabbaaabbbababbabaaabbab\"`, p =  `\"*aabb***aa**a******aa*\"`"
                    },
                    {
                        "username": "dmigalin",
                        "content": "What is wrong with 983 testcase?\\n\\ns = \"acdcb\"\\np = \"a*c?b\"\\n\\nMy answer is True, because p contains \"*\" -  the symbol that matches any sequence.\\nExpected answer is False.\\n\\nWhats wrong?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "`*` matches any sequence, it's true. but it doesn't mean you can return true as soon as you meet `*`\n\nexample -> \nafter `*` in the pattern there is a character, \"c\". so this \"c\" must match with one \"c\" from the check string.\nif \"c\" in the pattern matches the first \"c\" in the check string, we have:\n  \"a\" = \"a\"\n  `*` = \"\" (empty)\n  \"c\" = \"c\"\n  -> then \"?b\" must match \"dcb\" -> not possible\nif \"c\" in the pattern matches the second \"c\" in the check string:\n  \"a\" = \"a\"\n  `*` = \"cd\"\n  \"c\" = \"c\"\n  -> then \"?b\" must match \"b\" -> not possible, too\n\ntherefore, expected answer is false"
                    },
                    {
                        "username": "aq41",
                        "content": "so dumbass. why the hell * should be equal to empty string"
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "leetcode please provide some solid example input"
                    },
                    {
                        "username": "dpvidyasagar",
                        "content": "Hi,\\nPlease help! this code is failing in last test case, I don\\'t know why \\nclass Solution {\\nprivate:\\n    bool find(int i,int j,string s,string p,vector<vector<int>>& dp){\\n        if(i<0 || j<0){\\n            if(i<0 && j<0) return true;\\n            if(i>=0 && j<0) return false;\\n            if(i<0 && j>=0){\\n                while(j>=0){\\n                    if(p[j--]!= \\'*\\') return false;\\n                }\\n                return true;\\n            }\\n            return false;\\n        }\\n        if(dp[i][j] != -1) return dp[i][j];\\n        if(s[i] == p[j] || p[j] == \\'?\\') return dp[i][j] = find(i-1,j-1,s,p,dp);\\n        if(p[j] == \\'*\\') return dp[i][j] = find(i,j-1,s,p,dp) || find(i-1,j,s,p,dp);\\n        return dp[i][j] = false;\\n    }\\npublic:\\n    bool isMatch(string s, string p) {\\n        int n = s.size(),m = p.size();\\n        if(n == 0 && m == 0) return true;\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        return find(n-1,m-1,s,p,dp);\\n    }\\n};\\n"
                    },
                    {
                        "username": "simply_arko",
                        "content": "[Pic](https://drive.google.com/file/d/1VdNsh1Pi9KF7ITzvl-ImFqjDS08dcOrQ/view?usp=drive_link)\\nHuhhhh!.....What is this test case???"
                    },
                    {
                        "username": "asmithey",
                        "content": "I have no idea, but I\\'ve seen this before on other test cases. Has anyone been able to solve it recently, or is the problem just broken?"
                    },
                    {
                        "username": "pratikshaw8",
                        "content": "Same question. WTH is this?\\n"
                    },
                    {
                        "username": "khibach2004",
                        "content": "little hint for u guys this is exactly the same to regular expression matching the only different is the condition if that\\'s it\\nai ng Vi\\u1EC7t th\\xEC \\u0111\\u1ECDc kh\\xFAc n\\xE0y nha: c\\xE1i b\\xE0i n\\xE0y y chang b\\xE0i 10 leetcode n\\xF3 ch\\u1EC9 kh\\xE1c m\\u1ED7i \\u0111\\xECu ki\\u1EC7n ch\\u1ED7 if thoi c\\xF2n l\\u1EA1i y h\\u1EC7t"
                    }
                ]
            },
            {
                "id": 2009810,
                "content": [
                    {
                        "username": "scarletspeedster2",
                        "content": "Pattern needs pre-processing, remove consecutive \"*\"  from pattern "
                    },
                    {
                        "username": "vansh22559",
                        "content": "Aah faced 7 wrong submissions but still got bit of dopamine when it got passed on 8th attempt.\\nProblem had many edge cases, definitely a difficult one to solve but that\\'s where the fun is."
                    },
                    {
                        "username": "user8272RT",
                        "content": "Got here after doing [10. Regular Expression Matching](https://leetcode.com/problems/regular-expression-matching/), so this was solvable."
                    },
                    {
                        "username": "dvakar",
                        "content": "1. s =  `\"aab\"`, p =  `\"c*a*b\"`\n2. s =  `\"adceb\"`, p =  `\"*a*b\"`\n3. s =  `\"abbabbbaabaaabbbbbabbabbabbbabbaaabbbababbabaaabbab\"`, p =  `\"*aabb***aa**a******aa*\"`"
                    },
                    {
                        "username": "dmigalin",
                        "content": "What is wrong with 983 testcase?\\n\\ns = \"acdcb\"\\np = \"a*c?b\"\\n\\nMy answer is True, because p contains \"*\" -  the symbol that matches any sequence.\\nExpected answer is False.\\n\\nWhats wrong?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "`*` matches any sequence, it's true. but it doesn't mean you can return true as soon as you meet `*`\n\nexample -> \nafter `*` in the pattern there is a character, \"c\". so this \"c\" must match with one \"c\" from the check string.\nif \"c\" in the pattern matches the first \"c\" in the check string, we have:\n  \"a\" = \"a\"\n  `*` = \"\" (empty)\n  \"c\" = \"c\"\n  -> then \"?b\" must match \"dcb\" -> not possible\nif \"c\" in the pattern matches the second \"c\" in the check string:\n  \"a\" = \"a\"\n  `*` = \"cd\"\n  \"c\" = \"c\"\n  -> then \"?b\" must match \"b\" -> not possible, too\n\ntherefore, expected answer is false"
                    },
                    {
                        "username": "aq41",
                        "content": "so dumbass. why the hell * should be equal to empty string"
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "leetcode please provide some solid example input"
                    },
                    {
                        "username": "dpvidyasagar",
                        "content": "Hi,\\nPlease help! this code is failing in last test case, I don\\'t know why \\nclass Solution {\\nprivate:\\n    bool find(int i,int j,string s,string p,vector<vector<int>>& dp){\\n        if(i<0 || j<0){\\n            if(i<0 && j<0) return true;\\n            if(i>=0 && j<0) return false;\\n            if(i<0 && j>=0){\\n                while(j>=0){\\n                    if(p[j--]!= \\'*\\') return false;\\n                }\\n                return true;\\n            }\\n            return false;\\n        }\\n        if(dp[i][j] != -1) return dp[i][j];\\n        if(s[i] == p[j] || p[j] == \\'?\\') return dp[i][j] = find(i-1,j-1,s,p,dp);\\n        if(p[j] == \\'*\\') return dp[i][j] = find(i,j-1,s,p,dp) || find(i-1,j,s,p,dp);\\n        return dp[i][j] = false;\\n    }\\npublic:\\n    bool isMatch(string s, string p) {\\n        int n = s.size(),m = p.size();\\n        if(n == 0 && m == 0) return true;\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        return find(n-1,m-1,s,p,dp);\\n    }\\n};\\n"
                    },
                    {
                        "username": "simply_arko",
                        "content": "[Pic](https://drive.google.com/file/d/1VdNsh1Pi9KF7ITzvl-ImFqjDS08dcOrQ/view?usp=drive_link)\\nHuhhhh!.....What is this test case???"
                    },
                    {
                        "username": "asmithey",
                        "content": "I have no idea, but I\\'ve seen this before on other test cases. Has anyone been able to solve it recently, or is the problem just broken?"
                    },
                    {
                        "username": "pratikshaw8",
                        "content": "Same question. WTH is this?\\n"
                    },
                    {
                        "username": "khibach2004",
                        "content": "little hint for u guys this is exactly the same to regular expression matching the only different is the condition if that\\'s it\\nai ng Vi\\u1EC7t th\\xEC \\u0111\\u1ECDc kh\\xFAc n\\xE0y nha: c\\xE1i b\\xE0i n\\xE0y y chang b\\xE0i 10 leetcode n\\xF3 ch\\u1EC9 kh\\xE1c m\\u1ED7i \\u0111\\xECu ki\\u1EC7n ch\\u1ED7 if thoi c\\xF2n l\\u1EA1i y h\\u1EC7t"
                    }
                ]
            },
            {
                "id": 2007373,
                "content": [
                    {
                        "username": "scarletspeedster2",
                        "content": "Pattern needs pre-processing, remove consecutive \"*\"  from pattern "
                    },
                    {
                        "username": "vansh22559",
                        "content": "Aah faced 7 wrong submissions but still got bit of dopamine when it got passed on 8th attempt.\\nProblem had many edge cases, definitely a difficult one to solve but that\\'s where the fun is."
                    },
                    {
                        "username": "user8272RT",
                        "content": "Got here after doing [10. Regular Expression Matching](https://leetcode.com/problems/regular-expression-matching/), so this was solvable."
                    },
                    {
                        "username": "dvakar",
                        "content": "1. s =  `\"aab\"`, p =  `\"c*a*b\"`\n2. s =  `\"adceb\"`, p =  `\"*a*b\"`\n3. s =  `\"abbabbbaabaaabbbbbabbabbabbbabbaaabbbababbabaaabbab\"`, p =  `\"*aabb***aa**a******aa*\"`"
                    },
                    {
                        "username": "dmigalin",
                        "content": "What is wrong with 983 testcase?\\n\\ns = \"acdcb\"\\np = \"a*c?b\"\\n\\nMy answer is True, because p contains \"*\" -  the symbol that matches any sequence.\\nExpected answer is False.\\n\\nWhats wrong?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "`*` matches any sequence, it's true. but it doesn't mean you can return true as soon as you meet `*`\n\nexample -> \nafter `*` in the pattern there is a character, \"c\". so this \"c\" must match with one \"c\" from the check string.\nif \"c\" in the pattern matches the first \"c\" in the check string, we have:\n  \"a\" = \"a\"\n  `*` = \"\" (empty)\n  \"c\" = \"c\"\n  -> then \"?b\" must match \"dcb\" -> not possible\nif \"c\" in the pattern matches the second \"c\" in the check string:\n  \"a\" = \"a\"\n  `*` = \"cd\"\n  \"c\" = \"c\"\n  -> then \"?b\" must match \"b\" -> not possible, too\n\ntherefore, expected answer is false"
                    },
                    {
                        "username": "aq41",
                        "content": "so dumbass. why the hell * should be equal to empty string"
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "leetcode please provide some solid example input"
                    },
                    {
                        "username": "dpvidyasagar",
                        "content": "Hi,\\nPlease help! this code is failing in last test case, I don\\'t know why \\nclass Solution {\\nprivate:\\n    bool find(int i,int j,string s,string p,vector<vector<int>>& dp){\\n        if(i<0 || j<0){\\n            if(i<0 && j<0) return true;\\n            if(i>=0 && j<0) return false;\\n            if(i<0 && j>=0){\\n                while(j>=0){\\n                    if(p[j--]!= \\'*\\') return false;\\n                }\\n                return true;\\n            }\\n            return false;\\n        }\\n        if(dp[i][j] != -1) return dp[i][j];\\n        if(s[i] == p[j] || p[j] == \\'?\\') return dp[i][j] = find(i-1,j-1,s,p,dp);\\n        if(p[j] == \\'*\\') return dp[i][j] = find(i,j-1,s,p,dp) || find(i-1,j,s,p,dp);\\n        return dp[i][j] = false;\\n    }\\npublic:\\n    bool isMatch(string s, string p) {\\n        int n = s.size(),m = p.size();\\n        if(n == 0 && m == 0) return true;\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        return find(n-1,m-1,s,p,dp);\\n    }\\n};\\n"
                    },
                    {
                        "username": "simply_arko",
                        "content": "[Pic](https://drive.google.com/file/d/1VdNsh1Pi9KF7ITzvl-ImFqjDS08dcOrQ/view?usp=drive_link)\\nHuhhhh!.....What is this test case???"
                    },
                    {
                        "username": "asmithey",
                        "content": "I have no idea, but I\\'ve seen this before on other test cases. Has anyone been able to solve it recently, or is the problem just broken?"
                    },
                    {
                        "username": "pratikshaw8",
                        "content": "Same question. WTH is this?\\n"
                    },
                    {
                        "username": "khibach2004",
                        "content": "little hint for u guys this is exactly the same to regular expression matching the only different is the condition if that\\'s it\\nai ng Vi\\u1EC7t th\\xEC \\u0111\\u1ECDc kh\\xFAc n\\xE0y nha: c\\xE1i b\\xE0i n\\xE0y y chang b\\xE0i 10 leetcode n\\xF3 ch\\u1EC9 kh\\xE1c m\\u1ED7i \\u0111\\xECu ki\\u1EC7n ch\\u1ED7 if thoi c\\xF2n l\\u1EA1i y h\\u1EC7t"
                    }
                ]
            },
            {
                "id": 1994279,
                "content": [
                    {
                        "username": "scarletspeedster2",
                        "content": "Pattern needs pre-processing, remove consecutive \"*\"  from pattern "
                    },
                    {
                        "username": "vansh22559",
                        "content": "Aah faced 7 wrong submissions but still got bit of dopamine when it got passed on 8th attempt.\\nProblem had many edge cases, definitely a difficult one to solve but that\\'s where the fun is."
                    },
                    {
                        "username": "user8272RT",
                        "content": "Got here after doing [10. Regular Expression Matching](https://leetcode.com/problems/regular-expression-matching/), so this was solvable."
                    },
                    {
                        "username": "dvakar",
                        "content": "1. s =  `\"aab\"`, p =  `\"c*a*b\"`\n2. s =  `\"adceb\"`, p =  `\"*a*b\"`\n3. s =  `\"abbabbbaabaaabbbbbabbabbabbbabbaaabbbababbabaaabbab\"`, p =  `\"*aabb***aa**a******aa*\"`"
                    },
                    {
                        "username": "dmigalin",
                        "content": "What is wrong with 983 testcase?\\n\\ns = \"acdcb\"\\np = \"a*c?b\"\\n\\nMy answer is True, because p contains \"*\" -  the symbol that matches any sequence.\\nExpected answer is False.\\n\\nWhats wrong?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "`*` matches any sequence, it's true. but it doesn't mean you can return true as soon as you meet `*`\n\nexample -> \nafter `*` in the pattern there is a character, \"c\". so this \"c\" must match with one \"c\" from the check string.\nif \"c\" in the pattern matches the first \"c\" in the check string, we have:\n  \"a\" = \"a\"\n  `*` = \"\" (empty)\n  \"c\" = \"c\"\n  -> then \"?b\" must match \"dcb\" -> not possible\nif \"c\" in the pattern matches the second \"c\" in the check string:\n  \"a\" = \"a\"\n  `*` = \"cd\"\n  \"c\" = \"c\"\n  -> then \"?b\" must match \"b\" -> not possible, too\n\ntherefore, expected answer is false"
                    },
                    {
                        "username": "aq41",
                        "content": "so dumbass. why the hell * should be equal to empty string"
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "leetcode please provide some solid example input"
                    },
                    {
                        "username": "dpvidyasagar",
                        "content": "Hi,\\nPlease help! this code is failing in last test case, I don\\'t know why \\nclass Solution {\\nprivate:\\n    bool find(int i,int j,string s,string p,vector<vector<int>>& dp){\\n        if(i<0 || j<0){\\n            if(i<0 && j<0) return true;\\n            if(i>=0 && j<0) return false;\\n            if(i<0 && j>=0){\\n                while(j>=0){\\n                    if(p[j--]!= \\'*\\') return false;\\n                }\\n                return true;\\n            }\\n            return false;\\n        }\\n        if(dp[i][j] != -1) return dp[i][j];\\n        if(s[i] == p[j] || p[j] == \\'?\\') return dp[i][j] = find(i-1,j-1,s,p,dp);\\n        if(p[j] == \\'*\\') return dp[i][j] = find(i,j-1,s,p,dp) || find(i-1,j,s,p,dp);\\n        return dp[i][j] = false;\\n    }\\npublic:\\n    bool isMatch(string s, string p) {\\n        int n = s.size(),m = p.size();\\n        if(n == 0 && m == 0) return true;\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        return find(n-1,m-1,s,p,dp);\\n    }\\n};\\n"
                    },
                    {
                        "username": "simply_arko",
                        "content": "[Pic](https://drive.google.com/file/d/1VdNsh1Pi9KF7ITzvl-ImFqjDS08dcOrQ/view?usp=drive_link)\\nHuhhhh!.....What is this test case???"
                    },
                    {
                        "username": "asmithey",
                        "content": "I have no idea, but I\\'ve seen this before on other test cases. Has anyone been able to solve it recently, or is the problem just broken?"
                    },
                    {
                        "username": "pratikshaw8",
                        "content": "Same question. WTH is this?\\n"
                    },
                    {
                        "username": "khibach2004",
                        "content": "little hint for u guys this is exactly the same to regular expression matching the only different is the condition if that\\'s it\\nai ng Vi\\u1EC7t th\\xEC \\u0111\\u1ECDc kh\\xFAc n\\xE0y nha: c\\xE1i b\\xE0i n\\xE0y y chang b\\xE0i 10 leetcode n\\xF3 ch\\u1EC9 kh\\xE1c m\\u1ED7i \\u0111\\xECu ki\\u1EC7n ch\\u1ED7 if thoi c\\xF2n l\\u1EA1i y h\\u1EC7t"
                    }
                ]
            },
            {
                "id": 1966498,
                "content": [
                    {
                        "username": "scarletspeedster2",
                        "content": "Pattern needs pre-processing, remove consecutive \"*\"  from pattern "
                    },
                    {
                        "username": "vansh22559",
                        "content": "Aah faced 7 wrong submissions but still got bit of dopamine when it got passed on 8th attempt.\\nProblem had many edge cases, definitely a difficult one to solve but that\\'s where the fun is."
                    },
                    {
                        "username": "user8272RT",
                        "content": "Got here after doing [10. Regular Expression Matching](https://leetcode.com/problems/regular-expression-matching/), so this was solvable."
                    },
                    {
                        "username": "dvakar",
                        "content": "1. s =  `\"aab\"`, p =  `\"c*a*b\"`\n2. s =  `\"adceb\"`, p =  `\"*a*b\"`\n3. s =  `\"abbabbbaabaaabbbbbabbabbabbbabbaaabbbababbabaaabbab\"`, p =  `\"*aabb***aa**a******aa*\"`"
                    },
                    {
                        "username": "dmigalin",
                        "content": "What is wrong with 983 testcase?\\n\\ns = \"acdcb\"\\np = \"a*c?b\"\\n\\nMy answer is True, because p contains \"*\" -  the symbol that matches any sequence.\\nExpected answer is False.\\n\\nWhats wrong?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "`*` matches any sequence, it's true. but it doesn't mean you can return true as soon as you meet `*`\n\nexample -> \nafter `*` in the pattern there is a character, \"c\". so this \"c\" must match with one \"c\" from the check string.\nif \"c\" in the pattern matches the first \"c\" in the check string, we have:\n  \"a\" = \"a\"\n  `*` = \"\" (empty)\n  \"c\" = \"c\"\n  -> then \"?b\" must match \"dcb\" -> not possible\nif \"c\" in the pattern matches the second \"c\" in the check string:\n  \"a\" = \"a\"\n  `*` = \"cd\"\n  \"c\" = \"c\"\n  -> then \"?b\" must match \"b\" -> not possible, too\n\ntherefore, expected answer is false"
                    },
                    {
                        "username": "aq41",
                        "content": "so dumbass. why the hell * should be equal to empty string"
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "leetcode please provide some solid example input"
                    },
                    {
                        "username": "dpvidyasagar",
                        "content": "Hi,\\nPlease help! this code is failing in last test case, I don\\'t know why \\nclass Solution {\\nprivate:\\n    bool find(int i,int j,string s,string p,vector<vector<int>>& dp){\\n        if(i<0 || j<0){\\n            if(i<0 && j<0) return true;\\n            if(i>=0 && j<0) return false;\\n            if(i<0 && j>=0){\\n                while(j>=0){\\n                    if(p[j--]!= \\'*\\') return false;\\n                }\\n                return true;\\n            }\\n            return false;\\n        }\\n        if(dp[i][j] != -1) return dp[i][j];\\n        if(s[i] == p[j] || p[j] == \\'?\\') return dp[i][j] = find(i-1,j-1,s,p,dp);\\n        if(p[j] == \\'*\\') return dp[i][j] = find(i,j-1,s,p,dp) || find(i-1,j,s,p,dp);\\n        return dp[i][j] = false;\\n    }\\npublic:\\n    bool isMatch(string s, string p) {\\n        int n = s.size(),m = p.size();\\n        if(n == 0 && m == 0) return true;\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        return find(n-1,m-1,s,p,dp);\\n    }\\n};\\n"
                    },
                    {
                        "username": "simply_arko",
                        "content": "[Pic](https://drive.google.com/file/d/1VdNsh1Pi9KF7ITzvl-ImFqjDS08dcOrQ/view?usp=drive_link)\\nHuhhhh!.....What is this test case???"
                    },
                    {
                        "username": "asmithey",
                        "content": "I have no idea, but I\\'ve seen this before on other test cases. Has anyone been able to solve it recently, or is the problem just broken?"
                    },
                    {
                        "username": "pratikshaw8",
                        "content": "Same question. WTH is this?\\n"
                    },
                    {
                        "username": "khibach2004",
                        "content": "little hint for u guys this is exactly the same to regular expression matching the only different is the condition if that\\'s it\\nai ng Vi\\u1EC7t th\\xEC \\u0111\\u1ECDc kh\\xFAc n\\xE0y nha: c\\xE1i b\\xE0i n\\xE0y y chang b\\xE0i 10 leetcode n\\xF3 ch\\u1EC9 kh\\xE1c m\\u1ED7i \\u0111\\xECu ki\\u1EC7n ch\\u1ED7 if thoi c\\xF2n l\\u1EA1i y h\\u1EC7t"
                    }
                ]
            },
            {
                "id": 1965624,
                "content": [
                    {
                        "username": "scarletspeedster2",
                        "content": "Pattern needs pre-processing, remove consecutive \"*\"  from pattern "
                    },
                    {
                        "username": "vansh22559",
                        "content": "Aah faced 7 wrong submissions but still got bit of dopamine when it got passed on 8th attempt.\\nProblem had many edge cases, definitely a difficult one to solve but that\\'s where the fun is."
                    },
                    {
                        "username": "user8272RT",
                        "content": "Got here after doing [10. Regular Expression Matching](https://leetcode.com/problems/regular-expression-matching/), so this was solvable."
                    },
                    {
                        "username": "dvakar",
                        "content": "1. s =  `\"aab\"`, p =  `\"c*a*b\"`\n2. s =  `\"adceb\"`, p =  `\"*a*b\"`\n3. s =  `\"abbabbbaabaaabbbbbabbabbabbbabbaaabbbababbabaaabbab\"`, p =  `\"*aabb***aa**a******aa*\"`"
                    },
                    {
                        "username": "dmigalin",
                        "content": "What is wrong with 983 testcase?\\n\\ns = \"acdcb\"\\np = \"a*c?b\"\\n\\nMy answer is True, because p contains \"*\" -  the symbol that matches any sequence.\\nExpected answer is False.\\n\\nWhats wrong?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "`*` matches any sequence, it's true. but it doesn't mean you can return true as soon as you meet `*`\n\nexample -> \nafter `*` in the pattern there is a character, \"c\". so this \"c\" must match with one \"c\" from the check string.\nif \"c\" in the pattern matches the first \"c\" in the check string, we have:\n  \"a\" = \"a\"\n  `*` = \"\" (empty)\n  \"c\" = \"c\"\n  -> then \"?b\" must match \"dcb\" -> not possible\nif \"c\" in the pattern matches the second \"c\" in the check string:\n  \"a\" = \"a\"\n  `*` = \"cd\"\n  \"c\" = \"c\"\n  -> then \"?b\" must match \"b\" -> not possible, too\n\ntherefore, expected answer is false"
                    },
                    {
                        "username": "aq41",
                        "content": "so dumbass. why the hell * should be equal to empty string"
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "leetcode please provide some solid example input"
                    },
                    {
                        "username": "dpvidyasagar",
                        "content": "Hi,\\nPlease help! this code is failing in last test case, I don\\'t know why \\nclass Solution {\\nprivate:\\n    bool find(int i,int j,string s,string p,vector<vector<int>>& dp){\\n        if(i<0 || j<0){\\n            if(i<0 && j<0) return true;\\n            if(i>=0 && j<0) return false;\\n            if(i<0 && j>=0){\\n                while(j>=0){\\n                    if(p[j--]!= \\'*\\') return false;\\n                }\\n                return true;\\n            }\\n            return false;\\n        }\\n        if(dp[i][j] != -1) return dp[i][j];\\n        if(s[i] == p[j] || p[j] == \\'?\\') return dp[i][j] = find(i-1,j-1,s,p,dp);\\n        if(p[j] == \\'*\\') return dp[i][j] = find(i,j-1,s,p,dp) || find(i-1,j,s,p,dp);\\n        return dp[i][j] = false;\\n    }\\npublic:\\n    bool isMatch(string s, string p) {\\n        int n = s.size(),m = p.size();\\n        if(n == 0 && m == 0) return true;\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        return find(n-1,m-1,s,p,dp);\\n    }\\n};\\n"
                    },
                    {
                        "username": "simply_arko",
                        "content": "[Pic](https://drive.google.com/file/d/1VdNsh1Pi9KF7ITzvl-ImFqjDS08dcOrQ/view?usp=drive_link)\\nHuhhhh!.....What is this test case???"
                    },
                    {
                        "username": "asmithey",
                        "content": "I have no idea, but I\\'ve seen this before on other test cases. Has anyone been able to solve it recently, or is the problem just broken?"
                    },
                    {
                        "username": "pratikshaw8",
                        "content": "Same question. WTH is this?\\n"
                    },
                    {
                        "username": "khibach2004",
                        "content": "little hint for u guys this is exactly the same to regular expression matching the only different is the condition if that\\'s it\\nai ng Vi\\u1EC7t th\\xEC \\u0111\\u1ECDc kh\\xFAc n\\xE0y nha: c\\xE1i b\\xE0i n\\xE0y y chang b\\xE0i 10 leetcode n\\xF3 ch\\u1EC9 kh\\xE1c m\\u1ED7i \\u0111\\xECu ki\\u1EC7n ch\\u1ED7 if thoi c\\xF2n l\\u1EA1i y h\\u1EC7t"
                    }
                ]
            },
            {
                "id": 1960244,
                "content": [
                    {
                        "username": "scarletspeedster2",
                        "content": "Pattern needs pre-processing, remove consecutive \"*\"  from pattern "
                    },
                    {
                        "username": "vansh22559",
                        "content": "Aah faced 7 wrong submissions but still got bit of dopamine when it got passed on 8th attempt.\\nProblem had many edge cases, definitely a difficult one to solve but that\\'s where the fun is."
                    },
                    {
                        "username": "user8272RT",
                        "content": "Got here after doing [10. Regular Expression Matching](https://leetcode.com/problems/regular-expression-matching/), so this was solvable."
                    },
                    {
                        "username": "dvakar",
                        "content": "1. s =  `\"aab\"`, p =  `\"c*a*b\"`\n2. s =  `\"adceb\"`, p =  `\"*a*b\"`\n3. s =  `\"abbabbbaabaaabbbbbabbabbabbbabbaaabbbababbabaaabbab\"`, p =  `\"*aabb***aa**a******aa*\"`"
                    },
                    {
                        "username": "dmigalin",
                        "content": "What is wrong with 983 testcase?\\n\\ns = \"acdcb\"\\np = \"a*c?b\"\\n\\nMy answer is True, because p contains \"*\" -  the symbol that matches any sequence.\\nExpected answer is False.\\n\\nWhats wrong?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "`*` matches any sequence, it's true. but it doesn't mean you can return true as soon as you meet `*`\n\nexample -> \nafter `*` in the pattern there is a character, \"c\". so this \"c\" must match with one \"c\" from the check string.\nif \"c\" in the pattern matches the first \"c\" in the check string, we have:\n  \"a\" = \"a\"\n  `*` = \"\" (empty)\n  \"c\" = \"c\"\n  -> then \"?b\" must match \"dcb\" -> not possible\nif \"c\" in the pattern matches the second \"c\" in the check string:\n  \"a\" = \"a\"\n  `*` = \"cd\"\n  \"c\" = \"c\"\n  -> then \"?b\" must match \"b\" -> not possible, too\n\ntherefore, expected answer is false"
                    },
                    {
                        "username": "aq41",
                        "content": "so dumbass. why the hell * should be equal to empty string"
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "leetcode please provide some solid example input"
                    },
                    {
                        "username": "dpvidyasagar",
                        "content": "Hi,\\nPlease help! this code is failing in last test case, I don\\'t know why \\nclass Solution {\\nprivate:\\n    bool find(int i,int j,string s,string p,vector<vector<int>>& dp){\\n        if(i<0 || j<0){\\n            if(i<0 && j<0) return true;\\n            if(i>=0 && j<0) return false;\\n            if(i<0 && j>=0){\\n                while(j>=0){\\n                    if(p[j--]!= \\'*\\') return false;\\n                }\\n                return true;\\n            }\\n            return false;\\n        }\\n        if(dp[i][j] != -1) return dp[i][j];\\n        if(s[i] == p[j] || p[j] == \\'?\\') return dp[i][j] = find(i-1,j-1,s,p,dp);\\n        if(p[j] == \\'*\\') return dp[i][j] = find(i,j-1,s,p,dp) || find(i-1,j,s,p,dp);\\n        return dp[i][j] = false;\\n    }\\npublic:\\n    bool isMatch(string s, string p) {\\n        int n = s.size(),m = p.size();\\n        if(n == 0 && m == 0) return true;\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        return find(n-1,m-1,s,p,dp);\\n    }\\n};\\n"
                    },
                    {
                        "username": "simply_arko",
                        "content": "[Pic](https://drive.google.com/file/d/1VdNsh1Pi9KF7ITzvl-ImFqjDS08dcOrQ/view?usp=drive_link)\\nHuhhhh!.....What is this test case???"
                    },
                    {
                        "username": "asmithey",
                        "content": "I have no idea, but I\\'ve seen this before on other test cases. Has anyone been able to solve it recently, or is the problem just broken?"
                    },
                    {
                        "username": "pratikshaw8",
                        "content": "Same question. WTH is this?\\n"
                    },
                    {
                        "username": "khibach2004",
                        "content": "little hint for u guys this is exactly the same to regular expression matching the only different is the condition if that\\'s it\\nai ng Vi\\u1EC7t th\\xEC \\u0111\\u1ECDc kh\\xFAc n\\xE0y nha: c\\xE1i b\\xE0i n\\xE0y y chang b\\xE0i 10 leetcode n\\xF3 ch\\u1EC9 kh\\xE1c m\\u1ED7i \\u0111\\xECu ki\\u1EC7n ch\\u1ED7 if thoi c\\xF2n l\\u1EA1i y h\\u1EC7t"
                    }
                ]
            },
            {
                "id": 1947451,
                "content": [
                    {
                        "username": "scarletspeedster2",
                        "content": "Pattern needs pre-processing, remove consecutive \"*\"  from pattern "
                    },
                    {
                        "username": "vansh22559",
                        "content": "Aah faced 7 wrong submissions but still got bit of dopamine when it got passed on 8th attempt.\\nProblem had many edge cases, definitely a difficult one to solve but that\\'s where the fun is."
                    },
                    {
                        "username": "user8272RT",
                        "content": "Got here after doing [10. Regular Expression Matching](https://leetcode.com/problems/regular-expression-matching/), so this was solvable."
                    },
                    {
                        "username": "dvakar",
                        "content": "1. s =  `\"aab\"`, p =  `\"c*a*b\"`\n2. s =  `\"adceb\"`, p =  `\"*a*b\"`\n3. s =  `\"abbabbbaabaaabbbbbabbabbabbbabbaaabbbababbabaaabbab\"`, p =  `\"*aabb***aa**a******aa*\"`"
                    },
                    {
                        "username": "dmigalin",
                        "content": "What is wrong with 983 testcase?\\n\\ns = \"acdcb\"\\np = \"a*c?b\"\\n\\nMy answer is True, because p contains \"*\" -  the symbol that matches any sequence.\\nExpected answer is False.\\n\\nWhats wrong?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "`*` matches any sequence, it's true. but it doesn't mean you can return true as soon as you meet `*`\n\nexample -> \nafter `*` in the pattern there is a character, \"c\". so this \"c\" must match with one \"c\" from the check string.\nif \"c\" in the pattern matches the first \"c\" in the check string, we have:\n  \"a\" = \"a\"\n  `*` = \"\" (empty)\n  \"c\" = \"c\"\n  -> then \"?b\" must match \"dcb\" -> not possible\nif \"c\" in the pattern matches the second \"c\" in the check string:\n  \"a\" = \"a\"\n  `*` = \"cd\"\n  \"c\" = \"c\"\n  -> then \"?b\" must match \"b\" -> not possible, too\n\ntherefore, expected answer is false"
                    },
                    {
                        "username": "aq41",
                        "content": "so dumbass. why the hell * should be equal to empty string"
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "leetcode please provide some solid example input"
                    },
                    {
                        "username": "dpvidyasagar",
                        "content": "Hi,\\nPlease help! this code is failing in last test case, I don\\'t know why \\nclass Solution {\\nprivate:\\n    bool find(int i,int j,string s,string p,vector<vector<int>>& dp){\\n        if(i<0 || j<0){\\n            if(i<0 && j<0) return true;\\n            if(i>=0 && j<0) return false;\\n            if(i<0 && j>=0){\\n                while(j>=0){\\n                    if(p[j--]!= \\'*\\') return false;\\n                }\\n                return true;\\n            }\\n            return false;\\n        }\\n        if(dp[i][j] != -1) return dp[i][j];\\n        if(s[i] == p[j] || p[j] == \\'?\\') return dp[i][j] = find(i-1,j-1,s,p,dp);\\n        if(p[j] == \\'*\\') return dp[i][j] = find(i,j-1,s,p,dp) || find(i-1,j,s,p,dp);\\n        return dp[i][j] = false;\\n    }\\npublic:\\n    bool isMatch(string s, string p) {\\n        int n = s.size(),m = p.size();\\n        if(n == 0 && m == 0) return true;\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        return find(n-1,m-1,s,p,dp);\\n    }\\n};\\n"
                    },
                    {
                        "username": "simply_arko",
                        "content": "[Pic](https://drive.google.com/file/d/1VdNsh1Pi9KF7ITzvl-ImFqjDS08dcOrQ/view?usp=drive_link)\\nHuhhhh!.....What is this test case???"
                    },
                    {
                        "username": "asmithey",
                        "content": "I have no idea, but I\\'ve seen this before on other test cases. Has anyone been able to solve it recently, or is the problem just broken?"
                    },
                    {
                        "username": "pratikshaw8",
                        "content": "Same question. WTH is this?\\n"
                    },
                    {
                        "username": "khibach2004",
                        "content": "little hint for u guys this is exactly the same to regular expression matching the only different is the condition if that\\'s it\\nai ng Vi\\u1EC7t th\\xEC \\u0111\\u1ECDc kh\\xFAc n\\xE0y nha: c\\xE1i b\\xE0i n\\xE0y y chang b\\xE0i 10 leetcode n\\xF3 ch\\u1EC9 kh\\xE1c m\\u1ED7i \\u0111\\xECu ki\\u1EC7n ch\\u1ED7 if thoi c\\xF2n l\\u1EA1i y h\\u1EC7t"
                    }
                ]
            },
            {
                "id": 1903193,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "I was scared of this question for too long, for nothing tbh"
                    },
                    {
                        "username": "prakharu040",
                        "content": "My solution is failing on 1811/1811 case can anyone help as to why is this happening\\n\\n\\nclass Solution {\\n    HashMap<String,Boolean> map;\\n    \\n    public boolean regex(int i,int j,String s,String p)\\n    {\\n        if(j<0)\\n        {\\n            return i<0;\\n        }\\n        String key = String.valueOf(i)+\"#\"+String.valueOf(j);\\n        if(map.containsKey(key))\\n            return map.get(key);\\n        boolean charEquals = false;\\n        if(i>=0 && (s.charAt(i) == p.charAt(j) || p.charAt(j) == \\'?\\'))\\n        {\\n            if(regex(i-1,j-1,s,p))\\n            {\\n                map.put(key,true);\\n                return true;\\n            }\\n                \\n        }\\n        else if(p.charAt(j) == \\'*\\')\\n        {\\n            for(int m =0;m<=i+1;m++)\\n            {\\n                if(regex(i-m,j-1,s,p))\\n                {\\n                    map.put(key,true);\\n                    return true;\\n                }\\n            }\\n        }\\n        map.put(key,false);\\n        return false;\\n            \\n    }\\n    \\n    \\n    public boolean isMatch(String s, String p) {\\n        map = new HashMap<>();\\n        return regex(s.length()-1,p.length()-1,s,p);\\n    }\\n}"
                    },
                    {
                        "username": "prnvvarshney",
                        "content": "public class Solution {\\n    public boolean isMatch(String s, String p) {\\n        boolean[][] match=new boolean[s.length()+1][p.length()+1];\\n        match[s.length()][p.length()]=true;\\n        for(int i=p.length()-1;i>=0;i--){\\n            if(p.charAt(i)!=\\'*\\')\\n                break;\\n            else\\n                match[s.length()][i]=true;\\n        }\\n        for(int i=s.length()-1;i>=0;i--){\\n            for(int j=p.length()-1;j>=0;j--){\\n                if(s.charAt(i)==p.charAt(j)||p.charAt(j)==\\'?\\')\\n                        match[i][j]=match[i+1][j+1];\\n                else if(p.charAt(j)==\\'*\\')\\n                        match[i][j]=match[i+1][j]||match[i][j+1];\\n                else\\n                    match[i][j]=false;\\n            }\\n        }\\n        return match[0][0];\\n    }\\n}"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "I'm trying to wrap my mind around this: If the current pattern character is a star (p[0] == '*'), then there are two possible situations:\n        a. The star matches no characters, and hence the answer is isMatch(s, p[1:]).\n        b. The star matches one or more characters, and so the answer is isMatch(s[1:], p).\"\nCan someone give an example of input s and p where \"hence the answer is isMatch(s, p[1:])\"?\n\nTo understand case (a), first note that explaination \"* matches no character\" can be misleading. \n            s = \"adceb\"\n            p = \"*a*b\"\n\n            It's just saying solution is either in:\n                s = 'adceb'         <-- case (a) will evaluate to True\n                p = 'a*b'\n                    or\n                s = 'dceb'          <-- case (b) will evaluate to False\n                p = '*a*b'\n\n        To understand case (b)\n            s = \"a9absfkls\"\n            p = \"*abs*\"\n            helper(s[1:], p) True --> s[1:] = '9absfkls' ('*a': Case when the star matches one or more character)\n            helper(s, p[1:]) False --> p[1:] = 'abs*'"
                    },
                    {
                        "username": "hunnyjain711",
                        "content": "In the testcase s=\"abcabczzzde\", p=\"*abc???de*\" are they matching \"*abc\" with \"abcabc\"?\n\nedit: I guess yes, in this test case\ns=\"abefcdgiescdfimde\", p=\"ab*cd?i*de\"  leading suffix after \"*de\" are matched to0."
                    },
                    {
                        "username": "Bold_Bruiser",
                        "content": "s=\"aab\" p=\"a*a*b\"\nhow this is false??"
                    },
                    {
                        "username": "jayanth-c137",
                        "content": "` class Solution {`\\n`public:`\\n  `int tr(string& s,string& p,int i,int j,vector<vector<int>>& dp){`\\n      `  // cout<<i<<\" \"<<j<<\" \"<<dp[i][j]<<endl;`\\n   `     if(dp[i][j]!=-1)return dp[i][j];`\\n       ` if(j>=p.length() && i<s.length())return dp[i][j]=0;`\\n     `   if(j==p.length() && i==s.length()){`\\n       ` return dp[i][j]=1;`\\n       ` }`\\n    `    if(i>=s.length() && j<p.length()){`\\n         `   for(;j<p.length();j++){`\\n             `   if(p[j]!=\\'*\\')return dp[i][j]=0;`\\n         `   }`\\n       `     return dp[i][j]=1;`\\n     `   }`\\n        \\n        int ans;\\n        if(p[j]==\\'?\\'){\\n            ans = tr(s,p,i+1,j+1,dp);\\n                return dp[i][j]=ans;\\n        }\\n        else if(p[j]==\\'*\\'){\\n           int ans1 = tr(s,p,i,j+1,dp);\\n            ans = tr(s,p,i+1,j,dp);\\n                return dp[i][j]=(ans|ans1);\\n        }\\n        else {\\n            if(s[i]!=p[j]){\\n            return dp[i][j]=0;\\n            }\\n            else{\\n                ans = tr(s,p,i+1,j+1,dp);\\n            return dp[i][j]=ans;\\n            } \\n        }\\n\\n    }\\n    bool isMatch(string s, string p) {\\n        vector<vector<int>> dp(2001,vector<int>(2001,-1));\\n        if(s==\"\"){\\n            int i;\\n            for(i=0;i<p.length();i++){\\n                if(p[i]!=\\'*\\')return false;\\n            }\\n            return true;\\n        }\\n        int ans = tr(s,p,0,0,dp);\\n        if(ans==1)return true;\\n        else return false;\\n    }`\\n`};`\\n\\n\\ni\\'m getting tle for this , can someone please help\\n"
                    },
                    {
                        "username": "satyam_0405",
                        "content": "Please give 1 or 2 more testcases so that we can clearly understand the usage of  \\'*\\' in detail"
                    },
                    {
                        "username": "easy_problems_hunter",
                        "content": "clumsy questiion"
                    },
                    {
                        "username": "rawan9000",
                        "content": "Any answer please , Why the expected result is false  not true incase  s = \"acdcb\" and p = `  a*c?b` , \nalthough the mentioned point that '*' Matches any sequence of characters (including the empty sequence)."
                    },
                    {
                        "username": "SleekPanther",
                        "content": "I read it like this going left to right in the pattern:\\n1) `a` from pattern matches the 1st \"a\" from the string\\n2) `*` from pattern can match \"cd\", characters 2 and 3 from the string\\n3) `c` from pattern matches \"c\", the 4th character in the string\\n4) `?` from pattern matches any SINGLE character, the last \"b\"\\n5) `b` from pattern doesn\\'t match anything as we ran out"
                    }
                ]
            },
            {
                "id": 1872982,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "I was scared of this question for too long, for nothing tbh"
                    },
                    {
                        "username": "prakharu040",
                        "content": "My solution is failing on 1811/1811 case can anyone help as to why is this happening\\n\\n\\nclass Solution {\\n    HashMap<String,Boolean> map;\\n    \\n    public boolean regex(int i,int j,String s,String p)\\n    {\\n        if(j<0)\\n        {\\n            return i<0;\\n        }\\n        String key = String.valueOf(i)+\"#\"+String.valueOf(j);\\n        if(map.containsKey(key))\\n            return map.get(key);\\n        boolean charEquals = false;\\n        if(i>=0 && (s.charAt(i) == p.charAt(j) || p.charAt(j) == \\'?\\'))\\n        {\\n            if(regex(i-1,j-1,s,p))\\n            {\\n                map.put(key,true);\\n                return true;\\n            }\\n                \\n        }\\n        else if(p.charAt(j) == \\'*\\')\\n        {\\n            for(int m =0;m<=i+1;m++)\\n            {\\n                if(regex(i-m,j-1,s,p))\\n                {\\n                    map.put(key,true);\\n                    return true;\\n                }\\n            }\\n        }\\n        map.put(key,false);\\n        return false;\\n            \\n    }\\n    \\n    \\n    public boolean isMatch(String s, String p) {\\n        map = new HashMap<>();\\n        return regex(s.length()-1,p.length()-1,s,p);\\n    }\\n}"
                    },
                    {
                        "username": "prnvvarshney",
                        "content": "public class Solution {\\n    public boolean isMatch(String s, String p) {\\n        boolean[][] match=new boolean[s.length()+1][p.length()+1];\\n        match[s.length()][p.length()]=true;\\n        for(int i=p.length()-1;i>=0;i--){\\n            if(p.charAt(i)!=\\'*\\')\\n                break;\\n            else\\n                match[s.length()][i]=true;\\n        }\\n        for(int i=s.length()-1;i>=0;i--){\\n            for(int j=p.length()-1;j>=0;j--){\\n                if(s.charAt(i)==p.charAt(j)||p.charAt(j)==\\'?\\')\\n                        match[i][j]=match[i+1][j+1];\\n                else if(p.charAt(j)==\\'*\\')\\n                        match[i][j]=match[i+1][j]||match[i][j+1];\\n                else\\n                    match[i][j]=false;\\n            }\\n        }\\n        return match[0][0];\\n    }\\n}"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "I'm trying to wrap my mind around this: If the current pattern character is a star (p[0] == '*'), then there are two possible situations:\n        a. The star matches no characters, and hence the answer is isMatch(s, p[1:]).\n        b. The star matches one or more characters, and so the answer is isMatch(s[1:], p).\"\nCan someone give an example of input s and p where \"hence the answer is isMatch(s, p[1:])\"?\n\nTo understand case (a), first note that explaination \"* matches no character\" can be misleading. \n            s = \"adceb\"\n            p = \"*a*b\"\n\n            It's just saying solution is either in:\n                s = 'adceb'         <-- case (a) will evaluate to True\n                p = 'a*b'\n                    or\n                s = 'dceb'          <-- case (b) will evaluate to False\n                p = '*a*b'\n\n        To understand case (b)\n            s = \"a9absfkls\"\n            p = \"*abs*\"\n            helper(s[1:], p) True --> s[1:] = '9absfkls' ('*a': Case when the star matches one or more character)\n            helper(s, p[1:]) False --> p[1:] = 'abs*'"
                    },
                    {
                        "username": "hunnyjain711",
                        "content": "In the testcase s=\"abcabczzzde\", p=\"*abc???de*\" are they matching \"*abc\" with \"abcabc\"?\n\nedit: I guess yes, in this test case\ns=\"abefcdgiescdfimde\", p=\"ab*cd?i*de\"  leading suffix after \"*de\" are matched to0."
                    },
                    {
                        "username": "Bold_Bruiser",
                        "content": "s=\"aab\" p=\"a*a*b\"\nhow this is false??"
                    },
                    {
                        "username": "jayanth-c137",
                        "content": "` class Solution {`\\n`public:`\\n  `int tr(string& s,string& p,int i,int j,vector<vector<int>>& dp){`\\n      `  // cout<<i<<\" \"<<j<<\" \"<<dp[i][j]<<endl;`\\n   `     if(dp[i][j]!=-1)return dp[i][j];`\\n       ` if(j>=p.length() && i<s.length())return dp[i][j]=0;`\\n     `   if(j==p.length() && i==s.length()){`\\n       ` return dp[i][j]=1;`\\n       ` }`\\n    `    if(i>=s.length() && j<p.length()){`\\n         `   for(;j<p.length();j++){`\\n             `   if(p[j]!=\\'*\\')return dp[i][j]=0;`\\n         `   }`\\n       `     return dp[i][j]=1;`\\n     `   }`\\n        \\n        int ans;\\n        if(p[j]==\\'?\\'){\\n            ans = tr(s,p,i+1,j+1,dp);\\n                return dp[i][j]=ans;\\n        }\\n        else if(p[j]==\\'*\\'){\\n           int ans1 = tr(s,p,i,j+1,dp);\\n            ans = tr(s,p,i+1,j,dp);\\n                return dp[i][j]=(ans|ans1);\\n        }\\n        else {\\n            if(s[i]!=p[j]){\\n            return dp[i][j]=0;\\n            }\\n            else{\\n                ans = tr(s,p,i+1,j+1,dp);\\n            return dp[i][j]=ans;\\n            } \\n        }\\n\\n    }\\n    bool isMatch(string s, string p) {\\n        vector<vector<int>> dp(2001,vector<int>(2001,-1));\\n        if(s==\"\"){\\n            int i;\\n            for(i=0;i<p.length();i++){\\n                if(p[i]!=\\'*\\')return false;\\n            }\\n            return true;\\n        }\\n        int ans = tr(s,p,0,0,dp);\\n        if(ans==1)return true;\\n        else return false;\\n    }`\\n`};`\\n\\n\\ni\\'m getting tle for this , can someone please help\\n"
                    },
                    {
                        "username": "satyam_0405",
                        "content": "Please give 1 or 2 more testcases so that we can clearly understand the usage of  \\'*\\' in detail"
                    },
                    {
                        "username": "easy_problems_hunter",
                        "content": "clumsy questiion"
                    },
                    {
                        "username": "rawan9000",
                        "content": "Any answer please , Why the expected result is false  not true incase  s = \"acdcb\" and p = `  a*c?b` , \nalthough the mentioned point that '*' Matches any sequence of characters (including the empty sequence)."
                    },
                    {
                        "username": "SleekPanther",
                        "content": "I read it like this going left to right in the pattern:\\n1) `a` from pattern matches the 1st \"a\" from the string\\n2) `*` from pattern can match \"cd\", characters 2 and 3 from the string\\n3) `c` from pattern matches \"c\", the 4th character in the string\\n4) `?` from pattern matches any SINGLE character, the last \"b\"\\n5) `b` from pattern doesn\\'t match anything as we ran out"
                    }
                ]
            },
            {
                "id": 1868098,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "I was scared of this question for too long, for nothing tbh"
                    },
                    {
                        "username": "prakharu040",
                        "content": "My solution is failing on 1811/1811 case can anyone help as to why is this happening\\n\\n\\nclass Solution {\\n    HashMap<String,Boolean> map;\\n    \\n    public boolean regex(int i,int j,String s,String p)\\n    {\\n        if(j<0)\\n        {\\n            return i<0;\\n        }\\n        String key = String.valueOf(i)+\"#\"+String.valueOf(j);\\n        if(map.containsKey(key))\\n            return map.get(key);\\n        boolean charEquals = false;\\n        if(i>=0 && (s.charAt(i) == p.charAt(j) || p.charAt(j) == \\'?\\'))\\n        {\\n            if(regex(i-1,j-1,s,p))\\n            {\\n                map.put(key,true);\\n                return true;\\n            }\\n                \\n        }\\n        else if(p.charAt(j) == \\'*\\')\\n        {\\n            for(int m =0;m<=i+1;m++)\\n            {\\n                if(regex(i-m,j-1,s,p))\\n                {\\n                    map.put(key,true);\\n                    return true;\\n                }\\n            }\\n        }\\n        map.put(key,false);\\n        return false;\\n            \\n    }\\n    \\n    \\n    public boolean isMatch(String s, String p) {\\n        map = new HashMap<>();\\n        return regex(s.length()-1,p.length()-1,s,p);\\n    }\\n}"
                    },
                    {
                        "username": "prnvvarshney",
                        "content": "public class Solution {\\n    public boolean isMatch(String s, String p) {\\n        boolean[][] match=new boolean[s.length()+1][p.length()+1];\\n        match[s.length()][p.length()]=true;\\n        for(int i=p.length()-1;i>=0;i--){\\n            if(p.charAt(i)!=\\'*\\')\\n                break;\\n            else\\n                match[s.length()][i]=true;\\n        }\\n        for(int i=s.length()-1;i>=0;i--){\\n            for(int j=p.length()-1;j>=0;j--){\\n                if(s.charAt(i)==p.charAt(j)||p.charAt(j)==\\'?\\')\\n                        match[i][j]=match[i+1][j+1];\\n                else if(p.charAt(j)==\\'*\\')\\n                        match[i][j]=match[i+1][j]||match[i][j+1];\\n                else\\n                    match[i][j]=false;\\n            }\\n        }\\n        return match[0][0];\\n    }\\n}"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "I'm trying to wrap my mind around this: If the current pattern character is a star (p[0] == '*'), then there are two possible situations:\n        a. The star matches no characters, and hence the answer is isMatch(s, p[1:]).\n        b. The star matches one or more characters, and so the answer is isMatch(s[1:], p).\"\nCan someone give an example of input s and p where \"hence the answer is isMatch(s, p[1:])\"?\n\nTo understand case (a), first note that explaination \"* matches no character\" can be misleading. \n            s = \"adceb\"\n            p = \"*a*b\"\n\n            It's just saying solution is either in:\n                s = 'adceb'         <-- case (a) will evaluate to True\n                p = 'a*b'\n                    or\n                s = 'dceb'          <-- case (b) will evaluate to False\n                p = '*a*b'\n\n        To understand case (b)\n            s = \"a9absfkls\"\n            p = \"*abs*\"\n            helper(s[1:], p) True --> s[1:] = '9absfkls' ('*a': Case when the star matches one or more character)\n            helper(s, p[1:]) False --> p[1:] = 'abs*'"
                    },
                    {
                        "username": "hunnyjain711",
                        "content": "In the testcase s=\"abcabczzzde\", p=\"*abc???de*\" are they matching \"*abc\" with \"abcabc\"?\n\nedit: I guess yes, in this test case\ns=\"abefcdgiescdfimde\", p=\"ab*cd?i*de\"  leading suffix after \"*de\" are matched to0."
                    },
                    {
                        "username": "Bold_Bruiser",
                        "content": "s=\"aab\" p=\"a*a*b\"\nhow this is false??"
                    },
                    {
                        "username": "jayanth-c137",
                        "content": "` class Solution {`\\n`public:`\\n  `int tr(string& s,string& p,int i,int j,vector<vector<int>>& dp){`\\n      `  // cout<<i<<\" \"<<j<<\" \"<<dp[i][j]<<endl;`\\n   `     if(dp[i][j]!=-1)return dp[i][j];`\\n       ` if(j>=p.length() && i<s.length())return dp[i][j]=0;`\\n     `   if(j==p.length() && i==s.length()){`\\n       ` return dp[i][j]=1;`\\n       ` }`\\n    `    if(i>=s.length() && j<p.length()){`\\n         `   for(;j<p.length();j++){`\\n             `   if(p[j]!=\\'*\\')return dp[i][j]=0;`\\n         `   }`\\n       `     return dp[i][j]=1;`\\n     `   }`\\n        \\n        int ans;\\n        if(p[j]==\\'?\\'){\\n            ans = tr(s,p,i+1,j+1,dp);\\n                return dp[i][j]=ans;\\n        }\\n        else if(p[j]==\\'*\\'){\\n           int ans1 = tr(s,p,i,j+1,dp);\\n            ans = tr(s,p,i+1,j,dp);\\n                return dp[i][j]=(ans|ans1);\\n        }\\n        else {\\n            if(s[i]!=p[j]){\\n            return dp[i][j]=0;\\n            }\\n            else{\\n                ans = tr(s,p,i+1,j+1,dp);\\n            return dp[i][j]=ans;\\n            } \\n        }\\n\\n    }\\n    bool isMatch(string s, string p) {\\n        vector<vector<int>> dp(2001,vector<int>(2001,-1));\\n        if(s==\"\"){\\n            int i;\\n            for(i=0;i<p.length();i++){\\n                if(p[i]!=\\'*\\')return false;\\n            }\\n            return true;\\n        }\\n        int ans = tr(s,p,0,0,dp);\\n        if(ans==1)return true;\\n        else return false;\\n    }`\\n`};`\\n\\n\\ni\\'m getting tle for this , can someone please help\\n"
                    },
                    {
                        "username": "satyam_0405",
                        "content": "Please give 1 or 2 more testcases so that we can clearly understand the usage of  \\'*\\' in detail"
                    },
                    {
                        "username": "easy_problems_hunter",
                        "content": "clumsy questiion"
                    },
                    {
                        "username": "rawan9000",
                        "content": "Any answer please , Why the expected result is false  not true incase  s = \"acdcb\" and p = `  a*c?b` , \nalthough the mentioned point that '*' Matches any sequence of characters (including the empty sequence)."
                    },
                    {
                        "username": "SleekPanther",
                        "content": "I read it like this going left to right in the pattern:\\n1) `a` from pattern matches the 1st \"a\" from the string\\n2) `*` from pattern can match \"cd\", characters 2 and 3 from the string\\n3) `c` from pattern matches \"c\", the 4th character in the string\\n4) `?` from pattern matches any SINGLE character, the last \"b\"\\n5) `b` from pattern doesn\\'t match anything as we ran out"
                    }
                ]
            },
            {
                "id": 1864599,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "I was scared of this question for too long, for nothing tbh"
                    },
                    {
                        "username": "prakharu040",
                        "content": "My solution is failing on 1811/1811 case can anyone help as to why is this happening\\n\\n\\nclass Solution {\\n    HashMap<String,Boolean> map;\\n    \\n    public boolean regex(int i,int j,String s,String p)\\n    {\\n        if(j<0)\\n        {\\n            return i<0;\\n        }\\n        String key = String.valueOf(i)+\"#\"+String.valueOf(j);\\n        if(map.containsKey(key))\\n            return map.get(key);\\n        boolean charEquals = false;\\n        if(i>=0 && (s.charAt(i) == p.charAt(j) || p.charAt(j) == \\'?\\'))\\n        {\\n            if(regex(i-1,j-1,s,p))\\n            {\\n                map.put(key,true);\\n                return true;\\n            }\\n                \\n        }\\n        else if(p.charAt(j) == \\'*\\')\\n        {\\n            for(int m =0;m<=i+1;m++)\\n            {\\n                if(regex(i-m,j-1,s,p))\\n                {\\n                    map.put(key,true);\\n                    return true;\\n                }\\n            }\\n        }\\n        map.put(key,false);\\n        return false;\\n            \\n    }\\n    \\n    \\n    public boolean isMatch(String s, String p) {\\n        map = new HashMap<>();\\n        return regex(s.length()-1,p.length()-1,s,p);\\n    }\\n}"
                    },
                    {
                        "username": "prnvvarshney",
                        "content": "public class Solution {\\n    public boolean isMatch(String s, String p) {\\n        boolean[][] match=new boolean[s.length()+1][p.length()+1];\\n        match[s.length()][p.length()]=true;\\n        for(int i=p.length()-1;i>=0;i--){\\n            if(p.charAt(i)!=\\'*\\')\\n                break;\\n            else\\n                match[s.length()][i]=true;\\n        }\\n        for(int i=s.length()-1;i>=0;i--){\\n            for(int j=p.length()-1;j>=0;j--){\\n                if(s.charAt(i)==p.charAt(j)||p.charAt(j)==\\'?\\')\\n                        match[i][j]=match[i+1][j+1];\\n                else if(p.charAt(j)==\\'*\\')\\n                        match[i][j]=match[i+1][j]||match[i][j+1];\\n                else\\n                    match[i][j]=false;\\n            }\\n        }\\n        return match[0][0];\\n    }\\n}"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "I'm trying to wrap my mind around this: If the current pattern character is a star (p[0] == '*'), then there are two possible situations:\n        a. The star matches no characters, and hence the answer is isMatch(s, p[1:]).\n        b. The star matches one or more characters, and so the answer is isMatch(s[1:], p).\"\nCan someone give an example of input s and p where \"hence the answer is isMatch(s, p[1:])\"?\n\nTo understand case (a), first note that explaination \"* matches no character\" can be misleading. \n            s = \"adceb\"\n            p = \"*a*b\"\n\n            It's just saying solution is either in:\n                s = 'adceb'         <-- case (a) will evaluate to True\n                p = 'a*b'\n                    or\n                s = 'dceb'          <-- case (b) will evaluate to False\n                p = '*a*b'\n\n        To understand case (b)\n            s = \"a9absfkls\"\n            p = \"*abs*\"\n            helper(s[1:], p) True --> s[1:] = '9absfkls' ('*a': Case when the star matches one or more character)\n            helper(s, p[1:]) False --> p[1:] = 'abs*'"
                    },
                    {
                        "username": "hunnyjain711",
                        "content": "In the testcase s=\"abcabczzzde\", p=\"*abc???de*\" are they matching \"*abc\" with \"abcabc\"?\n\nedit: I guess yes, in this test case\ns=\"abefcdgiescdfimde\", p=\"ab*cd?i*de\"  leading suffix after \"*de\" are matched to0."
                    },
                    {
                        "username": "Bold_Bruiser",
                        "content": "s=\"aab\" p=\"a*a*b\"\nhow this is false??"
                    },
                    {
                        "username": "jayanth-c137",
                        "content": "` class Solution {`\\n`public:`\\n  `int tr(string& s,string& p,int i,int j,vector<vector<int>>& dp){`\\n      `  // cout<<i<<\" \"<<j<<\" \"<<dp[i][j]<<endl;`\\n   `     if(dp[i][j]!=-1)return dp[i][j];`\\n       ` if(j>=p.length() && i<s.length())return dp[i][j]=0;`\\n     `   if(j==p.length() && i==s.length()){`\\n       ` return dp[i][j]=1;`\\n       ` }`\\n    `    if(i>=s.length() && j<p.length()){`\\n         `   for(;j<p.length();j++){`\\n             `   if(p[j]!=\\'*\\')return dp[i][j]=0;`\\n         `   }`\\n       `     return dp[i][j]=1;`\\n     `   }`\\n        \\n        int ans;\\n        if(p[j]==\\'?\\'){\\n            ans = tr(s,p,i+1,j+1,dp);\\n                return dp[i][j]=ans;\\n        }\\n        else if(p[j]==\\'*\\'){\\n           int ans1 = tr(s,p,i,j+1,dp);\\n            ans = tr(s,p,i+1,j,dp);\\n                return dp[i][j]=(ans|ans1);\\n        }\\n        else {\\n            if(s[i]!=p[j]){\\n            return dp[i][j]=0;\\n            }\\n            else{\\n                ans = tr(s,p,i+1,j+1,dp);\\n            return dp[i][j]=ans;\\n            } \\n        }\\n\\n    }\\n    bool isMatch(string s, string p) {\\n        vector<vector<int>> dp(2001,vector<int>(2001,-1));\\n        if(s==\"\"){\\n            int i;\\n            for(i=0;i<p.length();i++){\\n                if(p[i]!=\\'*\\')return false;\\n            }\\n            return true;\\n        }\\n        int ans = tr(s,p,0,0,dp);\\n        if(ans==1)return true;\\n        else return false;\\n    }`\\n`};`\\n\\n\\ni\\'m getting tle for this , can someone please help\\n"
                    },
                    {
                        "username": "satyam_0405",
                        "content": "Please give 1 or 2 more testcases so that we can clearly understand the usage of  \\'*\\' in detail"
                    },
                    {
                        "username": "easy_problems_hunter",
                        "content": "clumsy questiion"
                    },
                    {
                        "username": "rawan9000",
                        "content": "Any answer please , Why the expected result is false  not true incase  s = \"acdcb\" and p = `  a*c?b` , \nalthough the mentioned point that '*' Matches any sequence of characters (including the empty sequence)."
                    },
                    {
                        "username": "SleekPanther",
                        "content": "I read it like this going left to right in the pattern:\\n1) `a` from pattern matches the 1st \"a\" from the string\\n2) `*` from pattern can match \"cd\", characters 2 and 3 from the string\\n3) `c` from pattern matches \"c\", the 4th character in the string\\n4) `?` from pattern matches any SINGLE character, the last \"b\"\\n5) `b` from pattern doesn\\'t match anything as we ran out"
                    }
                ]
            },
            {
                "id": 1863944,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "I was scared of this question for too long, for nothing tbh"
                    },
                    {
                        "username": "prakharu040",
                        "content": "My solution is failing on 1811/1811 case can anyone help as to why is this happening\\n\\n\\nclass Solution {\\n    HashMap<String,Boolean> map;\\n    \\n    public boolean regex(int i,int j,String s,String p)\\n    {\\n        if(j<0)\\n        {\\n            return i<0;\\n        }\\n        String key = String.valueOf(i)+\"#\"+String.valueOf(j);\\n        if(map.containsKey(key))\\n            return map.get(key);\\n        boolean charEquals = false;\\n        if(i>=0 && (s.charAt(i) == p.charAt(j) || p.charAt(j) == \\'?\\'))\\n        {\\n            if(regex(i-1,j-1,s,p))\\n            {\\n                map.put(key,true);\\n                return true;\\n            }\\n                \\n        }\\n        else if(p.charAt(j) == \\'*\\')\\n        {\\n            for(int m =0;m<=i+1;m++)\\n            {\\n                if(regex(i-m,j-1,s,p))\\n                {\\n                    map.put(key,true);\\n                    return true;\\n                }\\n            }\\n        }\\n        map.put(key,false);\\n        return false;\\n            \\n    }\\n    \\n    \\n    public boolean isMatch(String s, String p) {\\n        map = new HashMap<>();\\n        return regex(s.length()-1,p.length()-1,s,p);\\n    }\\n}"
                    },
                    {
                        "username": "prnvvarshney",
                        "content": "public class Solution {\\n    public boolean isMatch(String s, String p) {\\n        boolean[][] match=new boolean[s.length()+1][p.length()+1];\\n        match[s.length()][p.length()]=true;\\n        for(int i=p.length()-1;i>=0;i--){\\n            if(p.charAt(i)!=\\'*\\')\\n                break;\\n            else\\n                match[s.length()][i]=true;\\n        }\\n        for(int i=s.length()-1;i>=0;i--){\\n            for(int j=p.length()-1;j>=0;j--){\\n                if(s.charAt(i)==p.charAt(j)||p.charAt(j)==\\'?\\')\\n                        match[i][j]=match[i+1][j+1];\\n                else if(p.charAt(j)==\\'*\\')\\n                        match[i][j]=match[i+1][j]||match[i][j+1];\\n                else\\n                    match[i][j]=false;\\n            }\\n        }\\n        return match[0][0];\\n    }\\n}"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "I'm trying to wrap my mind around this: If the current pattern character is a star (p[0] == '*'), then there are two possible situations:\n        a. The star matches no characters, and hence the answer is isMatch(s, p[1:]).\n        b. The star matches one or more characters, and so the answer is isMatch(s[1:], p).\"\nCan someone give an example of input s and p where \"hence the answer is isMatch(s, p[1:])\"?\n\nTo understand case (a), first note that explaination \"* matches no character\" can be misleading. \n            s = \"adceb\"\n            p = \"*a*b\"\n\n            It's just saying solution is either in:\n                s = 'adceb'         <-- case (a) will evaluate to True\n                p = 'a*b'\n                    or\n                s = 'dceb'          <-- case (b) will evaluate to False\n                p = '*a*b'\n\n        To understand case (b)\n            s = \"a9absfkls\"\n            p = \"*abs*\"\n            helper(s[1:], p) True --> s[1:] = '9absfkls' ('*a': Case when the star matches one or more character)\n            helper(s, p[1:]) False --> p[1:] = 'abs*'"
                    },
                    {
                        "username": "hunnyjain711",
                        "content": "In the testcase s=\"abcabczzzde\", p=\"*abc???de*\" are they matching \"*abc\" with \"abcabc\"?\n\nedit: I guess yes, in this test case\ns=\"abefcdgiescdfimde\", p=\"ab*cd?i*de\"  leading suffix after \"*de\" are matched to0."
                    },
                    {
                        "username": "Bold_Bruiser",
                        "content": "s=\"aab\" p=\"a*a*b\"\nhow this is false??"
                    },
                    {
                        "username": "jayanth-c137",
                        "content": "` class Solution {`\\n`public:`\\n  `int tr(string& s,string& p,int i,int j,vector<vector<int>>& dp){`\\n      `  // cout<<i<<\" \"<<j<<\" \"<<dp[i][j]<<endl;`\\n   `     if(dp[i][j]!=-1)return dp[i][j];`\\n       ` if(j>=p.length() && i<s.length())return dp[i][j]=0;`\\n     `   if(j==p.length() && i==s.length()){`\\n       ` return dp[i][j]=1;`\\n       ` }`\\n    `    if(i>=s.length() && j<p.length()){`\\n         `   for(;j<p.length();j++){`\\n             `   if(p[j]!=\\'*\\')return dp[i][j]=0;`\\n         `   }`\\n       `     return dp[i][j]=1;`\\n     `   }`\\n        \\n        int ans;\\n        if(p[j]==\\'?\\'){\\n            ans = tr(s,p,i+1,j+1,dp);\\n                return dp[i][j]=ans;\\n        }\\n        else if(p[j]==\\'*\\'){\\n           int ans1 = tr(s,p,i,j+1,dp);\\n            ans = tr(s,p,i+1,j,dp);\\n                return dp[i][j]=(ans|ans1);\\n        }\\n        else {\\n            if(s[i]!=p[j]){\\n            return dp[i][j]=0;\\n            }\\n            else{\\n                ans = tr(s,p,i+1,j+1,dp);\\n            return dp[i][j]=ans;\\n            } \\n        }\\n\\n    }\\n    bool isMatch(string s, string p) {\\n        vector<vector<int>> dp(2001,vector<int>(2001,-1));\\n        if(s==\"\"){\\n            int i;\\n            for(i=0;i<p.length();i++){\\n                if(p[i]!=\\'*\\')return false;\\n            }\\n            return true;\\n        }\\n        int ans = tr(s,p,0,0,dp);\\n        if(ans==1)return true;\\n        else return false;\\n    }`\\n`};`\\n\\n\\ni\\'m getting tle for this , can someone please help\\n"
                    },
                    {
                        "username": "satyam_0405",
                        "content": "Please give 1 or 2 more testcases so that we can clearly understand the usage of  \\'*\\' in detail"
                    },
                    {
                        "username": "easy_problems_hunter",
                        "content": "clumsy questiion"
                    },
                    {
                        "username": "rawan9000",
                        "content": "Any answer please , Why the expected result is false  not true incase  s = \"acdcb\" and p = `  a*c?b` , \nalthough the mentioned point that '*' Matches any sequence of characters (including the empty sequence)."
                    },
                    {
                        "username": "SleekPanther",
                        "content": "I read it like this going left to right in the pattern:\\n1) `a` from pattern matches the 1st \"a\" from the string\\n2) `*` from pattern can match \"cd\", characters 2 and 3 from the string\\n3) `c` from pattern matches \"c\", the 4th character in the string\\n4) `?` from pattern matches any SINGLE character, the last \"b\"\\n5) `b` from pattern doesn\\'t match anything as we ran out"
                    }
                ]
            },
            {
                "id": 1847569,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "I was scared of this question for too long, for nothing tbh"
                    },
                    {
                        "username": "prakharu040",
                        "content": "My solution is failing on 1811/1811 case can anyone help as to why is this happening\\n\\n\\nclass Solution {\\n    HashMap<String,Boolean> map;\\n    \\n    public boolean regex(int i,int j,String s,String p)\\n    {\\n        if(j<0)\\n        {\\n            return i<0;\\n        }\\n        String key = String.valueOf(i)+\"#\"+String.valueOf(j);\\n        if(map.containsKey(key))\\n            return map.get(key);\\n        boolean charEquals = false;\\n        if(i>=0 && (s.charAt(i) == p.charAt(j) || p.charAt(j) == \\'?\\'))\\n        {\\n            if(regex(i-1,j-1,s,p))\\n            {\\n                map.put(key,true);\\n                return true;\\n            }\\n                \\n        }\\n        else if(p.charAt(j) == \\'*\\')\\n        {\\n            for(int m =0;m<=i+1;m++)\\n            {\\n                if(regex(i-m,j-1,s,p))\\n                {\\n                    map.put(key,true);\\n                    return true;\\n                }\\n            }\\n        }\\n        map.put(key,false);\\n        return false;\\n            \\n    }\\n    \\n    \\n    public boolean isMatch(String s, String p) {\\n        map = new HashMap<>();\\n        return regex(s.length()-1,p.length()-1,s,p);\\n    }\\n}"
                    },
                    {
                        "username": "prnvvarshney",
                        "content": "public class Solution {\\n    public boolean isMatch(String s, String p) {\\n        boolean[][] match=new boolean[s.length()+1][p.length()+1];\\n        match[s.length()][p.length()]=true;\\n        for(int i=p.length()-1;i>=0;i--){\\n            if(p.charAt(i)!=\\'*\\')\\n                break;\\n            else\\n                match[s.length()][i]=true;\\n        }\\n        for(int i=s.length()-1;i>=0;i--){\\n            for(int j=p.length()-1;j>=0;j--){\\n                if(s.charAt(i)==p.charAt(j)||p.charAt(j)==\\'?\\')\\n                        match[i][j]=match[i+1][j+1];\\n                else if(p.charAt(j)==\\'*\\')\\n                        match[i][j]=match[i+1][j]||match[i][j+1];\\n                else\\n                    match[i][j]=false;\\n            }\\n        }\\n        return match[0][0];\\n    }\\n}"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "I'm trying to wrap my mind around this: If the current pattern character is a star (p[0] == '*'), then there are two possible situations:\n        a. The star matches no characters, and hence the answer is isMatch(s, p[1:]).\n        b. The star matches one or more characters, and so the answer is isMatch(s[1:], p).\"\nCan someone give an example of input s and p where \"hence the answer is isMatch(s, p[1:])\"?\n\nTo understand case (a), first note that explaination \"* matches no character\" can be misleading. \n            s = \"adceb\"\n            p = \"*a*b\"\n\n            It's just saying solution is either in:\n                s = 'adceb'         <-- case (a) will evaluate to True\n                p = 'a*b'\n                    or\n                s = 'dceb'          <-- case (b) will evaluate to False\n                p = '*a*b'\n\n        To understand case (b)\n            s = \"a9absfkls\"\n            p = \"*abs*\"\n            helper(s[1:], p) True --> s[1:] = '9absfkls' ('*a': Case when the star matches one or more character)\n            helper(s, p[1:]) False --> p[1:] = 'abs*'"
                    },
                    {
                        "username": "hunnyjain711",
                        "content": "In the testcase s=\"abcabczzzde\", p=\"*abc???de*\" are they matching \"*abc\" with \"abcabc\"?\n\nedit: I guess yes, in this test case\ns=\"abefcdgiescdfimde\", p=\"ab*cd?i*de\"  leading suffix after \"*de\" are matched to0."
                    },
                    {
                        "username": "Bold_Bruiser",
                        "content": "s=\"aab\" p=\"a*a*b\"\nhow this is false??"
                    },
                    {
                        "username": "jayanth-c137",
                        "content": "` class Solution {`\\n`public:`\\n  `int tr(string& s,string& p,int i,int j,vector<vector<int>>& dp){`\\n      `  // cout<<i<<\" \"<<j<<\" \"<<dp[i][j]<<endl;`\\n   `     if(dp[i][j]!=-1)return dp[i][j];`\\n       ` if(j>=p.length() && i<s.length())return dp[i][j]=0;`\\n     `   if(j==p.length() && i==s.length()){`\\n       ` return dp[i][j]=1;`\\n       ` }`\\n    `    if(i>=s.length() && j<p.length()){`\\n         `   for(;j<p.length();j++){`\\n             `   if(p[j]!=\\'*\\')return dp[i][j]=0;`\\n         `   }`\\n       `     return dp[i][j]=1;`\\n     `   }`\\n        \\n        int ans;\\n        if(p[j]==\\'?\\'){\\n            ans = tr(s,p,i+1,j+1,dp);\\n                return dp[i][j]=ans;\\n        }\\n        else if(p[j]==\\'*\\'){\\n           int ans1 = tr(s,p,i,j+1,dp);\\n            ans = tr(s,p,i+1,j,dp);\\n                return dp[i][j]=(ans|ans1);\\n        }\\n        else {\\n            if(s[i]!=p[j]){\\n            return dp[i][j]=0;\\n            }\\n            else{\\n                ans = tr(s,p,i+1,j+1,dp);\\n            return dp[i][j]=ans;\\n            } \\n        }\\n\\n    }\\n    bool isMatch(string s, string p) {\\n        vector<vector<int>> dp(2001,vector<int>(2001,-1));\\n        if(s==\"\"){\\n            int i;\\n            for(i=0;i<p.length();i++){\\n                if(p[i]!=\\'*\\')return false;\\n            }\\n            return true;\\n        }\\n        int ans = tr(s,p,0,0,dp);\\n        if(ans==1)return true;\\n        else return false;\\n    }`\\n`};`\\n\\n\\ni\\'m getting tle for this , can someone please help\\n"
                    },
                    {
                        "username": "satyam_0405",
                        "content": "Please give 1 or 2 more testcases so that we can clearly understand the usage of  \\'*\\' in detail"
                    },
                    {
                        "username": "easy_problems_hunter",
                        "content": "clumsy questiion"
                    },
                    {
                        "username": "rawan9000",
                        "content": "Any answer please , Why the expected result is false  not true incase  s = \"acdcb\" and p = `  a*c?b` , \nalthough the mentioned point that '*' Matches any sequence of characters (including the empty sequence)."
                    },
                    {
                        "username": "SleekPanther",
                        "content": "I read it like this going left to right in the pattern:\\n1) `a` from pattern matches the 1st \"a\" from the string\\n2) `*` from pattern can match \"cd\", characters 2 and 3 from the string\\n3) `c` from pattern matches \"c\", the 4th character in the string\\n4) `?` from pattern matches any SINGLE character, the last \"b\"\\n5) `b` from pattern doesn\\'t match anything as we ran out"
                    }
                ]
            },
            {
                "id": 1815659,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "I was scared of this question for too long, for nothing tbh"
                    },
                    {
                        "username": "prakharu040",
                        "content": "My solution is failing on 1811/1811 case can anyone help as to why is this happening\\n\\n\\nclass Solution {\\n    HashMap<String,Boolean> map;\\n    \\n    public boolean regex(int i,int j,String s,String p)\\n    {\\n        if(j<0)\\n        {\\n            return i<0;\\n        }\\n        String key = String.valueOf(i)+\"#\"+String.valueOf(j);\\n        if(map.containsKey(key))\\n            return map.get(key);\\n        boolean charEquals = false;\\n        if(i>=0 && (s.charAt(i) == p.charAt(j) || p.charAt(j) == \\'?\\'))\\n        {\\n            if(regex(i-1,j-1,s,p))\\n            {\\n                map.put(key,true);\\n                return true;\\n            }\\n                \\n        }\\n        else if(p.charAt(j) == \\'*\\')\\n        {\\n            for(int m =0;m<=i+1;m++)\\n            {\\n                if(regex(i-m,j-1,s,p))\\n                {\\n                    map.put(key,true);\\n                    return true;\\n                }\\n            }\\n        }\\n        map.put(key,false);\\n        return false;\\n            \\n    }\\n    \\n    \\n    public boolean isMatch(String s, String p) {\\n        map = new HashMap<>();\\n        return regex(s.length()-1,p.length()-1,s,p);\\n    }\\n}"
                    },
                    {
                        "username": "prnvvarshney",
                        "content": "public class Solution {\\n    public boolean isMatch(String s, String p) {\\n        boolean[][] match=new boolean[s.length()+1][p.length()+1];\\n        match[s.length()][p.length()]=true;\\n        for(int i=p.length()-1;i>=0;i--){\\n            if(p.charAt(i)!=\\'*\\')\\n                break;\\n            else\\n                match[s.length()][i]=true;\\n        }\\n        for(int i=s.length()-1;i>=0;i--){\\n            for(int j=p.length()-1;j>=0;j--){\\n                if(s.charAt(i)==p.charAt(j)||p.charAt(j)==\\'?\\')\\n                        match[i][j]=match[i+1][j+1];\\n                else if(p.charAt(j)==\\'*\\')\\n                        match[i][j]=match[i+1][j]||match[i][j+1];\\n                else\\n                    match[i][j]=false;\\n            }\\n        }\\n        return match[0][0];\\n    }\\n}"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "I'm trying to wrap my mind around this: If the current pattern character is a star (p[0] == '*'), then there are two possible situations:\n        a. The star matches no characters, and hence the answer is isMatch(s, p[1:]).\n        b. The star matches one or more characters, and so the answer is isMatch(s[1:], p).\"\nCan someone give an example of input s and p where \"hence the answer is isMatch(s, p[1:])\"?\n\nTo understand case (a), first note that explaination \"* matches no character\" can be misleading. \n            s = \"adceb\"\n            p = \"*a*b\"\n\n            It's just saying solution is either in:\n                s = 'adceb'         <-- case (a) will evaluate to True\n                p = 'a*b'\n                    or\n                s = 'dceb'          <-- case (b) will evaluate to False\n                p = '*a*b'\n\n        To understand case (b)\n            s = \"a9absfkls\"\n            p = \"*abs*\"\n            helper(s[1:], p) True --> s[1:] = '9absfkls' ('*a': Case when the star matches one or more character)\n            helper(s, p[1:]) False --> p[1:] = 'abs*'"
                    },
                    {
                        "username": "hunnyjain711",
                        "content": "In the testcase s=\"abcabczzzde\", p=\"*abc???de*\" are they matching \"*abc\" with \"abcabc\"?\n\nedit: I guess yes, in this test case\ns=\"abefcdgiescdfimde\", p=\"ab*cd?i*de\"  leading suffix after \"*de\" are matched to0."
                    },
                    {
                        "username": "Bold_Bruiser",
                        "content": "s=\"aab\" p=\"a*a*b\"\nhow this is false??"
                    },
                    {
                        "username": "jayanth-c137",
                        "content": "` class Solution {`\\n`public:`\\n  `int tr(string& s,string& p,int i,int j,vector<vector<int>>& dp){`\\n      `  // cout<<i<<\" \"<<j<<\" \"<<dp[i][j]<<endl;`\\n   `     if(dp[i][j]!=-1)return dp[i][j];`\\n       ` if(j>=p.length() && i<s.length())return dp[i][j]=0;`\\n     `   if(j==p.length() && i==s.length()){`\\n       ` return dp[i][j]=1;`\\n       ` }`\\n    `    if(i>=s.length() && j<p.length()){`\\n         `   for(;j<p.length();j++){`\\n             `   if(p[j]!=\\'*\\')return dp[i][j]=0;`\\n         `   }`\\n       `     return dp[i][j]=1;`\\n     `   }`\\n        \\n        int ans;\\n        if(p[j]==\\'?\\'){\\n            ans = tr(s,p,i+1,j+1,dp);\\n                return dp[i][j]=ans;\\n        }\\n        else if(p[j]==\\'*\\'){\\n           int ans1 = tr(s,p,i,j+1,dp);\\n            ans = tr(s,p,i+1,j,dp);\\n                return dp[i][j]=(ans|ans1);\\n        }\\n        else {\\n            if(s[i]!=p[j]){\\n            return dp[i][j]=0;\\n            }\\n            else{\\n                ans = tr(s,p,i+1,j+1,dp);\\n            return dp[i][j]=ans;\\n            } \\n        }\\n\\n    }\\n    bool isMatch(string s, string p) {\\n        vector<vector<int>> dp(2001,vector<int>(2001,-1));\\n        if(s==\"\"){\\n            int i;\\n            for(i=0;i<p.length();i++){\\n                if(p[i]!=\\'*\\')return false;\\n            }\\n            return true;\\n        }\\n        int ans = tr(s,p,0,0,dp);\\n        if(ans==1)return true;\\n        else return false;\\n    }`\\n`};`\\n\\n\\ni\\'m getting tle for this , can someone please help\\n"
                    },
                    {
                        "username": "satyam_0405",
                        "content": "Please give 1 or 2 more testcases so that we can clearly understand the usage of  \\'*\\' in detail"
                    },
                    {
                        "username": "easy_problems_hunter",
                        "content": "clumsy questiion"
                    },
                    {
                        "username": "rawan9000",
                        "content": "Any answer please , Why the expected result is false  not true incase  s = \"acdcb\" and p = `  a*c?b` , \nalthough the mentioned point that '*' Matches any sequence of characters (including the empty sequence)."
                    },
                    {
                        "username": "SleekPanther",
                        "content": "I read it like this going left to right in the pattern:\\n1) `a` from pattern matches the 1st \"a\" from the string\\n2) `*` from pattern can match \"cd\", characters 2 and 3 from the string\\n3) `c` from pattern matches \"c\", the 4th character in the string\\n4) `?` from pattern matches any SINGLE character, the last \"b\"\\n5) `b` from pattern doesn\\'t match anything as we ran out"
                    }
                ]
            },
            {
                "id": 1780717,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "I was scared of this question for too long, for nothing tbh"
                    },
                    {
                        "username": "prakharu040",
                        "content": "My solution is failing on 1811/1811 case can anyone help as to why is this happening\\n\\n\\nclass Solution {\\n    HashMap<String,Boolean> map;\\n    \\n    public boolean regex(int i,int j,String s,String p)\\n    {\\n        if(j<0)\\n        {\\n            return i<0;\\n        }\\n        String key = String.valueOf(i)+\"#\"+String.valueOf(j);\\n        if(map.containsKey(key))\\n            return map.get(key);\\n        boolean charEquals = false;\\n        if(i>=0 && (s.charAt(i) == p.charAt(j) || p.charAt(j) == \\'?\\'))\\n        {\\n            if(regex(i-1,j-1,s,p))\\n            {\\n                map.put(key,true);\\n                return true;\\n            }\\n                \\n        }\\n        else if(p.charAt(j) == \\'*\\')\\n        {\\n            for(int m =0;m<=i+1;m++)\\n            {\\n                if(regex(i-m,j-1,s,p))\\n                {\\n                    map.put(key,true);\\n                    return true;\\n                }\\n            }\\n        }\\n        map.put(key,false);\\n        return false;\\n            \\n    }\\n    \\n    \\n    public boolean isMatch(String s, String p) {\\n        map = new HashMap<>();\\n        return regex(s.length()-1,p.length()-1,s,p);\\n    }\\n}"
                    },
                    {
                        "username": "prnvvarshney",
                        "content": "public class Solution {\\n    public boolean isMatch(String s, String p) {\\n        boolean[][] match=new boolean[s.length()+1][p.length()+1];\\n        match[s.length()][p.length()]=true;\\n        for(int i=p.length()-1;i>=0;i--){\\n            if(p.charAt(i)!=\\'*\\')\\n                break;\\n            else\\n                match[s.length()][i]=true;\\n        }\\n        for(int i=s.length()-1;i>=0;i--){\\n            for(int j=p.length()-1;j>=0;j--){\\n                if(s.charAt(i)==p.charAt(j)||p.charAt(j)==\\'?\\')\\n                        match[i][j]=match[i+1][j+1];\\n                else if(p.charAt(j)==\\'*\\')\\n                        match[i][j]=match[i+1][j]||match[i][j+1];\\n                else\\n                    match[i][j]=false;\\n            }\\n        }\\n        return match[0][0];\\n    }\\n}"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "I'm trying to wrap my mind around this: If the current pattern character is a star (p[0] == '*'), then there are two possible situations:\n        a. The star matches no characters, and hence the answer is isMatch(s, p[1:]).\n        b. The star matches one or more characters, and so the answer is isMatch(s[1:], p).\"\nCan someone give an example of input s and p where \"hence the answer is isMatch(s, p[1:])\"?\n\nTo understand case (a), first note that explaination \"* matches no character\" can be misleading. \n            s = \"adceb\"\n            p = \"*a*b\"\n\n            It's just saying solution is either in:\n                s = 'adceb'         <-- case (a) will evaluate to True\n                p = 'a*b'\n                    or\n                s = 'dceb'          <-- case (b) will evaluate to False\n                p = '*a*b'\n\n        To understand case (b)\n            s = \"a9absfkls\"\n            p = \"*abs*\"\n            helper(s[1:], p) True --> s[1:] = '9absfkls' ('*a': Case when the star matches one or more character)\n            helper(s, p[1:]) False --> p[1:] = 'abs*'"
                    },
                    {
                        "username": "hunnyjain711",
                        "content": "In the testcase s=\"abcabczzzde\", p=\"*abc???de*\" are they matching \"*abc\" with \"abcabc\"?\n\nedit: I guess yes, in this test case\ns=\"abefcdgiescdfimde\", p=\"ab*cd?i*de\"  leading suffix after \"*de\" are matched to0."
                    },
                    {
                        "username": "Bold_Bruiser",
                        "content": "s=\"aab\" p=\"a*a*b\"\nhow this is false??"
                    },
                    {
                        "username": "jayanth-c137",
                        "content": "` class Solution {`\\n`public:`\\n  `int tr(string& s,string& p,int i,int j,vector<vector<int>>& dp){`\\n      `  // cout<<i<<\" \"<<j<<\" \"<<dp[i][j]<<endl;`\\n   `     if(dp[i][j]!=-1)return dp[i][j];`\\n       ` if(j>=p.length() && i<s.length())return dp[i][j]=0;`\\n     `   if(j==p.length() && i==s.length()){`\\n       ` return dp[i][j]=1;`\\n       ` }`\\n    `    if(i>=s.length() && j<p.length()){`\\n         `   for(;j<p.length();j++){`\\n             `   if(p[j]!=\\'*\\')return dp[i][j]=0;`\\n         `   }`\\n       `     return dp[i][j]=1;`\\n     `   }`\\n        \\n        int ans;\\n        if(p[j]==\\'?\\'){\\n            ans = tr(s,p,i+1,j+1,dp);\\n                return dp[i][j]=ans;\\n        }\\n        else if(p[j]==\\'*\\'){\\n           int ans1 = tr(s,p,i,j+1,dp);\\n            ans = tr(s,p,i+1,j,dp);\\n                return dp[i][j]=(ans|ans1);\\n        }\\n        else {\\n            if(s[i]!=p[j]){\\n            return dp[i][j]=0;\\n            }\\n            else{\\n                ans = tr(s,p,i+1,j+1,dp);\\n            return dp[i][j]=ans;\\n            } \\n        }\\n\\n    }\\n    bool isMatch(string s, string p) {\\n        vector<vector<int>> dp(2001,vector<int>(2001,-1));\\n        if(s==\"\"){\\n            int i;\\n            for(i=0;i<p.length();i++){\\n                if(p[i]!=\\'*\\')return false;\\n            }\\n            return true;\\n        }\\n        int ans = tr(s,p,0,0,dp);\\n        if(ans==1)return true;\\n        else return false;\\n    }`\\n`};`\\n\\n\\ni\\'m getting tle for this , can someone please help\\n"
                    },
                    {
                        "username": "satyam_0405",
                        "content": "Please give 1 or 2 more testcases so that we can clearly understand the usage of  \\'*\\' in detail"
                    },
                    {
                        "username": "easy_problems_hunter",
                        "content": "clumsy questiion"
                    },
                    {
                        "username": "rawan9000",
                        "content": "Any answer please , Why the expected result is false  not true incase  s = \"acdcb\" and p = `  a*c?b` , \nalthough the mentioned point that '*' Matches any sequence of characters (including the empty sequence)."
                    },
                    {
                        "username": "SleekPanther",
                        "content": "I read it like this going left to right in the pattern:\\n1) `a` from pattern matches the 1st \"a\" from the string\\n2) `*` from pattern can match \"cd\", characters 2 and 3 from the string\\n3) `c` from pattern matches \"c\", the 4th character in the string\\n4) `?` from pattern matches any SINGLE character, the last \"b\"\\n5) `b` from pattern doesn\\'t match anything as we ran out"
                    }
                ]
            },
            {
                "id": 1769127,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "I was scared of this question for too long, for nothing tbh"
                    },
                    {
                        "username": "prakharu040",
                        "content": "My solution is failing on 1811/1811 case can anyone help as to why is this happening\\n\\n\\nclass Solution {\\n    HashMap<String,Boolean> map;\\n    \\n    public boolean regex(int i,int j,String s,String p)\\n    {\\n        if(j<0)\\n        {\\n            return i<0;\\n        }\\n        String key = String.valueOf(i)+\"#\"+String.valueOf(j);\\n        if(map.containsKey(key))\\n            return map.get(key);\\n        boolean charEquals = false;\\n        if(i>=0 && (s.charAt(i) == p.charAt(j) || p.charAt(j) == \\'?\\'))\\n        {\\n            if(regex(i-1,j-1,s,p))\\n            {\\n                map.put(key,true);\\n                return true;\\n            }\\n                \\n        }\\n        else if(p.charAt(j) == \\'*\\')\\n        {\\n            for(int m =0;m<=i+1;m++)\\n            {\\n                if(regex(i-m,j-1,s,p))\\n                {\\n                    map.put(key,true);\\n                    return true;\\n                }\\n            }\\n        }\\n        map.put(key,false);\\n        return false;\\n            \\n    }\\n    \\n    \\n    public boolean isMatch(String s, String p) {\\n        map = new HashMap<>();\\n        return regex(s.length()-1,p.length()-1,s,p);\\n    }\\n}"
                    },
                    {
                        "username": "prnvvarshney",
                        "content": "public class Solution {\\n    public boolean isMatch(String s, String p) {\\n        boolean[][] match=new boolean[s.length()+1][p.length()+1];\\n        match[s.length()][p.length()]=true;\\n        for(int i=p.length()-1;i>=0;i--){\\n            if(p.charAt(i)!=\\'*\\')\\n                break;\\n            else\\n                match[s.length()][i]=true;\\n        }\\n        for(int i=s.length()-1;i>=0;i--){\\n            for(int j=p.length()-1;j>=0;j--){\\n                if(s.charAt(i)==p.charAt(j)||p.charAt(j)==\\'?\\')\\n                        match[i][j]=match[i+1][j+1];\\n                else if(p.charAt(j)==\\'*\\')\\n                        match[i][j]=match[i+1][j]||match[i][j+1];\\n                else\\n                    match[i][j]=false;\\n            }\\n        }\\n        return match[0][0];\\n    }\\n}"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "I'm trying to wrap my mind around this: If the current pattern character is a star (p[0] == '*'), then there are two possible situations:\n        a. The star matches no characters, and hence the answer is isMatch(s, p[1:]).\n        b. The star matches one or more characters, and so the answer is isMatch(s[1:], p).\"\nCan someone give an example of input s and p where \"hence the answer is isMatch(s, p[1:])\"?\n\nTo understand case (a), first note that explaination \"* matches no character\" can be misleading. \n            s = \"adceb\"\n            p = \"*a*b\"\n\n            It's just saying solution is either in:\n                s = 'adceb'         <-- case (a) will evaluate to True\n                p = 'a*b'\n                    or\n                s = 'dceb'          <-- case (b) will evaluate to False\n                p = '*a*b'\n\n        To understand case (b)\n            s = \"a9absfkls\"\n            p = \"*abs*\"\n            helper(s[1:], p) True --> s[1:] = '9absfkls' ('*a': Case when the star matches one or more character)\n            helper(s, p[1:]) False --> p[1:] = 'abs*'"
                    },
                    {
                        "username": "hunnyjain711",
                        "content": "In the testcase s=\"abcabczzzde\", p=\"*abc???de*\" are they matching \"*abc\" with \"abcabc\"?\n\nedit: I guess yes, in this test case\ns=\"abefcdgiescdfimde\", p=\"ab*cd?i*de\"  leading suffix after \"*de\" are matched to0."
                    },
                    {
                        "username": "Bold_Bruiser",
                        "content": "s=\"aab\" p=\"a*a*b\"\nhow this is false??"
                    },
                    {
                        "username": "jayanth-c137",
                        "content": "` class Solution {`\\n`public:`\\n  `int tr(string& s,string& p,int i,int j,vector<vector<int>>& dp){`\\n      `  // cout<<i<<\" \"<<j<<\" \"<<dp[i][j]<<endl;`\\n   `     if(dp[i][j]!=-1)return dp[i][j];`\\n       ` if(j>=p.length() && i<s.length())return dp[i][j]=0;`\\n     `   if(j==p.length() && i==s.length()){`\\n       ` return dp[i][j]=1;`\\n       ` }`\\n    `    if(i>=s.length() && j<p.length()){`\\n         `   for(;j<p.length();j++){`\\n             `   if(p[j]!=\\'*\\')return dp[i][j]=0;`\\n         `   }`\\n       `     return dp[i][j]=1;`\\n     `   }`\\n        \\n        int ans;\\n        if(p[j]==\\'?\\'){\\n            ans = tr(s,p,i+1,j+1,dp);\\n                return dp[i][j]=ans;\\n        }\\n        else if(p[j]==\\'*\\'){\\n           int ans1 = tr(s,p,i,j+1,dp);\\n            ans = tr(s,p,i+1,j,dp);\\n                return dp[i][j]=(ans|ans1);\\n        }\\n        else {\\n            if(s[i]!=p[j]){\\n            return dp[i][j]=0;\\n            }\\n            else{\\n                ans = tr(s,p,i+1,j+1,dp);\\n            return dp[i][j]=ans;\\n            } \\n        }\\n\\n    }\\n    bool isMatch(string s, string p) {\\n        vector<vector<int>> dp(2001,vector<int>(2001,-1));\\n        if(s==\"\"){\\n            int i;\\n            for(i=0;i<p.length();i++){\\n                if(p[i]!=\\'*\\')return false;\\n            }\\n            return true;\\n        }\\n        int ans = tr(s,p,0,0,dp);\\n        if(ans==1)return true;\\n        else return false;\\n    }`\\n`};`\\n\\n\\ni\\'m getting tle for this , can someone please help\\n"
                    },
                    {
                        "username": "satyam_0405",
                        "content": "Please give 1 or 2 more testcases so that we can clearly understand the usage of  \\'*\\' in detail"
                    },
                    {
                        "username": "easy_problems_hunter",
                        "content": "clumsy questiion"
                    },
                    {
                        "username": "rawan9000",
                        "content": "Any answer please , Why the expected result is false  not true incase  s = \"acdcb\" and p = `  a*c?b` , \nalthough the mentioned point that '*' Matches any sequence of characters (including the empty sequence)."
                    },
                    {
                        "username": "SleekPanther",
                        "content": "I read it like this going left to right in the pattern:\\n1) `a` from pattern matches the 1st \"a\" from the string\\n2) `*` from pattern can match \"cd\", characters 2 and 3 from the string\\n3) `c` from pattern matches \"c\", the 4th character in the string\\n4) `?` from pattern matches any SINGLE character, the last \"b\"\\n5) `b` from pattern doesn\\'t match anything as we ran out"
                    }
                ]
            },
            {
                "id": 1741982,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "I was scared of this question for too long, for nothing tbh"
                    },
                    {
                        "username": "prakharu040",
                        "content": "My solution is failing on 1811/1811 case can anyone help as to why is this happening\\n\\n\\nclass Solution {\\n    HashMap<String,Boolean> map;\\n    \\n    public boolean regex(int i,int j,String s,String p)\\n    {\\n        if(j<0)\\n        {\\n            return i<0;\\n        }\\n        String key = String.valueOf(i)+\"#\"+String.valueOf(j);\\n        if(map.containsKey(key))\\n            return map.get(key);\\n        boolean charEquals = false;\\n        if(i>=0 && (s.charAt(i) == p.charAt(j) || p.charAt(j) == \\'?\\'))\\n        {\\n            if(regex(i-1,j-1,s,p))\\n            {\\n                map.put(key,true);\\n                return true;\\n            }\\n                \\n        }\\n        else if(p.charAt(j) == \\'*\\')\\n        {\\n            for(int m =0;m<=i+1;m++)\\n            {\\n                if(regex(i-m,j-1,s,p))\\n                {\\n                    map.put(key,true);\\n                    return true;\\n                }\\n            }\\n        }\\n        map.put(key,false);\\n        return false;\\n            \\n    }\\n    \\n    \\n    public boolean isMatch(String s, String p) {\\n        map = new HashMap<>();\\n        return regex(s.length()-1,p.length()-1,s,p);\\n    }\\n}"
                    },
                    {
                        "username": "prnvvarshney",
                        "content": "public class Solution {\\n    public boolean isMatch(String s, String p) {\\n        boolean[][] match=new boolean[s.length()+1][p.length()+1];\\n        match[s.length()][p.length()]=true;\\n        for(int i=p.length()-1;i>=0;i--){\\n            if(p.charAt(i)!=\\'*\\')\\n                break;\\n            else\\n                match[s.length()][i]=true;\\n        }\\n        for(int i=s.length()-1;i>=0;i--){\\n            for(int j=p.length()-1;j>=0;j--){\\n                if(s.charAt(i)==p.charAt(j)||p.charAt(j)==\\'?\\')\\n                        match[i][j]=match[i+1][j+1];\\n                else if(p.charAt(j)==\\'*\\')\\n                        match[i][j]=match[i+1][j]||match[i][j+1];\\n                else\\n                    match[i][j]=false;\\n            }\\n        }\\n        return match[0][0];\\n    }\\n}"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "I'm trying to wrap my mind around this: If the current pattern character is a star (p[0] == '*'), then there are two possible situations:\n        a. The star matches no characters, and hence the answer is isMatch(s, p[1:]).\n        b. The star matches one or more characters, and so the answer is isMatch(s[1:], p).\"\nCan someone give an example of input s and p where \"hence the answer is isMatch(s, p[1:])\"?\n\nTo understand case (a), first note that explaination \"* matches no character\" can be misleading. \n            s = \"adceb\"\n            p = \"*a*b\"\n\n            It's just saying solution is either in:\n                s = 'adceb'         <-- case (a) will evaluate to True\n                p = 'a*b'\n                    or\n                s = 'dceb'          <-- case (b) will evaluate to False\n                p = '*a*b'\n\n        To understand case (b)\n            s = \"a9absfkls\"\n            p = \"*abs*\"\n            helper(s[1:], p) True --> s[1:] = '9absfkls' ('*a': Case when the star matches one or more character)\n            helper(s, p[1:]) False --> p[1:] = 'abs*'"
                    },
                    {
                        "username": "hunnyjain711",
                        "content": "In the testcase s=\"abcabczzzde\", p=\"*abc???de*\" are they matching \"*abc\" with \"abcabc\"?\n\nedit: I guess yes, in this test case\ns=\"abefcdgiescdfimde\", p=\"ab*cd?i*de\"  leading suffix after \"*de\" are matched to0."
                    },
                    {
                        "username": "Bold_Bruiser",
                        "content": "s=\"aab\" p=\"a*a*b\"\nhow this is false??"
                    },
                    {
                        "username": "jayanth-c137",
                        "content": "` class Solution {`\\n`public:`\\n  `int tr(string& s,string& p,int i,int j,vector<vector<int>>& dp){`\\n      `  // cout<<i<<\" \"<<j<<\" \"<<dp[i][j]<<endl;`\\n   `     if(dp[i][j]!=-1)return dp[i][j];`\\n       ` if(j>=p.length() && i<s.length())return dp[i][j]=0;`\\n     `   if(j==p.length() && i==s.length()){`\\n       ` return dp[i][j]=1;`\\n       ` }`\\n    `    if(i>=s.length() && j<p.length()){`\\n         `   for(;j<p.length();j++){`\\n             `   if(p[j]!=\\'*\\')return dp[i][j]=0;`\\n         `   }`\\n       `     return dp[i][j]=1;`\\n     `   }`\\n        \\n        int ans;\\n        if(p[j]==\\'?\\'){\\n            ans = tr(s,p,i+1,j+1,dp);\\n                return dp[i][j]=ans;\\n        }\\n        else if(p[j]==\\'*\\'){\\n           int ans1 = tr(s,p,i,j+1,dp);\\n            ans = tr(s,p,i+1,j,dp);\\n                return dp[i][j]=(ans|ans1);\\n        }\\n        else {\\n            if(s[i]!=p[j]){\\n            return dp[i][j]=0;\\n            }\\n            else{\\n                ans = tr(s,p,i+1,j+1,dp);\\n            return dp[i][j]=ans;\\n            } \\n        }\\n\\n    }\\n    bool isMatch(string s, string p) {\\n        vector<vector<int>> dp(2001,vector<int>(2001,-1));\\n        if(s==\"\"){\\n            int i;\\n            for(i=0;i<p.length();i++){\\n                if(p[i]!=\\'*\\')return false;\\n            }\\n            return true;\\n        }\\n        int ans = tr(s,p,0,0,dp);\\n        if(ans==1)return true;\\n        else return false;\\n    }`\\n`};`\\n\\n\\ni\\'m getting tle for this , can someone please help\\n"
                    },
                    {
                        "username": "satyam_0405",
                        "content": "Please give 1 or 2 more testcases so that we can clearly understand the usage of  \\'*\\' in detail"
                    },
                    {
                        "username": "easy_problems_hunter",
                        "content": "clumsy questiion"
                    },
                    {
                        "username": "rawan9000",
                        "content": "Any answer please , Why the expected result is false  not true incase  s = \"acdcb\" and p = `  a*c?b` , \nalthough the mentioned point that '*' Matches any sequence of characters (including the empty sequence)."
                    },
                    {
                        "username": "SleekPanther",
                        "content": "I read it like this going left to right in the pattern:\\n1) `a` from pattern matches the 1st \"a\" from the string\\n2) `*` from pattern can match \"cd\", characters 2 and 3 from the string\\n3) `c` from pattern matches \"c\", the 4th character in the string\\n4) `?` from pattern matches any SINGLE character, the last \"b\"\\n5) `b` from pattern doesn\\'t match anything as we ran out"
                    }
                ]
            }
        ]
    },
    {
        "title": "Binary Tree Preorder Traversal",
        "question_content": "<p>Given the <code>root</code> of a binary tree, return <em>the preorder traversal of its nodes&#39; values</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg\" style=\"width: 125px; height: 200px;\" />\n<pre>\n<strong>Input:</strong> root = [1,null,2,3]\n<strong>Output:</strong> [1,2,3]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> []\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1]\n<strong>Output:</strong> [1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 100]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?</p>\n",
        "solutions": [
            {
                "id": 45266,
                "title": "accepted-iterative-solution-in-java-using-stack",
                "content": "Note that in this solution only right children are stored to stack.\\n\\n    public List<Integer> preorderTraversal(TreeNode node) {\\n\\t\\tList<Integer> list = new LinkedList<Integer>();\\n\\t\\tStack<TreeNode> rights = new Stack<TreeNode>();\\n\\t\\twhile(node != null) {\\n\\t\\t\\tlist.add(node.val);\\n\\t\\t\\tif (node.right != null) {\\n\\t\\t\\t\\trights.push(node.right);\\n\\t\\t\\t}\\n\\t\\t\\tnode = node.left;\\n\\t\\t\\tif (node == null && !rights.isEmpty()) {\\n\\t\\t\\t\\tnode = rights.pop();\\n\\t\\t\\t}\\n\\t\\t}\\n        return list;\\n    }",
                "solutionTags": [],
                "code": "Note that in this solution only right children are stored to stack.\\n\\n    public List<Integer> preorderTraversal(TreeNode node) {\\n\\t\\tList<Integer> list = new LinkedList<Integer>();\\n\\t\\tStack<TreeNode> rights = new Stack<TreeNode>();\\n\\t\\twhile(node != null) {\\n\\t\\t\\tlist.add(node.val);\\n\\t\\t\\tif (node.right != null) {\\n\\t\\t\\t\\trights.push(node.right);\\n\\t\\t\\t}\\n\\t\\t\\tnode = node.left;\\n\\t\\t\\tif (node == null && !rights.isEmpty()) {\\n\\t\\t\\t\\tnode = rights.pop();\\n\\t\\t\\t}\\n\\t\\t}\\n        return list;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 45273,
                "title": "very-simple-iterative-python-solution",
                "content": "Classical usage of stack's LIFO feature, very easy to grasp:\\n\\n    \\n    def preorderTraversal(self, root):\\n        ret = []\\n        stack = [root]\\n        while stack:\\n            node = stack.pop()\\n            if node:\\n                ret.append(node.val)\\n                stack.append(node.right)\\n                stack.append(node.left)\\n        return ret",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "Classical usage of stack's LIFO feature, very easy to grasp:\\n\\n    \\n    def preorderTraversal(self, root):\\n        ret = []\\n        stack = [root]\\n        while stack:\\n            node = stack.pop()\\n            if node:\\n                ret.append(node.val)\\n                stack.append(node.right)\\n                stack.append(node.left)\\n        return ret",
                "codeTag": "Python3"
            },
            {
                "id": 3025711,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> preorder;\\n        stack<TreeNode*> stack;\\n        if (root == NULL)\\n            return preorder;\\n        stack.push(root);\\n        while(!stack.empty()) {\\n            TreeNode* curr = stack.top();\\n            stack.pop();\\n            preorder.push_back(curr->val);\\n            if (curr->right != NULL)\\n                stack.push(curr->right);\\n            if (curr->left != NULL)\\n                stack.push(curr->left);\\n        }\\n        return preorder;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        head = root\\n        stack = []\\n        res = []\\n\\n        while head or stack:\\n            if head:\\n                res.append(head.val)\\n                if head.right:\\n                    stack.append(head.right)\\n                head = head.left\\n            else:\\n                head = stack.pop()\\n\\n        return res        \\n```\\n\\n```Java []\\nclass Solution {\\n    List<Integer> preorderTraverse(TreeNode root,List<Integer> list) {\\n\\n        if(root==null)\\n            return list;\\n        list.add(root.val);\\n        preorderTraverse(root.left,list);\\n        preorderTraverse(root.right,list);\\n        return list;\\n    }\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<Integer>();\\n        list = preorderTraverse(root,list);\\n        return list;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> preorder;\\n        stack<TreeNode*> stack;\\n        if (root == NULL)\\n            return preorder;\\n        stack.push(root);\\n        while(!stack.empty()) {\\n            TreeNode* curr = stack.top();\\n            stack.pop();\\n            preorder.push_back(curr->val);\\n            if (curr->right != NULL)\\n                stack.push(curr->right);\\n            if (curr->left != NULL)\\n                stack.push(curr->left);\\n        }\\n        return preorder;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        head = root\\n        stack = []\\n        res = []\\n\\n        while head or stack:\\n            if head:\\n                res.append(head.val)\\n                if head.right:\\n                    stack.append(head.right)\\n                head = head.left\\n            else:\\n                head = stack.pop()\\n\\n        return res        \\n```\n```Java []\\nclass Solution {\\n    List<Integer> preorderTraverse(TreeNode root,List<Integer> list) {\\n\\n        if(root==null)\\n            return list;\\n        list.add(root.val);\\n        preorderTraverse(root.left,list);\\n        preorderTraverse(root.right,list);\\n        return list;\\n    }\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<Integer>();\\n        list = preorderTraverse(root,list);\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 45466,
                "title": "c-iterative-recursive-and-morris-traversal",
                "content": "There are three solutions to this problem.\\n\\n 1. Iterative solution using stack --- `O(n)` time and `O(n)` space;\\n 2. Recursive solution --- `O(n)` time and `O(n)` space (function call stack);\\n 3. Morris traversal --- `O(n)` time and `O(1)` space.\\n\\n**Iterative solution using stack**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        stack<TreeNode*> todo;\\n        while (root || !todo.empty()) {\\n            if (root) {\\n                nodes.push_back(root -> val);\\n                if (root -> right) {\\n                    todo.push(root -> right);\\n                }\\n                root = root -> left;\\n            } else {\\n                root = todo.top();\\n                todo.pop();\\n            }\\n        }\\n        return nodes;\\n    }\\n};\\n```\\n\\n**Recursive solution**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        preorder(root, nodes);\\n        return nodes;\\n    }\\nprivate:\\n    void preorder(TreeNode* root, vector<int>& nodes) {\\n        if (!root) {\\n            return;\\n        }\\n        nodes.push_back(root -> val);\\n        preorder(root -> left, nodes);\\n        preorder(root -> right, nodes);\\n    }\\n};\\n```\\n\\n**Morris traversal**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        while (root) {\\n            if (root -> left) {\\n                TreeNode* pre = root -> left;\\n                while (pre -> right && pre -> right != root) {\\n                    pre = pre -> right;\\n                }\\n                if (!pre -> right) {\\n                    pre -> right = root;\\n                    nodes.push_back(root -> val);\\n                    root = root -> left;\\n                } else {\\n                    pre -> right = NULL;\\n                    root = root -> right;\\n                }\\n            } else {\\n                nodes.push_back(root -> val);\\n                root = root -> right;\\n            }\\n        }\\n        return nodes;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Recursion",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        stack<TreeNode*> todo;\\n        while (root || !todo.empty()) {\\n            if (root) {\\n                nodes.push_back(root -> val);\\n                if (root -> right) {\\n                    todo.push(root -> right);\\n                }\\n                root = root -> left;\\n            } else {\\n                root = todo.top();\\n                todo.pop();\\n            }\\n        }\\n        return nodes;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        preorder(root, nodes);\\n        return nodes;\\n    }\\nprivate:\\n    void preorder(TreeNode* root, vector<int>& nodes) {\\n        if (!root) {\\n            return;\\n        }\\n        nodes.push_back(root -> val);\\n        preorder(root -> left, nodes);\\n        preorder(root -> right, nodes);\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        while (root) {\\n            if (root -> left) {\\n                TreeNode* pre = root -> left;\\n                while (pre -> right && pre -> right != root) {\\n                    pre = pre -> right;\\n                }\\n                if (!pre -> right) {\\n                    pre -> right = root;\\n                    nodes.push_back(root -> val);\\n                    root = root -> left;\\n                } else {\\n                    pre -> right = NULL;\\n                    root = root -> right;\\n                }\\n            } else {\\n                nodes.push_back(root -> val);\\n                root = root -> right;\\n            }\\n        }\\n        return nodes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 45468,
                "title": "3-different-solutions",
                "content": "Recursive method with List as returning value:\\n\\n    \\tpublic List<Integer> preorderTraversal(TreeNode root) {\\n    \\t\\tList<Integer> pre = new LinkedList<Integer>();\\n    \\t\\tif(root==null) return pre;\\n    \\t\\tpre.add(root.val);\\n    \\t\\tpre.addAll(preorderTraversal(root.left));\\n    \\t\\tpre.addAll(preorderTraversal(root.right));\\n    \\t\\treturn pre;\\n    \\t}\\n\\nRecursive method with Helper method to have a List as paramater, so we can modify the parameter and don't have to instantiate a new List at each recursive call:\\n\\n    \\tpublic List<Integer> preorderTraversal(TreeNode root) {\\n    \\t\\tList<Integer> pre = new LinkedList<Integer>();\\n    \\t\\tpreHelper(root,pre);\\n    \\t\\treturn pre;\\n    \\t}\\n    \\tpublic void preHelper(TreeNode root, List<Integer> pre) {\\n    \\t\\tif(root==null) return;\\n    \\t\\tpre.add(root.val);\\n    \\t\\tpreHelper(root.left,pre);\\n    \\t\\tpreHelper(root.right,pre);\\n    \\t}\\n\\nIterative method with Stack:\\n\\n    \\tpublic List<Integer> preorderIt(TreeNode root) {\\n    \\t\\tList<Integer> pre = new LinkedList<Integer>();\\n    \\t\\tif(root==null) return pre;\\n    \\t\\tStack<TreeNode> tovisit = new Stack<TreeNode>();\\n    \\t\\ttovisit.push(root);\\n    \\t\\twhile(!tovisit.empty()) {\\n    \\t\\t\\tTreeNode visiting = tovisit.pop();\\n    \\t\\t\\tpre.add(visiting.val);\\n    \\t\\t\\tif(visiting.right!=null) tovisit.push(visiting.right);\\n    \\t\\t\\tif(visiting.left!=null) tovisit.push(visiting.left);\\n    \\t\\t}\\n    \\t\\treturn pre;\\n    \\t}",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "Recursive method with List as returning value:\\n\\n    \\tpublic List<Integer> preorderTraversal(TreeNode root) {\\n    \\t\\tList<Integer> pre = new LinkedList<Integer>();\\n    \\t\\tif(root==null) return pre;\\n    \\t\\tpre.add(root.val);\\n    \\t\\tpre.addAll(preorderTraversal(root.left));\\n    \\t\\tpre.addAll(preorderTraversal(root.right));\\n    \\t\\treturn pre;\\n    \\t}\\n\\nRecursive method with Helper method to have a List as paramater, so we can modify the parameter and don't have to instantiate a new List at each recursive call:\\n\\n    \\tpublic List<Integer> preorderTraversal(TreeNode root) {\\n    \\t\\tList<Integer> pre = new LinkedList<Integer>();\\n    \\t\\tpreHelper(root,pre);\\n    \\t\\treturn pre;\\n    \\t}\\n    \\tpublic void preHelper(TreeNode root, List<Integer> pre) {\\n    \\t\\tif(root==null) return;\\n    \\t\\tpre.add(root.val);\\n    \\t\\tpreHelper(root.left,pre);\\n    \\t\\tpreHelper(root.right,pre);\\n    \\t}\\n\\nIterative method with Stack:\\n\\n    \\tpublic List<Integer> preorderIt(TreeNode root) {\\n    \\t\\tList<Integer> pre = new LinkedList<Integer>();\\n    \\t\\tif(root==null) return pre;\\n    \\t\\tStack<TreeNode> tovisit = new Stack<TreeNode>();\\n    \\t\\ttovisit.push(root);\\n    \\t\\twhile(!tovisit.empty()) {\\n    \\t\\t\\tTreeNode visiting = tovisit.pop();\\n    \\t\\t\\tpre.add(visiting.val);\\n    \\t\\t\\tif(visiting.right!=null) tovisit.push(visiting.right);\\n    \\t\\t\\tif(visiting.left!=null) tovisit.push(visiting.left);\\n    \\t\\t}\\n    \\t\\treturn pre;\\n    \\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 45290,
                "title": "python-solutions-recursively-and-iteratively",
                "content": "        \\n    # recursively\\n    def preorderTraversal1(self, root):\\n        res = []\\n        self.dfs(root, res)\\n        return res\\n        \\n    def dfs(self, root, res):\\n        if root:\\n            res.append(root.val)\\n            self.dfs(root.left, res)\\n            self.dfs(root.right, res)\\n    \\n    # iteratively\\n    def preorderTraversal(self, root):\\n        stack, res = [root], []\\n        while stack:\\n            node = stack.pop()\\n            if node:\\n                res.append(node.val)\\n                stack.append(node.right)\\n                stack.append(node.left)\\n        return res",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "        \\n    # recursively\\n    def preorderTraversal1(self, root):\\n        res = []\\n        self.dfs(root, res)\\n        return res\\n        \\n    def dfs(self, root, res):\\n        if root:\\n            res.append(root.val)\\n            self.dfs(root.left, res)\\n            self.dfs(root.right, res)\\n    \\n    # iteratively\\n    def preorderTraversal(self, root):\\n        stack, res = [root], []\\n        while stack:\\n            node = stack.pop()\\n            if node:\\n                res.append(node.val)\\n                stack.append(node.right)\\n                stack.append(node.left)\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 3022021,
                "title": "c-easy-beats100-3-approach-with-explaination",
                "content": "\\uD83C\\uDFA5\\uD83D\\uDD25 Exciting News! Join my Coding Journey! Subscribe Now! \\uD83D\\uDD25\\uD83C\\uDFA5\\n\\n\\uD83D\\uDD17 Link in the leetcode profile \\n\\nNew coding channel alert! \\uD83D\\uDE80\\uD83D\\uDCBB Subscribe to unlock amazing coding content and tutorials. Help me reach 1K subs to start posting more videos! Join now! \\uD83C\\uDF1F\\uD83D\\uDCAA\\n\\nThanks for your support! \\uD83D\\uDE4F\\n# Intuition\\n3 ways to solve this problem\\n\\n# Approach\\n**1.Recursive approach**\\n  - Check if the current node is empty or Null.\\n  - Display the data part of the root (or current node)\\n  - Traverse the left subtree by recursively calling the preorder function.\\n  - Traverse the right subtree by recursively calling the preorder function.\\n  \\n**2.Iterative approach**\\n  - Create an empty stack and push the root node to it.\\n  - Do the following while the stack is not empty\\n      1. Pop the top item from the stack and display it.\\n      2. Push the right child of the popped item to the stack.\\n      3. Push the left child of the popped item to the stack.\\n# Complexity\\n   - **Time complexity**:O(N)\\n   - **Space complexity**:O(H)H=height of binary tree\\n\\n  **3.Morris traversal**\\n - Initialize current as root\\n - While current is not null:\\n     1. If current does not have a left child:\\n          (i) Print current\\'s data.\\n          (ii) Go to the right, i.e., current = current.right\\n     2. Else:\\n           (i)Make current as the right child of the rightmost node in current\\'s left subtree.\\n           (ii)Go to this left child, i.e., current = current.left.\\n\\n# Complexity\\n- **Time complexity**:O(N)\\n- **Space complexity**:O(1)\\n\\n\\n \\n![oms.png](https://assets.leetcode.com/users/images/f5a39b74-fd4e-4f2c-bfb2-7737e7f09f35_1673225202.6658852.png)\\n\\n# Code(Recursuve approach)\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int>ans;\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        if(root){\\n            ans.push_back(root->val);\\n            preorderTraversal(root->left);\\n            preorderTraversal(root->right);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Code(iterative approach)\\n```\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        stack<TreeNode*>st;\\n        while (root || !st.empty()) {\\n            if (root) {\\n                ans.push_back(root -> val);\\n                if (root -> right) {\\n                    st.push(root -> right);\\n                }\\n                root = root -> left;\\n            } else {\\n                root = st.top();\\n                st.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Code(Morris approach)\\n```\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        while (root) {\\n            if (root -> left) {\\n                TreeNode* pre = root -> left;\\n                while (pre -> right && pre -> right != root) {\\n                    pre = pre -> right;\\n                }\\n                if (!pre -> right) {\\n                    pre -> right = root;\\n                    nodes.push_back(root -> val);\\n                    root = root -> left;\\n                } else {\\n                    pre -> right = NULL;\\n                    root = root -> right;\\n                }\\n            } else {\\n                nodes.push_back(root -> val);\\n                root = root -> right;\\n            }\\n        }\\n        return nodes;\\n    }\\n};\\n```\\n\\nIf you really found my solution helpful **please upvote it**, as it motivates me to post such kind of codes.\\n*Let me know in comment if i can do bette*r.\\nLets connect on [LINKDIN](https://www.linkedin.com/in/mahesh-vishnoi-a4a47a193/).\\n\\n",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int>ans;\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        if(root){\\n            ans.push_back(root->val);\\n            preorderTraversal(root->left);\\n            preorderTraversal(root->right);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        stack<TreeNode*>st;\\n        while (root || !st.empty()) {\\n            if (root) {\\n                ans.push_back(root -> val);\\n                if (root -> right) {\\n                    st.push(root -> right);\\n                }\\n                root = root -> left;\\n            } else {\\n                root = st.top();\\n                st.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        while (root) {\\n            if (root -> left) {\\n                TreeNode* pre = root -> left;\\n                while (pre -> right && pre -> right != root) {\\n                    pre = pre -> right;\\n                }\\n                if (!pre -> right) {\\n                    pre -> right = root;\\n                    nodes.push_back(root -> val);\\n                    root = root -> left;\\n                } else {\\n                    pre -> right = NULL;\\n                    root = root -> right;\\n                }\\n            } else {\\n                nodes.push_back(root -> val);\\n                root = root -> right;\\n            }\\n        }\\n        return nodes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 45493,
                "title": "accepted-code-explaination-with-algo",
                "content": " 1. Create an empty stack, Push root node to the stack.\\n 2. Do following while stack is not empty.\\n\\n 2.1. pop an item from the stack and print it.\\n \\n 2.2. push the right child of popped item to stack.\\n\\n 2.3. push the left child of popped item to stack.\\n\\n \\n\\n\\n>     class Solution {\\n>     public:\\n>         vector<int> preorderTraversal(TreeNode *root) {\\n>             stack<TreeNode*> nodeStack;\\n>             vector<int> result;\\n>             //base case\\n>             if(root==NULL)\\n>             return result;\\n>             nodeStack.push(root);\\n>             while(!nodeStack.empty())\\n>             {\\n>                 TreeNode* node= nodeStack.top();\\n>                 result.push_back(node->val);\\n>                 nodeStack.pop();\\n>                 if(node->right)\\n>                 nodeStack.push(node->right);\\n>                 if(node->left)\\n>                 nodeStack.push(node->left);\\n>             }\\n>             return result;\\n>             \\n>         }\\n>     };",
                "solutionTags": [],
                "code": "class Solution {\\n>     public:\\n>         vector<int> preorderTraversal(TreeNode *root) {\\n>             stack<TreeNode*> nodeStack;\\n>             vector<int> result;\\n>             //base case\\n>             if(root==NULL)\\n>             return result;\\n>             nodeStack.push(root);\\n>             while(!nodeStack.empty())\\n>             {\\n>                 TreeNode* node= nodeStack.top();\\n>                 result.push_back(node->val);\\n>                 nodeStack.pop();\\n>                 if(node->right)\\n>                 nodeStack.push(node->right);\\n>                 if(node->left)\\n>                 nodeStack.push(node->left);\\n>             }",
                "codeTag": "Java"
            },
            {
                "id": 45435,
                "title": "4-solutions-in-c",
                "content": "\\n    // recursive, but it's trivial...\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n        preTraversal(root, v);\\n        return v;\\n    }\\n    void preTraversal(TreeNode* root, vector<int>& v){\\n        if(!root) return;\\n        v.push_back(root->val);\\n        preTraversal(root->left, v);\\n        preTraversal(root->right, v);\\n    }\\n    \\n    \\n    // iterate, use stack to imitate recursive\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n        if(!root) return v;\\n        TreeNode* temp = root;\\n        stack<TreeNode*> s;\\n        s.push(root);\\n        while(!s.empty()){\\n            temp = s.top();\\n            s.pop();\\n            v.push_back(temp->val);\\n            if(temp->right) s.push(temp->right);\\n            if(temp->left) s.push(temp->left);\\n        }\\n    }\\n    \\n    \\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n        if(!root) return v;\\n        TreeNode* temp = root;\\n        stack<TreeNode*> s;\\n        while(true){\\n            while(temp){\\n                v.push_back(temp->val);\\n                if(temp->right) s.push(temp->right);\\n                temp = temp->left;\\n            }\\n            if(s.empty()) break;\\n            temp = s.top();\\n            s.pop();\\n        };\\n    }\\n    \\n    // morris traversal\\uff0c O(1) space\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n        if(!root) return v;\\n        TreeNode* temp = root, *prev;\\n        while(temp){\\n            if(!temp->left){\\n                v.push_back(temp->val);\\n                temp = temp->right;\\n            }else{\\n                prev = temp->left;\\n                while(prev->right&&(prev->right != temp))\\n                    prev = prev->right;\\n                if(!prev->right){\\n                    v.push_back(temp->val);\\n                    prev->right = temp;\\n                    temp = temp->left;\\n                }else{\\n                    prev->right = NULL;\\n                    temp = temp->right;\\n                }\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "\\n    // recursive, but it's trivial...\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n        preTraversal(root, v);\\n        return v;\\n    }\\n    void preTraversal(TreeNode* root, vector<int>& v){\\n        if(!root) return;\\n        v.push_back(root->val);\\n        preTraversal(root->left, v);\\n        preTraversal(root->right, v);\\n    }\\n    \\n    \\n    // iterate, use stack to imitate recursive\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n        if(!root) return v;\\n        TreeNode* temp = root;\\n        stack<TreeNode*> s;\\n        s.push(root);\\n        while(!s.empty()){\\n            temp = s.top();\\n            s.pop();\\n            v.push_back(temp->val);\\n            if(temp->right) s.push(temp->right);\\n            if(temp->left) s.push(temp->left);\\n        }\\n    }\\n    \\n    \\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n        if(!root) return v;\\n        TreeNode* temp = root;\\n        stack<TreeNode*> s;\\n        while(true){\\n            while(temp){\\n                v.push_back(temp->val);\\n                if(temp->right) s.push(temp->right);\\n                temp = temp->left;\\n            }\\n            if(s.empty()) break;\\n            temp = s.top();\\n            s.pop();\\n        };\\n    }\\n    \\n    // morris traversal\\uff0c O(1) space\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n        if(!root) return v;\\n        TreeNode* temp = root, *prev;\\n        while(temp){\\n            if(!temp->left){\\n                v.push_back(temp->val);\\n                temp = temp->right;\\n            }else{\\n                prev = temp->left;\\n                while(prev->right&&(prev->right != temp))\\n                    prev = prev->right;\\n                if(!prev->right){\\n                    v.push_back(temp->val);\\n                    prev->right = temp;\\n                    temp = temp->left;\\n                }else{\\n                    prev->right = NULL;\\n                    temp = temp->right;\\n                }\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 45417,
                "title": "preorder-traversal-java-solution-both-iteration-and-recursion",
                "content": "    // recursive\\n    public class Solution {\\n        public List<Integer> preorderTraversal(TreeNode root) {\\n            List<Integer> result = new ArrayList<Integer>();\\n            if (root != null){\\n                result.add(root.val);\\n                result.addAll(preorderTraversal(root.left));\\n                result.addAll(preorderTraversal(root.right));\\n            }\\n            return result;\\n        }\\n    }\\n    \\n    // iterative\\n    public class Solution {\\n        public List<Integer> preorderTraversal(TreeNode root) {\\n            List<Integer> result = new ArrayList<Integer>();\\n            if (root == null) return result;\\n            Stack<TreeNode> stack = new Stack<TreeNode>();\\n            stack.push(root);\\n            while (!stack.isEmpty()){\\n                TreeNode node = stack.pop();\\n                result.add(node.val);\\n                if (node.right != null) stack.push(node.right);\\n                if (node.left != null) stack.push(node.left);\\n            }\\n            return result;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<Integer> preorderTraversal(TreeNode root) {\\n            List<Integer> result = new ArrayList<Integer>();\\n            if (root != null){\\n                result.add(root.val);\\n                result.addAll(preorderTraversal(root.left));\\n                result.addAll(preorderTraversal(root.right));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 45259,
                "title": "easy-c-solution-using-stack",
                "content": "    class Solution {\\n    public:\\n    vector<int> preorderTraversal(TreeNode *root) {\\n        if (root==NULL) {\\n            return vector<int>();\\n        }\\n        vector<int> result;\\n        stack<TreeNode *> treeStack;\\n        treeStack.push(root);\\n        while (!treeStack.empty()) {\\n            TreeNode *temp = treeStack.top();\\n            result.push_back(temp->val);\\n            treeStack.pop();\\n            if (temp->right!=NULL) {\\n                treeStack.push(temp->right);\\n            }\\n            if (temp->left!=NULL) {\\n                treeStack.push(temp->left);\\n            }\\n        }\\n        return result;\\n    }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    vector<int> preorderTraversal(TreeNode *root) {\\n        if (root==NULL) {\\n            return vector<int>();\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3022675,
                "title": "java-solution-with-explanation",
                "content": "\\n\\n# Approach and Explanation ( Recursive )\\n<!-- Describe your approach to solving the problem. -->\\n1. A preorder traversal is a traversal order in which the root node is visited first, followed by the left subtree, and then the right subtree. `The traversal order for a node is: root, left, right.`\\n\\n2. The code first defines a List called result which will store the preorder traversal of the tree. It then calls a helper function traversal which takes in a TreeNode called root and the result List.\\n\\n3. The traversal function first checks if the root is null. If it is, it returns without doing anything. If the root is not null, it adds the root\\'s value to the result List. It then calls itself recursively on the root\\'s left child and then on the root\\'s right child.\\n\\n4. This recursive function will continue until it reaches a leaf node (a node with no children), at which point it will start returning and adding the values of the nodes it traversed on the way back up the recursive stack to the result List.\\n\\n5. At the end of the function, the result List will contain the preorder traversal of the tree.\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n   public List<Integer> preorderTraversal(TreeNode root) {\\n       // Create a list to store the traversal result\\n\\tList<Integer> result = new ArrayList<>();\\n\\t\\n       // Call helper method to perform the traversal\\n\\ttraversal(root, result);\\n\\t\\n       // Return the result\\n\\treturn result;\\n   }\\n   \\n   // Helper method to perform the preorder traversal\\n   public void traversal(TreeNode root, List<Integer> result) {\\n       // Return if the current node is null\\n\\tif(root == null) return;\\n\\t\\n       // Add the current node\\'s value to the result list\\n\\tresult.add(root.val);\\n\\t\\n       // Recursively traverse the left and right subtrees\\n\\ttraversal(root.left, result);\\n\\ttraversal(root.right, result);\\n   }\\n}\\n```\\n# Approach and Explanation ( Iterative )\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. This code is implementing the pre-order traversal of a binary tree. In a pre-order traversal, the root node is visited first, then the left subtree, and then the right subtree.\\n\\n2. The code is using a stack to store nodes as it traverses the tree. A stack is a Last-In-First-Out (LIFO) data structure, which means that the last element added to the stack will be the first one to be removed. This property is useful for implementing a tree traversal because it allows us to process the nodes in the correct order (i.e., root node before the child nodes).\\n\\n3. The algorithm works as follows:\\n\\n- Create an empty stack and an empty list to store the traversal.\\n- Push the root node to the stack.\\n- While the stack is not empty:\\nPop the top element from the stack.\\nAdd the popped element\\'s value to the traversal list.\\nPush the right child of the popped element to the stack.\\nPush the left child of the popped element to the stack.\\n- Return the traversal list.\\n4. The reason why the right child is pushed to the stack before the left child is that we want to process the left subtree before the right subtree (since this is a pre-order traversal). Pushing the right child before the left child ensures that the left child will be processed first when it is popped from the stack.\\n```\\nclass Solution {\\n    // This method returns a list of integers representing the preorder traversal of a binary tree\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n     // Create an empty ArrayList to store the preorder traversal\\n     ArrayList<Integer> result = new ArrayList<Integer>();\\n      // If the root is null, return the empty list\\n      if(root == null) \\n      return result;\\n      \\n      // Create a stack to store the nodes as we traverse the tree\\n      Stack<TreeNode> st = new Stack<TreeNode>();\\n      // Push the root node onto the stack\\n      st.push(root);\\n      \\n      // While the stack is not empty,\\n      while(!st.isEmpty()) {\\n        // Pop the top node from the stack\\n        TreeNode current = st.pop(); \\n        // Add the value of the node to the list\\n        result.add(current.val);\\n        \\n        // If the current node has a right child, push it onto the stack\\n        if(current.right != null) \\n        st.push(current.right);\\n        // If the current node has a left child, push it onto the stack\\n        if(current.left != null)\\n        st.push(current.left);\\n      }\\n      // Return the list of preorder traversal values\\n      return result;\\n    }\\n}\\n\\n\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n   public List<Integer> preorderTraversal(TreeNode root) {\\n       // Create a list to store the traversal result\\n\\tList<Integer> result = new ArrayList<>();\\n\\t\\n       // Call helper method to perform the traversal\\n\\ttraversal(root, result);\\n\\t\\n       // Return the result\\n\\treturn result;\\n   }\\n   \\n   // Helper method to perform the preorder traversal\\n   public void traversal(TreeNode root, List<Integer> result) {\\n       // Return if the current node is null\\n\\tif(root == null) return;\\n\\t\\n       // Add the current node\\'s value to the result list\\n\\tresult.add(root.val);\\n\\t\\n       // Recursively traverse the left and right subtrees\\n\\ttraversal(root.left, result);\\n\\ttraversal(root.right, result);\\n   }\\n}\\n```\n```\\nclass Solution {\\n    // This method returns a list of integers representing the preorder traversal of a binary tree\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n     // Create an empty ArrayList to store the preorder traversal\\n     ArrayList<Integer> result = new ArrayList<Integer>();\\n      // If the root is null, return the empty list\\n      if(root == null) \\n      return result;\\n      \\n      // Create a stack to store the nodes as we traverse the tree\\n      Stack<TreeNode> st = new Stack<TreeNode>();\\n      // Push the root node onto the stack\\n      st.push(root);\\n      \\n      // While the stack is not empty,\\n      while(!st.isEmpty()) {\\n        // Pop the top node from the stack\\n        TreeNode current = st.pop(); \\n        // Add the value of the node to the list\\n        result.add(current.val);\\n        \\n        // If the current node has a right child, push it onto the stack\\n        if(current.right != null) \\n        st.push(current.right);\\n        // If the current node has a left child, push it onto the stack\\n        if(current.left != null)\\n        st.push(current.left);\\n      }\\n      // Return the list of preorder traversal values\\n      return result;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022631,
                "title": "java-iterative-recursive-100-faster",
                "content": "### Upvote If it adds little value, vote means a lot for me\\uD83D\\uDE0A\\n# Code 1 ( Iterative)\\n```\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        ArrayList<Integer> arrl = new ArrayList<>();\\n        if(root == null) return arrl;\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        while(!stack.isEmpty()){\\n            TreeNode current = stack.pop();\\n            arrl.add(current.val);\\n            if(current.right != null){\\n                stack.push(current.right);\\n            }\\n            if(current.left != null){\\n                stack.push(current.left);\\n            }\\n        }\\n        return arrl;\\n    }\\n}\\n```\\n# Iterative Approach\\n Unlike recursion, we require an additional data structure to store our `TreeNode` for iterative solutions. As a result, using `stack` is the best option.\\nAs we know for preorder traversal, we traverse from left -> right. Because the `stack` follow\\'s LIFO technique, we will push the right child of the `node` first then left.\\n\\n1. Initialize empty array `answer` and `stack`\\n2. If `root` is `null` return `answer` or else\\n3. Push `root` to `stack`\\n4. While `stack` is not empty\\n    - pop top `node` from `stack`\\n    - add its `value` to `answer`\\n    - if `node`\\'s right child is not `null`, push to `stack`\\n    - if `node`\\'s left child is not `null`, push to `stack`\\n# Code 2 ( Recursion)\\n```\\npublic class Solution {\\n\\npublic List<Integer> preorderTraversal(TreeNode root) {\\n    ArrayList<Integer> list = new ArrayList<Integer>();\\n    traverse(root, list);\\n    return list;\\n}\\n\\npublic void traverse(TreeNode node, ArrayList<Integer> list) {\\n    if(node == null) {\\n        return;\\n    }\\n    \\n    list.add(node.val);\\n    traverse(node.left, list);\\n    traverse(node.right, list);\\n    \\n}\\n}\\n```\\n# Recursive Approach\\nA recursive approach is simple. Here is psuedo code\\n\\n1. Initialize an empty array `answer`\\n1. In recursion\\n    - Base Case: If `root` is null return `root`.\\n    - Add `root` value to `answer`.\\n    - Traverse `root.left` subtree\\n    - Traverse `root.right` subtree",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        ArrayList<Integer> arrl = new ArrayList<>();\\n        if(root == null) return arrl;\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        while(!stack.isEmpty()){\\n            TreeNode current = stack.pop();\\n            arrl.add(current.val);\\n            if(current.right != null){\\n                stack.push(current.right);\\n            }\\n            if(current.left != null){\\n                stack.push(current.left);\\n            }\\n        }\\n        return arrl;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n\\npublic List<Integer> preorderTraversal(TreeNode root) {\\n    ArrayList<Integer> list = new ArrayList<Integer>();\\n    traverse(root, list);\\n    return list;\\n}\\n\\npublic void traverse(TreeNode node, ArrayList<Integer> list) {\\n    if(node == null) {\\n        return;\\n    }\\n    \\n    list.add(node.val);\\n    traverse(node.left, list);\\n    traverse(node.right, list);\\n    \\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 45467,
                "title": "132ms-in-javascript",
                "content": "    var preorderTraversal = function(root) {\\n      if (!root) return [];\\n      var result = [];\\n      var stack = [root];\\n      \\n      while(stack.length) {\\n        var node = stack.pop();\\n        result.push(node.val);\\n        if (node.right) stack.push(node.right);\\n        if (node.left) stack.push(node.left);\\n      }\\n      return result;\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var preorderTraversal = function(root) {\\n      if (!root) return [];\\n      var result = [];\\n      var stack = [root];\\n      \\n      while(stack.length) {\\n        var node = stack.pop();\\n        result.push(node.val);\\n        if (node.right) stack.push(node.right);\\n        if (node.left) stack.push(node.left);\\n      }\\n      return result;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 45267,
                "title": "3-iterative-solutions-stack-and-morris-traversal-complexity-explained",
                "content": "### 1 Stack-based:\\nStack-based: \\n```java\\npublic class Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        if (root == null)\\n            return res;\\n        Stack<TreeNode> s = new Stack<>();\\n        s.push(root);\\n        while (!s.isEmpty()) {\\n            TreeNode cur = s.pop();\\n            res.add(cur.val);\\n            if (cur.right != null)\\n                s.push(cur.right);\\n            if (cur.left != null)\\n                s.push(cur.left);\\n        }\\n        return res;\\n    }\\n}\\n```\\nPush right before left so that, due to the property of a stack, left is processed before right; This is the logic that echoes most throughout this problem's discussions, and is very easy to understand.\\n\\n### 2 Stack-based:\\nSlight changes. \\n```java\\npublic class Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        if (root == null)\\n            return res;\\n        Stack<TreeNode> s = new Stack<>();\\n        s.push(root);\\n        while (!s.isEmpty()) {\\n            TreeNode cur = s.pop();\\n            while (cur != null) {\\n                res.add(cur.val);\\n                s.push(cur.right);\\n                cur = cur.left;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\nThis algorithm employs a technique I like to call \"push horizontal\" that is frequently used in the implementation of stack-based InOrder and PostOrder algorithm. Since PreOrder logic is generally easier than the other two, this approach is not as much used as that of solution 1. Note that here we push `cur.right` rather than `cur`. The `null` cases will handle themselves by the inner while loop.\\n\\n\\n### 3 Morris Traversal\\n```java\\npublic class Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        if (root == null)\\n            return res;\\n        TreeNode cur = root;\\n        while (cur != null) {\\n            if (cur.left == null) {\\n                res.add(cur.val);\\n                cur = cur.right;\\n            } else {\\n                TreeNode prev = cur.left;\\n                while (prev.right != null && prev.right != cur)\\n                    prev = prev.right;\\n                if (prev.right == null) {\\n                    res.add(cur.val);\\n                    prev.right = cur;\\n                    cur = cur.left;\\n                } else {\\n                    prev.right = null;\\n                    cur = cur.right;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\nA [**good explanation**](http://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/) here gives implementation of Morris Traversal InOrder algorithm. The PreOrder algorithm can be achieved by tweaking the code very slightly: rather than visit `cur` when we **restore** the tree(which is generally the second time we are at node `cur`), we visit it the first time we encounter it, which is when we have to **modify**. \\n\\nThe space **complexity** for Morris Traversal is O(1) obviously. The time complexity is actually O(N) which is a little more subtle. The outer while loop is executed O(N) iterations obviously, depending on the position of `root` in the InOrder serialization of the tree. In each such iteration, we have to find the left predecessor for `cur`, which is the costly part. Trivially you would think that gives us `O(NlgN)` per height of the tree. But if you think aggregately, you will see these:\\n* For each node, we do `find left predecessor` on it only twice.\\n* Throughout these two `find left predecessor` inner while loops, each edge of the tree get traversed at most twice.\\n\\nYou might have to draw a tree and doodle some trace to convince yourself this. Since a tree has `N-1` edges, with `N` as the number of nodes, we know that the time complexity is O(N).",
                "solutionTags": [],
                "code": "```java\\npublic class Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        if (root == null)\\n            return res;\\n        Stack<TreeNode> s = new Stack<>();\\n        s.push(root);\\n        while (!s.isEmpty()) {\\n            TreeNode cur = s.pop();\\n            res.add(cur.val);\\n            if (cur.right != null)\\n                s.push(cur.right);\\n            if (cur.left != null)\\n                s.push(cur.left);\\n        }\\n        return res;\\n    }\\n}\\n```\n```java\\npublic class Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        if (root == null)\\n            return res;\\n        Stack<TreeNode> s = new Stack<>();\\n        s.push(root);\\n        while (!s.isEmpty()) {\\n            TreeNode cur = s.pop();\\n            while (cur != null) {\\n                res.add(cur.val);\\n                s.push(cur.right);\\n                cur = cur.left;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\n```java\\npublic class Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        if (root == null)\\n            return res;\\n        TreeNode cur = root;\\n        while (cur != null) {\\n            if (cur.left == null) {\\n                res.add(cur.val);\\n                cur = cur.right;\\n            } else {\\n                TreeNode prev = cur.left;\\n                while (prev.right != null && prev.right != cur)\\n                    prev = prev.right;\\n                if (prev.right == null) {\\n                    res.add(cur.val);\\n                    prev.right = cur;\\n                    cur = cur.left;\\n                } else {\\n                    prev.right = null;\\n                    cur = cur.right;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022150,
                "title": "python-3-1-10-lines-3-versions-w-example-t-m-98-29",
                "content": "\\nThe iterative version, with example:\\n```\\nclass Solution:\\n    def preorderTraversal(self, root: TreeNode) -> list[int]:\\n\\n                                            #  Ex: root = [1, 2,None, 3,4]\\n        if not root: return []              #         __1\\n        stack, ans = [root], []             #        /\\n                                            #       2\\n        while stack:                        #      / \\\\\\n            node = stack.pop()              #     3   4\\n            ans.append(node.val)            #\\n                                            #     node     node.left   node.right  stack    ans\\n            if node.right:                  #   \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\n                stack.append(node.right)    #                                       [1]     []\\n            if node. left:                  #       1          2         None       [2]     [1]\\n                stack.append(node.left )    #       2          3          4         [4,3]   [1,2]\\n                                            #       3        None        None       [4]     [1,2,3]\\n                                            #       4        None        None       [4]     [1,2,3,4]\\n        return ans  \\n```\\n[https://leetcode.com/problems/binary-tree-preorder-traversal/submissions/577636662/](http://)\\n\\nThe recursive version:\\n```\\nclass Solution:\\n    def preorderTraversal(self, root: TreeNode) -> list[int]:\\n\\n        def dfs(node):\\n            if not node: return\\n\\n            ans.append(node.val)\\n\\n            dfs(node.left)\\n            dfs(node.right)\\n  \\n            return   \\n        \\n        ans = []\\n        \\n        dfs(root)\\n\\n        return ans\\n```\\nAnd here\\'s a one-liner:\\n```\\nclass Solution:\\n    def preorderTraversal(self, root: TreeNode) -> list[int]:\\n\\n        return [] if not root else   ([root.val]+\\n                self.preorderTraversal(root.left)+\\n                self.preorderTraversal(root.right))\\n```\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*).\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def preorderTraversal(self, root: TreeNode) -> list[int]:\\n\\n                                            #  Ex: root = [1, 2,None, 3,4]\\n        if not root: return []              #         __1\\n        stack, ans = [root], []             #        /\\n                                            #       2\\n        while stack:                        #      / \\\\\\n            node = stack.pop()              #     3   4\\n            ans.append(node.val)            #\\n                                            #     node     node.left   node.right  stack    ans\\n            if node.right:                  #   \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\n                stack.append(node.right)    #                                       [1]     []\\n            if node. left:                  #       1          2         None       [2]     [1]\\n                stack.append(node.left )    #       2          3          4         [4,3]   [1,2]\\n                                            #       3        None        None       [4]     [1,2,3]\\n                                            #       4        None        None       [4]     [1,2,3,4]\\n        return ans  \\n```\n```\\nclass Solution:\\n    def preorderTraversal(self, root: TreeNode) -> list[int]:\\n\\n        def dfs(node):\\n            if not node: return\\n\\n            ans.append(node.val)\\n\\n            dfs(node.left)\\n            dfs(node.right)\\n  \\n            return   \\n        \\n        ans = []\\n        \\n        dfs(root)\\n\\n        return ans\\n```\n```\\nclass Solution:\\n    def preorderTraversal(self, root: TreeNode) -> list[int]:\\n\\n        return [] if not root else   ([root.val]+\\n                self.preorderTraversal(root.left)+\\n                self.preorderTraversal(root.right))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 45361,
                "title": "java-recursive-and-iterative-solutions",
                "content": "        \\n    // recursively\\n    public List<Integer> preorderTraversal1(TreeNode root) {\\n        List<Integer> ret = new ArrayList<>();\\n        dfs(root, ret);\\n        return ret;\\n    }\\n    \\n    private void dfs(TreeNode root, List<Integer> ret) {\\n        if (root != null) {\\n            ret.add(root.val);\\n            dfs(root.left, ret);\\n            dfs(root.right, ret);\\n        }\\n    }\\n    \\n    // iteratively\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> ret = new ArrayList<>();\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        while (!stack.isEmpty()) {\\n            TreeNode node = stack.pop();\\n            if (node != null) {\\n                ret.add(node.val);\\n                stack.push(node.right);\\n                stack.push(node.left);\\n            }\\n        }\\n        return ret;\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "        \\n    // recursively\\n    public List<Integer> preorderTraversal1(TreeNode root) {\\n        List<Integer> ret = new ArrayList<>();\\n        dfs(root, ret);\\n        return ret;\\n    }\\n    \\n    private void dfs(TreeNode root, List<Integer> ret) {\\n        if (root != null) {\\n            ret.add(root.val);\\n            dfs(root.left, ret);\\n            dfs(root.right, ret);\\n        }\\n    }\\n    \\n    // iteratively\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> ret = new ArrayList<>();\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        while (!stack.isEmpty()) {\\n            TreeNode node = stack.pop();\\n            if (node != null) {\\n                ret.add(node.val);\\n                stack.push(node.right);\\n                stack.push(node.left);\\n            }\\n        }\\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 45338,
                "title": "preorder-u3001inorder-u3001postorder-iterative-solution-by-c",
                "content": "preorder:\\n\\n    vector<int> preorderTraversal(TreeNode* root) {\\n    \\tvector<int> res;\\n    \\tstd::stack<TreeNode*> temp;\\n    \\twhile (root || !temp.empty()) {\\n    \\t\\twhile (root) {\\n    \\t\\t\\ttemp.push(root);\\n    \\t\\t\\tres.push_back(root->val);\\n    \\t\\t\\troot = root->left;\\n    \\t\\t}\\n    \\t\\troot = temp.top();\\n    \\t\\ttemp.pop();\\n    \\t\\troot = root->right;\\n    \\t}\\n    \\treturn res;\\n    }\\ninorder:\\n\\n    vector<int> inorderTraversal(TreeNode* root) {\\n    \\tvector<int> res;\\n    \\tstd::stack<TreeNode*> temp;\\n    \\twhile (root || !temp.empty()) {\\n    \\t\\twhile (root) {\\n    \\t\\t\\ttemp.push(root);\\n    \\t\\t\\troot = root->left;\\n    \\t\\t}\\n    \\t\\troot = temp.top();\\n    \\t\\ttemp.pop();\\n    \\t\\tres.push_back(root->val);\\n    \\t\\troot = root->right;\\n    \\t}\\n    \\treturn res;\\n    }\\n\\npostorder:\\n\\n    vector<int> postorderTraversal(TreeNode* root) {\\n    \\tvector<int> res;\\n    \\tstd::stack<TreeNode*> temp;\\n    \\twhile (root || !temp.empty()) {\\n    \\t\\twhile (root) {\\n    \\t\\t\\ttemp.push(root);\\n    \\t\\t\\tres.insert(res.begin(),root->val);\\n    \\t\\t\\troot = root->right;\\n    \\t\\t}\\n    \\t\\troot = temp.top();\\n    \\t\\ttemp.pop();\\n    \\t\\troot = root->left;\\n    \\t}\\n    \\treturn res;\\n    }",
                "solutionTags": [],
                "code": "preorder:\\n\\n    vector<int> preorderTraversal(TreeNode* root) {\\n    \\tvector<int> res;\\n    \\tstd::stack<TreeNode*> temp;\\n    \\twhile (root || !temp.empty()) {\\n    \\t\\twhile (root) {\\n    \\t\\t\\ttemp.push(root);\\n    \\t\\t\\tres.push_back(root->val);\\n    \\t\\t\\troot = root->left;\\n    \\t\\t}\\n    \\t\\troot = temp.top();\\n    \\t\\ttemp.pop();\\n    \\t\\troot = root->right;\\n    \\t}\\n    \\treturn res;\\n    }\\ninorder:\\n\\n    vector<int> inorderTraversal(TreeNode* root) {\\n    \\tvector<int> res;\\n    \\tstd::stack<TreeNode*> temp;\\n    \\twhile (root || !temp.empty()) {\\n    \\t\\twhile (root) {\\n    \\t\\t\\ttemp.push(root);\\n    \\t\\t\\troot = root->left;\\n    \\t\\t}\\n    \\t\\troot = temp.top();\\n    \\t\\ttemp.pop();\\n    \\t\\tres.push_back(root->val);\\n    \\t\\troot = root->right;\\n    \\t}\\n    \\treturn res;\\n    }\\n\\npostorder:\\n\\n    vector<int> postorderTraversal(TreeNode* root) {\\n    \\tvector<int> res;\\n    \\tstd::stack<TreeNode*> temp;\\n    \\twhile (root || !temp.empty()) {\\n    \\t\\twhile (root) {\\n    \\t\\t\\ttemp.push(root);\\n    \\t\\t\\tres.insert(res.begin(),root->val);\\n    \\t\\t\\troot = root->right;\\n    \\t\\t}\\n    \\t\\troot = temp.top();\\n    \\t\\ttemp.pop();\\n    \\t\\troot = root->left;\\n    \\t}\\n    \\treturn res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1334821,
                "title": "c-solution-100-faster-iterative-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> preorder;\\n        stack<TreeNode*> stack;\\n        if (root == NULL)\\n            return preorder;\\n        stack.push(root);\\n        while(!stack.empty()) {\\n            TreeNode* curr = stack.top();\\n            stack.pop();\\n            preorder.push_back(curr->val);\\n            if (curr->right != NULL)\\n                stack.push(curr->right);\\n            if (curr->left != NULL)\\n                stack.push(curr->left);\\n        }\\n        return preorder;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> preorder;\\n        stack<TreeNode*> stack;\\n        if (root == NULL)\\n            return preorder;\\n        stack.push(root);\\n        while(!stack.empty()) {\\n            TreeNode* curr = stack.top();\\n            stack.pop();\\n            preorder.push_back(curr->val);\\n            if (curr->right != NULL)\\n                stack.push(curr->right);\\n            if (curr->left != NULL)\\n                stack.push(curr->left);\\n        }\\n        return preorder;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 332277,
                "title": "python-recursive-and-iterative-solutions",
                "content": "Please see and vote for my solutions for these similar problems.\\n[94. Binary Tree Inorder Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal/discuss/332283/Python-recursive-and-iterative-solutions)\\n[144. Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/discuss/332277/Python-recursive-and-iterative-solutions)\\n[145. Binary Tree Postorder Traversal](https://leetcode.com/problems/binary-tree-postorder-traversal/discuss/332286/Python-recursive-and-iterative-solutions)\\n\\nRecursive solution:\\n```\\n    def preorderTraversal(self, root: TreeNode) -> List[int]:\\n        def dfs(node):\\n            if not node:\\n                return\\n            pre_order.append(node.val)\\n            dfs(node.left)\\n            dfs(node.right)\\n        \\n        pre_order = []\\n        dfs(root)\\n        return pre_order\\n```\\n\\nIterative solution:\\n```\\n    def preorderTraversal(self, root: TreeNode) -> List[int]:\\n        if not root:\\n            return []\\n        pre_order = []\\n        stack = [root]\\n        while stack:\\n            top = stack.pop()\\n            pre_order.append(top.val)\\n            if top.right:\\n                stack.append(top.right)\\n            if top.left:\\n                stack.append(top.left)\\n        return pre_order\\n```",
                "solutionTags": [],
                "code": "```\\n    def preorderTraversal(self, root: TreeNode) -> List[int]:\\n        def dfs(node):\\n            if not node:\\n                return\\n            pre_order.append(node.val)\\n            dfs(node.left)\\n            dfs(node.right)\\n        \\n        pre_order = []\\n        dfs(root)\\n        return pre_order\\n```\n```\\n    def preorderTraversal(self, root: TreeNode) -> List[int]:\\n        if not root:\\n            return []\\n        pre_order = []\\n        stack = [root]\\n        while stack:\\n            top = stack.pop()\\n            pre_order.append(top.val)\\n            if top.right:\\n                stack.append(top.right)\\n            if top.left:\\n                stack.append(top.left)\\n        return pre_order\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1508299,
                "title": "c-recursive-simple-solution-0-ms-100-faster",
                "content": "**C++ :**\\n\\n```\\nvoid preorderTraversalHelper(TreeNode* root, vector<int> &res) {\\n\\tif(root)\\n\\t{\\n\\t\\tres.push_back(root -> val);           \\n\\n\\t\\tif(root -> left)\\n\\t\\t\\tpreorderTraversalHelper(root -> left, res);\\n\\n\\t\\tif(root -> right)\\n\\t\\t\\tpreorderTraversalHelper(root -> right, res);\\n\\t}\\n\\n\\treturn;\\n}\\n\\n\\nvector<int> preorderTraversal(TreeNode* root) \\n{   \\n\\tvector<int> res;\\n\\tpreorderTraversalHelper(root, res) ;\\n\\treturn res;\\n}\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nvoid preorderTraversalHelper(TreeNode* root, vector<int> &res) {\\n\\tif(root)\\n\\t{\\n\\t\\tres.push_back(root -> val);           \\n\\n\\t\\tif(root -> left)\\n\\t\\t\\tpreorderTraversalHelper(root -> left, res);\\n\\n\\t\\tif(root -> right)\\n\\t\\t\\tpreorderTraversalHelper(root -> right, res);\\n\\t}\\n\\n\\treturn;\\n}\\n\\n\\nvector<int> preorderTraversal(TreeNode* root) \\n{   \\n\\tvector<int> res;\\n\\tpreorderTraversalHelper(root, res) ;\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1238346,
                "title": "easy-c-solution-with-explaination",
                "content": "**AN UPVOTE WOULD BE HIGHLY APPRECIATED !!!**\\n\\n*Overload the comments section with doubts and praises if you have.!!!*\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(n)\\n\\n```\\nclass Solution {\\npublic:\\n// Declairing global variable *ans* so that we don\\'t declare it again and again and affect the SC by some factors\\n    vector<int> ans;\\n    \\n\\t// Find the preorder sequence\\n    void preorder(TreeNode* root) {\\n        if(root==NULL) {\\n            return;\\n        }\\n        ans.push_back(root->val);\\n        preorder(root->left);\\n        preorder(root->right);        \\n    }\\n    \\n    // Recieve the preorder sequence from *preorder()* and return it\\n    vector<int> preorderTraversal(TreeNode* root) {\\n   \\n        preorder(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n// Declairing global variable *ans* so that we don\\'t declare it again and again and affect the SC by some factors\\n    vector<int> ans;\\n    \\n\\t// Find the preorder sequence\\n    void preorder(TreeNode* root) {\\n        if(root==NULL) {\\n            return;\\n        }\\n        ans.push_back(root->val);\\n        preorder(root->left);\\n        preorder(root->right);        \\n    }\\n    \\n    // Recieve the preorder sequence from *preorder()* and return it\\n    vector<int> preorderTraversal(TreeNode* root) {\\n   \\n        preorder(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 520452,
                "title": "javascript-stack-98-runtime-step-by-step",
                "content": "For anyone (new to algo/ds) who\\'s beaten by this, here\\'s an step by step explanation:\\n\\n```\\ntree:\\n    1\\n  2   3\\n4  5 6  7\\n\\n1st iteration:\\nstack: [1]\\n\\n2nd iteration:\\ncurrent node = stack pop last element = 1\\ncurrent node:\\n   1\\n 2   3\\nstack push right of current node first then followed by left \\nstack: [3, 2]\\n\\n3rd iteration:\\ncurrent node = stack pop last element = 2\\ncurrent node:\\n   2\\n 4   5\\nstack push right current node first then followed by left \\nstack: [3, 5, 4]\\n\\n4th iteration:\\ncurrent node = stack pop last element = 4\\ncurrent node:\\n    4\\nnull null\\nstack push right current node first then followed by left \\nstack: [3, 5]\\n\\n5th iteration:\\ncurrent node = stack pop last element = 5\\ncurrent node:\\n    5\\nnull null\\nstack push right current node first then followed by left \\nstack: [3]\\n\\n6th iteration:\\ncurrent node = stack pop last element = 3\\ncurrent node:\\n  3\\n6   7\\nstack push right current node first then followed by left \\nstack: [7, 6]\\n\\n7th iteration:\\ncurrent node = stack pop last element = 6\\ncurrent node:\\n     6\\nnull   null\\nstack push right current node first then followed by left \\nstack: [7]\\n\\n8th iteration:\\ncurrent node = stack pop last element = 6\\ncurrent node:\\n     7\\nnull   null\\nstack push right current node first then followed by left \\nstack: []\\nstack.length === 0, false thereby terminating the for loop\\n```\\n\\n**Full code:**\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar preorderTraversal = function(root) {\\n    if (!root) {\\n        return []\\n    }\\n    \\n    let stack = [root]\\n    let arr = []\\n        \\n    while (stack.length) {\\n        let curr = stack.pop()\\n        arr.push(curr.val)\\n        \\n        if (curr.right) {\\n            stack.push(curr.right)\\n        }\\n        \\n        if (curr.left) {\\n            stack.push(curr.left)\\n        }\\n    }\\n    \\n    return arr\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\ntree:\\n    1\\n  2   3\\n4  5 6  7\\n\\n1st iteration:\\nstack: [1]\\n\\n2nd iteration:\\ncurrent node = stack pop last element = 1\\ncurrent node:\\n   1\\n 2   3\\nstack push right of current node first then followed by left \\nstack: [3, 2]\\n\\n3rd iteration:\\ncurrent node = stack pop last element = 2\\ncurrent node:\\n   2\\n 4   5\\nstack push right current node first then followed by left \\nstack: [3, 5, 4]\\n\\n4th iteration:\\ncurrent node = stack pop last element = 4\\ncurrent node:\\n    4\\nnull null\\nstack push right current node first then followed by left \\nstack: [3, 5]\\n\\n5th iteration:\\ncurrent node = stack pop last element = 5\\ncurrent node:\\n    5\\nnull null\\nstack push right current node first then followed by left \\nstack: [3]\\n\\n6th iteration:\\ncurrent node = stack pop last element = 3\\ncurrent node:\\n  3\\n6   7\\nstack push right current node first then followed by left \\nstack: [7, 6]\\n\\n7th iteration:\\ncurrent node = stack pop last element = 6\\ncurrent node:\\n     6\\nnull   null\\nstack push right current node first then followed by left \\nstack: [7]\\n\\n8th iteration:\\ncurrent node = stack pop last element = 6\\ncurrent node:\\n     7\\nnull   null\\nstack push right current node first then followed by left \\nstack: []\\nstack.length === 0, false thereby terminating the for loop\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar preorderTraversal = function(root) {\\n    if (!root) {\\n        return []\\n    }\\n    \\n    let stack = [root]\\n    let arr = []\\n        \\n    while (stack.length) {\\n        let curr = stack.pop()\\n        arr.push(curr.val)\\n        \\n        if (curr.right) {\\n            stack.push(curr.right)\\n        }\\n        \\n        if (curr.left) {\\n            stack.push(curr.left)\\n        }\\n    }\\n    \\n    return arr\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1403244,
                "title": "3-simple-python-solutions",
                "content": "##### Solution 1: Preorder traversal with stack\\n\\n```\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        ans = []\\n        stack = [root]\\n        \\n        while stack:\\n            temp = stack.pop()\\n            \\n            if temp:\\n                ans.append(temp.val)\\n                stack.append(temp.right) #as we are using stack which works on LIFO, we need to push right tree first so that left will be popped out\\n                stack.append(temp.left)\\n                \\n        return ans\\n```\\n\\n\\n##### Solution 2: With recursion for python beginners\\n```\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        ans = []\\n        if not root:\\n            return ans\\n        \\n        def preorder(node):\\n            if node:\\n                ans.append(node.val)\\n                preorder(node.left)\\n                preorder(node.right)\\n            \\n        preorder(root)\\n        return ans\\n```\\n\\n##### Solution 3: Short solution\\n```\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root:\\n            return []\\n        \\n        return [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        ans = []\\n        stack = [root]\\n        \\n        while stack:\\n            temp = stack.pop()\\n            \\n            if temp:\\n                ans.append(temp.val)\\n                stack.append(temp.right) #as we are using stack which works on LIFO, we need to push right tree first so that left will be popped out\\n                stack.append(temp.left)\\n                \\n        return ans\\n```\n```\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        ans = []\\n        if not root:\\n            return ans\\n        \\n        def preorder(node):\\n            if node:\\n                ans.append(node.val)\\n                preorder(node.left)\\n                preorder(node.right)\\n            \\n        preorder(root)\\n        return ans\\n```\n```\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root:\\n            return []\\n        \\n        return [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1321689,
                "title": "java-2-easy-approach-with-explanation-dsf-and-stack",
                "content": "```\\n1)\\n//Recursive Solution //DFS\\nclass Solution \\n{\\n    List<Integer> res= new ArrayList<>();//global ArrayList \\n\\n    public List<Integer> preorderTraversal(TreeNode root)\\n    {\\n         if(root==null)//base case for the null graph \\n             return res;\\n\\n         preorder(root);//calling the preorder in order  \\n\\n         return res;//returning gthe resultant array list \\n    }\\n\\n    public void preorder(TreeNode root)\\n    {\\n        if(root==null)//base case when we reach to the null node while recuring down hill, returning to the calling function and deleting the  activation record \\n            return;//returning to the call function or the active acttib=vation record \\n        \\n        res.add(root.val);//adding first the value, as we first see the root we are adding it to the ArrayList (Root Left Right)\\n        \\n        preorder(root.left);//recursing down hill in search of left node \\n        preorder(root.right);//after the left node is done fo the particular activation record , we are going downhill for the right node search \\n        \\n        return;//returning to the calling function or the active activation record and deleting this activation record as all the fuction are completed \\n    }\\n}//Please do Upvote, It helps a lot\\n```\\n```\\n2)\\n//Non-Recursive Solution \\nclass Solution \\n{\\n    public List<Integer> preorderTraversal(TreeNode root) \\n    {\\n        List<Integer> list=new ArrayList<>();//for storing the element inorder \\n        \\n        if(root == null)//base case when the tree is empty\\n            return list;\\n        \\n        Stack<TreeNode> stack= new Stack<>();\\n        \\n        stack.push(root);//pushing the root node \\n        \\n        while(!stack.isEmpty())//terminating condition \\n        {\\n            TreeNode temp=stack.pop();//popping the top element \\n            \\n            list.add(temp.val);//adding the value to the ArrayList //Root\\n            \\n            if(temp.right != null)//first pushing the right because to access the left first and then the right //Right\\n                stack.push(temp.right);//pushing the right node \\n            \\n            if(temp.left != null)//pushing the left node if present after right because to access the left first //Left\\n                stack.push(temp.left);\\n        }//the main purpose of pushing this way is to achive Root Left Right pattern of Inorder Traversal \\n        return list;//returning the List of integer that are stored in Inorder fashion \\n    }\\n}//Please do Upvote, It helps a lot\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Recursion",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```\\n1)\\n//Recursive Solution //DFS\\nclass Solution \\n{\\n    List<Integer> res= new ArrayList<>();//global ArrayList \\n\\n    public List<Integer> preorderTraversal(TreeNode root)\\n    {\\n         if(root==null)//base case for the null graph \\n             return res;\\n\\n         preorder(root);//calling the preorder in order  \\n\\n         return res;//returning gthe resultant array list \\n    }\\n\\n    public void preorder(TreeNode root)\\n    {\\n        if(root==null)//base case when we reach to the null node while recuring down hill, returning to the calling function and deleting the  activation record \\n            return;//returning to the call function or the active acttib=vation record \\n        \\n        res.add(root.val);//adding first the value, as we first see the root we are adding it to the ArrayList (Root Left Right)\\n        \\n        preorder(root.left);//recursing down hill in search of left node \\n        preorder(root.right);//after the left node is done fo the particular activation record , we are going downhill for the right node search \\n        \\n        return;//returning to the calling function or the active activation record and deleting this activation record as all the fuction are completed \\n    }\\n}//Please do Upvote, It helps a lot\\n```\n```\\n2)\\n//Non-Recursive Solution \\nclass Solution \\n{\\n    public List<Integer> preorderTraversal(TreeNode root) \\n    {\\n        List<Integer> list=new ArrayList<>();//for storing the element inorder \\n        \\n        if(root == null)//base case when the tree is empty\\n            return list;\\n        \\n        Stack<TreeNode> stack= new Stack<>();\\n        \\n        stack.push(root);//pushing the root node \\n        \\n        while(!stack.isEmpty())//terminating condition \\n        {\\n            TreeNode temp=stack.pop();//popping the top element \\n            \\n            list.add(temp.val);//adding the value to the ArrayList //Root\\n            \\n            if(temp.right != null)//first pushing the right because to access the left first and then the right //Right\\n                stack.push(temp.right);//pushing the right node \\n            \\n            if(temp.left != null)//pushing the left node if present after right because to access the left first //Left\\n                stack.push(temp.left);\\n        }//the main purpose of pushing this way is to achive Root Left Right pattern of Inorder Traversal \\n        return list;//returning the List of integer that are stored in Inorder fashion \\n    }\\n}//Please do Upvote, It helps a lot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 164175,
                "title": "python-solution",
                "content": "Recursive:\\n```\\nclass Solution(object):\\n    def preorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        if not root:\\n            return []\\n        elif not root.left and not root.right:\\n            return [root.val]\\n        l = self.preorderTraversal(root.left)\\n        r = self.preorderTraversal(root.right)\\n        return [root.val]+l+r\\n```\\nIterative:\\n```\\nclass Solution(object):\\n    def preorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        if not root:\\n            return []\\n        res = []\\n        stack = [root]\\n        while stack:\\n            u = stack.pop()\\n            res.append(u.val)\\n            if u.right:\\n                stack.append(u.right)\\n            if u.left:\\n                stack.append(u.left)\\n        return res\\n```\\nAnother iterative solution:\\n```\\nclass Solution(object):\\n    def preorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        trav = root\\n        stack = []\\n        res = []\\n        while trav or stack:\\n            if trav:\\n                stack.append(trav)\\n                res.append(trav.val)\\n                trav = trav.left\\n            else:\\n                u = stack.pop()\\n                trav = u.right\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def preorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        if not root:\\n            return []\\n        elif not root.left and not root.right:\\n            return [root.val]\\n        l = self.preorderTraversal(root.left)\\n        r = self.preorderTraversal(root.right)\\n        return [root.val]+l+r\\n```\n```\\nclass Solution(object):\\n    def preorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        if not root:\\n            return []\\n        res = []\\n        stack = [root]\\n        while stack:\\n            u = stack.pop()\\n            res.append(u.val)\\n            if u.right:\\n                stack.append(u.right)\\n            if u.left:\\n                stack.append(u.left)\\n        return res\\n```\n```\\nclass Solution(object):\\n    def preorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        trav = root\\n        stack = []\\n        res = []\\n        while trav or stack:\\n            if trav:\\n                stack.append(trav)\\n                res.append(trav.val)\\n                trav = trav.left\\n            else:\\n                u = stack.pop()\\n                trav = u.right\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 45416,
                "title": "share-my-solution-in-c",
                "content": "//// iterative solution\\n\\n    int* preorderTraversal(struct TreeNode* root, int* returnSize) {\\n    int *result = NULL;\\n    if (root == NULL)\\n        return result;\\n        \\n    *returnSize = 0;\\n    \\n    struct TreeNode **stack = (struct TreeNode **)malloc(sizeof(struct TreeNode *));\\n    struct TreeNode *pop;\\n    int length = 0;\\n    stack[length++] = root;\\n    \\n    while (length > 0) {\\n        result = (int *)realloc(result, (*returnSize+1)*sizeof(int));\\n        pop = stack[--length];\\n        result[*returnSize] = pop->val;\\n        *returnSize += 1;\\n        if (pop->right) {\\n            stack = (struct TreeNode **)realloc(stack, sizeof(struct TreeNode*)*(length+1));\\n            stack[length++] = pop->right;\\n        }\\n        if (pop->left) {\\n            stack = (struct TreeNode **)realloc(stack, sizeof(struct TreeNode*)*(length+1));\\n            stack[length++] = pop->left;\\n        }\\n    }\\n    free(stack);\\n    return result;\\n}\\n\\n//// recursive solution\\n\\n    int* preorderTraversal(struct TreeNode* root, int* returnSize) {\\n    int *result = NULL;\\n    if (root == NULL)\\n        return result;\\n    result = (int *)malloc(sizeof(int));\\n    *result = root->val;\\n    \\n    int leftsize=0, rightsize=0, *leftarr, *rightarr;\\n    if (root->left)\\n        leftarr = preorderTraversal(root->left, &leftsize);\\n    if (root->right)\\n        rightarr = preorderTraversal(root->right, &rightsize);\\n    \\n    *returnSize = 1 + leftsize + rightsize;\\n    if (leftsize >0 || rightsize > 0)\\n        result = (int *)realloc(result, sizeof(int)*(*returnSize));\\n    \\n    int i, j;\\n    for (i=0; i<leftsize; i++)\\n        result[i+1] = leftarr[i];\\n    if (leftsize > 0)\\n        free(leftarr);\\n    for (j=0; j<rightsize; j++)\\n        result[i+j+1] = rightarr[j];\\n    if (rightsize > 0)\\n        free(rightarr);\\n        \\n    return result;\\n}",
                "solutionTags": [],
                "code": "//// iterative solution\\n\\n    int* preorderTraversal(struct TreeNode* root, int* returnSize) {\\n    int *result = NULL;\\n    if (root == NULL)\\n        return result;\\n        \\n    *returnSize = 0;\\n    \\n    struct TreeNode **stack = (struct TreeNode **)malloc(sizeof(struct TreeNode *));\\n    struct TreeNode *pop;\\n    int length = 0;\\n    stack[length++] = root;\\n    \\n    while (length > 0) {\\n        result = (int *)realloc(result, (*returnSize+1)*sizeof(int));\\n        pop = stack[--length];\\n        result[*returnSize] = pop->val;\\n        *returnSize += 1;\\n        if (pop->right) {\\n            stack = (struct TreeNode **)realloc(stack, sizeof(struct TreeNode*)*(length+1));\\n            stack[length++] = pop->right;\\n        }\\n        if (pop->left) {\\n            stack = (struct TreeNode **)realloc(stack, sizeof(struct TreeNode*)*(length+1));\\n            stack[length++] = pop->left;\\n        }\\n    }\\n    free(stack);\\n    return result;\\n}\\n\\n//// recursive solution\\n\\n    int* preorderTraversal(struct TreeNode* root, int* returnSize) {\\n    int *result = NULL;\\n    if (root == NULL)\\n        return result;\\n    result = (int *)malloc(sizeof(int));\\n    *result = root->val;\\n    \\n    int leftsize=0, rightsize=0, *leftarr, *rightarr;\\n    if (root->left)\\n        leftarr = preorderTraversal(root->left, &leftsize);\\n    if (root->right)\\n        rightarr = preorderTraversal(root->right, &rightsize);\\n    \\n    *returnSize = 1 + leftsize + rightsize;\\n    if (leftsize >0 || rightsize > 0)\\n        result = (int *)realloc(result, sizeof(int)*(*returnSize));\\n    \\n    int i, j;\\n    for (i=0; i<leftsize; i++)\\n        result[i+1] = leftarr[i];\\n    if (leftsize > 0)\\n        free(leftarr);\\n    for (j=0; j<rightsize; j++)\\n        result[i+j+1] = rightarr[j];\\n    if (rightsize > 0)\\n        free(rightarr);\\n        \\n    return result;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1941808,
                "title": "100-fastest-swift-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    func preorderTraversal(_ root: TreeNode?) -> [Int] {\\n        var res: [Int] = []\\n        \\n        func preOrder(_ root: TreeNode?) {\\n            guard let root = root else { return }\\n            \\n            res.append(root.val)\\n            preOrder(root.left)\\n            preOrder(root.right)\\n        }\\n        \\n        preOrder(root)\\n        return res\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    func preorderTraversal(_ root: TreeNode?) -> [Int] {\\n        var res: [Int] = []\\n        \\n        func preOrder(_ root: TreeNode?) {\\n            guard let root = root else { return }\\n            \\n            res.append(root.val)\\n            preOrder(root.left)\\n            preOrder(root.right)\\n        }\\n        \\n        preOrder(root)\\n        return res\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 753215,
                "title": "c-100-time-dfs-recursive-vs-iterative-solutions-explained-and-compared",
                "content": "First in the easy, convenient way of a plain DFS: we just move `left` as much as possible, update `res` at each step and only then we have met the last `left` branch on our current path we start considering going to the `right`:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> res;\\n    void dfs(TreeNode *root) {\\n        if (!root) return;\\n        res.push_back(root->val);\\n        dfs(root->left);\\n        dfs(root->right);\\n    }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        dfs(root);\\n        return res;\\n    }\\n};\\n```\\n\\nThe iterative solution does not take too much effort either, it is just potentially less intuitive; let\\'s go with a DFS for this one as well, since going for a BFS would require needless extra complexity and more logic as we go (in other words: the interviewer should really hate you for that); the structure will be similar: class accumulator variable `res`, no external helper function needed for this one and nice loop inside to build the result.\\n\\nWe start checking if the tree is empty, in which case we just return our `res`, empty as well. If not, we declare a stack `s` and initialise it with a first push, `root` itself.\\n\\nNow the fun begins: we loop while our stack is not empty, we pop the last element, we add back its possible child - but not that we add `right` first, `left` second, since in a stack the values come out following a LIFO approach.\\n\\nTry to visualise it with the example tree of any other one you might wish to build; use pen and paper if not sure, but it works :)\\n\\nOnce the stack is empty, we are done: time to return `res`.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> res;\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        if (!root) return res;\\n        stack<TreeNode*> s;\\n        s.push(root);\\n        TreeNode *currNode;\\n        while (s.size()) {\\n            currNode = s.top();\\n            s.pop();\\n            res.push_back(currNode->val);\\n            if (currNode->right) s.push(currNode->right);\\n            if (currNode->left) s.push(currNode->left);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> res;\\n    void dfs(TreeNode *root) {\\n        if (!root) return;\\n        res.push_back(root->val);\\n        dfs(root->left);\\n        dfs(root->right);\\n    }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        dfs(root);\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> res;\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        if (!root) return res;\\n        stack<TreeNode*> s;\\n        s.push(root);\\n        TreeNode *currNode;\\n        while (s.size()) {\\n            currNode = s.top();\\n            s.pop();\\n            res.push_back(currNode->val);\\n            if (currNode->right) s.push(currNode->right);\\n            if (currNode->left) s.push(currNode->left);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1514913,
                "title": "python-recursive-iterative-simple-solutions",
                "content": "### Recursive Solution\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def traversal(self, root, preorder):\\n        if root:\\n            preorder.append(root.val)\\n            self.traversal(root.left, preorder)\\n            self.traversal(root.right, preorder)\\n            \\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        preorder = []\\n        self.traversal(root, preorder)\\n        return preorder\\n```\\n\\n### Iterative Solution\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        preorder = []\\n        stack = [root]\\n        while stack:\\n            root = stack.pop()\\n            if root:\\n                preorder.append(root.val)\\n                stack.append(root.right)\\n                stack.append(root.left)\\n        return preorder\\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def traversal(self, root, preorder):\\n        if root:\\n            preorder.append(root.val)\\n            self.traversal(root.left, preorder)\\n            self.traversal(root.right, preorder)\\n            \\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        preorder = []\\n        self.traversal(root, preorder)\\n        return preorder\\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        preorder = []\\n        stack = [root]\\n        while stack:\\n            root = stack.pop()\\n            if root:\\n                preorder.append(root.val)\\n                stack.append(root.right)\\n                stack.append(root.left)\\n        return preorder\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2443518,
                "title": "easy-0-ms-100-fully-explained-java-c-python-python3-recursive-iterative",
                "content": "# **Java Solution (Iterative Approach Using Stack):**\\nRuntime: 1 ms, faster than 93.68% of Java online submissions for Binary Tree Preorder Traversal.\\nMemory Usage: 41.3 MB, less than 84.60% of Java online submissions for Binary Tree Preorder Traversal.\\n```\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        // Create an array list to store the solution result...\\n        List<Integer> sol = new ArrayList<>();\\n        // Return the solution answer if the tree is empty...\\n        if(root == null) return sol;\\n        // Create an empty stack and push the root node...\\n        Stack<TreeNode> bag = new Stack<>();\\n        bag.push(root);\\n        // Loop till stack is empty...\\n        while(!bag.isEmpty()){\\n            // Pop a node from the stack...\\n            TreeNode node = bag.pop();\\n            sol.add(node.val);\\n            // Push the right child of the popped node into the stack...\\n            if(node.right != null) bag.push(node.right);\\n            // Push the left child of the popped node into the stack...\\n            if(node.left != null) bag.push(node.left);\\n        }\\n        return sol;     // Return the solution list...\\n    }\\n}\\n```\\n\\n# **C++ Solution (Recursive Approach):**\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Binary Tree Preorder Traversal.\\nMemory Usage: 8.5 MB, less than 42.50% of C++ online submissions for Binary Tree Preorder Traversal.\\n```\\nclass Solution {\\npublic:\\n    vector<int> sol;\\n    void preorder(TreeNode* node){\\n        if(!node) return;\\n        sol.push_back(node->val);\\n        preorder(node->left);\\n        preorder(node->right);\\n    }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        preorder(root);\\n        return sol;\\n    }\\n};\\n```\\n\\n# **Python/Python3 Solution (Iterative Approach Using Stack):**\\n```\\nclass Solution(object):\\n    def preorderTraversal(self, root):\\n        # Create an empty stack and push the root node...\\n        bag = [root]\\n        # Create an array list to store the solution result...\\n        sol = []\\n        # Loop till stack is empty...\\n        while bag:\\n            # Pop a node from the stack...\\n            node = bag.pop()\\n            if node:\\n                sol.append(node.val)\\n                # Append the right child of the popped node into the stack\\n                bag.append(node.right)\\n                # Push the left child of the popped node into the stack\\n                bag.append(node.left)\\n        return sol      # Return the solution list...\\n```\\n**I am working hard for you guys...\\nPlease upvote if you found any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        // Create an array list to store the solution result...\\n        List<Integer> sol = new ArrayList<>();\\n        // Return the solution answer if the tree is empty...\\n        if(root == null) return sol;\\n        // Create an empty stack and push the root node...\\n        Stack<TreeNode> bag = new Stack<>();\\n        bag.push(root);\\n        // Loop till stack is empty...\\n        while(!bag.isEmpty()){\\n            // Pop a node from the stack...\\n            TreeNode node = bag.pop();\\n            sol.add(node.val);\\n            // Push the right child of the popped node into the stack...\\n            if(node.right != null) bag.push(node.right);\\n            // Push the left child of the popped node into the stack...\\n            if(node.left != null) bag.push(node.left);\\n        }\\n        return sol;     // Return the solution list...\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> sol;\\n    void preorder(TreeNode* node){\\n        if(!node) return;\\n        sol.push_back(node->val);\\n        preorder(node->left);\\n        preorder(node->right);\\n    }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        preorder(root);\\n        return sol;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def preorderTraversal(self, root):\\n        # Create an empty stack and push the root node...\\n        bag = [root]\\n        # Create an array list to store the solution result...\\n        sol = []\\n        # Loop till stack is empty...\\n        while bag:\\n            # Pop a node from the stack...\\n            node = bag.pop()\\n            if node:\\n                sol.append(node.val)\\n                # Append the right child of the popped node into the stack\\n                bag.append(node.right)\\n                # Push the left child of the popped node into the stack\\n                bag.append(node.left)\\n        return sol      # Return the solution list...\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2386004,
                "title": "easiest-traversal-without-stack-queue-100-preorder",
                "content": "## **Using This Solution We Can Make Preorder Traversal In Binary Tree Without Using Stack And Queue.**\\n\\n##### Global Declaration Of Ans Vector.\\n```\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        if(root == NULL){\\n            return v;\\n        }\\n        v.push_back(root->val);\\n        preorderTraversal(root->left);\\n        preorderTraversal(root->right);\\n        return v;\\n    }\\n};\\n```\\n\\n##### Pass By Reference Ans Vector.\\n\\n```\\nclass Solution {\\npublic:\\n    void helper(TreeNode *root, vector<int> &ans){\\n        if(root == NULL) return;\\n        ans.push_back(root->val);\\n        helper(root->left,ans);\\n        helper(root->right,ans);\\n    }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> ans; helper(root,ans);\\n        return ans;\\n    }\\n};\\n```\\n\\n**Like & UpVote If You Get My Intuition Also Comment If You Have Any Query..**\\n\\n",
                "solutionTags": [
                    "Tree",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        if(root == NULL){\\n            return v;\\n        }\\n        v.push_back(root->val);\\n        preorderTraversal(root->left);\\n        preorderTraversal(root->right);\\n        return v;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void helper(TreeNode *root, vector<int> &ans){\\n        if(root == NULL) return;\\n        ans.push_back(root->val);\\n        helper(root->left,ans);\\n        helper(root->right,ans);\\n    }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> ans; helper(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 376174,
                "title": "python-preorder-inorder-postorder-iterative-and-recursive-summary",
                "content": "Preorder:\\n**144. Binary Tree Preorder Traversal**\\n> Time Complexity O(N)\\n> Space Complexity O(1)\\n```\\n## Recursively\\ndef preorderTraversal1(self, root):\\n    res = []\\n    self.dfs(root, res)\\n    return res\\n    \\ndef dfs(self, root, res):\\n    if root:\\n        res.append(root.val)\\n        self.dfs(root.left, res)\\n        self.dfs(root.right, res)\\n\\t\\t\\n## Iteratively\\ndef preorderTraversal(self, root):\\n    def preorderTraversal(self, root):\\n        stack, res = [], []\\n        while stack or root:\\n            if root:\\n                stack.append(root)\\n                res.append(root.val)    \\n                root = root.left     \\n            else:\\n                node = stack.pop()\\n                root = node.right\\n        return res\\n```\\nInorder\\n**94. Binary Tree Inorder Traversal**\\n> Time Complexity O(N)\\n> Space Complexity O(1)\\n```\\n\\n## Recursively\\ndef inorderTraversal(self, root):\\n\\tres = []\\n\\tself.helper(root, res)\\n\\treturn res\\n\\ndef helper(self, root, res):\\n\\tif root:\\n\\t\\tself.helper(root.left, res)\\n\\t\\tres.append(root.val)\\n\\t\\tself.helper(root.right, res)\\n\\n## Iteratively\\ndef inorderTraversal(self, root):\\n    res = []\\n    stack = []\\n    while stack or root:\\n        if root:\\n            stack.append(root)\\n            root = root.left\\n        else:\\n            node = stack.pop()\\n            res.append(node.val)\\n            root = node.right   \\n    return res\\n```\\nPreorder\\n**145. Binary Tree Postorder Traversal**\\n> Time Complexity O(N)\\n> Space Complexity O(1)\\n```\\n## Recursively\\ndef postorderTraversal(self, root):\\n\\tself.res = []\\n\\tself.dfs(root)\\n\\treturn self.res\\n\\ndef dfs(self, root):\\n\\tif not root:\\n\\t\\treturn \\n\\tself.dfs(root.left)\\n\\tself.dfs(root.right) \\n\\tself.res.append(root.val)\\n\\t\\n## Iteratively\\ndef postorderTraversal(self, root):\\n\\tstack, res = [], []\\n\\twhile stack or root:\\n\\t\\tif root:\\n\\t\\t\\tstack.append(root)\\n\\t\\t\\tres.append(root.val)    \\n\\t\\t\\troot = root.right \\n\\t\\telse:\\n\\t\\t\\tnode = stack.pop()\\n\\t\\t\\troot = node.left\\n\\treturn res[::-1]\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\n## Recursively\\ndef preorderTraversal1(self, root):\\n    res = []\\n    self.dfs(root, res)\\n    return res\\n    \\ndef dfs(self, root, res):\\n    if root:\\n        res.append(root.val)\\n        self.dfs(root.left, res)\\n        self.dfs(root.right, res)\\n\\t\\t\\n## Iteratively\\ndef preorderTraversal(self, root):\\n    def preorderTraversal(self, root):\\n        stack, res = [], []\\n        while stack or root:\\n            if root:\\n                stack.append(root)\\n                res.append(root.val)    \\n                root = root.left     \\n            else:\\n                node = stack.pop()\\n                root = node.right\\n        return res\\n```\n```\\n\\n## Recursively\\ndef inorderTraversal(self, root):\\n\\tres = []\\n\\tself.helper(root, res)\\n\\treturn res\\n\\ndef helper(self, root, res):\\n\\tif root:\\n\\t\\tself.helper(root.left, res)\\n\\t\\tres.append(root.val)\\n\\t\\tself.helper(root.right, res)\\n\\n## Iteratively\\ndef inorderTraversal(self, root):\\n    res = []\\n    stack = []\\n    while stack or root:\\n        if root:\\n            stack.append(root)\\n            root = root.left\\n        else:\\n            node = stack.pop()\\n            res.append(node.val)\\n            root = node.right   \\n    return res\\n```\n```\\n## Recursively\\ndef postorderTraversal(self, root):\\n\\tself.res = []\\n\\tself.dfs(root)\\n\\treturn self.res\\n\\ndef dfs(self, root):\\n\\tif not root:\\n\\t\\treturn \\n\\tself.dfs(root.left)\\n\\tself.dfs(root.right) \\n\\tself.res.append(root.val)\\n\\t\\n## Iteratively\\ndef postorderTraversal(self, root):\\n\\tstack, res = [], []\\n\\twhile stack or root:\\n\\t\\tif root:\\n\\t\\t\\tstack.append(root)\\n\\t\\t\\tres.append(root.val)    \\n\\t\\t\\troot = root.right \\n\\t\\telse:\\n\\t\\t\\tnode = stack.pop()\\n\\t\\t\\troot = node.left\\n\\treturn res[::-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 185866,
                "title": "javascript-simple-iterative-solution",
                "content": "```\\nvar preorderTraversal = function(root) {\\n  const result = [];\\n  const stack = [];\\n  let node = root;\\n  \\n  while (node) {\\n    node.val && result.push(node.val);  \\n    node.right && stack.push(node.right);      \\n    node = node.left || stack.pop(); \\n  }\\n  \\n  return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar preorderTraversal = function(root) {\\n  const result = [];\\n  const stack = [];\\n  let node = root;\\n  \\n  while (node) {\\n    node.val && result.push(node.val);  \\n    node.right && stack.push(node.right);      \\n    node = node.left || stack.pop(); \\n  }\\n  \\n  return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 45439,
                "title": "easy-to-read-java-solutions-for-both-iterative-and-recursive-300ms",
                "content": "Recursive:\\n\\n    public class Solution {\\n        List<Integer> traversal = new ArrayList<>();\\n        public List<Integer> preorderTraversal(TreeNode root) {\\n            if(root!=null){helper(root);}\\n            return traversal;\\n        }\\n        \\n        void helper (TreeNode root){\\n            traversal.add(root.val);\\n            if(root.left!=null){helper(root.left);}\\n            if(root.right!=null){helper(root.right);}\\n            \\n        }\\n    }\\n\\nIterative: Use Stack\\n\\n    public class Solution {\\n        public List<Integer> preorderTraversal(TreeNode root) {\\n            Stack<TreeNode> stack = new Stack<>();\\n            List<Integer> traversal = new ArrayList<>();\\n            if(root!=null){\\n                stack.push(root);\\n                while(!stack.isEmpty()){\\n                    TreeNode curr = stack.pop();\\n                    traversal.add(curr.val);\\n                    if(curr.right!=null){ stack.push(curr.right); }\\n                    if(curr.left!=null){ stack.push(curr.left);  }\\n                }\\n            }\\n            return traversal;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        List<Integer> traversal = new ArrayList<>();\\n        public List<Integer> preorderTraversal(TreeNode root) {\\n            if(root!=null){helper(root);}",
                "codeTag": "Java"
            },
            {
                "id": 880873,
                "title": "iterative-and-recursive-dfs-js-solutions",
                "content": "```\\n// Iterative DFS Solution\\nvar preorderTraversal = function(root) {\\n    if (!root) return [];\\n    let stack = [], res = [];\\n    stack.push(root);\\n    while (stack.length) {\\n        let node = stack.pop();\\n        res.push(node.val);\\n        if (node.right) stack.push(node.right);\\n        if (node.left) stack.push(node.left);\\n    }\\n    return res;\\n\\t// Time Complexity: O(n)\\n    // Space Complexity: O(n)\\n};\\n```\\n\\n```\\n// Recursive DFS Solution\\nvar preorderTraversal = function(root, res = []) {\\n    if (!root) return [];\\n    res.push(root.val);\\n    if (root.left) preorderTraversal(root.left, res);\\n    if (root.right) preorderTraversal(root.right, res);\\n    return res;\\n    // Time Complexity: O(n)\\n    // Space Complexity: O(n)\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// Iterative DFS Solution\\nvar preorderTraversal = function(root) {\\n    if (!root) return [];\\n    let stack = [], res = [];\\n    stack.push(root);\\n    while (stack.length) {\\n        let node = stack.pop();\\n        res.push(node.val);\\n        if (node.right) stack.push(node.right);\\n        if (node.left) stack.push(node.left);\\n    }\\n    return res;\\n\\t// Time Complexity: O(n)\\n    // Space Complexity: O(n)\\n};\\n```\n```\\n// Recursive DFS Solution\\nvar preorderTraversal = function(root, res = []) {\\n    if (!root) return [];\\n    res.push(root.val);\\n    if (root.left) preorderTraversal(root.left, res);\\n    if (root.right) preorderTraversal(root.right, res);\\n    return res;\\n    // Time Complexity: O(n)\\n    // Space Complexity: O(n)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2549333,
                "title": "leetcode-the-hard-way-dfs-pre-order-explained-line-by-line",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [YouTube Channel](https://www.youtube.com/channel/@leetcodethehardway) if you are interested.\\n\\n---\\n\\nYou may also check out my recent DFS solutions on other tree problems.\\n\\n- [987. Vertical Order Traversal of a Binary Tree](https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/discuss/2527028/leetcode-the-hard-way-easy-dfs-explained-line-by-line)\\n- [1448. Count Good Nodes in Binary Tree](https://leetcode.com/problems/count-good-nodes-in-binary-tree/discuss/2511705/leetcode-the-hard-way-dfs-explained-line-by-line)\\n- [814. Binary Tree Pruning](https://leetcode.com/problems/binary-tree-pruning/discuss/2537510/leetcode-the-hard-way-easy-dfs-explained-line-by-line)\\n- [606. Construct String from Binary Tree](https://leetcode.com/problems/construct-string-from-binary-tree/discuss/2542523/leetcode-the-hard-way-dfs-5-cases-explained-line-by-line)\\n\\nThe steps for pre-order is \\n- do something with root value\\n- traverse left subtree \\n-  traverse right sub tree. \\n\\nFor example 1, starting the root node 1.\\n\\n - At node 1 now, add root value which is 1. answer = [1]\\n- At node 1 now, traverse left node, however, there is no left node, hence return.\\n- At node 1 now, traverse right node.\\n- At node 2 now, add root value which is 2. answer = [1, 2]\\n- At node 2 now, traverse left node.\\n- At node 3 now, add root value which is 3. answer = [1, 2, 3]\\n- At node 3 now, traverse left node, however, there is no left node, hence return.\\n- At node 3 now, traverse right node, however, there is no right node, hence return.\\n- At node 2 now, traverse right node, however, there is no right node, hence return.\\n\\n**C++**\\n\\n```cpp\\n// Time Complexity: O(N)\\n// Space Complexity: O(N)\\n\\n// This is a standard pre-order traversal problem, I\\'d suggest to learn in-order and post-order as well.\\n// Here\\'s a short tutorial if you\\'re interested.\\n// https://wingkwong.github.io/leetcode-the-hard-way/tutorials/graph-theory/binary-tree\\n// then you may try the following problems \\n// 94. Binary Tree Inorder Traversal: https://leetcode.com/problems/binary-tree-inorder-traversal/\\n// 145. Binary Tree Postorder Traversal: https://leetcode.com/problems/binary-tree-postorder-traversal/\\n\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void preorder(TreeNode* node) {\\n        if (node == NULL) return;\\n        // do something with node value here\\n        ans.push_back(node->val);\\n        // traverse the left node\\n        preorder(node->left);\\n        // traverse the right node\\n        preorder(node->right);\\n    }\\n    \\n    vector<int> preorderTraversal(TreeNode* root) {\\n        preorder(root);\\n        return ans;\\n    }\\n};\\n```\\n\\n**Python**\\n\\n```py\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\n# This is a standard pre-order traversal problem, I\\'d suggest to learn in-order and post-order as well.\\n# Here\\'s a short tutorial if you\\'re interested.\\n# https://wingkwong.github.io/leetcode-the-hard-way/tutorials/graph-theory/binary-tree\\n# then you may try the following problems \\n# 94. Binary Tree Inorder Traversal: https://leetcode.com/problems/binary-tree-inorder-traversal/\\n# 145. Binary Tree Postorder Traversal: https://leetcode.com/problems/binary-tree-postorder-traversal/\\n\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\t\\t# root -> left  -> right\\n        return [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right) if root else []\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C",
                    "Recursion"
                ],
                "code": "```cpp\\n// Time Complexity: O(N)\\n// Space Complexity: O(N)\\n\\n// This is a standard pre-order traversal problem, I\\'d suggest to learn in-order and post-order as well.\\n// Here\\'s a short tutorial if you\\'re interested.\\n// https://wingkwong.github.io/leetcode-the-hard-way/tutorials/graph-theory/binary-tree\\n// then you may try the following problems \\n// 94. Binary Tree Inorder Traversal: https://leetcode.com/problems/binary-tree-inorder-traversal/\\n// 145. Binary Tree Postorder Traversal: https://leetcode.com/problems/binary-tree-postorder-traversal/\\n\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void preorder(TreeNode* node) {\\n        if (node == NULL) return;\\n        // do something with node value here\\n        ans.push_back(node->val);\\n        // traverse the left node\\n        preorder(node->left);\\n        // traverse the right node\\n        preorder(node->right);\\n    }\\n    \\n    vector<int> preorderTraversal(TreeNode* root) {\\n        preorder(root);\\n        return ans;\\n    }\\n};\\n```\n```py\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\n# This is a standard pre-order traversal problem, I\\'d suggest to learn in-order and post-order as well.\\n# Here\\'s a short tutorial if you\\'re interested.\\n# https://wingkwong.github.io/leetcode-the-hard-way/tutorials/graph-theory/binary-tree\\n# then you may try the following problems \\n# 94. Binary Tree Inorder Traversal: https://leetcode.com/problems/binary-tree-inorder-traversal/\\n# 145. Binary Tree Postorder Traversal: https://leetcode.com/problems/binary-tree-postorder-traversal/\\n\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\t\\t# root -> left  -> right\\n        return [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right) if root else []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1588301,
                "title": "java-easy-solution-0ms-100-faster-recursion",
                "content": "**Code**\\n\\n```java\\npublic List<Integer> preorderTraversal(TreeNode root) {\\n\\tList<Integer> list = new ArrayList<>();\\n\\tpreorder(root, list);\\n\\treturn list;\\n}\\n\\npublic void preorder(TreeNode root, List<Integer> list) {\\n\\tif(root == null) return;\\n\\n\\tlist.add(root.val);\\n\\tpreorder(root.left, list);\\n\\tpreorder(root.right, list);\\n}\\n```\\n\\nHope it helps\\nDo upvote\\nThanks",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```java\\npublic List<Integer> preorderTraversal(TreeNode root) {\\n\\tList<Integer> list = new ArrayList<>();\\n\\tpreorder(root, list);\\n\\treturn list;\\n}\\n\\npublic void preorder(TreeNode root, List<Integer> list) {\\n\\tif(root == null) return;\\n\\n\\tlist.add(root.val);\\n\\tpreorder(root.left, list);\\n\\tpreorder(root.right, list);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1007458,
                "title": "simple-recursive-javascript-solution",
                "content": "```\\nvar preorderTraversal = function solution(root) {\\n    if (!root) {\\n        return [];\\n    }\\n    \\n    return [root.val, ...solution(root.left), ...solution(root.right)];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar preorderTraversal = function solution(root) {\\n    if (!root) {\\n        return [];\\n    }\\n    \\n    return [root.val, ...solution(root.left), ...solution(root.right)];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 45312,
                "title": "three-ways-of-iterative-preorder-traversing-easy-explanation",
                "content": "Three types of Iterative Preorder Traversals in java. \\n\\n1) **Using 1 Stack.** O(n) Time & O(n) Space\\n\\t* Print and push all `left` nodes into the `stack` till it hits `NULL`.\\n\\t* Then `Pop` the top element from the stack, and make the `root` point to its `right`.\\n\\t* Keep iterating till `both` the below conditions are met -\\n\\t\\t* Stack is empty `and`\\n        * Root is NULL.\\n\\t\\n\\n```\\n\\npublic List<Integer> preorderTraversal(TreeNode root) {\\n\\t\\tList<Integer> out = new ArrayList<Integer>();\\n\\t\\tif(root==null)\\n\\t\\t\\treturn out;\\n\\t\\tStack<TreeNode> s = new Stack();      \\n\\t\\twhile(root!=null || !s.empty()){\\n\\t\\t\\tif(root!=null){\\n\\t\\t\\t\\tout.add(root.val);\\n\\t\\t\\t\\ts.push(root);\\n\\t\\t\\t\\troot = root.left;\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\troot = s.pop();\\t\\t\\t\\t\\n\\t\\t\\t\\troot = root.right;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn out;\\n\\t}\\n\\t\\n```\\n\\n2) **Using 2 Stacks.** O(n) Time & O(n) Space\\nWe use two stacks. Stack `s` is used to find and traverse the child nodes, and `path` stack keeps track of the path from the `root` to the current node. (This is usefull in certain problems like [Binary Tree Paths](https://leetcode.com/problems/binary-tree-paths/) and [Path Sum](https://leetcode.com/problems/path-sum/) ). \\n    * Initially we push the `root` into `s`.\\n\\t* Keep iterating with below logic till `s` is `empty`.\\n\\t\\t* `root` = `s.peek()`\\n\\t\\t* If the top elements of both the stacks are not the same :\\t\\t\\n\\t\\t\\t* Print `root` and push it into `path`.\\n\\t\\t\\t* Push `root`\\'s children into `s` in reverse order. (Remember it\\'s a stack!)\\n\\t\\t* When top elements of both stacks are equal. (Which means we hit a deadend, and need to turn back)\\n\\t\\t\\t* `Pop` from `both` stacks.\\n\\t\\n\\t\\n```\\n\\npublic List<Integer> preorderTraversal(TreeNode root) {\\n\\t\\tList<Integer> out = new ArrayList<Integer>();\\n        if(root == null)\\n            return out; \\n        Stack<TreeNode> s = new Stack(), path = new Stack();\\n        s.push(root);\\n        while(!s.empty()){\\n            root = s.peek();\\n            if(!path.empty() && path.peek()==root){\\n                s.pop();\\n                path.pop();\\n            }\\n            else{\\n                out.add(root.val);\\n                path.push(root);\\n                if(root.right != null)\\n                    s.push(root.right);\\n                if(root.left != null)\\n                    s.push(root.left);\\n            }\\n        }\\n\\t    return out;\\n    }\\n\\t\\n```\\n\\n3) **Using No Stacks (Morris Traversal).** O(n) Time & O(1) Space\\nInstead of using stacks to remember our way back up the tree, we are going to modify the tree to create upwards links. The idea is based on [Threaded Binary Tree](https://en.wikipedia.org/wiki/Threaded_binary_tree). \\n\\t* Iterate till `root` is null.\\n\\t\\t* If `root` has a left child.\\n\\t\\t\\t* Find the `inorder predecessor`. (Inorder predecessor of root is the right most child of its left child)\\n\\t\\t\\t\\t* Make it point to root.\\n\\t\\t\\t\\t* `root` = `root.left`.\\n\\t\\t\\t* If its already pointing to root (which means we have traversed it already and are on our way up.)\\n\\t\\t\\t\\t* Make the `inorder predecessor` point to `null` (Reverting our structural changes)\\n\\t\\t\\t\\t* `root` = `root.right`.\\n\\t\\t* If left child is `null`\\n\\t\\t\\t* `root` = `root.right`. (We are climbing up our link.)\\n\\n\\t\\t\\t\\n```\\n\\npublic List<Integer> preorderTraversal(TreeNode root) {\\n\\t\\tList<Integer> out = new ArrayList<Integer>();\\n\\t\\tif(root == null)\\n\\t\\t\\treturn out;\\n\\t\\tTreeNode pre = null;\\n\\t\\twhile(root!=null){\\n\\t\\t\\tif(root.left !=null){\\n\\t\\t\\t\\tpre = root.left;\\n\\t\\t\\t\\t\\twhile(pre.right!=null && pre.right!=root)\\n\\t\\t\\t\\t\\tpre=pre.right;\\n\\t\\t\\t\\tif(pre.right==null){\\n\\t\\t\\t\\t\\tout.add(root.val);\\n\\t\\t\\t\\t\\tpre.right=root;\\n\\t\\t\\t\\t\\troot=root.left;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tpre.right=null;\\n\\t\\t\\t\\t\\troot=root.right;\\n\\t\\t\\t\\t}                   \\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tout.add(root.val);\\n\\t\\t\\t\\troot=root.right;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn out;\\n\\t}\\n\\t\\n```\\n\\nAlso checkout [Inorder](https://discuss.leetcode.com/topic/64682/three-ways-of-iterative-inorder-traversing-easy-explanation)  & [PostOrder](https://discuss.leetcode.com/topic/64689/three-ways-of-iterative-postorder-traversing-easy-explanation)  :))",
                "solutionTags": [],
                "code": "```\\n\\npublic List<Integer> preorderTraversal(TreeNode root) {\\n\\t\\tList<Integer> out = new ArrayList<Integer>();\\n\\t\\tif(root==null)\\n\\t\\t\\treturn out;\\n\\t\\tStack<TreeNode> s = new Stack();      \\n\\t\\twhile(root!=null || !s.empty()){\\n\\t\\t\\tif(root!=null){\\n\\t\\t\\t\\tout.add(root.val);\\n\\t\\t\\t\\ts.push(root);\\n\\t\\t\\t\\troot = root.left;\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\troot = s.pop();\\t\\t\\t\\t\\n\\t\\t\\t\\troot = root.right;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn out;\\n\\t}\\n\\t\\n```\n```\\n\\npublic List<Integer> preorderTraversal(TreeNode root) {\\n\\t\\tList<Integer> out = new ArrayList<Integer>();\\n        if(root == null)\\n            return out; \\n        Stack<TreeNode> s = new Stack(), path = new Stack();\\n        s.push(root);\\n        while(!s.empty()){\\n            root = s.peek();\\n            if(!path.empty() && path.peek()==root){\\n                s.pop();\\n                path.pop();\\n            }\\n            else{\\n                out.add(root.val);\\n                path.push(root);\\n                if(root.right != null)\\n                    s.push(root.right);\\n                if(root.left != null)\\n                    s.push(root.left);\\n            }\\n        }\\n\\t    return out;\\n    }\\n\\t\\n```\n```\\n\\npublic List<Integer> preorderTraversal(TreeNode root) {\\n\\t\\tList<Integer> out = new ArrayList<Integer>();\\n\\t\\tif(root == null)\\n\\t\\t\\treturn out;\\n\\t\\tTreeNode pre = null;\\n\\t\\twhile(root!=null){\\n\\t\\t\\tif(root.left !=null){\\n\\t\\t\\t\\tpre = root.left;\\n\\t\\t\\t\\t\\twhile(pre.right!=null && pre.right!=root)\\n\\t\\t\\t\\t\\tpre=pre.right;\\n\\t\\t\\t\\tif(pre.right==null){\\n\\t\\t\\t\\t\\tout.add(root.val);\\n\\t\\t\\t\\t\\tpre.right=root;\\n\\t\\t\\t\\t\\troot=root.left;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tpre.right=null;\\n\\t\\t\\t\\t\\troot=root.right;\\n\\t\\t\\t\\t}                   \\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tout.add(root.val);\\n\\t\\t\\t\\troot=root.right;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn out;\\n\\t}\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1724145,
                "title": "python-3-30ms-perfect-pythonic-recursive-one-liner-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if root is None:\\n            return []\\n        return [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if root is None:\\n            return []\\n        return [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961907,
                "title": "extremely-simple-morris-traversal-pre-in-post-order-summary",
                "content": "There are a lot of introductions about how Morris Traversal works. It is a beautiful algorithm which takes only O(1) space complexity while still maintaining O(n) time complexity. Here I summarized how Morris Traversal is implemented w.r.t. all three orders. \\n\\n**Pre-Order:**\\n```\\ndef preorderTraversal(self, root: TreeNode) -> List[int]:\\n       \\n\\tres = []\\n\\n\\twhile root:\\n\\t\\tif root.left:\\n\\t\\t\\ttemp = root.left\\n\\t\\t\\twhile temp.right and temp.right != root:\\n\\t\\t\\t\\ttemp = temp.right\\n\\t\\t\\tif not temp.right:\\n\\t\\t\\t\\tres.append(root.val) \\n\\t\\t\\t\\ttemp.right = root\\n\\t\\t\\t\\troot = root.left\\n\\t\\t\\telse:\\n\\t\\t\\t\\ttemp.right = None \\n\\t\\t\\t\\troot = root.right\\n\\t\\telse:\\n\\t\\t\\tres.append(root.val)\\n\\t\\t\\troot = root.right\\n\\n\\treturn res\\n```\\n**In-Order**: \\n\\nCompared to Pre-Order implementation, the change is just one line as maked \"***\"\\n```\\ndef inorderTraversal(self, root: TreeNode) -> List[int]:\\n  \\n\\tres = []\\n\\n\\twhile root:\\n\\t\\tif root.left:\\n\\t\\t\\ttemp = root.left\\n\\t\\t\\twhile temp.right and temp.right != root:\\n\\t\\t\\t\\ttemp = temp.right\\n\\t\\t\\tif not temp.right:\\n\\t\\t\\t\\ttemp.right = root\\n\\t\\t\\t\\troot = root.left\\n\\t\\t\\telse:\\n\\t\\t\\t\\tres.append(root.val)    # ***\\n\\t\\t\\t\\ttemp.right = None\\n\\t\\t\\t\\troot = root.right\\n\\t\\telse:\\n\\t\\t\\tres.append(root.val)\\n\\t\\t\\troot = root.right\\n\\n\\treturn res\\n```\\n**Post-Order:**\\n\\nI saw many implementations for the Post-Order to be very complex and hard to remember. Here I provide a simple version. It is very similar to the pre-order one, except that now we are doing everything reversely. By this I mean we go along the direction of right child and link the leftmost child on the right sub tree to the root. Then we leftappend the val to the result. \\n\\nTHAT`S IT!!\\n```\\ndef postorderTraversal(self, root: TreeNode) -> List[int]:\\n\\t\\n\\tres = deque()\\n\\n\\twhile root:\\n\\t\\tif root.right:\\n\\t\\t\\ttemp = root.right\\n\\t\\t\\twhile temp.left and temp.left != root:\\n\\t\\t\\t\\ttemp = temp.left\\n\\t\\t\\tif not temp.left:\\n\\t\\t\\t\\tres.appendleft(root.val)\\n\\t\\t\\t\\ttemp.left = root\\n\\t\\t\\t\\troot = root.right\\n\\t\\t\\telse:\\n\\t\\t\\t\\ttemp.left = None\\n\\t\\t\\t\\troot = root.left\\n\\t\\telse:\\n\\t\\t\\tres.appendleft(root.val)\\n\\t\\t\\troot = root.left\\n\\n\\treturn res\\n```\\n\\nHope you like it. Cheers.",
                "solutionTags": [],
                "code": "```\\ndef preorderTraversal(self, root: TreeNode) -> List[int]:\\n       \\n\\tres = []\\n\\n\\twhile root:\\n\\t\\tif root.left:\\n\\t\\t\\ttemp = root.left\\n\\t\\t\\twhile temp.right and temp.right != root:\\n\\t\\t\\t\\ttemp = temp.right\\n\\t\\t\\tif not temp.right:\\n\\t\\t\\t\\tres.append(root.val) \\n\\t\\t\\t\\ttemp.right = root\\n\\t\\t\\t\\troot = root.left\\n\\t\\t\\telse:\\n\\t\\t\\t\\ttemp.right = None \\n\\t\\t\\t\\troot = root.right\\n\\t\\telse:\\n\\t\\t\\tres.append(root.val)\\n\\t\\t\\troot = root.right\\n\\n\\treturn res\\n```\n```\\ndef inorderTraversal(self, root: TreeNode) -> List[int]:\\n  \\n\\tres = []\\n\\n\\twhile root:\\n\\t\\tif root.left:\\n\\t\\t\\ttemp = root.left\\n\\t\\t\\twhile temp.right and temp.right != root:\\n\\t\\t\\t\\ttemp = temp.right\\n\\t\\t\\tif not temp.right:\\n\\t\\t\\t\\ttemp.right = root\\n\\t\\t\\t\\troot = root.left\\n\\t\\t\\telse:\\n\\t\\t\\t\\tres.append(root.val)    # ***\\n\\t\\t\\t\\ttemp.right = None\\n\\t\\t\\t\\troot = root.right\\n\\t\\telse:\\n\\t\\t\\tres.append(root.val)\\n\\t\\t\\troot = root.right\\n\\n\\treturn res\\n```\n```\\ndef postorderTraversal(self, root: TreeNode) -> List[int]:\\n\\t\\n\\tres = deque()\\n\\n\\twhile root:\\n\\t\\tif root.right:\\n\\t\\t\\ttemp = root.right\\n\\t\\t\\twhile temp.left and temp.left != root:\\n\\t\\t\\t\\ttemp = temp.left\\n\\t\\t\\tif not temp.left:\\n\\t\\t\\t\\tres.appendleft(root.val)\\n\\t\\t\\t\\ttemp.left = root\\n\\t\\t\\t\\troot = root.right\\n\\t\\t\\telse:\\n\\t\\t\\t\\ttemp.left = None\\n\\t\\t\\t\\troot = root.left\\n\\t\\telse:\\n\\t\\t\\tres.appendleft(root.val)\\n\\t\\t\\troot = root.left\\n\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 177117,
                "title": "simple-iterative-javascript-solution",
                "content": "Of the three main types of binary tree traversals (inorder,preorder,postorder), I find preorder traversal the easiest to implement iteratively. You can just reuse the dfs algorithm, but make sure you push the children onto the stack in such a way that the left child is processed before the right child.\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar preorderTraversal = function(root) {\\n    var stack = [];\\n\\t\\t\\n    // We do not push the root node onto the stack if the root node is null. This way we will avoid\\n    // going into the while loop when the root is null and just return an empty array as the result. \\n    if(root !== null){\\n        stack.push(root);\\n    }\\n    \\n    // Initialize the result to an empty array \\n    var res = [];\\n\\t\\t\\n    // Keep iterating while there is something on the stack\\n    while(stack.length > 0){\\n        var node = stack.pop();\\n\\t\\t\\t\\t\\n\\t// Do the preorder processing\\n        res.push(node.val);\\n\\t\\t\\t\\t\\n        // If there is a right child, push it onto the stack. \\n        if(node.right !== null){\\n            stack.push(node.right);\\n        }\\n\\t\\t\\t\\t\\n        // If there is a left child, push it onto the stack. \\n        if(node.left !== null){\\n            stack.push(node.left);\\n        }\\n    }\\n    \\n    return res; \\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar preorderTraversal = function(root) {\\n    var stack = [];\\n\\t\\t\\n    // We do not push the root node onto the stack if the root node is null. This way we will avoid\\n    // going into the while loop when the root is null and just return an empty array as the result. \\n    if(root !== null){\\n        stack.push(root);\\n    }\\n    \\n    // Initialize the result to an empty array \\n    var res = [];\\n\\t\\t\\n    // Keep iterating while there is something on the stack\\n    while(stack.length > 0){\\n        var node = stack.pop();\\n\\t\\t\\t\\t\\n\\t// Do the preorder processing\\n        res.push(node.val);\\n\\t\\t\\t\\t\\n        // If there is a right child, push it onto the stack. \\n        if(node.right !== null){\\n            stack.push(node.right);\\n        }\\n\\t\\t\\t\\t\\n        // If there is a left child, push it onto the stack. \\n        if(node.left !== null){\\n            stack.push(node.left);\\n        }\\n    }\\n    \\n    return res; \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3022456,
                "title": "java-explained-in-detail-simple-fast-solution-recursive-iterative",
                "content": "I do my best everyday to give a clear explanation, so to help everyone improve their skills.\\n\\nIf you find this **helpful**, please \\uD83D\\uDC4D **upvote** this post and watch my [Github Repository](https://github.com/cheehwatang/leetcode-java).\\n\\nThank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.\\n\\n---\\n\\n# Approach\\n\\nAlgorithm for Preorder(tree)\\n   1. Visit the root.\\n   2. Traverse the left subtree\\n   3. Traverse the right subtree\\n\\nExample:\\n![image](https://assets.leetcode.com/users/images/3d49dfe8-0dd8-4537-8636-0a6f1a035377_1663136628.9607692.png)\\nSteps:\\n1. At node 1 now, add root value 1 => Integers[1]\\n2. At node 1 now, traverse the left node.\\n3. At node 2 now, add root value 2 => Integers[1, 2]\\n4. At node 2 now, traverse the left node.\\n5. At node 4 now, add root value 4 => Integers[1, 2, 4]\\n6. At node 4 now, traverse the left node. Since no left node (null), return to node 4.\\n7. At node 4 now, traverse the right node. Since no right node (null), return to node 4, then node 2.\\n8. At node 2 now, traverse the right node.\\n9. At node 5 now, add root value 5 => Integers[1, 2, 4, 5]\\n10. At node 5 now, traverse the left node. Since no left node (null), return to node 5.\\n11. At node 5 now, traverse the right node. Since no right node (null), return to node 5, then node 2, then node 1.\\n12. At node 1 now, traverse the riht node.\\n13. At node 3 now, add root value 3 => Integers[1, 2, 4, 5, 3]\\n14. At node 3 now, traverse the left node. Since no left node (null), return to node 3.\\n15. At node 3 now, traverse the right node. Since no right node (null), end traversal.\\n\\nAs shown, each node here has the traversal sequence of root -> left -> right.\\n\\n---\\n\\n# Recursive Implementation:\\n\\n## Complexity\\n- Time Complexity  : O(n), \\nwhere \\'n\\' is the number of nodes in the tree, as we are traversing every single node.\\nHowever, this does not take into account the resizing of the array backing the LinkedList, depending on the size of nodes in the tree.\\n\\n- Space Complexity : O(n), \\nwhere \\'n\\' is the number of nodes in the tree, as we are recording the value of every node into the List.\\nThe recursive call stack only takes up the maximum space of tree height, which is smaller than \\'n\\'.\\n\\n## Java - With Explanation (Recursive)\\n\\n```\\nclass Solution {\\n\\n    // Wrapper method to set up and initialize the recursive function.\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> integerList = new LinkedList<>();\\n        integerList = preorderTraversal(root, integerList);\\n        return integerList;\\n    }\\n\\n    // Recursive method.\\n    private List<Integer> preorderTraversal(TreeNode root, List<Integer> integerList) {\\n        // The base case, for when the root is null.\\n        if (root == null) return integerList;\\n\\n        // For preorder traversal, we first visit the root and add the value of the root to the list.\\n        integerList.add(root.val);\\n        // Then, we visit the left node.\\n        preorderTraversal(root.left, integerList);\\n        // Lastly, we visit the right node.\\n        preorderTraversal(root.right, integerList);\\n\\n        // Once done, we return the list.\\n        return integerList;\\n    }\\n}\\n```\\n\\n## Java - Clean Code (Recursive)\\n\\n```\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> integerList = new LinkedList<>();\\n        integerList = preorderTraversal(root, integerList);\\n        return integerList;\\n    }\\n\\n    private List<Integer> preorderTraversal(TreeNode root, List<Integer> integerList) {\\n        if (root == null) return integerList;\\n\\n        integerList.add(root.val);\\n        preorderTraversal(root.left, integerList);\\n        preorderTraversal(root.right, integerList);\\n\\n        return integerList;\\n    }\\n}\\n```\\n\\n---\\n\\n# Iterative Implementation:\\n\\n## Complexity\\n- Time Complexity  : O(n), \\nwhere \\'n\\' is the number of nodes in the tree, as we are traversing every single node.\\nHowever, this does not take into account the resizing of the array backing the LinkedList, depending on the size of nodes in the tree.\\n\\n- Space Complexity : O(n), \\nwhere \\'n\\' is the number of nodes in the tree, as we are recording the data of every node into the List.\\nThe stack only takes up the maximum space of tree height, which is smaller than \\'n\\'.\\n\\n## Java - With Explanation (Iterative)\\n\\n```\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> integerList = new LinkedList<>();\\n        Stack<TreeNode> rightNodes = new Stack<>();\\n\\n        while (root != null) {\\n            // First, we record the root.\\n            integerList.add(root.val);\\n\\n            // If right node is available, push the right node into the Stack first.\\n            // We will pop it later we are done with the left nodes.\\n            if (root.right != null) {\\n                rightNodes.push(root.right);\\n            }\\n\\n            // Continue to traverse to the left, while recording each subtree root nodes,\\n            // and pushing the subtree right nodes into the stack.\\n            // Once reaches a leaf node, pop the right nodes and continue.\\n            root = root.left;\\n            if (root == null && !rightNodes.isEmpty()) {\\n                root = rightNodes.pop();\\n            }\\n        }\\n        // Fully traversed the tree.\\n        return integerList;\\n    }\\n}\\n```\\n\\n## Java - Clean Code (Iterative)\\n\\n```\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> integerList = new LinkedList<>();\\n        Stack<TreeNode> rightNodes = new Stack<>();\\n\\n        while (root != null) {\\n            integerList.add(root.val);\\n\\n            if (root.right != null) {\\n                rightNodes.push(root.right);\\n            }\\n\\n            root = root.left;\\n            if (root == null && !rightNodes.isEmpty()) {\\n                root = rightNodes.pop();\\n            }\\n        }\\n        return integerList;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Stack",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n\\n    // Wrapper method to set up and initialize the recursive function.\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> integerList = new LinkedList<>();\\n        integerList = preorderTraversal(root, integerList);\\n        return integerList;\\n    }\\n\\n    // Recursive method.\\n    private List<Integer> preorderTraversal(TreeNode root, List<Integer> integerList) {\\n        // The base case, for when the root is null.\\n        if (root == null) return integerList;\\n\\n        // For preorder traversal, we first visit the root and add the value of the root to the list.\\n        integerList.add(root.val);\\n        // Then, we visit the left node.\\n        preorderTraversal(root.left, integerList);\\n        // Lastly, we visit the right node.\\n        preorderTraversal(root.right, integerList);\\n\\n        // Once done, we return the list.\\n        return integerList;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> integerList = new LinkedList<>();\\n        integerList = preorderTraversal(root, integerList);\\n        return integerList;\\n    }\\n\\n    private List<Integer> preorderTraversal(TreeNode root, List<Integer> integerList) {\\n        if (root == null) return integerList;\\n\\n        integerList.add(root.val);\\n        preorderTraversal(root.left, integerList);\\n        preorderTraversal(root.right, integerList);\\n\\n        return integerList;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> integerList = new LinkedList<>();\\n        Stack<TreeNode> rightNodes = new Stack<>();\\n\\n        while (root != null) {\\n            // First, we record the root.\\n            integerList.add(root.val);\\n\\n            // If right node is available, push the right node into the Stack first.\\n            // We will pop it later we are done with the left nodes.\\n            if (root.right != null) {\\n                rightNodes.push(root.right);\\n            }\\n\\n            // Continue to traverse to the left, while recording each subtree root nodes,\\n            // and pushing the subtree right nodes into the stack.\\n            // Once reaches a leaf node, pop the right nodes and continue.\\n            root = root.left;\\n            if (root == null && !rightNodes.isEmpty()) {\\n                root = rightNodes.pop();\\n            }\\n        }\\n        // Fully traversed the tree.\\n        return integerList;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> integerList = new LinkedList<>();\\n        Stack<TreeNode> rightNodes = new Stack<>();\\n\\n        while (root != null) {\\n            integerList.add(root.val);\\n\\n            if (root.right != null) {\\n                rightNodes.push(root.right);\\n            }\\n\\n            root = root.left;\\n            if (root == null && !rightNodes.isEmpty()) {\\n                root = rightNodes.pop();\\n            }\\n        }\\n        return integerList;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2827152,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* cur_node = head;\\n        while (cur_node && cur_node->next) {\\n            ListNode* next_node = cur_node->next;\\n            if (cur_node->val == next_node->val)\\n                cur_node->next = next_node->next;\\n            else\\n                cur_node = next_node;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* cur_node = head;\\n        while (cur_node && cur_node->next) {\\n            ListNode* next_node = cur_node->next;\\n            if (cur_node->val == next_node->val)\\n                cur_node->next = next_node->next;\\n            else\\n                cur_node = next_node;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2778147,
                "title": "c-solutiona-0-ms-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> preorder;\\n        stack<TreeNode*> stack;\\n        if (root == NULL)\\n            return preorder;\\n        stack.push(root);\\n        while(!stack.empty()) {\\n            TreeNode* curr = stack.top();\\n            stack.pop();\\n            preorder.push_back(curr->val);\\n            if (curr->right != NULL)\\n                stack.push(curr->right);\\n            if (curr->left != NULL)\\n                stack.push(curr->left);\\n        }\\n        return preorder;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> preorder;\\n        stack<TreeNode*> stack;\\n        if (root == NULL)\\n            return preorder;\\n        stack.push(root);\\n        while(!stack.empty()) {\\n            TreeNode* curr = stack.top();\\n            stack.pop();\\n            preorder.push_back(curr->val);\\n            if (curr->right != NULL)\\n                stack.push(curr->right);\\n            if (curr->left != NULL)\\n                stack.push(curr->left);\\n        }\\n        return preorder;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1260651,
                "title": "c-recursive-and-iterative-using-stack-with-explanation",
                "content": "Pre-order traversal is to visit the root first. Then traverse the left subtree. Finally, traverse the right subtree. \\n> Preorder: **visit > left > right**\\n\\n**Iterative Approach**\\n* We need to use a `Stack` to remember the sub-trees as we go deeper\\n* Since `stack`s are `first-in-last-out` approach, we need to:\\n\\t* **Visit**:  Add the node to the `list`\\n\\t* `Push` the `right sub-tree` first, then\\n\\t* `Push` the `left sub-tree`\\n* So, when we `pop` the stack, \\n\\t* We get the `left sub-tree` first *before* the `right sub-tree` since it\\'s pushed last\\n\\n```csharp\\npublic class Solution {\\n    public IList<int> PreorderTraversal(TreeNode root) {\\n        IList<int> preorder = new List<int>();\\n        \\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        TreeNode node = root;\\n        \\n        if (node != null)\\n            stack.Push(node);\\n        \\n        // visit > left > right\\n        while (stack.Count > 0) {\\n            node = stack.Pop();\\n            preorder.Add(node.val); // Visit\\n            \\n            if (node.right != null) { // Push right\\n                stack.Push(node.right);\\n            }\\n            \\n            if (node.left != null) { // Push left\\n                stack.Push(node.left);\\n            }\\n            \\n        }\\n        \\n        return preorder;\\n    }\\n}\\n```\\n\\n**Recursive Approach**\\n* Recursion is the straightforward approach and mimics the concept of `visit > left > right` for `preorder` traversals\\n* We need to pass the `list` as a parameter so we can add the values of the visited nodes to it\\n* **Alternative approach**: instead of passing `preorder` list, you can make it a `global` field. \\n* **Another approach**: final approach would be for the helper function to `return` the `preorder` list\\n\\n``` csharp\\npublic class Solution {\\n    public IList<int> PreorderTraversal(TreeNode root) { \\n        IList<int> preorder = new List<int>();\\n        PreOrder(preorder, root);\\n        \\n        return preorder;\\n    }\\n    \\n    private void PreOrder(IList<int> list, TreeNode node) {\\n        if (node == null) return;\\n        \\n        list.Add(node.val);         // Visit\\n        PreOrder(list, node.left);  // Left\\n        PreOrder(list, node.right); // Right\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Stack",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```csharp\\npublic class Solution {\\n    public IList<int> PreorderTraversal(TreeNode root) {\\n        IList<int> preorder = new List<int>();\\n        \\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        TreeNode node = root;\\n        \\n        if (node != null)\\n            stack.Push(node);\\n        \\n        // visit > left > right\\n        while (stack.Count > 0) {\\n            node = stack.Pop();\\n            preorder.Add(node.val); // Visit\\n            \\n            if (node.right != null) { // Push right\\n                stack.Push(node.right);\\n            }\\n            \\n            if (node.left != null) { // Push left\\n                stack.Push(node.left);\\n            }\\n            \\n        }\\n        \\n        return preorder;\\n    }\\n}\\n```\n``` csharp\\npublic class Solution {\\n    public IList<int> PreorderTraversal(TreeNode root) { \\n        IList<int> preorder = new List<int>();\\n        PreOrder(preorder, root);\\n        \\n        return preorder;\\n    }\\n    \\n    private void PreOrder(IList<int> list, TreeNode node) {\\n        if (node == null) return;\\n        \\n        list.Add(node.val);         // Visit\\n        PreOrder(list, node.left);  // Left\\n        PreOrder(list, node.right); // Right\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 504591,
                "title": "an-iterative-3-in-1-template-for-pre-in-post-order-traversal",
                "content": "## Explanation\\n\\nOne only needs to write the code to the corresponding block.\\n\\nThe concept is exactly how recursion works.\\nWe:\\n\\n- only traverse while the stack is not empty.  (#0)\\n- push a left child to the stack right after a pre-order region.  (#3)\\n- push a right child to the stack right after an in-order region.  (#6)\\n- pop the stack right after a post-order region.  (#8)\\n\\nAnd there are some implementation details:\\n\\n-  If a traversal is not a in-order nor post-order traversal, it\\'s a pre-order traversal. (#1)\\n-  Use a `while (true)` with a `if` statement inside to ensure `node` is not null outside the loop.  (#2, #4)\\n-  If a node has no right child, the in-order operation and post-order operation happen simutaneously. (#5, #7)\\n-  `prev` is the last post-order traversed node. (#9)\\n\\n## Template\\n\\n```C++\\n        stack<TreeNode*> stack{};\\n        TreeNode* prev = nullptr;\\n\\n        if (root)\\n            stack.push(root);\\n        while (not stack.empty()) {  // #0\\n            TreeNode* node = stack.top();\\n\\n            if (not prev or\\n                prev != node->left and prev != node->right) {  // #1\\n                while (true) {\\n                    // Pre-order region {\\n                    //   do_something();\\n                    // }\\n                    if (not node->left)\\n                        break;   // #2\\n                    node = node->left;\\n                    stack.push(node);  // #3\\n                }\\n            }\\n            // #4\\n            if (not node->right or prev != node->right) {  // #5\\n                // In-order region {\\n                //   do_something();\\n                // }\\n                if (node->right)\\n                    stack.push(node->right);  // #6\\n            }\\n\\n            if (not node->right or prev == node->right) {  // #7\\n                // Post-order region {\\n                //   do_something();\\n                // }\\n                stack.pop();  // #8\\n                prev = node;  // #9\\n            }\\n        }\\n```\\n\\n## A slightly changed version\\n\\n```C++\\n        stack<TreeNode*> stack{};\\n        TreeNode* node = root;\\n        TreeNode* prev = nullptr;\\n\\n        while (node or not stack.empty()) {\\n            while (node) {\\n                // Pre-order region {\\n                //   do_something();\\n                // }\\n                stack.push(node);\\n                node = node->left;\\n            }\\n            node = stack.top();\\n\\n            if (not node->right or prev != node->right) {\\n                // In-order region {\\n                //   do_something();\\n                // }\\n                if (node->right) {\\n                    node = node->right;\\n                    continue;\\n                }\\n            }\\n\\n            if (not node->right or prev == node->right) {\\n                // Post-order region {\\n                //   do_something();\\n                // }\\n                stack.pop();\\n                prev = node;\\n                node = nullptr;\\n            }\\n        }\\n```\\n\\n## Examples\\n\\n### [Problem: Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/)\\n\\n```C++\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> result{};\\n        stack<TreeNode*> stack{};\\n        TreeNode* prev = nullptr;\\n\\n        if (root)\\n            stack.push(root);\\n        while (not stack.empty()) {\\n            TreeNode* node = stack.top();\\n\\n            if (not prev or\\n                prev != node->left and prev != node->right) {\\n                while (true) {\\n                    // Pre-order region {\\n                    result.push_back(node->val);  // <-------------- See here!\\n                    // }\\n                    if (not node->left)\\n                        break;\\n                    node = node->left;\\n                    stack.push(node);\\n                }\\n            }\\n\\n            if (not node->right or prev != node->right) {\\n                // In-order region {\\n                //   do_something();\\n                // }\\n                if (node->right)\\n                    stack.push(node->right);\\n            }\\n\\n            if (not node->right or prev == node->right) {\\n                // Post-order region {\\n                //   do_something();\\n                // }\\n                stack.pop();\\n                prev = node;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n### [Problem: Binary Tree Inorder Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal/)\\n\\n```C++\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> result{};\\n        stack<TreeNode*> stack{};\\n        TreeNode* prev = nullptr;\\n\\n        if (root)\\n            stack.push(root);\\n        while (not stack.empty()) {\\n            TreeNode* node = stack.top();\\n\\n            if (not prev or\\n                prev != node->left and prev != node->right) {\\n                while (true) {\\n                    // Pre-order region {\\n                    //   do_something();\\n                    // }\\n                    if (not node->left)\\n                        break;\\n                    node = node->left;\\n                    stack.push(node);\\n                }\\n            }\\n\\n            if (not node->right or prev != node->right) {\\n                // In-order region {\\n                result.push_back(node->val);  // <-------------- See here!\\n                // }\\n                if (node->right)\\n                    stack.push(node->right);\\n            }\\n\\n            if (not node->right or prev == node->right) {\\n                // Post-order region {\\n                //   do_something();\\n                // }\\n                stack.pop();\\n                prev = node;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n### [Problem: Binary Tree Postorder Traversal](https://leetcode.com/problems/binary-tree-postorder-traversal/)\\n\\n```C++\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int> result{};\\n        stack<TreeNode*> stack{};\\n        TreeNode* prev = nullptr;\\n\\n        if (root)\\n            stack.push(root);\\n        while (not stack.empty()) {\\n            TreeNode* node = stack.top();\\n\\n            if (not prev or\\n                prev != node->left and prev != node->right) {\\n                while (true) {\\n                    // Pre-order region {\\n                    //   do_something();\\n                    // }\\n                    if (not node->left)\\n                        break;\\n                    node = node->left;\\n                    stack.push(node);\\n                }\\n            }\\n\\n            if (not node->right or prev != node->right) {\\n                // In-order region {\\n                //   do_something();\\n                // }\\n                if (node->right)\\n                    stack.push(node->right);\\n            }\\n\\n            if (not node->right or prev == node->right) {\\n                // Post-order region {\\n                result.push_back(node->val);  // <-------------- See here!\\n                // }\\n                stack.pop();\\n                prev = node;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Iterator"
                ],
                "code": "```C++\\n        stack<TreeNode*> stack{};\\n        TreeNode* prev = nullptr;\\n\\n        if (root)\\n            stack.push(root);\\n        while (not stack.empty()) {  // #0\\n            TreeNode* node = stack.top();\\n\\n            if (not prev or\\n                prev != node->left and prev != node->right) {  // #1\\n                while (true) {\\n                    // Pre-order region {\\n                    //   do_something();\\n                    // }\\n                    if (not node->left)\\n                        break;   // #2\\n                    node = node->left;\\n                    stack.push(node);  // #3\\n                }\\n            }\\n            // #4\\n            if (not node->right or prev != node->right) {  // #5\\n                // In-order region {\\n                //   do_something();\\n                // }\\n                if (node->right)\\n                    stack.push(node->right);  // #6\\n            }\\n\\n            if (not node->right or prev == node->right) {  // #7\\n                // Post-order region {\\n                //   do_something();\\n                // }\\n                stack.pop();  // #8\\n                prev = node;  // #9\\n            }\\n        }\\n```\n```C++\\n        stack<TreeNode*> stack{};\\n        TreeNode* node = root;\\n        TreeNode* prev = nullptr;\\n\\n        while (node or not stack.empty()) {\\n            while (node) {\\n                // Pre-order region {\\n                //   do_something();\\n                // }\\n                stack.push(node);\\n                node = node->left;\\n            }\\n            node = stack.top();\\n\\n            if (not node->right or prev != node->right) {\\n                // In-order region {\\n                //   do_something();\\n                // }\\n                if (node->right) {\\n                    node = node->right;\\n                    continue;\\n                }\\n            }\\n\\n            if (not node->right or prev == node->right) {\\n                // Post-order region {\\n                //   do_something();\\n                // }\\n                stack.pop();\\n                prev = node;\\n                node = nullptr;\\n            }\\n        }\\n```\n```C++\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> result{};\\n        stack<TreeNode*> stack{};\\n        TreeNode* prev = nullptr;\\n\\n        if (root)\\n            stack.push(root);\\n        while (not stack.empty()) {\\n            TreeNode* node = stack.top();\\n\\n            if (not prev or\\n                prev != node->left and prev != node->right) {\\n                while (true) {\\n                    // Pre-order region {\\n                    result.push_back(node->val);  // <-------------- See here!\\n                    // }\\n                    if (not node->left)\\n                        break;\\n                    node = node->left;\\n                    stack.push(node);\\n                }\\n            }\\n\\n            if (not node->right or prev != node->right) {\\n                // In-order region {\\n                //   do_something();\\n                // }\\n                if (node->right)\\n                    stack.push(node->right);\\n            }\\n\\n            if (not node->right or prev == node->right) {\\n                // Post-order region {\\n                //   do_something();\\n                // }\\n                stack.pop();\\n                prev = node;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\n```C++\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> result{};\\n        stack<TreeNode*> stack{};\\n        TreeNode* prev = nullptr;\\n\\n        if (root)\\n            stack.push(root);\\n        while (not stack.empty()) {\\n            TreeNode* node = stack.top();\\n\\n            if (not prev or\\n                prev != node->left and prev != node->right) {\\n                while (true) {\\n                    // Pre-order region {\\n                    //   do_something();\\n                    // }\\n                    if (not node->left)\\n                        break;\\n                    node = node->left;\\n                    stack.push(node);\\n                }\\n            }\\n\\n            if (not node->right or prev != node->right) {\\n                // In-order region {\\n                result.push_back(node->val);  // <-------------- See here!\\n                // }\\n                if (node->right)\\n                    stack.push(node->right);\\n            }\\n\\n            if (not node->right or prev == node->right) {\\n                // Post-order region {\\n                //   do_something();\\n                // }\\n                stack.pop();\\n                prev = node;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\n```C++\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int> result{};\\n        stack<TreeNode*> stack{};\\n        TreeNode* prev = nullptr;\\n\\n        if (root)\\n            stack.push(root);\\n        while (not stack.empty()) {\\n            TreeNode* node = stack.top();\\n\\n            if (not prev or\\n                prev != node->left and prev != node->right) {\\n                while (true) {\\n                    // Pre-order region {\\n                    //   do_something();\\n                    // }\\n                    if (not node->left)\\n                        break;\\n                    node = node->left;\\n                    stack.push(node);\\n                }\\n            }\\n\\n            if (not node->right or prev != node->right) {\\n                // In-order region {\\n                //   do_something();\\n                // }\\n                if (node->right)\\n                    stack.push(node->right);\\n            }\\n\\n            if (not node->right or prev == node->right) {\\n                // Post-order region {\\n                result.push_back(node->val);  // <-------------- See here!\\n                // }\\n                stack.pop();\\n                prev = node;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 45316,
                "title": "c-iterative-with-stack",
                "content": "    public IList<int> PreorderTraversal(TreeNode root) {\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        List<int> list = new List<int>();\\n        stack.Push(root);\\n        while (stack.Count() > 0)\\n        {\\n            TreeNode current = stack.Pop();\\n            if (current != null)\\n            {\\n                list.Add(current.val);\\n                stack.Push(current.right);\\n                stack.Push(current.left);\\n            }\\n        }\\n        \\n        return list;\\n    }",
                "solutionTags": [],
                "code": "    public IList<int> PreorderTraversal(TreeNode root) {\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        List<int> list = new List<int>();\\n        stack.Push(root);\\n        while (stack.Count() > 0)\\n        {\\n            TreeNode current = stack.Pop();\\n            if (current != null)\\n            {\\n                list.Add(current.val);\\n                stack.Push(current.right);\\n                stack.Push(current.left);\\n            }\\n        }\\n        \\n        return list;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 45438,
                "title": "java-solution-using-stack",
                "content": "    public List<Integer> postorderTraversal(TreeNode root) {\\n      List<Integer> res = new ArrayList<Integer>();\\n      \\n      if (root == null)\\n        return res;\\n          \\n      Stack<TreeNode> stack = new Stack<TreeNode>();\\n      stack.push(root);\\n      \\n      while (!stack.isEmpty()) {\\n        TreeNode node = stack.pop();\\n        res.add(node.val);\\n        \\n        if (node.right != null)\\n          stack.push(node.right);\\n            \\n        if (node.left != null)\\n          stack.push(node.left);\\n      }\\n      \\n      return res;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public List<Integer> postorderTraversal(TreeNode root) {\\n      List<Integer> res = new ArrayList<Integer>();\\n      \\n      if (root == null)\\n        return res;\\n          \\n      Stack<TreeNode> stack = new Stack<TreeNode>();\\n      stack.push(root);\\n      \\n      while (!stack.isEmpty()) {\\n        TreeNode node = stack.pop();\\n        res.add(node.val);\\n        \\n        if (node.right != null)\\n          stack.push(node.right);\\n            \\n        if (node.left != null)\\n          stack.push(node.left);\\n      }\\n      \\n      return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3205841,
                "title": "144-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTo traverse a binary tree in a preorder fashion, we start from the root node, visit the left subtree, then the right subtree. We will use a stack to keep track of the nodes to be visited. We first push the root node onto the stack, and then while the stack is not empty, we pop the top node and visit it. If the popped node has a right child, we push it onto the stack. If the popped node has a left child, we push it onto the stack. We continue this process until the stack is empty.\\n\\nIn this code, we first check if the root is None. If it is, we return an empty list. Otherwise, we create an empty stack and add the root node to it. We also create an empty list to store the result.\\n\\nWe then start a while loop that continues until the stack is empty. In each iteration of the loop, we pop the top node from the stack and add its value to the result list. We then check if the popped node has a right child. If it does, we push the right child onto the stack. We then check if the popped node has a left child. If it does, we push the left child onto the stack.\\n\\nAfter the loop ends, we return the result list. This will contain the values of the nodes in preorder traversal order.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def preorderTraversal(self, root: TreeNode) -> List[int]:\\n        if not root:\\n            return []\\n        stack = [root]\\n        result = []\\n        while stack:\\n            node = stack.pop()\\n            result.append(node.val)\\n            if node.right:\\n                stack.append(node.right)\\n            if node.left:\\n                stack.append(node.left)\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def preorderTraversal(self, root: TreeNode) -> List[int]:\\n        if not root:\\n            return []\\n        stack = [root]\\n        result = []\\n        while stack:\\n            node = stack.pop()\\n            result.append(node.val)\\n            if node.right:\\n                stack.append(node.right)\\n            if node.left:\\n                stack.append(node.left)\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022776,
                "title": "0ms-explained-easy-solution-c",
                "content": "# Approach\\nIn this question we need to traverse or move through this tree in pre order traversal\\n\\nFirst the root node, then the next node (left sibling, or left node) and after all the left nodes are exhausted on the left subtree, we go back on e node and check the right node or right sibling. Again when all nodes are done on that level we go back one level and repeat the same process unless we have reached the root back again; and then we start traversing the right sub tree, but here too we first go through the left siblings first and then the right siblings.\\n\\n```\\nclass Solution {\\npublic:\\n    void traverse(TreeNode* root, vector<int>& v) {\\n        if (root==NULL) return;     // if node is null there is nothing more to check\\n        v.push_back(root->val);     // We first add the node we\\'re visiting to the output vector\\n        traverse(root->left, v);    // Now let\\'s move through the left siblings\\n        traverse(root->right, v);   // After the left siblings are done with, we check for the right siblings as we start going back\\n    }\\n\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n        traverse(root, v);\\n        return v;\\n    }\\n};\\n```\\n\\n\\n*Upvote this solution, as it might have helped you :)*",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void traverse(TreeNode* root, vector<int>& v) {\\n        if (root==NULL) return;     // if node is null there is nothing more to check\\n        v.push_back(root->val);     // We first add the node we\\'re visiting to the output vector\\n        traverse(root->left, v);    // Now let\\'s move through the left siblings\\n        traverse(root->right, v);   // After the left siblings are done with, we check for the right siblings as we start going back\\n    }\\n\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n        traverse(root, v);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022418,
                "title": "iterative-solution-with-stack-beats-100-solution-in-time",
                "content": "# Intuition\\nWe have to do preorder traversal where we print value for root then we go for it\\'s left sub tree and in the last we go for right sub tree of the root.\\n\\nstack is the LIFO(Last in first out data structure) so we can use this property\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1-Add root of the tree in the stack and traverse till stack becomes empty \\n2-Remove top of the stack and store it in the variable called rem now add value of rem in our List\\n3-If there exist right child of the remove node (rem) then add it to the stack and then do same with the left child of the root \\n\\n(Here we are adding right child first and left child later so that while we will remove the element, left child will be poped out first )\\n\\n# Complexity\\n- Time complexity:O(N)\\nWe are Traversing all elements of the tree ones so that time complexity will be O(n)<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(H)\\n-Here H is the height of the tree (Stack will not store all n elements at once)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        if(root==null){\\n            return new ArrayList<>();\\n        }\\n        List<Integer>l = new ArrayList<>();\\n        Stack<TreeNode>st = new Stack<>();\\n        st.push(root);\\n        while(st.isEmpty()==false){\\n            TreeNode rem = st.pop();\\n            l.add(rem.val);\\n            if(rem.right!=null){\\n                st.push(rem.right);\\n            }\\n            if(rem.left!=null){\\n                st.push(rem.left);\\n            }\\n        }\\n        return l;\\n    }\\n}\\n```\\nI hope you understand the solution, have a great day ahead.\\nHar Har Mahadev\\uD83D\\uDD49\\uFE0F\\u2764\\uFE0F,\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        if(root==null){\\n            return new ArrayList<>();\\n        }\\n        List<Integer>l = new ArrayList<>();\\n        Stack<TreeNode>st = new Stack<>();\\n        st.push(root);\\n        while(st.isEmpty()==false){\\n            TreeNode rem = st.pop();\\n            l.add(rem.val);\\n            if(rem.right!=null){\\n                st.push(rem.right);\\n            }\\n            if(rem.left!=null){\\n                st.push(rem.left);\\n            }\\n        }\\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3021964,
                "title": "daily-leetcode-solution-easy-c-solution",
                "content": "```\\n//PreorderTraversal Using Recurrsion\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void preorder(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        ans.push_back(root->val);\\n        preorder(root->left);\\n        preorder(root->right);\\n    }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        preorder(root);\\n        return ans;\\n    }\\n};\\n```\\n```\\n//Preorder Traversal Using Morris Traversal\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        TreeNode* curr=root;\\n        while(curr){\\n            if(!curr->left){\\n                ans.push_back(curr->val);\\n                curr=curr->right;\\n            }\\n            else{\\n                TreeNode* pre=curr->left;\\n                while(pre->right&&pre->right!=curr){\\n                    pre=pre->right;\\n                }\\n                if(pre->right==NULL){\\n                    pre->right=curr;\\n                    ans.push_back(curr->val);\\n                    curr=curr->left;\\n                }\\n                else{\\n                    pre->right=NULL;\\n                    curr=curr->right;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n//PreorderTraversal Using Recurrsion\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void preorder(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        ans.push_back(root->val);\\n        preorder(root->left);\\n        preorder(root->right);\\n    }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        preorder(root);\\n        return ans;\\n    }\\n};\\n```\n```\\n//Preorder Traversal Using Morris Traversal\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        TreeNode* curr=root;\\n        while(curr){\\n            if(!curr->left){\\n                ans.push_back(curr->val);\\n                curr=curr->right;\\n            }\\n            else{\\n                TreeNode* pre=curr->left;\\n                while(pre->right&&pre->right!=curr){\\n                    pre=pre->right;\\n                }\\n                if(pre->right==NULL){\\n                    pre->right=curr;\\n                    ans.push_back(curr->val);\\n                    curr=curr->left;\\n                }\\n                else{\\n                    pre->right=NULL;\\n                    curr=curr->right;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2984350,
                "title": "iterative-preorder-travesal-using-stack",
                "content": "# Intuition\\nIterative Preorder Travesal using Stack\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> preorder;\\n        if(root==NULL){\\n            return preorder;\\n        }\\n        stack<TreeNode*> st;\\n        st.push(root);\\n        while(!st.empty()){\\n            root=st.top();\\n            st.pop();\\n            preorder.push_back(root->val);\\n\\n            if(root->right!=NULL){\\n                st.push(root->right);\\n            }\\n            if(root->left!=NULL){\\n                st.push(root->left);\\n            }\\n        }\\n        return preorder;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> preorder;\\n        if(root==NULL){\\n            return preorder;\\n        }\\n        stack<TreeNode*> st;\\n        st.push(root);\\n        while(!st.empty()){\\n            root=st.top();\\n            st.pop();\\n            preorder.push_back(root->val);\\n\\n            if(root->right!=NULL){\\n                st.push(root->right);\\n            }\\n            if(root->left!=NULL){\\n                st.push(root->left);\\n            }\\n        }\\n        return preorder;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2806507,
                "title": "striver-s-method-upvote-if-you-like",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> preorder;\\n        if(root==NULL) return preorder;\\n        stack<TreeNode*> st;\\n        st.push(root);\\n        while(!st.empty())\\n        {\\n\\n           root=st.top();\\n           st.pop();\\n           preorder.push_back(root->val);\\n           if(root->right!=NULL){\\n               st.push(root->right);\\n           }\\n\\n           if(root->left!=NULL)\\n           {\\n               st.push(root->left);\\n           }\\n\\n        }\\n        return preorder;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> preorder;\\n        if(root==NULL) return preorder;\\n        stack<TreeNode*> st;\\n        st.push(root);\\n        while(!st.empty())\\n        {\\n\\n           root=st.top();\\n           st.pop();\\n           preorder.push_back(root->val);\\n           if(root->right!=NULL){\\n               st.push(root->right);\\n           }\\n\\n           if(root->left!=NULL)\\n           {\\n               st.push(root->left);\\n           }\\n\\n        }\\n        return preorder;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1540041,
                "title": "c-inorder-preorder-postorder-all-3-solution-0ms-faster-than-100",
                "content": "You can observe there is just a minimal diffrence in all 3 ,i.e, it\\'s just the way of filling vector while calling fill function.  \\n***Inorder Traversal :*** \\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void fill(TreeNode* root){\\n        if(!root)\\n            return;\\n        fill(root->left);\\n        ans.push_back(root->val);  // Inorder\\n        fill(root->right);\\n    }\\n    \\n    vector<int> inorderTraversal(TreeNode* root) {\\n        fill(root);\\n        return ans;\\n    }\\n};\\n```\\n\\n***Preorder Traversal :***\\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void fill(TreeNode* root){\\n        if(!root)\\n            return;\\n        ans.push_back(root->val);  // Preoder\\n        fill(root->left);\\n        fill(root->right);\\n    }\\n    \\n    vector<int> preorderTraversal(TreeNode* root) {\\n        fill(root);\\n        return ans;\\n    }\\n};\\n```\\n\\n***Postorder Traversal :***\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void fill(TreeNode* root){\\n        if(!root)\\n            return;\\n        fill(root->left);\\n        fill(root->right);\\n        ans.push_back(root->val);  /// Postorder\\n    }\\n    \\n    vector<int> postorderTraversal(TreeNode* root) {\\n        fill(root);\\n        return ans;\\n    }\\n};\\n```\\nHope you liked it , kindly upvote !!\\n\\nHappy Coding \\uD83E\\uDD17",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void fill(TreeNode* root){\\n        if(!root)\\n            return;\\n        fill(root->left);\\n        ans.push_back(root->val);  // Inorder\\n        fill(root->right);\\n    }\\n    \\n    vector<int> inorderTraversal(TreeNode* root) {\\n        fill(root);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void fill(TreeNode* root){\\n        if(!root)\\n            return;\\n        ans.push_back(root->val);  // Preoder\\n        fill(root->left);\\n        fill(root->right);\\n    }\\n    \\n    vector<int> preorderTraversal(TreeNode* root) {\\n        fill(root);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void fill(TreeNode* root){\\n        if(!root)\\n            return;\\n        fill(root->left);\\n        fill(root->right);\\n        ans.push_back(root->val);  /// Postorder\\n    }\\n    \\n    vector<int> postorderTraversal(TreeNode* root) {\\n        fill(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369622,
                "title": "three-types-of-solution-recursion-iterative-morris-100-faster-c",
                "content": "## All Three types of solutions: \\n1. Recursion => TC - O(N) and SC - (N)\\n2. Iterative => TC - O(N) and SC - (N)\\n3. Morris Traversal => TC - O(N) and SC - (1)\\n\\n#### **Using recursion (4ms time) TC - O(N) and SC - O(N)**\\n```\\nclass Solution {\\npublic:\\n     vector<int> ans;\\n     vector<int> preorderTraversal(TreeNode* root) {\\n         if(root==NULL)return ans;\\n\\t\\t ans.push_back(root->val);\\n         preorderTraversal(root->left);\\n         preorderTraversal(root->right);\\n         return ans;\\n     }\\n}; \\n```\\n#### Iterative method using Stack(0ms) \\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        stack<TreeNode*> store;\\n        while(!store.empty() || root){\\n            if(root){\\n                ans.push_back(root->val); // print root\\n                if(root->right){ \\n                    store.push(root->right);//put into stack so that after print left we can go right\\n                }\\n                root=root->left; // make root of left sub tree;\\n            }\\n            else{\\n                root=store.top();//if root is null that means left tree is not there; we pop the node\\n                store.pop();\\n            }\\n        }\\n\\t\\t return ans;\\n    }\\n};\\n```\\n\\n#### **Morris Traversal in O(1) space and O(N) time**\\n```\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        while(root){\\n            if(root->left==NULL){ // if left not there, add root to answer\\n                ans.push_back(root->val);\\n                root=root->right; // go to right (bcz left is not there)\\n            }\\n            else{  // left is there then find the predecessor of root(for tracking to root after visiting left)\\n                TreeNode* temp = root;\\n                temp=temp->left;\\n                while(temp->right && temp->right!=root){\\n                    temp = temp->right;\\n                }\\n                if(temp->right==NULL){  //link predecessor->right to root(to go to root)\\n                    temp->right=root;\\n                    ans.push_back(root->val); // push the root node (we are going in left direction so before that add root as ans);\\n                    root=root->left;// goto left direction \\n                }\\n                else{ // if predecessor is linked with root that means left subtree is already visited; goto right \\n                    temp->right=NULL;\\n                    root=root->right;\\n                }    \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n### **If you like the solution please upvote it. Thanks**\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     vector<int> ans;\\n     vector<int> preorderTraversal(TreeNode* root) {\\n         if(root==NULL)return ans;\\n\\t\\t ans.push_back(root->val);\\n         preorderTraversal(root->left);\\n         preorderTraversal(root->right);\\n         return ans;\\n     }\\n}; \\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        stack<TreeNode*> store;\\n        while(!store.empty() || root){\\n            if(root){\\n                ans.push_back(root->val); // print root\\n                if(root->right){ \\n                    store.push(root->right);//put into stack so that after print left we can go right\\n                }\\n                root=root->left; // make root of left sub tree;\\n            }\\n            else{\\n                root=store.top();//if root is null that means left tree is not there; we pop the node\\n                store.pop();\\n            }\\n        }\\n\\t\\t return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        while(root){\\n            if(root->left==NULL){ // if left not there, add root to answer\\n                ans.push_back(root->val);\\n                root=root->right; // go to right (bcz left is not there)\\n            }\\n            else{  // left is there then find the predecessor of root(for tracking to root after visiting left)\\n                TreeNode* temp = root;\\n                temp=temp->left;\\n                while(temp->right && temp->right!=root){\\n                    temp = temp->right;\\n                }\\n                if(temp->right==NULL){  //link predecessor->right to root(to go to root)\\n                    temp->right=root;\\n                    ans.push_back(root->val); // push the root node (we are going in left direction so before that add root as ans);\\n                    root=root->left;// goto left direction \\n                }\\n                else{ // if predecessor is linked with root that means left subtree is already visited; goto right \\n                    temp->right=NULL;\\n                    root=root->right;\\n                }    \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1052899,
                "title": "c-solution",
                "content": "```\\n\\nint nodeCount(struct TreeNode* root) {\\n    if (NULL == root)\\n        return 0;\\n    \\n    return (nodeCount(root->left)+ nodeCount(root->right)) + 1;\\n}\\n\\nvoid preorder(struct TreeNode* root, int *res, int *size) {\\n    if(NULL == root)\\n        return;\\n    \\n    res[(*size)++] = root->val;\\n    preorder(root->left, res, size);\\n    preorder(root->right, res, size);\\n}\\n\\nint* preorderTraversal(struct TreeNode* root, int* returnSize){\\n    int lev = nodeCount(root);\\n    \\n    int *result =(int*)malloc(sizeof(int)*lev+1);\\n    *returnSize = 0;\\n\\n    preorder(root, result, returnSize);\\n    \\n    return result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nint nodeCount(struct TreeNode* root) {\\n    if (NULL == root)\\n        return 0;\\n    \\n    return (nodeCount(root->left)+ nodeCount(root->right)) + 1;\\n}\\n\\nvoid preorder(struct TreeNode* root, int *res, int *size) {\\n    if(NULL == root)\\n        return;\\n    \\n    res[(*size)++] = root->val;\\n    preorder(root->left, res, size);\\n    preorder(root->right, res, size);\\n}\\n\\nint* preorderTraversal(struct TreeNode* root, int* returnSize){\\n    int lev = nodeCount(root);\\n    \\n    int *result =(int*)malloc(sizeof(int)*lev+1);\\n    *returnSize = 0;\\n\\n    preorder(root, result, returnSize);\\n    \\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 45394,
                "title": "simple-iterative-and-recursive-solutions",
                "content": "\\n**Solution 1, Iterative**\\n\\n    def preorderTraversal(self, root):\\n        stack, ans =[root], []\\n        while stack:\\n            node = stack.pop(-1)\\n            while node:\\n                if node.right:\\n                    stack.append(node.right)\\n                ans.append(node.val)\\n                node=node.left\\n        return ans\\n\\n<br><br>\\n\\n**Solution 2 , Recursive**\\n\\n    def preorderTraversal(self, root):\\n        def DFS(node):\\n            if node:\\n                ans.append(node.val)\\n                DFS(node.left)\\n                DFS(node.right)\\n        ans = []\\n        DFS(root)\\n        return ans",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n**Solution 1, Iterative**\\n\\n    def preorderTraversal(self, root):\\n        stack, ans =[root], []\\n        while stack:\\n            node = stack.pop(-1)\\n            while node:\\n                if node.right:\\n                    stack.append(node.right)\\n                ans.append(node.val)\\n                node=node.left\\n        return ans\\n\\n<br><br>\\n\\n**Solution 2 , Recursive**\\n\\n    def preorderTraversal(self, root):\\n        def DFS(node):\\n            if node:\\n                ans.append(node.val)\\n                DFS(node.left)\\n                DFS(node.right)\\n        ans = []\\n        DFS(root)\\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 3022165,
                "title": "java-easy-to-understand-explanation-for-all-traversal",
                "content": "Its just a simple dfs on the tree. They ask you to do the pre-order traversal. So first we add the element to the list then traversal the left sub tree and then right sub tree.\\n\\n## Type of Traversal\\n\\nInorder    -> left , current , right\\nPre-order  -> current , left , right\\nPost order -> left , right , current\\n\\nLeft means traversal the left sub tree.\\nRight means traversal the right sub tree.\\nCurrent means we need to do the process for the current node. Here we simiply added into the list.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    void dfs(TreeNode root,List<Integer> l){\\n        if(root == null)return;\\n        l.add(root.val);\\n        dfs(root.left,l);\\n        dfs(root.right,l);\\n    }\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> l = new ArrayList<>();\\n        dfs(root,l);\\n        return l;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    void dfs(TreeNode root,List<Integer> l){\\n        if(root == null)return;\\n        l.add(root.val);\\n        dfs(root.left,l);\\n        dfs(root.right,l);\\n    }\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> l = new ArrayList<>();\\n        dfs(root,l);\\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3021963,
                "title": "dfs-pre-order-js",
                "content": "# Approach\\nDepth first search.\\n\\nT: O(n)  S: O(n)\\n\\n\\n\\n# Code\\n```\\nvar preorderTraversal = function (root, arr = []) {\\n  DFS(root);\\n  return arr;\\n  function DFS(node) {\\n    if (!node) return;\\n    arr.push(node.val);\\n    DFS(node.left);\\n    DFS(node.right);\\n  }\\n};\\n\\n```\\n\\n\\nor\\n\\n# Code\\n```\\nvar preorderTraversal = function (root, arr = []) {\\n  if (!root) return [];\\n  arr.push(node.val);\\n  preorderTraversal(root.left, arr);\\n  preorderTraversal(root.right, arr);\\n  return arr;\\n}\\n```\\nor\\n# Code\\n```\\nvar preorderTraversal = function (root, arr = []) {\\n  if (!root) return arr;\\n  return [root.val,...preorderTraversal(root.left, arr),...preorderTraversal(root.right, arr)];\\n};\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar preorderTraversal = function (root, arr = []) {\\n  DFS(root);\\n  return arr;\\n  function DFS(node) {\\n    if (!node) return;\\n    arr.push(node.val);\\n    DFS(node.left);\\n    DFS(node.right);\\n  }\\n};\\n\\n```\n```\\nvar preorderTraversal = function (root, arr = []) {\\n  if (!root) return [];\\n  arr.push(node.val);\\n  preorderTraversal(root.left, arr);\\n  preorderTraversal(root.right, arr);\\n  return arr;\\n}\\n```\n```\\nvar preorderTraversal = function (root, arr = []) {\\n  if (!root) return arr;\\n  return [root.val,...preorderTraversal(root.left, arr),...preorderTraversal(root.right, arr)];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3008946,
                "title": "c-easy-solution",
                "content": "\\n# Complexity\\n- Time complexity : $$O(N)$$\\n\\n- Space complexity : $$O(1)$$, if we don\\u2019t consider the size of the stack for function. Otherwise, $$O(H)$$ where H is the height of the tree. \\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int>res;\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        if(root!=NULL)\\n        {\\n            res.push_back(root->val);\\n            preorderTraversal(root->left);\\n            preorderTraversal(root->right); \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int>res;\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        if(root!=NULL)\\n        {\\n            res.push_back(root->val);\\n            preorderTraversal(root->left);\\n            preorderTraversal(root->right); \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2294410,
                "title": "3-approaches-in-c-recursive-iterative-morris-traversal",
                "content": "**Recursive Approach:**\\n````\\nvoid help(TreeNode* root, vector<int>& ans)\\n    {\\n        if(root == NULL)\\n            return;\\n        ans.push_back(root->val);\\n        help(root->left, ans);\\n        help(root->right, ans);\\n    }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        help(root, ans);\\n        return ans;\\n    }\\n````\\n\\n-------------------------------------------------------------------------------------------------------\\n**Iterative Approach:**\\n````\\nvector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        if(root==NULL) return ans;\\n        stack<TreeNode*> st;\\n        st.push(root);\\n        while(!st.empty())\\n        {\\n            root = st.top();\\n            st.pop();\\n            ans.push_back(root->val);\\n            if(root->right!=NULL)\\n            {\\n                st.push(root->right);\\n            }\\n            if(root->left!=NULL)\\n            {\\n                st.push(root->left);\\n            }\\n        }\\n        return ans;\\n    }\\n````\\n\\n-------------------------------------------------------------------------------------------------------\\n**Morris Traversal :**\\n````\\nvector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        TreeNode *node = root;\\n        while(node != NULL)\\n        {\\n            if(node->left == NULL) \\n            {\\n                ans.push_back(node->val);\\n                node = node->right;\\n            }\\n            else\\n            {\\n                TreeNode *prev = node->left;\\n                while(prev->right && prev->right != node)\\n                {\\n                    prev = prev->right;\\n                }\\n                if(prev->right == NULL)\\n                {\\n                    prev->right = node;\\n                    ans.push_back(node->val);\\n                    node = node->left;\\n                }\\n                else\\n                {\\n                    prev->right = NULL;\\n                    node = node->right;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n````\\n\\n**One Request : Please do upvote if you found these solutions helpful. Thanks in advance!**",
                "solutionTags": [],
                "code": "````\\nvoid help(TreeNode* root, vector<int>& ans)\\n    {\\n        if(root == NULL)\\n            return;\\n        ans.push_back(root->val);\\n        help(root->left, ans);\\n        help(root->right, ans);\\n    }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        help(root, ans);\\n        return ans;\\n    }\\n```\n````\\nvector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        if(root==NULL) return ans;\\n        stack<TreeNode*> st;\\n        st.push(root);\\n        while(!st.empty())\\n        {\\n            root = st.top();\\n            st.pop();\\n            ans.push_back(root->val);\\n            if(root->right!=NULL)\\n            {\\n                st.push(root->right);\\n            }\\n            if(root->left!=NULL)\\n            {\\n                st.push(root->left);\\n            }\\n        }\\n        return ans;\\n    }\\n```\n````\\nvector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        TreeNode *node = root;\\n        while(node != NULL)\\n        {\\n            if(node->left == NULL) \\n            {\\n                ans.push_back(node->val);\\n                node = node->right;\\n            }\\n            else\\n            {\\n                TreeNode *prev = node->left;\\n                while(prev->right && prev->right != node)\\n                {\\n                    prev = prev->right;\\n                }\\n                if(prev->right == NULL)\\n                {\\n                    prev->right = node;\\n                    ans.push_back(node->val);\\n                    node = node->left;\\n                }\\n                else\\n                {\\n                    prev->right = NULL;\\n                    node = node->right;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2248114,
                "title": "java-standard-iterative-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n     ArrayList<Integer> ans = new ArrayList<Integer>();\\n      if(root == null) return ans;\\n      \\n      Stack<TreeNode> st = new Stack<TreeNode>();\\n      st.push(root);\\n      \\n      while(!st.isEmpty()) {\\n        TreeNode cur = st.pop(); \\n        ans.add(cur.val);\\n        \\n          if(cur.right != null) st.push(cur.right);\\n          if(cur.left != null) st.push(cur.left);\\n      }\\n      return ans;\\n    }\\n}\\n```\\n# KINDLY UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n     ArrayList<Integer> ans = new ArrayList<Integer>();\\n      if(root == null) return ans;\\n      \\n      Stack<TreeNode> st = new Stack<TreeNode>();\\n      st.push(root);\\n      \\n      while(!st.isEmpty()) {\\n        TreeNode cur = st.pop(); \\n        ans.add(cur.val);\\n        \\n          if(cur.right != null) st.push(cur.right);\\n          if(cur.left != null) st.push(cur.left);\\n      }\\n      return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976349,
                "title": "100-percent-faster-easy-to-understand",
                "content": "class Solution {\\n    private : vector<int>res;\\n    void preorder(TreeNode *root, vector<int>&res)\\n    {\\n        if(root==NULL)\\n            return;\\n        res.push_back(root->val);\\n        preorder(root->left,res);\\n        preorder(root->right,res);\\n        return;\\n    }\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        \\n        preorder(root,res);\\n        return res;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n    private : vector<int>res;\\n    void preorder(TreeNode *root, vector<int>&res)\\n    {\\n        if(root==NULL)\\n            return;\\n        res.push_back(root->val);\\n        preorder(root->left,res);\\n        preorder(root->right,res);\\n        return;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1846236,
                "title": "simple-python-solution-recursive-and-iterative-both",
                "content": "**Iterative approach using stack:**\\n```\\ndef preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        ans=[]\\n        if root==None:\\n            return None\\n        stack=[root]\\n        while len(stack)>0:\\n            temp=stack.pop(-1)\\n            ans.append(temp.val)\\n            if temp.right!=None:\\n                stack.append(temp.right)\\n            if temp.left!=None:\\n                stack.append(temp.left)\\n        return ans\\n```\\n\\n**Recursive approach:**\\n```\\ndef preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\t\\tans=[]\\n        def preorder(root):\\n            if root==None:\\n                return None\\n            ans.append(root.val)\\n            preorder(root.left)\\n            preorder(root.right)\\n        preorder(root)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\ndef preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        ans=[]\\n        if root==None:\\n            return None\\n        stack=[root]\\n        while len(stack)>0:\\n            temp=stack.pop(-1)\\n            ans.append(temp.val)\\n            if temp.right!=None:\\n                stack.append(temp.right)\\n            if temp.left!=None:\\n                stack.append(temp.left)\\n        return ans\\n```\n```\\ndef preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\t\\tans=[]\\n        def preorder(root):\\n            if root==None:\\n                return None\\n            ans.append(root.val)\\n            preorder(root.left)\\n            preorder(root.right)\\n        preorder(root)\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1765377,
                "title": "python3-easiest-solution",
                "content": "```\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        res = []\\n        \\n        if root:\\n            res+= [root.val]\\n            res+= self.preorderTraversal(root.left)\\n            res+= self.preorderTraversal(root.right)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        res = []\\n        \\n        if root:\\n            res+= [root.val]\\n            res+= self.preorderTraversal(root.left)\\n            res+= self.preorderTraversal(root.right)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 886830,
                "title": "python-20ms-classic-implementation",
                "content": "Runtime: 20 ms, faster than 98.55% of Python3 online submissions for Binary Tree Preorder Traversal.\\nMemory Usage: 14.1 MB, less than 99.97% of Python3 online submissions for Binary Tree Preorder Traversal.\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def preorderTraversal(self, root: TreeNode) -> List[int]:\\n        self.ans=[]\\n        def preorder(root):\\n            if root is None:\\n                return\\n            self.ans.append(root.val)\\n            preorder(root.left)\\n            preorder(root.right)\\n        preorder(root)\\n        return self.ans\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def preorderTraversal(self, root: TreeNode) -> List[int]:\\n        self.ans=[]\\n        def preorder(root):\\n            if root is None:\\n                return\\n            self.ans.append(root.val)\\n            preorder(root.left)\\n            preorder(root.right)\\n        preorder(root)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 180119,
                "title": "javascript",
                "content": "```\\nvar preorderTraversal = function(root) {\\n    let result = [];\\n    dfs(root);\\n    \\n    function dfs(root) {\\n        if(root != null){\\n            result.push(root.val);\\n            dfs(root.left);\\n            dfs(root.right);\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar preorderTraversal = function(root) {\\n    let result = [];\\n    dfs(root);\\n    \\n    function dfs(root) {\\n        if(root != null){\\n            result.push(root.val);\\n            dfs(root.left);\\n            dfs(root.right);\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 158275,
                "title": "python-stack-dfs",
                "content": "### 144. Binary Tree Preorder Traversal\\n```\\n> \\u7C7B\\u578B\\uFF1ADFS Stack | Recursive\\n> Time Complexity O(n)\\n> Space Complexity O(1)\\n```\\n\\n#### DFS Recursive\\n```python\\nclass Solution(object):\\n    def preorderTraversal(self, root):\\n        self.res = []\\n        self.dfs(root)\\n        return self.res\\n    \\n    def dfs(self, root):\\n        if not root:\\n            return \\n        self.res.append(root.val)\\n        self.dfs(root.left)\\n        self.dfs(root.right)     \\n```\\n\\n#### Stack\\n```python\\nclass Solution(object):\\n    def preorderTraversal(self, root):\\n        res = []\\n        stack = [root]\\n        while stack:\\n            node = stack.pop()\\n            if node:\\n                res.append(node.val)\\n                stack.append(node.right)\\n                stack.append(node.left)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n> \\u7C7B\\u578B\\uFF1ADFS Stack | Recursive\\n> Time Complexity O(n)\\n> Space Complexity O(1)\\n```\n```python\\nclass Solution(object):\\n    def preorderTraversal(self, root):\\n        self.res = []\\n        self.dfs(root)\\n        return self.res\\n    \\n    def dfs(self, root):\\n        if not root:\\n            return \\n        self.res.append(root.val)\\n        self.dfs(root.left)\\n        self.dfs(root.right)     \\n```\n```python\\nclass Solution(object):\\n    def preorderTraversal(self, root):\\n        res = []\\n        stack = [root]\\n        while stack:\\n            node = stack.pop()\\n            if node:\\n                res.append(node.val)\\n                stack.append(node.right)\\n                stack.append(node.left)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 45292,
                "title": "python-one-line",
                "content": "```\\nclass Solution(object):\\n    def preorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n\\n        return [root.val]+ self.preorderTraversal(root.left) + self.preorderTraversal(root.right) if root else []\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def preorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n\\n        return [root.val]+ self.preorderTraversal(root.left) + self.preorderTraversal(root.right) if root else []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 45366,
                "title": "accepted-iterative-simplest-solution-in-java-using-stack",
                "content": "    public class Solution {\\n        public List<Integer> preorderTraversal(TreeNode root) {\\n            List<Integer> list = new LinkedList<Integer>();\\n            Stack<TreeNode> stack = new Stack<TreeNode>();\\n            if(root!=null) stack.push(root);\\n            while(!stack.isEmpty()){\\n                TreeNode node = stack.pop();\\n                list.add(node.val);\\n                if(node.right!=null) stack.push(node.right);\\n                if(node.left!=null) stack.push(node.left);\\n            }\\n            return list;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<Integer> preorderTraversal(TreeNode root) {\\n            List<Integer> list = new LinkedList<Integer>();\\n            Stack<TreeNode> stack = new Stack<TreeNode>();\\n            if(root!=null) stack.push(root);\\n            while(!stack.isEmpty()){\\n                TreeNode node = stack.pop();\\n                list.add(node.val);\\n                if(node.right!=null) stack.push(node.right);\\n                if(node.left!=null) stack.push(node.left);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 45389,
                "title": "java-solution-preorder-morris-traversal",
                "content": "![preorder Morris traversal][1]\\n\\n    public List<Integer> preorderTraversal(TreeNode node) {\\n        List<Integer> list = new ArrayList();\\n        \\n        while(node != null) {\\n            if(node.left == null) {\\n                list.add(node.val);\\n                node = node.right;\\n            }\\n            else {\\n                TreeNode nextNode = node.left;\\n                \\n                TreeNode p = nextNode;\\n                while(p.right != null) p = p.right;\\n                \\n                list.add(node.val);\\n                p.right = node.right;\\n                node = nextNode;\\n            }\\n        }\\n        return list;\\n    }\\n\\n\\n  [1]: http://images.cnitblog.com/blog/300640/201306/14221458-aa5f9e92cce743ccacbc735048133058.jpg",
                "solutionTags": [],
                "code": "![preorder Morris traversal][1]\\n\\n    public List<Integer> preorderTraversal(TreeNode node) {\\n        List<Integer> list = new ArrayList();\\n        \\n        while(node != null) {\\n            if(node.left == null) {\\n                list.add(node.val);\\n                node = node.right;\\n            }\\n            else {\\n                TreeNode nextNode = node.left;\\n                \\n                TreeNode p = nextNode;\\n                while(p.right != null) p = p.right;\\n                \\n                list.add(node.val);\\n                p.right = node.right;\\n                node = nextNode;\\n            }\\n        }\\n        return list;\\n    }\\n\\n\\n  [1]: http://images.cnitblog.com/blog/300640/201306/14221458-aa5f9e92cce743ccacbc735048133058.jpg",
                "codeTag": "Unknown"
            },
            {
                "id": 45446,
                "title": "elegant-c-iterative-solution-0ms-10-lines",
                "content": "    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> result;\\n        stack<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            auto p = q.top();\\n            q.pop();\\n            if(p == NULL)\\n            {\\n                continue;\\n            }\\n            result.push_back(p->val);\\n            q.push(p->right);\\n            q.push(p->left);\\n        }\\n        \\n        return result;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> result;\\n        stack<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            auto p = q.top();\\n            q.pop();\\n            if(p == NULL)\\n            {\\n                continue;\\n            }\\n            result.push_back(p->val);\\n            q.push(p->right);\\n            q.push(p->left);\\n        }\\n        \\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3024604,
                "title": "python-3-recursive-and-iterative-solutions-visual-explanation",
                "content": "Here is the visual explanation for the iterative version.\\nI\\'m waiting for your comments\\uD83D\\uDCA1\\n**Upvote** if you like this post!\\n\\n![return (1).png](https://assets.leetcode.com/users/images/c8ae62f3-3b86-4713-b7a1-5f0c37a35f4f_1673265765.4591982.png)\\n\\n\\n\\n\\n# Iterative Version\\n```\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        self.res, stack = [], [root]\\n\\n        while stack:\\n            n = stack.pop()\\n            if n:\\n                pre_list.append(n.val)\\n                stack.append(n.right)\\n                stack.append(n.left)\\n\\n        return self.res\\n```\\n\\n# Recursive Version\\n```\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        self.res = []\\n\\n        def preorder(curr):\\n            if curr:\\n                self.res.append(curr.val)\\n                preorder(curr.left)\\n                preorder(curr.right)\\n        \\n        preorder(root)\\n        return self.res\\n```\\n\\n\\n**Upvote** if you like this post!",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        self.res, stack = [], [root]\\n\\n        while stack:\\n            n = stack.pop()\\n            if n:\\n                pre_list.append(n.val)\\n                stack.append(n.right)\\n                stack.append(n.left)\\n\\n        return self.res\\n```\n```\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        self.res = []\\n\\n        def preorder(curr):\\n            if curr:\\n                self.res.append(curr.val)\\n                preorder(curr.left)\\n                preorder(curr.right)\\n        \\n        preorder(root)\\n        return self.res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3022592,
                "title": "c-easy-solution-using-recursion-and-moris-traversal",
                "content": "# **C++ Easy Solution Using Recursion and Moris traversal**\\n* # **Recursive Traversal**\\n```\\nclass Solution {\\npublic:\\n    void preorder(TreeNode*&root,vector<int>&pre){\\n        if(root){\\n            pre.push_back(root->val);\\n            preorder(root->left,pre);\\n            preorder(root->right,pre);\\n        }\\n    }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> pre;\\n        preorder(root,pre);\\n        return pre;\\n    }\\n};\\n```\\n# ***Time Complexity : `O(N)`***\\n# ***Space Complexity : `O(N)`***\\n* # **Moris Traversal**\\n```\\nclass Solution {\\npublic:\\n    TreeNode* rightMostFinder(TreeNode*cur,TreeNode*root){\\n        while(cur->right&&cur->right!=root){\\n            cur=cur->right;\\n        }\\n        return cur;\\n    }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        TreeNode*cur=root;\\n        vector<int>ans;\\n        while(cur){\\n            TreeNode*leftNode=cur->left;\\n            if(leftNode){\\n                TreeNode*RightMost=rightMostFinder(leftNode,cur);\\n                if(RightMost->right){\\n                    RightMost->right=nullptr;\\n                    cur=cur->right;\\n                }\\n                else{\\n                    RightMost->right=cur;\\n                    ans.push_back(cur->val);\\n                    cur=cur->left;\\n                }\\n            }\\n            else{\\n                ans.push_back(cur->val);\\n                cur=cur->right;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# ***Time Complexity : `O(N)`***\\n# ***Space Complexity : `O(1)`***\\n# **Please Upvote if solution Helped You It really motivates me\\uD83D\\uDE0A**\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void preorder(TreeNode*&root,vector<int>&pre){\\n        if(root){\\n            pre.push_back(root->val);\\n            preorder(root->left,pre);\\n            preorder(root->right,pre);\\n        }\\n    }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> pre;\\n        preorder(root,pre);\\n        return pre;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* rightMostFinder(TreeNode*cur,TreeNode*root){\\n        while(cur->right&&cur->right!=root){\\n            cur=cur->right;\\n        }\\n        return cur;\\n    }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        TreeNode*cur=root;\\n        vector<int>ans;\\n        while(cur){\\n            TreeNode*leftNode=cur->left;\\n            if(leftNode){\\n                TreeNode*RightMost=rightMostFinder(leftNode,cur);\\n                if(RightMost->right){\\n                    RightMost->right=nullptr;\\n                    cur=cur->right;\\n                }\\n                else{\\n                    RightMost->right=cur;\\n                    ans.push_back(cur->val);\\n                    cur=cur->left;\\n                }\\n            }\\n            else{\\n                ans.push_back(cur->val);\\n                cur=cur->right;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022462,
                "title": "c-three-solutions-recursive-iterative-morris-traversal",
                "content": "# Approach 1\\nRecursive Traversal \\n# Complexity\\n- Time complexity : $$O(n)$$\\n- Space complexity: $$O(n)$$ (Function Call Stack)\\n# Code\\n```\\nclass Solution {\\n    void traverse(TreeNode* root,vector<int>& ans)\\n    {\\n        if(root==NULL)return;\\n        \\n        ans.push_back(root->val);\\n        traverse(root->left,ans);\\n        traverse(root->right,ans);\\n    }\\n    \\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) \\n    {\\n        vector<int> ans;\\n        traverse(root,ans);\\n        return ans;\\n        \\n    }\\n};\\n```\\n\\n# Approach 2\\nIterative Traversal with Stack \\n# Complexity\\n- Time complexity : $$O(n)$$\\n- Space complexity: $$O(n)$$ (Stack space)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int>ans;\\n        stack<TreeNode*>st;\\n        \\n        if(root==NULL) return ans;\\n        st.push(root);\\n        \\n        while(!st.empty())\\n        {\\n            TreeNode *node=st.top();\\n            st.pop();\\n            \\n            if(node->right!=NULL) st.push(node->right);\\n            if(node->left!=NULL) st.push(node->left);\\n        \\n            ans.push_back(node->val);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Approach 3\\nMorris Traversal \\n# Complexity\\n- Time complexity : $$O(n)$$\\n- Space complexity: $$O(1)$$ \\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) \\n{\\n        vector<int>ans;\\n        TreeNode* curr=root;\\n        \\n        while(curr!=NULL)\\n        {\\n            if(curr->left==NULL)\\n            {\\n                ans.push_back(curr->val);\\n                curr=curr->right;\\n            }\\n            else\\n            {\\n                TreeNode* prev=curr->left;\\n                \\n                while(prev->right!=NULL && prev->right!=curr)\\n                {\\n                    prev=prev->right;\\n                }\\n\\n                if(prev->right==NULL)\\n                {\\n                    prev->right=curr;\\n                    ans.push_back(curr->val);\\n                    curr=curr->left;\\n                }\\n                else\\n                {\\n                    prev->right=NULL;\\n                    curr=curr->right;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    void traverse(TreeNode* root,vector<int>& ans)\\n    {\\n        if(root==NULL)return;\\n        \\n        ans.push_back(root->val);\\n        traverse(root->left,ans);\\n        traverse(root->right,ans);\\n    }\\n    \\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) \\n    {\\n        vector<int> ans;\\n        traverse(root,ans);\\n        return ans;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int>ans;\\n        stack<TreeNode*>st;\\n        \\n        if(root==NULL) return ans;\\n        st.push(root);\\n        \\n        while(!st.empty())\\n        {\\n            TreeNode *node=st.top();\\n            st.pop();\\n            \\n            if(node->right!=NULL) st.push(node->right);\\n            if(node->left!=NULL) st.push(node->left);\\n        \\n            ans.push_back(node->val);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) \\n{\\n        vector<int>ans;\\n        TreeNode* curr=root;\\n        \\n        while(curr!=NULL)\\n        {\\n            if(curr->left==NULL)\\n            {\\n                ans.push_back(curr->val);\\n                curr=curr->right;\\n            }\\n            else\\n            {\\n                TreeNode* prev=curr->left;\\n                \\n                while(prev->right!=NULL && prev->right!=curr)\\n                {\\n                    prev=prev->right;\\n                }\\n\\n                if(prev->right==NULL)\\n                {\\n                    prev->right=curr;\\n                    ans.push_back(curr->val);\\n                    curr=curr->left;\\n                }\\n                else\\n                {\\n                    prev->right=NULL;\\n                    curr=curr->right;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022357,
                "title": "c-recursion-full-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Using Recursive Approach.\\n\\n# Approach\\n- A binary tree is a recursive object where we have three essential components\\n     - Root node: The topmost node of a binary tree.\\n\\n    - Left-subtree: A smaller binary tree connected via the left pointer of root node.\\n\\n    - Right-subtree: A smaller binary tree connected via the right pointer of root node.\\n\\n- So traversing a binary tree requires traversal of each component Processing root node, traversing the left subtreeand traversing the right subtree.\\n\\n![image.png](https://assets.leetcode.com/users/images/cad94ad3-9f35-497f-ac31-166c06c6d627_1673231417.744738.png)\\n\\n## Recursive preorder traversal of binary tree \\n- In recursive preorder traversal, we first process the root node, then process all nodes in the left subtree, and finally, we process all nodes in the right subtree Suppose we use a function precrder(root) with root as an input parameter.\\n\\n### Steps of recursive preorder implementation\\n\\n- First, store data stored in the root node i.e process(root->value) in vector\\n- Then we recursively traverse and process each node in the left subtree by calling the same function with root->left as input parameter i.e preorder(root->left).\\n- Then we recursively traverse and process each node in the right subtree by calling the same function with rout->right as input parameter ie preorder(root->right). \\n- Base case: recursion will terminate and backtrack when it reaches the bottommost end of binary tree, i.e root==NULL\\n\\n![image.png](https://assets.leetcode.com/users/images/a4ee446e-7b0d-41a2-bac8-365b4398b3db_1673231891.0546484.png)\\n![image.png](https://assets.leetcode.com/users/images/41544952-4e5f-4f7d-8861-273e3e7b0ce5_1673231902.5866964.png)\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void preorder(TreeNode* root, vector<int> &a)\\n        {\\n            // Base Case\\n            if(root==NULL)\\n                return;\\n\\n            a.push_back(root->val);// store in vector\\n            preorder(root->left,a);// recursion for left sub tree\\n            preorder(root->right,a);// recursion for right sub tree\\n        }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n       vector<int> a;\\n        preorder(root,a);\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void preorder(TreeNode* root, vector<int> &a)\\n        {\\n            // Base Case\\n            if(root==NULL)\\n                return;\\n\\n            a.push_back(root->val);// store in vector\\n            preorder(root->left,a);// recursion for left sub tree\\n            preorder(root->right,a);// recursion for right sub tree\\n        }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n       vector<int> a;\\n        preorder(root,a);\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022151,
                "title": "rust-iterative-recursive-0ms",
                "content": "# Approach\\nThe recursive version descends the tree through recursive calls with their state pushed on the execution stack. The traversal prefers the left branch over the right, and the output is built before descending either branch.\\n\\nThe iterative version is very similar. It also uses a stack to preserve the state of traversal. The right branch is pushed before the left, since the left branch needs to be popped before the right. The output is updated before pushing any branches.\\n\\nThe cloning operations in the code don\\'t clone the actual tree nodes, what\\'s being cloned are the smart pointers that reference them. I don\\'t believe there\\'s any value in avoiding cloning these.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ Each node is visited in turn - no searching.\\n- Space complexity: $$O(n + log_2(n))$$ *auxiliary* memory used. The returned vector accounts for the $$n + $$ term. For the $$log_2(n)$$ term, the memory used when pushing an execution stack frame counts in the same way the memory used when pushing an iterative stack item counts. The height of the tree determines the max number of stack items that will be piled up at any time during traversal. Assuming the tree is balanced, the height will be $$log_2(n)$$.\\n\\n# Code\\n```rust\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\ntype NodeOpt = Option<Rc<RefCell<TreeNode>>>;\\n\\nimpl Solution {\\n    pub fn preorder_traversal(root: NodeOpt) -> Vec<i32> {\\n        Self::preorder_traversal_iter(root)\\n        //let mut result = vec![];\\n        //Self::preorder_traversal_recurs(root, &mut result);\\n        //result\\n    }\\n    fn preorder_traversal_recurs(root: NodeOpt, result: &mut Vec<i32>) {\\n        if let Some(pnode) = root {\\n            let node = pnode.borrow();\\n            result.push(node.val);\\n            Self::preorder_traversal_recurs(node.left.clone(), result);\\n            Self::preorder_traversal_recurs(node.right.clone(), result);\\n        }\\n    }\\n    fn preorder_traversal_iter(root: NodeOpt) -> Vec<i32> {\\n        let mut result = vec![];\\n        let mut stack  = vec![root];\\n        while let Some(node_opt) = stack.pop() {\\n            if let Some(pnode) = node_opt {\\n                let node = pnode.borrow();\\n                result.push(node.val);\\n                stack.push(node.right.clone());\\n                stack.push(node.left.clone());\\n            }\\n        }\\n        result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Binary Tree"
                ],
                "code": "```rust\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\ntype NodeOpt = Option<Rc<RefCell<TreeNode>>>;\\n\\nimpl Solution {\\n    pub fn preorder_traversal(root: NodeOpt) -> Vec<i32> {\\n        Self::preorder_traversal_iter(root)\\n        //let mut result = vec![];\\n        //Self::preorder_traversal_recurs(root, &mut result);\\n        //result\\n    }\\n    fn preorder_traversal_recurs(root: NodeOpt, result: &mut Vec<i32>) {\\n        if let Some(pnode) = root {\\n            let node = pnode.borrow();\\n            result.push(node.val);\\n            Self::preorder_traversal_recurs(node.left.clone(), result);\\n            Self::preorder_traversal_recurs(node.right.clone(), result);\\n        }\\n    }\\n    fn preorder_traversal_iter(root: NodeOpt) -> Vec<i32> {\\n        let mut result = vec![];\\n        let mut stack  = vec![root];\\n        while let Some(node_opt) = stack.pop() {\\n            if let Some(pnode) = node_opt {\\n                let node = pnode.borrow();\\n                result.push(node.val);\\n                stack.push(node.right.clone());\\n                stack.push(node.left.clone());\\n            }\\n        }\\n        result\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2867567,
                "title": "beated-94-21-javascript-simple-small-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar preorderTraversal = function (root) {\\n    let arr = []\\n    const getVal = (root) => {\\n        if(!root)\\n        return         \\n        arr.push(root.val)\\n        getVal(root.left)\\n        getVal(root.right)\\n    }\\n    getVal(root)\\n    return arr\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar preorderTraversal = function (root) {\\n    let arr = []\\n    const getVal = (root) => {\\n        if(!root)\\n        return         \\n        arr.push(root.val)\\n        getVal(root.left)\\n        getVal(root.right)\\n    }\\n    getVal(root)\\n    return arr\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2745358,
                "title": "java-iterative-and-recursive-clean-and-simple",
                "content": "# Please Upvote \\uD83D\\uDE07\\n---\\n### 1. Recursive approach:\\n``` java []\\nclass Solution {\\n    private List<Integer> ans = new ArrayList<>();\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        traverse(root);\\n        return ans;\\n    }\\n\\n    private void traverse(TreeNode root) {\\n        if (root == null) {\\n            return;\\n        }\\n        ans.add(root.val);\\n        traverse(root.left);\\n        traverse(root.right);\\n    }\\n}\\n\\n// TC: O(n), SC: O(h)\\n```\\n---\\n### 2. Iterative approach:\\n``` java []\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        if (root == null) {\\n            return ans;\\n        }\\n\\n        Stack<TreeNode> st = new Stack<>();\\n        st.push(root);\\n\\n        while (!st.isEmpty()) {\\n            TreeNode curr = st.pop();\\n            ans.add(curr.val);\\n\\n            if (curr.right != null) {\\n                st.push(curr.right);\\n            }\\n            if (curr.left != null) {\\n                st.push(curr.left);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n// TC: O(n), SC: O(h)\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Recursion"
                ],
                "code": "``` java []\\nclass Solution {\\n    private List<Integer> ans = new ArrayList<>();\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        traverse(root);\\n        return ans;\\n    }\\n\\n    private void traverse(TreeNode root) {\\n        if (root == null) {\\n            return;\\n        }\\n        ans.add(root.val);\\n        traverse(root.left);\\n        traverse(root.right);\\n    }\\n}\\n\\n// TC: O(n), SC: O(h)\\n```\n``` java []\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        if (root == null) {\\n            return ans;\\n        }\\n\\n        Stack<TreeNode> st = new Stack<>();\\n        st.push(root);\\n\\n        while (!st.isEmpty()) {\\n            TreeNode curr = st.pop();\\n            ans.add(curr.val);\\n\\n            if (curr.right != null) {\\n                st.push(curr.right);\\n            }\\n            if (curr.left != null) {\\n                st.push(curr.left);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n// TC: O(n), SC: O(h)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1570075,
                "title": "recursion-time-complexity-space-complexity-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector <int> nodeVec;\\n        doTraversal(nodeVec,root);\\n        return nodeVec;\\n    }\\n    void doTraversal(vector<int> &nodeVec, TreeNode* temp)\\n    {\\n        if(temp==nullptr)\\n            return;\\n        nodeVec.push_back(temp->val);\\n        doTraversal(nodeVec,temp->left);\\n        doTraversal(nodeVec,temp->right);\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector <int> nodeVec;\\n        doTraversal(nodeVec,root);\\n        return nodeVec;\\n    }\\n    void doTraversal(vector<int> &nodeVec, TreeNode* temp)\\n    {\\n        if(temp==nullptr)\\n            return;\\n        nodeVec.push_back(temp->val);\\n        doTraversal(nodeVec,temp->left);\\n        doTraversal(nodeVec,temp->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 971310,
                "title": "python-iterative-recursive-solution",
                "content": "## Leecode 144 - Preorder\\n### Iterative Tree Traversal\\n```python\\ndef preorderTraversal(self, root: TreeNode) -> List[int]:\\n    res, stack = [], [root]\\n\\n    while stack:\\n        root = stack.pop()\\n\\n        if root:\\n            res.append(root.val)\\n            stack.append(root.right)\\n            stack.append(root.left)\\n        \\n    return res\\n```\\n### Recursive Tree Traversal\\n```python\\ndef preorderTraversal(self, root: TreeNode) -> List[int]:\\n    res = []\\n\\n    def dfs(node: TreeNode):\\n        if node:\\n            result.append(node.val)\\n            dfs(node.left)\\n            dfs(node.right)\\n\\n    dfs(root)\\n    return res\\n```\\n\\n# Question List\\n94\\\\. Binary Tree Inorder Traversal \\\\\\n102\\\\. Binary Tree Level Order Traversal \\\\\\n144\\\\. Binary Tree Preorder Traversal \\\\\\n145\\\\. Binary Tree Postorder Traversal",
                "solutionTags": [
                    "Python",
                    "Tree"
                ],
                "code": "```python\\ndef preorderTraversal(self, root: TreeNode) -> List[int]:\\n    res, stack = [], [root]\\n\\n    while stack:\\n        root = stack.pop()\\n\\n        if root:\\n            res.append(root.val)\\n            stack.append(root.right)\\n            stack.append(root.left)\\n        \\n    return res\\n```\n```python\\ndef preorderTraversal(self, root: TreeNode) -> List[int]:\\n    res = []\\n\\n    def dfs(node: TreeNode):\\n        if node:\\n            result.append(node.val)\\n            dfs(node.left)\\n            dfs(node.right)\\n\\n    dfs(root)\\n    return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 937276,
                "title": "java-iterative-and-recursive-inorder-preorder-postorder-dfs-traversal",
                "content": "****************DFS Iterative Traversal****************\\n\\n****************\\n\\n**Inorder**\\n\\n```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        if (root == null)\\n            return list;\\n        Stack<TreeNode> stack = new Stack<>();\\n        while(stack.size() > 0 || root != null) {\\n            while(root != null) {\\n                stack.add(root);\\n                root = root.left;\\n            }\\n            root = stack.pop();\\n            list.add(root.val);\\n            root = root.right;\\n        }\\n\\n        return list;\\n    }\\n}\\n```\\n\\n\\n****************\\n\\n**Preorder**\\n\\n```\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList();\\n        if(root == null)\\n            return list;\\n        Stack<TreeNode> stack = new Stack();\\n        stack.add(root);\\n        while(!stack.isEmpty()) {\\n            root = stack.pop();\\n            list.add(root.val);\\n            if(root.right != null)\\n                stack.add(root.right);\\n            if(root.left != null)\\n                stack.add(root.left);\\n        }\\n        \\n        return list;\\n    }\\n}\\n```\\n\\n\\n****************\\n\\n**Postorder**\\n\\n```\\nclass Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList();\\n        Stack<TreeNode> stack = new Stack();\\n        while(!stack.isEmpty() || root != null) {\\n            if(root != null) {\\n                stack.add(root);\\n                root = root.left;\\n            } else {\\n                TreeNode temp = stack.peek().right;\\n                if(temp == null) {\\n                    temp = stack.pop();\\n                    list.add(temp.val);\\n                    while(!stack.isEmpty() && temp ==  stack.peek().right) {\\n                        temp = stack.pop();\\n                        list.add(temp.val);\\n                    }\\n                } else {\\n                    root = temp;\\n                }\\n            }\\n        }\\n        \\n        return list;\\n    }\\n}\\n```\\n\\n**Postorder from Preorder - Reverse the steps of pushing left and right child into stack and reverse full list in the end.**\\n\\n```\\nclass Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList();\\n        if(root == null)\\n            return list;\\n        Stack<TreeNode> stack = new Stack();\\n        stack.add(root);\\n        while(!stack.isEmpty()) {\\n            root = stack.pop();\\n            list.add(root.val);\\n            if(root.left != null)\\n                stack.add(root.left);\\n            if(root.right != null)\\n                stack.add(root.right);\\n        }\\n        Collections.reverse(list);\\n        return list;\\n    }\\n}\\n```\\n\\n****************\\n\\n****************DFS Recrsive Traversal****************\\n\\n**Inorder**\\n\\n```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList();\\n        dfs(root, list);\\n        return list;\\n    }\\n    \\n    private void dfs(TreeNode root, List<Integer> list) {\\n        if(root == null)\\n            return;\\n        dfs(root.left, list);\\n        list.add(root.val);\\n        dfs(root.right, list);\\n    } \\n}\\n```\\n\\n****************\\n\\n**Preorder**\\n\\n```\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList();\\n        dfs(root, list);\\n        return list;\\n    }\\n    \\n    private void dfs(TreeNode root, List<Integer> list) {\\n        if(root == null)\\n            return;\\n        list.add(root.val);\\n        dfs(root.left, list);\\n        dfs(root.right, list);\\n    }\\n}\\n```\\n\\n****************\\n\\n**Postorder**\\n\\n```\\nclass Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList();\\n        dfs(root, list);\\n        return list;\\n    }\\n    \\n    private void dfs(TreeNode root, List<Integer> list) {\\n        if(root == null)\\n            return;\\n        dfs(root.left, list);\\n        dfs(root.right, list);\\n        list.add(root.val);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        if (root == null)\\n            return list;\\n        Stack<TreeNode> stack = new Stack<>();\\n        while(stack.size() > 0 || root != null) {\\n            while(root != null) {\\n                stack.add(root);\\n                root = root.left;\\n            }\\n            root = stack.pop();\\n            list.add(root.val);\\n            root = root.right;\\n        }\\n\\n        return list;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList();\\n        if(root == null)\\n            return list;\\n        Stack<TreeNode> stack = new Stack();\\n        stack.add(root);\\n        while(!stack.isEmpty()) {\\n            root = stack.pop();\\n            list.add(root.val);\\n            if(root.right != null)\\n                stack.add(root.right);\\n            if(root.left != null)\\n                stack.add(root.left);\\n        }\\n        \\n        return list;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList();\\n        Stack<TreeNode> stack = new Stack();\\n        while(!stack.isEmpty() || root != null) {\\n            if(root != null) {\\n                stack.add(root);\\n                root = root.left;\\n            } else {\\n                TreeNode temp = stack.peek().right;\\n                if(temp == null) {\\n                    temp = stack.pop();\\n                    list.add(temp.val);\\n                    while(!stack.isEmpty() && temp ==  stack.peek().right) {\\n                        temp = stack.pop();\\n                        list.add(temp.val);\\n                    }\\n                } else {\\n                    root = temp;\\n                }\\n            }\\n        }\\n        \\n        return list;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList();\\n        if(root == null)\\n            return list;\\n        Stack<TreeNode> stack = new Stack();\\n        stack.add(root);\\n        while(!stack.isEmpty()) {\\n            root = stack.pop();\\n            list.add(root.val);\\n            if(root.left != null)\\n                stack.add(root.left);\\n            if(root.right != null)\\n                stack.add(root.right);\\n        }\\n        Collections.reverse(list);\\n        return list;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList();\\n        dfs(root, list);\\n        return list;\\n    }\\n    \\n    private void dfs(TreeNode root, List<Integer> list) {\\n        if(root == null)\\n            return;\\n        dfs(root.left, list);\\n        list.add(root.val);\\n        dfs(root.right, list);\\n    } \\n}\\n```\n```\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList();\\n        dfs(root, list);\\n        return list;\\n    }\\n    \\n    private void dfs(TreeNode root, List<Integer> list) {\\n        if(root == null)\\n            return;\\n        list.add(root.val);\\n        dfs(root.left, list);\\n        dfs(root.right, list);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList();\\n        dfs(root, list);\\n        return list;\\n    }\\n    \\n    private void dfs(TreeNode root, List<Integer> list) {\\n        if(root == null)\\n            return;\\n        dfs(root.left, list);\\n        dfs(root.right, list);\\n        list.add(root.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 806233,
                "title": "scala-recursive",
                "content": "```\\nobject Solution {\\n    def preorderTraversal(root: TreeNode): List[Int] = {\\n        Option(root) match {\\n            case Some(node) => List(node.value) ++ preorderTraversal(node.left) ++ preorderTraversal(node.right)\\n            case _ => List()\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala",
                    "Recursion"
                ],
                "code": "```\\nobject Solution {\\n    def preorderTraversal(root: TreeNode): List[Int] = {\\n        Option(root) match {\\n            case Some(node) => List(node.value) ++ preorderTraversal(node.left) ++ preorderTraversal(node.right)\\n            case _ => List()\\n        }\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 774069,
                "title": "runtime-0-ms-faster-than-100-00-c-iterative",
                "content": "\\n    class Solution {\\n        public:\\n            vector<int> preorderTraversal(TreeNode* root) {\\n                if(root==NULL)\\n                   return {};\\n                vector<int> vec;\\n                stack<TreeNode*> s;\\n                while(true){\\n                    if(root!=NULL){\\n                       s.push(root);\\n                       vec.push_back(root->val); \\n                       root=root->left; \\n                    }\\n                    else{\\n                        if(s.empty())\\n                            break;\\n                        root=s.top();\\n                        s.pop();\\n                        root=root->right;\\n                    }\\n                }\\n                return vec;\\n            }\\n      };\\n\\t\\n**Feel free to ask any question in the comment section.\\nIf you like this solution, do UPVOTE.\\nHappy Coding :)**\\n\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "class Solution {\\n        public:\\n            vector<int> preorderTraversal(TreeNode* root) {\\n                if(root==NULL)\\n                   return {}",
                "codeTag": "Java"
            },
            {
                "id": 446676,
                "title": "one-line-recursive-javascript-solution",
                "content": "``` javascript\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar preorderTraversal = function(root) {\\n    return root ? [root.val, ...preorderTraversal(root.left), ...preorderTraversal(root.right)] : [];\\n};\\n```\\n\\nOff course iterative solution is better.",
                "solutionTags": [],
                "code": "``` javascript\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar preorderTraversal = function(root) {\\n    return root ? [root.val, ...preorderTraversal(root.left), ...preorderTraversal(root.right)] : [];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 327891,
                "title": "c-o-n-in-place-80-beat-morris-traversal-hot-stinger-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        \\n        vector<int> aResult;\\n        \\n        //We memorize the Morris traversal of binary trees.\\n        TreeNode *aNode = root, *aPrev;\\n        while (aNode != NULL) {\\n            if (aNode->left == NULL) {\\n                aResult.push_back(aNode->val);\\n                aNode = aNode->right;\\n            } else {\\n                aPrev = aNode->left;\\n                while (aPrev->right != NULL && aPrev->right != aNode) {\\n                    aPrev = aPrev->right;\\n                }\\n                if (aPrev->right == aNode) {\\n                    aPrev->right = NULL;\\n                    aNode = aNode->right;\\n                } else {\\n                    aResult.push_back(aNode->val);\\n                    aPrev->right = aNode;\\n                    aNode = aNode->left;\\n                }\\n            }\\n        }\\n        \\n        return aResult;\\n    }\\n};\\n```\\n\\nThis only differs slightly from in-order traversal. We \"print\" the node the first time we visit it instead of on the pass-back-through...",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        \\n        vector<int> aResult;\\n        \\n        //We memorize the Morris traversal of binary trees.\\n        TreeNode *aNode = root, *aPrev;\\n        while (aNode != NULL) {\\n            if (aNode->left == NULL) {\\n                aResult.push_back(aNode->val);\\n                aNode = aNode->right;\\n            } else {\\n                aPrev = aNode->left;\\n                while (aPrev->right != NULL && aPrev->right != aNode) {\\n                    aPrev = aPrev->right;\\n                }\\n                if (aPrev->right == aNode) {\\n                    aPrev->right = NULL;\\n                    aNode = aNode->right;\\n                } else {\\n                    aResult.push_back(aNode->val);\\n                    aPrev->right = aNode;\\n                    aNode = aNode->left;\\n                }\\n            }\\n        }\\n        \\n        return aResult;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 148119,
                "title": "java-iterative-and-recursive-solutions",
                "content": "Iterative \\n```\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        Stack<TreeNode> stack = new Stack<>();\\n        \\n        while(root != null || !stack.isEmpty()) {\\n            while(root != null) {\\n                list.add(root.val);\\n                stack.push(root);\\n                root = root.left;\\n            }\\n            root = stack.pop();\\n            root = root.right;\\n        }\\n        \\n        return list;\\n    }\\n}\\n```\\n\\nRecursive\\n```\\nclass Solution {\\n    public List<Integer> list = new ArrayList<>();\\n    \\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        if (root == null) {\\n            return list;\\n        }\\n\\n        list.add(root.val);\\n        if (root.left != null)\\n            preorderTraversal(root.left);\\n\\n        if (root.right != null)\\n            preorderTraversal(root.right);\\n        \\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        Stack<TreeNode> stack = new Stack<>();\\n        \\n        while(root != null || !stack.isEmpty()) {\\n            while(root != null) {\\n                list.add(root.val);\\n                stack.push(root);\\n                root = root.left;\\n            }\\n            root = stack.pop();\\n            root = root.right;\\n        }\\n        \\n        return list;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<Integer> list = new ArrayList<>();\\n    \\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        if (root == null) {\\n            return list;\\n        }\\n\\n        list.add(root.val);\\n        if (root.left != null)\\n            preorderTraversal(root.left);\\n\\n        if (root.right != null)\\n            preorderTraversal(root.right);\\n        \\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 45385,
                "title": "my-recursive-and-iterative-cpp-code",
                "content": "**Recursive:**\\n\\n    class Solution {\\n    public:\\n        \\n        vector<int> result;\\n        \\n        void dfs(TreeNode *root)\\n        {\\n            if(!root) return;\\n            \\n            result.push_back(root->val);\\n            dfs(root->left);\\n            dfs(root->right);\\n        }\\n        \\n        vector<int> preorderTraversal(TreeNode* root) \\n        {\\n            dfs(root);\\n            return result;\\n        }\\n    };\\n\\n**Iterative:**\\n\\n    class Solution {\\n    public:\\n        \\n        vector<int> preorderTraversal(TreeNode* root) \\n        {\\n            vector<int> result;\\n            \\n            if(!root) return result;\\n            \\n            stack<TreeNode*> nodes;\\n        \\n            while(root)\\n            {\\n                result.push_back(root->val);\\n                nodes.push(root);\\n                root = root->left;\\n            }\\n            \\n            while( !nodes.empty() )\\n            {\\n                root = nodes.top();\\n                nodes.pop();\\n                \\n                root = root->right;\\n                while(root)\\n                {\\n                    result.push_back(root->val);\\n                    nodes.push(root);\\n                    root = root->left;\\n                }\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        \\n        vector<int> result;\\n        \\n        void dfs(TreeNode *root)\\n        {\\n            if(!root) return;\\n            \\n            result.push_back(root->val);\\n            dfs(root->left);\\n            dfs(root->right);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 45482,
                "title": "my-c-solution-recursive-and-stack-based-non-recursive",
                "content": "    For non-recursive, it is simple to use a stack, but just remember to push the right child before the left child  \\n      class Solution {\\n        public:\\n        /*\\n                //recursive solution\\n            void preorderVec(TreeNode *root, vector<int> &result)\\n            {\\n                if(root)\\n                {\\n                    result.push_back(root->val);\\n                    preorderVec(root->left, result);\\n                    preorderVec(root->right, result);\\n                }\\n            }\\n        \\n            vector<int> preorderTraversal(TreeNode *root) {\\n                vector<int> result;\\n                preorderVec(root, result);\\n                return result;\\n            }\\n        */    \\n            vector<int> preorderTraversal(TreeNode *root) {\\n                //non-recursive solution\\n                vector<int> result;\\n                stack<TreeNode *> nodeS;\\n                TreeNode *topS;\\n                if(root)\\n                {// if the tree is non-empty\\n                    nodeS.push(root); // push the root to the stack\\n        \\n                    while(!nodeS.empty())\\n                    {  \\n                        topS = nodeS.top();\\n                        nodeS.pop(); // remove the top node\\n                        // add right child first and then left child\\n                        if(topS->right)\\n                        {\\n                            nodeS.push(topS->right);\\n                        }\\n                        if(topS->left)\\n                        {\\n                            nodeS.push(topS->left);\\n                        }\\n                        \\n                        result.push_back(topS->val);\\n                    }\\n                }\\n                return result;\\n            }\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n        /*\\n                //recursive solution\\n            void preorderVec(TreeNode *root, vector<int> &result)\\n            {\\n                if(root)\\n                {\\n                    result.push_back(root->val);\\n                    preorderVec(root->left, result);\\n                    preorderVec(root->right, result);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3168483,
                "title": "best-o-n-solution",
                "content": "# Approach 1\\nRecursive Solution\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution { \\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector <int> nodes;\\n        preorder(root, nodes);\\n        return nodes;\\n    }\\nprivate:\\n    void preorder(TreeNode* root, vector <int>& nodes) {\\n        if (root == NULL)\\n            return;\\n        nodes.push_back(root->val);\\n        preorder(root->left, nodes);\\n        preorder(root->right, nodes);    \\n    }       \\n};\\n```\\n\\n# Approach 2\\nIterative Solution\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution { \\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector <int> preorder;\\n        if (root == NULL)\\n            return preorder;\\n        stack <TreeNode* > st;\\n        st.push(root);\\n        while (st.empty() != true) {\\n            TreeNode* curr = st.top();\\n            st.pop();\\n            preorder.push_back(curr->val);\\n            if (curr->right != NULL)\\n                st.push(curr->right);\\n            if (curr->left != NULL)\\n                st.push(curr->left);    \\n        }\\n        return preorder;\\n    }    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution { \\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector <int> nodes;\\n        preorder(root, nodes);\\n        return nodes;\\n    }\\nprivate:\\n    void preorder(TreeNode* root, vector <int>& nodes) {\\n        if (root == NULL)\\n            return;\\n        nodes.push_back(root->val);\\n        preorder(root->left, nodes);\\n        preorder(root->right, nodes);    \\n    }       \\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution { \\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector <int> preorder;\\n        if (root == NULL)\\n            return preorder;\\n        stack <TreeNode* > st;\\n        st.push(root);\\n        while (st.empty() != true) {\\n            TreeNode* curr = st.top();\\n            st.pop();\\n            preorder.push_back(curr->val);\\n            if (curr->right != NULL)\\n                st.push(curr->right);\\n            if (curr->left != NULL)\\n                st.push(curr->left);    \\n        }\\n        return preorder;\\n    }    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3090382,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void f(TreeNode* root,vector<int> &ans)\\n    {\\n        if(root==NULL)\\n            return;\\n        ans.push_back(root->val);\\n        f(root->left, ans);\\n        f(root->right, ans);\\n    }\\n    \\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        f(root, ans);\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void f(TreeNode* root,vector<int> &ans)\\n    {\\n        if(root==NULL)\\n            return;\\n        ans.push_back(root->val);\\n        f(root->left, ans);\\n        f(root->right, ans);\\n    }\\n    \\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        f(root, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3025030,
                "title": "100-faster-java-c-solutions-0-ms-with-explanation",
                "content": "\\n# Approach\\n- In PreOrder Traversal First we Consider value of Root Node \\n- After That Consider values of left sub-tree in PreOrder\\n- Afret That Consider Values of Rigth sub-tree in PreOrder \\n\\n# Java Code\\n```\\nclass Solution {\\n    public List<Integer> Answer=new ArrayList<Integer>();\\n//Consider Global List For Answer \\n    public List<Integer> preorderTraversal(TreeNode root) \\n    {\\n        if(root==null)  //if root of tree is null than tree dont have any element so return empty list of Answer\\n            return Answer;  \\n        \\n        Travers(root); //Travers Tree in  preorder(root,left sub-tree,right sub-tree)\\n\\n        return Answer;\\n    }\\n\\n    public void Travers(TreeNode root)\\n    {\\n        Answer.add(root.val);   // first add value of rood into list of Answer\\n            \\n        if(root.left!=null)     //if root have Left sub-tree than Travers it in preorder\\n            Travers(root.left);\\n            \\n        if(root.right!=null)     //if root have Right sub-tree than Travers it in preorder\\n            Travers(root.right);\\n    }   \\n}\\n```\\n\\n#  C++ Code\\n```\\n\\nclass Solution {\\npublic:\\n    vector<int> Answer; //Consider Global Vector For Answer \\n    vector<int> preorderTraversal(TreeNode* root) \\n    {\\n        if(root==NULL)  //if root of tree is null than tree dont have any element so return empty list of Answer\\n            return Answer;  \\n        \\n        Travers(root); //Travers Tree in  preorder(root,left sub-tree,right sub-tree)\\n\\n        return Answer;\\n    }\\n    void Travers(TreeNode* root)\\n    {\\n        Answer.push_back(root->val);   // first add value of rood into list of Answer\\n            \\n        if(root->left!=NULL)     //if root have Left sub-tree than Travers it in preorder\\n            Travers(root->left);\\n            \\n        if(root->right!=NULL)     //if root have Right sub-tree than Travers it in preorder\\n            Travers(root->right);  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> Answer=new ArrayList<Integer>();\\n//Consider Global List For Answer \\n    public List<Integer> preorderTraversal(TreeNode root) \\n    {\\n        if(root==null)  //if root of tree is null than tree dont have any element so return empty list of Answer\\n            return Answer;  \\n        \\n        Travers(root); //Travers Tree in  preorder(root,left sub-tree,right sub-tree)\\n\\n        return Answer;\\n    }\\n\\n    public void Travers(TreeNode root)\\n    {\\n        Answer.add(root.val);   // first add value of rood into list of Answer\\n            \\n        if(root.left!=null)     //if root have Left sub-tree than Travers it in preorder\\n            Travers(root.left);\\n            \\n        if(root.right!=null)     //if root have Right sub-tree than Travers it in preorder\\n            Travers(root.right);\\n    }   \\n}\\n```\n```\\n\\nclass Solution {\\npublic:\\n    vector<int> Answer; //Consider Global Vector For Answer \\n    vector<int> preorderTraversal(TreeNode* root) \\n    {\\n        if(root==NULL)  //if root of tree is null than tree dont have any element so return empty list of Answer\\n            return Answer;  \\n        \\n        Travers(root); //Travers Tree in  preorder(root,left sub-tree,right sub-tree)\\n\\n        return Answer;\\n    }\\n    void Travers(TreeNode* root)\\n    {\\n        Answer.push_back(root->val);   // first add value of rood into list of Answer\\n            \\n        if(root->left!=NULL)     //if root have Left sub-tree than Travers it in preorder\\n            Travers(root->left);\\n            \\n        if(root->right!=NULL)     //if root have Right sub-tree than Travers it in preorder\\n            Travers(root->right);  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3023226,
                "title": "beats-100-c-simple-recursive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust do three simple steps first insert the data of root and then call left subtree and then call right subtree .This will give us  preorder traversal\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)-->Recursive stack\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n void preorder(TreeNode *root,vector<int>&ans){\\n     if(!root)return;\\n     ans.push_back(root->val);\\n     preorder(root->left,ans);\\n    \\n     preorder(root->right,ans);\\n    \\n }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int>ans;\\n         preorder(root,ans);\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n void preorder(TreeNode *root,vector<int>&ans){\\n     if(!root)return;\\n     ans.push_back(root->val);\\n     preorder(root->left,ans);\\n    \\n     preorder(root->right,ans);\\n    \\n }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int>ans;\\n         preorder(root,ans);\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3023199,
                "title": "simple-c-stack-solution-for-beginner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    void fun(TreeNode* root){\\n       if(!root) return;\\n       stack<TreeNode*> st;\\n       st.push(root);\\n       while(!st.empty()){\\n           TreeNode* p=st.top();\\n           v.push_back(p->val);\\n           st.pop();\\n\\n            if(p->right){\\n               st.push(p->right);\\n           }\\n           if(p->left){\\n               st.push(p->left);\\n           }\\n          \\n           \\n       }\\n    }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        fun(root);\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    void fun(TreeNode* root){\\n       if(!root) return;\\n       stack<TreeNode*> st;\\n       st.push(root);\\n       while(!st.empty()){\\n           TreeNode* p=st.top();\\n           v.push_back(p->val);\\n           st.pop();\\n\\n            if(p->right){\\n               st.push(p->right);\\n           }\\n           if(p->left){\\n               st.push(p->left);\\n           }\\n          \\n           \\n       }\\n    }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        fun(root);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022820,
                "title": "detailed-explanation-iterative-and-recursive-solutions-in-java-and-javascript",
                "content": "# Recursive Solution\\n## Intuition\\nIn a preorder traversal, the root node is visited first, followed by the left subtree and then the right subtree.\\n\\nThe code uses function preorderTraversal() to traverse the tree in a recursive manner. The function is called on the root node of the tree, and then it is called recursively on the left and right children of the root (if they exist).\\n\\nThe key idea behind this algorithm is that the recursive function calls simulate the process of visiting the nodes of the tree in a preorder fashion. Each time the function is called, it adds the value of the current node to the list and then calls itself on the left and right children of the current node. This continues until the function has been called on all of the nodes in the tree, at which point the list will contain the values of the nodes in the correct order.\\n\\n## Approach\\n1. Initialize an empty list list to store the preorder traversal.\\n2. If the root node is null, return the empty list.\\n3. Add the value of the root node to the list.\\n4. Call the function recursively on the left child of the root node.\\n5. Call the function recursively on the right child of the root node.\\n6. Return the list.\\n\\n## Complexity\\n- Time complexity:\\nThe time complexity of the code provided is O(n), where n is the number of nodes in the tree. This is because the algorithm visits each node once, so the time complexity is linear in the size of the input.\\n\\n- Space complexity:\\nThe space complexity is O(n) in the worst case, when the tree is highly unbalanced and the function calls form a chain. In this case, the function call stack will contain all of the nodes in the tree, and the space complexity will be linear in the size of the input. In the best case, when the tree is balanced, the space complexity is O(log n), since the height of the tree is logarithmic in the number of nodes.\\n\\n## Code\\n```Java []\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    List<Integer> list = new ArrayList<Integer>();\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        if(root == null){\\n            return list;\\n        }\\n        list.add(root.val);\\n        preorderTraversal(root.left);\\n        preorderTraversal(root.right);\\n        return list;\\n    }\\n}\\n```\\n```javascript []\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\n\\nvar preorderTraversal = function(root, list = []) {\\n    if(!root){\\n        return [];\\n    }\\n    list.push(root.val);\\n    if (root.left !== null) preorderTraversal(root.left, list);\\n    if (root.right !== null) preorderTraversal(root.right, list);\\n    return list;\\n};\\n```\\n# Iterative Approach\\n## Intuition\\nIn a preorder traversal, the root node is visited first, followed by the left subtree and then the right subtree.\\n\\nWe use a stack to keep track of the nodes that have been visited but have not yet had their subtrees explored. The algorithm works by pushing the root node onto the stack and then repeatedly popping a node from the stack, adding its value to the list, and pushing its children (if any) onto the stack.\\n\\nThe key idea behind this algorithm is that **the stack simulates the behavior of the function call stack in a recursive implementation of the preorder traversal.** Each time a node is popped from the stack, it is as if the function has returned from exploring that node\\'s subtree and is now ready to move on to the next node.\\n\\n## Approach\\n1. Initialize an empty list list to store the preorder traversal and an empty stack stack to keep track of the nodes that have been visited but have not yet had their subtrees explored.\\n2. If the root node is null, return the empty list.\\n3. Push the root node onto the stack.\\n4. While the stack is not empty:\\n    1. Pop a node from the stack and add its value to the list.\\n    2. If the node has a right child, push it onto the stack.\\n    3. If the node has a left child, push it onto the stack.\\n5. Return the list.\\n## Complexity\\n- Time complexity:\\nThe time complexity of this approach is O(n), where n is the number of nodes in the tree. This is because the algorithm visits each node once, so the time complexity is linear in the size of the input.\\n\\n- Space complexity:\\nThe space complexity is also O(n), since the stack may contain up to n nodes at any given time. This is because the stack is used to keep track of the nodes that have been visited but have not yet had their right subtrees explored, and in the worst case, the stack could contain all of the nodes in the tree.\\n\\n## Code\\n\\n```Java []\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    \\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<Integer>();\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        if(root == null){\\n            return list;\\n        }\\n        stack.push(root);\\n        \\n        while(!stack.isEmpty()){\\n            TreeNode curr = stack.pop();\\n            list.add(curr.val);\\n            if(curr.right != null){\\n                stack.push(curr.right);\\n            }\\n            if(curr.left != null){\\n                stack.push(curr.left);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```\\n```javascript []\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\n\\nvar preorderTraversal = function(root) {\\n    if(!root) return [];\\n    let stack = [];\\n    let list = [];\\n    stack.push(root);\\n    while(stack.length){\\n        let node = stack.pop();\\n        list.push(node.val);\\n        if(node.right) stack.push(node.right);\\n        if(node.left) stack.push(node.left);\\n    }\\n    return list;\\n};\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "JavaScript",
                    "Stack",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```Java []\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    List<Integer> list = new ArrayList<Integer>();\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        if(root == null){\\n            return list;\\n        }\\n        list.add(root.val);\\n        preorderTraversal(root.left);\\n        preorderTraversal(root.right);\\n        return list;\\n    }\\n}\\n```\n```javascript []\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\n\\nvar preorderTraversal = function(root, list = []) {\\n    if(!root){\\n        return [];\\n    }\\n    list.push(root.val);\\n    if (root.left !== null) preorderTraversal(root.left, list);\\n    if (root.right !== null) preorderTraversal(root.right, list);\\n    return list;\\n};\\n```\n```Java []\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    \\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<Integer>();\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        if(root == null){\\n            return list;\\n        }\\n        stack.push(root);\\n        \\n        while(!stack.isEmpty()){\\n            TreeNode curr = stack.pop();\\n            list.add(curr.val);\\n            if(curr.right != null){\\n                stack.push(curr.right);\\n            }\\n            if(curr.left != null){\\n                stack.push(curr.left);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```\n```javascript []\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\n\\nvar preorderTraversal = function(root) {\\n    if(!root) return [];\\n    let stack = [];\\n    let list = [];\\n    stack.push(root);\\n    while(stack.length){\\n        let node = stack.pop();\\n        list.push(node.val);\\n        if(node.right) stack.push(node.right);\\n        if(node.left) stack.push(node.left);\\n    }\\n    return list;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022722,
                "title": "a-classic-approach-to-preorder-tree-traversal-a-recursive-solution-beats-100-time-c",
                "content": "The PreorderTraversal function is the public interface for the algorithm, and it accepts the root node of a binary tree as an argument. It creates an empty list to store the result of the traversal, and then calls the PreorderTraversalRecursive function on the root node to perform the actual traversal.\\n\\nThe PreorderTraversalRecursive function has the following steps:\\n\\nIf the node is null, it returns immediately.\\nIt adds the value of the node (node.val) to the list.\\nIt calls itself recursively on the left child of the node (node.left).\\nIt calls itself recursively on the right child of the node (node.right).\\nThis way, the function traverses the tree in a depth-first fashion, visiting the root node first, then the left subtree, and finally the right subtree.\\n\\nWhen the traversal is complete, the PreorderTraversal function returns the list containing the values of the nodes in the order they were visited.\\n\\n# Approach\\nDFS\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public IList<int> PreorderTraversal(TreeNode root)\\n    {\\n        var list = new List<int>();\\n        PreorderTraversalRecursive(root, list);\\n        return list;\\n    }\\n\\n    private void PreorderTraversalRecursive(TreeNode node, List<int> list)\\n    {\\n        if (node == null) return;\\n        list.Add(node.val);\\n        PreorderTraversalRecursive(node.left, list);\\n        PreorderTraversalRecursive(node.right, list);\\n    }\\n}\\n```\\n\\nIf you found my solution helpful, please consider upvoting it to let others know!",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public IList<int> PreorderTraversal(TreeNode root)\\n    {\\n        var list = new List<int>();\\n        PreorderTraversalRecursive(root, list);\\n        return list;\\n    }\\n\\n    private void PreorderTraversalRecursive(TreeNode node, List<int> list)\\n    {\\n        if (node == null) return;\\n        list.Add(node.val);\\n        PreorderTraversalRecursive(node.left, list);\\n        PreorderTraversalRecursive(node.right, list);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022068,
                "title": "java-o-n-0-ms",
                "content": "# Intuition\\n    step 1---> add the root element in list\\n    step 2--->add the left element in list\\n    step 3--->add the right element in list\\n\\n# Approach\\n    Using Recursion\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> list =new ArrayList<>();\\n        if(root!=null){\\n        //root-->left-->right====>pre-order traversal\\n        list.add(root.val);\\n        list.addAll(preorderTraversal(root.left));\\n        list.addAll(preorderTraversal(root.right));\\n        return list;\\n        }\\n    //   If the Root is NULL ,then return the list\\n        return list;\\n        \\n    }\\n}\\n```\\n![upvote.jpeg](https://assets.leetcode.com/users/images/27555805-c730-4eb8-9b0c-9ebda36f3080_1673225293.3940446.jpeg)\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> list =new ArrayList<>();\\n        if(root!=null){\\n        //root-->left-->right====>pre-order traversal\\n        list.add(root.val);\\n        list.addAll(preorderTraversal(root.left));\\n        list.addAll(preorderTraversal(root.right));\\n        return list;\\n        }\\n    //   If the Root is NULL ,then return the list\\n        return list;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3021971,
                "title": "most-easy-short-and-clean-code-in-java-dfs-iterative",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs the definition of PreOrder Traversal is add->left->right\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst add data of the node to list then go to left and then go to right\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    ArrayList<Integer> list = new ArrayList<>();\\n\\n    public void preTree(TreeNode root){\\n        if(root == null) return;\\n\\n        list.add(root.val);\\n        preTree(root.left);\\n        preTree(root.right);\\n    }\\n\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        preTree(root);\\n        return list;\\n    }\\n}\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    ArrayList<Integer> list = new ArrayList<>();\\n\\n    public void preTree(TreeNode root){\\n        if(root == null) return;\\n\\n        list.add(root.val);\\n        preTree(root.left);\\n        preTree(root.right);\\n    }\\n\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        preTree(root);\\n        return list;\\n    }\\n}\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3021955,
                "title": "daily-leetcoding-challenge-january-day-9",
                "content": "This problem is the Daily LeetCoding Challenge for January, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-tree-preorder-traversal/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-tree-preorder-traversal/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2765272,
                "title": "preorder",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> a;\\n    void preorder(TreeNode* root)\\n    {\\n        if(root)\\n        {\\n            a.push_back(root->val);\\n            preorder(root->left);\\n            preorder(root->right);\\n        }\\n    }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        preorder(root);\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> a;\\n    void preorder(TreeNode* root)\\n    {\\n        if(root)\\n        {\\n            a.push_back(root->val);\\n            preorder(root->left);\\n            preorder(root->right);\\n        }\\n    }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        preorder(root);\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2575711,
                "title": "preorder-with-recursion-small-code",
                "content": "\\n```\\ntype Res struct {\\n\\tRes []int\\n}\\n\\nfunc preorderTraversal(root *tree.TreeNode) []int {\\n\\tr := Res{}\\n\\tr.traversal(root)\\n\\treturn r.Res\\n}\\n\\nfunc (r *Res) traversal(node *tree.TreeNode) {\\n\\tif node != nil {\\n\\t\\tr.Res = append(r.Res, node.Val)\\n\\t\\tr.traversal(node.Left)\\n\\t\\tr.traversal(node.Right)\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Tree"
                ],
                "code": "```\\ntype Res struct {\\n\\tRes []int\\n}\\n\\nfunc preorderTraversal(root *tree.TreeNode) []int {\\n\\tr := Res{}\\n\\tr.traversal(root)\\n\\treturn r.Res\\n}\\n\\nfunc (r *Res) traversal(node *tree.TreeNode) {\\n\\tif node != nil {\\n\\t\\tr.Res = append(r.Res, node.Val)\\n\\t\\tr.traversal(node.Left)\\n\\t\\tr.traversal(node.Right)\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1765397,
                "title": "python3-fastest-solution-recursion-one-liner",
                "content": "```\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if root is None:\\n            return []\\n        return [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if root is None:\\n            return []\\n        return [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1694797,
                "title": "c-using-recursive-approach",
                "content": "```\\nvoid helper(TreeNode* root,vector<int> &vec){\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        vec.push_back(root->val);\\n        helper(root->left,vec);\\n        helper(root->right,vec);\\n        }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> vec;\\n        helper(root,vec);\\n        return vec;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nvoid helper(TreeNode* root,vector<int> &vec){\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        vec.push_back(root->val);\\n        helper(root->left,vec);\\n        helper(root->right,vec);\\n        }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> vec;\\n        helper(root,vec);\\n        return vec;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1688224,
                "title": "python3-explanation-with-both-recursive-and-iterative-solution",
                "content": "My template for solving the problem:\\n* Clarify requirements\\n* Propose testcases\\n* Define function signature\\n* Coding\\n* Work through testcases\\n* Time and Space Complexity\\n<hr>\\n\\n**video explanation**: \\n<hr>\\n\\n**Prior Knowledge before working on this problem**\\n* Preorder Traversal: Node, traverse the Left subtree, then traverse the right subtree\\n```\\n\\t\\t 4\\n\\t3        5\\n1      2   6\\n```\\nThe preorder traversal for the above tree is 431256\\n\\n**1. Clarify requirements**\\n* \\tIt\\'s a binary tree\\n* \\tWe need to do a preorder traversal and return their values\\n\\n**2. Propose testcases**\\n```\\n1. Empty Tree\\n2. Two nodes, the right child is nil\\n    Node(3)\\nNode(2)\\n3.  Two nodes, the left child is nil\\n    Node(3)\\n\\t\\tNode(5)\\n```\\n**3. Define function signature**\\n* input: TreeNode\\n* return: List[int]\\n\\n**4. Coding**\\nWe have two ways to solve this problem. We can approach by recursion first since that\\'s the most intuitive way.\\n\\n```\\nrecursion\\nclass Solution:\\n    def preorderTraversal(self, root: TreeNode) -> List[int]:\\n        if not root:\\n            return []\\n\\n        ret = []\\n        def dfs(node):\\n            if not node:\\n                return\\n            ret.append(node.val)\\n            dfs(node.left)\\n            dfs(node.right)\\n        dfs(root)\\n        return ret\\n\\nExplanation: In the dfs function, If node is not null, we store its value and visit its left side, and then its right side.\\n\\nOptimize:\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root: return []\\n        return [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right)\\n\\n\\nWe can also implement it iteratively.\\nclass Solution:\\n    def preorderTraversal(self, root: TreeNode) -> List[int]:\\n        if not root:\\n            return []\\n\\n        stack, ret = [root], []\\n        while stack:\\n            node = stack.pop()\\n            ret.append(node.val)\\n            if node.right: \\n                stack.append(node.right)\\n            if node.left: \\n                stack.append(node.left)\\n        return ret\\n\\nExplanation: \\nNotice that the order is Node, Left, Right. We can use a stack to store the node\\'s right child first and then store the nodes\\' left child. If the node has a left child, we can get that by stack.pop()\\nThis runs fast than the recursive approach\\n```\\n\\n**5. Work through testcases**\\nGo through the proposed testcases and check the code line by line to make sure it runs expectedly.\\n\\n**6. Time and Space Complexity**\\nAverage Time: O(n), where n is the number of nodes\\nSpace: O(1), constant space\\n\\n**Please upvote if this is helpful to you. Your upvote will motivate me to write more content.**",
                "solutionTags": [
                    "Python3",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n\\t\\t 4\\n\\t3        5\\n1      2   6\\n```\n```\\n1. Empty Tree\\n2. Two nodes, the right child is nil\\n    Node(3)\\nNode(2)\\n3.  Two nodes, the left child is nil\\n    Node(3)\\n\\t\\tNode(5)\\n```\n```\\nrecursion\\nclass Solution:\\n    def preorderTraversal(self, root: TreeNode) -> List[int]:\\n        if not root:\\n            return []\\n\\n        ret = []\\n        def dfs(node):\\n            if not node:\\n                return\\n            ret.append(node.val)\\n            dfs(node.left)\\n            dfs(node.right)\\n        dfs(root)\\n        return ret\\n\\nExplanation: In the dfs function, If node is not null, we store its value and visit its left side, and then its right side.\\n\\nOptimize:\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root: return []\\n        return [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right)\\n\\n\\nWe can also implement it iteratively.\\nclass Solution:\\n    def preorderTraversal(self, root: TreeNode) -> List[int]:\\n        if not root:\\n            return []\\n\\n        stack, ret = [root], []\\n        while stack:\\n            node = stack.pop()\\n            ret.append(node.val)\\n            if node.right: \\n                stack.append(node.right)\\n            if node.left: \\n                stack.append(node.left)\\n        return ret\\n\\nExplanation: \\nNotice that the order is Node, Left, Right. We can use a stack to store the node\\'s right child first and then store the nodes\\' left child. If the node has a left child, we can get that by stack.pop()\\nThis runs fast than the recursive approach\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1670795,
                "title": "javascript-solutions",
                "content": "**1. Recursive solution.**\\n\\nRuntime: 72 ms, faster than 74.34% of JavaScript online submissions for Binary Tree Preorder Traversal.\\nMemory Usage: 38.8 MB, less than 80.63% of JavaScript online submissions for Binary Tree Preorder Traversal.\\n\\n```\\nvar preorderTraversal = function(root) {\\n    let output = [];\\n    function foo (node) {\\n        if(!node) return;\\n        output.push(node.val);\\n        foo(node.left);\\n        foo(node.right);\\n    }\\n    foo(root);\\n    return output;\\n};\\n```\\n\\n**2. Iterative Solution.**\\n\\nRuntime: 72 ms, faster than 74.34% of JavaScript online submissions for Binary Tree Preorder Traversal.\\nMemory Usage: 38.9 MB, less than 69.88% of JavaScript online submissions for Binary Tree Preorder Traversal.\\n\\n```\\nvar preorderTraversal = function(node) {\\n    let stack = [];\\n    let output = [];\\n    while (stack.length || node !== null) {\\n        if (node !== null) {\\n            output.push(node.val);\\n            stack.push(node);\\n            node = node.left;\\n        } else {\\n            node = stack.pop().right;\\n        }\\n        \\n    }\\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```\\nvar preorderTraversal = function(root) {\\n    let output = [];\\n    function foo (node) {\\n        if(!node) return;\\n        output.push(node.val);\\n        foo(node.left);\\n        foo(node.right);\\n    }\\n    foo(root);\\n    return output;\\n};\\n```\n```\\nvar preorderTraversal = function(node) {\\n    let stack = [];\\n    let output = [];\\n    while (stack.length || node !== null) {\\n        if (node !== null) {\\n            output.push(node.val);\\n            stack.push(node);\\n            node = node.left;\\n        } else {\\n            node = stack.pop().right;\\n        }\\n        \\n    }\\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1514657,
                "title": "java-easy-non-recursive-stack-based",
                "content": "```\\npublic class Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        if(root==null)\\n            return res;\\n        Stack<TreeNode> st = new Stack <>();\\n        st.push(root);\\n        while(!st.isEmpty())\\n        {\\n            TreeNode top = st.pop();\\n            res.add(top.val);\\n            if(top.right!=null)\\n                st.push(top.right);\\n            if(top.left!=null)\\n                st.push(top.left);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        if(root==null)\\n            return res;\\n        Stack<TreeNode> st = new Stack <>();\\n        st.push(root);\\n        while(!st.isEmpty())\\n        {\\n            TreeNode top = st.pop();\\n            res.add(top.val);\\n            if(top.right!=null)\\n                st.push(top.right);\\n            if(top.left!=null)\\n                st.push(top.left);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1380065,
                "title": "c-easy-and-efficient-recursion",
                "content": "**If you liked this solution, Please Upvote. Thanks**\\n\\n```\\n\\tvoid preorder(TreeNode *root,vector<int>&vec)\\n    {\\n        if(!root) return;\\n        vec.push_back(root->val);\\n        preorder(root->left,vec);\\n        preorder(root->right,vec);\\n    }\\n    \\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int>vec;\\n        preorder(root,vec);\\n        return vec;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tvoid preorder(TreeNode *root,vector<int>&vec)\\n    {\\n        if(!root) return;\\n        vec.push_back(root->val);\\n        preorder(root->left,vec);\\n        preorder(root->right,vec);\\n    }\\n    \\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int>vec;\\n        preorder(root,vec);\\n        return vec;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1020137,
                "title": "recursive-faster-than-100-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> vec;\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        if(root==nullptr) return {};\\n        vec.push_back(root->val);\\n        preorderTraversal(root->left);\\n        preorderTraversal(root->right);\\n        return vec;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> vec;\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        if(root==nullptr) return {};\\n        vec.push_back(root->val);\\n        preorderTraversal(root->left);\\n        preorderTraversal(root->right);\\n        return vec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 897240,
                "title": "c-solution",
                "content": "void travel(struct TreeNode *root,int *arr,int *size){\\n    if(root==NULL)\\n        return;\\n    arr[(*size)++]=root->val;\\n    travel(root->left,arr,size);\\n    travel(root->right,arr,size);\\n}\\nint* preorderTraversal(struct TreeNode* root, int* returnSize){\\n    *returnSize=0;\\n    int *arr=(int *)malloc(100*sizeof(int));\\n    travel(root,arr,returnSize);\\n    return arr;\\n}",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "void travel(struct TreeNode *root,int *arr,int *size){\\n    if(root==NULL)\\n        return;\\n    arr[(*size)++]=root->val;\\n    travel(root->left,arr,size);\\n    travel(root->right,arr,size);\\n}\\nint* preorderTraversal(struct TreeNode* root, int* returnSize){\\n    *returnSize=0;\\n    int *arr=(int *)malloc(100*sizeof(int));\\n    travel(root,arr,returnSize);\\n    return arr;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 775203,
                "title": "javascript-clean-3-liner",
                "content": "```javascript\\nvar preorderTraversal = function(root) {\\n  \\n    function traverse(node) {\\n        if(!node) return [];\\n        return [node.val, ...traverse(node.left), ...traverse(node.right)];\\n    }\\n    return traverse(root);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar preorderTraversal = function(root) {\\n  \\n    function traverse(node) {\\n        if(!node) return [];\\n        return [node.val, ...traverse(node.left), ...traverse(node.right)];\\n    }\\n    return traverse(root);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 646180,
                "title": "python-iterative-and-recursive",
                "content": "Method 1: Iterative \\n\\n```\\nclass Solution:\\n    def preorderTraversal(self, root: TreeNode) -> List[int]:\\n        result, stack = [], []\\n        while stack or root:\\n            if root:\\n                stack.append(root)\\n                result.append(root.val)\\n                root = root.left\\n            else:\\n                node = stack.pop()\\n                root = node.right\\n        return result\\n\\n```\\n\\nMethod 2: Recursive (Trivial, not desired in the question guidelines) \\n\\n```\\nclass Solution:\\n    def preorderTraversal(self, root: TreeNode) -> List[int]:      \\n        output = []\\n        self._helper(root, output)\\n        return output\\n    \\n    def _helper(self, root, output):\\n        if root is None: return \\n        output.append(root.val)\\n        self._helper(root.left, output)\\n        self._helper(root.right, output)\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def preorderTraversal(self, root: TreeNode) -> List[int]:\\n        result, stack = [], []\\n        while stack or root:\\n            if root:\\n                stack.append(root)\\n                result.append(root.val)\\n                root = root.left\\n            else:\\n                node = stack.pop()\\n                root = node.right\\n        return result\\n\\n```\n```\\nclass Solution:\\n    def preorderTraversal(self, root: TreeNode) -> List[int]:      \\n        output = []\\n        self._helper(root, output)\\n        return output\\n    \\n    def _helper(self, root, output):\\n        if root is None: return \\n        output.append(root.val)\\n        self._helper(root.left, output)\\n        self._helper(root.right, output)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 406827,
                "title": "c-clean-and-easy-to-read",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Binary Tree Preorder Traversal.\\nMemory Usage: 9.1 MB, less than 100.00% of C++ online submissions for Binary Tree Preorder Traversal.\\n```\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> res;\\n        if(!root) return res;\\n        stack<TreeNode*> stack;\\n        stack.push(root);\\n        while(!stack.empty()){\\n            TreeNode* temp=stack.top();\\n            res.push_back(temp->val);\\n            stack.pop();\\n            if(temp->right) stack.push(temp->right);\\n            if(temp->left) stack.push(temp->left);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> res;\\n        if(!root) return res;\\n        stack<TreeNode*> stack;\\n        stack.push(root);\\n        while(!stack.empty()){\\n            TreeNode* temp=stack.top();\\n            res.push_back(temp->val);\\n            stack.pop();\\n            if(temp->right) stack.push(temp->right);\\n            if(temp->left) stack.push(temp->left);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 359086,
                "title": "javascript-iterative-stack",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar preorderTraversal = function(root) {\\n    let res = [];\\n    let stack = [];\\n    let cur = root;\\n    while(cur || stack.length) {\\n        while(cur) {\\n            res.push(cur.val);\\n            stack.push(cur);\\n            cur = cur.left;\\n        }\\n        cur = stack.pop();\\n        cur = cur.right;\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar preorderTraversal = function(root) {\\n    let res = [];\\n    let stack = [];\\n    let cur = root;\\n    while(cur || stack.length) {\\n        while(cur) {\\n            res.push(cur.val);\\n            stack.push(cur);\\n            cur = cur.left;\\n        }\\n        cur = stack.pop();\\n        cur = cur.right;\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 326245,
                "title": "help-python-3-attributeerror-nonetype-object-has-no-attribute-right",
                "content": "Although I am checking for the stack length in the while condition, I do not understand why this error appears\\nLine 13: AttributeError: \\'NoneType\\' object has no attribute \\'right\\'\\n\\n```\\n\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def preorderTraversal(self, root: TreeNode) -> List[int]:\\n        stack,res = [root],[]\\n        while len(stack)>0:\\n            node = stack.pop()\\n            if node.right:\\n                stack.append(node.right)\\n            if node.left:\\n                stack.append(node.left)\\n            res.append(node.val)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def preorderTraversal(self, root: TreeNode) -> List[int]:\\n        stack,res = [root],[]\\n        while len(stack)>0:\\n            node = stack.pop()\\n            if node.right:\\n                stack.append(node.right)\\n            if node.left:\\n                stack.append(node.left)\\n            res.append(node.val)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 274116,
                "title": "go-solution",
                "content": "```\\nfunc preorderTraversal(root *TreeNode) []int {\\n    if root == nil {\\n        return nil\\n    }\\n\\n    var ret []int\\n    p := root\\n    stack := make([]*TreeNode, 0)\\n    stack = append(stack, p)\\n\\n    for len(stack) != 0 {\\n        visit := stack[len(stack)-1]\\n        stack = stack[:len(stack)-1]\\n        \\n        ret = append(ret, visit.Val)\\n        \\n        if visit.Right != nil {\\n            stack = append(stack, visit.Right)\\n        }\\n        if visit.Left != nil {\\n            stack = append(stack, visit.Left)\\n        }\\n    }\\n    return ret\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc preorderTraversal(root *TreeNode) []int {\\n    if root == nil {\\n        return nil\\n    }\\n\\n    var ret []int\\n    p := root\\n    stack := make([]*TreeNode, 0)\\n    stack = append(stack, p)\\n\\n    for len(stack) != 0 {\\n        visit := stack[len(stack)-1]\\n        stack = stack[:len(stack)-1]\\n        \\n        ret = append(ret, visit.Val)\\n        \\n        if visit.Right != nil {\\n            stack = append(stack, visit.Right)\\n        }\\n        if visit.Left != nil {\\n            stack = append(stack, visit.Left)\\n        }\\n    }\\n    return ret\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 257252,
                "title": "javascript-iterative-recursive-solutions",
                "content": "**RECURSIVE:**\\n```\\nvar preorderTraversal = function(root) {\\n    \\n    let result = [];\\n    \\n    function pot(node) {\\n        if(node) {\\n            result.push(node.val);\\n            if(node.left) {\\n                pot(node.left);\\n            }\\n            if(node.right) {\\n                pot(node.right);\\n            }\\n        } else {\\n            return;\\n        }\\n    }\\n    \\n    pot(root);\\n    return result;\\n};\\n```\\n\\n**ITERATIVE - USE STACK**\\n```\\nvar preorderTraversal = function(root) {\\n    let result = [];\\n    let stack = [];\\n    if(root) {\\n        stack.push(root);\\n        while(stack.length > 0) {\\n            let node = stack.pop();\\n            result.push(node.val);\\n            if(node.right) {\\n                stack.push(node.right);\\n            }\\n            if(node.left) {\\n                stack.push(node.left);\\n            }\\n        }\\n    }\\n    return result;\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nvar preorderTraversal = function(root) {\\n    \\n    let result = [];\\n    \\n    function pot(node) {\\n        if(node) {\\n            result.push(node.val);\\n            if(node.left) {\\n                pot(node.left);\\n            }\\n            if(node.right) {\\n                pot(node.right);\\n            }\\n        } else {\\n            return;\\n        }\\n    }\\n    \\n    pot(root);\\n    return result;\\n};\\n```\n```\\nvar preorderTraversal = function(root) {\\n    let result = [];\\n    let stack = [];\\n    if(root) {\\n        stack.push(root);\\n        while(stack.length > 0) {\\n            let node = stack.pop();\\n            result.push(node.val);\\n            if(node.right) {\\n                stack.push(node.right);\\n            }\\n            if(node.left) {\\n                stack.push(node.left);\\n            }\\n        }\\n    }\\n    return result;\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 45258,
                "title": "1-line-python",
                "content": "```\\nclass Solution(object):\\n    def preorderTraversal(self, root):\\n        return [] if not root else [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def preorderTraversal(self, root):\\n        return [] if not root else [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 45444,
                "title": "java-solution-both-recursion-and-iteration",
                "content": "    public List<Integer> preorderTraversal(TreeNode root) {\\n        // root --> left --> right\\n        // recursion method\\n        List<Integer> res = new ArrayList<>();\\n        if (root == null) return res;\\n        res.add(root.val);\\n        if (root.left != null) \\n            for (int left : preorderTraversal(root.left)) res.add(left);\\n        if (root.right != null) \\n            for (int right : preorderTraversal(root.right)) res.add(right);\\n        return res;\\n    }\\n\\n\\n----------\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        // root --> left --> right\\n        // iteration method\\n        List<Integer> res = new ArrayList<>();\\n        Stack<TreeNode> stack = new Stack<>();\\n        if (root == null) return res;\\n        stack.push(root);\\n        while (!stack.isEmpty()) {\\n            TreeNode temp = stack.pop();\\n            if (temp != null) {\\n                res.add(temp.val);\\n                stack.push(temp.right);\\n                stack.push(temp.left);\\n            }\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public List<Integer> preorderTraversal(TreeNode root) {\\n        // root --> left --> right\\n        // recursion method\\n        List<Integer> res = new ArrayList<>();\\n        if (root == null) return res;\\n        res.add(root.val);\\n        if (root.left != null) \\n            for (int left : preorderTraversal(root.left)) res.add(left);\\n        if (root.right != null) \\n            for (int right : preorderTraversal(root.right)) res.add(right);\\n        return res;\\n    }\\n\\n\\n----------\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        // root --> left --> right\\n        // iteration method\\n        List<Integer> res = new ArrayList<>();\\n        Stack<TreeNode> stack = new Stack<>();\\n        if (root == null) return res;\\n        stack.push(root);\\n        while (!stack.isEmpty()) {\\n            TreeNode temp = stack.pop();\\n            if (temp != null) {\\n                res.add(temp.val);\\n                stack.push(temp.right);\\n                stack.push(temp.left);\\n            }\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 45484,
                "title": "what-s-the-simplest-and-cleanest-answer",
                "content": "Here's the answer I got. I was wondering if someone came up with something simpler and cleaner.\\n\\n    class Solution {\\n    public:\\n        vector<int> order;\\n        vector<int> preorderTraversal(TreeNode *root) {\\n            addNextNode(root);\\n            return order;\\n        }\\n        void addNextNode(TreeNode* node) {\\n            if (node) {\\n                order.push_back(node->val);\\n                addNextNode(node->left);\\n                addNextNode(node->right);\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> order;\\n        vector<int> preorderTraversal(TreeNode *root) {\\n            addNextNode(root);\\n            return order;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4052573,
                "title": "simplest-solution-beginner-friendly-waiting-for-you",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n```PreOrder -> Printing root val and Calling left subtree then right subtree```\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n*Step-1 -> Declare a ```list``` outside method bcoz we are using recursion\\nStep-2 -> ```Loop until root becomes null ```\\nStep-3 -> ```Add root val to list```\\nStep-4 -> ```Recursively Call for left subtree```\\nStep-5 -> ```Recursively Call for right subtree```\\nStep-6 -> Job is done Just return ```list``` in the end*\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    List<Integer> list = new ArrayList();\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        if(root != null){\\n            list.add(root.val);\\n            preorderTraversal(root.left);\\n            preorderTraversal(root.right);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```PreOrder -> Printing root val and Calling left subtree then right subtree```\n```list```\n```Loop until root becomes null ```\n```Add root val to list```\n```Recursively Call for left subtree```\n```Recursively Call for right subtree```\n```list```\n```\\nclass Solution {\\n    List<Integer> list = new ArrayList();\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        if(root != null){\\n            list.add(root.val);\\n            preorderTraversal(root.left);\\n            preorderTraversal(root.right);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929505,
                "title": "3-easy-c-solutions-dfs-bfs-and-morris-traversal-beats-100",
                "content": "# Code\\n```\\n// Recursive approach\\nclass Solution {\\npublic:\\n    void preorder(TreeNode* root, vector<int> &ans){\\n        //base case\\n        if(root == NULL)\\n            return;\\n\\n        ans.push_back(root->val);\\n        preorder(root->left, ans);\\n        preorder(root->right, ans);\\n    }\\n\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        preorder(root, ans);\\n        return ans;\\n    }\\n};\\n\\n// Iterative approach\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        if(root == NULL)        return ans;\\n\\n        stack<TreeNode*> s;\\n        s.push(root);\\n\\n        while(!s.empty()){\\n            TreeNode *temp = s.top();\\n            s.pop();\\n            ans.push_back(temp->val);\\n\\n            if(temp->right != NULL)\\n                s.push(temp->right);\\n            if(temp->left != NULL)\\n                s.push(temp->left);\\n        }\\n        return ans;\\n    }\\n};\\n\\n// Morris traversal - Space O(1)\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> ans ;\\n        TreeNode *curr = root, *pre;\\n\\n        while(curr != NULL){\\n            if(curr->left == NULL){\\n                ans.push_back(curr->val);\\n                curr = curr->right;\\n            }\\n            else{\\n                pre = curr->left;\\n                while(pre->right != NULL && pre->right != curr)\\n                    pre = pre->right;\\n                \\n                if(pre->right == NULL){\\n                    ans.push_back(curr->val);\\n                    pre->right = curr;\\n                    curr = curr->left;\\n                }\\n                else{\\n                    pre->right = NULL;\\n                    curr = curr->right;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n// Recursive approach\\nclass Solution {\\npublic:\\n    void preorder(TreeNode* root, vector<int> &ans){\\n        //base case\\n        if(root == NULL)\\n            return;\\n\\n        ans.push_back(root->val);\\n        preorder(root->left, ans);\\n        preorder(root->right, ans);\\n    }\\n\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        preorder(root, ans);\\n        return ans;\\n    }\\n};\\n\\n// Iterative approach\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        if(root == NULL)        return ans;\\n\\n        stack<TreeNode*> s;\\n        s.push(root);\\n\\n        while(!s.empty()){\\n            TreeNode *temp = s.top();\\n            s.pop();\\n            ans.push_back(temp->val);\\n\\n            if(temp->right != NULL)\\n                s.push(temp->right);\\n            if(temp->left != NULL)\\n                s.push(temp->left);\\n        }\\n        return ans;\\n    }\\n};\\n\\n// Morris traversal - Space O(1)\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> ans ;\\n        TreeNode *curr = root, *pre;\\n\\n        while(curr != NULL){\\n            if(curr->left == NULL){\\n                ans.push_back(curr->val);\\n                curr = curr->right;\\n            }\\n            else{\\n                pre = curr->left;\\n                while(pre->right != NULL && pre->right != curr)\\n                    pre = pre->right;\\n                \\n                if(pre->right == NULL){\\n                    ans.push_back(curr->val);\\n                    pre->right = curr;\\n                    curr = curr->left;\\n                }\\n                else{\\n                    pre->right = NULL;\\n                    curr = curr->right;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3875596,
                "title": "recursive-iteration-o-n-approach-for-beginners-easy",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void preorder(TreeNode *root,vector<int>& ans) {\\n        if(!root)return ;\\n        ans.push_back(root->val);\\n        preorder(root->left,ans);\\n        preorder(root->right,ans);\\n    }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        //preorder(root,ans); to do recursively\\n        stack<TreeNode *>st;\\n        while(true){\\n            while(root){\\n                ans.push_back(root->val);\\n                if(root->right)st.push(root->right);\\n                root=root->left;\\n            }\\n            if(st.empty())break;\\n            root=st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void preorder(TreeNode *root,vector<int>& ans) {\\n        if(!root)return ;\\n        ans.push_back(root->val);\\n        preorder(root->left,ans);\\n        preorder(root->right,ans);\\n    }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        //preorder(root,ans); to do recursively\\n        stack<TreeNode *>st;\\n        while(true){\\n            while(root){\\n                ans.push_back(root->val);\\n                if(root->right)st.push(root->right);\\n                root=root->left;\\n            }\\n            if(st.empty())break;\\n            root=st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3806147,
                "title": "crack-the-code",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nvoid preorder(TreeNode* root,vector<int> &ans){\\n         if(root==NULL)return;\\n         ans.push_back(root->val);\\n         preorder(root->left,ans);\\n         preorder(root->right,ans);\\n}\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        preorder(root,ans);\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n\\n# Intuition:\\nThe goal is to perform a preorder traversal on a binary tree, which means visiting the nodes in the order: root, left, right. To achieve this, we can use a recursive approach. We start at the root node and perform the following steps:\\n\\nVisit the current node and store its value in a vector called \"ans.\"\\nRecursively traverse the left subtree.\\nRecursively traverse the right subtree.\\n# Algorithm:\\n\\nDefine a helper function called preorder that takes the current node and a reference to a vector called \"ans\" as input.\\nInside the preorder function:\\nIf the current node is NULL (base case), return from the function.\\nOtherwise, add the value of the current node to the \"ans\" vector.\\nRecursively call the preorder function for the left child of the current node.\\nRecursively call the preorder function for the right child of the current node.\\nInitialize an empty vector called \"ans\" to store the preorder traversal result.\\nCall the preorder function with the root node and the \"ans\" vector as arguments.\\nReturn the \"ans\" vector, which now contains the preorder traversal of the binary tree.\\n# Complexity Analysis:\\n\\n# Time Complexity:\\n The time complexity of the preorder traversal using recursion is O(N), where \"N\" is the number of nodes in the binary tree. This is because we visit each node exactly once during the traversal.\\n# Space Complexity:\\n The space complexity is O(H), where \"H\" is the height of the binary tree. In the worst case, the height of the binary tree can be N (when the tree is skewed), so the space complexity is O(N). This is because the maximum number of function calls stored in the call stack at any point is equal to the height of the binary tree. The space used by the \"ans\" vector is also considered, but it is not dominating compared to the space used by the call stack. Therefore, the overall space complexity is O(N).\\n\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nvoid preorder(TreeNode* root,vector<int> &ans){\\n         if(root==NULL)return;\\n         ans.push_back(root->val);\\n         preorder(root->left,ans);\\n         preorder(root->right,ans);\\n}\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        preorder(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3723664,
                "title": "recursive-and-iterative-approach-please-upvote-me-it-would-encourage-me-alot",
                "content": "# 1. Recursive Approach\\n```\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        list1=[]\\n        def preorder(root,list1):\\n            if not root:\\n                return \\n            list1.append(root.val)\\n            preorder(root.left,list1)\\n            preorder(root.right,list1)\\n        preorder(root,list1)\\n        return list1\\n```\\n# 2. Iterative Approach\\n```\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root:\\n            return None\\n        stack,ans=[],[]\\n        stack.append(root)\\n        while stack:\\n            node=stack.pop()\\n            if node.right:\\n                stack.append(node.right)\\n            if node.left:\\n                stack.append(node.left)\\n            ans.append(node.val)\\n        return ans\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        list1=[]\\n        def preorder(root,list1):\\n            if not root:\\n                return \\n            list1.append(root.val)\\n            preorder(root.left,list1)\\n            preorder(root.right,list1)\\n        preorder(root,list1)\\n        return list1\\n```\n```\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root:\\n            return None\\n        stack,ans=[],[]\\n        stack.append(root)\\n        while stack:\\n            node=stack.pop()\\n            if node.right:\\n                stack.append(node.right)\\n            if node.left:\\n                stack.append(node.left)\\n            ans.append(node.val)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3678499,
                "title": "binary-tree-preorder-traversal-iterative-using-stack-beat-100-time-best-solution",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse stack ---push root first---loop while stacl is not empty--pop top-- push right child --- push left child--- insert value into vector--- return vector\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n          O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n          O(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int>ans;\\n        if(!root){    //if root is null\\n            return ans;\\n        }\\n        stack<TreeNode*>op;\\n        op.push(root);\\n        while(!op.empty()){\\n            TreeNode* top=op.top();\\n            op.pop();\\n            ans.push_back(top->val);\\n            if(top->right) op.push(top->right);\\n            if(top->left) op.push(top->left);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int>ans;\\n        if(!root){    //if root is null\\n            return ans;\\n        }\\n        stack<TreeNode*>op;\\n        op.push(root);\\n        while(!op.empty()){\\n            TreeNode* top=op.top();\\n            op.pop();\\n            ans.push_back(top->val);\\n            if(top->right) op.push(top->right);\\n            if(top->left) op.push(top->left);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3302205,
                "title": "easiest-solution-out-there-in-5-lines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nPlsssss Up vote -> \\uD83D\\uDE2D\\n# Code\\n```\\nclass Solution {\\n    List<Integer> list = new ArrayList<>();\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        if(root!=null){\\n            list.add(root.val);\\n            preorderTraversal(root.left);\\n            preorderTraversal(root.right);\\n        }\\n        return list;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    List<Integer> list = new ArrayList<>();\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        if(root!=null){\\n            list.add(root.val);\\n            preorderTraversal(root.left);\\n            preorderTraversal(root.right);\\n        }\\n        return list;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272343,
                "title": "python3-memory-efficient-32ms",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- visit root first.\\n- now visit left sub-tree.\\n- now visit right sub-tree.\\n- return ans\\n---\\n# Note\\n- used yield because it is memory efficient.\\n---\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        def preOrder(curr=root):\\n            if curr:\\n                yield curr.val\\n                for i in preOrder(curr.left):\\n                    yield i\\n                for j in preOrder(curr.right):\\n                    yield j\\n        preorder = preOrder()\\n        ans = []\\n        for i in preorder:\\n            ans.append(i)\\n        return ans\\n```\\n# Please like and comment below. :-)",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        def preOrder(curr=root):\\n            if curr:\\n                yield curr.val\\n                for i in preOrder(curr.left):\\n                    yield i\\n                for j in preOrder(curr.right):\\n                    yield j\\n        preorder = preOrder()\\n        ans = []\\n        for i in preorder:\\n            ans.append(i)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3264403,
                "title": "c-solution-using-recursion-run-time-0ms",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    void solve(TreeNode* root, vector<int>& ans) { // NLR\\n        if(root == NULL) {\\n            return;\\n        }\\n\\n        ans.push_back(root->val);\\n        solve(root->left, ans);\\n        solve(root->right, ans);\\n    }\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        solve(root, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    void solve(TreeNode* root, vector<int>& ans) { // NLR\\n        if(root == NULL) {\\n            return;\\n        }\\n\\n        ans.push_back(root->val);\\n        solve(root->left, ans);\\n        solve(root->right, ans);\\n    }\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        solve(root, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163085,
                "title": "simple-java-100-easy-comments-readable-beginners-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {    \\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> answer = new ArrayList<>();\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.add(root);\\n        \\n        // Note that we add currNode\\'s right child to the stack first.\\n        while (!stack.isEmpty()) {\\n            TreeNode currNode = stack.peek();\\n            stack.pop();\\n            if (currNode != null) {\\n                answer.add(currNode.val);\\n                stack.add(currNode.right);\\n                stack.add(currNode.left);\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {    \\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> answer = new ArrayList<>();\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.add(root);\\n        \\n        // Note that we add currNode\\'s right child to the stack first.\\n        while (!stack.isEmpty()) {\\n            TreeNode currNode = stack.peek();\\n            stack.pop();\\n            if (currNode != null) {\\n                answer.add(currNode.val);\\n                stack.add(currNode.right);\\n                stack.add(currNode.left);\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053471,
                "title": "c-short-simple-recursion",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<int> v;\\nvoid preorder(TreeNode* root){\\n    if(root==nullptr){return;}\\n        v.push_back(root->val);\\n        preorder(root->left);\\n        preorder(root->right);\\n    }\\n\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        preorder(root);\\n        return v;   \\n    }\\n};\\n```\\n**Please upvote if it helped. Happy Coding!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<int> v;\\nvoid preorder(TreeNode* root){\\n    if(root==nullptr){return;}\\n        v.push_back(root->val);\\n        preorder(root->left);\\n        preorder(root->right);\\n    }\\n\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        preorder(root);\\n        return v;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3025551,
                "title": "100-faster-easy-java-soln-with-explanation",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere we have taken the help of an helper function.\\nThe function first adds the value of the root node to the result list. It then recursively calls itself on the left and right subtrees, appending the results of these calls to the result list. If the root node is null, it simply returns.\\n\\n# Complexity\\n- Time complexity:\\n\\nThis implementation has a time complexity of O(n), where n is the number of nodes in the tree, because it visits each node exactly once\\n\\n- Space complexity:\\n\\nThe space complexity is also O(n), because at any given time there can be up to n function calls on the call stack.\\n\\nI hope this helps! Let me know if you have any questions.Please upvote!!!!!!!!!!!!!!!!!!!\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        helper(root,list);\\n        return list;\\n        \\n    }\\n    private static void helper(TreeNode root,List<Integer> list)\\n    {\\n        if(root==null)\\n        return;\\n        list.add(root.val);\\n        helper(root.left,list);\\n        helper(root.right,list);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        helper(root,list);\\n        return list;\\n        \\n    }\\n    private static void helper(TreeNode root,List<Integer> list)\\n    {\\n        if(root==null)\\n        return;\\n        list.add(root.val);\\n        helper(root.left,list);\\n        helper(root.right,list);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3025140,
                "title": "beats-100-easy-solution-c",
                "content": "\\n\\n\\n**- Time complexity:**\\n**O(n) \\nwhere, n = Number of Nodes**\\n\\n**- Space complexity:\\nO(h) \\nwhere, h = height of tree**\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void pre(TreeNode *root, vector<int>&v){\\n        if(root == NULL){\\n            return ;\\n        }\\n        else{\\n            v.push_back(root->val);\\n            pre(root->left,v);\\n            pre(root->right,v);\\n        }\\n    }\\n\\n\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n        pre(root,v);\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void pre(TreeNode *root, vector<int>&v){\\n        if(root == NULL){\\n            return ;\\n        }\\n        else{\\n            v.push_back(root->val);\\n            pre(root->left,v);\\n            pre(root->right,v);\\n        }\\n    }\\n\\n\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n        pre(root,v);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3023752,
                "title": "c-0ms-short-simple-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nApply recursion for complete traversal of tree.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n    void help(TreeNode* root, vector<int>&ans){\\n        if(!root) return;\\n        ans.push_back(root->val);\\n        help(root->left,ans);\\n        help(root->right,ans);\\n    }\\n\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int>ans;\\n        help(root,ans);\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\n    void help(TreeNode* root, vector<int>&ans){\\n        if(!root) return;\\n        ans.push_back(root->val);\\n        help(root->left,ans);\\n        help(root->right,ans);\\n    }\\n\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int>ans;\\n        help(root,ans);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3023679,
                "title": "python-beats-97-9",
                "content": "# Intuition\\nWhen it comes down to binary tries it\\'s usually about some kind of bfs or dfs. Here is an easy way to implement it.\\n\\n# Approach\\nIterate over given tree and collect all non `null` values. Using stack to iterate we end up with sorted array and we dont have to anything else.\\n\\n# Complexity\\n- Time complexity: O(n) Because we need to itaret over entire tree\\n\\n- Space complexity: O(n) Because we copy tree values 1:1 to result array.\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if root is None:\\n            return []\\n        \\n        preordered = []\\n        nodes = [root]\\n        \\n        while nodes:\\n            node = nodes[-1]\\n            del nodes [-1]\\n            \\n            if node.right is not None:\\n                nodes.append(node.right)\\n            \\n            if node.left is not None:\\n                nodes.append(node.left)\\n            \\n            preordered.append(node.val)\\n\\n        return preordered\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if root is None:\\n            return []\\n        \\n        preordered = []\\n        nodes = [root]\\n        \\n        while nodes:\\n            node = nodes[-1]\\n            del nodes [-1]\\n            \\n            if node.right is not None:\\n                nodes.append(node.right)\\n            \\n            if node.left is not None:\\n                nodes.append(node.left)\\n            \\n            preordered.append(node.val)\\n\\n        return preordered\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3023648,
                "title": "c-easy-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\nO[N]\\n\\n- Space complexity:\\nO[N]\\nAs Used vector\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void yo(TreeNode* root,vector<int>& A){\\n        if(root!=NULL){\\n            A.push_back(root->val);\\n            yo(root->left,A);\\n            yo(root->right,A);\\n        }\\n\\n    }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int>A;\\n        yo(root,A);\\n        return A;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void yo(TreeNode* root,vector<int>& A){\\n        if(root!=NULL){\\n            A.push_back(root->val);\\n            yo(root->left,A);\\n            yo(root->right,A);\\n        }\\n\\n    }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int>A;\\n        yo(root,A);\\n        return A;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3023506,
                "title": "java-solution-for-pre-order-binary-tree-beats-100-solution-in-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/14399fe7-0b15-4d89-801d-47d199f34e6a_1673248747.2783885.png)\\n# Approach\\n## **Recursive**\\n**Algorithm for Preorder(tree)**\\n\\n1. Visit the root.\\n2. Traverse the left subtree\\n3. Traverse the right subtree\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    public void traversal(TreeNode root, List<Integer> res) {\\n       \\n        // Return if the current node is null\\n        //base case\\n        if(root == null) return;\\n        \\n        // Add the current node\\'s value to the result list\\n        res.add(root.val);\\n        \\n        // Recursively traverse the left and right subtrees\\n        traversal(root.left, res);\\n        traversal(root.right, res);\\n   }\\n\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        // Creating a list to store the traversal result\\n        //Initialization\\n        List<Integer> res = new ArrayList<>();\\n        \\n        // To perform the traversal\\n        traversal(root, res);\\n        \\n        // Return the result\\n        return res;\\n   }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    public void traversal(TreeNode root, List<Integer> res) {\\n       \\n        // Return if the current node is null\\n        //base case\\n        if(root == null) return;\\n        \\n        // Add the current node\\'s value to the result list\\n        res.add(root.val);\\n        \\n        // Recursively traverse the left and right subtrees\\n        traversal(root.left, res);\\n        traversal(root.right, res);\\n   }\\n\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        // Creating a list to store the traversal result\\n        //Initialization\\n        List<Integer> res = new ArrayList<>();\\n        \\n        // To perform the traversal\\n        traversal(root, res);\\n        \\n        // Return the result\\n        return res;\\n   }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3023171,
                "title": "c-begineer-friendly-easy-understanding-2-methods-video-solution",
                "content": "# Intuition && Intution.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**C++ Clear Explaination ,Please support if you find it usefull. Can give me feedback in comment for improvement.,will be very thankfull.**\\nhttps://www.youtube.com/watch?v=NQjAvtyLFM0/\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n    O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n  O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n## Iterative \\n```\\nclass Solution {\\npublic:\\n vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int>preorder;\\n        stack<TreeNode*>st;\\n\\n        if(root == NULL){return preorder; }\\n\\n        st.push(root);\\n\\n\\n        while(!st.empty()){\\n            TreeNode* top = st.top();\\n            st.pop();\\n            preorder.push_back(top->val);\\n\\n            if(top->right!= NULL){\\n                st.push(top->right);\\n            }\\n            if(top->left!= NULL){\\n                st.push(top->left);\\n            }\\n        }\\n\\n        return preorder;\\n    }\\n};\\n```\\n\\n## Recursive\\n\\n```\\n  void preorderfun(vector<int>& preorder,TreeNode* root){\\n         if(root == NULL){return;}\\n        preorder.push_back(root->val);\\n        preorderfun(preorder,root->left);\\n        preorderfun(preorder,root->right);\\n     }\\n\\n    vector<int> preorderTraversal(TreeNode* root) {\\n         vector<int>preorder;\\n        preorderfun(preorder,root);\\n         return preorder;\\n}\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int>preorder;\\n        stack<TreeNode*>st;\\n\\n        if(root == NULL){return preorder; }\\n\\n        st.push(root);\\n\\n\\n        while(!st.empty()){\\n            TreeNode* top = st.top();\\n            st.pop();\\n            preorder.push_back(top->val);\\n\\n            if(top->right!= NULL){\\n                st.push(top->right);\\n            }\\n            if(top->left!= NULL){\\n                st.push(top->left);\\n            }\\n        }\\n\\n        return preorder;\\n    }\\n};\\n```\n```\\n  void preorderfun(vector<int>& preorder,TreeNode* root){\\n         if(root == NULL){return;}\\n        preorder.push_back(root->val);\\n        preorderfun(preorder,root->left);\\n        preorderfun(preorder,root->right);\\n     }\\n\\n    vector<int> preorderTraversal(TreeNode* root) {\\n         vector<int>preorder;\\n        preorderfun(preorder,root);\\n         return preorder;\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022989,
                "title": "c-solution-o-n-solution-with-explanation-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere we use the concept of recursion to solve this problem.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPreorder traversal is like **root, left, right**\\nSo, startimg from the root node, if root is not null we insert the value part of that node in the vector or array and then move to left substree, and after traversing the left subtree then we move to right subtree. \\nIf the value of any root is NULL then we simply return.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    // preorder --> root, left, right\\n    void preorder(TreeNode* root, vector<int> & v)\\n    {\\n        if (root == NULL)\\n        return;\\n        v.push_back(root->val);\\n        preorder(root->left,v);\\n        preorder(root->right,v);\\n    }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n        preorder(root, v);\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    // preorder --> root, left, right\\n    void preorder(TreeNode* root, vector<int> & v)\\n    {\\n        if (root == NULL)\\n        return;\\n        v.push_back(root->val);\\n        preorder(root->left,v);\\n        preorder(root->right,v);\\n    }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n        preorder(root, v);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022946,
                "title": "c-simplest-stack-and-recursive-method-easiest-and-cleanest-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPreorder Traversal of a binary tree, follows the order \\n```\\nTraverse:\\n1.(root)         //Current Root\\n2.(root->left)   //Current Root\\'s left\\n3.(root->right)  //Current Root\\'s right\\n```\\n# Method 1 : Using Recursion\\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;    //Answer vector\\n    void pre(TreeNode * root){\\n        if(root==NULL) return ;\\n        else {\\n            ans.push_back(root->val);   //Take current root value.\\n            pre(root->left);            //Traverse root\\'s Left\\n            pre(root->right);           //Traverse root\\'s Right\\n        }\\n    }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        pre(root);    //Passing root for computation of recursive fn\\n        return ans;   //Final ans\\n    }\\n    \\n};\\n```\\n```\\nTime Complexity - O(N) //Traversing all nodes\\nSpace Complexity- O(N) //Recursive Function calls\\n```\\n# Method 2 : Using Stack\\n```\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> pre;\\n        if(root==NULL) return pre;  //Empty Tree\\n        stack<TreeNode *> st;\\n        st.push(root);  //Push root\\n        while(!st.empty()){\\n            root=st.top();  //New root=Take the topmost node\\n            st.pop();       //Remove from stack\\n            pre.push_back(root->val);  //Push into ans vector\\n            if(root->right!=NULL) st.push(root->right);  //Goto Left \\n            if(root->left!=NULL ) st.push(root->left);   //Goto Right\\n        }\\n        return pre;\\n    }\\n};\\n```\\n```\\nTime Complexity - O(N) //Traversing all nodes\\nSpace Complexity- O(N) //Storing all nodes\\n```\\nPlease upvote if found useful \\uD83D\\uDE00\\uD83C\\uDF83\\uD83E\\uDD21",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nTraverse:\\n1.(root)         //Current Root\\n2.(root->left)   //Current Root\\'s left\\n3.(root->right)  //Current Root\\'s right\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;    //Answer vector\\n    void pre(TreeNode * root){\\n        if(root==NULL) return ;\\n        else {\\n            ans.push_back(root->val);   //Take current root value.\\n            pre(root->left);            //Traverse root\\'s Left\\n            pre(root->right);           //Traverse root\\'s Right\\n        }\\n    }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        pre(root);    //Passing root for computation of recursive fn\\n        return ans;   //Final ans\\n    }\\n    \\n};\\n```\n```\\nTime Complexity - O(N) //Traversing all nodes\\nSpace Complexity- O(N) //Recursive Function calls\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> pre;\\n        if(root==NULL) return pre;  //Empty Tree\\n        stack<TreeNode *> st;\\n        st.push(root);  //Push root\\n        while(!st.empty()){\\n            root=st.top();  //New root=Take the topmost node\\n            st.pop();       //Remove from stack\\n            pre.push_back(root->val);  //Push into ans vector\\n            if(root->right!=NULL) st.push(root->right);  //Goto Left \\n            if(root->left!=NULL ) st.push(root->left);   //Goto Right\\n        }\\n        return pre;\\n    }\\n};\\n```\n```\\nTime Complexity - O(N) //Traversing all nodes\\nSpace Complexity- O(N) //Storing all nodes\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022895,
                "title": "python-4-solutions-recursion-stack-morris-1-morris-2-short-and-clean",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBelow listed are 4 approaches:\\n- **Recursive:** Uses linear space. clean and Short. Potential recursion max depth issue.\\n- **Stack:** Uses linear space. Short.\\n- **Morris without recovery:** Uses constant space. Destroys the input tree.\\n- **Morris with recovery:** Uses constant space. Destroys and recovers the input tree before returning.\\n\\n---\\n\\n# Approach 1\\nRecursive solution.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def preorderTraversal(self, root_: TreeNode | None) -> list[int]:\\n        def preorder(root: TreeNode | None) -> Iterable:\\n            if not root: return\\n            yield root.val\\n            yield from preorder(root.left)\\n            yield from preorder(root.right)\\n                \\n        return list(preorder(root_))\\n```\\nReduced to 1 - liner:\\n```\\nclass Solution:\\n    def preorderTraversal(self, root_: TreeNode | None) -> list[int]:\\n        def preorder(root: TreeNode | None) -> Iterable:\\n            yield from chain((root.val,), preorder(root.left), preorder(root.right)) if root else []\\n                \\n        return list(preorder(root_))\\n```\\n---\\n\\n# Approach 2\\nStack solution.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def preorderTraversal(self, root_: TreeNode | None) -> list[int]:\\n        def preorder(root: TreeNode | None) -> Iterable:\\n            stack = [root] if root else []\\n            \\n            while stack:\\n                node = stack.pop()\\n                yield node.val\\n                \\n                if node.right: stack.append(node.right)\\n                if node.left: stack.append(node.left)\\n                \\n        return list(preorder(root_))\\n```\\n\\n---\\n\\n# Approach 3\\nMorris Treversal without recovery.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def preorderTraversal(self, root_: TreeNode | None) -> list[int]:\\n        # Morris (Destroys the tree)\\n        def preorder(root: TreeNode | None) -> Iterable:\\n            node = root\\n            while node:\\n                if node.left is None:\\n                    yield node.val\\n                    node = node.right\\n                    continue\\n\\n                last = node.left\\n                while last.right:\\n                    last = last.right\\n                last.right = node.right\\n\\n                yield node.val\\n                node = node.left\\n                \\n        return list(preorder(root_))\\n```\\n\\n---\\n\\n# Approach 4\\nMorris Treversal with recovery.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def preorderTraversal(self, root_: TreeNode | None) -> list[int]:\\n        # Morris (Destroys and recovers the tree)\\n        def preorder(root: TreeNode | None) -> Iterable:\\n            node = root\\n            while node:\\n                if node.left is None:\\n                    yield node.val\\n                    node = node.right\\n                    continue\\n\\n                last = node.left\\n                while last.right and last.right != node:\\n                    last = last.right\\n                \\n                if last.right is None:\\n                    last.right = node\\n                    yield node.val\\n                    node = node.left\\n                else:\\n                    last.right = None\\n                    node = node.right\\n                \\n        return list(preorder(root_))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def preorderTraversal(self, root_: TreeNode | None) -> list[int]:\\n        def preorder(root: TreeNode | None) -> Iterable:\\n            if not root: return\\n            yield root.val\\n            yield from preorder(root.left)\\n            yield from preorder(root.right)\\n                \\n        return list(preorder(root_))\\n```\n```\\nclass Solution:\\n    def preorderTraversal(self, root_: TreeNode | None) -> list[int]:\\n        def preorder(root: TreeNode | None) -> Iterable:\\n            yield from chain((root.val,), preorder(root.left), preorder(root.right)) if root else []\\n                \\n        return list(preorder(root_))\\n```\n```\\nclass Solution:\\n    def preorderTraversal(self, root_: TreeNode | None) -> list[int]:\\n        def preorder(root: TreeNode | None) -> Iterable:\\n            stack = [root] if root else []\\n            \\n            while stack:\\n                node = stack.pop()\\n                yield node.val\\n                \\n                if node.right: stack.append(node.right)\\n                if node.left: stack.append(node.left)\\n                \\n        return list(preorder(root_))\\n```\n```\\nclass Solution:\\n    def preorderTraversal(self, root_: TreeNode | None) -> list[int]:\\n        # Morris (Destroys the tree)\\n        def preorder(root: TreeNode | None) -> Iterable:\\n            node = root\\n            while node:\\n                if node.left is None:\\n                    yield node.val\\n                    node = node.right\\n                    continue\\n\\n                last = node.left\\n                while last.right:\\n                    last = last.right\\n                last.right = node.right\\n\\n                yield node.val\\n                node = node.left\\n                \\n        return list(preorder(root_))\\n```\n```\\nclass Solution:\\n    def preorderTraversal(self, root_: TreeNode | None) -> list[int]:\\n        # Morris (Destroys and recovers the tree)\\n        def preorder(root: TreeNode | None) -> Iterable:\\n            node = root\\n            while node:\\n                if node.left is None:\\n                    yield node.val\\n                    node = node.right\\n                    continue\\n\\n                last = node.left\\n                while last.right and last.right != node:\\n                    last = last.right\\n                \\n                if last.right is None:\\n                    last.right = node\\n                    yield node.val\\n                    node = node.left\\n                else:\\n                    last.right = None\\n                    node = node.right\\n                \\n        return list(preorder(root_))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022589,
                "title": "iterative-traversal-c-using-stack",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int>ans;\\n        if(root==NULL)\\n        {\\n            return ans;\\n        }\\n        stack<TreeNode*>st;\\n        st.push(root);\\n        while(!st.empty())\\n        {\\n            TreeNode* temp=st.top();\\n            ans.push_back(temp->val);\\n            st.pop();\\n            if(temp->right!=NULL) st.push(temp->right);\\n            if(temp->left!=NULL) st.push(temp->left);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int>ans;\\n        if(root==NULL)\\n        {\\n            return ans;\\n        }\\n        stack<TreeNode*>st;\\n        st.push(root);\\n        while(!st.empty())\\n        {\\n            TreeNode* temp=st.top();\\n            ans.push_back(temp->val);\\n            st.pop();\\n            if(temp->right!=NULL) st.push(temp->right);\\n            if(temp->left!=NULL) st.push(temp->left);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022473,
                "title": "tree-easy-py",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root: return []             \\n        stack, ans = [root],[]                                            \\n        while stack:                      \\n            node = stack.pop()             \\n            ans.append(node.val)                              \\n            if node.right:                 \\n                stack.append(node.right)   \\n            if node.left:                  \\n                stack.append(node.left )    \\n        return ans  \\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root: return []             \\n        stack, ans = [root],[]                                            \\n        while stack:                      \\n            node = stack.pop()             \\n            ans.append(node.val)                              \\n            if node.right:                 \\n                stack.append(node.right)   \\n            if node.left:                  \\n                stack.append(node.left )    \\n        return ans  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022311,
                "title": "0ms-c-faster-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    o(n)\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,vector<int>&v){        \\n        if(root==NULL)return ;\\n        v.push_back(root->val);\\n        solve(root->left,v);\\n        solve(root->right,v);\\n    }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        solve(root,v);\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,vector<int>&v){        \\n        if(root==NULL)return ;\\n        v.push_back(root->val);\\n        solve(root->left,v);\\n        solve(root->right,v);\\n    }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        solve(root,v);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022295,
                "title": "easy-java-solution-recursive-beginner-friendly",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        if(root == null) {\\n            return new ArrayList<>();\\n        }\\n        if(root.left == null && root.right == null) {\\n            List<Integer> leaf = new ArrayList<>();\\n            leaf.add(root.val);\\n            return leaf;\\n        }\\n        List<Integer> ans = new ArrayList<>();\\n        ans.add(root.val);\\n        ans.addAll(preorderTraversal(root.left));\\n        ans.addAll(preorderTraversal(root.right));\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        if(root == null) {\\n            return new ArrayList<>();\\n        }\\n        if(root.left == null && root.right == null) {\\n            List<Integer> leaf = new ArrayList<>();\\n            leaf.add(root.val);\\n            return leaf;\\n        }\\n        List<Integer> ans = new ArrayList<>();\\n        ans.add(root.val);\\n        ans.addAll(preorderTraversal(root.left));\\n        ans.addAll(preorderTraversal(root.right));\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022288,
                "title": "python3-23-ms-faster-than-98-78-of-python3-clean-and-easy-to-understand",
                "content": "```\\ndef preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        self.output = []\\n        def traverse(root):\\n            if(root):\\n                self.output.append(root.val)\\n                traverse(root.left)\\n                traverse(root.right)\\n        traverse(root)\\n        return self.output\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\ndef preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        self.output = []\\n        def traverse(root):\\n            if(root):\\n                self.output.append(root.val)\\n                traverse(root.left)\\n                traverse(root.right)\\n        traverse(root)\\n        return self.output\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3022253,
                "title": "java-easy-recursive-iterative-solution-approach-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- ***Preorder Traversal is :  Root -> left-subtree -> right-subtree***\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- ### Recursive:\\n    1. Add the current root node to ans list\\n    2. Call preorder for the left subtree\\n    3. Call preorder for right subtree\\n    4. Base Case: If root is null just return.\\n\\n- ### Iterative:\\n    1. If the root is null return an empty list\\n    2. Create a stack which will hold nodes of the tree.\\n    3. Push the root onto the stack\\n    4. Now iterate till stack is not empty\\n    5. At every iteration do the following: \\n        a.  Pop the top node in stack and add it to ans list.\\n        b.  If we have a node to the right of the popped node, push it onto the stack;\\n        c.  If we have a left node add it to the stack too.\\n\\n\\n# Code \\n## Recursive Approach\\n```\\n// Recursive Solution\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> ls = new ArrayList<>();\\n        preorder(root, ls);\\n        return ls;\\n    }\\n    public void preorder(TreeNode root, List<Integer> ls){\\n        if(root == null) return;\\n\\n        ls.add(root.val);\\n        preorder(root.left, ls);\\n        preorder(root.right, ls);\\n         \\n    }\\n}\\n```\\n## Iterative Approach\\n``` \\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> ls = new ArrayList<>();\\n        if(root == null) return ls;\\n\\n        Stack<TreeNode> st = new Stack<>();\\n        st.push(root);\\n        while(!st.empty()){\\n            TreeNode temp = st.pop();\\n            ls.add(temp.val);\\n            if(temp.right != null) st.push(temp.right);\\n            if(temp.left != null) st.push(temp.left);\\n        }\\n        return ls;\\n    } \\n}\\n```\\n\\n#### Please do Upvote if you find it helpful\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n// Recursive Solution\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> ls = new ArrayList<>();\\n        preorder(root, ls);\\n        return ls;\\n    }\\n    public void preorder(TreeNode root, List<Integer> ls){\\n        if(root == null) return;\\n\\n        ls.add(root.val);\\n        preorder(root.left, ls);\\n        preorder(root.right, ls);\\n         \\n    }\\n}\\n```\n``` \\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> ls = new ArrayList<>();\\n        if(root == null) return ls;\\n\\n        Stack<TreeNode> st = new Stack<>();\\n        st.push(root);\\n        while(!st.empty()){\\n            TreeNode temp = st.pop();\\n            ls.add(temp.val);\\n            if(temp.right != null) st.push(temp.right);\\n            if(temp.left != null) st.push(temp.left);\\n        }\\n        return ls;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022130,
                "title": "preorder-traversal-simple-approach",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> list=new ArrayList<Integer>();\\n        preorder(root,list);\\n        return list;\\n    }\\n    public void preorder(TreeNode root,List<Integer> list){\\n        if(root==null) return ;\\n        list.add(root.val);\\n        preorder(root.left,list);\\n        preorder(root.right,list);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> list=new ArrayList<Integer>();\\n        preorder(root,list);\\n        return list;\\n    }\\n    public void preorder(TreeNode root,List<Integer> list){\\n        if(root==null) return ;\\n        list.add(root.val);\\n        preorder(root.left,list);\\n        preorder(root.right,list);\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1748954,
                "content": [
                    {
                        "username": "kontsis",
                        "content": "I remember the days when I couldn\\'t solve this. Look how far we\\'ve come."
                    },
                    {
                        "username": "miss_sunshine",
                        "content": "someday I\\'ll reach there!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "[@shivamgcodes](/shivamgcodes) there is no book like this ig but you can go to cp-alogrithms website it has all the algos but not all algos are beautiful and worth doing, like morris traversal is only worth using if you are constrained with using no extra space and already know it, but can be used to learn a new perspective on using null pointers in trees and threading.\\nalmost all sufficient algorithms are most beautifully explained in cormen but it doesn\\'t fill the criteria for what you want  but  i trust this book."
                    },
                    {
                        "username": "ankurgupta1999",
                        "content": "I remember the college days when I could solve this at a blink. Look how far I\\'ve come \\uD83E\\uDD72"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "[@Rishabh_yaduwanshi](/Rishabh_yaduwanshi) bro can u please recommend me a book which has all the algos and DS , not necessarily in depth , because being honest , i am reading the word morris traversal for the first time ."
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "i\\'m living your days right now..... hope i might solve these problems soon...!! :  )"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "I remember skipping questions that had slightest mention of tree or graph."
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "i spent a week understanding all these traversals and wasn\\'t able to grasp whole,but now even Morris traversal seems simple,keep pushing."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Yes!! Hard work pays off!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Remember : \\nPreorder Traversal : Root | Left | Right"
                    },
                    {
                        "username": "parapsychic",
                        "content": "A quick way to remember preorder, postorder and inorder is to actually look at the meaning of the word itself. It\\'s always left -> right. The only position that matters is the root. Pre = before, In = in between, post = after.\\nSo, preorder becomes: root left right\\npostorder becomes: left right root\\ninorder becomes: left root right"
                    },
                    {
                        "username": "Msey",
                        "content": "But remember, the power of the Jedi Knight is the power of the universe"
                    },
                    {
                        "username": "kenzoengineer",
                        "content": "thank you daddy leetcode for giving us this question after \"Max Points on a Line\""
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@shivamgcodes](/shivamgcodes) instead of copy pasting it, atleast should have learned the brute force approach and attempted it. it doesnt take much time.. im also a beginner"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "i did not even attempt it , just copy pasted the solution will just read the solution and then implement it myself "
                    },
                    {
                        "username": "neopraveen",
                        "content": "Just a little addition for whom tree is new :\\nPreOrder Traversal -> In preorder traversal, the root node is visited first, then left subtree and then right subtree.\\nIt\\'s required simple recursive solution. You just need to add your current node in the List (it may be a class level variable) and traverse left and right node with same recursive function. That\\'s it, no more line of code is required, the same function will take care of whole tree traversal. Maybe the solution is looking very easy, but believe me it\\'s more easier than you think.\\nPS - Please don\\'t forget to check if current node is null or not, in example you can see a node with null value.\\n\\nIf I am helpful, you know how you can motivate me :)\\nHappy coding."
                    },
                    {
                        "username": "ritteh",
                        "content": "The problem statement indicates the recurrsive version is trivial. How can it be trivial for anyone who has never done trees before? There is exactly zero guidance on how to do it. What terrible training. Fortunately there is Google and I was able to solve it."
                    },
                    {
                        "username": "arthurjwannerjr",
                        "content": "I think that the problem is trivial when you\\'ve got a bit of experience under your belt. Leetcode isn\\'t really for beginners. This problem is probably one of the easiest problems on Leetcode, so relative to other problems on Leetcode, it is trivial.\\n\\nNow, with all that said, the dumb part is that the iterative solution is just as trivial as the recursive solution, for this particular problem anyways.\\n\\nFor other DFS algos such as Post Order Traversal, the iterative version is actually a lot harder than the recursive version."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Agree"
                    },
                    {
                        "username": "Mr_Fish",
                        "content": "Just out of curiosity. I am perfectly capable of coming up with BFS or DFS of traversing a tree as well as just recursion. \\n\\nWill knowing Morris Traversal help you in an interview? I mean while it has O(1) space, it actually has O(2*n) time complexity and time complexity is more significant in an interview."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "O(2 * n) is still O(n). The problem is the locality. Chasing pointers is cache-unfriendly on modern architectures, Morris traversal follows each pointer multiple times so it probably tends to be slower. But in an interview situation it depends on the interviewer. They might just want to tick boxes on a checklist (recursive: check, morris: check), they might be a show-off who tries to impress the interviewee with obscure knowlege (not good but it happens) or they might be an experienced programmer who wants to you find a reasonable solution and/or weigh the advantages/disadvantages."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-09 15.32.48.jpg](https://assets.leetcode.com/users/images/2323c791-f48e-431d-a064-499d1a314186_1673260399.4520557.jpeg)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Recursive approach is quite trivial, can you code it iteravtively!!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "use morris traversal if you want to use constant space,but if you can trade in space using stack is best."
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "stack<TreeNode*> s;\\nwhile(root || !s.empty()){\\n   if(root){\\n        res.push_back(root->val);\\n        s.push(root);\\n        root=root->left;\\n      }\\n   else{\\n        TreeNode* temp=s.top();\\n        temp=temp->right;\\n        }\\n   }\\nreturn res;"
                    },
                    {
                        "username": "nishant7372",
                        "content": "        if(root!=null)\n           stack.push(root);\n        while(!stack.isEmpty()){\n           TreeNode curr = stack.pop();\n           list.add(curr.val);\n           if(curr.right!=null)\n               stack.push(curr.right);\n           if(curr.left!=null)\n               stack.push(curr.left);\n        }"
                    },
                    {
                        "username": "tjin94",
                        "content": "as the title suggests, my code fails for this:\\n\\n[3,5,1,4,2]\\n\\ntest case(testcase66) and i have no idea how they visualize this input tree \\xA0 as the example is too short.."
                    },
                    {
                        "username": "andresstawski",
                        "content": "did you declare your vector as a global variable?"
                    },
                    {
                        "username": "llufan",
                        "content": "`const preorderTraversal = (root) => root ? [root.val, ...preorderTraversal(root.left), ...preorderTraversal(root.right)] : []`"
                    }
                ]
            },
            {
                "id": 1748997,
                "content": [
                    {
                        "username": "kontsis",
                        "content": "I remember the days when I couldn\\'t solve this. Look how far we\\'ve come."
                    },
                    {
                        "username": "miss_sunshine",
                        "content": "someday I\\'ll reach there!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "[@shivamgcodes](/shivamgcodes) there is no book like this ig but you can go to cp-alogrithms website it has all the algos but not all algos are beautiful and worth doing, like morris traversal is only worth using if you are constrained with using no extra space and already know it, but can be used to learn a new perspective on using null pointers in trees and threading.\\nalmost all sufficient algorithms are most beautifully explained in cormen but it doesn\\'t fill the criteria for what you want  but  i trust this book."
                    },
                    {
                        "username": "ankurgupta1999",
                        "content": "I remember the college days when I could solve this at a blink. Look how far I\\'ve come \\uD83E\\uDD72"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "[@Rishabh_yaduwanshi](/Rishabh_yaduwanshi) bro can u please recommend me a book which has all the algos and DS , not necessarily in depth , because being honest , i am reading the word morris traversal for the first time ."
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "i\\'m living your days right now..... hope i might solve these problems soon...!! :  )"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "I remember skipping questions that had slightest mention of tree or graph."
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "i spent a week understanding all these traversals and wasn\\'t able to grasp whole,but now even Morris traversal seems simple,keep pushing."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Yes!! Hard work pays off!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Remember : \\nPreorder Traversal : Root | Left | Right"
                    },
                    {
                        "username": "parapsychic",
                        "content": "A quick way to remember preorder, postorder and inorder is to actually look at the meaning of the word itself. It\\'s always left -> right. The only position that matters is the root. Pre = before, In = in between, post = after.\\nSo, preorder becomes: root left right\\npostorder becomes: left right root\\ninorder becomes: left root right"
                    },
                    {
                        "username": "Msey",
                        "content": "But remember, the power of the Jedi Knight is the power of the universe"
                    },
                    {
                        "username": "kenzoengineer",
                        "content": "thank you daddy leetcode for giving us this question after \"Max Points on a Line\""
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@shivamgcodes](/shivamgcodes) instead of copy pasting it, atleast should have learned the brute force approach and attempted it. it doesnt take much time.. im also a beginner"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "i did not even attempt it , just copy pasted the solution will just read the solution and then implement it myself "
                    },
                    {
                        "username": "neopraveen",
                        "content": "Just a little addition for whom tree is new :\\nPreOrder Traversal -> In preorder traversal, the root node is visited first, then left subtree and then right subtree.\\nIt\\'s required simple recursive solution. You just need to add your current node in the List (it may be a class level variable) and traverse left and right node with same recursive function. That\\'s it, no more line of code is required, the same function will take care of whole tree traversal. Maybe the solution is looking very easy, but believe me it\\'s more easier than you think.\\nPS - Please don\\'t forget to check if current node is null or not, in example you can see a node with null value.\\n\\nIf I am helpful, you know how you can motivate me :)\\nHappy coding."
                    },
                    {
                        "username": "ritteh",
                        "content": "The problem statement indicates the recurrsive version is trivial. How can it be trivial for anyone who has never done trees before? There is exactly zero guidance on how to do it. What terrible training. Fortunately there is Google and I was able to solve it."
                    },
                    {
                        "username": "arthurjwannerjr",
                        "content": "I think that the problem is trivial when you\\'ve got a bit of experience under your belt. Leetcode isn\\'t really for beginners. This problem is probably one of the easiest problems on Leetcode, so relative to other problems on Leetcode, it is trivial.\\n\\nNow, with all that said, the dumb part is that the iterative solution is just as trivial as the recursive solution, for this particular problem anyways.\\n\\nFor other DFS algos such as Post Order Traversal, the iterative version is actually a lot harder than the recursive version."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Agree"
                    },
                    {
                        "username": "Mr_Fish",
                        "content": "Just out of curiosity. I am perfectly capable of coming up with BFS or DFS of traversing a tree as well as just recursion. \\n\\nWill knowing Morris Traversal help you in an interview? I mean while it has O(1) space, it actually has O(2*n) time complexity and time complexity is more significant in an interview."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "O(2 * n) is still O(n). The problem is the locality. Chasing pointers is cache-unfriendly on modern architectures, Morris traversal follows each pointer multiple times so it probably tends to be slower. But in an interview situation it depends on the interviewer. They might just want to tick boxes on a checklist (recursive: check, morris: check), they might be a show-off who tries to impress the interviewee with obscure knowlege (not good but it happens) or they might be an experienced programmer who wants to you find a reasonable solution and/or weigh the advantages/disadvantages."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-09 15.32.48.jpg](https://assets.leetcode.com/users/images/2323c791-f48e-431d-a064-499d1a314186_1673260399.4520557.jpeg)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Recursive approach is quite trivial, can you code it iteravtively!!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "use morris traversal if you want to use constant space,but if you can trade in space using stack is best."
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "stack<TreeNode*> s;\\nwhile(root || !s.empty()){\\n   if(root){\\n        res.push_back(root->val);\\n        s.push(root);\\n        root=root->left;\\n      }\\n   else{\\n        TreeNode* temp=s.top();\\n        temp=temp->right;\\n        }\\n   }\\nreturn res;"
                    },
                    {
                        "username": "nishant7372",
                        "content": "        if(root!=null)\n           stack.push(root);\n        while(!stack.isEmpty()){\n           TreeNode curr = stack.pop();\n           list.add(curr.val);\n           if(curr.right!=null)\n               stack.push(curr.right);\n           if(curr.left!=null)\n               stack.push(curr.left);\n        }"
                    },
                    {
                        "username": "tjin94",
                        "content": "as the title suggests, my code fails for this:\\n\\n[3,5,1,4,2]\\n\\ntest case(testcase66) and i have no idea how they visualize this input tree \\xA0 as the example is too short.."
                    },
                    {
                        "username": "andresstawski",
                        "content": "did you declare your vector as a global variable?"
                    },
                    {
                        "username": "llufan",
                        "content": "`const preorderTraversal = (root) => root ? [root.val, ...preorderTraversal(root.left), ...preorderTraversal(root.right)] : []`"
                    }
                ]
            },
            {
                "id": 1748979,
                "content": [
                    {
                        "username": "kontsis",
                        "content": "I remember the days when I couldn\\'t solve this. Look how far we\\'ve come."
                    },
                    {
                        "username": "miss_sunshine",
                        "content": "someday I\\'ll reach there!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "[@shivamgcodes](/shivamgcodes) there is no book like this ig but you can go to cp-alogrithms website it has all the algos but not all algos are beautiful and worth doing, like morris traversal is only worth using if you are constrained with using no extra space and already know it, but can be used to learn a new perspective on using null pointers in trees and threading.\\nalmost all sufficient algorithms are most beautifully explained in cormen but it doesn\\'t fill the criteria for what you want  but  i trust this book."
                    },
                    {
                        "username": "ankurgupta1999",
                        "content": "I remember the college days when I could solve this at a blink. Look how far I\\'ve come \\uD83E\\uDD72"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "[@Rishabh_yaduwanshi](/Rishabh_yaduwanshi) bro can u please recommend me a book which has all the algos and DS , not necessarily in depth , because being honest , i am reading the word morris traversal for the first time ."
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "i\\'m living your days right now..... hope i might solve these problems soon...!! :  )"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "I remember skipping questions that had slightest mention of tree or graph."
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "i spent a week understanding all these traversals and wasn\\'t able to grasp whole,but now even Morris traversal seems simple,keep pushing."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Yes!! Hard work pays off!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Remember : \\nPreorder Traversal : Root | Left | Right"
                    },
                    {
                        "username": "parapsychic",
                        "content": "A quick way to remember preorder, postorder and inorder is to actually look at the meaning of the word itself. It\\'s always left -> right. The only position that matters is the root. Pre = before, In = in between, post = after.\\nSo, preorder becomes: root left right\\npostorder becomes: left right root\\ninorder becomes: left root right"
                    },
                    {
                        "username": "Msey",
                        "content": "But remember, the power of the Jedi Knight is the power of the universe"
                    },
                    {
                        "username": "kenzoengineer",
                        "content": "thank you daddy leetcode for giving us this question after \"Max Points on a Line\""
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@shivamgcodes](/shivamgcodes) instead of copy pasting it, atleast should have learned the brute force approach and attempted it. it doesnt take much time.. im also a beginner"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "i did not even attempt it , just copy pasted the solution will just read the solution and then implement it myself "
                    },
                    {
                        "username": "neopraveen",
                        "content": "Just a little addition for whom tree is new :\\nPreOrder Traversal -> In preorder traversal, the root node is visited first, then left subtree and then right subtree.\\nIt\\'s required simple recursive solution. You just need to add your current node in the List (it may be a class level variable) and traverse left and right node with same recursive function. That\\'s it, no more line of code is required, the same function will take care of whole tree traversal. Maybe the solution is looking very easy, but believe me it\\'s more easier than you think.\\nPS - Please don\\'t forget to check if current node is null or not, in example you can see a node with null value.\\n\\nIf I am helpful, you know how you can motivate me :)\\nHappy coding."
                    },
                    {
                        "username": "ritteh",
                        "content": "The problem statement indicates the recurrsive version is trivial. How can it be trivial for anyone who has never done trees before? There is exactly zero guidance on how to do it. What terrible training. Fortunately there is Google and I was able to solve it."
                    },
                    {
                        "username": "arthurjwannerjr",
                        "content": "I think that the problem is trivial when you\\'ve got a bit of experience under your belt. Leetcode isn\\'t really for beginners. This problem is probably one of the easiest problems on Leetcode, so relative to other problems on Leetcode, it is trivial.\\n\\nNow, with all that said, the dumb part is that the iterative solution is just as trivial as the recursive solution, for this particular problem anyways.\\n\\nFor other DFS algos such as Post Order Traversal, the iterative version is actually a lot harder than the recursive version."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Agree"
                    },
                    {
                        "username": "Mr_Fish",
                        "content": "Just out of curiosity. I am perfectly capable of coming up with BFS or DFS of traversing a tree as well as just recursion. \\n\\nWill knowing Morris Traversal help you in an interview? I mean while it has O(1) space, it actually has O(2*n) time complexity and time complexity is more significant in an interview."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "O(2 * n) is still O(n). The problem is the locality. Chasing pointers is cache-unfriendly on modern architectures, Morris traversal follows each pointer multiple times so it probably tends to be slower. But in an interview situation it depends on the interviewer. They might just want to tick boxes on a checklist (recursive: check, morris: check), they might be a show-off who tries to impress the interviewee with obscure knowlege (not good but it happens) or they might be an experienced programmer who wants to you find a reasonable solution and/or weigh the advantages/disadvantages."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-09 15.32.48.jpg](https://assets.leetcode.com/users/images/2323c791-f48e-431d-a064-499d1a314186_1673260399.4520557.jpeg)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Recursive approach is quite trivial, can you code it iteravtively!!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "use morris traversal if you want to use constant space,but if you can trade in space using stack is best."
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "stack<TreeNode*> s;\\nwhile(root || !s.empty()){\\n   if(root){\\n        res.push_back(root->val);\\n        s.push(root);\\n        root=root->left;\\n      }\\n   else{\\n        TreeNode* temp=s.top();\\n        temp=temp->right;\\n        }\\n   }\\nreturn res;"
                    },
                    {
                        "username": "nishant7372",
                        "content": "        if(root!=null)\n           stack.push(root);\n        while(!stack.isEmpty()){\n           TreeNode curr = stack.pop();\n           list.add(curr.val);\n           if(curr.right!=null)\n               stack.push(curr.right);\n           if(curr.left!=null)\n               stack.push(curr.left);\n        }"
                    },
                    {
                        "username": "tjin94",
                        "content": "as the title suggests, my code fails for this:\\n\\n[3,5,1,4,2]\\n\\ntest case(testcase66) and i have no idea how they visualize this input tree \\xA0 as the example is too short.."
                    },
                    {
                        "username": "andresstawski",
                        "content": "did you declare your vector as a global variable?"
                    },
                    {
                        "username": "llufan",
                        "content": "`const preorderTraversal = (root) => root ? [root.val, ...preorderTraversal(root.left), ...preorderTraversal(root.right)] : []`"
                    }
                ]
            },
            {
                "id": 1749377,
                "content": [
                    {
                        "username": "kontsis",
                        "content": "I remember the days when I couldn\\'t solve this. Look how far we\\'ve come."
                    },
                    {
                        "username": "miss_sunshine",
                        "content": "someday I\\'ll reach there!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "[@shivamgcodes](/shivamgcodes) there is no book like this ig but you can go to cp-alogrithms website it has all the algos but not all algos are beautiful and worth doing, like morris traversal is only worth using if you are constrained with using no extra space and already know it, but can be used to learn a new perspective on using null pointers in trees and threading.\\nalmost all sufficient algorithms are most beautifully explained in cormen but it doesn\\'t fill the criteria for what you want  but  i trust this book."
                    },
                    {
                        "username": "ankurgupta1999",
                        "content": "I remember the college days when I could solve this at a blink. Look how far I\\'ve come \\uD83E\\uDD72"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "[@Rishabh_yaduwanshi](/Rishabh_yaduwanshi) bro can u please recommend me a book which has all the algos and DS , not necessarily in depth , because being honest , i am reading the word morris traversal for the first time ."
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "i\\'m living your days right now..... hope i might solve these problems soon...!! :  )"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "I remember skipping questions that had slightest mention of tree or graph."
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "i spent a week understanding all these traversals and wasn\\'t able to grasp whole,but now even Morris traversal seems simple,keep pushing."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Yes!! Hard work pays off!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Remember : \\nPreorder Traversal : Root | Left | Right"
                    },
                    {
                        "username": "parapsychic",
                        "content": "A quick way to remember preorder, postorder and inorder is to actually look at the meaning of the word itself. It\\'s always left -> right. The only position that matters is the root. Pre = before, In = in between, post = after.\\nSo, preorder becomes: root left right\\npostorder becomes: left right root\\ninorder becomes: left root right"
                    },
                    {
                        "username": "Msey",
                        "content": "But remember, the power of the Jedi Knight is the power of the universe"
                    },
                    {
                        "username": "kenzoengineer",
                        "content": "thank you daddy leetcode for giving us this question after \"Max Points on a Line\""
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@shivamgcodes](/shivamgcodes) instead of copy pasting it, atleast should have learned the brute force approach and attempted it. it doesnt take much time.. im also a beginner"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "i did not even attempt it , just copy pasted the solution will just read the solution and then implement it myself "
                    },
                    {
                        "username": "neopraveen",
                        "content": "Just a little addition for whom tree is new :\\nPreOrder Traversal -> In preorder traversal, the root node is visited first, then left subtree and then right subtree.\\nIt\\'s required simple recursive solution. You just need to add your current node in the List (it may be a class level variable) and traverse left and right node with same recursive function. That\\'s it, no more line of code is required, the same function will take care of whole tree traversal. Maybe the solution is looking very easy, but believe me it\\'s more easier than you think.\\nPS - Please don\\'t forget to check if current node is null or not, in example you can see a node with null value.\\n\\nIf I am helpful, you know how you can motivate me :)\\nHappy coding."
                    },
                    {
                        "username": "ritteh",
                        "content": "The problem statement indicates the recurrsive version is trivial. How can it be trivial for anyone who has never done trees before? There is exactly zero guidance on how to do it. What terrible training. Fortunately there is Google and I was able to solve it."
                    },
                    {
                        "username": "arthurjwannerjr",
                        "content": "I think that the problem is trivial when you\\'ve got a bit of experience under your belt. Leetcode isn\\'t really for beginners. This problem is probably one of the easiest problems on Leetcode, so relative to other problems on Leetcode, it is trivial.\\n\\nNow, with all that said, the dumb part is that the iterative solution is just as trivial as the recursive solution, for this particular problem anyways.\\n\\nFor other DFS algos such as Post Order Traversal, the iterative version is actually a lot harder than the recursive version."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Agree"
                    },
                    {
                        "username": "Mr_Fish",
                        "content": "Just out of curiosity. I am perfectly capable of coming up with BFS or DFS of traversing a tree as well as just recursion. \\n\\nWill knowing Morris Traversal help you in an interview? I mean while it has O(1) space, it actually has O(2*n) time complexity and time complexity is more significant in an interview."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "O(2 * n) is still O(n). The problem is the locality. Chasing pointers is cache-unfriendly on modern architectures, Morris traversal follows each pointer multiple times so it probably tends to be slower. But in an interview situation it depends on the interviewer. They might just want to tick boxes on a checklist (recursive: check, morris: check), they might be a show-off who tries to impress the interviewee with obscure knowlege (not good but it happens) or they might be an experienced programmer who wants to you find a reasonable solution and/or weigh the advantages/disadvantages."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-09 15.32.48.jpg](https://assets.leetcode.com/users/images/2323c791-f48e-431d-a064-499d1a314186_1673260399.4520557.jpeg)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Recursive approach is quite trivial, can you code it iteravtively!!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "use morris traversal if you want to use constant space,but if you can trade in space using stack is best."
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "stack<TreeNode*> s;\\nwhile(root || !s.empty()){\\n   if(root){\\n        res.push_back(root->val);\\n        s.push(root);\\n        root=root->left;\\n      }\\n   else{\\n        TreeNode* temp=s.top();\\n        temp=temp->right;\\n        }\\n   }\\nreturn res;"
                    },
                    {
                        "username": "nishant7372",
                        "content": "        if(root!=null)\n           stack.push(root);\n        while(!stack.isEmpty()){\n           TreeNode curr = stack.pop();\n           list.add(curr.val);\n           if(curr.right!=null)\n               stack.push(curr.right);\n           if(curr.left!=null)\n               stack.push(curr.left);\n        }"
                    },
                    {
                        "username": "tjin94",
                        "content": "as the title suggests, my code fails for this:\\n\\n[3,5,1,4,2]\\n\\ntest case(testcase66) and i have no idea how they visualize this input tree \\xA0 as the example is too short.."
                    },
                    {
                        "username": "andresstawski",
                        "content": "did you declare your vector as a global variable?"
                    },
                    {
                        "username": "llufan",
                        "content": "`const preorderTraversal = (root) => root ? [root.val, ...preorderTraversal(root.left), ...preorderTraversal(root.right)] : []`"
                    }
                ]
            },
            {
                "id": 1570384,
                "content": [
                    {
                        "username": "kontsis",
                        "content": "I remember the days when I couldn\\'t solve this. Look how far we\\'ve come."
                    },
                    {
                        "username": "miss_sunshine",
                        "content": "someday I\\'ll reach there!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "[@shivamgcodes](/shivamgcodes) there is no book like this ig but you can go to cp-alogrithms website it has all the algos but not all algos are beautiful and worth doing, like morris traversal is only worth using if you are constrained with using no extra space and already know it, but can be used to learn a new perspective on using null pointers in trees and threading.\\nalmost all sufficient algorithms are most beautifully explained in cormen but it doesn\\'t fill the criteria for what you want  but  i trust this book."
                    },
                    {
                        "username": "ankurgupta1999",
                        "content": "I remember the college days when I could solve this at a blink. Look how far I\\'ve come \\uD83E\\uDD72"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "[@Rishabh_yaduwanshi](/Rishabh_yaduwanshi) bro can u please recommend me a book which has all the algos and DS , not necessarily in depth , because being honest , i am reading the word morris traversal for the first time ."
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "i\\'m living your days right now..... hope i might solve these problems soon...!! :  )"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "I remember skipping questions that had slightest mention of tree or graph."
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "i spent a week understanding all these traversals and wasn\\'t able to grasp whole,but now even Morris traversal seems simple,keep pushing."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Yes!! Hard work pays off!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Remember : \\nPreorder Traversal : Root | Left | Right"
                    },
                    {
                        "username": "parapsychic",
                        "content": "A quick way to remember preorder, postorder and inorder is to actually look at the meaning of the word itself. It\\'s always left -> right. The only position that matters is the root. Pre = before, In = in between, post = after.\\nSo, preorder becomes: root left right\\npostorder becomes: left right root\\ninorder becomes: left root right"
                    },
                    {
                        "username": "Msey",
                        "content": "But remember, the power of the Jedi Knight is the power of the universe"
                    },
                    {
                        "username": "kenzoengineer",
                        "content": "thank you daddy leetcode for giving us this question after \"Max Points on a Line\""
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@shivamgcodes](/shivamgcodes) instead of copy pasting it, atleast should have learned the brute force approach and attempted it. it doesnt take much time.. im also a beginner"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "i did not even attempt it , just copy pasted the solution will just read the solution and then implement it myself "
                    },
                    {
                        "username": "neopraveen",
                        "content": "Just a little addition for whom tree is new :\\nPreOrder Traversal -> In preorder traversal, the root node is visited first, then left subtree and then right subtree.\\nIt\\'s required simple recursive solution. You just need to add your current node in the List (it may be a class level variable) and traverse left and right node with same recursive function. That\\'s it, no more line of code is required, the same function will take care of whole tree traversal. Maybe the solution is looking very easy, but believe me it\\'s more easier than you think.\\nPS - Please don\\'t forget to check if current node is null or not, in example you can see a node with null value.\\n\\nIf I am helpful, you know how you can motivate me :)\\nHappy coding."
                    },
                    {
                        "username": "ritteh",
                        "content": "The problem statement indicates the recurrsive version is trivial. How can it be trivial for anyone who has never done trees before? There is exactly zero guidance on how to do it. What terrible training. Fortunately there is Google and I was able to solve it."
                    },
                    {
                        "username": "arthurjwannerjr",
                        "content": "I think that the problem is trivial when you\\'ve got a bit of experience under your belt. Leetcode isn\\'t really for beginners. This problem is probably one of the easiest problems on Leetcode, so relative to other problems on Leetcode, it is trivial.\\n\\nNow, with all that said, the dumb part is that the iterative solution is just as trivial as the recursive solution, for this particular problem anyways.\\n\\nFor other DFS algos such as Post Order Traversal, the iterative version is actually a lot harder than the recursive version."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Agree"
                    },
                    {
                        "username": "Mr_Fish",
                        "content": "Just out of curiosity. I am perfectly capable of coming up with BFS or DFS of traversing a tree as well as just recursion. \\n\\nWill knowing Morris Traversal help you in an interview? I mean while it has O(1) space, it actually has O(2*n) time complexity and time complexity is more significant in an interview."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "O(2 * n) is still O(n). The problem is the locality. Chasing pointers is cache-unfriendly on modern architectures, Morris traversal follows each pointer multiple times so it probably tends to be slower. But in an interview situation it depends on the interviewer. They might just want to tick boxes on a checklist (recursive: check, morris: check), they might be a show-off who tries to impress the interviewee with obscure knowlege (not good but it happens) or they might be an experienced programmer who wants to you find a reasonable solution and/or weigh the advantages/disadvantages."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-09 15.32.48.jpg](https://assets.leetcode.com/users/images/2323c791-f48e-431d-a064-499d1a314186_1673260399.4520557.jpeg)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Recursive approach is quite trivial, can you code it iteravtively!!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "use morris traversal if you want to use constant space,but if you can trade in space using stack is best."
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "stack<TreeNode*> s;\\nwhile(root || !s.empty()){\\n   if(root){\\n        res.push_back(root->val);\\n        s.push(root);\\n        root=root->left;\\n      }\\n   else{\\n        TreeNode* temp=s.top();\\n        temp=temp->right;\\n        }\\n   }\\nreturn res;"
                    },
                    {
                        "username": "nishant7372",
                        "content": "        if(root!=null)\n           stack.push(root);\n        while(!stack.isEmpty()){\n           TreeNode curr = stack.pop();\n           list.add(curr.val);\n           if(curr.right!=null)\n               stack.push(curr.right);\n           if(curr.left!=null)\n               stack.push(curr.left);\n        }"
                    },
                    {
                        "username": "tjin94",
                        "content": "as the title suggests, my code fails for this:\\n\\n[3,5,1,4,2]\\n\\ntest case(testcase66) and i have no idea how they visualize this input tree \\xA0 as the example is too short.."
                    },
                    {
                        "username": "andresstawski",
                        "content": "did you declare your vector as a global variable?"
                    },
                    {
                        "username": "llufan",
                        "content": "`const preorderTraversal = (root) => root ? [root.val, ...preorderTraversal(root.left), ...preorderTraversal(root.right)] : []`"
                    }
                ]
            },
            {
                "id": 1565777,
                "content": [
                    {
                        "username": "kontsis",
                        "content": "I remember the days when I couldn\\'t solve this. Look how far we\\'ve come."
                    },
                    {
                        "username": "miss_sunshine",
                        "content": "someday I\\'ll reach there!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "[@shivamgcodes](/shivamgcodes) there is no book like this ig but you can go to cp-alogrithms website it has all the algos but not all algos are beautiful and worth doing, like morris traversal is only worth using if you are constrained with using no extra space and already know it, but can be used to learn a new perspective on using null pointers in trees and threading.\\nalmost all sufficient algorithms are most beautifully explained in cormen but it doesn\\'t fill the criteria for what you want  but  i trust this book."
                    },
                    {
                        "username": "ankurgupta1999",
                        "content": "I remember the college days when I could solve this at a blink. Look how far I\\'ve come \\uD83E\\uDD72"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "[@Rishabh_yaduwanshi](/Rishabh_yaduwanshi) bro can u please recommend me a book which has all the algos and DS , not necessarily in depth , because being honest , i am reading the word morris traversal for the first time ."
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "i\\'m living your days right now..... hope i might solve these problems soon...!! :  )"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "I remember skipping questions that had slightest mention of tree or graph."
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "i spent a week understanding all these traversals and wasn\\'t able to grasp whole,but now even Morris traversal seems simple,keep pushing."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Yes!! Hard work pays off!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Remember : \\nPreorder Traversal : Root | Left | Right"
                    },
                    {
                        "username": "parapsychic",
                        "content": "A quick way to remember preorder, postorder and inorder is to actually look at the meaning of the word itself. It\\'s always left -> right. The only position that matters is the root. Pre = before, In = in between, post = after.\\nSo, preorder becomes: root left right\\npostorder becomes: left right root\\ninorder becomes: left root right"
                    },
                    {
                        "username": "Msey",
                        "content": "But remember, the power of the Jedi Knight is the power of the universe"
                    },
                    {
                        "username": "kenzoengineer",
                        "content": "thank you daddy leetcode for giving us this question after \"Max Points on a Line\""
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@shivamgcodes](/shivamgcodes) instead of copy pasting it, atleast should have learned the brute force approach and attempted it. it doesnt take much time.. im also a beginner"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "i did not even attempt it , just copy pasted the solution will just read the solution and then implement it myself "
                    },
                    {
                        "username": "neopraveen",
                        "content": "Just a little addition for whom tree is new :\\nPreOrder Traversal -> In preorder traversal, the root node is visited first, then left subtree and then right subtree.\\nIt\\'s required simple recursive solution. You just need to add your current node in the List (it may be a class level variable) and traverse left and right node with same recursive function. That\\'s it, no more line of code is required, the same function will take care of whole tree traversal. Maybe the solution is looking very easy, but believe me it\\'s more easier than you think.\\nPS - Please don\\'t forget to check if current node is null or not, in example you can see a node with null value.\\n\\nIf I am helpful, you know how you can motivate me :)\\nHappy coding."
                    },
                    {
                        "username": "ritteh",
                        "content": "The problem statement indicates the recurrsive version is trivial. How can it be trivial for anyone who has never done trees before? There is exactly zero guidance on how to do it. What terrible training. Fortunately there is Google and I was able to solve it."
                    },
                    {
                        "username": "arthurjwannerjr",
                        "content": "I think that the problem is trivial when you\\'ve got a bit of experience under your belt. Leetcode isn\\'t really for beginners. This problem is probably one of the easiest problems on Leetcode, so relative to other problems on Leetcode, it is trivial.\\n\\nNow, with all that said, the dumb part is that the iterative solution is just as trivial as the recursive solution, for this particular problem anyways.\\n\\nFor other DFS algos such as Post Order Traversal, the iterative version is actually a lot harder than the recursive version."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Agree"
                    },
                    {
                        "username": "Mr_Fish",
                        "content": "Just out of curiosity. I am perfectly capable of coming up with BFS or DFS of traversing a tree as well as just recursion. \\n\\nWill knowing Morris Traversal help you in an interview? I mean while it has O(1) space, it actually has O(2*n) time complexity and time complexity is more significant in an interview."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "O(2 * n) is still O(n). The problem is the locality. Chasing pointers is cache-unfriendly on modern architectures, Morris traversal follows each pointer multiple times so it probably tends to be slower. But in an interview situation it depends on the interviewer. They might just want to tick boxes on a checklist (recursive: check, morris: check), they might be a show-off who tries to impress the interviewee with obscure knowlege (not good but it happens) or they might be an experienced programmer who wants to you find a reasonable solution and/or weigh the advantages/disadvantages."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-09 15.32.48.jpg](https://assets.leetcode.com/users/images/2323c791-f48e-431d-a064-499d1a314186_1673260399.4520557.jpeg)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Recursive approach is quite trivial, can you code it iteravtively!!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "use morris traversal if you want to use constant space,but if you can trade in space using stack is best."
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "stack<TreeNode*> s;\\nwhile(root || !s.empty()){\\n   if(root){\\n        res.push_back(root->val);\\n        s.push(root);\\n        root=root->left;\\n      }\\n   else{\\n        TreeNode* temp=s.top();\\n        temp=temp->right;\\n        }\\n   }\\nreturn res;"
                    },
                    {
                        "username": "nishant7372",
                        "content": "        if(root!=null)\n           stack.push(root);\n        while(!stack.isEmpty()){\n           TreeNode curr = stack.pop();\n           list.add(curr.val);\n           if(curr.right!=null)\n               stack.push(curr.right);\n           if(curr.left!=null)\n               stack.push(curr.left);\n        }"
                    },
                    {
                        "username": "tjin94",
                        "content": "as the title suggests, my code fails for this:\\n\\n[3,5,1,4,2]\\n\\ntest case(testcase66) and i have no idea how they visualize this input tree \\xA0 as the example is too short.."
                    },
                    {
                        "username": "andresstawski",
                        "content": "did you declare your vector as a global variable?"
                    },
                    {
                        "username": "llufan",
                        "content": "`const preorderTraversal = (root) => root ? [root.val, ...preorderTraversal(root.left), ...preorderTraversal(root.right)] : []`"
                    }
                ]
            },
            {
                "id": 1749643,
                "content": [
                    {
                        "username": "kontsis",
                        "content": "I remember the days when I couldn\\'t solve this. Look how far we\\'ve come."
                    },
                    {
                        "username": "miss_sunshine",
                        "content": "someday I\\'ll reach there!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "[@shivamgcodes](/shivamgcodes) there is no book like this ig but you can go to cp-alogrithms website it has all the algos but not all algos are beautiful and worth doing, like morris traversal is only worth using if you are constrained with using no extra space and already know it, but can be used to learn a new perspective on using null pointers in trees and threading.\\nalmost all sufficient algorithms are most beautifully explained in cormen but it doesn\\'t fill the criteria for what you want  but  i trust this book."
                    },
                    {
                        "username": "ankurgupta1999",
                        "content": "I remember the college days when I could solve this at a blink. Look how far I\\'ve come \\uD83E\\uDD72"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "[@Rishabh_yaduwanshi](/Rishabh_yaduwanshi) bro can u please recommend me a book which has all the algos and DS , not necessarily in depth , because being honest , i am reading the word morris traversal for the first time ."
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "i\\'m living your days right now..... hope i might solve these problems soon...!! :  )"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "I remember skipping questions that had slightest mention of tree or graph."
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "i spent a week understanding all these traversals and wasn\\'t able to grasp whole,but now even Morris traversal seems simple,keep pushing."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Yes!! Hard work pays off!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Remember : \\nPreorder Traversal : Root | Left | Right"
                    },
                    {
                        "username": "parapsychic",
                        "content": "A quick way to remember preorder, postorder and inorder is to actually look at the meaning of the word itself. It\\'s always left -> right. The only position that matters is the root. Pre = before, In = in between, post = after.\\nSo, preorder becomes: root left right\\npostorder becomes: left right root\\ninorder becomes: left root right"
                    },
                    {
                        "username": "Msey",
                        "content": "But remember, the power of the Jedi Knight is the power of the universe"
                    },
                    {
                        "username": "kenzoengineer",
                        "content": "thank you daddy leetcode for giving us this question after \"Max Points on a Line\""
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@shivamgcodes](/shivamgcodes) instead of copy pasting it, atleast should have learned the brute force approach and attempted it. it doesnt take much time.. im also a beginner"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "i did not even attempt it , just copy pasted the solution will just read the solution and then implement it myself "
                    },
                    {
                        "username": "neopraveen",
                        "content": "Just a little addition for whom tree is new :\\nPreOrder Traversal -> In preorder traversal, the root node is visited first, then left subtree and then right subtree.\\nIt\\'s required simple recursive solution. You just need to add your current node in the List (it may be a class level variable) and traverse left and right node with same recursive function. That\\'s it, no more line of code is required, the same function will take care of whole tree traversal. Maybe the solution is looking very easy, but believe me it\\'s more easier than you think.\\nPS - Please don\\'t forget to check if current node is null or not, in example you can see a node with null value.\\n\\nIf I am helpful, you know how you can motivate me :)\\nHappy coding."
                    },
                    {
                        "username": "ritteh",
                        "content": "The problem statement indicates the recurrsive version is trivial. How can it be trivial for anyone who has never done trees before? There is exactly zero guidance on how to do it. What terrible training. Fortunately there is Google and I was able to solve it."
                    },
                    {
                        "username": "arthurjwannerjr",
                        "content": "I think that the problem is trivial when you\\'ve got a bit of experience under your belt. Leetcode isn\\'t really for beginners. This problem is probably one of the easiest problems on Leetcode, so relative to other problems on Leetcode, it is trivial.\\n\\nNow, with all that said, the dumb part is that the iterative solution is just as trivial as the recursive solution, for this particular problem anyways.\\n\\nFor other DFS algos such as Post Order Traversal, the iterative version is actually a lot harder than the recursive version."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Agree"
                    },
                    {
                        "username": "Mr_Fish",
                        "content": "Just out of curiosity. I am perfectly capable of coming up with BFS or DFS of traversing a tree as well as just recursion. \\n\\nWill knowing Morris Traversal help you in an interview? I mean while it has O(1) space, it actually has O(2*n) time complexity and time complexity is more significant in an interview."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "O(2 * n) is still O(n). The problem is the locality. Chasing pointers is cache-unfriendly on modern architectures, Morris traversal follows each pointer multiple times so it probably tends to be slower. But in an interview situation it depends on the interviewer. They might just want to tick boxes on a checklist (recursive: check, morris: check), they might be a show-off who tries to impress the interviewee with obscure knowlege (not good but it happens) or they might be an experienced programmer who wants to you find a reasonable solution and/or weigh the advantages/disadvantages."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-09 15.32.48.jpg](https://assets.leetcode.com/users/images/2323c791-f48e-431d-a064-499d1a314186_1673260399.4520557.jpeg)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Recursive approach is quite trivial, can you code it iteravtively!!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "use morris traversal if you want to use constant space,but if you can trade in space using stack is best."
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "stack<TreeNode*> s;\\nwhile(root || !s.empty()){\\n   if(root){\\n        res.push_back(root->val);\\n        s.push(root);\\n        root=root->left;\\n      }\\n   else{\\n        TreeNode* temp=s.top();\\n        temp=temp->right;\\n        }\\n   }\\nreturn res;"
                    },
                    {
                        "username": "nishant7372",
                        "content": "        if(root!=null)\n           stack.push(root);\n        while(!stack.isEmpty()){\n           TreeNode curr = stack.pop();\n           list.add(curr.val);\n           if(curr.right!=null)\n               stack.push(curr.right);\n           if(curr.left!=null)\n               stack.push(curr.left);\n        }"
                    },
                    {
                        "username": "tjin94",
                        "content": "as the title suggests, my code fails for this:\\n\\n[3,5,1,4,2]\\n\\ntest case(testcase66) and i have no idea how they visualize this input tree \\xA0 as the example is too short.."
                    },
                    {
                        "username": "andresstawski",
                        "content": "did you declare your vector as a global variable?"
                    },
                    {
                        "username": "llufan",
                        "content": "`const preorderTraversal = (root) => root ? [root.val, ...preorderTraversal(root.left), ...preorderTraversal(root.right)] : []`"
                    }
                ]
            },
            {
                "id": 1748998,
                "content": [
                    {
                        "username": "kontsis",
                        "content": "I remember the days when I couldn\\'t solve this. Look how far we\\'ve come."
                    },
                    {
                        "username": "miss_sunshine",
                        "content": "someday I\\'ll reach there!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "[@shivamgcodes](/shivamgcodes) there is no book like this ig but you can go to cp-alogrithms website it has all the algos but not all algos are beautiful and worth doing, like morris traversal is only worth using if you are constrained with using no extra space and already know it, but can be used to learn a new perspective on using null pointers in trees and threading.\\nalmost all sufficient algorithms are most beautifully explained in cormen but it doesn\\'t fill the criteria for what you want  but  i trust this book."
                    },
                    {
                        "username": "ankurgupta1999",
                        "content": "I remember the college days when I could solve this at a blink. Look how far I\\'ve come \\uD83E\\uDD72"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "[@Rishabh_yaduwanshi](/Rishabh_yaduwanshi) bro can u please recommend me a book which has all the algos and DS , not necessarily in depth , because being honest , i am reading the word morris traversal for the first time ."
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "i\\'m living your days right now..... hope i might solve these problems soon...!! :  )"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "I remember skipping questions that had slightest mention of tree or graph."
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "i spent a week understanding all these traversals and wasn\\'t able to grasp whole,but now even Morris traversal seems simple,keep pushing."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Yes!! Hard work pays off!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Remember : \\nPreorder Traversal : Root | Left | Right"
                    },
                    {
                        "username": "parapsychic",
                        "content": "A quick way to remember preorder, postorder and inorder is to actually look at the meaning of the word itself. It\\'s always left -> right. The only position that matters is the root. Pre = before, In = in between, post = after.\\nSo, preorder becomes: root left right\\npostorder becomes: left right root\\ninorder becomes: left root right"
                    },
                    {
                        "username": "Msey",
                        "content": "But remember, the power of the Jedi Knight is the power of the universe"
                    },
                    {
                        "username": "kenzoengineer",
                        "content": "thank you daddy leetcode for giving us this question after \"Max Points on a Line\""
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@shivamgcodes](/shivamgcodes) instead of copy pasting it, atleast should have learned the brute force approach and attempted it. it doesnt take much time.. im also a beginner"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "i did not even attempt it , just copy pasted the solution will just read the solution and then implement it myself "
                    },
                    {
                        "username": "neopraveen",
                        "content": "Just a little addition for whom tree is new :\\nPreOrder Traversal -> In preorder traversal, the root node is visited first, then left subtree and then right subtree.\\nIt\\'s required simple recursive solution. You just need to add your current node in the List (it may be a class level variable) and traverse left and right node with same recursive function. That\\'s it, no more line of code is required, the same function will take care of whole tree traversal. Maybe the solution is looking very easy, but believe me it\\'s more easier than you think.\\nPS - Please don\\'t forget to check if current node is null or not, in example you can see a node with null value.\\n\\nIf I am helpful, you know how you can motivate me :)\\nHappy coding."
                    },
                    {
                        "username": "ritteh",
                        "content": "The problem statement indicates the recurrsive version is trivial. How can it be trivial for anyone who has never done trees before? There is exactly zero guidance on how to do it. What terrible training. Fortunately there is Google and I was able to solve it."
                    },
                    {
                        "username": "arthurjwannerjr",
                        "content": "I think that the problem is trivial when you\\'ve got a bit of experience under your belt. Leetcode isn\\'t really for beginners. This problem is probably one of the easiest problems on Leetcode, so relative to other problems on Leetcode, it is trivial.\\n\\nNow, with all that said, the dumb part is that the iterative solution is just as trivial as the recursive solution, for this particular problem anyways.\\n\\nFor other DFS algos such as Post Order Traversal, the iterative version is actually a lot harder than the recursive version."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Agree"
                    },
                    {
                        "username": "Mr_Fish",
                        "content": "Just out of curiosity. I am perfectly capable of coming up with BFS or DFS of traversing a tree as well as just recursion. \\n\\nWill knowing Morris Traversal help you in an interview? I mean while it has O(1) space, it actually has O(2*n) time complexity and time complexity is more significant in an interview."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "O(2 * n) is still O(n). The problem is the locality. Chasing pointers is cache-unfriendly on modern architectures, Morris traversal follows each pointer multiple times so it probably tends to be slower. But in an interview situation it depends on the interviewer. They might just want to tick boxes on a checklist (recursive: check, morris: check), they might be a show-off who tries to impress the interviewee with obscure knowlege (not good but it happens) or they might be an experienced programmer who wants to you find a reasonable solution and/or weigh the advantages/disadvantages."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-09 15.32.48.jpg](https://assets.leetcode.com/users/images/2323c791-f48e-431d-a064-499d1a314186_1673260399.4520557.jpeg)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Recursive approach is quite trivial, can you code it iteravtively!!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "use morris traversal if you want to use constant space,but if you can trade in space using stack is best."
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "stack<TreeNode*> s;\\nwhile(root || !s.empty()){\\n   if(root){\\n        res.push_back(root->val);\\n        s.push(root);\\n        root=root->left;\\n      }\\n   else{\\n        TreeNode* temp=s.top();\\n        temp=temp->right;\\n        }\\n   }\\nreturn res;"
                    },
                    {
                        "username": "nishant7372",
                        "content": "        if(root!=null)\n           stack.push(root);\n        while(!stack.isEmpty()){\n           TreeNode curr = stack.pop();\n           list.add(curr.val);\n           if(curr.right!=null)\n               stack.push(curr.right);\n           if(curr.left!=null)\n               stack.push(curr.left);\n        }"
                    },
                    {
                        "username": "tjin94",
                        "content": "as the title suggests, my code fails for this:\\n\\n[3,5,1,4,2]\\n\\ntest case(testcase66) and i have no idea how they visualize this input tree \\xA0 as the example is too short.."
                    },
                    {
                        "username": "andresstawski",
                        "content": "did you declare your vector as a global variable?"
                    },
                    {
                        "username": "llufan",
                        "content": "`const preorderTraversal = (root) => root ? [root.val, ...preorderTraversal(root.left), ...preorderTraversal(root.right)] : []`"
                    }
                ]
            },
            {
                "id": 1572820,
                "content": [
                    {
                        "username": "kontsis",
                        "content": "I remember the days when I couldn\\'t solve this. Look how far we\\'ve come."
                    },
                    {
                        "username": "miss_sunshine",
                        "content": "someday I\\'ll reach there!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "[@shivamgcodes](/shivamgcodes) there is no book like this ig but you can go to cp-alogrithms website it has all the algos but not all algos are beautiful and worth doing, like morris traversal is only worth using if you are constrained with using no extra space and already know it, but can be used to learn a new perspective on using null pointers in trees and threading.\\nalmost all sufficient algorithms are most beautifully explained in cormen but it doesn\\'t fill the criteria for what you want  but  i trust this book."
                    },
                    {
                        "username": "ankurgupta1999",
                        "content": "I remember the college days when I could solve this at a blink. Look how far I\\'ve come \\uD83E\\uDD72"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "[@Rishabh_yaduwanshi](/Rishabh_yaduwanshi) bro can u please recommend me a book which has all the algos and DS , not necessarily in depth , because being honest , i am reading the word morris traversal for the first time ."
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "i\\'m living your days right now..... hope i might solve these problems soon...!! :  )"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "I remember skipping questions that had slightest mention of tree or graph."
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "i spent a week understanding all these traversals and wasn\\'t able to grasp whole,but now even Morris traversal seems simple,keep pushing."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Yes!! Hard work pays off!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Remember : \\nPreorder Traversal : Root | Left | Right"
                    },
                    {
                        "username": "parapsychic",
                        "content": "A quick way to remember preorder, postorder and inorder is to actually look at the meaning of the word itself. It\\'s always left -> right. The only position that matters is the root. Pre = before, In = in between, post = after.\\nSo, preorder becomes: root left right\\npostorder becomes: left right root\\ninorder becomes: left root right"
                    },
                    {
                        "username": "Msey",
                        "content": "But remember, the power of the Jedi Knight is the power of the universe"
                    },
                    {
                        "username": "kenzoengineer",
                        "content": "thank you daddy leetcode for giving us this question after \"Max Points on a Line\""
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@shivamgcodes](/shivamgcodes) instead of copy pasting it, atleast should have learned the brute force approach and attempted it. it doesnt take much time.. im also a beginner"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "i did not even attempt it , just copy pasted the solution will just read the solution and then implement it myself "
                    },
                    {
                        "username": "neopraveen",
                        "content": "Just a little addition for whom tree is new :\\nPreOrder Traversal -> In preorder traversal, the root node is visited first, then left subtree and then right subtree.\\nIt\\'s required simple recursive solution. You just need to add your current node in the List (it may be a class level variable) and traverse left and right node with same recursive function. That\\'s it, no more line of code is required, the same function will take care of whole tree traversal. Maybe the solution is looking very easy, but believe me it\\'s more easier than you think.\\nPS - Please don\\'t forget to check if current node is null or not, in example you can see a node with null value.\\n\\nIf I am helpful, you know how you can motivate me :)\\nHappy coding."
                    },
                    {
                        "username": "ritteh",
                        "content": "The problem statement indicates the recurrsive version is trivial. How can it be trivial for anyone who has never done trees before? There is exactly zero guidance on how to do it. What terrible training. Fortunately there is Google and I was able to solve it."
                    },
                    {
                        "username": "arthurjwannerjr",
                        "content": "I think that the problem is trivial when you\\'ve got a bit of experience under your belt. Leetcode isn\\'t really for beginners. This problem is probably one of the easiest problems on Leetcode, so relative to other problems on Leetcode, it is trivial.\\n\\nNow, with all that said, the dumb part is that the iterative solution is just as trivial as the recursive solution, for this particular problem anyways.\\n\\nFor other DFS algos such as Post Order Traversal, the iterative version is actually a lot harder than the recursive version."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Agree"
                    },
                    {
                        "username": "Mr_Fish",
                        "content": "Just out of curiosity. I am perfectly capable of coming up with BFS or DFS of traversing a tree as well as just recursion. \\n\\nWill knowing Morris Traversal help you in an interview? I mean while it has O(1) space, it actually has O(2*n) time complexity and time complexity is more significant in an interview."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "O(2 * n) is still O(n). The problem is the locality. Chasing pointers is cache-unfriendly on modern architectures, Morris traversal follows each pointer multiple times so it probably tends to be slower. But in an interview situation it depends on the interviewer. They might just want to tick boxes on a checklist (recursive: check, morris: check), they might be a show-off who tries to impress the interviewee with obscure knowlege (not good but it happens) or they might be an experienced programmer who wants to you find a reasonable solution and/or weigh the advantages/disadvantages."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-09 15.32.48.jpg](https://assets.leetcode.com/users/images/2323c791-f48e-431d-a064-499d1a314186_1673260399.4520557.jpeg)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Recursive approach is quite trivial, can you code it iteravtively!!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "use morris traversal if you want to use constant space,but if you can trade in space using stack is best."
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "stack<TreeNode*> s;\\nwhile(root || !s.empty()){\\n   if(root){\\n        res.push_back(root->val);\\n        s.push(root);\\n        root=root->left;\\n      }\\n   else{\\n        TreeNode* temp=s.top();\\n        temp=temp->right;\\n        }\\n   }\\nreturn res;"
                    },
                    {
                        "username": "nishant7372",
                        "content": "        if(root!=null)\n           stack.push(root);\n        while(!stack.isEmpty()){\n           TreeNode curr = stack.pop();\n           list.add(curr.val);\n           if(curr.right!=null)\n               stack.push(curr.right);\n           if(curr.left!=null)\n               stack.push(curr.left);\n        }"
                    },
                    {
                        "username": "tjin94",
                        "content": "as the title suggests, my code fails for this:\\n\\n[3,5,1,4,2]\\n\\ntest case(testcase66) and i have no idea how they visualize this input tree \\xA0 as the example is too short.."
                    },
                    {
                        "username": "andresstawski",
                        "content": "did you declare your vector as a global variable?"
                    },
                    {
                        "username": "llufan",
                        "content": "`const preorderTraversal = (root) => root ? [root.val, ...preorderTraversal(root.left), ...preorderTraversal(root.right)] : []`"
                    }
                ]
            },
            {
                "id": 1568092,
                "content": [
                    {
                        "username": "kontsis",
                        "content": "I remember the days when I couldn\\'t solve this. Look how far we\\'ve come."
                    },
                    {
                        "username": "miss_sunshine",
                        "content": "someday I\\'ll reach there!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "[@shivamgcodes](/shivamgcodes) there is no book like this ig but you can go to cp-alogrithms website it has all the algos but not all algos are beautiful and worth doing, like morris traversal is only worth using if you are constrained with using no extra space and already know it, but can be used to learn a new perspective on using null pointers in trees and threading.\\nalmost all sufficient algorithms are most beautifully explained in cormen but it doesn\\'t fill the criteria for what you want  but  i trust this book."
                    },
                    {
                        "username": "ankurgupta1999",
                        "content": "I remember the college days when I could solve this at a blink. Look how far I\\'ve come \\uD83E\\uDD72"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "[@Rishabh_yaduwanshi](/Rishabh_yaduwanshi) bro can u please recommend me a book which has all the algos and DS , not necessarily in depth , because being honest , i am reading the word morris traversal for the first time ."
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "i\\'m living your days right now..... hope i might solve these problems soon...!! :  )"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "I remember skipping questions that had slightest mention of tree or graph."
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "i spent a week understanding all these traversals and wasn\\'t able to grasp whole,but now even Morris traversal seems simple,keep pushing."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Yes!! Hard work pays off!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Remember : \\nPreorder Traversal : Root | Left | Right"
                    },
                    {
                        "username": "parapsychic",
                        "content": "A quick way to remember preorder, postorder and inorder is to actually look at the meaning of the word itself. It\\'s always left -> right. The only position that matters is the root. Pre = before, In = in between, post = after.\\nSo, preorder becomes: root left right\\npostorder becomes: left right root\\ninorder becomes: left root right"
                    },
                    {
                        "username": "Msey",
                        "content": "But remember, the power of the Jedi Knight is the power of the universe"
                    },
                    {
                        "username": "kenzoengineer",
                        "content": "thank you daddy leetcode for giving us this question after \"Max Points on a Line\""
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@shivamgcodes](/shivamgcodes) instead of copy pasting it, atleast should have learned the brute force approach and attempted it. it doesnt take much time.. im also a beginner"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "i did not even attempt it , just copy pasted the solution will just read the solution and then implement it myself "
                    },
                    {
                        "username": "neopraveen",
                        "content": "Just a little addition for whom tree is new :\\nPreOrder Traversal -> In preorder traversal, the root node is visited first, then left subtree and then right subtree.\\nIt\\'s required simple recursive solution. You just need to add your current node in the List (it may be a class level variable) and traverse left and right node with same recursive function. That\\'s it, no more line of code is required, the same function will take care of whole tree traversal. Maybe the solution is looking very easy, but believe me it\\'s more easier than you think.\\nPS - Please don\\'t forget to check if current node is null or not, in example you can see a node with null value.\\n\\nIf I am helpful, you know how you can motivate me :)\\nHappy coding."
                    },
                    {
                        "username": "ritteh",
                        "content": "The problem statement indicates the recurrsive version is trivial. How can it be trivial for anyone who has never done trees before? There is exactly zero guidance on how to do it. What terrible training. Fortunately there is Google and I was able to solve it."
                    },
                    {
                        "username": "arthurjwannerjr",
                        "content": "I think that the problem is trivial when you\\'ve got a bit of experience under your belt. Leetcode isn\\'t really for beginners. This problem is probably one of the easiest problems on Leetcode, so relative to other problems on Leetcode, it is trivial.\\n\\nNow, with all that said, the dumb part is that the iterative solution is just as trivial as the recursive solution, for this particular problem anyways.\\n\\nFor other DFS algos such as Post Order Traversal, the iterative version is actually a lot harder than the recursive version."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Agree"
                    },
                    {
                        "username": "Mr_Fish",
                        "content": "Just out of curiosity. I am perfectly capable of coming up with BFS or DFS of traversing a tree as well as just recursion. \\n\\nWill knowing Morris Traversal help you in an interview? I mean while it has O(1) space, it actually has O(2*n) time complexity and time complexity is more significant in an interview."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "O(2 * n) is still O(n). The problem is the locality. Chasing pointers is cache-unfriendly on modern architectures, Morris traversal follows each pointer multiple times so it probably tends to be slower. But in an interview situation it depends on the interviewer. They might just want to tick boxes on a checklist (recursive: check, morris: check), they might be a show-off who tries to impress the interviewee with obscure knowlege (not good but it happens) or they might be an experienced programmer who wants to you find a reasonable solution and/or weigh the advantages/disadvantages."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-09 15.32.48.jpg](https://assets.leetcode.com/users/images/2323c791-f48e-431d-a064-499d1a314186_1673260399.4520557.jpeg)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Recursive approach is quite trivial, can you code it iteravtively!!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "use morris traversal if you want to use constant space,but if you can trade in space using stack is best."
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "stack<TreeNode*> s;\\nwhile(root || !s.empty()){\\n   if(root){\\n        res.push_back(root->val);\\n        s.push(root);\\n        root=root->left;\\n      }\\n   else{\\n        TreeNode* temp=s.top();\\n        temp=temp->right;\\n        }\\n   }\\nreturn res;"
                    },
                    {
                        "username": "nishant7372",
                        "content": "        if(root!=null)\n           stack.push(root);\n        while(!stack.isEmpty()){\n           TreeNode curr = stack.pop();\n           list.add(curr.val);\n           if(curr.right!=null)\n               stack.push(curr.right);\n           if(curr.left!=null)\n               stack.push(curr.left);\n        }"
                    },
                    {
                        "username": "tjin94",
                        "content": "as the title suggests, my code fails for this:\\n\\n[3,5,1,4,2]\\n\\ntest case(testcase66) and i have no idea how they visualize this input tree \\xA0 as the example is too short.."
                    },
                    {
                        "username": "andresstawski",
                        "content": "did you declare your vector as a global variable?"
                    },
                    {
                        "username": "llufan",
                        "content": "`const preorderTraversal = (root) => root ? [root.val, ...preorderTraversal(root.left), ...preorderTraversal(root.right)] : []`"
                    }
                ]
            },
            {
                "id": 1748954,
                "content": [
                    {
                        "username": "kontsis",
                        "content": "I remember the days when I couldn\\'t solve this. Look how far we\\'ve come."
                    },
                    {
                        "username": "miss_sunshine",
                        "content": "someday I\\'ll reach there!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "[@shivamgcodes](/shivamgcodes) there is no book like this ig but you can go to cp-alogrithms website it has all the algos but not all algos are beautiful and worth doing, like morris traversal is only worth using if you are constrained with using no extra space and already know it, but can be used to learn a new perspective on using null pointers in trees and threading.\\nalmost all sufficient algorithms are most beautifully explained in cormen but it doesn\\'t fill the criteria for what you want  but  i trust this book."
                    },
                    {
                        "username": "ankurgupta1999",
                        "content": "I remember the college days when I could solve this at a blink. Look how far I\\'ve come \\uD83E\\uDD72"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "[@Rishabh_yaduwanshi](/Rishabh_yaduwanshi) bro can u please recommend me a book which has all the algos and DS , not necessarily in depth , because being honest , i am reading the word morris traversal for the first time ."
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "i\\'m living your days right now..... hope i might solve these problems soon...!! :  )"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "I remember skipping questions that had slightest mention of tree or graph."
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "i spent a week understanding all these traversals and wasn\\'t able to grasp whole,but now even Morris traversal seems simple,keep pushing."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Yes!! Hard work pays off!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Remember : \\nPreorder Traversal : Root | Left | Right"
                    },
                    {
                        "username": "parapsychic",
                        "content": "A quick way to remember preorder, postorder and inorder is to actually look at the meaning of the word itself. It\\'s always left -> right. The only position that matters is the root. Pre = before, In = in between, post = after.\\nSo, preorder becomes: root left right\\npostorder becomes: left right root\\ninorder becomes: left root right"
                    },
                    {
                        "username": "Msey",
                        "content": "But remember, the power of the Jedi Knight is the power of the universe"
                    },
                    {
                        "username": "kenzoengineer",
                        "content": "thank you daddy leetcode for giving us this question after \"Max Points on a Line\""
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@shivamgcodes](/shivamgcodes) instead of copy pasting it, atleast should have learned the brute force approach and attempted it. it doesnt take much time.. im also a beginner"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "i did not even attempt it , just copy pasted the solution will just read the solution and then implement it myself "
                    },
                    {
                        "username": "neopraveen",
                        "content": "Just a little addition for whom tree is new :\\nPreOrder Traversal -> In preorder traversal, the root node is visited first, then left subtree and then right subtree.\\nIt\\'s required simple recursive solution. You just need to add your current node in the List (it may be a class level variable) and traverse left and right node with same recursive function. That\\'s it, no more line of code is required, the same function will take care of whole tree traversal. Maybe the solution is looking very easy, but believe me it\\'s more easier than you think.\\nPS - Please don\\'t forget to check if current node is null or not, in example you can see a node with null value.\\n\\nIf I am helpful, you know how you can motivate me :)\\nHappy coding."
                    },
                    {
                        "username": "ritteh",
                        "content": "The problem statement indicates the recurrsive version is trivial. How can it be trivial for anyone who has never done trees before? There is exactly zero guidance on how to do it. What terrible training. Fortunately there is Google and I was able to solve it."
                    },
                    {
                        "username": "arthurjwannerjr",
                        "content": "I think that the problem is trivial when you\\'ve got a bit of experience under your belt. Leetcode isn\\'t really for beginners. This problem is probably one of the easiest problems on Leetcode, so relative to other problems on Leetcode, it is trivial.\\n\\nNow, with all that said, the dumb part is that the iterative solution is just as trivial as the recursive solution, for this particular problem anyways.\\n\\nFor other DFS algos such as Post Order Traversal, the iterative version is actually a lot harder than the recursive version."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Agree"
                    },
                    {
                        "username": "Mr_Fish",
                        "content": "Just out of curiosity. I am perfectly capable of coming up with BFS or DFS of traversing a tree as well as just recursion. \\n\\nWill knowing Morris Traversal help you in an interview? I mean while it has O(1) space, it actually has O(2*n) time complexity and time complexity is more significant in an interview."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "O(2 * n) is still O(n). The problem is the locality. Chasing pointers is cache-unfriendly on modern architectures, Morris traversal follows each pointer multiple times so it probably tends to be slower. But in an interview situation it depends on the interviewer. They might just want to tick boxes on a checklist (recursive: check, morris: check), they might be a show-off who tries to impress the interviewee with obscure knowlege (not good but it happens) or they might be an experienced programmer who wants to you find a reasonable solution and/or weigh the advantages/disadvantages."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-09 15.32.48.jpg](https://assets.leetcode.com/users/images/2323c791-f48e-431d-a064-499d1a314186_1673260399.4520557.jpeg)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Recursive approach is quite trivial, can you code it iteravtively!!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "use morris traversal if you want to use constant space,but if you can trade in space using stack is best."
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "stack<TreeNode*> s;\\nwhile(root || !s.empty()){\\n   if(root){\\n        res.push_back(root->val);\\n        s.push(root);\\n        root=root->left;\\n      }\\n   else{\\n        TreeNode* temp=s.top();\\n        temp=temp->right;\\n        }\\n   }\\nreturn res;"
                    },
                    {
                        "username": "nishant7372",
                        "content": "        if(root!=null)\n           stack.push(root);\n        while(!stack.isEmpty()){\n           TreeNode curr = stack.pop();\n           list.add(curr.val);\n           if(curr.right!=null)\n               stack.push(curr.right);\n           if(curr.left!=null)\n               stack.push(curr.left);\n        }"
                    },
                    {
                        "username": "tjin94",
                        "content": "as the title suggests, my code fails for this:\\n\\n[3,5,1,4,2]\\n\\ntest case(testcase66) and i have no idea how they visualize this input tree \\xA0 as the example is too short.."
                    },
                    {
                        "username": "andresstawski",
                        "content": "did you declare your vector as a global variable?"
                    },
                    {
                        "username": "llufan",
                        "content": "`const preorderTraversal = (root) => root ? [root.val, ...preorderTraversal(root.left), ...preorderTraversal(root.right)] : []`"
                    }
                ]
            },
            {
                "id": 1748997,
                "content": [
                    {
                        "username": "kontsis",
                        "content": "I remember the days when I couldn\\'t solve this. Look how far we\\'ve come."
                    },
                    {
                        "username": "miss_sunshine",
                        "content": "someday I\\'ll reach there!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "[@shivamgcodes](/shivamgcodes) there is no book like this ig but you can go to cp-alogrithms website it has all the algos but not all algos are beautiful and worth doing, like morris traversal is only worth using if you are constrained with using no extra space and already know it, but can be used to learn a new perspective on using null pointers in trees and threading.\\nalmost all sufficient algorithms are most beautifully explained in cormen but it doesn\\'t fill the criteria for what you want  but  i trust this book."
                    },
                    {
                        "username": "ankurgupta1999",
                        "content": "I remember the college days when I could solve this at a blink. Look how far I\\'ve come \\uD83E\\uDD72"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "[@Rishabh_yaduwanshi](/Rishabh_yaduwanshi) bro can u please recommend me a book which has all the algos and DS , not necessarily in depth , because being honest , i am reading the word morris traversal for the first time ."
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "i\\'m living your days right now..... hope i might solve these problems soon...!! :  )"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "I remember skipping questions that had slightest mention of tree or graph."
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "i spent a week understanding all these traversals and wasn\\'t able to grasp whole,but now even Morris traversal seems simple,keep pushing."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Yes!! Hard work pays off!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Remember : \\nPreorder Traversal : Root | Left | Right"
                    },
                    {
                        "username": "parapsychic",
                        "content": "A quick way to remember preorder, postorder and inorder is to actually look at the meaning of the word itself. It\\'s always left -> right. The only position that matters is the root. Pre = before, In = in between, post = after.\\nSo, preorder becomes: root left right\\npostorder becomes: left right root\\ninorder becomes: left root right"
                    },
                    {
                        "username": "Msey",
                        "content": "But remember, the power of the Jedi Knight is the power of the universe"
                    },
                    {
                        "username": "kenzoengineer",
                        "content": "thank you daddy leetcode for giving us this question after \"Max Points on a Line\""
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@shivamgcodes](/shivamgcodes) instead of copy pasting it, atleast should have learned the brute force approach and attempted it. it doesnt take much time.. im also a beginner"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "i did not even attempt it , just copy pasted the solution will just read the solution and then implement it myself "
                    },
                    {
                        "username": "neopraveen",
                        "content": "Just a little addition for whom tree is new :\\nPreOrder Traversal -> In preorder traversal, the root node is visited first, then left subtree and then right subtree.\\nIt\\'s required simple recursive solution. You just need to add your current node in the List (it may be a class level variable) and traverse left and right node with same recursive function. That\\'s it, no more line of code is required, the same function will take care of whole tree traversal. Maybe the solution is looking very easy, but believe me it\\'s more easier than you think.\\nPS - Please don\\'t forget to check if current node is null or not, in example you can see a node with null value.\\n\\nIf I am helpful, you know how you can motivate me :)\\nHappy coding."
                    },
                    {
                        "username": "ritteh",
                        "content": "The problem statement indicates the recurrsive version is trivial. How can it be trivial for anyone who has never done trees before? There is exactly zero guidance on how to do it. What terrible training. Fortunately there is Google and I was able to solve it."
                    },
                    {
                        "username": "arthurjwannerjr",
                        "content": "I think that the problem is trivial when you\\'ve got a bit of experience under your belt. Leetcode isn\\'t really for beginners. This problem is probably one of the easiest problems on Leetcode, so relative to other problems on Leetcode, it is trivial.\\n\\nNow, with all that said, the dumb part is that the iterative solution is just as trivial as the recursive solution, for this particular problem anyways.\\n\\nFor other DFS algos such as Post Order Traversal, the iterative version is actually a lot harder than the recursive version."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Agree"
                    },
                    {
                        "username": "Mr_Fish",
                        "content": "Just out of curiosity. I am perfectly capable of coming up with BFS or DFS of traversing a tree as well as just recursion. \\n\\nWill knowing Morris Traversal help you in an interview? I mean while it has O(1) space, it actually has O(2*n) time complexity and time complexity is more significant in an interview."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "O(2 * n) is still O(n). The problem is the locality. Chasing pointers is cache-unfriendly on modern architectures, Morris traversal follows each pointer multiple times so it probably tends to be slower. But in an interview situation it depends on the interviewer. They might just want to tick boxes on a checklist (recursive: check, morris: check), they might be a show-off who tries to impress the interviewee with obscure knowlege (not good but it happens) or they might be an experienced programmer who wants to you find a reasonable solution and/or weigh the advantages/disadvantages."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-09 15.32.48.jpg](https://assets.leetcode.com/users/images/2323c791-f48e-431d-a064-499d1a314186_1673260399.4520557.jpeg)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Recursive approach is quite trivial, can you code it iteravtively!!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "use morris traversal if you want to use constant space,but if you can trade in space using stack is best."
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "stack<TreeNode*> s;\\nwhile(root || !s.empty()){\\n   if(root){\\n        res.push_back(root->val);\\n        s.push(root);\\n        root=root->left;\\n      }\\n   else{\\n        TreeNode* temp=s.top();\\n        temp=temp->right;\\n        }\\n   }\\nreturn res;"
                    },
                    {
                        "username": "nishant7372",
                        "content": "        if(root!=null)\n           stack.push(root);\n        while(!stack.isEmpty()){\n           TreeNode curr = stack.pop();\n           list.add(curr.val);\n           if(curr.right!=null)\n               stack.push(curr.right);\n           if(curr.left!=null)\n               stack.push(curr.left);\n        }"
                    },
                    {
                        "username": "tjin94",
                        "content": "as the title suggests, my code fails for this:\\n\\n[3,5,1,4,2]\\n\\ntest case(testcase66) and i have no idea how they visualize this input tree \\xA0 as the example is too short.."
                    },
                    {
                        "username": "andresstawski",
                        "content": "did you declare your vector as a global variable?"
                    },
                    {
                        "username": "llufan",
                        "content": "`const preorderTraversal = (root) => root ? [root.val, ...preorderTraversal(root.left), ...preorderTraversal(root.right)] : []`"
                    }
                ]
            },
            {
                "id": 1748979,
                "content": [
                    {
                        "username": "kontsis",
                        "content": "I remember the days when I couldn\\'t solve this. Look how far we\\'ve come."
                    },
                    {
                        "username": "miss_sunshine",
                        "content": "someday I\\'ll reach there!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "[@shivamgcodes](/shivamgcodes) there is no book like this ig but you can go to cp-alogrithms website it has all the algos but not all algos are beautiful and worth doing, like morris traversal is only worth using if you are constrained with using no extra space and already know it, but can be used to learn a new perspective on using null pointers in trees and threading.\\nalmost all sufficient algorithms are most beautifully explained in cormen but it doesn\\'t fill the criteria for what you want  but  i trust this book."
                    },
                    {
                        "username": "ankurgupta1999",
                        "content": "I remember the college days when I could solve this at a blink. Look how far I\\'ve come \\uD83E\\uDD72"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "[@Rishabh_yaduwanshi](/Rishabh_yaduwanshi) bro can u please recommend me a book which has all the algos and DS , not necessarily in depth , because being honest , i am reading the word morris traversal for the first time ."
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "i\\'m living your days right now..... hope i might solve these problems soon...!! :  )"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "I remember skipping questions that had slightest mention of tree or graph."
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "i spent a week understanding all these traversals and wasn\\'t able to grasp whole,but now even Morris traversal seems simple,keep pushing."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Yes!! Hard work pays off!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Remember : \\nPreorder Traversal : Root | Left | Right"
                    },
                    {
                        "username": "parapsychic",
                        "content": "A quick way to remember preorder, postorder and inorder is to actually look at the meaning of the word itself. It\\'s always left -> right. The only position that matters is the root. Pre = before, In = in between, post = after.\\nSo, preorder becomes: root left right\\npostorder becomes: left right root\\ninorder becomes: left root right"
                    },
                    {
                        "username": "Msey",
                        "content": "But remember, the power of the Jedi Knight is the power of the universe"
                    },
                    {
                        "username": "kenzoengineer",
                        "content": "thank you daddy leetcode for giving us this question after \"Max Points on a Line\""
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@shivamgcodes](/shivamgcodes) instead of copy pasting it, atleast should have learned the brute force approach and attempted it. it doesnt take much time.. im also a beginner"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "i did not even attempt it , just copy pasted the solution will just read the solution and then implement it myself "
                    },
                    {
                        "username": "neopraveen",
                        "content": "Just a little addition for whom tree is new :\\nPreOrder Traversal -> In preorder traversal, the root node is visited first, then left subtree and then right subtree.\\nIt\\'s required simple recursive solution. You just need to add your current node in the List (it may be a class level variable) and traverse left and right node with same recursive function. That\\'s it, no more line of code is required, the same function will take care of whole tree traversal. Maybe the solution is looking very easy, but believe me it\\'s more easier than you think.\\nPS - Please don\\'t forget to check if current node is null or not, in example you can see a node with null value.\\n\\nIf I am helpful, you know how you can motivate me :)\\nHappy coding."
                    },
                    {
                        "username": "ritteh",
                        "content": "The problem statement indicates the recurrsive version is trivial. How can it be trivial for anyone who has never done trees before? There is exactly zero guidance on how to do it. What terrible training. Fortunately there is Google and I was able to solve it."
                    },
                    {
                        "username": "arthurjwannerjr",
                        "content": "I think that the problem is trivial when you\\'ve got a bit of experience under your belt. Leetcode isn\\'t really for beginners. This problem is probably one of the easiest problems on Leetcode, so relative to other problems on Leetcode, it is trivial.\\n\\nNow, with all that said, the dumb part is that the iterative solution is just as trivial as the recursive solution, for this particular problem anyways.\\n\\nFor other DFS algos such as Post Order Traversal, the iterative version is actually a lot harder than the recursive version."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Agree"
                    },
                    {
                        "username": "Mr_Fish",
                        "content": "Just out of curiosity. I am perfectly capable of coming up with BFS or DFS of traversing a tree as well as just recursion. \\n\\nWill knowing Morris Traversal help you in an interview? I mean while it has O(1) space, it actually has O(2*n) time complexity and time complexity is more significant in an interview."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "O(2 * n) is still O(n). The problem is the locality. Chasing pointers is cache-unfriendly on modern architectures, Morris traversal follows each pointer multiple times so it probably tends to be slower. But in an interview situation it depends on the interviewer. They might just want to tick boxes on a checklist (recursive: check, morris: check), they might be a show-off who tries to impress the interviewee with obscure knowlege (not good but it happens) or they might be an experienced programmer who wants to you find a reasonable solution and/or weigh the advantages/disadvantages."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-09 15.32.48.jpg](https://assets.leetcode.com/users/images/2323c791-f48e-431d-a064-499d1a314186_1673260399.4520557.jpeg)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Recursive approach is quite trivial, can you code it iteravtively!!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "use morris traversal if you want to use constant space,but if you can trade in space using stack is best."
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "stack<TreeNode*> s;\\nwhile(root || !s.empty()){\\n   if(root){\\n        res.push_back(root->val);\\n        s.push(root);\\n        root=root->left;\\n      }\\n   else{\\n        TreeNode* temp=s.top();\\n        temp=temp->right;\\n        }\\n   }\\nreturn res;"
                    },
                    {
                        "username": "nishant7372",
                        "content": "        if(root!=null)\n           stack.push(root);\n        while(!stack.isEmpty()){\n           TreeNode curr = stack.pop();\n           list.add(curr.val);\n           if(curr.right!=null)\n               stack.push(curr.right);\n           if(curr.left!=null)\n               stack.push(curr.left);\n        }"
                    },
                    {
                        "username": "tjin94",
                        "content": "as the title suggests, my code fails for this:\\n\\n[3,5,1,4,2]\\n\\ntest case(testcase66) and i have no idea how they visualize this input tree \\xA0 as the example is too short.."
                    },
                    {
                        "username": "andresstawski",
                        "content": "did you declare your vector as a global variable?"
                    },
                    {
                        "username": "llufan",
                        "content": "`const preorderTraversal = (root) => root ? [root.val, ...preorderTraversal(root.left), ...preorderTraversal(root.right)] : []`"
                    }
                ]
            },
            {
                "id": 1749377,
                "content": [
                    {
                        "username": "kontsis",
                        "content": "I remember the days when I couldn\\'t solve this. Look how far we\\'ve come."
                    },
                    {
                        "username": "miss_sunshine",
                        "content": "someday I\\'ll reach there!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "[@shivamgcodes](/shivamgcodes) there is no book like this ig but you can go to cp-alogrithms website it has all the algos but not all algos are beautiful and worth doing, like morris traversal is only worth using if you are constrained with using no extra space and already know it, but can be used to learn a new perspective on using null pointers in trees and threading.\\nalmost all sufficient algorithms are most beautifully explained in cormen but it doesn\\'t fill the criteria for what you want  but  i trust this book."
                    },
                    {
                        "username": "ankurgupta1999",
                        "content": "I remember the college days when I could solve this at a blink. Look how far I\\'ve come \\uD83E\\uDD72"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "[@Rishabh_yaduwanshi](/Rishabh_yaduwanshi) bro can u please recommend me a book which has all the algos and DS , not necessarily in depth , because being honest , i am reading the word morris traversal for the first time ."
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "i\\'m living your days right now..... hope i might solve these problems soon...!! :  )"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "I remember skipping questions that had slightest mention of tree or graph."
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "i spent a week understanding all these traversals and wasn\\'t able to grasp whole,but now even Morris traversal seems simple,keep pushing."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Yes!! Hard work pays off!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Remember : \\nPreorder Traversal : Root | Left | Right"
                    },
                    {
                        "username": "parapsychic",
                        "content": "A quick way to remember preorder, postorder and inorder is to actually look at the meaning of the word itself. It\\'s always left -> right. The only position that matters is the root. Pre = before, In = in between, post = after.\\nSo, preorder becomes: root left right\\npostorder becomes: left right root\\ninorder becomes: left root right"
                    },
                    {
                        "username": "Msey",
                        "content": "But remember, the power of the Jedi Knight is the power of the universe"
                    },
                    {
                        "username": "kenzoengineer",
                        "content": "thank you daddy leetcode for giving us this question after \"Max Points on a Line\""
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@shivamgcodes](/shivamgcodes) instead of copy pasting it, atleast should have learned the brute force approach and attempted it. it doesnt take much time.. im also a beginner"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "i did not even attempt it , just copy pasted the solution will just read the solution and then implement it myself "
                    },
                    {
                        "username": "neopraveen",
                        "content": "Just a little addition for whom tree is new :\\nPreOrder Traversal -> In preorder traversal, the root node is visited first, then left subtree and then right subtree.\\nIt\\'s required simple recursive solution. You just need to add your current node in the List (it may be a class level variable) and traverse left and right node with same recursive function. That\\'s it, no more line of code is required, the same function will take care of whole tree traversal. Maybe the solution is looking very easy, but believe me it\\'s more easier than you think.\\nPS - Please don\\'t forget to check if current node is null or not, in example you can see a node with null value.\\n\\nIf I am helpful, you know how you can motivate me :)\\nHappy coding."
                    },
                    {
                        "username": "ritteh",
                        "content": "The problem statement indicates the recurrsive version is trivial. How can it be trivial for anyone who has never done trees before? There is exactly zero guidance on how to do it. What terrible training. Fortunately there is Google and I was able to solve it."
                    },
                    {
                        "username": "arthurjwannerjr",
                        "content": "I think that the problem is trivial when you\\'ve got a bit of experience under your belt. Leetcode isn\\'t really for beginners. This problem is probably one of the easiest problems on Leetcode, so relative to other problems on Leetcode, it is trivial.\\n\\nNow, with all that said, the dumb part is that the iterative solution is just as trivial as the recursive solution, for this particular problem anyways.\\n\\nFor other DFS algos such as Post Order Traversal, the iterative version is actually a lot harder than the recursive version."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Agree"
                    },
                    {
                        "username": "Mr_Fish",
                        "content": "Just out of curiosity. I am perfectly capable of coming up with BFS or DFS of traversing a tree as well as just recursion. \\n\\nWill knowing Morris Traversal help you in an interview? I mean while it has O(1) space, it actually has O(2*n) time complexity and time complexity is more significant in an interview."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "O(2 * n) is still O(n). The problem is the locality. Chasing pointers is cache-unfriendly on modern architectures, Morris traversal follows each pointer multiple times so it probably tends to be slower. But in an interview situation it depends on the interviewer. They might just want to tick boxes on a checklist (recursive: check, morris: check), they might be a show-off who tries to impress the interviewee with obscure knowlege (not good but it happens) or they might be an experienced programmer who wants to you find a reasonable solution and/or weigh the advantages/disadvantages."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-09 15.32.48.jpg](https://assets.leetcode.com/users/images/2323c791-f48e-431d-a064-499d1a314186_1673260399.4520557.jpeg)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Recursive approach is quite trivial, can you code it iteravtively!!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "use morris traversal if you want to use constant space,but if you can trade in space using stack is best."
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "stack<TreeNode*> s;\\nwhile(root || !s.empty()){\\n   if(root){\\n        res.push_back(root->val);\\n        s.push(root);\\n        root=root->left;\\n      }\\n   else{\\n        TreeNode* temp=s.top();\\n        temp=temp->right;\\n        }\\n   }\\nreturn res;"
                    },
                    {
                        "username": "nishant7372",
                        "content": "        if(root!=null)\n           stack.push(root);\n        while(!stack.isEmpty()){\n           TreeNode curr = stack.pop();\n           list.add(curr.val);\n           if(curr.right!=null)\n               stack.push(curr.right);\n           if(curr.left!=null)\n               stack.push(curr.left);\n        }"
                    },
                    {
                        "username": "tjin94",
                        "content": "as the title suggests, my code fails for this:\\n\\n[3,5,1,4,2]\\n\\ntest case(testcase66) and i have no idea how they visualize this input tree \\xA0 as the example is too short.."
                    },
                    {
                        "username": "andresstawski",
                        "content": "did you declare your vector as a global variable?"
                    },
                    {
                        "username": "llufan",
                        "content": "`const preorderTraversal = (root) => root ? [root.val, ...preorderTraversal(root.left), ...preorderTraversal(root.right)] : []`"
                    }
                ]
            },
            {
                "id": 1570384,
                "content": [
                    {
                        "username": "kontsis",
                        "content": "I remember the days when I couldn\\'t solve this. Look how far we\\'ve come."
                    },
                    {
                        "username": "miss_sunshine",
                        "content": "someday I\\'ll reach there!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "[@shivamgcodes](/shivamgcodes) there is no book like this ig but you can go to cp-alogrithms website it has all the algos but not all algos are beautiful and worth doing, like morris traversal is only worth using if you are constrained with using no extra space and already know it, but can be used to learn a new perspective on using null pointers in trees and threading.\\nalmost all sufficient algorithms are most beautifully explained in cormen but it doesn\\'t fill the criteria for what you want  but  i trust this book."
                    },
                    {
                        "username": "ankurgupta1999",
                        "content": "I remember the college days when I could solve this at a blink. Look how far I\\'ve come \\uD83E\\uDD72"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "[@Rishabh_yaduwanshi](/Rishabh_yaduwanshi) bro can u please recommend me a book which has all the algos and DS , not necessarily in depth , because being honest , i am reading the word morris traversal for the first time ."
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "i\\'m living your days right now..... hope i might solve these problems soon...!! :  )"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "I remember skipping questions that had slightest mention of tree or graph."
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "i spent a week understanding all these traversals and wasn\\'t able to grasp whole,but now even Morris traversal seems simple,keep pushing."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Yes!! Hard work pays off!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Remember : \\nPreorder Traversal : Root | Left | Right"
                    },
                    {
                        "username": "parapsychic",
                        "content": "A quick way to remember preorder, postorder and inorder is to actually look at the meaning of the word itself. It\\'s always left -> right. The only position that matters is the root. Pre = before, In = in between, post = after.\\nSo, preorder becomes: root left right\\npostorder becomes: left right root\\ninorder becomes: left root right"
                    },
                    {
                        "username": "Msey",
                        "content": "But remember, the power of the Jedi Knight is the power of the universe"
                    },
                    {
                        "username": "kenzoengineer",
                        "content": "thank you daddy leetcode for giving us this question after \"Max Points on a Line\""
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@shivamgcodes](/shivamgcodes) instead of copy pasting it, atleast should have learned the brute force approach and attempted it. it doesnt take much time.. im also a beginner"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "i did not even attempt it , just copy pasted the solution will just read the solution and then implement it myself "
                    },
                    {
                        "username": "neopraveen",
                        "content": "Just a little addition for whom tree is new :\\nPreOrder Traversal -> In preorder traversal, the root node is visited first, then left subtree and then right subtree.\\nIt\\'s required simple recursive solution. You just need to add your current node in the List (it may be a class level variable) and traverse left and right node with same recursive function. That\\'s it, no more line of code is required, the same function will take care of whole tree traversal. Maybe the solution is looking very easy, but believe me it\\'s more easier than you think.\\nPS - Please don\\'t forget to check if current node is null or not, in example you can see a node with null value.\\n\\nIf I am helpful, you know how you can motivate me :)\\nHappy coding."
                    },
                    {
                        "username": "ritteh",
                        "content": "The problem statement indicates the recurrsive version is trivial. How can it be trivial for anyone who has never done trees before? There is exactly zero guidance on how to do it. What terrible training. Fortunately there is Google and I was able to solve it."
                    },
                    {
                        "username": "arthurjwannerjr",
                        "content": "I think that the problem is trivial when you\\'ve got a bit of experience under your belt. Leetcode isn\\'t really for beginners. This problem is probably one of the easiest problems on Leetcode, so relative to other problems on Leetcode, it is trivial.\\n\\nNow, with all that said, the dumb part is that the iterative solution is just as trivial as the recursive solution, for this particular problem anyways.\\n\\nFor other DFS algos such as Post Order Traversal, the iterative version is actually a lot harder than the recursive version."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Agree"
                    },
                    {
                        "username": "Mr_Fish",
                        "content": "Just out of curiosity. I am perfectly capable of coming up with BFS or DFS of traversing a tree as well as just recursion. \\n\\nWill knowing Morris Traversal help you in an interview? I mean while it has O(1) space, it actually has O(2*n) time complexity and time complexity is more significant in an interview."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "O(2 * n) is still O(n). The problem is the locality. Chasing pointers is cache-unfriendly on modern architectures, Morris traversal follows each pointer multiple times so it probably tends to be slower. But in an interview situation it depends on the interviewer. They might just want to tick boxes on a checklist (recursive: check, morris: check), they might be a show-off who tries to impress the interviewee with obscure knowlege (not good but it happens) or they might be an experienced programmer who wants to you find a reasonable solution and/or weigh the advantages/disadvantages."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-09 15.32.48.jpg](https://assets.leetcode.com/users/images/2323c791-f48e-431d-a064-499d1a314186_1673260399.4520557.jpeg)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Recursive approach is quite trivial, can you code it iteravtively!!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "use morris traversal if you want to use constant space,but if you can trade in space using stack is best."
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "stack<TreeNode*> s;\\nwhile(root || !s.empty()){\\n   if(root){\\n        res.push_back(root->val);\\n        s.push(root);\\n        root=root->left;\\n      }\\n   else{\\n        TreeNode* temp=s.top();\\n        temp=temp->right;\\n        }\\n   }\\nreturn res;"
                    },
                    {
                        "username": "nishant7372",
                        "content": "        if(root!=null)\n           stack.push(root);\n        while(!stack.isEmpty()){\n           TreeNode curr = stack.pop();\n           list.add(curr.val);\n           if(curr.right!=null)\n               stack.push(curr.right);\n           if(curr.left!=null)\n               stack.push(curr.left);\n        }"
                    },
                    {
                        "username": "tjin94",
                        "content": "as the title suggests, my code fails for this:\\n\\n[3,5,1,4,2]\\n\\ntest case(testcase66) and i have no idea how they visualize this input tree \\xA0 as the example is too short.."
                    },
                    {
                        "username": "andresstawski",
                        "content": "did you declare your vector as a global variable?"
                    },
                    {
                        "username": "llufan",
                        "content": "`const preorderTraversal = (root) => root ? [root.val, ...preorderTraversal(root.left), ...preorderTraversal(root.right)] : []`"
                    }
                ]
            },
            {
                "id": 1565777,
                "content": [
                    {
                        "username": "kontsis",
                        "content": "I remember the days when I couldn\\'t solve this. Look how far we\\'ve come."
                    },
                    {
                        "username": "miss_sunshine",
                        "content": "someday I\\'ll reach there!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "[@shivamgcodes](/shivamgcodes) there is no book like this ig but you can go to cp-alogrithms website it has all the algos but not all algos are beautiful and worth doing, like morris traversal is only worth using if you are constrained with using no extra space and already know it, but can be used to learn a new perspective on using null pointers in trees and threading.\\nalmost all sufficient algorithms are most beautifully explained in cormen but it doesn\\'t fill the criteria for what you want  but  i trust this book."
                    },
                    {
                        "username": "ankurgupta1999",
                        "content": "I remember the college days when I could solve this at a blink. Look how far I\\'ve come \\uD83E\\uDD72"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "[@Rishabh_yaduwanshi](/Rishabh_yaduwanshi) bro can u please recommend me a book which has all the algos and DS , not necessarily in depth , because being honest , i am reading the word morris traversal for the first time ."
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "i\\'m living your days right now..... hope i might solve these problems soon...!! :  )"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "I remember skipping questions that had slightest mention of tree or graph."
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "i spent a week understanding all these traversals and wasn\\'t able to grasp whole,but now even Morris traversal seems simple,keep pushing."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Yes!! Hard work pays off!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Remember : \\nPreorder Traversal : Root | Left | Right"
                    },
                    {
                        "username": "parapsychic",
                        "content": "A quick way to remember preorder, postorder and inorder is to actually look at the meaning of the word itself. It\\'s always left -> right. The only position that matters is the root. Pre = before, In = in between, post = after.\\nSo, preorder becomes: root left right\\npostorder becomes: left right root\\ninorder becomes: left root right"
                    },
                    {
                        "username": "Msey",
                        "content": "But remember, the power of the Jedi Knight is the power of the universe"
                    },
                    {
                        "username": "kenzoengineer",
                        "content": "thank you daddy leetcode for giving us this question after \"Max Points on a Line\""
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@shivamgcodes](/shivamgcodes) instead of copy pasting it, atleast should have learned the brute force approach and attempted it. it doesnt take much time.. im also a beginner"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "i did not even attempt it , just copy pasted the solution will just read the solution and then implement it myself "
                    },
                    {
                        "username": "neopraveen",
                        "content": "Just a little addition for whom tree is new :\\nPreOrder Traversal -> In preorder traversal, the root node is visited first, then left subtree and then right subtree.\\nIt\\'s required simple recursive solution. You just need to add your current node in the List (it may be a class level variable) and traverse left and right node with same recursive function. That\\'s it, no more line of code is required, the same function will take care of whole tree traversal. Maybe the solution is looking very easy, but believe me it\\'s more easier than you think.\\nPS - Please don\\'t forget to check if current node is null or not, in example you can see a node with null value.\\n\\nIf I am helpful, you know how you can motivate me :)\\nHappy coding."
                    },
                    {
                        "username": "ritteh",
                        "content": "The problem statement indicates the recurrsive version is trivial. How can it be trivial for anyone who has never done trees before? There is exactly zero guidance on how to do it. What terrible training. Fortunately there is Google and I was able to solve it."
                    },
                    {
                        "username": "arthurjwannerjr",
                        "content": "I think that the problem is trivial when you\\'ve got a bit of experience under your belt. Leetcode isn\\'t really for beginners. This problem is probably one of the easiest problems on Leetcode, so relative to other problems on Leetcode, it is trivial.\\n\\nNow, with all that said, the dumb part is that the iterative solution is just as trivial as the recursive solution, for this particular problem anyways.\\n\\nFor other DFS algos such as Post Order Traversal, the iterative version is actually a lot harder than the recursive version."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Agree"
                    },
                    {
                        "username": "Mr_Fish",
                        "content": "Just out of curiosity. I am perfectly capable of coming up with BFS or DFS of traversing a tree as well as just recursion. \\n\\nWill knowing Morris Traversal help you in an interview? I mean while it has O(1) space, it actually has O(2*n) time complexity and time complexity is more significant in an interview."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "O(2 * n) is still O(n). The problem is the locality. Chasing pointers is cache-unfriendly on modern architectures, Morris traversal follows each pointer multiple times so it probably tends to be slower. But in an interview situation it depends on the interviewer. They might just want to tick boxes on a checklist (recursive: check, morris: check), they might be a show-off who tries to impress the interviewee with obscure knowlege (not good but it happens) or they might be an experienced programmer who wants to you find a reasonable solution and/or weigh the advantages/disadvantages."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-09 15.32.48.jpg](https://assets.leetcode.com/users/images/2323c791-f48e-431d-a064-499d1a314186_1673260399.4520557.jpeg)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Recursive approach is quite trivial, can you code it iteravtively!!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "use morris traversal if you want to use constant space,but if you can trade in space using stack is best."
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "stack<TreeNode*> s;\\nwhile(root || !s.empty()){\\n   if(root){\\n        res.push_back(root->val);\\n        s.push(root);\\n        root=root->left;\\n      }\\n   else{\\n        TreeNode* temp=s.top();\\n        temp=temp->right;\\n        }\\n   }\\nreturn res;"
                    },
                    {
                        "username": "nishant7372",
                        "content": "        if(root!=null)\n           stack.push(root);\n        while(!stack.isEmpty()){\n           TreeNode curr = stack.pop();\n           list.add(curr.val);\n           if(curr.right!=null)\n               stack.push(curr.right);\n           if(curr.left!=null)\n               stack.push(curr.left);\n        }"
                    },
                    {
                        "username": "tjin94",
                        "content": "as the title suggests, my code fails for this:\\n\\n[3,5,1,4,2]\\n\\ntest case(testcase66) and i have no idea how they visualize this input tree \\xA0 as the example is too short.."
                    },
                    {
                        "username": "andresstawski",
                        "content": "did you declare your vector as a global variable?"
                    },
                    {
                        "username": "llufan",
                        "content": "`const preorderTraversal = (root) => root ? [root.val, ...preorderTraversal(root.left), ...preorderTraversal(root.right)] : []`"
                    }
                ]
            },
            {
                "id": 1749643,
                "content": [
                    {
                        "username": "kontsis",
                        "content": "I remember the days when I couldn\\'t solve this. Look how far we\\'ve come."
                    },
                    {
                        "username": "miss_sunshine",
                        "content": "someday I\\'ll reach there!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "[@shivamgcodes](/shivamgcodes) there is no book like this ig but you can go to cp-alogrithms website it has all the algos but not all algos are beautiful and worth doing, like morris traversal is only worth using if you are constrained with using no extra space and already know it, but can be used to learn a new perspective on using null pointers in trees and threading.\\nalmost all sufficient algorithms are most beautifully explained in cormen but it doesn\\'t fill the criteria for what you want  but  i trust this book."
                    },
                    {
                        "username": "ankurgupta1999",
                        "content": "I remember the college days when I could solve this at a blink. Look how far I\\'ve come \\uD83E\\uDD72"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "[@Rishabh_yaduwanshi](/Rishabh_yaduwanshi) bro can u please recommend me a book which has all the algos and DS , not necessarily in depth , because being honest , i am reading the word morris traversal for the first time ."
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "i\\'m living your days right now..... hope i might solve these problems soon...!! :  )"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "I remember skipping questions that had slightest mention of tree or graph."
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "i spent a week understanding all these traversals and wasn\\'t able to grasp whole,but now even Morris traversal seems simple,keep pushing."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Yes!! Hard work pays off!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Remember : \\nPreorder Traversal : Root | Left | Right"
                    },
                    {
                        "username": "parapsychic",
                        "content": "A quick way to remember preorder, postorder and inorder is to actually look at the meaning of the word itself. It\\'s always left -> right. The only position that matters is the root. Pre = before, In = in between, post = after.\\nSo, preorder becomes: root left right\\npostorder becomes: left right root\\ninorder becomes: left root right"
                    },
                    {
                        "username": "Msey",
                        "content": "But remember, the power of the Jedi Knight is the power of the universe"
                    },
                    {
                        "username": "kenzoengineer",
                        "content": "thank you daddy leetcode for giving us this question after \"Max Points on a Line\""
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@shivamgcodes](/shivamgcodes) instead of copy pasting it, atleast should have learned the brute force approach and attempted it. it doesnt take much time.. im also a beginner"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "i did not even attempt it , just copy pasted the solution will just read the solution and then implement it myself "
                    },
                    {
                        "username": "neopraveen",
                        "content": "Just a little addition for whom tree is new :\\nPreOrder Traversal -> In preorder traversal, the root node is visited first, then left subtree and then right subtree.\\nIt\\'s required simple recursive solution. You just need to add your current node in the List (it may be a class level variable) and traverse left and right node with same recursive function. That\\'s it, no more line of code is required, the same function will take care of whole tree traversal. Maybe the solution is looking very easy, but believe me it\\'s more easier than you think.\\nPS - Please don\\'t forget to check if current node is null or not, in example you can see a node with null value.\\n\\nIf I am helpful, you know how you can motivate me :)\\nHappy coding."
                    },
                    {
                        "username": "ritteh",
                        "content": "The problem statement indicates the recurrsive version is trivial. How can it be trivial for anyone who has never done trees before? There is exactly zero guidance on how to do it. What terrible training. Fortunately there is Google and I was able to solve it."
                    },
                    {
                        "username": "arthurjwannerjr",
                        "content": "I think that the problem is trivial when you\\'ve got a bit of experience under your belt. Leetcode isn\\'t really for beginners. This problem is probably one of the easiest problems on Leetcode, so relative to other problems on Leetcode, it is trivial.\\n\\nNow, with all that said, the dumb part is that the iterative solution is just as trivial as the recursive solution, for this particular problem anyways.\\n\\nFor other DFS algos such as Post Order Traversal, the iterative version is actually a lot harder than the recursive version."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Agree"
                    },
                    {
                        "username": "Mr_Fish",
                        "content": "Just out of curiosity. I am perfectly capable of coming up with BFS or DFS of traversing a tree as well as just recursion. \\n\\nWill knowing Morris Traversal help you in an interview? I mean while it has O(1) space, it actually has O(2*n) time complexity and time complexity is more significant in an interview."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "O(2 * n) is still O(n). The problem is the locality. Chasing pointers is cache-unfriendly on modern architectures, Morris traversal follows each pointer multiple times so it probably tends to be slower. But in an interview situation it depends on the interviewer. They might just want to tick boxes on a checklist (recursive: check, morris: check), they might be a show-off who tries to impress the interviewee with obscure knowlege (not good but it happens) or they might be an experienced programmer who wants to you find a reasonable solution and/or weigh the advantages/disadvantages."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-09 15.32.48.jpg](https://assets.leetcode.com/users/images/2323c791-f48e-431d-a064-499d1a314186_1673260399.4520557.jpeg)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Recursive approach is quite trivial, can you code it iteravtively!!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "use morris traversal if you want to use constant space,but if you can trade in space using stack is best."
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "stack<TreeNode*> s;\\nwhile(root || !s.empty()){\\n   if(root){\\n        res.push_back(root->val);\\n        s.push(root);\\n        root=root->left;\\n      }\\n   else{\\n        TreeNode* temp=s.top();\\n        temp=temp->right;\\n        }\\n   }\\nreturn res;"
                    },
                    {
                        "username": "nishant7372",
                        "content": "        if(root!=null)\n           stack.push(root);\n        while(!stack.isEmpty()){\n           TreeNode curr = stack.pop();\n           list.add(curr.val);\n           if(curr.right!=null)\n               stack.push(curr.right);\n           if(curr.left!=null)\n               stack.push(curr.left);\n        }"
                    },
                    {
                        "username": "tjin94",
                        "content": "as the title suggests, my code fails for this:\\n\\n[3,5,1,4,2]\\n\\ntest case(testcase66) and i have no idea how they visualize this input tree \\xA0 as the example is too short.."
                    },
                    {
                        "username": "andresstawski",
                        "content": "did you declare your vector as a global variable?"
                    },
                    {
                        "username": "llufan",
                        "content": "`const preorderTraversal = (root) => root ? [root.val, ...preorderTraversal(root.left), ...preorderTraversal(root.right)] : []`"
                    }
                ]
            },
            {
                "id": 1748998,
                "content": [
                    {
                        "username": "kontsis",
                        "content": "I remember the days when I couldn\\'t solve this. Look how far we\\'ve come."
                    },
                    {
                        "username": "miss_sunshine",
                        "content": "someday I\\'ll reach there!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "[@shivamgcodes](/shivamgcodes) there is no book like this ig but you can go to cp-alogrithms website it has all the algos but not all algos are beautiful and worth doing, like morris traversal is only worth using if you are constrained with using no extra space and already know it, but can be used to learn a new perspective on using null pointers in trees and threading.\\nalmost all sufficient algorithms are most beautifully explained in cormen but it doesn\\'t fill the criteria for what you want  but  i trust this book."
                    },
                    {
                        "username": "ankurgupta1999",
                        "content": "I remember the college days when I could solve this at a blink. Look how far I\\'ve come \\uD83E\\uDD72"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "[@Rishabh_yaduwanshi](/Rishabh_yaduwanshi) bro can u please recommend me a book which has all the algos and DS , not necessarily in depth , because being honest , i am reading the word morris traversal for the first time ."
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "i\\'m living your days right now..... hope i might solve these problems soon...!! :  )"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "I remember skipping questions that had slightest mention of tree or graph."
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "i spent a week understanding all these traversals and wasn\\'t able to grasp whole,but now even Morris traversal seems simple,keep pushing."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Yes!! Hard work pays off!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Remember : \\nPreorder Traversal : Root | Left | Right"
                    },
                    {
                        "username": "parapsychic",
                        "content": "A quick way to remember preorder, postorder and inorder is to actually look at the meaning of the word itself. It\\'s always left -> right. The only position that matters is the root. Pre = before, In = in between, post = after.\\nSo, preorder becomes: root left right\\npostorder becomes: left right root\\ninorder becomes: left root right"
                    },
                    {
                        "username": "Msey",
                        "content": "But remember, the power of the Jedi Knight is the power of the universe"
                    },
                    {
                        "username": "kenzoengineer",
                        "content": "thank you daddy leetcode for giving us this question after \"Max Points on a Line\""
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@shivamgcodes](/shivamgcodes) instead of copy pasting it, atleast should have learned the brute force approach and attempted it. it doesnt take much time.. im also a beginner"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "i did not even attempt it , just copy pasted the solution will just read the solution and then implement it myself "
                    },
                    {
                        "username": "neopraveen",
                        "content": "Just a little addition for whom tree is new :\\nPreOrder Traversal -> In preorder traversal, the root node is visited first, then left subtree and then right subtree.\\nIt\\'s required simple recursive solution. You just need to add your current node in the List (it may be a class level variable) and traverse left and right node with same recursive function. That\\'s it, no more line of code is required, the same function will take care of whole tree traversal. Maybe the solution is looking very easy, but believe me it\\'s more easier than you think.\\nPS - Please don\\'t forget to check if current node is null or not, in example you can see a node with null value.\\n\\nIf I am helpful, you know how you can motivate me :)\\nHappy coding."
                    },
                    {
                        "username": "ritteh",
                        "content": "The problem statement indicates the recurrsive version is trivial. How can it be trivial for anyone who has never done trees before? There is exactly zero guidance on how to do it. What terrible training. Fortunately there is Google and I was able to solve it."
                    },
                    {
                        "username": "arthurjwannerjr",
                        "content": "I think that the problem is trivial when you\\'ve got a bit of experience under your belt. Leetcode isn\\'t really for beginners. This problem is probably one of the easiest problems on Leetcode, so relative to other problems on Leetcode, it is trivial.\\n\\nNow, with all that said, the dumb part is that the iterative solution is just as trivial as the recursive solution, for this particular problem anyways.\\n\\nFor other DFS algos such as Post Order Traversal, the iterative version is actually a lot harder than the recursive version."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Agree"
                    },
                    {
                        "username": "Mr_Fish",
                        "content": "Just out of curiosity. I am perfectly capable of coming up with BFS or DFS of traversing a tree as well as just recursion. \\n\\nWill knowing Morris Traversal help you in an interview? I mean while it has O(1) space, it actually has O(2*n) time complexity and time complexity is more significant in an interview."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "O(2 * n) is still O(n). The problem is the locality. Chasing pointers is cache-unfriendly on modern architectures, Morris traversal follows each pointer multiple times so it probably tends to be slower. But in an interview situation it depends on the interviewer. They might just want to tick boxes on a checklist (recursive: check, morris: check), they might be a show-off who tries to impress the interviewee with obscure knowlege (not good but it happens) or they might be an experienced programmer who wants to you find a reasonable solution and/or weigh the advantages/disadvantages."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-09 15.32.48.jpg](https://assets.leetcode.com/users/images/2323c791-f48e-431d-a064-499d1a314186_1673260399.4520557.jpeg)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Recursive approach is quite trivial, can you code it iteravtively!!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "use morris traversal if you want to use constant space,but if you can trade in space using stack is best."
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "stack<TreeNode*> s;\\nwhile(root || !s.empty()){\\n   if(root){\\n        res.push_back(root->val);\\n        s.push(root);\\n        root=root->left;\\n      }\\n   else{\\n        TreeNode* temp=s.top();\\n        temp=temp->right;\\n        }\\n   }\\nreturn res;"
                    },
                    {
                        "username": "nishant7372",
                        "content": "        if(root!=null)\n           stack.push(root);\n        while(!stack.isEmpty()){\n           TreeNode curr = stack.pop();\n           list.add(curr.val);\n           if(curr.right!=null)\n               stack.push(curr.right);\n           if(curr.left!=null)\n               stack.push(curr.left);\n        }"
                    },
                    {
                        "username": "tjin94",
                        "content": "as the title suggests, my code fails for this:\\n\\n[3,5,1,4,2]\\n\\ntest case(testcase66) and i have no idea how they visualize this input tree \\xA0 as the example is too short.."
                    },
                    {
                        "username": "andresstawski",
                        "content": "did you declare your vector as a global variable?"
                    },
                    {
                        "username": "llufan",
                        "content": "`const preorderTraversal = (root) => root ? [root.val, ...preorderTraversal(root.left), ...preorderTraversal(root.right)] : []`"
                    }
                ]
            },
            {
                "id": 1572820,
                "content": [
                    {
                        "username": "kontsis",
                        "content": "I remember the days when I couldn\\'t solve this. Look how far we\\'ve come."
                    },
                    {
                        "username": "miss_sunshine",
                        "content": "someday I\\'ll reach there!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "[@shivamgcodes](/shivamgcodes) there is no book like this ig but you can go to cp-alogrithms website it has all the algos but not all algos are beautiful and worth doing, like morris traversal is only worth using if you are constrained with using no extra space and already know it, but can be used to learn a new perspective on using null pointers in trees and threading.\\nalmost all sufficient algorithms are most beautifully explained in cormen but it doesn\\'t fill the criteria for what you want  but  i trust this book."
                    },
                    {
                        "username": "ankurgupta1999",
                        "content": "I remember the college days when I could solve this at a blink. Look how far I\\'ve come \\uD83E\\uDD72"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "[@Rishabh_yaduwanshi](/Rishabh_yaduwanshi) bro can u please recommend me a book which has all the algos and DS , not necessarily in depth , because being honest , i am reading the word morris traversal for the first time ."
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "i\\'m living your days right now..... hope i might solve these problems soon...!! :  )"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "I remember skipping questions that had slightest mention of tree or graph."
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "i spent a week understanding all these traversals and wasn\\'t able to grasp whole,but now even Morris traversal seems simple,keep pushing."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Yes!! Hard work pays off!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Remember : \\nPreorder Traversal : Root | Left | Right"
                    },
                    {
                        "username": "parapsychic",
                        "content": "A quick way to remember preorder, postorder and inorder is to actually look at the meaning of the word itself. It\\'s always left -> right. The only position that matters is the root. Pre = before, In = in between, post = after.\\nSo, preorder becomes: root left right\\npostorder becomes: left right root\\ninorder becomes: left root right"
                    },
                    {
                        "username": "Msey",
                        "content": "But remember, the power of the Jedi Knight is the power of the universe"
                    },
                    {
                        "username": "kenzoengineer",
                        "content": "thank you daddy leetcode for giving us this question after \"Max Points on a Line\""
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@shivamgcodes](/shivamgcodes) instead of copy pasting it, atleast should have learned the brute force approach and attempted it. it doesnt take much time.. im also a beginner"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "i did not even attempt it , just copy pasted the solution will just read the solution and then implement it myself "
                    },
                    {
                        "username": "neopraveen",
                        "content": "Just a little addition for whom tree is new :\\nPreOrder Traversal -> In preorder traversal, the root node is visited first, then left subtree and then right subtree.\\nIt\\'s required simple recursive solution. You just need to add your current node in the List (it may be a class level variable) and traverse left and right node with same recursive function. That\\'s it, no more line of code is required, the same function will take care of whole tree traversal. Maybe the solution is looking very easy, but believe me it\\'s more easier than you think.\\nPS - Please don\\'t forget to check if current node is null or not, in example you can see a node with null value.\\n\\nIf I am helpful, you know how you can motivate me :)\\nHappy coding."
                    },
                    {
                        "username": "ritteh",
                        "content": "The problem statement indicates the recurrsive version is trivial. How can it be trivial for anyone who has never done trees before? There is exactly zero guidance on how to do it. What terrible training. Fortunately there is Google and I was able to solve it."
                    },
                    {
                        "username": "arthurjwannerjr",
                        "content": "I think that the problem is trivial when you\\'ve got a bit of experience under your belt. Leetcode isn\\'t really for beginners. This problem is probably one of the easiest problems on Leetcode, so relative to other problems on Leetcode, it is trivial.\\n\\nNow, with all that said, the dumb part is that the iterative solution is just as trivial as the recursive solution, for this particular problem anyways.\\n\\nFor other DFS algos such as Post Order Traversal, the iterative version is actually a lot harder than the recursive version."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Agree"
                    },
                    {
                        "username": "Mr_Fish",
                        "content": "Just out of curiosity. I am perfectly capable of coming up with BFS or DFS of traversing a tree as well as just recursion. \\n\\nWill knowing Morris Traversal help you in an interview? I mean while it has O(1) space, it actually has O(2*n) time complexity and time complexity is more significant in an interview."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "O(2 * n) is still O(n). The problem is the locality. Chasing pointers is cache-unfriendly on modern architectures, Morris traversal follows each pointer multiple times so it probably tends to be slower. But in an interview situation it depends on the interviewer. They might just want to tick boxes on a checklist (recursive: check, morris: check), they might be a show-off who tries to impress the interviewee with obscure knowlege (not good but it happens) or they might be an experienced programmer who wants to you find a reasonable solution and/or weigh the advantages/disadvantages."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-09 15.32.48.jpg](https://assets.leetcode.com/users/images/2323c791-f48e-431d-a064-499d1a314186_1673260399.4520557.jpeg)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Recursive approach is quite trivial, can you code it iteravtively!!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "use morris traversal if you want to use constant space,but if you can trade in space using stack is best."
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "stack<TreeNode*> s;\\nwhile(root || !s.empty()){\\n   if(root){\\n        res.push_back(root->val);\\n        s.push(root);\\n        root=root->left;\\n      }\\n   else{\\n        TreeNode* temp=s.top();\\n        temp=temp->right;\\n        }\\n   }\\nreturn res;"
                    },
                    {
                        "username": "nishant7372",
                        "content": "        if(root!=null)\n           stack.push(root);\n        while(!stack.isEmpty()){\n           TreeNode curr = stack.pop();\n           list.add(curr.val);\n           if(curr.right!=null)\n               stack.push(curr.right);\n           if(curr.left!=null)\n               stack.push(curr.left);\n        }"
                    },
                    {
                        "username": "tjin94",
                        "content": "as the title suggests, my code fails for this:\\n\\n[3,5,1,4,2]\\n\\ntest case(testcase66) and i have no idea how they visualize this input tree \\xA0 as the example is too short.."
                    },
                    {
                        "username": "andresstawski",
                        "content": "did you declare your vector as a global variable?"
                    },
                    {
                        "username": "llufan",
                        "content": "`const preorderTraversal = (root) => root ? [root.val, ...preorderTraversal(root.left), ...preorderTraversal(root.right)] : []`"
                    }
                ]
            },
            {
                "id": 1568092,
                "content": [
                    {
                        "username": "kontsis",
                        "content": "I remember the days when I couldn\\'t solve this. Look how far we\\'ve come."
                    },
                    {
                        "username": "miss_sunshine",
                        "content": "someday I\\'ll reach there!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "[@shivamgcodes](/shivamgcodes) there is no book like this ig but you can go to cp-alogrithms website it has all the algos but not all algos are beautiful and worth doing, like morris traversal is only worth using if you are constrained with using no extra space and already know it, but can be used to learn a new perspective on using null pointers in trees and threading.\\nalmost all sufficient algorithms are most beautifully explained in cormen but it doesn\\'t fill the criteria for what you want  but  i trust this book."
                    },
                    {
                        "username": "ankurgupta1999",
                        "content": "I remember the college days when I could solve this at a blink. Look how far I\\'ve come \\uD83E\\uDD72"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "[@Rishabh_yaduwanshi](/Rishabh_yaduwanshi) bro can u please recommend me a book which has all the algos and DS , not necessarily in depth , because being honest , i am reading the word morris traversal for the first time ."
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "i\\'m living your days right now..... hope i might solve these problems soon...!! :  )"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "I remember skipping questions that had slightest mention of tree or graph."
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "i spent a week understanding all these traversals and wasn\\'t able to grasp whole,but now even Morris traversal seems simple,keep pushing."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Yes!! Hard work pays off!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Remember : \\nPreorder Traversal : Root | Left | Right"
                    },
                    {
                        "username": "parapsychic",
                        "content": "A quick way to remember preorder, postorder and inorder is to actually look at the meaning of the word itself. It\\'s always left -> right. The only position that matters is the root. Pre = before, In = in between, post = after.\\nSo, preorder becomes: root left right\\npostorder becomes: left right root\\ninorder becomes: left root right"
                    },
                    {
                        "username": "Msey",
                        "content": "But remember, the power of the Jedi Knight is the power of the universe"
                    },
                    {
                        "username": "kenzoengineer",
                        "content": "thank you daddy leetcode for giving us this question after \"Max Points on a Line\""
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@shivamgcodes](/shivamgcodes) instead of copy pasting it, atleast should have learned the brute force approach and attempted it. it doesnt take much time.. im also a beginner"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "i did not even attempt it , just copy pasted the solution will just read the solution and then implement it myself "
                    },
                    {
                        "username": "neopraveen",
                        "content": "Just a little addition for whom tree is new :\\nPreOrder Traversal -> In preorder traversal, the root node is visited first, then left subtree and then right subtree.\\nIt\\'s required simple recursive solution. You just need to add your current node in the List (it may be a class level variable) and traverse left and right node with same recursive function. That\\'s it, no more line of code is required, the same function will take care of whole tree traversal. Maybe the solution is looking very easy, but believe me it\\'s more easier than you think.\\nPS - Please don\\'t forget to check if current node is null or not, in example you can see a node with null value.\\n\\nIf I am helpful, you know how you can motivate me :)\\nHappy coding."
                    },
                    {
                        "username": "ritteh",
                        "content": "The problem statement indicates the recurrsive version is trivial. How can it be trivial for anyone who has never done trees before? There is exactly zero guidance on how to do it. What terrible training. Fortunately there is Google and I was able to solve it."
                    },
                    {
                        "username": "arthurjwannerjr",
                        "content": "I think that the problem is trivial when you\\'ve got a bit of experience under your belt. Leetcode isn\\'t really for beginners. This problem is probably one of the easiest problems on Leetcode, so relative to other problems on Leetcode, it is trivial.\\n\\nNow, with all that said, the dumb part is that the iterative solution is just as trivial as the recursive solution, for this particular problem anyways.\\n\\nFor other DFS algos such as Post Order Traversal, the iterative version is actually a lot harder than the recursive version."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Agree"
                    },
                    {
                        "username": "Mr_Fish",
                        "content": "Just out of curiosity. I am perfectly capable of coming up with BFS or DFS of traversing a tree as well as just recursion. \\n\\nWill knowing Morris Traversal help you in an interview? I mean while it has O(1) space, it actually has O(2*n) time complexity and time complexity is more significant in an interview."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "O(2 * n) is still O(n). The problem is the locality. Chasing pointers is cache-unfriendly on modern architectures, Morris traversal follows each pointer multiple times so it probably tends to be slower. But in an interview situation it depends on the interviewer. They might just want to tick boxes on a checklist (recursive: check, morris: check), they might be a show-off who tries to impress the interviewee with obscure knowlege (not good but it happens) or they might be an experienced programmer who wants to you find a reasonable solution and/or weigh the advantages/disadvantages."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-09 15.32.48.jpg](https://assets.leetcode.com/users/images/2323c791-f48e-431d-a064-499d1a314186_1673260399.4520557.jpeg)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Recursive approach is quite trivial, can you code it iteravtively!!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "use morris traversal if you want to use constant space,but if you can trade in space using stack is best."
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "stack<TreeNode*> s;\\nwhile(root || !s.empty()){\\n   if(root){\\n        res.push_back(root->val);\\n        s.push(root);\\n        root=root->left;\\n      }\\n   else{\\n        TreeNode* temp=s.top();\\n        temp=temp->right;\\n        }\\n   }\\nreturn res;"
                    },
                    {
                        "username": "nishant7372",
                        "content": "        if(root!=null)\n           stack.push(root);\n        while(!stack.isEmpty()){\n           TreeNode curr = stack.pop();\n           list.add(curr.val);\n           if(curr.right!=null)\n               stack.push(curr.right);\n           if(curr.left!=null)\n               stack.push(curr.left);\n        }"
                    },
                    {
                        "username": "tjin94",
                        "content": "as the title suggests, my code fails for this:\\n\\n[3,5,1,4,2]\\n\\ntest case(testcase66) and i have no idea how they visualize this input tree \\xA0 as the example is too short.."
                    },
                    {
                        "username": "andresstawski",
                        "content": "did you declare your vector as a global variable?"
                    },
                    {
                        "username": "llufan",
                        "content": "`const preorderTraversal = (root) => root ? [root.val, ...preorderTraversal(root.left), ...preorderTraversal(root.right)] : []`"
                    }
                ]
            },
            {
                "id": 1569545,
                "content": [
                    {
                        "username": "SDWillems",
                        "content": "This is my First Leetcode challenge I take.\\nSo you get a little bit of explenation what a Binary Tree is and what ways there are to traverse. Then you directly must make an question without any knowledge of how you can do this? On top of that they add that you must return a list, what makes it Way harder bc now you need to create a new list everytime and add it recursivly?? \\n\\nMy question: HOW can one learn from this? I don\\'t see how you learn from not knowing what you must do or how you can get at it. The only way I know how to do it is from looking at the answers.. There must be a lesson but I just cannot find it.."
                    },
                    {
                        "username": "VinayakNegi",
                        "content": "this platform is not for learning, this is for practicing what you already know if you think that these questions will help you learn without you having prior knowledge then it\\'ll be a hell for you here. \\nI suggest you to go and watch a few videos, practice a few questions and then implement it. \\n"
                    },
                    {
                        "username": "bean_bean005",
                        "content": "`int* preorderTraversal(struct TreeNode* root, int* returnSize){\nstruct TreeNode* p=(struct TreeNode*) malloc(sizeof(struct TreeNode));\nif(root){\n    p=root->val;\n    preorderTraversal(root->left, returnSize);\n    preorderTraversal(root->right, returnSize);\n}\nreturn p;\n}`\nWhat is wrong with this C solution"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The function should return an array of `int`, and communicate the number of elements in the array via the OUT-parameter `returnSize`. So in some way you will have to allocate enough memory for all values in the tree, write the values to the array, and return it.  \\nIn this solution the function allocates memory for a single `struct TreeNode`, stores the value of the `root` in that allocated memory, calls itself recursively for the left and right subtree and discards the result of those function calls. That doesn\\'t work at all.  \\n\\nHow about this: First count the number of nodes in the tree, then allocate enough memory for the result, then call a \"helper function\" that writes to the array and calls itself recursively."
                    },
                    {
                        "username": "ajaymaida17",
                        "content": "100% beats  c++ easy Iterative solution: \nHINT: \nuse Stack to process each node;\npush right element first and then left .\nand process stack till it becomes an empty.\n\n\n\n\n\n\n\n\n         vector<int> v;\n        stack<TreeNode*> st;\n        if(root==NULL) return v;\n        st.push(root);\n        while(!st.empty()){\n            TreeNode* temp=st.top();\n            st.pop();\n            v.push_back(temp->val);\n            if(temp->right!=NULL)st.push(temp->right);\n            if(temp->left!=NULL)st.push(temp->left);\n        }\n        return v; "
                    },
                    {
                        "username": "rjalali",
                        "content": "We deserved this after yesterday\\'s problem."
                    },
                    {
                        "username": "Petersburg",
                        "content": "Why do some answers use while root or stack: and others use while stack: ?\\n\\nUsually the latter is much simpler and I cannot understand the thought process behind \\nwhile root or stack:\\n\\nCan anyone help me here?"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "As you understood the second approach:\\nbasically here you are pushing the right then left, so when you go to the next iteration you pick the left part of the current node from stack first. And after completing that part you come to the right part of the current node.\\n\\nIn the first approach , instead of pushing the left part and poping it from the stack, we just take that left part into root as:\\n    root=root->left and continue pushing the right part.\\nSo, you need to check either stack is not empty or root exists in the first approach as the iteration condition.\\n\\n"
                    },
                    {
                        "username": "arthurjwannerjr",
                        "content": "It basically means that the loop will keep looping if the data exists.\\n\"while root\" will keep looping if the node named root exists and continues to exist.\\n\"while stack\" will keep looping as long as the stack is not empty."
                    },
                    {
                        "username": "feiger123",
                        "content": "although recursive is trivial, not sure how to pass the return value: List<Integer> if using recursive method.\\n\\nLooks like we can use global variables, any better ideas?"
                    },
                    {
                        "username": "nishant7372",
                        "content": "if you want to avoid using global variable, then create another function and pass list/vector to it."
                    },
                    {
                        "username": "ivozayas",
                        "content": "excuse me?\\n\\nInput\\nroot =\\n[1,4,3,2]\\n\\nOutput\\n[1,4,3,2]\\n\\nExpected\\n[1,4,2,3]"
                    },
                    {
                        "username": "ysosalty",
                        "content": "why is there a null at all i dont get it"
                    },
                    {
                        "username": "codearyan",
                        "content": "why this code doesn\\'t work like is there a way to code it in same function without creating a helper one \\n\\n\\nvector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n       \\n        if (root  == NULL) {\\n            return v ;\\n        }\\n        \\n       v.push_back(root->val);\\n        preorderTraversal(root->left);\\n       preorderTraversal(root->right);\\n       return v;\\n        \\n    }"
                    },
                    {
                        "username": "codearyan",
                        "content": "[@andresstawski](/andresstawski)  the vector declaration is wrong else the code works thank you so much.\\n"
                    },
                    {
                        "username": "andresstawski",
                        "content": "put vector v outside of the function\\n\\nclass Solution {\\npublic:\\n    \\nvector<int> ans;\\n\\n    vector<int> preorderTraversal(TreeNode* root) {\\n       \\n\\n        if (root == NULL) return ans;\\n        \\n        ans.push_back(root -> val);\\n    \\n        if (root->left) preorderTraversal(root->left);\\n        if (root->right) preorderTraversal(root->right);\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Each time `preorderTraversal()` gets called the function creates an empty `std::vector` and returns it at the end. But the recursive calls (`preorderTraversal(root->left);` and `preorderTraversal(root->right);`) create their own `std::vector` which gets discarded. Therefore in the end the result is a `std::vector` with a single element, the value of the `root` (or none if the `root` is `NULL`).\\n\\nCreating a helper function that takes the `std::vector` by reference allows the recursive calls to write to the exact same `std::vector`."
                    },
                    {
                        "username": "andresstawski",
                        "content": "using vector as a global variable instead of local variable helped me solve issue where I could not push the last node to the vector."
                    }
                ]
            },
            {
                "id": 1750815,
                "content": [
                    {
                        "username": "SDWillems",
                        "content": "This is my First Leetcode challenge I take.\\nSo you get a little bit of explenation what a Binary Tree is and what ways there are to traverse. Then you directly must make an question without any knowledge of how you can do this? On top of that they add that you must return a list, what makes it Way harder bc now you need to create a new list everytime and add it recursivly?? \\n\\nMy question: HOW can one learn from this? I don\\'t see how you learn from not knowing what you must do or how you can get at it. The only way I know how to do it is from looking at the answers.. There must be a lesson but I just cannot find it.."
                    },
                    {
                        "username": "VinayakNegi",
                        "content": "this platform is not for learning, this is for practicing what you already know if you think that these questions will help you learn without you having prior knowledge then it\\'ll be a hell for you here. \\nI suggest you to go and watch a few videos, practice a few questions and then implement it. \\n"
                    },
                    {
                        "username": "bean_bean005",
                        "content": "`int* preorderTraversal(struct TreeNode* root, int* returnSize){\nstruct TreeNode* p=(struct TreeNode*) malloc(sizeof(struct TreeNode));\nif(root){\n    p=root->val;\n    preorderTraversal(root->left, returnSize);\n    preorderTraversal(root->right, returnSize);\n}\nreturn p;\n}`\nWhat is wrong with this C solution"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The function should return an array of `int`, and communicate the number of elements in the array via the OUT-parameter `returnSize`. So in some way you will have to allocate enough memory for all values in the tree, write the values to the array, and return it.  \\nIn this solution the function allocates memory for a single `struct TreeNode`, stores the value of the `root` in that allocated memory, calls itself recursively for the left and right subtree and discards the result of those function calls. That doesn\\'t work at all.  \\n\\nHow about this: First count the number of nodes in the tree, then allocate enough memory for the result, then call a \"helper function\" that writes to the array and calls itself recursively."
                    },
                    {
                        "username": "ajaymaida17",
                        "content": "100% beats  c++ easy Iterative solution: \nHINT: \nuse Stack to process each node;\npush right element first and then left .\nand process stack till it becomes an empty.\n\n\n\n\n\n\n\n\n         vector<int> v;\n        stack<TreeNode*> st;\n        if(root==NULL) return v;\n        st.push(root);\n        while(!st.empty()){\n            TreeNode* temp=st.top();\n            st.pop();\n            v.push_back(temp->val);\n            if(temp->right!=NULL)st.push(temp->right);\n            if(temp->left!=NULL)st.push(temp->left);\n        }\n        return v; "
                    },
                    {
                        "username": "rjalali",
                        "content": "We deserved this after yesterday\\'s problem."
                    },
                    {
                        "username": "Petersburg",
                        "content": "Why do some answers use while root or stack: and others use while stack: ?\\n\\nUsually the latter is much simpler and I cannot understand the thought process behind \\nwhile root or stack:\\n\\nCan anyone help me here?"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "As you understood the second approach:\\nbasically here you are pushing the right then left, so when you go to the next iteration you pick the left part of the current node from stack first. And after completing that part you come to the right part of the current node.\\n\\nIn the first approach , instead of pushing the left part and poping it from the stack, we just take that left part into root as:\\n    root=root->left and continue pushing the right part.\\nSo, you need to check either stack is not empty or root exists in the first approach as the iteration condition.\\n\\n"
                    },
                    {
                        "username": "arthurjwannerjr",
                        "content": "It basically means that the loop will keep looping if the data exists.\\n\"while root\" will keep looping if the node named root exists and continues to exist.\\n\"while stack\" will keep looping as long as the stack is not empty."
                    },
                    {
                        "username": "feiger123",
                        "content": "although recursive is trivial, not sure how to pass the return value: List<Integer> if using recursive method.\\n\\nLooks like we can use global variables, any better ideas?"
                    },
                    {
                        "username": "nishant7372",
                        "content": "if you want to avoid using global variable, then create another function and pass list/vector to it."
                    },
                    {
                        "username": "ivozayas",
                        "content": "excuse me?\\n\\nInput\\nroot =\\n[1,4,3,2]\\n\\nOutput\\n[1,4,3,2]\\n\\nExpected\\n[1,4,2,3]"
                    },
                    {
                        "username": "ysosalty",
                        "content": "why is there a null at all i dont get it"
                    },
                    {
                        "username": "codearyan",
                        "content": "why this code doesn\\'t work like is there a way to code it in same function without creating a helper one \\n\\n\\nvector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n       \\n        if (root  == NULL) {\\n            return v ;\\n        }\\n        \\n       v.push_back(root->val);\\n        preorderTraversal(root->left);\\n       preorderTraversal(root->right);\\n       return v;\\n        \\n    }"
                    },
                    {
                        "username": "codearyan",
                        "content": "[@andresstawski](/andresstawski)  the vector declaration is wrong else the code works thank you so much.\\n"
                    },
                    {
                        "username": "andresstawski",
                        "content": "put vector v outside of the function\\n\\nclass Solution {\\npublic:\\n    \\nvector<int> ans;\\n\\n    vector<int> preorderTraversal(TreeNode* root) {\\n       \\n\\n        if (root == NULL) return ans;\\n        \\n        ans.push_back(root -> val);\\n    \\n        if (root->left) preorderTraversal(root->left);\\n        if (root->right) preorderTraversal(root->right);\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Each time `preorderTraversal()` gets called the function creates an empty `std::vector` and returns it at the end. But the recursive calls (`preorderTraversal(root->left);` and `preorderTraversal(root->right);`) create their own `std::vector` which gets discarded. Therefore in the end the result is a `std::vector` with a single element, the value of the `root` (or none if the `root` is `NULL`).\\n\\nCreating a helper function that takes the `std::vector` by reference allows the recursive calls to write to the exact same `std::vector`."
                    },
                    {
                        "username": "andresstawski",
                        "content": "using vector as a global variable instead of local variable helped me solve issue where I could not push the last node to the vector."
                    }
                ]
            },
            {
                "id": 1749782,
                "content": [
                    {
                        "username": "SDWillems",
                        "content": "This is my First Leetcode challenge I take.\\nSo you get a little bit of explenation what a Binary Tree is and what ways there are to traverse. Then you directly must make an question without any knowledge of how you can do this? On top of that they add that you must return a list, what makes it Way harder bc now you need to create a new list everytime and add it recursivly?? \\n\\nMy question: HOW can one learn from this? I don\\'t see how you learn from not knowing what you must do or how you can get at it. The only way I know how to do it is from looking at the answers.. There must be a lesson but I just cannot find it.."
                    },
                    {
                        "username": "VinayakNegi",
                        "content": "this platform is not for learning, this is for practicing what you already know if you think that these questions will help you learn without you having prior knowledge then it\\'ll be a hell for you here. \\nI suggest you to go and watch a few videos, practice a few questions and then implement it. \\n"
                    },
                    {
                        "username": "bean_bean005",
                        "content": "`int* preorderTraversal(struct TreeNode* root, int* returnSize){\nstruct TreeNode* p=(struct TreeNode*) malloc(sizeof(struct TreeNode));\nif(root){\n    p=root->val;\n    preorderTraversal(root->left, returnSize);\n    preorderTraversal(root->right, returnSize);\n}\nreturn p;\n}`\nWhat is wrong with this C solution"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The function should return an array of `int`, and communicate the number of elements in the array via the OUT-parameter `returnSize`. So in some way you will have to allocate enough memory for all values in the tree, write the values to the array, and return it.  \\nIn this solution the function allocates memory for a single `struct TreeNode`, stores the value of the `root` in that allocated memory, calls itself recursively for the left and right subtree and discards the result of those function calls. That doesn\\'t work at all.  \\n\\nHow about this: First count the number of nodes in the tree, then allocate enough memory for the result, then call a \"helper function\" that writes to the array and calls itself recursively."
                    },
                    {
                        "username": "ajaymaida17",
                        "content": "100% beats  c++ easy Iterative solution: \nHINT: \nuse Stack to process each node;\npush right element first and then left .\nand process stack till it becomes an empty.\n\n\n\n\n\n\n\n\n         vector<int> v;\n        stack<TreeNode*> st;\n        if(root==NULL) return v;\n        st.push(root);\n        while(!st.empty()){\n            TreeNode* temp=st.top();\n            st.pop();\n            v.push_back(temp->val);\n            if(temp->right!=NULL)st.push(temp->right);\n            if(temp->left!=NULL)st.push(temp->left);\n        }\n        return v; "
                    },
                    {
                        "username": "rjalali",
                        "content": "We deserved this after yesterday\\'s problem."
                    },
                    {
                        "username": "Petersburg",
                        "content": "Why do some answers use while root or stack: and others use while stack: ?\\n\\nUsually the latter is much simpler and I cannot understand the thought process behind \\nwhile root or stack:\\n\\nCan anyone help me here?"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "As you understood the second approach:\\nbasically here you are pushing the right then left, so when you go to the next iteration you pick the left part of the current node from stack first. And after completing that part you come to the right part of the current node.\\n\\nIn the first approach , instead of pushing the left part and poping it from the stack, we just take that left part into root as:\\n    root=root->left and continue pushing the right part.\\nSo, you need to check either stack is not empty or root exists in the first approach as the iteration condition.\\n\\n"
                    },
                    {
                        "username": "arthurjwannerjr",
                        "content": "It basically means that the loop will keep looping if the data exists.\\n\"while root\" will keep looping if the node named root exists and continues to exist.\\n\"while stack\" will keep looping as long as the stack is not empty."
                    },
                    {
                        "username": "feiger123",
                        "content": "although recursive is trivial, not sure how to pass the return value: List<Integer> if using recursive method.\\n\\nLooks like we can use global variables, any better ideas?"
                    },
                    {
                        "username": "nishant7372",
                        "content": "if you want to avoid using global variable, then create another function and pass list/vector to it."
                    },
                    {
                        "username": "ivozayas",
                        "content": "excuse me?\\n\\nInput\\nroot =\\n[1,4,3,2]\\n\\nOutput\\n[1,4,3,2]\\n\\nExpected\\n[1,4,2,3]"
                    },
                    {
                        "username": "ysosalty",
                        "content": "why is there a null at all i dont get it"
                    },
                    {
                        "username": "codearyan",
                        "content": "why this code doesn\\'t work like is there a way to code it in same function without creating a helper one \\n\\n\\nvector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n       \\n        if (root  == NULL) {\\n            return v ;\\n        }\\n        \\n       v.push_back(root->val);\\n        preorderTraversal(root->left);\\n       preorderTraversal(root->right);\\n       return v;\\n        \\n    }"
                    },
                    {
                        "username": "codearyan",
                        "content": "[@andresstawski](/andresstawski)  the vector declaration is wrong else the code works thank you so much.\\n"
                    },
                    {
                        "username": "andresstawski",
                        "content": "put vector v outside of the function\\n\\nclass Solution {\\npublic:\\n    \\nvector<int> ans;\\n\\n    vector<int> preorderTraversal(TreeNode* root) {\\n       \\n\\n        if (root == NULL) return ans;\\n        \\n        ans.push_back(root -> val);\\n    \\n        if (root->left) preorderTraversal(root->left);\\n        if (root->right) preorderTraversal(root->right);\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Each time `preorderTraversal()` gets called the function creates an empty `std::vector` and returns it at the end. But the recursive calls (`preorderTraversal(root->left);` and `preorderTraversal(root->right);`) create their own `std::vector` which gets discarded. Therefore in the end the result is a `std::vector` with a single element, the value of the `root` (or none if the `root` is `NULL`).\\n\\nCreating a helper function that takes the `std::vector` by reference allows the recursive calls to write to the exact same `std::vector`."
                    },
                    {
                        "username": "andresstawski",
                        "content": "using vector as a global variable instead of local variable helped me solve issue where I could not push the last node to the vector."
                    }
                ]
            },
            {
                "id": 1749373,
                "content": [
                    {
                        "username": "SDWillems",
                        "content": "This is my First Leetcode challenge I take.\\nSo you get a little bit of explenation what a Binary Tree is and what ways there are to traverse. Then you directly must make an question without any knowledge of how you can do this? On top of that they add that you must return a list, what makes it Way harder bc now you need to create a new list everytime and add it recursivly?? \\n\\nMy question: HOW can one learn from this? I don\\'t see how you learn from not knowing what you must do or how you can get at it. The only way I know how to do it is from looking at the answers.. There must be a lesson but I just cannot find it.."
                    },
                    {
                        "username": "VinayakNegi",
                        "content": "this platform is not for learning, this is for practicing what you already know if you think that these questions will help you learn without you having prior knowledge then it\\'ll be a hell for you here. \\nI suggest you to go and watch a few videos, practice a few questions and then implement it. \\n"
                    },
                    {
                        "username": "bean_bean005",
                        "content": "`int* preorderTraversal(struct TreeNode* root, int* returnSize){\nstruct TreeNode* p=(struct TreeNode*) malloc(sizeof(struct TreeNode));\nif(root){\n    p=root->val;\n    preorderTraversal(root->left, returnSize);\n    preorderTraversal(root->right, returnSize);\n}\nreturn p;\n}`\nWhat is wrong with this C solution"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The function should return an array of `int`, and communicate the number of elements in the array via the OUT-parameter `returnSize`. So in some way you will have to allocate enough memory for all values in the tree, write the values to the array, and return it.  \\nIn this solution the function allocates memory for a single `struct TreeNode`, stores the value of the `root` in that allocated memory, calls itself recursively for the left and right subtree and discards the result of those function calls. That doesn\\'t work at all.  \\n\\nHow about this: First count the number of nodes in the tree, then allocate enough memory for the result, then call a \"helper function\" that writes to the array and calls itself recursively."
                    },
                    {
                        "username": "ajaymaida17",
                        "content": "100% beats  c++ easy Iterative solution: \nHINT: \nuse Stack to process each node;\npush right element first and then left .\nand process stack till it becomes an empty.\n\n\n\n\n\n\n\n\n         vector<int> v;\n        stack<TreeNode*> st;\n        if(root==NULL) return v;\n        st.push(root);\n        while(!st.empty()){\n            TreeNode* temp=st.top();\n            st.pop();\n            v.push_back(temp->val);\n            if(temp->right!=NULL)st.push(temp->right);\n            if(temp->left!=NULL)st.push(temp->left);\n        }\n        return v; "
                    },
                    {
                        "username": "rjalali",
                        "content": "We deserved this after yesterday\\'s problem."
                    },
                    {
                        "username": "Petersburg",
                        "content": "Why do some answers use while root or stack: and others use while stack: ?\\n\\nUsually the latter is much simpler and I cannot understand the thought process behind \\nwhile root or stack:\\n\\nCan anyone help me here?"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "As you understood the second approach:\\nbasically here you are pushing the right then left, so when you go to the next iteration you pick the left part of the current node from stack first. And after completing that part you come to the right part of the current node.\\n\\nIn the first approach , instead of pushing the left part and poping it from the stack, we just take that left part into root as:\\n    root=root->left and continue pushing the right part.\\nSo, you need to check either stack is not empty or root exists in the first approach as the iteration condition.\\n\\n"
                    },
                    {
                        "username": "arthurjwannerjr",
                        "content": "It basically means that the loop will keep looping if the data exists.\\n\"while root\" will keep looping if the node named root exists and continues to exist.\\n\"while stack\" will keep looping as long as the stack is not empty."
                    },
                    {
                        "username": "feiger123",
                        "content": "although recursive is trivial, not sure how to pass the return value: List<Integer> if using recursive method.\\n\\nLooks like we can use global variables, any better ideas?"
                    },
                    {
                        "username": "nishant7372",
                        "content": "if you want to avoid using global variable, then create another function and pass list/vector to it."
                    },
                    {
                        "username": "ivozayas",
                        "content": "excuse me?\\n\\nInput\\nroot =\\n[1,4,3,2]\\n\\nOutput\\n[1,4,3,2]\\n\\nExpected\\n[1,4,2,3]"
                    },
                    {
                        "username": "ysosalty",
                        "content": "why is there a null at all i dont get it"
                    },
                    {
                        "username": "codearyan",
                        "content": "why this code doesn\\'t work like is there a way to code it in same function without creating a helper one \\n\\n\\nvector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n       \\n        if (root  == NULL) {\\n            return v ;\\n        }\\n        \\n       v.push_back(root->val);\\n        preorderTraversal(root->left);\\n       preorderTraversal(root->right);\\n       return v;\\n        \\n    }"
                    },
                    {
                        "username": "codearyan",
                        "content": "[@andresstawski](/andresstawski)  the vector declaration is wrong else the code works thank you so much.\\n"
                    },
                    {
                        "username": "andresstawski",
                        "content": "put vector v outside of the function\\n\\nclass Solution {\\npublic:\\n    \\nvector<int> ans;\\n\\n    vector<int> preorderTraversal(TreeNode* root) {\\n       \\n\\n        if (root == NULL) return ans;\\n        \\n        ans.push_back(root -> val);\\n    \\n        if (root->left) preorderTraversal(root->left);\\n        if (root->right) preorderTraversal(root->right);\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Each time `preorderTraversal()` gets called the function creates an empty `std::vector` and returns it at the end. But the recursive calls (`preorderTraversal(root->left);` and `preorderTraversal(root->right);`) create their own `std::vector` which gets discarded. Therefore in the end the result is a `std::vector` with a single element, the value of the `root` (or none if the `root` is `NULL`).\\n\\nCreating a helper function that takes the `std::vector` by reference allows the recursive calls to write to the exact same `std::vector`."
                    },
                    {
                        "username": "andresstawski",
                        "content": "using vector as a global variable instead of local variable helped me solve issue where I could not push the last node to the vector."
                    }
                ]
            },
            {
                "id": 1569864,
                "content": [
                    {
                        "username": "SDWillems",
                        "content": "This is my First Leetcode challenge I take.\\nSo you get a little bit of explenation what a Binary Tree is and what ways there are to traverse. Then you directly must make an question without any knowledge of how you can do this? On top of that they add that you must return a list, what makes it Way harder bc now you need to create a new list everytime and add it recursivly?? \\n\\nMy question: HOW can one learn from this? I don\\'t see how you learn from not knowing what you must do or how you can get at it. The only way I know how to do it is from looking at the answers.. There must be a lesson but I just cannot find it.."
                    },
                    {
                        "username": "VinayakNegi",
                        "content": "this platform is not for learning, this is for practicing what you already know if you think that these questions will help you learn without you having prior knowledge then it\\'ll be a hell for you here. \\nI suggest you to go and watch a few videos, practice a few questions and then implement it. \\n"
                    },
                    {
                        "username": "bean_bean005",
                        "content": "`int* preorderTraversal(struct TreeNode* root, int* returnSize){\nstruct TreeNode* p=(struct TreeNode*) malloc(sizeof(struct TreeNode));\nif(root){\n    p=root->val;\n    preorderTraversal(root->left, returnSize);\n    preorderTraversal(root->right, returnSize);\n}\nreturn p;\n}`\nWhat is wrong with this C solution"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The function should return an array of `int`, and communicate the number of elements in the array via the OUT-parameter `returnSize`. So in some way you will have to allocate enough memory for all values in the tree, write the values to the array, and return it.  \\nIn this solution the function allocates memory for a single `struct TreeNode`, stores the value of the `root` in that allocated memory, calls itself recursively for the left and right subtree and discards the result of those function calls. That doesn\\'t work at all.  \\n\\nHow about this: First count the number of nodes in the tree, then allocate enough memory for the result, then call a \"helper function\" that writes to the array and calls itself recursively."
                    },
                    {
                        "username": "ajaymaida17",
                        "content": "100% beats  c++ easy Iterative solution: \nHINT: \nuse Stack to process each node;\npush right element first and then left .\nand process stack till it becomes an empty.\n\n\n\n\n\n\n\n\n         vector<int> v;\n        stack<TreeNode*> st;\n        if(root==NULL) return v;\n        st.push(root);\n        while(!st.empty()){\n            TreeNode* temp=st.top();\n            st.pop();\n            v.push_back(temp->val);\n            if(temp->right!=NULL)st.push(temp->right);\n            if(temp->left!=NULL)st.push(temp->left);\n        }\n        return v; "
                    },
                    {
                        "username": "rjalali",
                        "content": "We deserved this after yesterday\\'s problem."
                    },
                    {
                        "username": "Petersburg",
                        "content": "Why do some answers use while root or stack: and others use while stack: ?\\n\\nUsually the latter is much simpler and I cannot understand the thought process behind \\nwhile root or stack:\\n\\nCan anyone help me here?"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "As you understood the second approach:\\nbasically here you are pushing the right then left, so when you go to the next iteration you pick the left part of the current node from stack first. And after completing that part you come to the right part of the current node.\\n\\nIn the first approach , instead of pushing the left part and poping it from the stack, we just take that left part into root as:\\n    root=root->left and continue pushing the right part.\\nSo, you need to check either stack is not empty or root exists in the first approach as the iteration condition.\\n\\n"
                    },
                    {
                        "username": "arthurjwannerjr",
                        "content": "It basically means that the loop will keep looping if the data exists.\\n\"while root\" will keep looping if the node named root exists and continues to exist.\\n\"while stack\" will keep looping as long as the stack is not empty."
                    },
                    {
                        "username": "feiger123",
                        "content": "although recursive is trivial, not sure how to pass the return value: List<Integer> if using recursive method.\\n\\nLooks like we can use global variables, any better ideas?"
                    },
                    {
                        "username": "nishant7372",
                        "content": "if you want to avoid using global variable, then create another function and pass list/vector to it."
                    },
                    {
                        "username": "ivozayas",
                        "content": "excuse me?\\n\\nInput\\nroot =\\n[1,4,3,2]\\n\\nOutput\\n[1,4,3,2]\\n\\nExpected\\n[1,4,2,3]"
                    },
                    {
                        "username": "ysosalty",
                        "content": "why is there a null at all i dont get it"
                    },
                    {
                        "username": "codearyan",
                        "content": "why this code doesn\\'t work like is there a way to code it in same function without creating a helper one \\n\\n\\nvector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n       \\n        if (root  == NULL) {\\n            return v ;\\n        }\\n        \\n       v.push_back(root->val);\\n        preorderTraversal(root->left);\\n       preorderTraversal(root->right);\\n       return v;\\n        \\n    }"
                    },
                    {
                        "username": "codearyan",
                        "content": "[@andresstawski](/andresstawski)  the vector declaration is wrong else the code works thank you so much.\\n"
                    },
                    {
                        "username": "andresstawski",
                        "content": "put vector v outside of the function\\n\\nclass Solution {\\npublic:\\n    \\nvector<int> ans;\\n\\n    vector<int> preorderTraversal(TreeNode* root) {\\n       \\n\\n        if (root == NULL) return ans;\\n        \\n        ans.push_back(root -> val);\\n    \\n        if (root->left) preorderTraversal(root->left);\\n        if (root->right) preorderTraversal(root->right);\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Each time `preorderTraversal()` gets called the function creates an empty `std::vector` and returns it at the end. But the recursive calls (`preorderTraversal(root->left);` and `preorderTraversal(root->right);`) create their own `std::vector` which gets discarded. Therefore in the end the result is a `std::vector` with a single element, the value of the `root` (or none if the `root` is `NULL`).\\n\\nCreating a helper function that takes the `std::vector` by reference allows the recursive calls to write to the exact same `std::vector`."
                    },
                    {
                        "username": "andresstawski",
                        "content": "using vector as a global variable instead of local variable helped me solve issue where I could not push the last node to the vector."
                    }
                ]
            },
            {
                "id": 1571310,
                "content": [
                    {
                        "username": "SDWillems",
                        "content": "This is my First Leetcode challenge I take.\\nSo you get a little bit of explenation what a Binary Tree is and what ways there are to traverse. Then you directly must make an question without any knowledge of how you can do this? On top of that they add that you must return a list, what makes it Way harder bc now you need to create a new list everytime and add it recursivly?? \\n\\nMy question: HOW can one learn from this? I don\\'t see how you learn from not knowing what you must do or how you can get at it. The only way I know how to do it is from looking at the answers.. There must be a lesson but I just cannot find it.."
                    },
                    {
                        "username": "VinayakNegi",
                        "content": "this platform is not for learning, this is for practicing what you already know if you think that these questions will help you learn without you having prior knowledge then it\\'ll be a hell for you here. \\nI suggest you to go and watch a few videos, practice a few questions and then implement it. \\n"
                    },
                    {
                        "username": "bean_bean005",
                        "content": "`int* preorderTraversal(struct TreeNode* root, int* returnSize){\nstruct TreeNode* p=(struct TreeNode*) malloc(sizeof(struct TreeNode));\nif(root){\n    p=root->val;\n    preorderTraversal(root->left, returnSize);\n    preorderTraversal(root->right, returnSize);\n}\nreturn p;\n}`\nWhat is wrong with this C solution"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The function should return an array of `int`, and communicate the number of elements in the array via the OUT-parameter `returnSize`. So in some way you will have to allocate enough memory for all values in the tree, write the values to the array, and return it.  \\nIn this solution the function allocates memory for a single `struct TreeNode`, stores the value of the `root` in that allocated memory, calls itself recursively for the left and right subtree and discards the result of those function calls. That doesn\\'t work at all.  \\n\\nHow about this: First count the number of nodes in the tree, then allocate enough memory for the result, then call a \"helper function\" that writes to the array and calls itself recursively."
                    },
                    {
                        "username": "ajaymaida17",
                        "content": "100% beats  c++ easy Iterative solution: \nHINT: \nuse Stack to process each node;\npush right element first and then left .\nand process stack till it becomes an empty.\n\n\n\n\n\n\n\n\n         vector<int> v;\n        stack<TreeNode*> st;\n        if(root==NULL) return v;\n        st.push(root);\n        while(!st.empty()){\n            TreeNode* temp=st.top();\n            st.pop();\n            v.push_back(temp->val);\n            if(temp->right!=NULL)st.push(temp->right);\n            if(temp->left!=NULL)st.push(temp->left);\n        }\n        return v; "
                    },
                    {
                        "username": "rjalali",
                        "content": "We deserved this after yesterday\\'s problem."
                    },
                    {
                        "username": "Petersburg",
                        "content": "Why do some answers use while root or stack: and others use while stack: ?\\n\\nUsually the latter is much simpler and I cannot understand the thought process behind \\nwhile root or stack:\\n\\nCan anyone help me here?"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "As you understood the second approach:\\nbasically here you are pushing the right then left, so when you go to the next iteration you pick the left part of the current node from stack first. And after completing that part you come to the right part of the current node.\\n\\nIn the first approach , instead of pushing the left part and poping it from the stack, we just take that left part into root as:\\n    root=root->left and continue pushing the right part.\\nSo, you need to check either stack is not empty or root exists in the first approach as the iteration condition.\\n\\n"
                    },
                    {
                        "username": "arthurjwannerjr",
                        "content": "It basically means that the loop will keep looping if the data exists.\\n\"while root\" will keep looping if the node named root exists and continues to exist.\\n\"while stack\" will keep looping as long as the stack is not empty."
                    },
                    {
                        "username": "feiger123",
                        "content": "although recursive is trivial, not sure how to pass the return value: List<Integer> if using recursive method.\\n\\nLooks like we can use global variables, any better ideas?"
                    },
                    {
                        "username": "nishant7372",
                        "content": "if you want to avoid using global variable, then create another function and pass list/vector to it."
                    },
                    {
                        "username": "ivozayas",
                        "content": "excuse me?\\n\\nInput\\nroot =\\n[1,4,3,2]\\n\\nOutput\\n[1,4,3,2]\\n\\nExpected\\n[1,4,2,3]"
                    },
                    {
                        "username": "ysosalty",
                        "content": "why is there a null at all i dont get it"
                    },
                    {
                        "username": "codearyan",
                        "content": "why this code doesn\\'t work like is there a way to code it in same function without creating a helper one \\n\\n\\nvector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n       \\n        if (root  == NULL) {\\n            return v ;\\n        }\\n        \\n       v.push_back(root->val);\\n        preorderTraversal(root->left);\\n       preorderTraversal(root->right);\\n       return v;\\n        \\n    }"
                    },
                    {
                        "username": "codearyan",
                        "content": "[@andresstawski](/andresstawski)  the vector declaration is wrong else the code works thank you so much.\\n"
                    },
                    {
                        "username": "andresstawski",
                        "content": "put vector v outside of the function\\n\\nclass Solution {\\npublic:\\n    \\nvector<int> ans;\\n\\n    vector<int> preorderTraversal(TreeNode* root) {\\n       \\n\\n        if (root == NULL) return ans;\\n        \\n        ans.push_back(root -> val);\\n    \\n        if (root->left) preorderTraversal(root->left);\\n        if (root->right) preorderTraversal(root->right);\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Each time `preorderTraversal()` gets called the function creates an empty `std::vector` and returns it at the end. But the recursive calls (`preorderTraversal(root->left);` and `preorderTraversal(root->right);`) create their own `std::vector` which gets discarded. Therefore in the end the result is a `std::vector` with a single element, the value of the `root` (or none if the `root` is `NULL`).\\n\\nCreating a helper function that takes the `std::vector` by reference allows the recursive calls to write to the exact same `std::vector`."
                    },
                    {
                        "username": "andresstawski",
                        "content": "using vector as a global variable instead of local variable helped me solve issue where I could not push the last node to the vector."
                    }
                ]
            },
            {
                "id": 2067039,
                "content": [
                    {
                        "username": "SDWillems",
                        "content": "This is my First Leetcode challenge I take.\\nSo you get a little bit of explenation what a Binary Tree is and what ways there are to traverse. Then you directly must make an question without any knowledge of how you can do this? On top of that they add that you must return a list, what makes it Way harder bc now you need to create a new list everytime and add it recursivly?? \\n\\nMy question: HOW can one learn from this? I don\\'t see how you learn from not knowing what you must do or how you can get at it. The only way I know how to do it is from looking at the answers.. There must be a lesson but I just cannot find it.."
                    },
                    {
                        "username": "VinayakNegi",
                        "content": "this platform is not for learning, this is for practicing what you already know if you think that these questions will help you learn without you having prior knowledge then it\\'ll be a hell for you here. \\nI suggest you to go and watch a few videos, practice a few questions and then implement it. \\n"
                    },
                    {
                        "username": "bean_bean005",
                        "content": "`int* preorderTraversal(struct TreeNode* root, int* returnSize){\nstruct TreeNode* p=(struct TreeNode*) malloc(sizeof(struct TreeNode));\nif(root){\n    p=root->val;\n    preorderTraversal(root->left, returnSize);\n    preorderTraversal(root->right, returnSize);\n}\nreturn p;\n}`\nWhat is wrong with this C solution"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The function should return an array of `int`, and communicate the number of elements in the array via the OUT-parameter `returnSize`. So in some way you will have to allocate enough memory for all values in the tree, write the values to the array, and return it.  \\nIn this solution the function allocates memory for a single `struct TreeNode`, stores the value of the `root` in that allocated memory, calls itself recursively for the left and right subtree and discards the result of those function calls. That doesn\\'t work at all.  \\n\\nHow about this: First count the number of nodes in the tree, then allocate enough memory for the result, then call a \"helper function\" that writes to the array and calls itself recursively."
                    },
                    {
                        "username": "ajaymaida17",
                        "content": "100% beats  c++ easy Iterative solution: \nHINT: \nuse Stack to process each node;\npush right element first and then left .\nand process stack till it becomes an empty.\n\n\n\n\n\n\n\n\n         vector<int> v;\n        stack<TreeNode*> st;\n        if(root==NULL) return v;\n        st.push(root);\n        while(!st.empty()){\n            TreeNode* temp=st.top();\n            st.pop();\n            v.push_back(temp->val);\n            if(temp->right!=NULL)st.push(temp->right);\n            if(temp->left!=NULL)st.push(temp->left);\n        }\n        return v; "
                    },
                    {
                        "username": "rjalali",
                        "content": "We deserved this after yesterday\\'s problem."
                    },
                    {
                        "username": "Petersburg",
                        "content": "Why do some answers use while root or stack: and others use while stack: ?\\n\\nUsually the latter is much simpler and I cannot understand the thought process behind \\nwhile root or stack:\\n\\nCan anyone help me here?"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "As you understood the second approach:\\nbasically here you are pushing the right then left, so when you go to the next iteration you pick the left part of the current node from stack first. And after completing that part you come to the right part of the current node.\\n\\nIn the first approach , instead of pushing the left part and poping it from the stack, we just take that left part into root as:\\n    root=root->left and continue pushing the right part.\\nSo, you need to check either stack is not empty or root exists in the first approach as the iteration condition.\\n\\n"
                    },
                    {
                        "username": "arthurjwannerjr",
                        "content": "It basically means that the loop will keep looping if the data exists.\\n\"while root\" will keep looping if the node named root exists and continues to exist.\\n\"while stack\" will keep looping as long as the stack is not empty."
                    },
                    {
                        "username": "feiger123",
                        "content": "although recursive is trivial, not sure how to pass the return value: List<Integer> if using recursive method.\\n\\nLooks like we can use global variables, any better ideas?"
                    },
                    {
                        "username": "nishant7372",
                        "content": "if you want to avoid using global variable, then create another function and pass list/vector to it."
                    },
                    {
                        "username": "ivozayas",
                        "content": "excuse me?\\n\\nInput\\nroot =\\n[1,4,3,2]\\n\\nOutput\\n[1,4,3,2]\\n\\nExpected\\n[1,4,2,3]"
                    },
                    {
                        "username": "ysosalty",
                        "content": "why is there a null at all i dont get it"
                    },
                    {
                        "username": "codearyan",
                        "content": "why this code doesn\\'t work like is there a way to code it in same function without creating a helper one \\n\\n\\nvector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n       \\n        if (root  == NULL) {\\n            return v ;\\n        }\\n        \\n       v.push_back(root->val);\\n        preorderTraversal(root->left);\\n       preorderTraversal(root->right);\\n       return v;\\n        \\n    }"
                    },
                    {
                        "username": "codearyan",
                        "content": "[@andresstawski](/andresstawski)  the vector declaration is wrong else the code works thank you so much.\\n"
                    },
                    {
                        "username": "andresstawski",
                        "content": "put vector v outside of the function\\n\\nclass Solution {\\npublic:\\n    \\nvector<int> ans;\\n\\n    vector<int> preorderTraversal(TreeNode* root) {\\n       \\n\\n        if (root == NULL) return ans;\\n        \\n        ans.push_back(root -> val);\\n    \\n        if (root->left) preorderTraversal(root->left);\\n        if (root->right) preorderTraversal(root->right);\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Each time `preorderTraversal()` gets called the function creates an empty `std::vector` and returns it at the end. But the recursive calls (`preorderTraversal(root->left);` and `preorderTraversal(root->right);`) create their own `std::vector` which gets discarded. Therefore in the end the result is a `std::vector` with a single element, the value of the `root` (or none if the `root` is `NULL`).\\n\\nCreating a helper function that takes the `std::vector` by reference allows the recursive calls to write to the exact same `std::vector`."
                    },
                    {
                        "username": "andresstawski",
                        "content": "using vector as a global variable instead of local variable helped me solve issue where I could not push the last node to the vector."
                    }
                ]
            },
            {
                "id": 2045738,
                "content": [
                    {
                        "username": "SDWillems",
                        "content": "This is my First Leetcode challenge I take.\\nSo you get a little bit of explenation what a Binary Tree is and what ways there are to traverse. Then you directly must make an question without any knowledge of how you can do this? On top of that they add that you must return a list, what makes it Way harder bc now you need to create a new list everytime and add it recursivly?? \\n\\nMy question: HOW can one learn from this? I don\\'t see how you learn from not knowing what you must do or how you can get at it. The only way I know how to do it is from looking at the answers.. There must be a lesson but I just cannot find it.."
                    },
                    {
                        "username": "VinayakNegi",
                        "content": "this platform is not for learning, this is for practicing what you already know if you think that these questions will help you learn without you having prior knowledge then it\\'ll be a hell for you here. \\nI suggest you to go and watch a few videos, practice a few questions and then implement it. \\n"
                    },
                    {
                        "username": "bean_bean005",
                        "content": "`int* preorderTraversal(struct TreeNode* root, int* returnSize){\nstruct TreeNode* p=(struct TreeNode*) malloc(sizeof(struct TreeNode));\nif(root){\n    p=root->val;\n    preorderTraversal(root->left, returnSize);\n    preorderTraversal(root->right, returnSize);\n}\nreturn p;\n}`\nWhat is wrong with this C solution"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The function should return an array of `int`, and communicate the number of elements in the array via the OUT-parameter `returnSize`. So in some way you will have to allocate enough memory for all values in the tree, write the values to the array, and return it.  \\nIn this solution the function allocates memory for a single `struct TreeNode`, stores the value of the `root` in that allocated memory, calls itself recursively for the left and right subtree and discards the result of those function calls. That doesn\\'t work at all.  \\n\\nHow about this: First count the number of nodes in the tree, then allocate enough memory for the result, then call a \"helper function\" that writes to the array and calls itself recursively."
                    },
                    {
                        "username": "ajaymaida17",
                        "content": "100% beats  c++ easy Iterative solution: \nHINT: \nuse Stack to process each node;\npush right element first and then left .\nand process stack till it becomes an empty.\n\n\n\n\n\n\n\n\n         vector<int> v;\n        stack<TreeNode*> st;\n        if(root==NULL) return v;\n        st.push(root);\n        while(!st.empty()){\n            TreeNode* temp=st.top();\n            st.pop();\n            v.push_back(temp->val);\n            if(temp->right!=NULL)st.push(temp->right);\n            if(temp->left!=NULL)st.push(temp->left);\n        }\n        return v; "
                    },
                    {
                        "username": "rjalali",
                        "content": "We deserved this after yesterday\\'s problem."
                    },
                    {
                        "username": "Petersburg",
                        "content": "Why do some answers use while root or stack: and others use while stack: ?\\n\\nUsually the latter is much simpler and I cannot understand the thought process behind \\nwhile root or stack:\\n\\nCan anyone help me here?"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "As you understood the second approach:\\nbasically here you are pushing the right then left, so when you go to the next iteration you pick the left part of the current node from stack first. And after completing that part you come to the right part of the current node.\\n\\nIn the first approach , instead of pushing the left part and poping it from the stack, we just take that left part into root as:\\n    root=root->left and continue pushing the right part.\\nSo, you need to check either stack is not empty or root exists in the first approach as the iteration condition.\\n\\n"
                    },
                    {
                        "username": "arthurjwannerjr",
                        "content": "It basically means that the loop will keep looping if the data exists.\\n\"while root\" will keep looping if the node named root exists and continues to exist.\\n\"while stack\" will keep looping as long as the stack is not empty."
                    },
                    {
                        "username": "feiger123",
                        "content": "although recursive is trivial, not sure how to pass the return value: List<Integer> if using recursive method.\\n\\nLooks like we can use global variables, any better ideas?"
                    },
                    {
                        "username": "nishant7372",
                        "content": "if you want to avoid using global variable, then create another function and pass list/vector to it."
                    },
                    {
                        "username": "ivozayas",
                        "content": "excuse me?\\n\\nInput\\nroot =\\n[1,4,3,2]\\n\\nOutput\\n[1,4,3,2]\\n\\nExpected\\n[1,4,2,3]"
                    },
                    {
                        "username": "ysosalty",
                        "content": "why is there a null at all i dont get it"
                    },
                    {
                        "username": "codearyan",
                        "content": "why this code doesn\\'t work like is there a way to code it in same function without creating a helper one \\n\\n\\nvector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n       \\n        if (root  == NULL) {\\n            return v ;\\n        }\\n        \\n       v.push_back(root->val);\\n        preorderTraversal(root->left);\\n       preorderTraversal(root->right);\\n       return v;\\n        \\n    }"
                    },
                    {
                        "username": "codearyan",
                        "content": "[@andresstawski](/andresstawski)  the vector declaration is wrong else the code works thank you so much.\\n"
                    },
                    {
                        "username": "andresstawski",
                        "content": "put vector v outside of the function\\n\\nclass Solution {\\npublic:\\n    \\nvector<int> ans;\\n\\n    vector<int> preorderTraversal(TreeNode* root) {\\n       \\n\\n        if (root == NULL) return ans;\\n        \\n        ans.push_back(root -> val);\\n    \\n        if (root->left) preorderTraversal(root->left);\\n        if (root->right) preorderTraversal(root->right);\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Each time `preorderTraversal()` gets called the function creates an empty `std::vector` and returns it at the end. But the recursive calls (`preorderTraversal(root->left);` and `preorderTraversal(root->right);`) create their own `std::vector` which gets discarded. Therefore in the end the result is a `std::vector` with a single element, the value of the `root` (or none if the `root` is `NULL`).\\n\\nCreating a helper function that takes the `std::vector` by reference allows the recursive calls to write to the exact same `std::vector`."
                    },
                    {
                        "username": "andresstawski",
                        "content": "using vector as a global variable instead of local variable helped me solve issue where I could not push the last node to the vector."
                    }
                ]
            },
            {
                "id": 1950035,
                "content": [
                    {
                        "username": "SDWillems",
                        "content": "This is my First Leetcode challenge I take.\\nSo you get a little bit of explenation what a Binary Tree is and what ways there are to traverse. Then you directly must make an question without any knowledge of how you can do this? On top of that they add that you must return a list, what makes it Way harder bc now you need to create a new list everytime and add it recursivly?? \\n\\nMy question: HOW can one learn from this? I don\\'t see how you learn from not knowing what you must do or how you can get at it. The only way I know how to do it is from looking at the answers.. There must be a lesson but I just cannot find it.."
                    },
                    {
                        "username": "VinayakNegi",
                        "content": "this platform is not for learning, this is for practicing what you already know if you think that these questions will help you learn without you having prior knowledge then it\\'ll be a hell for you here. \\nI suggest you to go and watch a few videos, practice a few questions and then implement it. \\n"
                    },
                    {
                        "username": "bean_bean005",
                        "content": "`int* preorderTraversal(struct TreeNode* root, int* returnSize){\nstruct TreeNode* p=(struct TreeNode*) malloc(sizeof(struct TreeNode));\nif(root){\n    p=root->val;\n    preorderTraversal(root->left, returnSize);\n    preorderTraversal(root->right, returnSize);\n}\nreturn p;\n}`\nWhat is wrong with this C solution"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The function should return an array of `int`, and communicate the number of elements in the array via the OUT-parameter `returnSize`. So in some way you will have to allocate enough memory for all values in the tree, write the values to the array, and return it.  \\nIn this solution the function allocates memory for a single `struct TreeNode`, stores the value of the `root` in that allocated memory, calls itself recursively for the left and right subtree and discards the result of those function calls. That doesn\\'t work at all.  \\n\\nHow about this: First count the number of nodes in the tree, then allocate enough memory for the result, then call a \"helper function\" that writes to the array and calls itself recursively."
                    },
                    {
                        "username": "ajaymaida17",
                        "content": "100% beats  c++ easy Iterative solution: \nHINT: \nuse Stack to process each node;\npush right element first and then left .\nand process stack till it becomes an empty.\n\n\n\n\n\n\n\n\n         vector<int> v;\n        stack<TreeNode*> st;\n        if(root==NULL) return v;\n        st.push(root);\n        while(!st.empty()){\n            TreeNode* temp=st.top();\n            st.pop();\n            v.push_back(temp->val);\n            if(temp->right!=NULL)st.push(temp->right);\n            if(temp->left!=NULL)st.push(temp->left);\n        }\n        return v; "
                    },
                    {
                        "username": "rjalali",
                        "content": "We deserved this after yesterday\\'s problem."
                    },
                    {
                        "username": "Petersburg",
                        "content": "Why do some answers use while root or stack: and others use while stack: ?\\n\\nUsually the latter is much simpler and I cannot understand the thought process behind \\nwhile root or stack:\\n\\nCan anyone help me here?"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "As you understood the second approach:\\nbasically here you are pushing the right then left, so when you go to the next iteration you pick the left part of the current node from stack first. And after completing that part you come to the right part of the current node.\\n\\nIn the first approach , instead of pushing the left part and poping it from the stack, we just take that left part into root as:\\n    root=root->left and continue pushing the right part.\\nSo, you need to check either stack is not empty or root exists in the first approach as the iteration condition.\\n\\n"
                    },
                    {
                        "username": "arthurjwannerjr",
                        "content": "It basically means that the loop will keep looping if the data exists.\\n\"while root\" will keep looping if the node named root exists and continues to exist.\\n\"while stack\" will keep looping as long as the stack is not empty."
                    },
                    {
                        "username": "feiger123",
                        "content": "although recursive is trivial, not sure how to pass the return value: List<Integer> if using recursive method.\\n\\nLooks like we can use global variables, any better ideas?"
                    },
                    {
                        "username": "nishant7372",
                        "content": "if you want to avoid using global variable, then create another function and pass list/vector to it."
                    },
                    {
                        "username": "ivozayas",
                        "content": "excuse me?\\n\\nInput\\nroot =\\n[1,4,3,2]\\n\\nOutput\\n[1,4,3,2]\\n\\nExpected\\n[1,4,2,3]"
                    },
                    {
                        "username": "ysosalty",
                        "content": "why is there a null at all i dont get it"
                    },
                    {
                        "username": "codearyan",
                        "content": "why this code doesn\\'t work like is there a way to code it in same function without creating a helper one \\n\\n\\nvector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n       \\n        if (root  == NULL) {\\n            return v ;\\n        }\\n        \\n       v.push_back(root->val);\\n        preorderTraversal(root->left);\\n       preorderTraversal(root->right);\\n       return v;\\n        \\n    }"
                    },
                    {
                        "username": "codearyan",
                        "content": "[@andresstawski](/andresstawski)  the vector declaration is wrong else the code works thank you so much.\\n"
                    },
                    {
                        "username": "andresstawski",
                        "content": "put vector v outside of the function\\n\\nclass Solution {\\npublic:\\n    \\nvector<int> ans;\\n\\n    vector<int> preorderTraversal(TreeNode* root) {\\n       \\n\\n        if (root == NULL) return ans;\\n        \\n        ans.push_back(root -> val);\\n    \\n        if (root->left) preorderTraversal(root->left);\\n        if (root->right) preorderTraversal(root->right);\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Each time `preorderTraversal()` gets called the function creates an empty `std::vector` and returns it at the end. But the recursive calls (`preorderTraversal(root->left);` and `preorderTraversal(root->right);`) create their own `std::vector` which gets discarded. Therefore in the end the result is a `std::vector` with a single element, the value of the `root` (or none if the `root` is `NULL`).\\n\\nCreating a helper function that takes the `std::vector` by reference allows the recursive calls to write to the exact same `std::vector`."
                    },
                    {
                        "username": "andresstawski",
                        "content": "using vector as a global variable instead of local variable helped me solve issue where I could not push the last node to the vector."
                    }
                ]
            },
            {
                "id": 1901509,
                "content": [
                    {
                        "username": "SDWillems",
                        "content": "This is my First Leetcode challenge I take.\\nSo you get a little bit of explenation what a Binary Tree is and what ways there are to traverse. Then you directly must make an question without any knowledge of how you can do this? On top of that they add that you must return a list, what makes it Way harder bc now you need to create a new list everytime and add it recursivly?? \\n\\nMy question: HOW can one learn from this? I don\\'t see how you learn from not knowing what you must do or how you can get at it. The only way I know how to do it is from looking at the answers.. There must be a lesson but I just cannot find it.."
                    },
                    {
                        "username": "VinayakNegi",
                        "content": "this platform is not for learning, this is for practicing what you already know if you think that these questions will help you learn without you having prior knowledge then it\\'ll be a hell for you here. \\nI suggest you to go and watch a few videos, practice a few questions and then implement it. \\n"
                    },
                    {
                        "username": "bean_bean005",
                        "content": "`int* preorderTraversal(struct TreeNode* root, int* returnSize){\nstruct TreeNode* p=(struct TreeNode*) malloc(sizeof(struct TreeNode));\nif(root){\n    p=root->val;\n    preorderTraversal(root->left, returnSize);\n    preorderTraversal(root->right, returnSize);\n}\nreturn p;\n}`\nWhat is wrong with this C solution"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The function should return an array of `int`, and communicate the number of elements in the array via the OUT-parameter `returnSize`. So in some way you will have to allocate enough memory for all values in the tree, write the values to the array, and return it.  \\nIn this solution the function allocates memory for a single `struct TreeNode`, stores the value of the `root` in that allocated memory, calls itself recursively for the left and right subtree and discards the result of those function calls. That doesn\\'t work at all.  \\n\\nHow about this: First count the number of nodes in the tree, then allocate enough memory for the result, then call a \"helper function\" that writes to the array and calls itself recursively."
                    },
                    {
                        "username": "ajaymaida17",
                        "content": "100% beats  c++ easy Iterative solution: \nHINT: \nuse Stack to process each node;\npush right element first and then left .\nand process stack till it becomes an empty.\n\n\n\n\n\n\n\n\n         vector<int> v;\n        stack<TreeNode*> st;\n        if(root==NULL) return v;\n        st.push(root);\n        while(!st.empty()){\n            TreeNode* temp=st.top();\n            st.pop();\n            v.push_back(temp->val);\n            if(temp->right!=NULL)st.push(temp->right);\n            if(temp->left!=NULL)st.push(temp->left);\n        }\n        return v; "
                    },
                    {
                        "username": "rjalali",
                        "content": "We deserved this after yesterday\\'s problem."
                    },
                    {
                        "username": "Petersburg",
                        "content": "Why do some answers use while root or stack: and others use while stack: ?\\n\\nUsually the latter is much simpler and I cannot understand the thought process behind \\nwhile root or stack:\\n\\nCan anyone help me here?"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "As you understood the second approach:\\nbasically here you are pushing the right then left, so when you go to the next iteration you pick the left part of the current node from stack first. And after completing that part you come to the right part of the current node.\\n\\nIn the first approach , instead of pushing the left part and poping it from the stack, we just take that left part into root as:\\n    root=root->left and continue pushing the right part.\\nSo, you need to check either stack is not empty or root exists in the first approach as the iteration condition.\\n\\n"
                    },
                    {
                        "username": "arthurjwannerjr",
                        "content": "It basically means that the loop will keep looping if the data exists.\\n\"while root\" will keep looping if the node named root exists and continues to exist.\\n\"while stack\" will keep looping as long as the stack is not empty."
                    },
                    {
                        "username": "feiger123",
                        "content": "although recursive is trivial, not sure how to pass the return value: List<Integer> if using recursive method.\\n\\nLooks like we can use global variables, any better ideas?"
                    },
                    {
                        "username": "nishant7372",
                        "content": "if you want to avoid using global variable, then create another function and pass list/vector to it."
                    },
                    {
                        "username": "ivozayas",
                        "content": "excuse me?\\n\\nInput\\nroot =\\n[1,4,3,2]\\n\\nOutput\\n[1,4,3,2]\\n\\nExpected\\n[1,4,2,3]"
                    },
                    {
                        "username": "ysosalty",
                        "content": "why is there a null at all i dont get it"
                    },
                    {
                        "username": "codearyan",
                        "content": "why this code doesn\\'t work like is there a way to code it in same function without creating a helper one \\n\\n\\nvector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n       \\n        if (root  == NULL) {\\n            return v ;\\n        }\\n        \\n       v.push_back(root->val);\\n        preorderTraversal(root->left);\\n       preorderTraversal(root->right);\\n       return v;\\n        \\n    }"
                    },
                    {
                        "username": "codearyan",
                        "content": "[@andresstawski](/andresstawski)  the vector declaration is wrong else the code works thank you so much.\\n"
                    },
                    {
                        "username": "andresstawski",
                        "content": "put vector v outside of the function\\n\\nclass Solution {\\npublic:\\n    \\nvector<int> ans;\\n\\n    vector<int> preorderTraversal(TreeNode* root) {\\n       \\n\\n        if (root == NULL) return ans;\\n        \\n        ans.push_back(root -> val);\\n    \\n        if (root->left) preorderTraversal(root->left);\\n        if (root->right) preorderTraversal(root->right);\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Each time `preorderTraversal()` gets called the function creates an empty `std::vector` and returns it at the end. But the recursive calls (`preorderTraversal(root->left);` and `preorderTraversal(root->right);`) create their own `std::vector` which gets discarded. Therefore in the end the result is a `std::vector` with a single element, the value of the `root` (or none if the `root` is `NULL`).\\n\\nCreating a helper function that takes the `std::vector` by reference allows the recursive calls to write to the exact same `std::vector`."
                    },
                    {
                        "username": "andresstawski",
                        "content": "using vector as a global variable instead of local variable helped me solve issue where I could not push the last node to the vector."
                    }
                ]
            },
            {
                "id": 1851840,
                "content": [
                    {
                        "username": "williamtheconqueror",
                        "content": "love how this used to be medium"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Use Self function to work on"
                    },
                    {
                        "username": "seelamadisheshu149",
                        "content": "Explanation step by step in recursive method:\\n1. create a return type list\\n2.call the preorder function\\n    In preorder function\\n       1.base condition \\n       2. data leftnode right node \\n3.return list;\\n\\npreorder data leftnode rightnode\\ninorder leftnode data rightnode\\npostorder leftnode rightnode data"
                    },
                    {
                        "username": "SumitHere",
                        "content": "This is what I\\'m doing in Swift. it\\'s not working but same logic is working in Java.\\n\\nclass Solution {\\n            var arr = [Int]()\\n    func preorderTraversal(_ root: TreeNode?) -> [Int] {\\n        if root == nil {\\n            return arr\\n        }\\n        arr.append(root!.val)\\n        if root?.left != nil {\\n            preorderTraversal(root?.left)\\n        } else if root?.right != nil {\\n            preorderTraversal(root?.right)\\n        }\\n        return arr\\n    }\\n}"
                    },
                    {
                        "username": "user3571Ej",
                        "content": "```C++\\n    vector<int> preorderTraversal(TreeNode* root) {\\n    \\n        static vector<int> v;\\n        if(!root)\\n            return {};\\n        v.push_back(root->val);\\n        preorderTraversal(root->left);\\n        preorderTraversal(root->right);\\n        return v;\\n    }\\n```\\nthis should work but for this test case it shows it has fails \\n\\ntest case => root = [1] in my computer it return 1 but in the web ide provided by leetcode it return [1,2,3,1] as output which is weird "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`v` is a `static` local variable, it keeps its value across the function calls. Remove that keyword `static`."
                    },
                    {
                        "username": "vishwajeet_004",
                        "content": "I tried to solve this problem and in starting I was not able to solve and Today I solved it after few mins of pain"
                    },
                    {
                        "username": "juggernaut1101",
                        "content": "Any suggestions on where I can start to learn about trees from scratch?"
                    },
                    {
                        "username": "tinnamchoi",
                        "content": "mfw i misunderstood what preorder traversal was and did bfs instead of dfs"
                    },
                    {
                        "username": "bipul007",
                        "content": "This ques can be solved by creating a viod func having parameters root and a vector to store the root."
                    },
                    {
                        "username": "pr0107",
                        "content": "You know the happiness of getting this question after getting max points on line"
                    }
                ]
            },
            {
                "id": 1801928,
                "content": [
                    {
                        "username": "williamtheconqueror",
                        "content": "love how this used to be medium"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Use Self function to work on"
                    },
                    {
                        "username": "seelamadisheshu149",
                        "content": "Explanation step by step in recursive method:\\n1. create a return type list\\n2.call the preorder function\\n    In preorder function\\n       1.base condition \\n       2. data leftnode right node \\n3.return list;\\n\\npreorder data leftnode rightnode\\ninorder leftnode data rightnode\\npostorder leftnode rightnode data"
                    },
                    {
                        "username": "SumitHere",
                        "content": "This is what I\\'m doing in Swift. it\\'s not working but same logic is working in Java.\\n\\nclass Solution {\\n            var arr = [Int]()\\n    func preorderTraversal(_ root: TreeNode?) -> [Int] {\\n        if root == nil {\\n            return arr\\n        }\\n        arr.append(root!.val)\\n        if root?.left != nil {\\n            preorderTraversal(root?.left)\\n        } else if root?.right != nil {\\n            preorderTraversal(root?.right)\\n        }\\n        return arr\\n    }\\n}"
                    },
                    {
                        "username": "user3571Ej",
                        "content": "```C++\\n    vector<int> preorderTraversal(TreeNode* root) {\\n    \\n        static vector<int> v;\\n        if(!root)\\n            return {};\\n        v.push_back(root->val);\\n        preorderTraversal(root->left);\\n        preorderTraversal(root->right);\\n        return v;\\n    }\\n```\\nthis should work but for this test case it shows it has fails \\n\\ntest case => root = [1] in my computer it return 1 but in the web ide provided by leetcode it return [1,2,3,1] as output which is weird "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`v` is a `static` local variable, it keeps its value across the function calls. Remove that keyword `static`."
                    },
                    {
                        "username": "vishwajeet_004",
                        "content": "I tried to solve this problem and in starting I was not able to solve and Today I solved it after few mins of pain"
                    },
                    {
                        "username": "juggernaut1101",
                        "content": "Any suggestions on where I can start to learn about trees from scratch?"
                    },
                    {
                        "username": "tinnamchoi",
                        "content": "mfw i misunderstood what preorder traversal was and did bfs instead of dfs"
                    },
                    {
                        "username": "bipul007",
                        "content": "This ques can be solved by creating a viod func having parameters root and a vector to store the root."
                    },
                    {
                        "username": "pr0107",
                        "content": "You know the happiness of getting this question after getting max points on line"
                    }
                ]
            },
            {
                "id": 1800542,
                "content": [
                    {
                        "username": "williamtheconqueror",
                        "content": "love how this used to be medium"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Use Self function to work on"
                    },
                    {
                        "username": "seelamadisheshu149",
                        "content": "Explanation step by step in recursive method:\\n1. create a return type list\\n2.call the preorder function\\n    In preorder function\\n       1.base condition \\n       2. data leftnode right node \\n3.return list;\\n\\npreorder data leftnode rightnode\\ninorder leftnode data rightnode\\npostorder leftnode rightnode data"
                    },
                    {
                        "username": "SumitHere",
                        "content": "This is what I\\'m doing in Swift. it\\'s not working but same logic is working in Java.\\n\\nclass Solution {\\n            var arr = [Int]()\\n    func preorderTraversal(_ root: TreeNode?) -> [Int] {\\n        if root == nil {\\n            return arr\\n        }\\n        arr.append(root!.val)\\n        if root?.left != nil {\\n            preorderTraversal(root?.left)\\n        } else if root?.right != nil {\\n            preorderTraversal(root?.right)\\n        }\\n        return arr\\n    }\\n}"
                    },
                    {
                        "username": "user3571Ej",
                        "content": "```C++\\n    vector<int> preorderTraversal(TreeNode* root) {\\n    \\n        static vector<int> v;\\n        if(!root)\\n            return {};\\n        v.push_back(root->val);\\n        preorderTraversal(root->left);\\n        preorderTraversal(root->right);\\n        return v;\\n    }\\n```\\nthis should work but for this test case it shows it has fails \\n\\ntest case => root = [1] in my computer it return 1 but in the web ide provided by leetcode it return [1,2,3,1] as output which is weird "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`v` is a `static` local variable, it keeps its value across the function calls. Remove that keyword `static`."
                    },
                    {
                        "username": "vishwajeet_004",
                        "content": "I tried to solve this problem and in starting I was not able to solve and Today I solved it after few mins of pain"
                    },
                    {
                        "username": "juggernaut1101",
                        "content": "Any suggestions on where I can start to learn about trees from scratch?"
                    },
                    {
                        "username": "tinnamchoi",
                        "content": "mfw i misunderstood what preorder traversal was and did bfs instead of dfs"
                    },
                    {
                        "username": "bipul007",
                        "content": "This ques can be solved by creating a viod func having parameters root and a vector to store the root."
                    },
                    {
                        "username": "pr0107",
                        "content": "You know the happiness of getting this question after getting max points on line"
                    }
                ]
            },
            {
                "id": 1772395,
                "content": [
                    {
                        "username": "williamtheconqueror",
                        "content": "love how this used to be medium"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Use Self function to work on"
                    },
                    {
                        "username": "seelamadisheshu149",
                        "content": "Explanation step by step in recursive method:\\n1. create a return type list\\n2.call the preorder function\\n    In preorder function\\n       1.base condition \\n       2. data leftnode right node \\n3.return list;\\n\\npreorder data leftnode rightnode\\ninorder leftnode data rightnode\\npostorder leftnode rightnode data"
                    },
                    {
                        "username": "SumitHere",
                        "content": "This is what I\\'m doing in Swift. it\\'s not working but same logic is working in Java.\\n\\nclass Solution {\\n            var arr = [Int]()\\n    func preorderTraversal(_ root: TreeNode?) -> [Int] {\\n        if root == nil {\\n            return arr\\n        }\\n        arr.append(root!.val)\\n        if root?.left != nil {\\n            preorderTraversal(root?.left)\\n        } else if root?.right != nil {\\n            preorderTraversal(root?.right)\\n        }\\n        return arr\\n    }\\n}"
                    },
                    {
                        "username": "user3571Ej",
                        "content": "```C++\\n    vector<int> preorderTraversal(TreeNode* root) {\\n    \\n        static vector<int> v;\\n        if(!root)\\n            return {};\\n        v.push_back(root->val);\\n        preorderTraversal(root->left);\\n        preorderTraversal(root->right);\\n        return v;\\n    }\\n```\\nthis should work but for this test case it shows it has fails \\n\\ntest case => root = [1] in my computer it return 1 but in the web ide provided by leetcode it return [1,2,3,1] as output which is weird "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`v` is a `static` local variable, it keeps its value across the function calls. Remove that keyword `static`."
                    },
                    {
                        "username": "vishwajeet_004",
                        "content": "I tried to solve this problem and in starting I was not able to solve and Today I solved it after few mins of pain"
                    },
                    {
                        "username": "juggernaut1101",
                        "content": "Any suggestions on where I can start to learn about trees from scratch?"
                    },
                    {
                        "username": "tinnamchoi",
                        "content": "mfw i misunderstood what preorder traversal was and did bfs instead of dfs"
                    },
                    {
                        "username": "bipul007",
                        "content": "This ques can be solved by creating a viod func having parameters root and a vector to store the root."
                    },
                    {
                        "username": "pr0107",
                        "content": "You know the happiness of getting this question after getting max points on line"
                    }
                ]
            },
            {
                "id": 1754967,
                "content": [
                    {
                        "username": "williamtheconqueror",
                        "content": "love how this used to be medium"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Use Self function to work on"
                    },
                    {
                        "username": "seelamadisheshu149",
                        "content": "Explanation step by step in recursive method:\\n1. create a return type list\\n2.call the preorder function\\n    In preorder function\\n       1.base condition \\n       2. data leftnode right node \\n3.return list;\\n\\npreorder data leftnode rightnode\\ninorder leftnode data rightnode\\npostorder leftnode rightnode data"
                    },
                    {
                        "username": "SumitHere",
                        "content": "This is what I\\'m doing in Swift. it\\'s not working but same logic is working in Java.\\n\\nclass Solution {\\n            var arr = [Int]()\\n    func preorderTraversal(_ root: TreeNode?) -> [Int] {\\n        if root == nil {\\n            return arr\\n        }\\n        arr.append(root!.val)\\n        if root?.left != nil {\\n            preorderTraversal(root?.left)\\n        } else if root?.right != nil {\\n            preorderTraversal(root?.right)\\n        }\\n        return arr\\n    }\\n}"
                    },
                    {
                        "username": "user3571Ej",
                        "content": "```C++\\n    vector<int> preorderTraversal(TreeNode* root) {\\n    \\n        static vector<int> v;\\n        if(!root)\\n            return {};\\n        v.push_back(root->val);\\n        preorderTraversal(root->left);\\n        preorderTraversal(root->right);\\n        return v;\\n    }\\n```\\nthis should work but for this test case it shows it has fails \\n\\ntest case => root = [1] in my computer it return 1 but in the web ide provided by leetcode it return [1,2,3,1] as output which is weird "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`v` is a `static` local variable, it keeps its value across the function calls. Remove that keyword `static`."
                    },
                    {
                        "username": "vishwajeet_004",
                        "content": "I tried to solve this problem and in starting I was not able to solve and Today I solved it after few mins of pain"
                    },
                    {
                        "username": "juggernaut1101",
                        "content": "Any suggestions on where I can start to learn about trees from scratch?"
                    },
                    {
                        "username": "tinnamchoi",
                        "content": "mfw i misunderstood what preorder traversal was and did bfs instead of dfs"
                    },
                    {
                        "username": "bipul007",
                        "content": "This ques can be solved by creating a viod func having parameters root and a vector to store the root."
                    },
                    {
                        "username": "pr0107",
                        "content": "You know the happiness of getting this question after getting max points on line"
                    }
                ]
            },
            {
                "id": 1750338,
                "content": [
                    {
                        "username": "williamtheconqueror",
                        "content": "love how this used to be medium"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Use Self function to work on"
                    },
                    {
                        "username": "seelamadisheshu149",
                        "content": "Explanation step by step in recursive method:\\n1. create a return type list\\n2.call the preorder function\\n    In preorder function\\n       1.base condition \\n       2. data leftnode right node \\n3.return list;\\n\\npreorder data leftnode rightnode\\ninorder leftnode data rightnode\\npostorder leftnode rightnode data"
                    },
                    {
                        "username": "SumitHere",
                        "content": "This is what I\\'m doing in Swift. it\\'s not working but same logic is working in Java.\\n\\nclass Solution {\\n            var arr = [Int]()\\n    func preorderTraversal(_ root: TreeNode?) -> [Int] {\\n        if root == nil {\\n            return arr\\n        }\\n        arr.append(root!.val)\\n        if root?.left != nil {\\n            preorderTraversal(root?.left)\\n        } else if root?.right != nil {\\n            preorderTraversal(root?.right)\\n        }\\n        return arr\\n    }\\n}"
                    },
                    {
                        "username": "user3571Ej",
                        "content": "```C++\\n    vector<int> preorderTraversal(TreeNode* root) {\\n    \\n        static vector<int> v;\\n        if(!root)\\n            return {};\\n        v.push_back(root->val);\\n        preorderTraversal(root->left);\\n        preorderTraversal(root->right);\\n        return v;\\n    }\\n```\\nthis should work but for this test case it shows it has fails \\n\\ntest case => root = [1] in my computer it return 1 but in the web ide provided by leetcode it return [1,2,3,1] as output which is weird "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`v` is a `static` local variable, it keeps its value across the function calls. Remove that keyword `static`."
                    },
                    {
                        "username": "vishwajeet_004",
                        "content": "I tried to solve this problem and in starting I was not able to solve and Today I solved it after few mins of pain"
                    },
                    {
                        "username": "juggernaut1101",
                        "content": "Any suggestions on where I can start to learn about trees from scratch?"
                    },
                    {
                        "username": "tinnamchoi",
                        "content": "mfw i misunderstood what preorder traversal was and did bfs instead of dfs"
                    },
                    {
                        "username": "bipul007",
                        "content": "This ques can be solved by creating a viod func having parameters root and a vector to store the root."
                    },
                    {
                        "username": "pr0107",
                        "content": "You know the happiness of getting this question after getting max points on line"
                    }
                ]
            },
            {
                "id": 1750278,
                "content": [
                    {
                        "username": "williamtheconqueror",
                        "content": "love how this used to be medium"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Use Self function to work on"
                    },
                    {
                        "username": "seelamadisheshu149",
                        "content": "Explanation step by step in recursive method:\\n1. create a return type list\\n2.call the preorder function\\n    In preorder function\\n       1.base condition \\n       2. data leftnode right node \\n3.return list;\\n\\npreorder data leftnode rightnode\\ninorder leftnode data rightnode\\npostorder leftnode rightnode data"
                    },
                    {
                        "username": "SumitHere",
                        "content": "This is what I\\'m doing in Swift. it\\'s not working but same logic is working in Java.\\n\\nclass Solution {\\n            var arr = [Int]()\\n    func preorderTraversal(_ root: TreeNode?) -> [Int] {\\n        if root == nil {\\n            return arr\\n        }\\n        arr.append(root!.val)\\n        if root?.left != nil {\\n            preorderTraversal(root?.left)\\n        } else if root?.right != nil {\\n            preorderTraversal(root?.right)\\n        }\\n        return arr\\n    }\\n}"
                    },
                    {
                        "username": "user3571Ej",
                        "content": "```C++\\n    vector<int> preorderTraversal(TreeNode* root) {\\n    \\n        static vector<int> v;\\n        if(!root)\\n            return {};\\n        v.push_back(root->val);\\n        preorderTraversal(root->left);\\n        preorderTraversal(root->right);\\n        return v;\\n    }\\n```\\nthis should work but for this test case it shows it has fails \\n\\ntest case => root = [1] in my computer it return 1 but in the web ide provided by leetcode it return [1,2,3,1] as output which is weird "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`v` is a `static` local variable, it keeps its value across the function calls. Remove that keyword `static`."
                    },
                    {
                        "username": "vishwajeet_004",
                        "content": "I tried to solve this problem and in starting I was not able to solve and Today I solved it after few mins of pain"
                    },
                    {
                        "username": "juggernaut1101",
                        "content": "Any suggestions on where I can start to learn about trees from scratch?"
                    },
                    {
                        "username": "tinnamchoi",
                        "content": "mfw i misunderstood what preorder traversal was and did bfs instead of dfs"
                    },
                    {
                        "username": "bipul007",
                        "content": "This ques can be solved by creating a viod func having parameters root and a vector to store the root."
                    },
                    {
                        "username": "pr0107",
                        "content": "You know the happiness of getting this question after getting max points on line"
                    }
                ]
            },
            {
                "id": 1750130,
                "content": [
                    {
                        "username": "williamtheconqueror",
                        "content": "love how this used to be medium"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Use Self function to work on"
                    },
                    {
                        "username": "seelamadisheshu149",
                        "content": "Explanation step by step in recursive method:\\n1. create a return type list\\n2.call the preorder function\\n    In preorder function\\n       1.base condition \\n       2. data leftnode right node \\n3.return list;\\n\\npreorder data leftnode rightnode\\ninorder leftnode data rightnode\\npostorder leftnode rightnode data"
                    },
                    {
                        "username": "SumitHere",
                        "content": "This is what I\\'m doing in Swift. it\\'s not working but same logic is working in Java.\\n\\nclass Solution {\\n            var arr = [Int]()\\n    func preorderTraversal(_ root: TreeNode?) -> [Int] {\\n        if root == nil {\\n            return arr\\n        }\\n        arr.append(root!.val)\\n        if root?.left != nil {\\n            preorderTraversal(root?.left)\\n        } else if root?.right != nil {\\n            preorderTraversal(root?.right)\\n        }\\n        return arr\\n    }\\n}"
                    },
                    {
                        "username": "user3571Ej",
                        "content": "```C++\\n    vector<int> preorderTraversal(TreeNode* root) {\\n    \\n        static vector<int> v;\\n        if(!root)\\n            return {};\\n        v.push_back(root->val);\\n        preorderTraversal(root->left);\\n        preorderTraversal(root->right);\\n        return v;\\n    }\\n```\\nthis should work but for this test case it shows it has fails \\n\\ntest case => root = [1] in my computer it return 1 but in the web ide provided by leetcode it return [1,2,3,1] as output which is weird "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`v` is a `static` local variable, it keeps its value across the function calls. Remove that keyword `static`."
                    },
                    {
                        "username": "vishwajeet_004",
                        "content": "I tried to solve this problem and in starting I was not able to solve and Today I solved it after few mins of pain"
                    },
                    {
                        "username": "juggernaut1101",
                        "content": "Any suggestions on where I can start to learn about trees from scratch?"
                    },
                    {
                        "username": "tinnamchoi",
                        "content": "mfw i misunderstood what preorder traversal was and did bfs instead of dfs"
                    },
                    {
                        "username": "bipul007",
                        "content": "This ques can be solved by creating a viod func having parameters root and a vector to store the root."
                    },
                    {
                        "username": "pr0107",
                        "content": "You know the happiness of getting this question after getting max points on line"
                    }
                ]
            },
            {
                "id": 1750129,
                "content": [
                    {
                        "username": "williamtheconqueror",
                        "content": "love how this used to be medium"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Use Self function to work on"
                    },
                    {
                        "username": "seelamadisheshu149",
                        "content": "Explanation step by step in recursive method:\\n1. create a return type list\\n2.call the preorder function\\n    In preorder function\\n       1.base condition \\n       2. data leftnode right node \\n3.return list;\\n\\npreorder data leftnode rightnode\\ninorder leftnode data rightnode\\npostorder leftnode rightnode data"
                    },
                    {
                        "username": "SumitHere",
                        "content": "This is what I\\'m doing in Swift. it\\'s not working but same logic is working in Java.\\n\\nclass Solution {\\n            var arr = [Int]()\\n    func preorderTraversal(_ root: TreeNode?) -> [Int] {\\n        if root == nil {\\n            return arr\\n        }\\n        arr.append(root!.val)\\n        if root?.left != nil {\\n            preorderTraversal(root?.left)\\n        } else if root?.right != nil {\\n            preorderTraversal(root?.right)\\n        }\\n        return arr\\n    }\\n}"
                    },
                    {
                        "username": "user3571Ej",
                        "content": "```C++\\n    vector<int> preorderTraversal(TreeNode* root) {\\n    \\n        static vector<int> v;\\n        if(!root)\\n            return {};\\n        v.push_back(root->val);\\n        preorderTraversal(root->left);\\n        preorderTraversal(root->right);\\n        return v;\\n    }\\n```\\nthis should work but for this test case it shows it has fails \\n\\ntest case => root = [1] in my computer it return 1 but in the web ide provided by leetcode it return [1,2,3,1] as output which is weird "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`v` is a `static` local variable, it keeps its value across the function calls. Remove that keyword `static`."
                    },
                    {
                        "username": "vishwajeet_004",
                        "content": "I tried to solve this problem and in starting I was not able to solve and Today I solved it after few mins of pain"
                    },
                    {
                        "username": "juggernaut1101",
                        "content": "Any suggestions on where I can start to learn about trees from scratch?"
                    },
                    {
                        "username": "tinnamchoi",
                        "content": "mfw i misunderstood what preorder traversal was and did bfs instead of dfs"
                    },
                    {
                        "username": "bipul007",
                        "content": "This ques can be solved by creating a viod func having parameters root and a vector to store the root."
                    },
                    {
                        "username": "pr0107",
                        "content": "You know the happiness of getting this question after getting max points on line"
                    }
                ]
            },
            {
                "id": 1749798,
                "content": [
                    {
                        "username": "williamtheconqueror",
                        "content": "love how this used to be medium"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Use Self function to work on"
                    },
                    {
                        "username": "seelamadisheshu149",
                        "content": "Explanation step by step in recursive method:\\n1. create a return type list\\n2.call the preorder function\\n    In preorder function\\n       1.base condition \\n       2. data leftnode right node \\n3.return list;\\n\\npreorder data leftnode rightnode\\ninorder leftnode data rightnode\\npostorder leftnode rightnode data"
                    },
                    {
                        "username": "SumitHere",
                        "content": "This is what I\\'m doing in Swift. it\\'s not working but same logic is working in Java.\\n\\nclass Solution {\\n            var arr = [Int]()\\n    func preorderTraversal(_ root: TreeNode?) -> [Int] {\\n        if root == nil {\\n            return arr\\n        }\\n        arr.append(root!.val)\\n        if root?.left != nil {\\n            preorderTraversal(root?.left)\\n        } else if root?.right != nil {\\n            preorderTraversal(root?.right)\\n        }\\n        return arr\\n    }\\n}"
                    },
                    {
                        "username": "user3571Ej",
                        "content": "```C++\\n    vector<int> preorderTraversal(TreeNode* root) {\\n    \\n        static vector<int> v;\\n        if(!root)\\n            return {};\\n        v.push_back(root->val);\\n        preorderTraversal(root->left);\\n        preorderTraversal(root->right);\\n        return v;\\n    }\\n```\\nthis should work but for this test case it shows it has fails \\n\\ntest case => root = [1] in my computer it return 1 but in the web ide provided by leetcode it return [1,2,3,1] as output which is weird "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`v` is a `static` local variable, it keeps its value across the function calls. Remove that keyword `static`."
                    },
                    {
                        "username": "vishwajeet_004",
                        "content": "I tried to solve this problem and in starting I was not able to solve and Today I solved it after few mins of pain"
                    },
                    {
                        "username": "juggernaut1101",
                        "content": "Any suggestions on where I can start to learn about trees from scratch?"
                    },
                    {
                        "username": "tinnamchoi",
                        "content": "mfw i misunderstood what preorder traversal was and did bfs instead of dfs"
                    },
                    {
                        "username": "bipul007",
                        "content": "This ques can be solved by creating a viod func having parameters root and a vector to store the root."
                    },
                    {
                        "username": "pr0107",
                        "content": "You know the happiness of getting this question after getting max points on line"
                    }
                ]
            },
            {
                "id": 1749687,
                "content": [
                    {
                        "username": "user4216mR",
                        "content": "Remember :\\nPreorder Traversal : Root | Left | Right.... "
                    },
                    {
                        "username": "hahahamid",
                        "content": "Do I really need to know Morris Traversal?   "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "it\\'s fav question in interview for the BST topic , or in O(1) space complexity to traversing in tree"
                    },
                    {
                        "username": "Praveen135",
                        "content": "c++ easy pesy..\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nvector<int>res;\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        \\n        if(!root)return res;\\n        res.push_back(root->val);\\n        if(root->left){\\n            preorderTraversal(root->left);\\n        }\\n        if(root->right){\\n            preorderTraversal(root->right);\\n        }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "Kishan_Kumar_Pandey_2002",
                        "content": "it\\'s Easy problem .\\nPreOrder Trversal : Root | Left | Right ."
                    },
                    {
                        "username": "shaon_here",
                        "content": "\n    vector<int> preorderTraversal(TreeNode* root) {\n\n        vector<int> res;\n        if(!root)\n            return res;\n        res.push_back(root->val);\n        if(root->left)\n            preorderTraversal(root->left);\n        if(root->right)\n            preorderTraversal(root->right);\n        return res;\n\n    }             \n\n\nCan anyone say why this code returns [1] in case of [1,null,2,3] ?"
                    },
                    {
                        "username": "VedanshNigam",
                        "content": "You need to declare the vector outside the function.\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "nice hills -> extra hard / extra easy"
                    },
                    {
                        "username": "anuAi",
                        "content": "someone pls suggest an approach to solve this problem"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "you can use the following three approaches:\\n1. Using recursion.\\n2. Using iteration with the help of stack.\\n3. Using the Morris approach , which is similar to approach 2 but without using stack."
                    },
                    {
                        "username": "powerpro1",
                        "content": "Root- >Root.left->Root.right"
                    },
                    {
                        "username": "S_Basu",
                        "content": "***Wow!! Surprised** to see Preorder traversal of binary tree after yesterday's question - Max Points on a Line.*\nI thought another BrainF***-ing Question will come today... "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "looks like yesterday\\'s setter got fired"
                    }
                ]
            },
            {
                "id": 1749635,
                "content": [
                    {
                        "username": "user4216mR",
                        "content": "Remember :\\nPreorder Traversal : Root | Left | Right.... "
                    },
                    {
                        "username": "hahahamid",
                        "content": "Do I really need to know Morris Traversal?   "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "it\\'s fav question in interview for the BST topic , or in O(1) space complexity to traversing in tree"
                    },
                    {
                        "username": "Praveen135",
                        "content": "c++ easy pesy..\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nvector<int>res;\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        \\n        if(!root)return res;\\n        res.push_back(root->val);\\n        if(root->left){\\n            preorderTraversal(root->left);\\n        }\\n        if(root->right){\\n            preorderTraversal(root->right);\\n        }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "Kishan_Kumar_Pandey_2002",
                        "content": "it\\'s Easy problem .\\nPreOrder Trversal : Root | Left | Right ."
                    },
                    {
                        "username": "shaon_here",
                        "content": "\n    vector<int> preorderTraversal(TreeNode* root) {\n\n        vector<int> res;\n        if(!root)\n            return res;\n        res.push_back(root->val);\n        if(root->left)\n            preorderTraversal(root->left);\n        if(root->right)\n            preorderTraversal(root->right);\n        return res;\n\n    }             \n\n\nCan anyone say why this code returns [1] in case of [1,null,2,3] ?"
                    },
                    {
                        "username": "VedanshNigam",
                        "content": "You need to declare the vector outside the function.\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "nice hills -> extra hard / extra easy"
                    },
                    {
                        "username": "anuAi",
                        "content": "someone pls suggest an approach to solve this problem"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "you can use the following three approaches:\\n1. Using recursion.\\n2. Using iteration with the help of stack.\\n3. Using the Morris approach , which is similar to approach 2 but without using stack."
                    },
                    {
                        "username": "powerpro1",
                        "content": "Root- >Root.left->Root.right"
                    },
                    {
                        "username": "S_Basu",
                        "content": "***Wow!! Surprised** to see Preorder traversal of binary tree after yesterday's question - Max Points on a Line.*\nI thought another BrainF***-ing Question will come today... "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "looks like yesterday\\'s setter got fired"
                    }
                ]
            },
            {
                "id": 1749616,
                "content": [
                    {
                        "username": "user4216mR",
                        "content": "Remember :\\nPreorder Traversal : Root | Left | Right.... "
                    },
                    {
                        "username": "hahahamid",
                        "content": "Do I really need to know Morris Traversal?   "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "it\\'s fav question in interview for the BST topic , or in O(1) space complexity to traversing in tree"
                    },
                    {
                        "username": "Praveen135",
                        "content": "c++ easy pesy..\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nvector<int>res;\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        \\n        if(!root)return res;\\n        res.push_back(root->val);\\n        if(root->left){\\n            preorderTraversal(root->left);\\n        }\\n        if(root->right){\\n            preorderTraversal(root->right);\\n        }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "Kishan_Kumar_Pandey_2002",
                        "content": "it\\'s Easy problem .\\nPreOrder Trversal : Root | Left | Right ."
                    },
                    {
                        "username": "shaon_here",
                        "content": "\n    vector<int> preorderTraversal(TreeNode* root) {\n\n        vector<int> res;\n        if(!root)\n            return res;\n        res.push_back(root->val);\n        if(root->left)\n            preorderTraversal(root->left);\n        if(root->right)\n            preorderTraversal(root->right);\n        return res;\n\n    }             \n\n\nCan anyone say why this code returns [1] in case of [1,null,2,3] ?"
                    },
                    {
                        "username": "VedanshNigam",
                        "content": "You need to declare the vector outside the function.\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "nice hills -> extra hard / extra easy"
                    },
                    {
                        "username": "anuAi",
                        "content": "someone pls suggest an approach to solve this problem"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "you can use the following three approaches:\\n1. Using recursion.\\n2. Using iteration with the help of stack.\\n3. Using the Morris approach , which is similar to approach 2 but without using stack."
                    },
                    {
                        "username": "powerpro1",
                        "content": "Root- >Root.left->Root.right"
                    },
                    {
                        "username": "S_Basu",
                        "content": "***Wow!! Surprised** to see Preorder traversal of binary tree after yesterday's question - Max Points on a Line.*\nI thought another BrainF***-ing Question will come today... "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "looks like yesterday\\'s setter got fired"
                    }
                ]
            },
            {
                "id": 1749588,
                "content": [
                    {
                        "username": "user4216mR",
                        "content": "Remember :\\nPreorder Traversal : Root | Left | Right.... "
                    },
                    {
                        "username": "hahahamid",
                        "content": "Do I really need to know Morris Traversal?   "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "it\\'s fav question in interview for the BST topic , or in O(1) space complexity to traversing in tree"
                    },
                    {
                        "username": "Praveen135",
                        "content": "c++ easy pesy..\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nvector<int>res;\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        \\n        if(!root)return res;\\n        res.push_back(root->val);\\n        if(root->left){\\n            preorderTraversal(root->left);\\n        }\\n        if(root->right){\\n            preorderTraversal(root->right);\\n        }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "Kishan_Kumar_Pandey_2002",
                        "content": "it\\'s Easy problem .\\nPreOrder Trversal : Root | Left | Right ."
                    },
                    {
                        "username": "shaon_here",
                        "content": "\n    vector<int> preorderTraversal(TreeNode* root) {\n\n        vector<int> res;\n        if(!root)\n            return res;\n        res.push_back(root->val);\n        if(root->left)\n            preorderTraversal(root->left);\n        if(root->right)\n            preorderTraversal(root->right);\n        return res;\n\n    }             \n\n\nCan anyone say why this code returns [1] in case of [1,null,2,3] ?"
                    },
                    {
                        "username": "VedanshNigam",
                        "content": "You need to declare the vector outside the function.\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "nice hills -> extra hard / extra easy"
                    },
                    {
                        "username": "anuAi",
                        "content": "someone pls suggest an approach to solve this problem"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "you can use the following three approaches:\\n1. Using recursion.\\n2. Using iteration with the help of stack.\\n3. Using the Morris approach , which is similar to approach 2 but without using stack."
                    },
                    {
                        "username": "powerpro1",
                        "content": "Root- >Root.left->Root.right"
                    },
                    {
                        "username": "S_Basu",
                        "content": "***Wow!! Surprised** to see Preorder traversal of binary tree after yesterday's question - Max Points on a Line.*\nI thought another BrainF***-ing Question will come today... "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "looks like yesterday\\'s setter got fired"
                    }
                ]
            },
            {
                "id": 1749478,
                "content": [
                    {
                        "username": "user4216mR",
                        "content": "Remember :\\nPreorder Traversal : Root | Left | Right.... "
                    },
                    {
                        "username": "hahahamid",
                        "content": "Do I really need to know Morris Traversal?   "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "it\\'s fav question in interview for the BST topic , or in O(1) space complexity to traversing in tree"
                    },
                    {
                        "username": "Praveen135",
                        "content": "c++ easy pesy..\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nvector<int>res;\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        \\n        if(!root)return res;\\n        res.push_back(root->val);\\n        if(root->left){\\n            preorderTraversal(root->left);\\n        }\\n        if(root->right){\\n            preorderTraversal(root->right);\\n        }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "Kishan_Kumar_Pandey_2002",
                        "content": "it\\'s Easy problem .\\nPreOrder Trversal : Root | Left | Right ."
                    },
                    {
                        "username": "shaon_here",
                        "content": "\n    vector<int> preorderTraversal(TreeNode* root) {\n\n        vector<int> res;\n        if(!root)\n            return res;\n        res.push_back(root->val);\n        if(root->left)\n            preorderTraversal(root->left);\n        if(root->right)\n            preorderTraversal(root->right);\n        return res;\n\n    }             \n\n\nCan anyone say why this code returns [1] in case of [1,null,2,3] ?"
                    },
                    {
                        "username": "VedanshNigam",
                        "content": "You need to declare the vector outside the function.\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "nice hills -> extra hard / extra easy"
                    },
                    {
                        "username": "anuAi",
                        "content": "someone pls suggest an approach to solve this problem"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "you can use the following three approaches:\\n1. Using recursion.\\n2. Using iteration with the help of stack.\\n3. Using the Morris approach , which is similar to approach 2 but without using stack."
                    },
                    {
                        "username": "powerpro1",
                        "content": "Root- >Root.left->Root.right"
                    },
                    {
                        "username": "S_Basu",
                        "content": "***Wow!! Surprised** to see Preorder traversal of binary tree after yesterday's question - Max Points on a Line.*\nI thought another BrainF***-ing Question will come today... "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "looks like yesterday\\'s setter got fired"
                    }
                ]
            },
            {
                "id": 1749392,
                "content": [
                    {
                        "username": "user4216mR",
                        "content": "Remember :\\nPreorder Traversal : Root | Left | Right.... "
                    },
                    {
                        "username": "hahahamid",
                        "content": "Do I really need to know Morris Traversal?   "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "it\\'s fav question in interview for the BST topic , or in O(1) space complexity to traversing in tree"
                    },
                    {
                        "username": "Praveen135",
                        "content": "c++ easy pesy..\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nvector<int>res;\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        \\n        if(!root)return res;\\n        res.push_back(root->val);\\n        if(root->left){\\n            preorderTraversal(root->left);\\n        }\\n        if(root->right){\\n            preorderTraversal(root->right);\\n        }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "Kishan_Kumar_Pandey_2002",
                        "content": "it\\'s Easy problem .\\nPreOrder Trversal : Root | Left | Right ."
                    },
                    {
                        "username": "shaon_here",
                        "content": "\n    vector<int> preorderTraversal(TreeNode* root) {\n\n        vector<int> res;\n        if(!root)\n            return res;\n        res.push_back(root->val);\n        if(root->left)\n            preorderTraversal(root->left);\n        if(root->right)\n            preorderTraversal(root->right);\n        return res;\n\n    }             \n\n\nCan anyone say why this code returns [1] in case of [1,null,2,3] ?"
                    },
                    {
                        "username": "VedanshNigam",
                        "content": "You need to declare the vector outside the function.\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "nice hills -> extra hard / extra easy"
                    },
                    {
                        "username": "anuAi",
                        "content": "someone pls suggest an approach to solve this problem"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "you can use the following three approaches:\\n1. Using recursion.\\n2. Using iteration with the help of stack.\\n3. Using the Morris approach , which is similar to approach 2 but without using stack."
                    },
                    {
                        "username": "powerpro1",
                        "content": "Root- >Root.left->Root.right"
                    },
                    {
                        "username": "S_Basu",
                        "content": "***Wow!! Surprised** to see Preorder traversal of binary tree after yesterday's question - Max Points on a Line.*\nI thought another BrainF***-ing Question will come today... "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "looks like yesterday\\'s setter got fired"
                    }
                ]
            },
            {
                "id": 1749384,
                "content": [
                    {
                        "username": "user4216mR",
                        "content": "Remember :\\nPreorder Traversal : Root | Left | Right.... "
                    },
                    {
                        "username": "hahahamid",
                        "content": "Do I really need to know Morris Traversal?   "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "it\\'s fav question in interview for the BST topic , or in O(1) space complexity to traversing in tree"
                    },
                    {
                        "username": "Praveen135",
                        "content": "c++ easy pesy..\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nvector<int>res;\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        \\n        if(!root)return res;\\n        res.push_back(root->val);\\n        if(root->left){\\n            preorderTraversal(root->left);\\n        }\\n        if(root->right){\\n            preorderTraversal(root->right);\\n        }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "Kishan_Kumar_Pandey_2002",
                        "content": "it\\'s Easy problem .\\nPreOrder Trversal : Root | Left | Right ."
                    },
                    {
                        "username": "shaon_here",
                        "content": "\n    vector<int> preorderTraversal(TreeNode* root) {\n\n        vector<int> res;\n        if(!root)\n            return res;\n        res.push_back(root->val);\n        if(root->left)\n            preorderTraversal(root->left);\n        if(root->right)\n            preorderTraversal(root->right);\n        return res;\n\n    }             \n\n\nCan anyone say why this code returns [1] in case of [1,null,2,3] ?"
                    },
                    {
                        "username": "VedanshNigam",
                        "content": "You need to declare the vector outside the function.\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "nice hills -> extra hard / extra easy"
                    },
                    {
                        "username": "anuAi",
                        "content": "someone pls suggest an approach to solve this problem"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "you can use the following three approaches:\\n1. Using recursion.\\n2. Using iteration with the help of stack.\\n3. Using the Morris approach , which is similar to approach 2 but without using stack."
                    },
                    {
                        "username": "powerpro1",
                        "content": "Root- >Root.left->Root.right"
                    },
                    {
                        "username": "S_Basu",
                        "content": "***Wow!! Surprised** to see Preorder traversal of binary tree after yesterday's question - Max Points on a Line.*\nI thought another BrainF***-ing Question will come today... "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "looks like yesterday\\'s setter got fired"
                    }
                ]
            },
            {
                "id": 1749292,
                "content": [
                    {
                        "username": "user4216mR",
                        "content": "Remember :\\nPreorder Traversal : Root | Left | Right.... "
                    },
                    {
                        "username": "hahahamid",
                        "content": "Do I really need to know Morris Traversal?   "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "it\\'s fav question in interview for the BST topic , or in O(1) space complexity to traversing in tree"
                    },
                    {
                        "username": "Praveen135",
                        "content": "c++ easy pesy..\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nvector<int>res;\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        \\n        if(!root)return res;\\n        res.push_back(root->val);\\n        if(root->left){\\n            preorderTraversal(root->left);\\n        }\\n        if(root->right){\\n            preorderTraversal(root->right);\\n        }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "Kishan_Kumar_Pandey_2002",
                        "content": "it\\'s Easy problem .\\nPreOrder Trversal : Root | Left | Right ."
                    },
                    {
                        "username": "shaon_here",
                        "content": "\n    vector<int> preorderTraversal(TreeNode* root) {\n\n        vector<int> res;\n        if(!root)\n            return res;\n        res.push_back(root->val);\n        if(root->left)\n            preorderTraversal(root->left);\n        if(root->right)\n            preorderTraversal(root->right);\n        return res;\n\n    }             \n\n\nCan anyone say why this code returns [1] in case of [1,null,2,3] ?"
                    },
                    {
                        "username": "VedanshNigam",
                        "content": "You need to declare the vector outside the function.\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "nice hills -> extra hard / extra easy"
                    },
                    {
                        "username": "anuAi",
                        "content": "someone pls suggest an approach to solve this problem"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "you can use the following three approaches:\\n1. Using recursion.\\n2. Using iteration with the help of stack.\\n3. Using the Morris approach , which is similar to approach 2 but without using stack."
                    },
                    {
                        "username": "powerpro1",
                        "content": "Root- >Root.left->Root.right"
                    },
                    {
                        "username": "S_Basu",
                        "content": "***Wow!! Surprised** to see Preorder traversal of binary tree after yesterday's question - Max Points on a Line.*\nI thought another BrainF***-ing Question will come today... "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "looks like yesterday\\'s setter got fired"
                    }
                ]
            },
            {
                "id": 1749286,
                "content": [
                    {
                        "username": "user4216mR",
                        "content": "Remember :\\nPreorder Traversal : Root | Left | Right.... "
                    },
                    {
                        "username": "hahahamid",
                        "content": "Do I really need to know Morris Traversal?   "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "it\\'s fav question in interview for the BST topic , or in O(1) space complexity to traversing in tree"
                    },
                    {
                        "username": "Praveen135",
                        "content": "c++ easy pesy..\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nvector<int>res;\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        \\n        if(!root)return res;\\n        res.push_back(root->val);\\n        if(root->left){\\n            preorderTraversal(root->left);\\n        }\\n        if(root->right){\\n            preorderTraversal(root->right);\\n        }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "Kishan_Kumar_Pandey_2002",
                        "content": "it\\'s Easy problem .\\nPreOrder Trversal : Root | Left | Right ."
                    },
                    {
                        "username": "shaon_here",
                        "content": "\n    vector<int> preorderTraversal(TreeNode* root) {\n\n        vector<int> res;\n        if(!root)\n            return res;\n        res.push_back(root->val);\n        if(root->left)\n            preorderTraversal(root->left);\n        if(root->right)\n            preorderTraversal(root->right);\n        return res;\n\n    }             \n\n\nCan anyone say why this code returns [1] in case of [1,null,2,3] ?"
                    },
                    {
                        "username": "VedanshNigam",
                        "content": "You need to declare the vector outside the function.\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "nice hills -> extra hard / extra easy"
                    },
                    {
                        "username": "anuAi",
                        "content": "someone pls suggest an approach to solve this problem"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "you can use the following three approaches:\\n1. Using recursion.\\n2. Using iteration with the help of stack.\\n3. Using the Morris approach , which is similar to approach 2 but without using stack."
                    },
                    {
                        "username": "powerpro1",
                        "content": "Root- >Root.left->Root.right"
                    },
                    {
                        "username": "S_Basu",
                        "content": "***Wow!! Surprised** to see Preorder traversal of binary tree after yesterday's question - Max Points on a Line.*\nI thought another BrainF***-ing Question will come today... "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "looks like yesterday\\'s setter got fired"
                    }
                ]
            },
            {
                "id": 1749237,
                "content": [
                    {
                        "username": "user4216mR",
                        "content": "Remember :\\nPreorder Traversal : Root | Left | Right.... "
                    },
                    {
                        "username": "hahahamid",
                        "content": "Do I really need to know Morris Traversal?   "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "it\\'s fav question in interview for the BST topic , or in O(1) space complexity to traversing in tree"
                    },
                    {
                        "username": "Praveen135",
                        "content": "c++ easy pesy..\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nvector<int>res;\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        \\n        if(!root)return res;\\n        res.push_back(root->val);\\n        if(root->left){\\n            preorderTraversal(root->left);\\n        }\\n        if(root->right){\\n            preorderTraversal(root->right);\\n        }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "Kishan_Kumar_Pandey_2002",
                        "content": "it\\'s Easy problem .\\nPreOrder Trversal : Root | Left | Right ."
                    },
                    {
                        "username": "shaon_here",
                        "content": "\n    vector<int> preorderTraversal(TreeNode* root) {\n\n        vector<int> res;\n        if(!root)\n            return res;\n        res.push_back(root->val);\n        if(root->left)\n            preorderTraversal(root->left);\n        if(root->right)\n            preorderTraversal(root->right);\n        return res;\n\n    }             \n\n\nCan anyone say why this code returns [1] in case of [1,null,2,3] ?"
                    },
                    {
                        "username": "VedanshNigam",
                        "content": "You need to declare the vector outside the function.\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "nice hills -> extra hard / extra easy"
                    },
                    {
                        "username": "anuAi",
                        "content": "someone pls suggest an approach to solve this problem"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "you can use the following three approaches:\\n1. Using recursion.\\n2. Using iteration with the help of stack.\\n3. Using the Morris approach , which is similar to approach 2 but without using stack."
                    },
                    {
                        "username": "powerpro1",
                        "content": "Root- >Root.left->Root.right"
                    },
                    {
                        "username": "S_Basu",
                        "content": "***Wow!! Surprised** to see Preorder traversal of binary tree after yesterday's question - Max Points on a Line.*\nI thought another BrainF***-ing Question will come today... "
                    },
                    {
                        "username": "crazysamurai",
                        "content": "looks like yesterday\\'s setter got fired"
                    }
                ]
            },
            {
                "id": 1749221,
                "content": [
                    {
                        "username": "kd_5304",
                        "content": "\"Max points on a line\" was there just to break my streak T_T"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime and space || Easy to understand\\nhttps://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3022745/simple-java-0-ms-beats-100-runtime-and-space-easy-to-understand/"
                    },
                    {
                        "username": "verma15ayush",
                        "content": "Easy question for Daily Challenge is an opportunity to revisit the hard ones encountered lately."
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "preorder : dlr ( data left right )\\ninorder  : ldr (left data right )"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "I wonder life to be easy as this problem..."
                    },
                    {
                        "username": "amanchandna",
                        "content": "preorder = Root,Left,Right\\nFirst process `root` node, than `root.left` than `root.right`"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "3 ways to solve this problem\\n\\nApproach\\n**1.Recursive approach-----------**\\n\\nCheck if the current node is empty or Null.\\nDisplay the data part of the root (or current node)\\nTraverse the left subtree by recursively calling the preorder function.\\nTraverse the right subtree by recursively calling the preorder function.\\n**2.Iterative approach----------**\\n\\nCreate an empty stack and push the root node to it.\\nDo the following while the stack is not empty\\nPop the top item from the stack and display it.\\nPush the right child of the popped item to the stack.\\nPush the left child of the popped item to the stack.\\n**Complexity**\\nTime complexity:O(N)\\nSpace complexity:O(H)H=height of binary tree\\n**3.Morris traversal-------**\\n\\nInitialize current as root\\nWhile current is not null:\\nIf current does not have a left child:\\n(i) Print current\\'s data.\\n(ii) Go to the right, i.e., current = current.right\\nElse:\\n(i)Make current as the right child of the rightmost node in current\\'s left subtree.\\n(ii)Go to this left child, i.e., current = current.left.\\n**Complexity**\\nTime complexity:O(N)\\n\\nSpace complexity:O(1)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "This problem is easy if your knowledge of working of trees is clear.\\n\\nIn this we will create a vector of datatype integer in Class Solution of public access (outside the function) so that we don\\'t have to create another function unnecessarily and the vector can be accessed by the function.\\n\\nInside the function, create an if loop stating a condition: if root!=NULL\\nHere, if root becomes NULL, the root will not be checked further.\\n\\nFor every root!=NULL checked condition, we will push root value in the vector and call the function for left elements to the root node and then call the function for right elements to the root node.\\n\\nThis way, the tree is checked from both the sides.\\n\\nReturn the resultant vector.\\n\\nLink to the solution for better understanding:[ https://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3021999/simple-and-easy-c-code/]( https://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3021999/simple-and-easy-c-code/)\\n\\nHope it helps ^_^"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "MY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n\\nvoid helper(TreeNode* root, vector<int> &v)\\n{\\n    if(root==NULL)\\n     return;\\n     v.push_back(root->val);\\n     helper(root->left,v);\\n     helper(root->right,v);\\n}\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        helper(root,v);\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/binary-tree-pre-order-traversal/"
                    }
                ]
            },
            {
                "id": 1749219,
                "content": [
                    {
                        "username": "kd_5304",
                        "content": "\"Max points on a line\" was there just to break my streak T_T"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime and space || Easy to understand\\nhttps://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3022745/simple-java-0-ms-beats-100-runtime-and-space-easy-to-understand/"
                    },
                    {
                        "username": "verma15ayush",
                        "content": "Easy question for Daily Challenge is an opportunity to revisit the hard ones encountered lately."
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "preorder : dlr ( data left right )\\ninorder  : ldr (left data right )"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "I wonder life to be easy as this problem..."
                    },
                    {
                        "username": "amanchandna",
                        "content": "preorder = Root,Left,Right\\nFirst process `root` node, than `root.left` than `root.right`"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "3 ways to solve this problem\\n\\nApproach\\n**1.Recursive approach-----------**\\n\\nCheck if the current node is empty or Null.\\nDisplay the data part of the root (or current node)\\nTraverse the left subtree by recursively calling the preorder function.\\nTraverse the right subtree by recursively calling the preorder function.\\n**2.Iterative approach----------**\\n\\nCreate an empty stack and push the root node to it.\\nDo the following while the stack is not empty\\nPop the top item from the stack and display it.\\nPush the right child of the popped item to the stack.\\nPush the left child of the popped item to the stack.\\n**Complexity**\\nTime complexity:O(N)\\nSpace complexity:O(H)H=height of binary tree\\n**3.Morris traversal-------**\\n\\nInitialize current as root\\nWhile current is not null:\\nIf current does not have a left child:\\n(i) Print current\\'s data.\\n(ii) Go to the right, i.e., current = current.right\\nElse:\\n(i)Make current as the right child of the rightmost node in current\\'s left subtree.\\n(ii)Go to this left child, i.e., current = current.left.\\n**Complexity**\\nTime complexity:O(N)\\n\\nSpace complexity:O(1)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "This problem is easy if your knowledge of working of trees is clear.\\n\\nIn this we will create a vector of datatype integer in Class Solution of public access (outside the function) so that we don\\'t have to create another function unnecessarily and the vector can be accessed by the function.\\n\\nInside the function, create an if loop stating a condition: if root!=NULL\\nHere, if root becomes NULL, the root will not be checked further.\\n\\nFor every root!=NULL checked condition, we will push root value in the vector and call the function for left elements to the root node and then call the function for right elements to the root node.\\n\\nThis way, the tree is checked from both the sides.\\n\\nReturn the resultant vector.\\n\\nLink to the solution for better understanding:[ https://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3021999/simple-and-easy-c-code/]( https://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3021999/simple-and-easy-c-code/)\\n\\nHope it helps ^_^"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "MY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n\\nvoid helper(TreeNode* root, vector<int> &v)\\n{\\n    if(root==NULL)\\n     return;\\n     v.push_back(root->val);\\n     helper(root->left,v);\\n     helper(root->right,v);\\n}\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        helper(root,v);\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/binary-tree-pre-order-traversal/"
                    }
                ]
            },
            {
                "id": 1749135,
                "content": [
                    {
                        "username": "kd_5304",
                        "content": "\"Max points on a line\" was there just to break my streak T_T"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime and space || Easy to understand\\nhttps://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3022745/simple-java-0-ms-beats-100-runtime-and-space-easy-to-understand/"
                    },
                    {
                        "username": "verma15ayush",
                        "content": "Easy question for Daily Challenge is an opportunity to revisit the hard ones encountered lately."
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "preorder : dlr ( data left right )\\ninorder  : ldr (left data right )"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "I wonder life to be easy as this problem..."
                    },
                    {
                        "username": "amanchandna",
                        "content": "preorder = Root,Left,Right\\nFirst process `root` node, than `root.left` than `root.right`"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "3 ways to solve this problem\\n\\nApproach\\n**1.Recursive approach-----------**\\n\\nCheck if the current node is empty or Null.\\nDisplay the data part of the root (or current node)\\nTraverse the left subtree by recursively calling the preorder function.\\nTraverse the right subtree by recursively calling the preorder function.\\n**2.Iterative approach----------**\\n\\nCreate an empty stack and push the root node to it.\\nDo the following while the stack is not empty\\nPop the top item from the stack and display it.\\nPush the right child of the popped item to the stack.\\nPush the left child of the popped item to the stack.\\n**Complexity**\\nTime complexity:O(N)\\nSpace complexity:O(H)H=height of binary tree\\n**3.Morris traversal-------**\\n\\nInitialize current as root\\nWhile current is not null:\\nIf current does not have a left child:\\n(i) Print current\\'s data.\\n(ii) Go to the right, i.e., current = current.right\\nElse:\\n(i)Make current as the right child of the rightmost node in current\\'s left subtree.\\n(ii)Go to this left child, i.e., current = current.left.\\n**Complexity**\\nTime complexity:O(N)\\n\\nSpace complexity:O(1)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "This problem is easy if your knowledge of working of trees is clear.\\n\\nIn this we will create a vector of datatype integer in Class Solution of public access (outside the function) so that we don\\'t have to create another function unnecessarily and the vector can be accessed by the function.\\n\\nInside the function, create an if loop stating a condition: if root!=NULL\\nHere, if root becomes NULL, the root will not be checked further.\\n\\nFor every root!=NULL checked condition, we will push root value in the vector and call the function for left elements to the root node and then call the function for right elements to the root node.\\n\\nThis way, the tree is checked from both the sides.\\n\\nReturn the resultant vector.\\n\\nLink to the solution for better understanding:[ https://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3021999/simple-and-easy-c-code/]( https://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3021999/simple-and-easy-c-code/)\\n\\nHope it helps ^_^"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "MY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n\\nvoid helper(TreeNode* root, vector<int> &v)\\n{\\n    if(root==NULL)\\n     return;\\n     v.push_back(root->val);\\n     helper(root->left,v);\\n     helper(root->right,v);\\n}\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        helper(root,v);\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/binary-tree-pre-order-traversal/"
                    }
                ]
            },
            {
                "id": 1749091,
                "content": [
                    {
                        "username": "kd_5304",
                        "content": "\"Max points on a line\" was there just to break my streak T_T"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime and space || Easy to understand\\nhttps://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3022745/simple-java-0-ms-beats-100-runtime-and-space-easy-to-understand/"
                    },
                    {
                        "username": "verma15ayush",
                        "content": "Easy question for Daily Challenge is an opportunity to revisit the hard ones encountered lately."
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "preorder : dlr ( data left right )\\ninorder  : ldr (left data right )"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "I wonder life to be easy as this problem..."
                    },
                    {
                        "username": "amanchandna",
                        "content": "preorder = Root,Left,Right\\nFirst process `root` node, than `root.left` than `root.right`"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "3 ways to solve this problem\\n\\nApproach\\n**1.Recursive approach-----------**\\n\\nCheck if the current node is empty or Null.\\nDisplay the data part of the root (or current node)\\nTraverse the left subtree by recursively calling the preorder function.\\nTraverse the right subtree by recursively calling the preorder function.\\n**2.Iterative approach----------**\\n\\nCreate an empty stack and push the root node to it.\\nDo the following while the stack is not empty\\nPop the top item from the stack and display it.\\nPush the right child of the popped item to the stack.\\nPush the left child of the popped item to the stack.\\n**Complexity**\\nTime complexity:O(N)\\nSpace complexity:O(H)H=height of binary tree\\n**3.Morris traversal-------**\\n\\nInitialize current as root\\nWhile current is not null:\\nIf current does not have a left child:\\n(i) Print current\\'s data.\\n(ii) Go to the right, i.e., current = current.right\\nElse:\\n(i)Make current as the right child of the rightmost node in current\\'s left subtree.\\n(ii)Go to this left child, i.e., current = current.left.\\n**Complexity**\\nTime complexity:O(N)\\n\\nSpace complexity:O(1)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "This problem is easy if your knowledge of working of trees is clear.\\n\\nIn this we will create a vector of datatype integer in Class Solution of public access (outside the function) so that we don\\'t have to create another function unnecessarily and the vector can be accessed by the function.\\n\\nInside the function, create an if loop stating a condition: if root!=NULL\\nHere, if root becomes NULL, the root will not be checked further.\\n\\nFor every root!=NULL checked condition, we will push root value in the vector and call the function for left elements to the root node and then call the function for right elements to the root node.\\n\\nThis way, the tree is checked from both the sides.\\n\\nReturn the resultant vector.\\n\\nLink to the solution for better understanding:[ https://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3021999/simple-and-easy-c-code/]( https://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3021999/simple-and-easy-c-code/)\\n\\nHope it helps ^_^"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "MY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n\\nvoid helper(TreeNode* root, vector<int> &v)\\n{\\n    if(root==NULL)\\n     return;\\n     v.push_back(root->val);\\n     helper(root->left,v);\\n     helper(root->right,v);\\n}\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        helper(root,v);\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/binary-tree-pre-order-traversal/"
                    }
                ]
            },
            {
                "id": 1749090,
                "content": [
                    {
                        "username": "kd_5304",
                        "content": "\"Max points on a line\" was there just to break my streak T_T"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime and space || Easy to understand\\nhttps://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3022745/simple-java-0-ms-beats-100-runtime-and-space-easy-to-understand/"
                    },
                    {
                        "username": "verma15ayush",
                        "content": "Easy question for Daily Challenge is an opportunity to revisit the hard ones encountered lately."
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "preorder : dlr ( data left right )\\ninorder  : ldr (left data right )"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "I wonder life to be easy as this problem..."
                    },
                    {
                        "username": "amanchandna",
                        "content": "preorder = Root,Left,Right\\nFirst process `root` node, than `root.left` than `root.right`"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "3 ways to solve this problem\\n\\nApproach\\n**1.Recursive approach-----------**\\n\\nCheck if the current node is empty or Null.\\nDisplay the data part of the root (or current node)\\nTraverse the left subtree by recursively calling the preorder function.\\nTraverse the right subtree by recursively calling the preorder function.\\n**2.Iterative approach----------**\\n\\nCreate an empty stack and push the root node to it.\\nDo the following while the stack is not empty\\nPop the top item from the stack and display it.\\nPush the right child of the popped item to the stack.\\nPush the left child of the popped item to the stack.\\n**Complexity**\\nTime complexity:O(N)\\nSpace complexity:O(H)H=height of binary tree\\n**3.Morris traversal-------**\\n\\nInitialize current as root\\nWhile current is not null:\\nIf current does not have a left child:\\n(i) Print current\\'s data.\\n(ii) Go to the right, i.e., current = current.right\\nElse:\\n(i)Make current as the right child of the rightmost node in current\\'s left subtree.\\n(ii)Go to this left child, i.e., current = current.left.\\n**Complexity**\\nTime complexity:O(N)\\n\\nSpace complexity:O(1)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "This problem is easy if your knowledge of working of trees is clear.\\n\\nIn this we will create a vector of datatype integer in Class Solution of public access (outside the function) so that we don\\'t have to create another function unnecessarily and the vector can be accessed by the function.\\n\\nInside the function, create an if loop stating a condition: if root!=NULL\\nHere, if root becomes NULL, the root will not be checked further.\\n\\nFor every root!=NULL checked condition, we will push root value in the vector and call the function for left elements to the root node and then call the function for right elements to the root node.\\n\\nThis way, the tree is checked from both the sides.\\n\\nReturn the resultant vector.\\n\\nLink to the solution for better understanding:[ https://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3021999/simple-and-easy-c-code/]( https://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3021999/simple-and-easy-c-code/)\\n\\nHope it helps ^_^"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "MY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n\\nvoid helper(TreeNode* root, vector<int> &v)\\n{\\n    if(root==NULL)\\n     return;\\n     v.push_back(root->val);\\n     helper(root->left,v);\\n     helper(root->right,v);\\n}\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        helper(root,v);\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/binary-tree-pre-order-traversal/"
                    }
                ]
            },
            {
                "id": 1749088,
                "content": [
                    {
                        "username": "kd_5304",
                        "content": "\"Max points on a line\" was there just to break my streak T_T"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime and space || Easy to understand\\nhttps://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3022745/simple-java-0-ms-beats-100-runtime-and-space-easy-to-understand/"
                    },
                    {
                        "username": "verma15ayush",
                        "content": "Easy question for Daily Challenge is an opportunity to revisit the hard ones encountered lately."
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "preorder : dlr ( data left right )\\ninorder  : ldr (left data right )"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "I wonder life to be easy as this problem..."
                    },
                    {
                        "username": "amanchandna",
                        "content": "preorder = Root,Left,Right\\nFirst process `root` node, than `root.left` than `root.right`"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "3 ways to solve this problem\\n\\nApproach\\n**1.Recursive approach-----------**\\n\\nCheck if the current node is empty or Null.\\nDisplay the data part of the root (or current node)\\nTraverse the left subtree by recursively calling the preorder function.\\nTraverse the right subtree by recursively calling the preorder function.\\n**2.Iterative approach----------**\\n\\nCreate an empty stack and push the root node to it.\\nDo the following while the stack is not empty\\nPop the top item from the stack and display it.\\nPush the right child of the popped item to the stack.\\nPush the left child of the popped item to the stack.\\n**Complexity**\\nTime complexity:O(N)\\nSpace complexity:O(H)H=height of binary tree\\n**3.Morris traversal-------**\\n\\nInitialize current as root\\nWhile current is not null:\\nIf current does not have a left child:\\n(i) Print current\\'s data.\\n(ii) Go to the right, i.e., current = current.right\\nElse:\\n(i)Make current as the right child of the rightmost node in current\\'s left subtree.\\n(ii)Go to this left child, i.e., current = current.left.\\n**Complexity**\\nTime complexity:O(N)\\n\\nSpace complexity:O(1)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "This problem is easy if your knowledge of working of trees is clear.\\n\\nIn this we will create a vector of datatype integer in Class Solution of public access (outside the function) so that we don\\'t have to create another function unnecessarily and the vector can be accessed by the function.\\n\\nInside the function, create an if loop stating a condition: if root!=NULL\\nHere, if root becomes NULL, the root will not be checked further.\\n\\nFor every root!=NULL checked condition, we will push root value in the vector and call the function for left elements to the root node and then call the function for right elements to the root node.\\n\\nThis way, the tree is checked from both the sides.\\n\\nReturn the resultant vector.\\n\\nLink to the solution for better understanding:[ https://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3021999/simple-and-easy-c-code/]( https://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3021999/simple-and-easy-c-code/)\\n\\nHope it helps ^_^"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "MY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n\\nvoid helper(TreeNode* root, vector<int> &v)\\n{\\n    if(root==NULL)\\n     return;\\n     v.push_back(root->val);\\n     helper(root->left,v);\\n     helper(root->right,v);\\n}\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        helper(root,v);\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/binary-tree-pre-order-traversal/"
                    }
                ]
            },
            {
                "id": 1749059,
                "content": [
                    {
                        "username": "kd_5304",
                        "content": "\"Max points on a line\" was there just to break my streak T_T"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime and space || Easy to understand\\nhttps://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3022745/simple-java-0-ms-beats-100-runtime-and-space-easy-to-understand/"
                    },
                    {
                        "username": "verma15ayush",
                        "content": "Easy question for Daily Challenge is an opportunity to revisit the hard ones encountered lately."
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "preorder : dlr ( data left right )\\ninorder  : ldr (left data right )"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "I wonder life to be easy as this problem..."
                    },
                    {
                        "username": "amanchandna",
                        "content": "preorder = Root,Left,Right\\nFirst process `root` node, than `root.left` than `root.right`"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "3 ways to solve this problem\\n\\nApproach\\n**1.Recursive approach-----------**\\n\\nCheck if the current node is empty or Null.\\nDisplay the data part of the root (or current node)\\nTraverse the left subtree by recursively calling the preorder function.\\nTraverse the right subtree by recursively calling the preorder function.\\n**2.Iterative approach----------**\\n\\nCreate an empty stack and push the root node to it.\\nDo the following while the stack is not empty\\nPop the top item from the stack and display it.\\nPush the right child of the popped item to the stack.\\nPush the left child of the popped item to the stack.\\n**Complexity**\\nTime complexity:O(N)\\nSpace complexity:O(H)H=height of binary tree\\n**3.Morris traversal-------**\\n\\nInitialize current as root\\nWhile current is not null:\\nIf current does not have a left child:\\n(i) Print current\\'s data.\\n(ii) Go to the right, i.e., current = current.right\\nElse:\\n(i)Make current as the right child of the rightmost node in current\\'s left subtree.\\n(ii)Go to this left child, i.e., current = current.left.\\n**Complexity**\\nTime complexity:O(N)\\n\\nSpace complexity:O(1)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "This problem is easy if your knowledge of working of trees is clear.\\n\\nIn this we will create a vector of datatype integer in Class Solution of public access (outside the function) so that we don\\'t have to create another function unnecessarily and the vector can be accessed by the function.\\n\\nInside the function, create an if loop stating a condition: if root!=NULL\\nHere, if root becomes NULL, the root will not be checked further.\\n\\nFor every root!=NULL checked condition, we will push root value in the vector and call the function for left elements to the root node and then call the function for right elements to the root node.\\n\\nThis way, the tree is checked from both the sides.\\n\\nReturn the resultant vector.\\n\\nLink to the solution for better understanding:[ https://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3021999/simple-and-easy-c-code/]( https://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3021999/simple-and-easy-c-code/)\\n\\nHope it helps ^_^"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "MY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n\\nvoid helper(TreeNode* root, vector<int> &v)\\n{\\n    if(root==NULL)\\n     return;\\n     v.push_back(root->val);\\n     helper(root->left,v);\\n     helper(root->right,v);\\n}\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        helper(root,v);\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/binary-tree-pre-order-traversal/"
                    }
                ]
            },
            {
                "id": 1748960,
                "content": [
                    {
                        "username": "kd_5304",
                        "content": "\"Max points on a line\" was there just to break my streak T_T"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime and space || Easy to understand\\nhttps://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3022745/simple-java-0-ms-beats-100-runtime-and-space-easy-to-understand/"
                    },
                    {
                        "username": "verma15ayush",
                        "content": "Easy question for Daily Challenge is an opportunity to revisit the hard ones encountered lately."
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "preorder : dlr ( data left right )\\ninorder  : ldr (left data right )"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "I wonder life to be easy as this problem..."
                    },
                    {
                        "username": "amanchandna",
                        "content": "preorder = Root,Left,Right\\nFirst process `root` node, than `root.left` than `root.right`"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "3 ways to solve this problem\\n\\nApproach\\n**1.Recursive approach-----------**\\n\\nCheck if the current node is empty or Null.\\nDisplay the data part of the root (or current node)\\nTraverse the left subtree by recursively calling the preorder function.\\nTraverse the right subtree by recursively calling the preorder function.\\n**2.Iterative approach----------**\\n\\nCreate an empty stack and push the root node to it.\\nDo the following while the stack is not empty\\nPop the top item from the stack and display it.\\nPush the right child of the popped item to the stack.\\nPush the left child of the popped item to the stack.\\n**Complexity**\\nTime complexity:O(N)\\nSpace complexity:O(H)H=height of binary tree\\n**3.Morris traversal-------**\\n\\nInitialize current as root\\nWhile current is not null:\\nIf current does not have a left child:\\n(i) Print current\\'s data.\\n(ii) Go to the right, i.e., current = current.right\\nElse:\\n(i)Make current as the right child of the rightmost node in current\\'s left subtree.\\n(ii)Go to this left child, i.e., current = current.left.\\n**Complexity**\\nTime complexity:O(N)\\n\\nSpace complexity:O(1)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "This problem is easy if your knowledge of working of trees is clear.\\n\\nIn this we will create a vector of datatype integer in Class Solution of public access (outside the function) so that we don\\'t have to create another function unnecessarily and the vector can be accessed by the function.\\n\\nInside the function, create an if loop stating a condition: if root!=NULL\\nHere, if root becomes NULL, the root will not be checked further.\\n\\nFor every root!=NULL checked condition, we will push root value in the vector and call the function for left elements to the root node and then call the function for right elements to the root node.\\n\\nThis way, the tree is checked from both the sides.\\n\\nReturn the resultant vector.\\n\\nLink to the solution for better understanding:[ https://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3021999/simple-and-easy-c-code/]( https://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3021999/simple-and-easy-c-code/)\\n\\nHope it helps ^_^"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "MY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n\\nvoid helper(TreeNode* root, vector<int> &v)\\n{\\n    if(root==NULL)\\n     return;\\n     v.push_back(root->val);\\n     helper(root->left,v);\\n     helper(root->right,v);\\n}\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        helper(root,v);\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/binary-tree-pre-order-traversal/"
                    }
                ]
            },
            {
                "id": 1736949,
                "content": [
                    {
                        "username": "kd_5304",
                        "content": "\"Max points on a line\" was there just to break my streak T_T"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime and space || Easy to understand\\nhttps://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3022745/simple-java-0-ms-beats-100-runtime-and-space-easy-to-understand/"
                    },
                    {
                        "username": "verma15ayush",
                        "content": "Easy question for Daily Challenge is an opportunity to revisit the hard ones encountered lately."
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "preorder : dlr ( data left right )\\ninorder  : ldr (left data right )"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "I wonder life to be easy as this problem..."
                    },
                    {
                        "username": "amanchandna",
                        "content": "preorder = Root,Left,Right\\nFirst process `root` node, than `root.left` than `root.right`"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "3 ways to solve this problem\\n\\nApproach\\n**1.Recursive approach-----------**\\n\\nCheck if the current node is empty or Null.\\nDisplay the data part of the root (or current node)\\nTraverse the left subtree by recursively calling the preorder function.\\nTraverse the right subtree by recursively calling the preorder function.\\n**2.Iterative approach----------**\\n\\nCreate an empty stack and push the root node to it.\\nDo the following while the stack is not empty\\nPop the top item from the stack and display it.\\nPush the right child of the popped item to the stack.\\nPush the left child of the popped item to the stack.\\n**Complexity**\\nTime complexity:O(N)\\nSpace complexity:O(H)H=height of binary tree\\n**3.Morris traversal-------**\\n\\nInitialize current as root\\nWhile current is not null:\\nIf current does not have a left child:\\n(i) Print current\\'s data.\\n(ii) Go to the right, i.e., current = current.right\\nElse:\\n(i)Make current as the right child of the rightmost node in current\\'s left subtree.\\n(ii)Go to this left child, i.e., current = current.left.\\n**Complexity**\\nTime complexity:O(N)\\n\\nSpace complexity:O(1)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "This problem is easy if your knowledge of working of trees is clear.\\n\\nIn this we will create a vector of datatype integer in Class Solution of public access (outside the function) so that we don\\'t have to create another function unnecessarily and the vector can be accessed by the function.\\n\\nInside the function, create an if loop stating a condition: if root!=NULL\\nHere, if root becomes NULL, the root will not be checked further.\\n\\nFor every root!=NULL checked condition, we will push root value in the vector and call the function for left elements to the root node and then call the function for right elements to the root node.\\n\\nThis way, the tree is checked from both the sides.\\n\\nReturn the resultant vector.\\n\\nLink to the solution for better understanding:[ https://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3021999/simple-and-easy-c-code/]( https://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3021999/simple-and-easy-c-code/)\\n\\nHope it helps ^_^"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "MY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n\\nvoid helper(TreeNode* root, vector<int> &v)\\n{\\n    if(root==NULL)\\n     return;\\n     v.push_back(root->val);\\n     helper(root->left,v);\\n     helper(root->right,v);\\n}\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        helper(root,v);\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/binary-tree-pre-order-traversal/"
                    }
                ]
            },
            {
                "id": 1735526,
                "content": [
                    {
                        "username": "kd_5304",
                        "content": "\"Max points on a line\" was there just to break my streak T_T"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime and space || Easy to understand\\nhttps://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3022745/simple-java-0-ms-beats-100-runtime-and-space-easy-to-understand/"
                    },
                    {
                        "username": "verma15ayush",
                        "content": "Easy question for Daily Challenge is an opportunity to revisit the hard ones encountered lately."
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "preorder : dlr ( data left right )\\ninorder  : ldr (left data right )"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "I wonder life to be easy as this problem..."
                    },
                    {
                        "username": "amanchandna",
                        "content": "preorder = Root,Left,Right\\nFirst process `root` node, than `root.left` than `root.right`"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "3 ways to solve this problem\\n\\nApproach\\n**1.Recursive approach-----------**\\n\\nCheck if the current node is empty or Null.\\nDisplay the data part of the root (or current node)\\nTraverse the left subtree by recursively calling the preorder function.\\nTraverse the right subtree by recursively calling the preorder function.\\n**2.Iterative approach----------**\\n\\nCreate an empty stack and push the root node to it.\\nDo the following while the stack is not empty\\nPop the top item from the stack and display it.\\nPush the right child of the popped item to the stack.\\nPush the left child of the popped item to the stack.\\n**Complexity**\\nTime complexity:O(N)\\nSpace complexity:O(H)H=height of binary tree\\n**3.Morris traversal-------**\\n\\nInitialize current as root\\nWhile current is not null:\\nIf current does not have a left child:\\n(i) Print current\\'s data.\\n(ii) Go to the right, i.e., current = current.right\\nElse:\\n(i)Make current as the right child of the rightmost node in current\\'s left subtree.\\n(ii)Go to this left child, i.e., current = current.left.\\n**Complexity**\\nTime complexity:O(N)\\n\\nSpace complexity:O(1)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "This problem is easy if your knowledge of working of trees is clear.\\n\\nIn this we will create a vector of datatype integer in Class Solution of public access (outside the function) so that we don\\'t have to create another function unnecessarily and the vector can be accessed by the function.\\n\\nInside the function, create an if loop stating a condition: if root!=NULL\\nHere, if root becomes NULL, the root will not be checked further.\\n\\nFor every root!=NULL checked condition, we will push root value in the vector and call the function for left elements to the root node and then call the function for right elements to the root node.\\n\\nThis way, the tree is checked from both the sides.\\n\\nReturn the resultant vector.\\n\\nLink to the solution for better understanding:[ https://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3021999/simple-and-easy-c-code/]( https://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3021999/simple-and-easy-c-code/)\\n\\nHope it helps ^_^"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "MY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n\\nvoid helper(TreeNode* root, vector<int> &v)\\n{\\n    if(root==NULL)\\n     return;\\n     v.push_back(root->val);\\n     helper(root->left,v);\\n     helper(root->right,v);\\n}\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        helper(root,v);\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/binary-tree-pre-order-traversal/"
                    }
                ]
            }
        ]
    },
    {
        "title": "Shortest Word Distance II",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1565247,
                "content": [
                    {
                        "username": "daalp9999",
                        "content": "It would help a ton to understand what does it mean as `distance`\\n\\nAlso felt that it should have explaination with sample input and output"
                    },
                    {
                        "username": "hahadaxiong",
                        "content": "We can use a hash map to store the shortest distances for any pair of words."
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "The format is really weird that I can't catch the idea. Which one is input String[], which is word1, which is word2?\\n\\n[\"WordDistance\",\"shortest\",\"shortest\"]\\n[[[\"practice\",\"makes\",\"perfect\",\"coding\",\"makes\"]],[\"coding\",\"practice\"],[\"makes\",\"coding\"]]"
                    },
                    {
                        "username": "drnothing",
                        "content": "Poorly written question, downvoted."
                    },
                    {
                        "username": "willm3003",
                        "content": "What is \"distance\"?"
                    },
                    {
                        "username": "willm3003",
                        "content": "It is comparing the indices"
                    }
                ]
            },
            {
                "id": 1564914,
                "content": [
                    {
                        "username": "daalp9999",
                        "content": "It would help a ton to understand what does it mean as `distance`\\n\\nAlso felt that it should have explaination with sample input and output"
                    },
                    {
                        "username": "hahadaxiong",
                        "content": "We can use a hash map to store the shortest distances for any pair of words."
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "The format is really weird that I can't catch the idea. Which one is input String[], which is word1, which is word2?\\n\\n[\"WordDistance\",\"shortest\",\"shortest\"]\\n[[[\"practice\",\"makes\",\"perfect\",\"coding\",\"makes\"]],[\"coding\",\"practice\"],[\"makes\",\"coding\"]]"
                    },
                    {
                        "username": "drnothing",
                        "content": "Poorly written question, downvoted."
                    },
                    {
                        "username": "willm3003",
                        "content": "What is \"distance\"?"
                    },
                    {
                        "username": "willm3003",
                        "content": "It is comparing the indices"
                    }
                ]
            },
            {
                "id": 1571487,
                "content": [
                    {
                        "username": "daalp9999",
                        "content": "It would help a ton to understand what does it mean as `distance`\\n\\nAlso felt that it should have explaination with sample input and output"
                    },
                    {
                        "username": "hahadaxiong",
                        "content": "We can use a hash map to store the shortest distances for any pair of words."
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "The format is really weird that I can't catch the idea. Which one is input String[], which is word1, which is word2?\\n\\n[\"WordDistance\",\"shortest\",\"shortest\"]\\n[[[\"practice\",\"makes\",\"perfect\",\"coding\",\"makes\"]],[\"coding\",\"practice\"],[\"makes\",\"coding\"]]"
                    },
                    {
                        "username": "drnothing",
                        "content": "Poorly written question, downvoted."
                    },
                    {
                        "username": "willm3003",
                        "content": "What is \"distance\"?"
                    },
                    {
                        "username": "willm3003",
                        "content": "It is comparing the indices"
                    }
                ]
            },
            {
                "id": 1894890,
                "content": [
                    {
                        "username": "daalp9999",
                        "content": "It would help a ton to understand what does it mean as `distance`\\n\\nAlso felt that it should have explaination with sample input and output"
                    },
                    {
                        "username": "hahadaxiong",
                        "content": "We can use a hash map to store the shortest distances for any pair of words."
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "The format is really weird that I can't catch the idea. Which one is input String[], which is word1, which is word2?\\n\\n[\"WordDistance\",\"shortest\",\"shortest\"]\\n[[[\"practice\",\"makes\",\"perfect\",\"coding\",\"makes\"]],[\"coding\",\"practice\"],[\"makes\",\"coding\"]]"
                    },
                    {
                        "username": "drnothing",
                        "content": "Poorly written question, downvoted."
                    },
                    {
                        "username": "willm3003",
                        "content": "What is \"distance\"?"
                    },
                    {
                        "username": "willm3003",
                        "content": "It is comparing the indices"
                    }
                ]
            },
            {
                "id": 1867751,
                "content": [
                    {
                        "username": "daalp9999",
                        "content": "It would help a ton to understand what does it mean as `distance`\\n\\nAlso felt that it should have explaination with sample input and output"
                    },
                    {
                        "username": "hahadaxiong",
                        "content": "We can use a hash map to store the shortest distances for any pair of words."
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "The format is really weird that I can't catch the idea. Which one is input String[], which is word1, which is word2?\\n\\n[\"WordDistance\",\"shortest\",\"shortest\"]\\n[[[\"practice\",\"makes\",\"perfect\",\"coding\",\"makes\"]],[\"coding\",\"practice\"],[\"makes\",\"coding\"]]"
                    },
                    {
                        "username": "drnothing",
                        "content": "Poorly written question, downvoted."
                    },
                    {
                        "username": "willm3003",
                        "content": "What is \"distance\"?"
                    },
                    {
                        "username": "willm3003",
                        "content": "It is comparing the indices"
                    }
                ]
            }
        ]
    },
    {
        "title": "Reverse String",
        "question_content": "<p>Write a function that reverses a string. The input string is given as an array of characters <code>s</code>.</p>\n\n<p>You must do this by modifying the input array <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\">in-place</a> with <code>O(1)</code> extra memory.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> s = [\"h\",\"e\",\"l\",\"l\",\"o\"]\n<strong>Output:</strong> [\"o\",\"l\",\"l\",\"e\",\"h\"]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\n<strong>Output:</strong> [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code> is a <a href=\"https://en.wikipedia.org/wiki/ASCII#Printable_characters\" target=\"_blank\">printable ascii character</a>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 80937,
                "title": "java-simple-and-clean-with-explanations-6-solutions",
                "content": "https://www.ratchapong.com/algorithm-practice/leetcode/reverse-string [Full solutions]\\n```\\npublic class Solution {\\n    public String reverseString(String s) {\\n        char[] word = s.toCharArray();\\n        int i = 0;\\n        int j = s.length() - 1;\\n        while (i < j) {\\n            char temp = word[i];\\n            word[i] = word[j];\\n            word[j] = temp;\\n            i++;\\n            j--;\\n        }\\n        return new String(word);\\n    }\\n}\\n```\\n<div class=\"margin-bottom-20\">\\n    <h4 class=\"text-uppercase margin-bottom-10\">Complexity Analysis</h4>\\n    <p>\\n        <b>Time Complexity:</b>\\n        `O(n)` (Average Case) and `O(n)` (Worst Case) where `n` is the total number character in the input string.\\n        The algorithm need to reverse the whole string.\\n    </p>\\n    <p>\\n        <b>Auxiliary Space:</b>\\n        `O(n)` space is used where `n` is the total number character in the input string. Space is needed to transform\\n        string to character array.\\n    </p>\\n</div>\\n<div class=\"margin-bottom-20\">\\n    <h4 class=\"text-uppercase margin-bottom-10\">Algorithm</h4>\\n    <p>\\n        <b>Approach:</b>\\n        Iterative Swapping Using Two Pointers\\n    </p>\\n    <p>\\n        One pointer is pointing at the start of the string while the other pointer is pointing at the end of the string.\\n        Both pointers will keep swapping its element and travel towards each other. The algorithm basically simulating\\n        rotation of a string with respect to its midpoint.\\n    </p>\\n</div>\\n\\n```\\npublic class Solution {\\n    public String reverseString(String s) {\\n        byte[] bytes = s.getBytes();\\n        int i = 0;\\n        int j = s.length() - 1;\\n        while (i < j) {\\n            byte temp = bytes[i];\\n            bytes[i] = bytes[j];\\n            bytes[j] = temp;\\n            i++;\\n            j--;\\n        }\\n        return new String(bytes);\\n    }\\n}\\n```\\n<div class=\"margin-bottom-20\">\\n    <h4 class=\"text-uppercase margin-bottom-10\">Complexity Analysis</h4>\\n    <p>\\n        <b>Time Complexity:</b>\\n        `O(n)` (Average Case) and `O(n)` (Worst Case) where `n` is the total number character in the input string.\\n        The algorithm need to reverse the whole string. Each character is `1` byte.\\n    </p>\\n    <p>\\n        <b>Auxiliary Space:</b>\\n        `O(n)` space is used where `n` is the total number character in the input string. Space is needed to transform\\n        string to byte array.\\n    </p>\\n</div>\\n<div class=\"margin-bottom-20\">\\n    <h4 class=\"text-uppercase margin-bottom-10\">Algorithm</h4>\\n    <p>\\n        <b>Approach:</b>\\n        Iterative Swapping Using Two Pointers\\n    </p>\\n    <p>\\n        One pointer is pointing at the start of the byte array while the other pointer is pointing at the end of the\\n        byte array.\\n        Both pointers will keep swapping its element and travel towards each other. The algorithm basically simulating\\n        rotation of a string with respect to its midpoint.\\n    </p>\\n    <p>\\n        Note that this assume that the input string is encoded using\\n        ASCII format. This will not work with Unicode value where one character may be more than 1 byte.\\n    </p>\\n</div>\\n\\n```\\npublic class Solution {\\n    public String reverseString(String s) {\\n        char[] word = s.toCharArray();\\n        int i = 0;\\n        int j = s.length() - 1;\\n        while (i < j) {\\n            word[i] = (char) (word[i] ^ word[j]);\\n            word[j] = (char) (word[i] ^ word[j]);\\n            word[i] = (char) (word[i] ^ word[j]);\\n            i++;\\n            j--;\\n        }\\n        return new String(bytes);\\n    }\\n}\\n```\\n<div class=\"margin-bottom-20\">\\n    <h4 class=\"text-uppercase margin-bottom-10\">Complexity Analysis</h4>\\n    <p>\\n        <b>Time Complexity:</b>\\n        `O(n)` (Average Case) and `O(n)` (Worst Case) where `n` is the total number character in the input string.\\n        The algorithm need to reverse the whole string.\\n    </p>\\n    <p>\\n        <b>Auxiliary Space:</b>\\n        `O(n)` space is used where `n` is the total number character in the input string. Space is needed to transform\\n        string to character array.\\n    </p>\\n</div>\\n<div class=\"margin-bottom-20\">\\n    <h4 class=\"text-uppercase margin-bottom-10\">Algorithm</h4>\\n    <p>\\n        <b>Approach:</b>\\n        Iterative Swapping Using Two Pointers\\n    </p>\\n    <p>\\n        One pointer is pointing at the start of the string while the other pointer is pointing at the end of the string.\\n        Both pointers will keep swapping its element and travel towards each other. The algorithm basically simulating\\n        rotation of a string with respect to its midpoint. The swapping is done by using <code>XOR</code> swapping\\n        algorithm.\\n    </p>\\n    <div align=\"center\" class=\"margin-bottom-10 margin-top-10\">\\n        <table class=\"table table-bordered\" style=\"width: 60%\">\\n            <thead>\\n                <tr>\\n                    <th class=\"text-center\">Operation</th>\\n                    <th class=\"text-center\">Result</th>\\n                </tr>\\n            </thead>\\n            <tbody>\\n                <tr>\\n                    <td align=\"center\">`a = a \\\\oplus b`</td>\\n                    <td align=\"left\">`a = a \\\\oplus b`</td>\\n                </tr>\\n                <tr>\\n                    <td align=\"center\">`b = a \\\\oplus b`</td>\\n                    <td align=\"left\">`b = (a \\\\oplus b) \\\\oplus b = a \\\\oplus b \\\\oplus b = a`</td>\\n                </tr>\\n                <tr>\\n                    <td align=\"center\">`a = a \\\\oplus b`</td>\\n                    <td align=\"left\">`a = (a \\\\oplus b) \\\\oplus a = a \\\\oplus b \\\\oplus a = b`</td>\\n                </tr>\\n            </tbody>\\n        </table>\\n    </div>\\n    <p>\\n        Note that this assume that the input string is encoded using\\n        ASCII format. This will not work with Unicode value where one character may be more than 1 byte.\\n    </p>\\n</div>\\n\\n```\\npublic class Solution {\\n    public String reverseString(String s) {\\n        byte[] bytes = s.getBytes();\\n        int i = 0;\\n        int j = s.length() - 1;\\n        while (i < j) {\\n            bytes[i] = (byte) (bytes[i] ^ bytes[j]);\\n            bytes[j] = (byte) (bytes[i] ^ bytes[j]);\\n            bytes[i] = (byte) (bytes[i] ^ bytes[j]);\\n            i++;\\n            j--;\\n        }\\n        return new String(bytes);\\n    }\\n}\\n```\\n<div class=\"margin-bottom-20\">\\n    <h4 class=\"text-uppercase margin-bottom-10\">Complexity Analysis</h4>\\n    <p>\\n        <b>Time Complexity:</b>\\n        `O(n)` (Average Case) and `O(n)` (Worst Case) where `n` is the total number character in the input string.\\n        The algorithm need to reverse the whole string. Each character is `1` byte.\\n    </p>\\n    <p>\\n        <b>Auxiliary Space:</b>\\n        `O(n)` space is used where `n` is the total number character in the input string. Space is needed to transform\\n        string to byte array.\\n    </p>\\n</div>\\n<div class=\"margin-bottom-20\">\\n    <h4 class=\"text-uppercase margin-bottom-10\">Algorithm</h4>\\n    <p>\\n        <b>Approach:</b>\\n        Iterative Swapping Using Two Pointers\\n    </p>\\n    <p>\\n        One pointer is pointing at the start of the byte array while the other pointer is pointing at the end of the\\n        byte array.\\n        Both pointers will keep swapping its element and travel towards each other. The algorithm basically simulating\\n        rotation of a string with respect to its midpoint. The swapping is done by using <code>XOR</code> swapping\\n        algorithm.\\n    </p>\\n    <div align=\"center\" class=\"margin-bottom-10 margin-top-10\">\\n        <table class=\"table table-bordered\" style=\"width: 60%\">\\n            <thead>\\n                <tr>\\n                    <th class=\"text-center\">Operation</th>\\n                    <th class=\"text-center\">Result</th>\\n                </tr>\\n            </thead>\\n            <tbody>\\n                <tr>\\n                    <td align=\"center\">`a = a \\\\oplus b`</td>\\n                    <td align=\"left\">`a = a \\\\oplus b`</td>\\n                </tr>\\n                <tr>\\n                    <td align=\"center\">`b = a \\\\oplus b`</td>\\n                    <td align=\"left\">`b = (a \\\\oplus b) \\\\oplus b = a \\\\oplus b \\\\oplus b = a`</td>\\n                </tr>\\n                <tr>\\n                    <td align=\"center\">`a = a \\\\oplus b`</td>\\n                    <td align=\"left\">`a = (a \\\\oplus b) \\\\oplus a = a \\\\oplus b \\\\oplus a = b`</td>\\n                </tr>\\n            </tbody>\\n        </table>\\n    </div>\\n    <p>\\n        Note that this assume that the input string is encoded using\\n        ASCII format. This will not work with Unicode value where one character may be more than 1 byte.\\n    </p>\\n</div>\\n\\n```\\npublic class Solution {\\n    public String reverseString(String s) {\\n        return new StringBuilder(s).reverse().toString();\\n    }\\n}\\n```\\n<div class=\"margin-bottom-20\">\\n    <h4 class=\"text-uppercase margin-bottom-10\">Complexity Analysis</h4>\\n    <p>\\n        <b>Time Complexity:</b>\\n        `O(n)` (Average Case) and `O(n)` (Worst Case) where `n` is the total number character in the input string.\\n        Depending on the implementation. However, it is not possible to reverse string in less than `O(n)`.\\n    </p>\\n    <p>\\n        <b>Auxiliary Space:</b>\\n        `O(n)` space is used where `n` is the total number character in the input string. Space is needed to transform\\n        immutable string into character buffer in <code>StringBuilder</code>.\\n    </p>\\n</div>\\n<div class=\"margin-bottom-20\">\\n    <h4 class=\"text-uppercase margin-bottom-10\">Algorithm</h4>\\n    <p>\\n        <b>Approach:</b>\\n        Using Java Library\\n    </p>\\n    <p>\\n        Java's library is probably slower that direct implementation due to extra overhead in check various edge cases\\n        such as surrogate pairs.\\n    </p>\\n</div>\\n\\n```\\npublic class Solution {\\n    public String reverseString(String s) {\\n        int length = s.length();\\n        if (length <= 1) return s;\\n        String leftStr = s.substring(0, length / 2);\\n        String rightStr = s.substring(length / 2, length);\\n        return reverseString(rightStr) + reverseString(leftStr);\\n    }\\n}\\n```\\n<div class=\"margin-bottom-20\">\\n    <h4 class=\"text-uppercase margin-bottom-10\">Complexity Analysis</h4>\\n    <p>\\n        <b>Time Complexity:</b>\\n        `O(n log(n))` (Average Case) and `O(n * log(n))` (Worst Case) where `n` is the total number character in the\\n        input string.\\n        The recurrence equation is `T(n) = 2 * T(n/2) + O(n)`. `O(n)` is due to the fact that concatenation function\\n        takes linear time.\\n        The recurrence equation can be solved to get `O(n * log(n))`.\\n    </p>\\n    <p>\\n        <b>Auxiliary Space:</b>\\n        `O(h)` space is used where `h` is the depth of recursion tree generated which is `log(n)`. Space is needed for\\n        activation stack during recursion calls.\\n    </p>\\n</div>\\n<div class=\"margin-bottom-20\">\\n    <h4 class=\"text-uppercase margin-bottom-10\">Algorithm</h4>\\n    <p>\\n        <b>Approach:</b>\\n        Divide and Conquer (Recursive)\\n    </p>\\n    <p>\\n        The string is split into half. Each substring will be further divided. This process continues until the string\\n        can no longer be divided (length `<= 1`). The conquering process will take they previously split strings and\\n        concatenate them in reverse order.\\n    </p>\\n</div>",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public String reverseString(String s) {\\n        char[] word = s.toCharArray();\\n        int i = 0;\\n        int j = s.length() - 1;\\n        while (i < j) {\\n            char temp = word[i];\\n            word[i] = word[j];\\n            word[j] = temp;\\n            i++;\\n            j--;\\n        }\\n        return new String(word);\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public String reverseString(String s) {\\n        byte[] bytes = s.getBytes();\\n        int i = 0;\\n        int j = s.length() - 1;\\n        while (i < j) {\\n            byte temp = bytes[i];\\n            bytes[i] = bytes[j];\\n            bytes[j] = temp;\\n            i++;\\n            j--;\\n        }\\n        return new String(bytes);\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public String reverseString(String s) {\\n        char[] word = s.toCharArray();\\n        int i = 0;\\n        int j = s.length() - 1;\\n        while (i < j) {\\n            word[i] = (char) (word[i] ^ word[j]);\\n            word[j] = (char) (word[i] ^ word[j]);\\n            word[i] = (char) (word[i] ^ word[j]);\\n            i++;\\n            j--;\\n        }\\n        return new String(bytes);\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public String reverseString(String s) {\\n        byte[] bytes = s.getBytes();\\n        int i = 0;\\n        int j = s.length() - 1;\\n        while (i < j) {\\n            bytes[i] = (byte) (bytes[i] ^ bytes[j]);\\n            bytes[j] = (byte) (bytes[i] ^ bytes[j]);\\n            bytes[i] = (byte) (bytes[i] ^ bytes[j]);\\n            i++;\\n            j--;\\n        }\\n        return new String(bytes);\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public String reverseString(String s) {\\n        return new StringBuilder(s).reverse().toString();\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public String reverseString(String s) {\\n        int length = s.length();\\n        if (length <= 1) return s;\\n        String leftStr = s.substring(0, length / 2);\\n        String rightStr = s.substring(length / 2, length);\\n        return reverseString(rightStr) + reverseString(leftStr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1901756,
                "title": "java-c-3-way-s-visual-solution",
                "content": "How\\'s going Ladies - n - Gentlemen today we are going to solve another coolest problem i.e. **Reverse String**\\n\\n```\\nThis is A way easy Problem, if you encounter this in your Technical Interview, belive me you are way more lucky <^^> \\n```\\n\\nSo, to solve this problem there are couple of ways to do that.\\n```\\nWe gonna solve this problem in 3 simple & effective way\\'s \\n```\\n**1. Two Pointer\\'s**\\n\\n**`Visuall EXPLANATION :-`**\\n\\n![image](https://assets.leetcode.com/users/images/75d33fe6-b487-4781-80de-5b6bfe447021_1648774237.6632404.gif)\\n\\n\\n**Java**\\n```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int i = 0;\\n        int j = s.length - 1;\\n        \\n        while(i <= j){\\n            char temp = s[i];\\n            s[i] = s[j];\\n            s[j] = temp;\\n            i++;\\n            j--;\\n        }\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int i = 0;\\n        int j = s.size() - 1;\\n        \\n        while(i <= j){\\n            char temp = s[i];\\n            s[i] = s[j];\\n            s[j] = temp;\\n            i++;\\n            j--;\\n        }\\n    }\\n};\\n```\\n\\nANALYSIS :-\\n* **Time Complexity :-** BigO(N)\\n\\n* **Space Complexity :-** BigO(1)\\n\\n**2. Recursive Call**\\n\\nExplanation is same as Two Pointer\\'s what only different happening is, we are solve this using our fucntion call every time. We are just doing the work to reverse only **1 time** first & last element, rest one we are not worrying about!! Because recursion will do that for us :)\\n\\n**Java**\\n```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int i = 0;\\n        int j = s.length - 1;\\n        solve(s, i, j);\\n    }\\n    public void solve(char[] s, int i, int j){\\n        if(i >= j) return;\\n        char temp = s[i];\\n        s[i] = s[j];\\n        s[j] = temp;\\n        solve(s, ++i, --j);\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int i = 0;\\n        int j = s.size() - 1;\\n        solve(s, i, j);\\n    }\\n    void solve(vector<char>& s, int i, int j){\\n        if(i >= j) return;\\n        char temp = s[i];\\n        s[i] = s[j];\\n        s[j] = temp;\\n        solve(s, ++i, --j);\\n    }\\n};\\n```\\n\\nANALYSIS :-\\n* **Time Complexity :-** BigO(N)\\n\\n* **Space Complexity :-** BigO(N)\\n\\n**3. Stack**\\n\\n**`Visuall EXPLANATION :-`**\\n\\n![image](https://assets.leetcode.com/users/images/6184e953-8895-4444-b1ed-5b288e955acc_1648775574.5048985.gif)\\n\\n\\n**Java**\\n```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        Stack<Character> st = new Stack<>();\\n        String str = new String(s);\\n        for(int i = 0; i < str.length(); i++){\\n            st.push(s[i]);\\n        }\\n        char ans[] = new char[s.length];\\n        int i = 0;\\n        while(st.size() > 0){\\n            s[i++] = st.pop();\\n        }\\n        for(int j = 0; j < str.length(); j++){\\n            ans[j] = str.charAt(j);\\n        }\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        //create a stack\\n        stack<char> st;\\n        //loop through the string, to add all the string elements in stack\\n        for(int i=0;i<s.size();i++){\\n            //create a variable to add the values\\n            char ch = s[i];\\n            st.push(ch);\\n        }\\n        //empty the original string\\n        s.clear();\\n        //add the stack elements to the string\\n        while(!st.empty()){\\n            char ch = st.top();\\n            //reversed\\n            s.push_back(ch);\\n            st.pop();\\n        }\\n    }\\n};\\n```\\n\\nANALYSIS :-\\n* **Time Complexity :-** BigO(N)\\n\\n* **Space Complexity :-** BigO(N)",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nThis is A way easy Problem, if you encounter this in your Technical Interview, belive me you are way more lucky <^^> \\n```\n```\\nWe gonna solve this problem in 3 simple & effective way\\'s \\n```\n```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int i = 0;\\n        int j = s.length - 1;\\n        \\n        while(i <= j){\\n            char temp = s[i];\\n            s[i] = s[j];\\n            s[j] = temp;\\n            i++;\\n            j--;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int i = 0;\\n        int j = s.size() - 1;\\n        \\n        while(i <= j){\\n            char temp = s[i];\\n            s[i] = s[j];\\n            s[j] = temp;\\n            i++;\\n            j--;\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int i = 0;\\n        int j = s.length - 1;\\n        solve(s, i, j);\\n    }\\n    public void solve(char[] s, int i, int j){\\n        if(i >= j) return;\\n        char temp = s[i];\\n        s[i] = s[j];\\n        s[j] = temp;\\n        solve(s, ++i, --j);\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int i = 0;\\n        int j = s.size() - 1;\\n        solve(s, i, j);\\n    }\\n    void solve(vector<char>& s, int i, int j){\\n        if(i >= j) return;\\n        char temp = s[i];\\n        s[i] = s[j];\\n        s[j] = temp;\\n        solve(s, ++i, --j);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        Stack<Character> st = new Stack<>();\\n        String str = new String(s);\\n        for(int i = 0; i < str.length(); i++){\\n            st.push(s[i]);\\n        }\\n        char ans[] = new char[s.length];\\n        int i = 0;\\n        while(st.size() > 0){\\n            s[i++] = st.pop();\\n        }\\n        for(int j = 0; j < str.length(); j++){\\n            ans[j] = str.charAt(j);\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        //create a stack\\n        stack<char> st;\\n        //loop through the string, to add all the string elements in stack\\n        for(int i=0;i<s.size();i++){\\n            //create a variable to add the values\\n            char ch = s[i];\\n            st.push(ch);\\n        }\\n        //empty the original string\\n        s.clear();\\n        //add the stack elements to the string\\n        while(!st.empty()){\\n            char ch = st.top();\\n            //reversed\\n            s.push_back(ch);\\n            st.pop();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 80935,
                "title": "simple-c-solution",
                "content": "    class Solution {\\n    public:\\n        string reverseString(string s) {\\n            int i = 0, j = s.size() - 1;\\n            while(i < j){\\n                swap(s[i++], s[j--]); \\n            }\\n            \\n            return s;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        string reverseString(string s) {\\n            int i = 0, j = s.size() - 1;\\n            while(i < j){\\n                swap(s[i++], s[j--]); \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 80946,
                "title": "python2-7-3-solutions-recursive-classic-pythonic",
                "content": "```\\nclass Solution(object):\\n    def reverseString(self, s):\\n        l = len(s)\\n        if l < 2:\\n            return s\\n        return self.reverseString(s[l/2:]) + self.reverseString(s[:l/2])\\n\\n\\nclass SolutionClassic(object):\\n    def reverseString(self, s):\\n        r = list(s)\\n        i, j  = 0, len(r) - 1\\n        while i < j:\\n            r[i], r[j] = r[j], r[i]\\n            i += 1\\n            j -= 1\\n\\n        return \"\".join(r)\\n\\nclass SolutionPythonic(object):\\n    def reverseString(self, s):\\n        return s[::-1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def reverseString(self, s):\\n        l = len(s)\\n        if l < 2:\\n            return s\\n        return self.reverseString(s[l/2:]) + self.reverseString(s[:l/2])\\n\\n\\nclass SolutionClassic(object):\\n    def reverseString(self, s):\\n        r = list(s)\\n        i, j  = 0, len(r) - 1\\n        while i < j:\\n            r[i], r[j] = r[j], r[i]\\n            i += 1\\n            j -= 1\\n\\n        return \"\".join(r)\\n\\nclass SolutionPythonic(object):\\n    def reverseString(self, s):\\n        return s[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 670137,
                "title": "python-3-actually-easiest-solution",
                "content": "**It\\'s so simiple, a caveman could do it**\\n\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        s[:] = s[::-1]\\n```\\n\\n**Note:**\\n`s[:] = s[::-1]` is required **NOT** `s = s[::-1]` because you have to edit the list **inplace**. \\nUnder the hood, `s[:] =` is editing the actual memory bytes s points to, and `s = ` points the variable name `s` to other bytes in the memory.\\n\\n(easiest except .reverse())",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        s[:] = s[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 669571,
                "title": "python-oneliner-two-pointers-explained",
                "content": "It is very tempting in Python just to use  `reverse()` function, but I think it is not fully honest solution. \\nInstead, we go from the start and the end of the string and swap pair of elements. One thing, that we need to do is to stop at the middle of our string. We can see this as simplified version of **two points** approach, because each step we increase one of them and decrease another.\\n\\n**Complexity**: Time complexity is `O(n)` and additional space is `O(1)`.\\n\\n```\\nclass Solution:\\n    def reverseString(self, s):\\n        for i in range(len(s)//2): s[i], s[-i-1] = s[-i-1], s[i]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def reverseString(self, s):\\n        for i in range(len(s)//2): s[i], s[-i-1] = s[-i-1], s[i]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 669726,
                "title": "python-js-java-go-c-sol-sharing-w-visualization",
                "content": "Several solution sharing\\n\\n---\\n\\n**Illustartion**&**Visualization**:\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1591263228.png)\\n\\n---\\n\\n**Implementation** by mirror image:\\n\\nPython\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n       \\n        size = len(s)\\n\\t\\t\\n\\t\\t# reverse string by mirror image\\n        for i in range(size//2):\\n            s[i], s[-i-1] = s[-i-1], s[i]\\n```\\n\\n\\n---\\n\\n\\nC++\\n<details>\\n\\t<summary> Click to show source code\\n\\t</summary>\\n\\t\\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        \\n        size_t n = s.size();\\n        \\n\\t\\t// reverse string by mirror image\\n        for( size_t i = 0; i < n/2 ; i ++){\\n\\t\\t\\n            swap(s[i], s[n-1-i]);            \\n        }\\n        \\n        return;\\n    }\\n};\\n```\\t\\n\\t\\n</details>\\n\\n---\\n\\nGolang:\\n\\n<details>\\n\\t<summary> Click to show source code\\n\\t</summary>\\n\\t\\n```\\nfunc reverseString(s []byte)  {\\n    \\n    size := len(s)\\n    \\n    // reverse string by mirror image\\n    for i := 0 ; i < size/2 ; i++{\\n        s[i], s[size-1-i] = s[size-1-i], s[i]\\n    }\\n    \\n    return\\n    \\n}\\n```\\t\\n\\t\\n</details>\\n\\n\\n---\\n\\nJava:\\n\\n<details>\\n\\t<summary> Click to show source code\\n\\t</summary>\\n\\n```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        \\n        int n = s.length;\\n        \\n\\t\\t// reverse string by mirror image\\n        for( int i = 0; i < n/2 ; i ++){\\n\\t\\t\\n            char temp = s[i];\\n            s[i] = s[n-1-i];\\n            s[n-1-i] = temp;\\n        }\\n        \\n        return;\\n    }\\n}\\n```\\n</details>\\n\\n---\\n\\nJavascript:\\n\\n<details>\\n\\t<summary> Click to show source code\\n\\t</summary>\\n\\t\\n```\\nvar reverseString = function(s) {\\n    \\n    let size = s.length;\\n    \\n    // reverse string by mirror image\\n    for(let i = 0 ; i < Math.floor(size/2) ; i++ ){\\n        [ s[i], s[size-1-i] ] = [ s[size-1-i], s[i] ] ;\\n    }\\n    \\n    return;\\n};\\n```\\t\\n\\t\\n</details>\\n\\n\\n\\n\\n---\\n\\n**Implementation** by two pointers:\\n\\nPython\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:            \\n        \\n\\t\\t# one points to head position, the other points to tail position\\n        left, right = 0, len(s)-1\\n        \\n\\t\\t# reverse string by two pointers\\n        while left < right:\\n            \\n            s[left], s[right] = s[right], s[left]\\n            \\n            left,right = left+1, right-1\\n```\\n\\n---\\n\\nC++\\n\\n<details>\\n\\t<summary>Click to show source code\\n\\t</summary>\\n\\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        \\n        // one points to head position, the other points to tail position\\n        size_t left = 0, right = s.size()-1;\\n        \\n        // reverse string by two pointers\\n        while( left < right ){\\n            \\n            swap(s[left], s[right]);            \\n            \\n            left += 1;\\n            right -= 1;\\n        }\\n        \\n        return;\\n    }\\n};\\n```\\n\\n</details>\\n\\n---\\n\\nGo:\\n\\n<details>\\n\\t<summary>Click to show source code\\n\\t</summary>\\n\\n```\\nfunc reverseString(s []byte)  {\\n    \\n    // one points to head position, the other points to tail position\\n    left, right := 0, len(s)-1\\n    \\n    // reverse string by two pointers\\n    for left < right{\\n        \\n        s[left], s[right] = s[right], s[left]\\n\\n        left,right = left+1, right-1\\n    }\\n    \\n    return\\n    \\n}\\n```\\n\\n</details>\\n\\n---\\n\\nJava:\\n\\n\\n<details>\\n\\t<summary>Click to show source code\\n\\t</summary>\\n\\t\\n```\\n\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        \\n        // one points to head position, the other points to tail position\\n        int left = 0, right = s.length-1;\\n        \\n        // reverse string by two pointers\\n        while( left < right ){\\n            \\n            char temp = s[left];\\n            s[left] = s[right];            \\n            s[right] = temp;\\n            \\n            left += 1;\\n            right -= 1;\\n        }\\n        \\n        return;\\n    }\\n}\\n```\\t\\n\\t\\n\\t\\n</details>\\n\\n---\\n\\nJavascript:\\n\\n\\n<details>\\n\\t<summary>Click to show source code\\n\\t</summary>\\n\\n```\\nvar reverseString = function(s) {\\n    \\n    // one points to head position, the other points to tail position\\n    let [left, right] = [0, s.length-1];\\n    \\n    // reverse string by two pointers\\n    while( left < right ){\\n        [ s[left], s[right] ] = [ s[right], s[left] ];\\n        \\n        left += 1;\\n        right -= 1;\\n    }\\n     \\n    return;\\n};\\n```\\n\\n</details>\\n\\n\\n\\n---\\n\\n**Implementation** by recursion:\\n\\nPython\\n\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:            \\n\\n        def helper( left:int, right:int, string: List[str]):     \\n            \\n            if left >= right:\\n                # base case\\n                return\\n            \\n            # general case\\n            s[left], s[right] = s[right], s[left]\\n            \\n            helper( left+1, right-1, s)\\n        # ------------------------------------------------\\n        \\n        helper( left = 0, right = len(s)-1, string = s)\\n```\\n\\n---\\n\\nC++\\n<details>\\n\\t<summary> Click to show source code\\n\\t</summary>\\n\\t\\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        \\n        \\n        helper(0, s.size()-1, s);\\n        \\n        return;\\n    }\\n    \\nprivate:\\n    void helper(int left, int right, vector<char>& s){\\n        \\n        if( left > right ){\\n            // base case aka stop condition\\n            return ;\\n        }\\n        \\n        // general cases\\n        swap( s[left], s[right] );\\n        helper(left+1, right-1, s);\\n        \\n        return;\\n    }\\n    \\n};\\n```\\t\\n\\t\\n</details>\\n\\n---\\n\\nGo:\\n\\n<details>\\n\\t<summary> Click to show source code\\n\\t</summary>\\n\\t\\n```\\n\\nfunc reverseString(s []byte)  {\\n\\n    \\n    var helper func( int, int)\\n    \\n    helper = func( left int, right int){\\n    \\n        if left >= right{\\n            // base case aka stop condition\\n            return\\n        }\\n        \\n        // general case\\n        // swap character \\n        s[left], s[right] = s[right], s[left]\\n        \\n        helper(left+1, right-1)\\n        return\\n    }\\n    \\n    \\n    helper(0, len(s)-1)\\n    \\n    return\\n    \\n}\\n```\\t\\n\\t\\n</details>\\n\\n---\\n\\nJavascript:\\n\\n<details>\\n\\t<summary> Click to show source code\\n\\t</summary>\\n\\t\\n```\\n\\nvar reverseString = function(s) {\\n    \\n    function helper(left, right){\\n        \\n        // base case aka stop condition\\n        if( left >= right){      \\n            return;\\n        }\\n        \\n        // general cases\\n        [ s[left], s[right] ] = [ s[right], s[left] ];\\n        \\n        helper(left+1, right-1);\\n        return;\\n    };\\n     \\n    helper( left=0, right=s.length-1 );\\n    return;\\n};\\n```\\t\\n\\t\\n</details>\\n\\n\\n---",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Go",
                    "String",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n       \\n        size = len(s)\\n\\t\\t\\n\\t\\t# reverse string by mirror image\\n        for i in range(size//2):\\n            s[i], s[-i-1] = s[-i-1], s[i]\\n```\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        \\n        size_t n = s.size();\\n        \\n\\t\\t// reverse string by mirror image\\n        for( size_t i = 0; i < n/2 ; i ++){\\n\\t\\t\\n            swap(s[i], s[n-1-i]);            \\n        }\\n        \\n        return;\\n    }\\n};\\n```\n```\\nfunc reverseString(s []byte)  {\\n    \\n    size := len(s)\\n    \\n    // reverse string by mirror image\\n    for i := 0 ; i < size/2 ; i++{\\n        s[i], s[size-1-i] = s[size-1-i], s[i]\\n    }\\n    \\n    return\\n    \\n}\\n```\n```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        \\n        int n = s.length;\\n        \\n\\t\\t// reverse string by mirror image\\n        for( int i = 0; i < n/2 ; i ++){\\n\\t\\t\\n            char temp = s[i];\\n            s[i] = s[n-1-i];\\n            s[n-1-i] = temp;\\n        }\\n        \\n        return;\\n    }\\n}\\n```\n```\\nvar reverseString = function(s) {\\n    \\n    let size = s.length;\\n    \\n    // reverse string by mirror image\\n    for(let i = 0 ; i < Math.floor(size/2) ; i++ ){\\n        [ s[i], s[size-1-i] ] = [ s[size-1-i], s[i] ] ;\\n    }\\n    \\n    return;\\n};\\n```\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:            \\n        \\n\\t\\t# one points to head position, the other points to tail position\\n        left, right = 0, len(s)-1\\n        \\n\\t\\t# reverse string by two pointers\\n        while left < right:\\n            \\n            s[left], s[right] = s[right], s[left]\\n            \\n            left,right = left+1, right-1\\n```\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        \\n        // one points to head position, the other points to tail position\\n        size_t left = 0, right = s.size()-1;\\n        \\n        // reverse string by two pointers\\n        while( left < right ){\\n            \\n            swap(s[left], s[right]);            \\n            \\n            left += 1;\\n            right -= 1;\\n        }\\n        \\n        return;\\n    }\\n};\\n```\n```\\nfunc reverseString(s []byte)  {\\n    \\n    // one points to head position, the other points to tail position\\n    left, right := 0, len(s)-1\\n    \\n    // reverse string by two pointers\\n    for left < right{\\n        \\n        s[left], s[right] = s[right], s[left]\\n\\n        left,right = left+1, right-1\\n    }\\n    \\n    return\\n    \\n}\\n```\n```\\n\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        \\n        // one points to head position, the other points to tail position\\n        int left = 0, right = s.length-1;\\n        \\n        // reverse string by two pointers\\n        while( left < right ){\\n            \\n            char temp = s[left];\\n            s[left] = s[right];            \\n            s[right] = temp;\\n            \\n            left += 1;\\n            right -= 1;\\n        }\\n        \\n        return;\\n    }\\n}\\n```\n```\\nvar reverseString = function(s) {\\n    \\n    // one points to head position, the other points to tail position\\n    let [left, right] = [0, s.length-1];\\n    \\n    // reverse string by two pointers\\n    while( left < right ){\\n        [ s[left], s[right] ] = [ s[right], s[left] ];\\n        \\n        left += 1;\\n        right -= 1;\\n    }\\n     \\n    return;\\n};\\n```\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:            \\n\\n        def helper( left:int, right:int, string: List[str]):     \\n            \\n            if left >= right:\\n                # base case\\n                return\\n            \\n            # general case\\n            s[left], s[right] = s[right], s[left]\\n            \\n            helper( left+1, right-1, s)\\n        # ------------------------------------------------\\n        \\n        helper( left = 0, right = len(s)-1, string = s)\\n```\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        \\n        \\n        helper(0, s.size()-1, s);\\n        \\n        return;\\n    }\\n    \\nprivate:\\n    void helper(int left, int right, vector<char>& s){\\n        \\n        if( left > right ){\\n            // base case aka stop condition\\n            return ;\\n        }\\n        \\n        // general cases\\n        swap( s[left], s[right] );\\n        helper(left+1, right-1, s);\\n        \\n        return;\\n    }\\n    \\n};\\n```\n```\\n\\nfunc reverseString(s []byte)  {\\n\\n    \\n    var helper func( int, int)\\n    \\n    helper = func( left int, right int){\\n    \\n        if left >= right{\\n            // base case aka stop condition\\n            return\\n        }\\n        \\n        // general case\\n        // swap character \\n        s[left], s[right] = s[right], s[left]\\n        \\n        helper(left+1, right-1)\\n        return\\n    }\\n    \\n    \\n    helper(0, len(s)-1)\\n    \\n    return\\n    \\n}\\n```\n```\\n\\nvar reverseString = function(s) {\\n    \\n    function helper(left, right){\\n        \\n        // base case aka stop condition\\n        if( left >= right){      \\n            return;\\n        }\\n        \\n        // general cases\\n        [ s[left], s[right] ] = [ s[right], s[left] ];\\n        \\n        helper(left+1, right-1);\\n        return;\\n    };\\n     \\n    helper( left=0, right=s.length-1 );\\n    return;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1901752,
                "title": "c-two-lines-wow-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nWe use here two pointers that gives us access to characters for swapping in left and right side of the string. For swapping we use a convinient C++ method [swap](https://www.cplusplus.com/reference/algorithm/swap/). We just iterate over characters and swap them.\\n\\nTime: **O(n)**\\nSpace: **O(1)**\\n\\nRuntime: 24 ms, faster than **76.05%** of C++ online submissions for Reverse String.\\nMemory Usage: 23.3 MB, less than **41.72%** of C++ online submissions for Reverse String.\\n\\n```\\nvoid reverseString(vector<char>& s) {\\n\\tint i = 0, j = s.size() - 1;\\n\\twhile (i < j) swap(s[i++], s[j--]);\\n}\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid reverseString(vector<char>& s) {\\n\\tint i = 0, j = s.size() - 1;\\n\\twhile (i < j) swap(s[i++], s[j--]);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 794541,
                "title": "easy-to-understand-recursive-approach-c",
                "content": "In recursion, we just need to take care of 2 things i.e.\\n1. Base Condition\\n2. A relation or a formula that can divide a big problem into small subproblem of same type\\n\\nRest other things we don\\'t have to bother about, it wil be taken care by recursion.\\nSo here\\'s my recursive solution\\n```\\nclass Solution {\\npublic:\\n    void rev(vector<char>& s, int left, int right)\\n    {\\n        if(left>=right)                             // Base Condition\\n            return;\\n        swap(s[left++],s[right--]);                 // makes the problem smaller of same type            \\n        rev(s,left,right);\\n    }\\n    void reverseString(vector<char>& s) {\\n        rev(s,0,s.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rev(vector<char>& s, int left, int right)\\n    {\\n        if(left>=right)                             // Base Condition\\n            return;\\n        swap(s[left++],s[right--]);                 // makes the problem smaller of same type            \\n        rev(s,left,right);\\n    }\\n    void reverseString(vector<char>& s) {\\n        rev(s,0,s.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 279927,
                "title": "es6-destructuring-assignment",
                "content": "Leverage ES6 Destructuring assignment - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\\n```\\n/**\\n * @param {character[]} s\\n * @return {void} Do not return anything, modify s in-place instead.\\n */\\nvar reverseString = function(s) {\\n  let i = 0, j = s.length - 1;\\n  while (i < j) {\\n    // ES6 destructuring assignment\\n    [s[i], s[j]] = [s[j], s[i]];\\n    i++;\\n    j--;\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {character[]} s\\n * @return {void} Do not return anything, modify s in-place instead.\\n */\\nvar reverseString = function(s) {\\n  let i = 0, j = s.length - 1;\\n  while (i < j) {\\n    // ES6 destructuring assignment\\n    [s[i], s[j]] = [s[j], s[i]];\\n    i++;\\n    j--;\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3718521,
                "title": "easy-solution-with-simple-explanation",
                "content": "## ***Please Upvote my solution, if you find it helpful ;)***\\n\\n# Intuition\\nWe want to reverse a character array in place, meaning we cannot use any additional memory like creating a new array.\\nTo achieve this, we will use the two-pointer approach, where we place two pointers, i and j, at the two ends of the array. We\\'ll swap the characters at these pointers to reverse the array.\\n# Approach\\n1. We will use two pointers, i and j, initialized to the start and end of the array, respectively.\\n1. While i is less than j, we will perform the following steps:\\n- Swap the characters at positions i and j.\\n- Move i one step forward (towards the middle) by incrementing it.\\n- Move j one step backward (towards the middle) by decrementing it.\\n- We keep repeating the above steps until i is less than or equal to j. When i becomes equal to or greater than j, the whole array will be reversed.\\n# Complexity\\n- Time complexity:\\nThe two-pointer approach runs in linear time $$O(N)$$, where N is the length of the character array. This is because each element is swapped at most once.\\n\\n- Space complexity:\\nThe space complexity is constant $$O(1)$$ because we are not using any additional memory that grows with the input size. We are modifying the given array in place.\\n# Code\\n```java []\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        // Iterate from the beginning (i) and end (j) of the array towards the middle.\\n        for (int i = 0, j = s.length - 1; i < s.length / 2; i++, j--) {\\n            // Use a temporary variable (temp) to store the character at index i.\\n            char temp = s[i];\\n\\n            // Replace the character at index i with the character at index j.\\n            s[i] = s[j];\\n\\n            // Replace the character at index j with the character in the temporary variable (temp).\\n            s[j] = temp;\\n        } \\n        // At this point, the character array \\'s\\' contains the reversed string.\\n    }\\n}\\n```\\n```python []\\nclass Solution(object):\\n    def reverseString(self, s):\\n        # Two pointers, i pointing to the start and j pointing to the end of the list\\n        i = 0\\n        j = len(s) - 1\\n\\n        while i < j:\\n            # Swap the characters at positions i and j\\n            s[i], s[j] = s[j], s[i]\\n\\n            # Move i one step forward and j one step backward\\n            i += 1\\n            j -= 1\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        // Two pointers, i pointing to the start and j pointing to the end of the vector\\n        int i = 0;\\n        int j = s.size() - 1;\\n\\n        while (i < j) {\\n            // Swap the characters at positions i and j\\n            char temp = s[i];\\n            s[i] = s[j];\\n            s[j] = temp;\\n\\n            // Move i one step forward and j one step backward\\n            i++;\\n            j--;\\n        }\\n    }\\n};\\n```\\n## ***Please Upvote my solution, if you find it helpful ;)***\\n![6a87bc25-d70b-424f-9e60-7da6f345b82a_1673875931.8933976.jpeg](https://assets.leetcode.com/users/images/43b7b8c2-a65b-425a-a9fe-3b558ba3e7e2_1688491323.1367128.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Two Pointers",
                    "String"
                ],
                "code": "```java []\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        // Iterate from the beginning (i) and end (j) of the array towards the middle.\\n        for (int i = 0, j = s.length - 1; i < s.length / 2; i++, j--) {\\n            // Use a temporary variable (temp) to store the character at index i.\\n            char temp = s[i];\\n\\n            // Replace the character at index i with the character at index j.\\n            s[i] = s[j];\\n\\n            // Replace the character at index j with the character in the temporary variable (temp).\\n            s[j] = temp;\\n        } \\n        // At this point, the character array \\'s\\' contains the reversed string.\\n    }\\n}\\n```\n```python []\\nclass Solution(object):\\n    def reverseString(self, s):\\n        # Two pointers, i pointing to the start and j pointing to the end of the list\\n        i = 0\\n        j = len(s) - 1\\n\\n        while i < j:\\n            # Swap the characters at positions i and j\\n            s[i], s[j] = s[j], s[i]\\n\\n            # Move i one step forward and j one step backward\\n            i += 1\\n            j -= 1\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        // Two pointers, i pointing to the start and j pointing to the end of the vector\\n        int i = 0;\\n        int j = s.size() - 1;\\n\\n        while (i < j) {\\n            // Swap the characters at positions i and j\\n            char temp = s[i];\\n            s[i] = s[j];\\n            s[j] = temp;\\n\\n            // Move i one step forward and j one step backward\\n            i++;\\n            j--;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1232381,
                "title": "c-easy-to-understand-iterative",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)**\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        vector<char> vec;\\n        for(int i=s.size()-1;i>=0;i--)\\n        {\\n            vec.push_back(s[i]);\\n        }\\n        s=vec;\\n    }\\n};\\n**In a similar way you may also use a stack to solve the given problem**\\n\\n**Two pointers approach(more space efficient)**\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n       int start=0,e=s.size()-1;\\n        while(start<e)\\n        {\\n            swap(s[start],s[e]);\\n            start++;\\n            e--;\\n        }\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        vector<char> vec;\\n        for(int i=s.size()-1;i>=0;i--)\\n        {\\n            vec.push_back(s[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 275116,
                "title": "java-simple-multiple-solutions-w-explanations",
                "content": "Interesting ways to do this problem!!!\\n\\n\\nSolution 1:  1ms\\n-Correct way of doing this. Modifying the input array in-place with O(1) extra memory.\\n```\\n    public void reverseString(char[] s) {\\n        for(int i=0; i<s.length/2; i++){    //Do it half the number of String length\\n            char tmp = s[i];\\n            s[i] = s[s.length-1-i];     //Front swap with other End side \\n            s[s.length-1-i] = tmp;      //End swap with other Front side\\n        }\\n    }\\n```\\n\\n\\nSolution 2: 400ms\\n-If you have no idea how to do this correctly and you just gota try something.\\n```\\n    public void reverseString(char[] s) {\\n        String str = \"\";                   //Allocate extra space\\n        \\n        for(int i=s.length-1; i>=0; i--)   /*Add to extra space from rear to front */\\n            str += s[i];\\n        \\n        for(int i=0; i<s.length; i++)      /*Set reversed \\'str\\' into char array \\'s\\' */\\n            s[i] = str.charAt(i);\\n    }\\n```\\n\\nSolution 3:\\n-You said you control the interview.\\n```\\n new StringBuilder(s).reverse().toString();\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public void reverseString(char[] s) {\\n        for(int i=0; i<s.length/2; i++){    //Do it half the number of String length\\n            char tmp = s[i];\\n            s[i] = s[s.length-1-i];     //Front swap with other End side \\n            s[s.length-1-i] = tmp;      //End swap with other Front side\\n        }\\n    }\\n```\n```\\n    public void reverseString(char[] s) {\\n        String str = \"\";                   //Allocate extra space\\n        \\n        for(int i=s.length-1; i>=0; i--)   /*Add to extra space from rear to front */\\n            str += s[i];\\n        \\n        for(int i=0; i<s.length; i++)      /*Set reversed \\'str\\' into char array \\'s\\' */\\n            s[i] = str.charAt(i);\\n    }\\n```\n```\\n new StringBuilder(s).reverse().toString();\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 164959,
                "title": "two-javascript-solutions-with-detailed-explanation-two-pointers-native-functions-and-bad-examples",
                "content": "Here are my two solutions for this question.\\n\\n*-- edit --*\\nSince the question mutated from \"reverse immutable string\" into \"reverse array of characters\", **\"Bad solution 1\" is now the best answer**. In programming best practices can sometimes mutate into anti-patterns, but this is the first time for me when an anti-pattern mutated into the best solution.\\n*-- end of edit --*\\n\\n**Native functions**\\nThis approach uses native javascript functions to make the code very short and easy to read.\\n\\n```\\nlet reverseString = function(s) {\\n    return s.split(\\'\\').reverse().join(\\'\\');\\n};\\n```\\n\\nWhat we did there:\\nFirst, we split a string into array of characters. Since we provide empty string as divider, the entire string is split into array elements, every character becomes a separate element. Next, we apply Array.prototype method `reverse()`, which, as the name implies, reverses the contents of an array. Then we simply join the array back into a string without any divider (using empty string `\\'\\'` as element divider).\\n\\nTime and space complexity are unknown because we\\'re using built-in language functions instead of writing our own super-efficient code. You can google on time and space complexity of these functions if you *must* know.\\n\\n**Two pointers approach**\\nWe can do this using two pointer approach to reduce the number of times we \"run\" this script against array by half:\\n\\n```\\nlet reverseString = function(s) {\\n    let arr = s.split(\\'\\'), left = 0, right = arr.length - 1;\\n    while (left < right) {\\n        let temp = arr[left];\\n        arr[left] = arr[right];\\n        arr[right] = temp;\\n        ++left;\\n        --right;\\n    }\\n    return arr.join(\\'\\');\\n};\\n```\\n\\nThis approach is fairly straightforward:\\nFirst, declare two pointers, left and right. Then iterate over the array, one pointer looking at the front of the array, another looking at the rear. As long as left is smaller than right, swap elements in place. When pointers meet or cross, you\\'re done.\\n\\nTime complexity: O(n)\\nSpace complexity: O(n). We create a separate array based on input string, number of elements in array matches the number of characters in the string.\\n\\n**Bad examples**\\nHere are two more solutions you should not use.\\n1. Assume strings can be manipulated directly, like an array (since you can access string elements by index). Example:\\n```\\nlet reverseString = function(s) {\\n    let left = 0, right = s.length - 1;\\n    while (left < right) {\\n        let temp = s[left];\\n        s[left] = s[right];\\n        s[right] = temp;\\n        ++left;\\n        --right;\\n    }\\n    return s;\\n};\\n```\\n**In Javascript** strings are immutable (this depends on programming language), which means string is like an array in the meaning you can access its elements by index. But it does not allow manipulating individual elements at individual indexes. If you try this in \\'normal\\' mode, it fill fail silently (it will execute but string won\\'t be modified and you\\'ll never know why). If you use strict mode via `\\'use strict\\';`, it will fail with the following error:\\n`TypeError: Cannot assign to read only property \\'0\\' of string \\'hello\\'`\\n\\nVerdict of the story: you should **always** use strict mode.\\n\\n2. Try to work around the problem of immutable strings by \\'concatenating\\' strings at each step of a loop, like this:\\n\\n```\\nvar reverseString = function(s) {\\n    let res = \"\";\\n    for(let i = s.length - 1; i >= 0; i --){\\n        res += s[i];\\n    }\\n    return res;\\n};\\n```\\n\\nCode source:\\nhttps://leetcode.com/problems/reverse-string/discuss/164660/javascript-solution\\n\\nThis approach will work and won\\'t crash (not immediately, at least). The problem of this approach is that it will use a ton of space (`O(n!)`, I believe, which is pretty **bad**) instead of `O(n)` one would expect.\\n\\n*Why this happens*: since strings are immutable, you\\'ll be creating a new string at each step of the loop, each string will be as long as previous string + 1 element. This means we\\'re effectively creating and discarding O(n) strings, each of which ranges from `O(1)` to `O(n)` in space, effectively means we\\'re **wasting** (touching, garbaging) `O(n!)` space even though it seems we only use `O(n)` space at any one moment. All those strings should be garbage-collected at some point, which will affect performance. For smaller strings and smaller programs the effect will be minimal, but for large-scale applications this could create bottlenecks at some point.\\n\\nHopefully you find this information useful :)\\n\\nP.S.: all examples will only work with strings that fit into memory. If your string doesn\\'t fit into memory (large files, multiple gigabytes each, will not fit into the memory of a small virtual machine in AWS cluster, for example), you have to create a different approach. For example: create a number of files, each containing a portion of the reversed string and save them with some index. Then process file array from the end, streaming file contents into the resulting file.\\n\\nIf you know a better approach of reversing huge files, please do let me know.",
                "solutionTags": [],
                "code": "```\\nlet reverseString = function(s) {\\n    return s.split(\\'\\').reverse().join(\\'\\');\\n};\\n```\n```\\nlet reverseString = function(s) {\\n    let arr = s.split(\\'\\'), left = 0, right = arr.length - 1;\\n    while (left < right) {\\n        let temp = arr[left];\\n        arr[left] = arr[right];\\n        arr[right] = temp;\\n        ++left;\\n        --right;\\n    }\\n    return arr.join(\\'\\');\\n};\\n```\n```\\nlet reverseString = function(s) {\\n    let left = 0, right = s.length - 1;\\n    while (left < right) {\\n        let temp = s[left];\\n        s[left] = s[right];\\n        s[right] = temp;\\n        ++left;\\n        --right;\\n    }\\n    return s;\\n};\\n```\n```\\nvar reverseString = function(s) {\\n    let res = \"\";\\n    for(let i = s.length - 1; i >= 0; i --){\\n        res += s[i];\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 81156,
                "title": "c-solution-sharing",
                "content": "    char* reverseString(char* s) {\\n     int l = 0;\\n     int r = strlen(s)-1;\\n     char c;\\n     \\n     while(l<r)\\n     {\\n         // swap chars\\n         c = s[l];\\n         s[l] = s[r];\\n         s[r] = c;\\n         l++;\\n         r--;\\n     }\\n     \\n     return s;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "    char* reverseString(char* s) {\\n     int l = 0;\\n     int r = strlen(s)-1;\\n     char c;\\n     \\n     while(l<r)\\n     {\\n         // swap chars\\n         c = s[l];\\n         s[l] = s[r];\\n         s[r] = c;\\n         l++;\\n         r--;\\n     }\\n     \\n     return s;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 80961,
                "title": "python-solution",
                "content": " Python:\\n\\n       class Solution(object):\\n            def reverseString(self, s):\\n                \"\"\"\\n                :type s: str\\n                :rtype: str\\n                \"\"\"\\n                return s[::-1]",
                "solutionTags": [
                    "Python"
                ],
                "code": " Python:\\n\\n       class Solution(object):\\n            def reverseString(self, s):\\n                \"\"\"\\n                :type s: str\\n                :rtype: str\\n                \"\"\"\\n                return s[::-1]",
                "codeTag": "Java"
            },
            {
                "id": 995210,
                "title": "java-4-line-solution",
                "content": "```\\npublic void reverseString(char[] s) {\\n        for(int i = 0, j = s.length- 1 ; i < j ; i++,j--){\\n            char temp = s[i];\\n            s[i] = s[j];\\n            s[j] = temp;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic void reverseString(char[] s) {\\n        for(int i = 0, j = s.length- 1 ; i < j ; i++,j--){\\n            char temp = s[i];\\n            s[i] = s[j];\\n            s[j] = temp;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 480217,
                "title": "js-2-pointer-technique-2-liner",
                "content": "### 2 pointer technique with iteration\\n- Time complexity: **O(N)**\\n- Space complexity: **O(1)**\\n\\n```JavaScript\\n/**\\n * @param {character[]} s\\n * @return {void} Do not return anything, modify s in-place instead.\\n */\\nvar reverseString = (s) => {\\n    for (let [a, b] = [0, s.length - 1]; a < b; a++, b--) {\\n        [s[a], s[b]] = [s[b], s[a]]\\n    }\\n};\\n```\\n### 2 pointer technique with recursion\\n- Time complexity: **O(N)**\\n- Space complexity: **O(N)**\\n```JavaScript\\n/**\\n * @param {character[]} s\\n * @return {void} Do not return anything, modify s in-place instead.\\n */\\nvar reverseString = s => {\\n    reverse(0, s.length - 1);\\n\\n    /**\\n     * @param {character[]} s\\n     * @return {void} Do not return anything, modify s in-place instead.\\n     */\\n    function reverse(i, j) {\\n        if (i >= j) return;\\n        [s[i], s[j]] = [s[j], s[i]];\\n        reverse(i + 1, j - 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```JavaScript\\n/**\\n * @param {character[]} s\\n * @return {void} Do not return anything, modify s in-place instead.\\n */\\nvar reverseString = (s) => {\\n    for (let [a, b] = [0, s.length - 1]; a < b; a++, b--) {\\n        [s[a], s[b]] = [s[b], s[a]]\\n    }\\n};\\n```\n```JavaScript\\n/**\\n * @param {character[]} s\\n * @return {void} Do not return anything, modify s in-place instead.\\n */\\nvar reverseString = s => {\\n    reverse(0, s.length - 1);\\n\\n    /**\\n     * @param {character[]} s\\n     * @return {void} Do not return anything, modify s in-place instead.\\n     */\\n    function reverse(i, j) {\\n        if (i >= j) return;\\n        [s[i], s[j]] = [s[j], s[i]];\\n        reverse(i + 1, j - 1);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 81063,
                "title": "java-easiest-method-2-line-code-attached-another-method",
                "content": "   \\n\\n    //method 1: use StringBuilder\\n        public String reverseString(String s) {\\n            StringBuilder sb = new StringBuilder(s);\\n            return sb.reverse().toString();\\n        }\\n    \\n        //method 2: use swap method\\n        public String reverseString(String s){\\n            if(s == null || s.length() == 0)\\n                return \"\";\\n            char[] cs = s.toCharArray();\\n            int begin = 0, end = s.length() - 1;\\n            while(begin <= end){\\n                char c = cs[begin];\\n                cs[begin] = cs[end];\\n                cs[end] = c;\\n                begin++;\\n                end--;\\n            }\\n            \\n            return new String(cs);\\n        }",
                "solutionTags": [],
                "code": "   \\n\\n    //method 1: use StringBuilder\\n        public String reverseString(String s) {\\n            StringBuilder sb = new StringBuilder(s);\\n            return sb.reverse().toString();\\n        }\\n    \\n        //method 2: use swap method\\n        public String reverseString(String s){\\n            if(s == null || s.length() == 0)\\n                return \"\";\\n            char[] cs = s.toCharArray();\\n            int begin = 0, end = s.length() - 1;\\n            while(begin <= end){\\n                char c = cs[begin];\\n                cs[begin] = cs[end];\\n                cs[end] = c;\\n                begin++;\\n                end--;\\n            }\\n            \\n            return new String(cs);\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 1902265,
                "title": "simple-clear-easy-understanding",
                "content": "```\\nvar reverseString = function(s) {\\n    \\n  let left = 0;\\n  let right = s.length - 1;\\n\\n  while (left <= right) {\\n    [s[left],s[right]] = [s[right],s[left]]\\n    left++;\\n    right--;\\n  }\\n  return s;\\n};\\n```\\n**PLEASE UPVOTE!**",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nvar reverseString = function(s) {\\n    \\n  let left = 0;\\n  let right = s.length - 1;\\n\\n  while (left <= right) {\\n    [s[left],s[right]] = [s[right],s[left]]\\n    left++;\\n    right--;\\n  }\\n  return s;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 81199,
                "title": "python-one-line-solution",
                "content": "    class Solution(object):\\n        def reverseString(self, s):\\n            \"\"\"\\n            :type s: str\\n            :rtype: str\\n            \"\"\"\\n            return s[::-1]",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n        def reverseString(self, s):\\n            \"\"\"\\n            :type s: str\\n            :rtype: str\\n            \"\"\"\\n            return s[::-1]",
                "codeTag": "Java"
            },
            {
                "id": 3194987,
                "title": "python-two-pointer-clean-simple-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n    Loop goes until n/2 but we represent $$O(n/2)$$ to $$O(n)$$. \\nHence TC is $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        # Two Pointer\\n        l, r =0, len(s) - 1\\n        while l < r:\\n            s[l], s[r] = s[r], s[l]\\n            l += 1\\n            r -= 1\\n```\\n\\nSimply you can use for loop like below :\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        n = len(s)\\n        for i in range(n // 2):\\n            s[i], s[n - i - 1] = s[n - i - 1], s[i]\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        # Two Pointer\\n        l, r =0, len(s) - 1\\n        while l < r:\\n            s[l], s[r] = s[r], s[l]\\n            l += 1\\n            r -= 1\\n```\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        n = len(s)\\n        for i in range(n // 2):\\n            s[i], s[n - i - 1] = s[n - i - 1], s[i]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2681103,
                "title": "js-es6-two-pointers-with-explanation",
                "content": "Two pointers is the use of two different pointers (usually to keep track of array or string indexes) to solve a problem with specified indexes in order to save time and space.\\n\\nTo solve this problem, we just need to steps by indices from both ends, and swap them until the indices meet in the middle.\\n\\nI hope the picture below will give you a clearer understanding :)\\n\\n![image](https://assets.leetcode.com/users/images/f8dfebd6-5f46-4ffa-8071-7b4d0c6c94ba_1665314490.753274.png)\\n\\n\\n```\\nvar reverseString = function(s) {\\n    for (let i = 0, j = s.length - 1; i < j;) {\\n        [s[i], s[j]] = [s[j], s[i]];\\n        i++;\\n        j--;\\n    }\\n    return s;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nvar reverseString = function(s) {\\n    for (let i = 0, j = s.length - 1; i < j;) {\\n        [s[i], s[j]] = [s[j], s[i]];\\n        i++;\\n        j--;\\n    }\\n    return s;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2998802,
                "title": "c-java-c-python-simple-solutions-easy-to-understand-two-pointers",
                "content": "# Frequently encountered in technical interviews\\n```\\nstd::vector<std::pair<std::string, int>> interview_frequency= {\\n    {\"Amazon\", 6},\\n    {\"Microsoft\", 5},\\n    {\"Adobe\", 5},\\n    {\"Facebook\", 3},\\n    {\"tcs\", 3},\\n    {\"Apple\", 2},\\n    {\"Intel\", 2}\\n};\\n```\\n\\n# Solution\\n\\n```C++ []\\n// 1. Using Stack\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        stack<char> st;\\n        for(int i=0; i<s.size(); i++) st.push(s[i]);\\n        s.clear();\\n        while(!st.empty()) {\\n            s.push_back(st.top());\\n            st.pop();\\n        }\\n    }\\n};\\n// 2. Recursion\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int i=0, j = s.size() - 1;\\n        swapImp(s, i, j); \\n    }\\n    void swapImp(vector<char>& s,int i,int j){\\n        if(i >= j) return;\\n        s[i] ^= s[j];\\n        s[j] ^= s[i];\\n        s[i] ^= s[j];\\n        swapImp(s, ++i, --j);\\n    }\\n};\\n// 3. Two Pointers\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int i = 0, j = s.size()-1;\\n        while (i < j) \\n            swap(s[i++], s[j--]); \\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int i = 0;\\n        int j = s.length-1;\\n        while (i<j) {\\n            char temp = s[i];\\n            s[i++] = s[j];\\n            s[j--] = temp;\\n        }\\n    }\\n}\\n```\\n```csharp []\\npublic class Solution {\\n    public void ReverseString(char[] s) {\\n        int i = 0;\\n        int j = s.Length-1;\\n        while (i < j) {\\n            char temp = s[i];\\n            s[i++] = s[j];\\n            s[j--] = temp;\\n        }\\n    }\\n}\\n```\\n```python []\\nclass Solution(object):\\n    def reverseString(self, s):\\n        i = 0\\n        j = len(s) - 1\\n        while (i < j):\\n            temp = s[i]\\n            s[i] = s[j]\\n            s[j] = temp\\n            i += 1\\n            j -= 1\\n        return s\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C#",
                    "Two Pointers",
                    "Stack"
                ],
                "code": "```\\nstd::vector<std::pair<std::string, int>> interview_frequency= {\\n    {\"Amazon\", 6},\\n    {\"Microsoft\", 5},\\n    {\"Adobe\", 5},\\n    {\"Facebook\", 3},\\n    {\"tcs\", 3},\\n    {\"Apple\", 2},\\n    {\"Intel\", 2}\\n};\\n```\n```C++ []\\n// 1. Using Stack\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        stack<char> st;\\n        for(int i=0; i<s.size(); i++) st.push(s[i]);\\n        s.clear();\\n        while(!st.empty()) {\\n            s.push_back(st.top());\\n            st.pop();\\n        }\\n    }\\n};\\n// 2. Recursion\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int i=0, j = s.size() - 1;\\n        swapImp(s, i, j); \\n    }\\n    void swapImp(vector<char>& s,int i,int j){\\n        if(i >= j) return;\\n        s[i] ^= s[j];\\n        s[j] ^= s[i];\\n        s[i] ^= s[j];\\n        swapImp(s, ++i, --j);\\n    }\\n};\\n// 3. Two Pointers\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int i = 0, j = s.size()-1;\\n        while (i < j) \\n            swap(s[i++], s[j--]); \\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int i = 0;\\n        int j = s.length-1;\\n        while (i<j) {\\n            char temp = s[i];\\n            s[i++] = s[j];\\n            s[j--] = temp;\\n        }\\n    }\\n}\\n```\n```csharp []\\npublic class Solution {\\n    public void ReverseString(char[] s) {\\n        int i = 0;\\n        int j = s.Length-1;\\n        while (i < j) {\\n            char temp = s[i];\\n            s[i++] = s[j];\\n            s[j--] = temp;\\n        }\\n    }\\n}\\n```\n```python []\\nclass Solution(object):\\n    def reverseString(self, s):\\n        i = 0\\n        j = len(s) - 1\\n        while (i < j):\\n            temp = s[i]\\n            s[i] = s[j]\\n            s[j] = temp\\n            i += 1\\n            j -= 1\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 81152,
                "title": "python-recursive-solution",
                "content": "    class Solution(object):\\n        def reverseString(self, s):\\n            \"\"\"\\n            :type s: str\\n            :rtype: str\\n            \"\"\"\\n            if len(s)<=1:\\n                return s\\n            n=len(s)\\n            return self.reverseString(s[n//2:])+self.reverseString(s[:n//2])",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n        def reverseString(self, s):\\n            \"\"\"\\n            :type s: str\\n            :rtype: str\\n            \"\"\"\\n            if len(s)<=1:\\n                return s\\n            n=len(s)\\n            return self.reverseString(s[n//2:])+self.reverseString(s[:n//2])",
                "codeTag": "Java"
            },
            {
                "id": 302693,
                "title": "c-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int start = 0, end = s.size() - 1;    \\n        \\n        revStr(s, start, end);\\n    }\\n    \\n    void revStr(vector<char>& s, int start, int end){\\n        \\n        if(start >= end) return;\\n        int temp = s[start];\\n        s[start] = s[end];\\n        s[end] = temp;\\n        \\n        revStr(s, start+1, end-1);\\n    }\\n    \\n    \\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int start = 0, end = s.size() - 1;    \\n        \\n        revStr(s, start, end);\\n    }\\n    \\n    void revStr(vector<char>& s, int start, int end){\\n        \\n        if(start >= end) return;\\n        int temp = s[start];\\n        s[start] = s[end];\\n        s[end] = temp;\\n        \\n        revStr(s, start+1, end-1);\\n    }\\n    \\n    \\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 81206,
                "title": "java-swapping-char-array",
                "content": "    public String reverseString(String s) {\\n            char[] c = s.toCharArray();\\n            for (int i=0,j=c.length-1;i<j;i++,j--){\\n                char temp = c[i];\\n                c[i]=c[j];\\n                c[j]=temp;\\n            }\\n            return new String(c);\\n        }",
                "solutionTags": [],
                "code": "    public String reverseString(String s) {\\n            char[] c = s.toCharArray();\\n            for (int i=0,j=c.length-1;i<j;i++,j--){\\n                char temp = c[i];\\n                c[i]=c[j];\\n                c[j]=temp;\\n            }\\n            return new String(c);\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 1902296,
                "title": "reverse-string-one-liner-python-solution",
                "content": "Write a function that reverses a string. The input string is given as an array of characters s.\\nYou must do this by modifying the input array in-place with O(1) extra memory.\\n\\nExample 1:\\n```\\nInput: s = [\"h\",\"e\",\"l\",\"l\",\"o\"]\\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\\n```\\n\\nExample 2:\\n\\n```\\nInput: s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]\\n```\\nConstraints:\\n1 <= s.length <= 105\\ns[i] is a printable ascii character.\\n\\n**Python Code**\\n\\n```\\nclass Solution:\\n    def reverseString(self, s):\\n        s.reverse()\\n```",
                "solutionTags": [],
                "code": "```\\nInput: s = [\"h\",\"e\",\"l\",\"l\",\"o\"]\\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\\n```\n```\\nInput: s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]\\n```\n```\\nclass Solution:\\n    def reverseString(self, s):\\n        s.reverse()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1901942,
                "title": "multiple-c-solutions-with-explanations",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistakes please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Here we\\u2019re using ***Extra Space*** which doesn\\'t satisfy the condition.\\n- We iterate the array elements from last and push it to the current vector.\\n- Then we\\u2019ll erase the first n elements from the vector and will get out the reverse string.\\n- **Time complexity:** O(n).\\n\\n### Solution 02\\n\\n- Here we\\u2019re using the ***Two Pointer Approach.***\\n- We\\u2019ll use the swap function which takes O(1) time complexity.\\n- Take 2 pointers to start & end, swap them and move the pointer.\\n- **Time complexity:** O(n).\\n\\n### Solution 03\\n\\n- Here we\\u2019re using ***STL function*** reverse which takes O(n) time complexity.\\n- **Time complexity:** O(n).\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    \\n    void reverseString(vector<char>& s) {\\n        int n= s.size();\\n        for(int i=n-1; i>=0; i--){\\n            s.push_back(s[i]);\\n        }\\n        s.erase(s.begin(), s.begin()+n);\\n        return;\\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int n = s.size();\\n        int low = 0, high = n-1;\\n        \\n        while(low <= high){\\n            swap(s[low], s[high]);\\n            low++; high--;\\n        }\\n        return;\\n    }\\n};\\n\\n//Solution 03:\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        reverse(s.begin(), s.end());\\n        return;\\n    }\\n};\\n```\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    \\n    void reverseString(vector<char>& s) {\\n        int n= s.size();\\n        for(int i=n-1; i>=0; i--){\\n            s.push_back(s[i]);\\n        }\\n        s.erase(s.begin(), s.begin()+n);\\n        return;\\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int n = s.size();\\n        int low = 0, high = n-1;\\n        \\n        while(low <= high){\\n            swap(s[low], s[high]);\\n            low++; high--;\\n        }\\n        return;\\n    }\\n};\\n\\n//Solution 03:\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        reverse(s.begin(), s.end());\\n        return;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1555808,
                "title": "java-tc-o-n-sc-o-1-simple-concise-3-diff-solutions-iterative-recursive",
                "content": "**Swap each character. Using XOR**\\n```java\\n/**\\n * Time Complexity: O(N/2) = O(N)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of input char array.\\n */\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        if (s == null || s.length <= 1) {\\n            return;\\n        }\\n\\n        int left = 0;\\n        int right = s.length - 1;\\n        while (left < right) {\\n            s[left] = (char) (s[left] ^ s[right]);\\n            s[right] = (char) (s[left] ^ s[right]);\\n            s[left] = (char) (s[left] ^ s[right]);\\n            left++;\\n            right--;\\n        }\\n    }\\n}\\n```\\n\\n---\\n**Swap each character. Using a temporay character**\\n\\n```java\\n/**\\n * Time Complexity: O(N/2) = O(N)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of input char array.\\n */\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        if (s == null || s.length <= 1) {\\n            return;\\n        }\\n\\n        int left = 0;\\n        int right = s.length - 1;\\n        while (left < right) {\\n            char c = s[left];\\n            s[left] = s[right];\\n            s[right] = c;\\n            left++;\\n            right--;\\n        }\\n    }\\n}\\n```\\n\\n---\\n**Recursive Solution**\\n```java\\n/**\\n * Recursive Solution\\n *\\n * Time Complexity: O(N/2) = O(N)\\n *\\n * Space Complexity: O(N/2) = O(N)\\n *\\n * N = Length of input char array.\\n */\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        if (s == null || s.length <= 1) {\\n            return;\\n        }\\n\\n        reverseStringHelper(s, 0, s.length - 1);\\n    }\\n\\n    private void reverseStringHelper(char[] s, int left, int right) {\\n        if (left >= right) {\\n            return;\\n        }\\n        s[left] = (char) (s[left] ^ s[right]);\\n        s[right] = (char) (s[left] ^ s[right]);\\n        s[left] = (char) (s[left] ^ s[right]);\\n        reverseStringHelper(s, left + 1, right - 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n/**\\n * Time Complexity: O(N/2) = O(N)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of input char array.\\n */\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        if (s == null || s.length <= 1) {\\n            return;\\n        }\\n\\n        int left = 0;\\n        int right = s.length - 1;\\n        while (left < right) {\\n            s[left] = (char) (s[left] ^ s[right]);\\n            s[right] = (char) (s[left] ^ s[right]);\\n            s[left] = (char) (s[left] ^ s[right]);\\n            left++;\\n            right--;\\n        }\\n    }\\n}\\n```\n```java\\n/**\\n * Time Complexity: O(N/2) = O(N)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of input char array.\\n */\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        if (s == null || s.length <= 1) {\\n            return;\\n        }\\n\\n        int left = 0;\\n        int right = s.length - 1;\\n        while (left < right) {\\n            char c = s[left];\\n            s[left] = s[right];\\n            s[right] = c;\\n            left++;\\n            right--;\\n        }\\n    }\\n}\\n```\n```java\\n/**\\n * Recursive Solution\\n *\\n * Time Complexity: O(N/2) = O(N)\\n *\\n * Space Complexity: O(N/2) = O(N)\\n *\\n * N = Length of input char array.\\n */\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        if (s == null || s.length <= 1) {\\n            return;\\n        }\\n\\n        reverseStringHelper(s, 0, s.length - 1);\\n    }\\n\\n    private void reverseStringHelper(char[] s, int left, int right) {\\n        if (left >= right) {\\n            return;\\n        }\\n        s[left] = (char) (s[left] ^ s[right]);\\n        s[right] = (char) (s[left] ^ s[right]);\\n        s[left] = (char) (s[left] ^ s[right]);\\n        reverseStringHelper(s, left + 1, right - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1524631,
                "title": "java-recursive-solution",
                "content": "```\\npublic void reverseString(char[] s) {\\n        solve(s, 0, s.length-1);  \\n    }\\n    \\n    public void solve(char[] s, int start, int end){\\n        if(start>=end)return; //base case\\n        swap(s, start, end);\\n        solve(s, ++start, --end);\\n    }\\n    \\n    public void swap(char[] s, int i, int j){\\n        char tmp = s[i];\\n        s[i] = s[j];\\n        s[j] = tmp;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\npublic void reverseString(char[] s) {\\n        solve(s, 0, s.length-1);  \\n    }\\n    \\n    public void solve(char[] s, int start, int end){\\n        if(start>=end)return; //base case\\n        swap(s, start, end);\\n        solve(s, ++start, --end);\\n    }\\n    \\n    public void swap(char[] s, int i, int j){\\n        char tmp = s[i];\\n        s[i] = s[j];\\n        s[j] = tmp;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 797426,
                "title": "c-single-pointer-recursive-vs-iterative-solutions-explained-100-time-70-space",
                "content": "I don\\'t really think this problem was ideal to teach recursion, but I guess it is still a worthy exercise to go both ways (recursive and iterative), so let\\'s give it a look.\\n\\nWe just need one pointer `pos` to progress (although with 2 you do a bit less computation), ideally starting from the left (easier) and then computing its specular equivalent as `s.size() - 1 - pos`; our base case is that `pos` has reached half the size of the string, in which case we exit. Otherwise, we keep swapping the values of our 2 chars.\\n\\nThe recursive version:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s, int pos = 0) {\\n        if (pos < s.size() / 2) {\\n            swap(s[pos], s[s.size() - 1 - pos]);\\n            reverseString(s, pos + 1);\\n        }\\n    }\\n};\\n```\\n\\nAnother alternative recursive version doing basically the same:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s, int pos = 0) {\\n        if (pos >= s.size() / 2) return;\\n        swap(s[pos], s[s.size() - 1 - pos]);\\n        reverseString(s, pos + 1);\\n    }\\n};\\n```\\n\\nThe translation of the problem to an iterative approach, which for once appears shorter, if you use the trick of declaring variables as parameters:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s, int pos = 0) {\\n        while (pos < s.size() / 2) swap(s[pos], s[s.size() - 1 - pos++]);\\n    }\\n};\\n```\\n\\nFinally, the real solution I would use outside of any interview context:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        reverse(begin(s), end(s));\\n    }\\n};\\n```\\n\\nBecause well tested, reliable and sturdy built-in are there to use for a reason!",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s, int pos = 0) {\\n        if (pos < s.size() / 2) {\\n            swap(s[pos], s[s.size() - 1 - pos]);\\n            reverseString(s, pos + 1);\\n        }\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s, int pos = 0) {\\n        if (pos >= s.size() / 2) return;\\n        swap(s[pos], s[s.size() - 1 - pos]);\\n        reverseString(s, pos + 1);\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s, int pos = 0) {\\n        while (pos < s.size() / 2) swap(s[pos], s[s.size() - 1 - pos++]);\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        reverse(begin(s), end(s));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 402685,
                "title": "javascript-es6",
                "content": "```\\nvar reverseString = function(s) {\\n    var i = 0;\\n    var j = s.length - 1;\\n    while (i < j) {\\n        [s[i], s[j]] = [s[j], s[i]];\\n        i++;\\n        j--;\\n    }\\n};\\n```\\nUsing destructuring assignment array matching available in ES6+ though not very effecient.",
                "solutionTags": [],
                "code": "```\\nvar reverseString = function(s) {\\n    var i = 0;\\n    var j = s.length - 1;\\n    while (i < j) {\\n        [s[i], s[j]] = [s[j], s[i]];\\n        i++;\\n        j--;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3222200,
                "title": "js-basic-two-pointers-decision-easy-to-read-and-understand",
                "content": "![photo_5456553622704865185_y.jpg](https://assets.leetcode.com/users/images/a8e77441-ef53-4ff7-bec1-818615746890_1677166190.006001.jpeg)\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {character[]} s\\n * @return {void} Do not return anything, modify s in-place instead.\\n */\\nvar reverseString = function(s) {\\n    let left = 0\\n    let right = s.length - 1\\n    while(left <= right) {\\n        let temp = s[left]\\n        s[left] = s[right]\\n        s[right] = temp\\n        left++\\n        right--\\n    }\\n\\n    return s\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {character[]} s\\n * @return {void} Do not return anything, modify s in-place instead.\\n */\\nvar reverseString = function(s) {\\n    let left = 0\\n    let right = s.length - 1\\n    while(left <= right) {\\n        let temp = s[left]\\n        s[left] = s[right]\\n        s[right] = temp\\n        left++\\n        right--\\n    }\\n\\n    return s\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2645839,
                "title": "python-faster-than-93-two-pointer",
                "content": "```\\n\"\"\"https://leetcode.com/problems/reverse-string/\"\"\"\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        l=0\\n        r=len(s)-1\\n        while l<r:\\n            s[l],s[r]=s[r],s[l]\\n            l+=1\\n            r-=1\\n        \\n# SUBMISSION REPORT:-\\n    # Runtime: 207 ms, faster than 93.06% of Python3 online submissions for Reverse String.\\n    # Memory Usage: 18.4 MB, less than 82.79% of Python3 online submissions for Reverse String.\\n    \\n# EXPLANATION:-\\n    # We will use two pointers, one from start and one from end\\n    # We will swap the chars and increment the left and decrement the right\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\n\"\"\"https://leetcode.com/problems/reverse-string/\"\"\"\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        l=0\\n        r=len(s)-1\\n        while l<r:\\n            s[l],s[r]=s[r],s[l]\\n            l+=1\\n            r-=1\\n        \\n# SUBMISSION REPORT:-\\n    # Runtime: 207 ms, faster than 93.06% of Python3 online submissions for Reverse String.\\n    # Memory Usage: 18.4 MB, less than 82.79% of Python3 online submissions for Reverse String.\\n    \\n# EXPLANATION:-\\n    # We will use two pointers, one from start and one from end\\n    # We will swap the chars and increment the left and decrement the right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1072607,
                "title": "javascript-two-pointer",
                "content": "var reverseString = function(s) {\\n   \\n    let pointer1 = 0;\\n    let pointer2 = s.length-1;\\n    \\n    while(pointer1<pointer2){\\n        \\n        let temp=s[pointer1];\\n        s[pointer1]=s[pointer2];\\n        s[pointer2]=temp;\\n        \\n        pointer1++;\\n        pointer2--;\\n    }\\n    \\n    return s;\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "var reverseString = function(s) {\\n   \\n    let pointer1 = 0;\\n    let pointer2 = s.length-1;\\n    \\n    while(pointer1<pointer2){\\n        \\n        let temp=s[pointer1];\\n        s[pointer1]=s[pointer2];\\n        s[pointer2]=temp;\\n        \\n        pointer1++;\\n        pointer2--;\\n    }\\n    \\n    return s;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 80981,
                "title": "three-ways-to-reverse-a-string-in-javascript",
                "content": "    var reverseString = function(s) {\\n       //solution 1 \\n       var reversedStr = \"\";\\n        var high = s.length - 1;\\n        var i;\\n        for(i = high; i >= 0; i--) {\\n            reversedStr += s.charAt(i);\\n        }\\n        return reversedStr;\\n        \\n        /*solution2 with built-in function\\n        return s.split('').reverse().join('');*/\\n        \\n        /*recursion with substr and charAt, will have runtime error\\n        return (s === '') ? '' : reverseString(s.substr(1)) + s.charAt(0);*/\\n    };",
                "solutionTags": [],
                "code": "    var reverseString = function(s) {\\n       //solution 1 \\n       var reversedStr = \"\";\\n        var high = s.length - 1;\\n        var i;\\n        for(i = high; i >= 0; i--) {\\n            reversedStr += s.charAt(i);\\n        }\\n        return reversedStr;\\n        \\n        /*solution2 with built-in function\\n        return s.split('').reverse().join('');*/\\n        \\n        /*recursion with substr and charAt, will have runtime error\\n        return (s === '') ? '' : reverseString(s.substr(1)) + s.charAt(0);*/\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 2722427,
                "title": "easy-c-code-beats-98-in-time",
                "content": "## My GitHub: https://github.com/crimsonKn1ght\\n\\n\\n``` C++ []\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int i=0, j=s.size()-1;\\n        while (i<j) {\\n            char tmp = s[i];\\n            s[i] = s[j];\\n            s[j] = tmp;\\n            i++, j--;\\n        }\\n    }\\n};\\n```\\n\\n*If this code helps, please upvote it, it encourages me to write more solutions*\\n",
                "solutionTags": [
                    "C++",
                    "Iterator"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int i=0, j=s.size()-1;\\n        while (i<j) {\\n            char tmp = s[i];\\n            s[i] = s[j];\\n            s[j] = tmp;\\n            i++, j--;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1617193,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        sLen = len(s)\\n        for i in range(sLen//2):\\n            #swap is awesome in python\\n            s[i], s[sLen-1-i] = s[sLen-1-i], s[i]",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        sLen = len(s)\\n        for i in range(sLen//2):\\n            #swap is awesome in python\\n            s[i], s[sLen-1-i] = s[sLen-1-i], s[i]",
                "codeTag": "Java"
            },
            {
                "id": 1480872,
                "title": "python-and-java-one-line-iterative-recursive-solutions",
                "content": "## PYTHON SOLUTIONS\\n##\\nOne line solution using python\\'s handy functions\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        s.reverse()\\n```\\n\\nIterative Approach\\n```\\nclass Solution:\\n\\tdef reverseString(self, s: List[str]) -> None:\\n\\t\\tN = len(s)\\n\\t\\tfor i in range(N // 2):\\n\\t\\t\\ts[i], s[-i-1] == s[-i-1], s[i]\\n```\\n\\nRecursive Approach\\n```\\nclass Solution:\\n    def reverse(self, l, r, s):\\n        if l >= r:\\n            return\\n        s[l], s[r] = s[r], s[l]\\n        self.reverse(l+1, r-1, s)\\n\\n    def reverseString(self, s: List[str]) -> None:\\n        self.reverse(0, len(s)-1, s)\\n```\\n\\n## JAVA SOLUTIONS\\n##\\n\\nIterative Approach\\n```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int N = s.length;\\n        for (int i = 0; i < N / 2; i++) {\\n            char temp = s[i];\\n            s[i] = s[N-i-1];\\n            s[N-i-1] = temp;\\n        }\\n    }\\n}\\n```\\n\\nRecursive Approach\\n```\\nclass Solution {\\n    public char[] reverse(int l, int r, char[] s) {\\n        if (l >= r) return s;\\n        char temp = s[l];\\n        s[l++] = s[r];\\n        s[r--] = temp;\\n        reverse(l, r, s);\\n        return null;\\n    }\\n\\n    public void reverseString(char[] s) {\\n        reverse(0, s.length-1, s);\\n    }\\n}\\n```\\n\\nPlease upvote for encouragement :)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        s.reverse()\\n```\n```\\nclass Solution:\\n\\tdef reverseString(self, s: List[str]) -> None:\\n\\t\\tN = len(s)\\n\\t\\tfor i in range(N // 2):\\n\\t\\t\\ts[i], s[-i-1] == s[-i-1], s[i]\\n```\n```\\nclass Solution:\\n    def reverse(self, l, r, s):\\n        if l >= r:\\n            return\\n        s[l], s[r] = s[r], s[l]\\n        self.reverse(l+1, r-1, s)\\n\\n    def reverseString(self, s: List[str]) -> None:\\n        self.reverse(0, len(s)-1, s)\\n```\n```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int N = s.length;\\n        for (int i = 0; i < N / 2; i++) {\\n            char temp = s[i];\\n            s[i] = s[N-i-1];\\n            s[N-i-1] = temp;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public char[] reverse(int l, int r, char[] s) {\\n        if (l >= r) return s;\\n        char temp = s[l];\\n        s[l++] = s[r];\\n        s[r--] = temp;\\n        reverse(l, r, s);\\n        return null;\\n    }\\n\\n    public void reverseString(char[] s) {\\n        reverse(0, s.length-1, s);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3077649,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n         int i = 0, j = s.size() - 1;\\n        while(i < j){\\n            swap(s[i++], s[j--]); \\n        }\\n        \\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n         int i = 0, j = s.size() - 1;\\n        while(i < j){\\n            swap(s[i++], s[j--]); \\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1902861,
                "title": "naive-approach-vs-hat-vs-array-reverse-with-benchmark-results",
                "content": "The easiest way is to use the built-in method `Reverse`:\\n```csharp\\npublic class Solution\\n{\\n    public void ReverseString(char[] s)\\n    {\\n        Array.Reverse(s);\\n    }\\n}\\n```\\nThe naive approach would to use one or two pointers and a `for` or a `while` loop. Please note that there is no need to introduce a temp variable for swapping values - use tuples instead. Here is an example:\\n```csharp\\npublic class Solution\\n{\\n    public void ReverseString(char[] s)\\n    {\\n        int len = s.Length;\\n        for (int i = 0; i < len / 2; i++)\\n        {\\n            (s[i], s[len - 1 - i]) = (s[len - 1 - i], s[i]);\\n        }\\n    }\\n}\\n```\\nReadability can be somewhat improved by using the hat operator `^`:\\n```csharp\\npublic class Solution\\n{\\n    public void ReverseString(char[] s)\\n    {\\n        for (int i = 1; i <= s.Length / 2; i++)\\n        {\\n            (s[i - 1], s[^i]) = (s[^i], s[i - 1]);\\n        }\\n    }\\n}\\n```\\n`^1` refers to the last element of an array, `^2` is the one before that, etc. More about the hat operator and ranges here: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-8.0/ranges\\n\\nBenchmark results on arrays of three different sizes. The built-in method is the fastest:\\n![image](https://assets.leetcode.com/users/images/5ff87d48-c4e4-40bc-b0b4-be3a3648f9a6_1648803525.3944693.png)\\n",
                "solutionTags": [
                    "C#"
                ],
                "code": "```csharp\\npublic class Solution\\n{\\n    public void ReverseString(char[] s)\\n    {\\n        Array.Reverse(s);\\n    }\\n}\\n```\n```csharp\\npublic class Solution\\n{\\n    public void ReverseString(char[] s)\\n    {\\n        int len = s.Length;\\n        for (int i = 0; i < len / 2; i++)\\n        {\\n            (s[i], s[len - 1 - i]) = (s[len - 1 - i], s[i]);\\n        }\\n    }\\n}\\n```\n```csharp\\npublic class Solution\\n{\\n    public void ReverseString(char[] s)\\n    {\\n        for (int i = 1; i <= s.Length / 2; i++)\\n        {\\n            (s[i - 1], s[^i]) = (s[^i], s[i - 1]);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1683132,
                "title": "0ms-java-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int start = 0, end = s.length - 1;\\n        while(start < end) {\\n            char temp = s[start];\\n            s[start++] = s[end];\\n            s[end--] = temp;\\n        }\\n    }\\n}\\n```\\n\\n**Approach : Swapping using two pointer**\\n\\nOne pointer is pointing **at the start of the string** while the other pointer is pointing at the **end of the string**. Both pointers will keep swapping its element and travel towards each other. The algorithm basically simulating rotation of a string with respect to its midpoint.\\n\\n**Complexity** :\\nTime Complexity - O(N)\\nSpace Complexity - O(1)\\n\\nPlease UPVOTE if you understand the solution\\nThank You \\uD83D\\uDE0A",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int start = 0, end = s.length - 1;\\n        while(start < end) {\\n            char temp = s[start];\\n            s[start++] = s[end];\\n            s[end--] = temp;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563138,
                "title": "python-one-line-3-simple-solutions",
                "content": "**Python :**\\n\\n**1:** Swap string elements to reverse \\n\\n```\\ndef reverseString(self, s: List[str]) -> None:\\n\\tfor i in range(len(s) // 2): s[i], s[len(s) - 1 - i] = s[len(s) - 1 - i], s[i]\\n```\\n\\n**2:** Using slice\\n\\n```\\ndef reverseString(self, s: List[str]) -> None:\\n\\ts[:] = s[::-1]\\n```\\n\\n**3:** Using built in string **reverse** method\\n\\n```\\ndef reverseString(self, s: List[str]) -> None:\\n\\ts.reverse()\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef reverseString(self, s: List[str]) -> None:\\n\\tfor i in range(len(s) // 2): s[i], s[len(s) - 1 - i] = s[len(s) - 1 - i], s[i]\\n```\n```\\ndef reverseString(self, s: List[str]) -> None:\\n\\ts[:] = s[::-1]\\n```\n```\\ndef reverseString(self, s: List[str]) -> None:\\n\\ts.reverse()\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 946287,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        for i in range(len(s)//2):\\n            s[i],s[-i-1]=s[-i-1],s[i]\\n        return s\\n```\\n\\nI\\'m traversing till half of the string\\nand swapping first ith letter with last but ith letter\\n\\ns[-1] refers the last character\\ns[-2] refers the last but ith character",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        for i in range(len(s)//2):\\n            s[i],s[-i-1]=s[-i-1],s[i]\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3574765,
                "title": "easiest-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int i=0,j=s.size()-1;\\n        while(i<j)\\n            swap(s[i++],s[j--]);\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int i=0,j=s.size()-1;\\n        while(i<j)\\n            swap(s[i++],s[j--]);\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1923001,
                "title": "344-easy-python-reverse-string",
                "content": "**Using Recursion**\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        i=0\\n        j=len(s)-1\\n        def rev(s,i,j):\\n            if i>=j:\\n                return\\n            s[i],s[j]=s[j],s[i]\\n            rev(s,i+1,j-1)\\n        rev(s,i,j)\\n```\\n\\n**Using Iteration**\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n       \\n        size = len(s)\\n        for i in range(size//2):\\n            s[i], s[-i-1] = s[-i-1], s[i]\\n```\\n**Two Pointer**\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        i,j=0,len(s)-1\\n        while i<j:\\n            s[i],s[j]=s[j],s[i]\\n            i+=1\\n            j-=1\\n```\\n**Using Python**\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        s[:]=s[::-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        i=0\\n        j=len(s)-1\\n        def rev(s,i,j):\\n            if i>=j:\\n                return\\n            s[i],s[j]=s[j],s[i]\\n            rev(s,i+1,j-1)\\n        rev(s,i,j)\\n```\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n       \\n        size = len(s)\\n        for i in range(size//2):\\n            s[i], s[-i-1] = s[-i-1], s[i]\\n```\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        i,j=0,len(s)-1\\n        while i<j:\\n            s[i],s[j]=s[j],s[i]\\n            i+=1\\n            j-=1\\n```\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        s[:]=s[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 699961,
                "title": "python-seems-easy-when-coming-from-c",
                "content": "simple swapping operation\\n```\\ndef reverseString(self, s: List[str]) -> None:\\n        n = len(s)\\n        i , j = 0 , n-1\\n        \\n        while i<j:\\n            s[i] = ord(s[i])     # converting from char to int this is not necessary in cpp though\\n            s[j] = ord(s[j])\\n            \\n            s[i]^=s[j]           # swapping operation inplace\\n            s[j]^=s[i]\\n            s[i]^=s[j]\\n            \\n\\t\\t\\ts[i] = chr(s[i])     # converting back to char\\n            s[j] = chr(s[j])\\n            \\n            i+=1                   # updating pointers\\n            j-=1\\n```\\nsame code is cpp is much looks much more elegant\\n```\\nvoid reverseString(vector<char>& s) {\\n        \\n        int i=0 , j=s.size()-1;\\n        while (i<j)\\n            swap(s[i++] , s[j--]);       \\n    }\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\ndef reverseString(self, s: List[str]) -> None:\\n        n = len(s)\\n        i , j = 0 , n-1\\n        \\n        while i<j:\\n            s[i] = ord(s[i])     # converting from char to int this is not necessary in cpp though\\n            s[j] = ord(s[j])\\n            \\n            s[i]^=s[j]           # swapping operation inplace\\n            s[j]^=s[i]\\n            s[i]^=s[j]\\n            \\n\\t\\t\\ts[i] = chr(s[i])     # converting back to char\\n            s[j] = chr(s[j])\\n            \\n            i+=1                   # updating pointers\\n            j-=1\\n```\n```\\nvoid reverseString(vector<char>& s) {\\n        \\n        int i=0 , j=s.size()-1;\\n        while (i<j)\\n            swap(s[i++] , s[j--]);       \\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 305439,
                "title": "javascript-recursion",
                "content": "```\\nvar reverseString = function(s) {\\n    if (s.length == 0) {\\n        return;\\n    }\\n    var temp = s[0];\\n    s.shift();\\n    reverseString(s);\\n    s.push(temp);\\n};\\n```\\n\\nFirst Attemp",
                "solutionTags": [],
                "code": "```\\nvar reverseString = function(s) {\\n    if (s.length == 0) {\\n        return;\\n    }\\n    var temp = s[0];\\n    s.shift();\\n    reverseString(s);\\n    s.push(temp);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 258497,
                "title": "javascript",
                "content": "```\\nvar reverseString = function(s) {\\n    for (let i=0, j=s.length-1; i<j; i++, j--) {\\n        const x = s[i]; const y = s[j];\\n        s[i] = y; s[j] = x;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar reverseString = function(s) {\\n    for (let i=0, j=s.length-1; i<j; i++, j--) {\\n        const x = s[i]; const y = s[j];\\n        s[i] = y; s[j] = x;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 231834,
                "title": "kotlin-solution",
                "content": "```\\nclass Solution {\\n    fun reverseString(s: CharArray): Unit {\\n        var start = 0\\n        var end = s.lastIndex\\n        while (start < end){\\n            s[start] = s[end].also { s[end] = s[start] }\\n            start++\\n            end--\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun reverseString(s: CharArray): Unit {\\n        var start = 0\\n        var end = s.lastIndex\\n        while (start < end){\\n            s[start] = s[end].also { s[end] = s[start] }\\n            start++\\n            end--\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2759308,
                "title": "java-recursive-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        recursiveArray(s.length - 1, s);\\n    }\\n    \\n    void recursiveArray(int index, char[] s) {\\n        if (index < s.length / 2) {\\n            return;\\n        }\\n\\n        char temp = s[index];\\n        s[index] = s[s.length - index - 1];\\n        s[s.length - index - 1] = temp;\\n\\n        recursiveArray(index - 1, s);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        recursiveArray(s.length - 1, s);\\n    }\\n    \\n    void recursiveArray(int index, char[] s) {\\n        if (index < s.length / 2) {\\n            return;\\n        }\\n\\n        char temp = s[index];\\n        s[index] = s[s.length - index - 1];\\n        s[s.length - index - 1] = temp;\\n\\n        recursiveArray(index - 1, s);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2334448,
                "title": "two-pointer-java-simple-solution",
                "content": "My simple solution, inspired from binary search\\'s some part\\n\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int n = s.length;\\n        int low=0;\\n        int high=n-1;\\n\\t\\t\\n        while(low < high) {\\n            char ch = s[low];\\n            s[low] = s[high];\\n            s[high] = ch;\\n            \\n            low++;\\n            high--;\\n        }\\n        //System.out.println(Arrays.toString(s));\\n    }\\n}\\n\\n**Complexity Analysis**\\n\\n**Time Complexity:**  O(n)  where n is the total number character in the input string. The algorithm need to reverse the whole string.\\n\\n**Auxiliary Space:** O(1) or constant space is used. As you can see we are not using any extra space to reverse the elements.\\n\\nHope it help. Please **upvote** it and inspire me",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n    public void reverseString(char[] s) {\\n        int n = s.length;\\n        int low=0;\\n        int high=n-1;\\n\\t\\t\\n        while(low < high) {\\n            char ch = s[low];\\n            s[low] = s[high];\\n            s[high] = ch;\\n            \\n            low++;\\n            high--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1901760,
                "title": "2-approaches-two-pointers-and-recursion",
                "content": "[Leetcode](https://leetcode.com/) [344. Reverse String](https://leetcode.com/problems/reverse-string).\\n\\n***By Frank Luo***\\n\\nHere shows **2** Approaches to slove this problem, **Two Pointers** and **Recursion**.\\n\\n\\n# Two Pointers\\n\\nThe first mind come to my mind is **Two Pointers**.\\n\\nWe need $N/2$ swaps, which $N$ is the length of string $s$. \\n\\n```java\\n    public void reverseString(char[] s) {\\n        if (s == null || s.length <= 1) {\\n            return;\\n        }\\n        \\n        int left = 0;\\n        int right = s.length - 1;\\n        while (left < right) {\\n            char ch = s[left];\\n            s[left] = s[right];\\n            s[right] = ch;\\n            left++;\\n            right--;\\n        }\\n    }\\n```\\n\\nor use **For** Loop:\\n\\n```java\\n    // Two Pointers Opt O(n) O(1)\\n    public static void reverseString_tp_opt(char[] s) {\\n        if (s == null || s.length <= 1) {\\n            return;\\n        }\\n\\n        int n = s.length;\\n        for (int left = 0, right = n - 1; left < right; ++left, --right) {\\n            char tmp = s[left];\\n            s[left] = s[right];\\n            s[right] = tmp;\\n        }\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(n)$\\n- **Space Complexity**: $O(1)$\\n\\n\\n# Recursion\\n \\nRecursion solution is also easy.\\n\\n```java\\npublic void reverseString(char[] s) {\\n        if (s == null || s.length <= 1) {\\n            return;\\n        }\\n        \\n        reverse(s, 0, s.length - 1);\\n }\\n    \\n    public void reverse(char[] str, int begin, int end) {\\n        if (begin >= end) {\\n            return;\\n        }\\n        char ch = str[begin];\\n        str[begin] = str[end];\\n        str[end] = ch;\\n        reverse(str, begin + 1, end - 1);\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(n)$.\\n- **Space Complexity**: $O(n/2)$.\\n\\n\\n------------\\n\\nAll suggestions are welcome. \\nIf you have any query or suggestion please comment below.\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)\\n\\nExplore More [Leetcode Solutions](https://leetcode.com/discuss/general-discussion/1868912/My-Leetcode-Solutions-All-In-One). \\uD83D\\uDE09\\uD83D\\uDE03\\uD83D\\uDC97\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Two Pointers",
                    "String",
                    "Recursion"
                ],
                "code": "```java\\n    public void reverseString(char[] s) {\\n        if (s == null || s.length <= 1) {\\n            return;\\n        }\\n        \\n        int left = 0;\\n        int right = s.length - 1;\\n        while (left < right) {\\n            char ch = s[left];\\n            s[left] = s[right];\\n            s[right] = ch;\\n            left++;\\n            right--;\\n        }\\n    }\\n```\n```java\\n    // Two Pointers Opt O(n) O(1)\\n    public static void reverseString_tp_opt(char[] s) {\\n        if (s == null || s.length <= 1) {\\n            return;\\n        }\\n\\n        int n = s.length;\\n        for (int left = 0, right = n - 1; left < right; ++left, --right) {\\n            char tmp = s[left];\\n            s[left] = s[right];\\n            s[right] = tmp;\\n        }\\n    }\\n```\n```java\\npublic void reverseString(char[] s) {\\n        if (s == null || s.length <= 1) {\\n            return;\\n        }\\n        \\n        reverse(s, 0, s.length - 1);\\n }\\n    \\n    public void reverse(char[] str, int begin, int end) {\\n        if (begin >= end) {\\n            return;\\n        }\\n        char ch = str[begin];\\n        str[begin] = str[end];\\n        str[end] = ch;\\n        reverse(str, begin + 1, end - 1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 785740,
                "title": "c-simplest-recursion",
                "content": "```\\nvoid reverseString(char* s, int sSize){\\n    char* ptr = s+sSize-1;\\n    if (sSize <= 1)\\n        return;\\n    char tmp = *s;\\n    *s = *(ptr);\\n    *(ptr) = tmp;\\n    reverseString(s+1, sSize-2);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid reverseString(char* s, int sSize){\\n    char* ptr = s+sSize-1;\\n    if (sSize <= 1)\\n        return;\\n    char tmp = *s;\\n    *s = *(ptr);\\n    *(ptr) = tmp;\\n    reverseString(s+1, sSize-2);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 262269,
                "title": "elegant-ruby-iterative-solution-two-pointers-2-lines-of-code",
                "content": "That\\'s what I call \"Ruby-way\" ;-)\\n\\n```ruby\\ndef reverse_string(s)\\n  return nil if s.empty?\\n\\n  (s.length / 2).times { |i| s[i], s[~i] = s[~i], s[i] }\\nend\\n```\\n\\nOld one:\\n```ruby\\ndef reverse_string(s)\\n    first, last = -1, s.length\\n    s[first], s[last] = s[last], s[first] until (first += 1) > (last -= 1)\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef reverse_string(s)\\n  return nil if s.empty?\\n\\n  (s.length / 2).times { |i| s[i], s[~i] = s[~i], s[i] }\\nend\\n```\n```ruby\\ndef reverse_string(s)\\n    first, last = -1, s.length\\n    s[first], s[last] = s[last], s[first] until (first += 1) > (last -= 1)\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 166869,
                "title": "python-solutions",
                "content": "```\\nclass Solution(object):\\n    \"\"\"Reverse String class.\"\"\"\\n    def reverse_string_by_position(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        return s[::-1]\\n\\n    def reverse_string_recursive(self, s):\\n    \\t\\'\\'\\'\\n        Reverse a string recursively\\n\\n        :param s: A string\\n        :type s: str\\n        :rtype: str\\n        \\'\\'\\'\\n        if len(s) < 1:\\n            return s\\n        return s[-1] + self.reverse_string_recursive(s[:-1])\\n\\n    def reverse_string_iteratively(self, s):\\n    \\t\"\"\"\\n        Reverse a string recursively\\n\\n        :param s: A string\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        length = len(s)\\n        result = list(s)\\n        for i in range(length / 2):\\n            result[length - 1], result[i] = s[length - 1], s[i]\\n            length -= 1\\n        return \\'\\'.join(result)\\n\\n    def reverse_string_using_built_in_method(self, s):\\n    \\t\"\"\"\\n        Reverse a string using built in method\\n\\n        :param s: A string\\n        :type s: str\\n        :rype: str\\n        \"\"\"\\n        return \\'\\'.join(reversed(s))\\n```\\n\\nPlease feel free to comment, give advice, etc",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    \"\"\"Reverse String class.\"\"\"\\n    def reverse_string_by_position(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        return s[::-1]\\n\\n    def reverse_string_recursive(self, s):\\n    \\t\\'\\'\\'\\n        Reverse a string recursively\\n\\n        :param s: A string\\n        :type s: str\\n        :rtype: str\\n        \\'\\'\\'\\n        if len(s) < 1:\\n            return s\\n        return s[-1] + self.reverse_string_recursive(s[:-1])\\n\\n    def reverse_string_iteratively(self, s):\\n    \\t\"\"\"\\n        Reverse a string recursively\\n\\n        :param s: A string\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        length = len(s)\\n        result = list(s)\\n        for i in range(length / 2):\\n            result[length - 1], result[i] = s[length - 1], s[i]\\n            length -= 1\\n        return \\'\\'.join(result)\\n\\n    def reverse_string_using_built_in_method(self, s):\\n    \\t\"\"\"\\n        Reverse a string using built in method\\n\\n        :param s: A string\\n        :type s: str\\n        :rype: str\\n        \"\"\"\\n        return \\'\\'.join(reversed(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 81074,
                "title": "2ms-java-solution",
                "content": "    public class Solution {\\n        public String reverseString(String s) {\\n            if(s == null) return null;\\n            if(s.equals(\"\")) return s;\\n            char[] arrChar = s.toCharArray();\\n            for (int i = 0, j = arrChar.length-1; i <= j; i++, j--) {\\n                char temp = arrChar[i];\\n                arrChar[i] = arrChar[j];\\n                arrChar[j] = temp;\\n            }\\n            return new String(arrChar);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public String reverseString(String s) {\\n            if(s == null) return null;\\n            if(s.equals(\"\")) return s;\\n            char[] arrChar = s.toCharArray();\\n            for (int i = 0, j = arrChar.length-1; i <= j; i++, j--) {\\n                char temp = arrChar[i];\\n                arrChar[i] = arrChar[j];\\n                arrChar[j] = temp;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 80945,
                "title": "one-line-c-code-with-help-of-stl",
                "content": "   \\n \"Cheating\" method by calling proper iterator & constructor.\\n\\n    class Solution {\\n        public:\\n            string reverseString(string s) {\\n                return string(s.rbegin(), s.rend());\\n            }\\n        };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n        public:\\n            string reverseString(string s) {\\n                return string(s.rbegin(), s.rend());\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3350770,
                "title": "what-if-the-interviewer-request-to-solve-this-solution-using-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSwapping the characters in the array is a recurive operation here\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a recursive function using two pointers\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        //Two Pointers were used here\\n        int startPointer = 0; \\n        int endPointer = s.length-1;\\n\\n        //Since swapping is a recursive operation we can use recursion technique\\n        solve(startPointer, endPointer, s);\\n\\n    }\\n    public void solve(int startPointer, int endPointer, char[] s){\\n        if(startPointer > endPointer) return; //Base condition\\n\\n            char temp = s[startPointer];\\n            s[startPointer] = s[endPointer];\\n            s[endPointer] = temp;\\n            \\n        solve(++startPointer, --endPointer, s);\\n    }\\n}\\n```\\n![please-upvote-and.jpeg](https://assets.leetcode.com/users/images/b08a9414-0482-430a-a0c1-5cdfde050c0f_1679992511.6273758.jpeg)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        //Two Pointers were used here\\n        int startPointer = 0; \\n        int endPointer = s.length-1;\\n\\n        //Since swapping is a recursive operation we can use recursion technique\\n        solve(startPointer, endPointer, s);\\n\\n    }\\n    public void solve(int startPointer, int endPointer, char[] s){\\n        if(startPointer > endPointer) return; //Base condition\\n\\n            char temp = s[startPointer];\\n            s[startPointer] = s[endPointer];\\n            s[endPointer] = temp;\\n            \\n        solve(++startPointer, --endPointer, s);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2996835,
                "title": "two-pointers-easy-c-solution-3-lines",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n  Here, we are using two pointers for starting and ending index of the string and we swap them until we are at the middle of the string or we can say left poiner is less than right pointer.\\n# Complexity\\n- Time complexity : $$O(N) $$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$ O(1) $$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int left = 0, right = s.size()-1;\\n        while(left<right)\\n        {\\n            swap(s[left++],s[right--]);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int left = 0, right = s.size()-1;\\n        while(left<right)\\n        {\\n            swap(s[left++],s[right--]);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2192244,
                "title": "c-two-approach-easy-to-understand",
                "content": "#### **Approach 1: Using recursion**\\n\\nclass Solution {\\npublic:\\n\\t\\n    int idx = 0; // idx points to start of the vector and incremented at each function call.\\n    \\n    void rev(int n, vector<char>& s){\\n        if(idx == s.size()/2) return; // Recursion till half of the vector to swap.\\n        swap(s[idx++], s[n]);\\n        rev(--n, s);\\n    }\\n    \\n    void reverseString(vector<char>& s) {\\n        if(s.size() == 1) return;\\n        else rev(s.size()-1, s);  //Passing the last index as parameter to swap.\\n    }\\n};\\n\\n#### **Approach 2: Two pointers**\\n\\nclass Solution {\\npublic:\\n\\n    void reverseString(vector<char>& s) {\\n        int l = 0, r = s.size()-1;\\n        while(l < r) swap(s[l++] , s[r--]);\\n    }\\n};\\n\\nNote: For better understanding, prefer dry running yourself.\\nPLEASE UPVOTE IF HELPFUL!!",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n\\t\\n    int idx = 0; // idx points to start of the vector and incremented at each function call.\\n    \\n    void rev(int n, vector<char>& s){\\n        if(idx == s.size()/2) return; // Recursion till half of the vector to swap.\\n        swap(s[idx++], s[n]);\\n        rev(--n, s);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1902443,
                "title": "python-easy-solutions-one-liner",
                "content": "**Solution 1:** two pointers iterative\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        lo, hi = 0, len(s) - 1\\n        while lo < hi:\\n            s[lo], s[hi] = s[hi], s[lo]\\n            lo += 1\\n            hi -= 1\\n```\\n***\\n``` Space Complexity: O(1)```\\n***\\n\\n**Solution 2:** two pointers recursive\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        def reverse(lo,hi):\\n            if lo > hi: return\\n            s[lo], s[hi] = s[hi], s[lo]\\n            reverse(lo+1, hi-1)\\n        reverse(0, len(s)-1)\\n```\\n***\\n``` Space Complexity: O(N)```\\n***\\n\\n**Solution 3:**  One Liner\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        for i in range(1,len(s) // 2 + 1): s[i-1], s[-i] = s[-i], s[i-1]\\n```\\n***\\n``` Space Complexity: O(1)```\\n***",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        lo, hi = 0, len(s) - 1\\n        while lo < hi:\\n            s[lo], s[hi] = s[hi], s[lo]\\n            lo += 1\\n            hi -= 1\\n```\n``` Space Complexity: O(1)```\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        def reverse(lo,hi):\\n            if lo > hi: return\\n            s[lo], s[hi] = s[hi], s[lo]\\n            reverse(lo+1, hi-1)\\n        reverse(0, len(s)-1)\\n```\n``` Space Complexity: O(N)```\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        for i in range(1,len(s) // 2 + 1): s[i-1], s[-i] = s[-i], s[i-1]\\n```\n``` Space Complexity: O(1)```",
                "codeTag": "Java"
            },
            {
                "id": 1902370,
                "title": "c-intuitive-easy-to-understand-tc-o-n-sc-o-1",
                "content": "#### *Upvote if it helps\\u2B06\\uFE0F*\\n```\\n\\tvoid reverseString(vector<char>& s) {\\n        int l=0,r=s.size()-1;\\n        char temp;\\n        while(l<r){\\n            temp=s[l];\\n            s[l]=s[r];\\n            s[r]=temp;\\n            l++,r--;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n\\tvoid reverseString(vector<char>& s) {\\n        int l=0,r=s.size()-1;\\n        char temp;\\n        while(l<r){\\n            temp=s[l];\\n            s[l]=s[r];\\n            s[r]=temp;\\n            l++,r--;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1765698,
                "title": "c-efficient-algo-2-lines-easy-solutions",
                "content": "##### If you understand the approach please please upvote!!!\\uD83D\\uDC4D\\n***Thanks :)***\\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int n=s.size();\\n        \\n        for(int i=0;i<n/2;i++){\\n            swap(s[i],s[n-1-i]);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int n=s.size();\\n        \\n        for(int i=0;i<n/2;i++){\\n            swap(s[i],s[n-1-i]);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1673247,
                "title": "c-o-n-easy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int st=0;\\n        int e=s.size()-1;\\n        \\n        while(st<e)\\n            swap(s[st++],s[e--]);\\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int st=0;\\n        int e=s.size()-1;\\n        \\n        while(st<e)\\n            swap(s[st++],s[e--]);\\n        \\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 497258,
                "title": "simple-rust-solutions-recursive-and-iterator",
                "content": "1. Recursive\\n```\\nimpl Solution {\\n    fn swap(s: &mut Vec<char>, beg: usize, end: usize) {\\n        if beg >= end { return; }\\n\\n        s.swap(beg, end);\\n\\n        Solution::swap(s, beg + 1, end - 1);\\n    }\\n\\n    pub fn reverse_string(s: &mut Vec<char>) {\\n        match s.len() {\\n            0 => (),\\n            l => Solution::swap(s, 0, l - 1),\\n        };\\n    }\\n}\\n```\\n\\n2. Using iterator\\n```\\nimpl Solution {\\n    pub fn reverse_string(s: &mut Vec<char>) {\\n        match s.len() {\\n            0 => (),\\n            size => {\\n                (0..(size / 2)).into_iter().for_each(|beg| {\\n                    let end = size - 1 - beg;\\n\\n                    s.swap(beg, end);\\n                });\\n            }\\n        };\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    fn swap(s: &mut Vec<char>, beg: usize, end: usize) {\\n        if beg >= end { return; }\\n\\n        s.swap(beg, end);\\n\\n        Solution::swap(s, beg + 1, end - 1);\\n    }\\n\\n    pub fn reverse_string(s: &mut Vec<char>) {\\n        match s.len() {\\n            0 => (),\\n            l => Solution::swap(s, 0, l - 1),\\n        };\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn reverse_string(s: &mut Vec<char>) {\\n        match s.len() {\\n            0 => (),\\n            size => {\\n                (0..(size / 2)).into_iter().for_each(|beg| {\\n                    let end = size - 1 - beg;\\n\\n                    s.swap(beg, end);\\n                });\\n            }\\n        };\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 458692,
                "title": "c",
                "content": "```\\npublic void ReverseString(char[] s) {\\n\\tvar n = s.Length;\\n\\n\\tfor (var i = 0; i < n / 2; i++) {\\n\\t\\tvar temp = s[i];\\n\\t\\ts[i] = s[n - i - 1];\\n\\t\\ts[n - i - 1] = temp;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic void ReverseString(char[] s) {\\n\\tvar n = s.Length;\\n\\n\\tfor (var i = 0; i < n / 2; i++) {\\n\\t\\tvar temp = s[i];\\n\\t\\ts[i] = s[n - i - 1];\\n\\t\\ts[n - i - 1] = temp;\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 377460,
                "title": "c-in-place-recursive",
                "content": "```\\nclass Solution {\\nprivate:\\n    void reverseHelper(vector<char>& s, int i, int j) {\\n        if (i >= j)\\n            return;\\n        char temp = s[i];\\n        s[i] = s[j];\\n        s[j] = temp;\\n        reverseHelper(s, i+1, j-1);\\n    }\\n    \\npublic:\\n    void reverseString(vector<char>& s) {\\n        reverseHelper(s, 0, s.size() - 1);\\n    }\\n};\\n```\\nWell, this can be done in a simple loop. Since this problem appears in the chapter of Recursion, I just modify a bit in a recursive way.",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void reverseHelper(vector<char>& s, int i, int j) {\\n        if (i >= j)\\n            return;\\n        char temp = s[i];\\n        s[i] = s[j];\\n        s[j] = temp;\\n        reverseHelper(s, i+1, j-1);\\n    }\\n    \\npublic:\\n    void reverseString(vector<char>& s) {\\n        reverseHelper(s, 0, s.size() - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 275569,
                "title": "javascript",
                "content": "```\\nvar reverseString = function(s) {\\n\\n  for (let leftIndex = 0, rightIndex = s.length - 1; leftIndex < rightIndex; leftIndex++, rightIndex--) {\\n    let temp = s[leftIndex];\\n    s[leftIndex] = s[rightIndex];\\n    s[rightIndex] = temp;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar reverseString = function(s) {\\n\\n  for (let leftIndex = 0, rightIndex = s.length - 1; leftIndex < rightIndex; leftIndex++, rightIndex--) {\\n    let temp = s[leftIndex];\\n    s[leftIndex] = s[rightIndex];\\n    s[rightIndex] = temp;\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 254110,
                "title": "swift-4-2-solution",
                "content": "```\\nclass Solution {\\n    func reverseString(_ s: inout [Character]) {\\n        var first = 0\\n        var last = s.count - 1\\n        \\n        while first < last {\\n            (s[first], s[last]) = (s[last], s[first])\\n            first += 1\\n            last -= 1\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func reverseString(_ s: inout [Character]) {\\n        var first = 0\\n        var last = s.count - 1\\n        \\n        while first < last {\\n            (s[first], s[last]) = (s[last], s[first])\\n            first += 1\\n            last -= 1\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 81200,
                "title": "java-solution-using-stringbuilder-s-reverse-function",
                "content": "    public String reverseString(String s) {\\n        return new StringBuilder(s).reverse().toString();\\n    }",
                "solutionTags": [],
                "code": "    public String reverseString(String s) {\\n        return new StringBuilder(s).reverse().toString();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3975766,
                "title": "reverse-string-java-solution-super-easy-approach",
                "content": "# for detailed explaination and for your better understanding , you can watch this video :-\\nhttps://youtu.be/OKrM-UoOqkw?si=hAQwmLsxtPzD7wEz\\n\\n# Code\\n```\\nclass Solution {\\n    public void reverseString(char[] s) \\n    {\\n        int start = 0 ;\\n        int end = s.length -1 ;\\n\\n        while(start < end)\\n        {\\n            char temp = s[start];\\n            s[start] = s[end];\\n            s[end] = temp ;\\n\\n            start++ ;\\n            end-- ;\\n        }  \\n    }\\n}\\n```\\n# If you found my solution helpful, I would greatly appreciate your upvote, as it would motivate me to continue sharing more solutions.\\n# wish you the best  !",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public void reverseString(char[] s) \\n    {\\n        int start = 0 ;\\n        int end = s.length -1 ;\\n\\n        while(start < end)\\n        {\\n            char temp = s[start];\\n            s[start] = s[end];\\n            s[end] = temp ;\\n\\n            start++ ;\\n            end-- ;\\n        }  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3781112,
                "title": "easy-java-solution-using-two-pointer-runtime-0ms-sc-o-1",
                "content": "# Intuition\\nSwap the value between s[i] and s[j] until s.length/2\\n\\n# Code\\n```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        for(int i=0, j = s.length - 1; i< s.length/2; i++, j--){\\n            char tmp = s[i];\\n            s[i] = s[j];\\n            s[j] = tmp;\\n        }\\n    }\\n}\\n```\\n\\n# Time Complexity : O(n)\\nIn the reverseString method, the loop iterates until i reaches s.length/2, which means it only needs to iterate through half of the array. Therefore, the number of iterations is proportional to N/2, which can be simplified to N.\\n\\nInside the loop, there are constant time operations swapping two characters in the array. These operations take a constant amount of time, regardless of the size of the input.\\n\\nThus, the overall time complexity of the code is O(N).\\n\\n# Space Complexity : O(1)\\nThe space complexity is determined by the amount of additional space used by an algorithm, apart from the input itself. In this case, the code only uses a constant amount of extra space for the tmp variable to temporarily store a character during the swap operation. The space used for this variable does not depend on the size of the input array s.\\n\\nTherefore, regardless of the size of the input array, the code always requires the same amount of additional space, leading to a constant space complexity of O(1).\\n\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        for(int i=0, j = s.length - 1; i< s.length/2; i++, j--){\\n            char tmp = s[i];\\n            s[i] = s[j];\\n            s[j] = tmp;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3537373,
                "title": "java-simple-solution-with-o-1-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst, I tried to solve this problem using a **\\'for\\'** loop, which made the code **shorter** but a little **difficult to understand**. \\n\\nIt is important for a solution to take only constant space, which is **O(1)**. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nIn this approach, I am declaring two variables, **\\'left\\'** and **\\'right\\'**, to keep track of the starting and ending indices. These indices change every time at the end of the **\\'while\\'** loop.\\n\\n# Complexity\\n- **Time complexity:**\\n\\nThe **time complexity** of this function is **O(n)**, where n is the length of the input string s. The function iterates over the string in a while loop, swapping characters from the **left and right** ends until the left pointer surpasses the right pointer. \\n\\nSince each iteration swaps two characters, the number of iterations required to reverse the string is approximately **n/2**, which gives us **a linear time complexity**.\\n\\n\\n- **Space complexity:**\\n\\nThe **space complexity** of this function is **O(1)**, constant space. The function does not use any additional data structures that grow with the input size. \\n\\nInstead, it performs the character swaps in-place, modifying the input string directly. Therefore, the space required remains **constant** regardless of the size of the input string.\\n\\n# Code\\n```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int right = s.length-1;\\n        int left = 0;\\n\\n        while(left < right){\\n            char c = s[right];\\n            s[right] = s[left];\\n            s[left] = c;\\n\\n            left++;\\n            right--;\\n        }\\n    }\\n}\\n```\\n\\n# **Do you like it? Upvote then..!**\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int right = s.length-1;\\n        int left = 0;\\n\\n        while(left < right){\\n            char c = s[right];\\n            s[right] = s[left];\\n            s[left] = c;\\n\\n            left++;\\n            right--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3488277,
                "title": "344-reverse-string-solution",
                "content": "````\\ncode\\n\\n---\\n\\n- ````# Intuition\\n\\n---\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n```javascript []\\n```\\nconsole.log(\\'Hello world!\\')\\n```\\n```\\n```python []\\nprint(\\'Hello world!\\')\\n```\\n```ruby []\\nputs \\'Hello world!\\'\\n```\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def reverseString(self, s: List[str]) -> None:\\n    l = 0\\n    r = len(s) - 1\\n\\n    while l < r:\\n      s[l], s[r] = s[r], s[l]\\n      l += 1\\n      r -= 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "````\\ncode\\n\\n---\\n\\n- ```\n```javascript []\\n```\n```\\n```\n```python []\\nprint(\\'Hello world!\\')\\n```\n```ruby []\\nputs \\'Hello world!\\'\\n```\n```\\nclass Solution:\\n  def reverseString(self, s: List[str]) -> None:\\n    l = 0\\n    r = len(s) - 1\\n\\n    while l < r:\\n      s[l], s[r] = s[r], s[l]\\n      l += 1\\n      r -= 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3438368,
                "title": "86-beats-two-pointer-approach-c",
                "content": "![Screenshot (625).png](https://assets.leetcode.com/users/images/952ae49a-eaec-4b94-850d-002a60a8d33a_1682002782.8422697.png)\\n\\n# Approach\\nhere i don\\'t use swap function so if we don\\'t use swap function then we use this temp variable technique \\n# Code\\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int n=s.size(),temp;\\n        int start=0, end=n-1;\\n        while(start<=end){\\n           temp=s[start];\\n           s[start]=s[end];\\n           s[end]=temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n};\\n```\\n![upvote 1.jpeg](https://assets.leetcode.com/users/images/7c692f2b-8726-4f65-8612-fd4231521ac0_1682002801.8522642.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int n=s.size(),temp;\\n        int start=0, end=n-1;\\n        while(start<=end){\\n           temp=s[start];\\n           s[start]=s[end];\\n           s[end]=temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3246263,
                "title": "344-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis problem can be easily solved by swapping the characters from both ends of the given string until they meet at the center.\\n\\nHere\\'s the step-by-step explanation of the algorithm:\\n\\n1. Initialize two pointers: left pointing to the first character of the string and right pointing to the last character of the string.\\n2. While left < right, swap the characters at indices left and right and increment left and decrement right.\\n3. Return the modified string.\\n\\nThe time complexity of this algorithm is O(n) and the space complexity is O(1), where n is the length of the input string.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        # Initialize the left and right pointers\\n        left, right = 0, len(s) - 1\\n        \\n        # Loop until the pointers meet at the center\\n        while left < right:\\n            # Swap the characters at the left and right indices\\n            s[left], s[right] = s[right], s[left]\\n            \\n            # Increment left and decrement right\\n            left += 1\\n            right -= 1\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        # Initialize the left and right pointers\\n        left, right = 0, len(s) - 1\\n        \\n        # Loop until the pointers meet at the center\\n        while left < right:\\n            # Swap the characters at the left and right indices\\n            s[left], s[right] = s[right], s[left]\\n            \\n            # Increment left and decrement right\\n            left += 1\\n            right -= 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792737,
                "title": "python-easy-two-pointer-o-n-solution",
                "content": "```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        i,j=0,len(s)-1\\n        while i<=j:\\n            s[i],s[j]=s[j],s[i]\\n            i+=1\\n            j-=1\\n```\\n\\n**Please upvote if you like the solution**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        i,j=0,len(s)-1\\n        while i<=j:\\n            s[i],s[j]=s[j],s[i]\\n            i+=1\\n            j-=1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775622,
                "title": "java-runtime-1ms-faster-than-99-94-memory-usage-less-than-97-54",
                "content": "```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int l = 0, r = s.length - 1;\\n        while (l < r) {\\n            char temp = s[l];\\n            s[l] = s[r];\\n            s[r] = temp;\\n            l++;\\n            r--;\\n        }\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/8a913d77-ae73-4853-b438-00b02512dea0_1667528314.4989285.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int l = 0, r = s.length - 1;\\n        while (l < r) {\\n            char temp = s[l];\\n            s[l] = s[r];\\n            s[r] = temp;\\n            l++;\\n            r--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2403620,
                "title": "python-4-method-beginner-friendly-easyto-understand-very-simple",
                "content": "If you find it helpful please upvote.\\nupvote is on left hand side just below (<Back) Button.\\nThankyou\\n\\nUSING RECURSION\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        i=0\\n        j=len(s)-1\\n        def rev(s,i,j):\\n            if i>=j:\\n                return\\n            s[i],s[j]=s[j],s[i]\\n            rev(s,i+1,j-1)\\n        rev(s,i,j)\\n```\\nUsing iteration\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n       \\n        size = len(s)\\n        for i in range(size//2):\\n            s[i], s[-i-1] = s[-i-1], s[i]\\n```\\nUsing Two Pointer\\n```\\n\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        i,j=0,len(s)-1\\n        while i<j:\\n            s[i],s[j]=s[j],s[i]\\n            i+=1\\n            j-=1\\n```\\nusing python slicing\\n```\\n\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        s[:]=s[::-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        i=0\\n        j=len(s)-1\\n        def rev(s,i,j):\\n            if i>=j:\\n                return\\n            s[i],s[j]=s[j],s[i]\\n            rev(s,i+1,j-1)\\n        rev(s,i,j)\\n```\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n       \\n        size = len(s)\\n        for i in range(size//2):\\n            s[i], s[-i-1] = s[-i-1], s[i]\\n```\n```\\n\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        i,j=0,len(s)-1\\n        while i<j:\\n            s[i],s[j]=s[j],s[i]\\n            i+=1\\n            j-=1\\n```\n```\\n\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        s[:]=s[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1901987,
                "title": "3-line-code-two-pointer-approach-easiest-way",
                "content": "```\\n//please upvote if u like my solution :)\\nvoid reverseString(vector<char>& s) {\\n        for(int i=0,j=s.size()-1;i<j;i++,j--){\\n            swap(s[i],s[j]);\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Two Pointers",
                    "Recursion"
                ],
                "code": "```\\n//please upvote if u like my solution :)\\nvoid reverseString(vector<char>& s) {\\n        for(int i=0,j=s.size()-1;i<j;i++,j--){\\n            swap(s[i],s[j]);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1901845,
                "title": "bad-complicated-recursion",
                "content": "For jokes. This is terrible code.\\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        helper(s, 0);\\n    }\\n    char helper(vector<char>& s, int i){\\n        if(i == s.size()) \\n            return s[0];\\n        char res = i == 0 ? 0 : s[s.size() - i]; // determine and store the value for prev index\\n        s[i] = helper(s, i + 1); // get the character for the current index\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        helper(s, 0);\\n    }\\n    char helper(vector<char>& s, int i){\\n        if(i == s.size()) \\n            return s[0];\\n        char res = i == 0 ? 0 : s[s.size() - i]; // determine and store the value for prev index\\n        s[i] = helper(s, i + 1); // get the character for the current index\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1704410,
                "title": "3-solutions-one-liner-iterative-recursive-c-easy-to-understand",
                "content": "**One liner:**\\n\\n    void reverseString(vector<char>& s) { \\n          reverse(s.begin(), s.end());\\n    }\\n\\t\\n**Iterative:**\\n   \\n  ```\\n void reverseString(vector<char>& s) {   \\n        int low = 0;\\n        int high = s.size()-1;\\n        while(low <= high) {\\n            swap(s[low++], s[high--]);\\n        }\\n    }\\n```\\n\\n**Recurive:**\\n\\n    void rec(vector<char>& s, int low, int high)\\n    {\\n        if(low >= high)                  // Base Condition\\n            return;\\n        swap(s[low++], s[high--]);       // makes the problem smaller of same type            \\n        rec(s, low, high);\\n    }\\n    void reverseString(vector<char>& s) {\\n        rec(s, 0, s.size()-1);\\n    }\\n\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Recursion"
                ],
                "code": "```\\n void reverseString(vector<char>& s) {   \\n        int low = 0;\\n        int high = s.size()-1;\\n        while(low <= high) {\\n            swap(s[low++], s[high--]);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1699563,
                "title": "python-iterative-and-recursive-solution",
                "content": "\\t# Iterative Approach\\n\\tclass Solution:\\n\\t\\tdef reverseString(self, s: List[str]) -> None:\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tDo not return anything, modify s in-place instead.\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tn = len(s)//2\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\ts[i], s[-(i+1)] = s[-(i+1)], s[i]\\n\\n\\t# Recursive Approach\\n\\tclass Solution:\\n\\t\\tdef reverseString(self, s: List[str]) -> None:\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tDo not return anything, modify s in-place instead.\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tdef revStr(st, s, e):\\n\\t\\t\\t\\tif s >= e:\\n\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\tst[s], st[e] = st[e], st[s]\\n\\t\\t\\t\\trevStr(st, s+1, e-1)\\n\\n\\t\\t\\trevStr(s, 0, len(s)-1)\\nIf you have any questions, please ask me, and if you like this approach, please **vote it up**!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "\\t# Iterative Approach\\n\\tclass Solution:\\n\\t\\tdef reverseString(self, s: List[str]) -> None:\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tDo not return anything, modify s in-place instead.\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tn = len(s)//2\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\ts[i], s[-(i+1)] = s[-(i+1)], s[i]\\n\\n\\t# Recursive Approach\\n\\tclass Solution:\\n\\t\\tdef reverseString(self, s: List[str]) -> None:\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tDo not return anything, modify s in-place instead.\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tdef revStr(st, s, e):\\n\\t\\t\\t\\tif s >= e:\\n\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\tst[s], st[e] = st[e], st[s]\\n\\t\\t\\t\\trevStr(st, s+1, e-1)\\n\\n\\t\\t\\trevStr(s, 0, len(s)-1)\\nIf you have any questions, please ask me, and if you like this approach, please **vote it up**!",
                "codeTag": "Java"
            },
            {
                "id": 1394982,
                "title": "simplest-java-solution-beats-100-online-java-submissions",
                "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        int max=s.length-1;\\n    \\n        int halfindex=s.length/2;\\n        for(int i=0;i<halfindex;i++){\\n            char c=s[i];\\n            s[i]=s[max-i];\\n            s[max-i]=c;\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public void reverseString(char[] s) {\\n        int max=s.length-1;\\n    \\n        int halfindex=s.length/2;\\n        for(int i=0;i<halfindex;i++){\\n            char c=s[i];\\n            s[i]=s[max-i];\\n            s[max-i]=c;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1357993,
                "title": "simple-c-recursive-solution",
                "content": "```c++\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        _reverseString(s, 0, s.size() - 1);\\n    }\\n    void _reverseString(vector<char>& s, int start, int end){\\n        // Base Case\\n        if(start > end) return;\\n        swap(s[start++], s[end--]);\\n        // Recurrence relation\\n        _reverseString(s, start, end);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        _reverseString(s, 0, s.size() - 1);\\n    }\\n    void _reverseString(vector<char>& s, int start, int end){\\n        // Base Case\\n        if(start > end) return;\\n        swap(s[start++], s[end--]);\\n        // Recurrence relation\\n        _reverseString(s, start, end);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 669557,
                "title": "c-iterative-and-recursive-simple-and-short",
                "content": "**Iterative**\\n```\\n    void reverseString(vector<char>& s) {\\n        int n = s.size();\\n        for(int i = 0; i < n/2; i++){\\n            swap(s[i],s[n-i-1]);\\n        }\\n    }\\n```\\n**Recursive**\\n```\\nvoid reverse(vector<char>& str,int i)\\n    {\\n        if(i == str.size()/2) \\n            return;\\n        swap(str[i] , str[str.size() - 1 - i]);\\n        reverse(str,i + 1);\\n    }\\n    void reverseString(vector<char>& s) {\\n        reverse(s , 0);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    void reverseString(vector<char>& s) {\\n        int n = s.size();\\n        for(int i = 0; i < n/2; i++){\\n            swap(s[i],s[n-i-1]);\\n        }\\n    }\\n```\n```\\nvoid reverse(vector<char>& str,int i)\\n    {\\n        if(i == str.size()/2) \\n            return;\\n        swap(str[i] , str[str.size() - 1 - i]);\\n        reverse(str,i + 1);\\n    }\\n    void reverseString(vector<char>& s) {\\n        reverse(s , 0);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 374535,
                "title": "easy-c-2-line-solution-beats-92-100",
                "content": "Runtime: 44 ms, faster than 92.12% of C++ online submissions for Reverse String.\\nMemory Usage: 15.2 MB, less than 96.34% of C++ online submissions for Reverse String.\\n\\n```\\nvoid reverseString(vector<char>& s) {\\n        \\n        for(int start=0, end = s.size()-1; start < end; start++, end--)\\n            swap(s[start], s[end]);\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "Runtime: 44 ms, faster than 92.12% of C++ online submissions for Reverse String.\\nMemory Usage: 15.2 MB, less than 96.34% of C++ online submissions for Reverse String.\\n\\n```\\nvoid reverseString(vector<char>& s) {\\n        \\n        for(int start=0, end = s.size()-1; start < end; start++, end--)\\n            swap(s[start], s[end]);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 272264,
                "title": "fastest-c-solution",
                "content": "```\\npublic class Solution {\\n    public void ReverseString(char[] s) {\\n        var length = s.Length;\\n        for(int i = 0; i < length/2; i++){\\n            var temp = s[i];\\n            s[i] = s[length - i - 1];\\n            s[length - i - 1] = temp;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public void ReverseString(char[] s) {\\n        var length = s.Length;\\n        for(int i = 0; i < length/2; i++){\\n            var temp = s[i];\\n            s[i] = s[length - i - 1];\\n            s[length - i - 1] = temp;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 151308,
                "title": "javascript-es6",
                "content": "new submission.\\n\\n```\\nvar reverseString = function(s) {\\n  if (s.length < 2) return s;\\n  let start = 0,end = s.length - 1;\\n  while (end > start) {\\n    [s[start], s[end]] = [s[end], s[start]]; // es6 swap trick\\n    end--;\\n    start++;\\n  }\\n};\\n```\\n\\n/////Note: Question desc has  changed from what it was back in 2018 //////\\n```\\nreturn s.reverse();\\n```\\njs\\n```\\nvar reverseString = function(s) {\\n    let result = \\'\\'\\n    for(let i= s.length -1; i >= 0; i--){\\n        result += s[i];\\n    }\\n    return result.split(\\'\\');\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nvar reverseString = function(s) {\\n  if (s.length < 2) return s;\\n  let start = 0,end = s.length - 1;\\n  while (end > start) {\\n    [s[start], s[end]] = [s[end], s[start]]; // es6 swap trick\\n    end--;\\n    start++;\\n  }\\n};\\n```\n```\\nreturn s.reverse();\\n```\n```\\nvar reverseString = function(s) {\\n    let result = \\'\\'\\n    for(let i= s.length -1; i >= 0; i--){\\n        result += s[i];\\n    }\\n    return result.split(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 80982,
                "title": "c-solution-char-array",
                "content": "```\\npublic class Solution {\\n    public void ReverseString(char[] s) {\\n        var left = 0;\\n        var right = s.Length - 1;\\n\\n        while(left < right)\\n        {\\n            var temp = s[left];\\n            s[left] = s[right];\\n            s[right] = temp;\\n            \\n            left++;\\n            right--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public void ReverseString(char[] s) {\\n        var left = 0;\\n        var right = s.Length - 1;\\n\\n        while(left < right)\\n        {\\n            var temp = s[left];\\n            s[left] = s[right];\\n            s[right] = temp;\\n            \\n            left++;\\n            right--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 80994,
                "title": "share-my-simple-c-solution-no-swap",
                "content": "    class Solution {\\n    public:\\n        string reverseString(string s) {\\n            string ret;\\n            for(int i = s.size()-1; i >= 0; --i)\\n                ret += s[i];\\n            return ret;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string reverseString(string s) {\\n            string ret;\\n            for(int i = s.size()-1; i >= 0; --i)\\n                ret += s[i];\\n            return ret;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 81195,
                "title": "share-my-c-solution-very-easy-to-understand",
                "content": "    class Solution {\\n    public:\\n        string reverseString(string s) {\\n            int start = 0;\\n            int end = s.length() - 1;\\n            char ch = 0;\\n            \\n            for (; start < end; start++, end--)\\n            {\\n                ch = s[start];\\n                s[start] = s[end];\\n                s[end] = ch;\\n            }\\n            \\n            return s;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        string reverseString(string s) {\\n            int start = 0;\\n            int end = s.length() - 1;\\n            char ch = 0;\\n            \\n            for (; start < end; start++, end--)\\n            {\\n                ch = s[start];\\n                s[start] = s[end];\\n                s[end] = ch;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3649560,
                "title": "cpp-easy-2-lines-solution-using-swap-function",
                "content": "# Intuition\\nfirst thought was to use two pointers, one at start and one at end.\\n\\n# Approach\\n- Put a pointer st at start.\\n- pointer e at end of char array.\\n- put while loop till st<e.\\n- and swap s[st] with s[e].\\n- st++ and e--.\\n\\n# Complexity\\n- Time complexity:\\n                  O(n)\\n\\n- Space complexity:\\n O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int st=0;\\n        int e=s.size()-1;\\n        while(st<e)\\n        {\\n           swap(s[st++],s[e--]);\\n        }\\n    }\\n};\\n```\\n# Please upvote if you liked my explanation",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int st=0;\\n        int e=s.size()-1;\\n        while(st<e)\\n        {\\n           swap(s[st++],s[e--]);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3431886,
                "title": "easy-js-solution-no-inbuilt-methods",
                "content": "\\n# Approach\\nThis is a standard two-pointer algorithm. We would start off with two variables, $$left$$ and $$right$$. Run a for loop until $$left < right$$ and swap the characters at left and right by using $$[arr[left] , arr[right]] = [arr[right], arr[left]]$$. Return the answer\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$Constant$$\\n\\n# Code\\n```\\n\\nvar reverseString = function(s) {\\n   let left = 0, right=s.length-1;\\n\\n   while(left < right ) {\\n       [s[left] , s[right]] = [s[right] , s[left]];\\n       left++;\\n       right--\\n   } \\n\\n   return s\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar reverseString = function(s) {\\n   let left = 0, right=s.length-1;\\n\\n   while(left < right ) {\\n       [s[left] , s[right]] = [s[right] , s[left]];\\n       left++;\\n       right--\\n   } \\n\\n   return s\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3423152,
                "title": "easy-c-code-using-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    void f(int i,vector<char>&s){\\n        if(i>=s.size()/2) return;\\n        swap(s[i],s[s.size()-i-1]);\\n        f(i+1,s);\\n    }\\n    void reverseString(vector<char>& s) {\\n        f(0,s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void f(int i,vector<char>&s){\\n        if(i>=s.size()/2) return;\\n        swap(s[i],s[s.size()-i-1]);\\n        f(i+1,s);\\n    }\\n    void reverseString(vector<char>& s) {\\n        f(0,s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342891,
                "title": "two-pointers",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvoid reverseString(char* s, int sSize){\\n    char* left = s;\\n    char* right = s + sSize - 1;\\n\\n    while (left < right) {\\n        char temp = *right;\\n        *right-- = *left;\\n        *left++ = temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nvoid reverseString(char* s, int sSize){\\n    char* left = s;\\n    char* right = s + sSize - 1;\\n\\n    while (left < right) {\\n        char temp = *right;\\n        *right-- = *left;\\n        *left++ = temp;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3002634,
                "title": "very-simple-c-solution-two-pointers-o-n-time-o-1-memory",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public void ReverseString(char[] s) {\\n        var l = 0;\\n        var r = s.Length-1;\\n        while (l < r)\\n        {\\n            var temp = s[l];\\n            s[l] = s[r];\\n            s[r] = temp;\\n            l++;\\n            r--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Two Pointers"
                ],
                "code": "```\\npublic class Solution {\\n    public void ReverseString(char[] s) {\\n        var l = 0;\\n        var r = s.Length-1;\\n        while (l < r)\\n        {\\n            var temp = s[l];\\n            s[l] = s[r];\\n            s[r] = temp;\\n            l++;\\n            r--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2739302,
                "title": "using-stack-recursion-and-two-pointers-easy-and-fast",
                "content": "\\n\\n```Approach 1:```\\n\\n**Using Two Pointers**\\n\\ncode:\\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int left = 0, right = s.size()-1;\\n        while(left<right)\\n        {\\n            char temp = s[right];\\n            s[right--] = s[left];\\n            s[left++] = temp;\\n        }\\n        \\n    }\\n};\\n```\\n\\n```Approach 2:```\\n\\n**Using recursion**\\n \\n code:\\n ```\\nclass Solution {\\npublic:\\n\\n    void solve(vector<char>& s, int left, int right){\\n        if(left >= right) return;\\n        char temp = s[left];\\n        s[left] = s[right];\\n        s[right] = temp;\\n        solve(s, ++left, --right);\\n    }\\n\\n    void reverseString(vector<char>& s) {\\n        int left = 0;\\n        int right = s.size() - 1;\\n        solve(s, left, right);\\n    }\\n    \\n};\\n```\\n\\n```Approach 3:```\\n\\n**Using stack**\\n\\ncode:\\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        \\n        stack<char> tempStack;\\n        int i=0;\\n        while(i<s.size()){\\n            tempStack.push(s[i++]);\\n        }\\n        \\n        s.clear();\\n        while(!tempStack.empty()){\\n            s.push_back(tempStack.top());\\n            tempStack.pop();\\n        }\\n    }\\n};\\n```\\n\\nHope it will help you \\uD83D\\uDE4C .\\nThank you!",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Stack",
                    "Recursion"
                ],
                "code": "```Approach 1:```\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int left = 0, right = s.size()-1;\\n        while(left<right)\\n        {\\n            char temp = s[right];\\n            s[right--] = s[left];\\n            s[left++] = temp;\\n        }\\n        \\n    }\\n};\\n```\n```Approach 2:```\n```\\nclass Solution {\\npublic:\\n\\n    void solve(vector<char>& s, int left, int right){\\n        if(left >= right) return;\\n        char temp = s[left];\\n        s[left] = s[right];\\n        s[right] = temp;\\n        solve(s, ++left, --right);\\n    }\\n\\n    void reverseString(vector<char>& s) {\\n        int left = 0;\\n        int right = s.size() - 1;\\n        solve(s, left, right);\\n    }\\n    \\n};\\n```\n```Approach 3:```\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        \\n        stack<char> tempStack;\\n        int i=0;\\n        while(i<s.size()){\\n            tempStack.push(s[i++]);\\n        }\\n        \\n        s.clear();\\n        while(!tempStack.empty()){\\n            s.push_back(tempStack.top());\\n            tempStack.pop();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2685812,
                "title": "two-pointers-approach-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Start off with two-pointers (start and end).\\n2. Create a loop with breaking conditions i.e left must be less than right.\\n3. Swap the values with each other in each iteration.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\n/**\\n * @param {character[]} s\\n * @return {void} Do not return anything, modify s in-place instead.\\n */\\nvar reverseString = function(s) {\\n    let left = 0;\\n    let right = s.length - 1 ;\\n\\n    while(left < right){\\n        const temp = s[left];\\n        s[left] = s[right];\\n        s[right] = temp;\\n\\n        left += 1;\\n        right -= 1;\\n    }\\n\\n    return s;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\n/**\\n * @param {character[]} s\\n * @return {void} Do not return anything, modify s in-place instead.\\n */\\nvar reverseString = function(s) {\\n    let left = 0;\\n    let right = s.length - 1 ;\\n\\n    while(left < right){\\n        const temp = s[left];\\n        s[left] = s[right];\\n        s[right] = temp;\\n\\n        left += 1;\\n        right -= 1;\\n    }\\n\\n    return s;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2617831,
                "title": "c-2-pointer-approch-swaping-elemnts-on-the-pointer",
                "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s)\\n    {\\n        int i=0;\\n        int j=s.size()-1;\\n        while(j>=i)\\n        {\\n           swap(s[i],s[j]);\\n            i++;\\n            j--;\\n        }\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s)\\n    {\\n        int i=0;\\n        int j=s.size()-1;\\n        while(j>=i)\\n        {\\n           swap(s[i],s[j]);\\n            i++;\\n            j--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2534280,
                "title": "java-3-line-code-faster-than-99-easy-to-understand",
                "content": "\\tclass Solution {\\n    public void reverseString(char[] s) {\\n        int startIndex = 0;\\n        int endIndex = s.length - 1;\\n        char temp;\\n        while (startIndex < endIndex) {\\n            temp = s[startIndex];\\n            s[startIndex] = s[endIndex];\\n            s[endIndex] = temp;\\n            startIndex++;\\n            endIndex--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\n\\t\\nIf you like solution, than UpVote ^ me :)",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n    public void reverseString(char[] s) {\\n        int startIndex = 0;\\n        int endIndex = s.length - 1;\\n        char temp;\\n        while (startIndex < endIndex) {\\n            temp = s[startIndex];\\n            s[startIndex] = s[endIndex];\\n            s[endIndex] = temp;\\n            startIndex++;\\n            endIndex--;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2397227,
                "title": "simple-1ms-java-solution",
                "content": "```\\npublic void reverseString(char[] s) \\n    {\\n        int i=0;\\n        int j= s.length-1;\\n        char t;\\n\\n        \\n        while(i <= j)\\n        {\\n            t = s[i];\\n            s[i] = s[j];\\n            s[j] = t;\\n            i++;\\n            j--;\\n        }\\n    }\\n\\t\\n\\t```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\npublic void reverseString(char[] s) \\n    {\\n        int i=0;\\n        int j= s.length-1;\\n        char t;\\n\\n        \\n        while(i <= j)\\n        {\\n            t = s[i];\\n            s[i] = s[j];\\n            s[j] = t;\\n            i++;\\n            j--;\\n        }\\n    }\\n\\t\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2381464,
                "title": "simple-c-solution",
                "content": "```\\nvoid swap(char* a, char* b){\\n    char temp = *a;\\n    *a = *b;\\n    *b = temp;\\n}\\n\\nvoid reverseString(char* s, int sSize){\\n    int starting = 0, ending = sSize - 1;\\n    while (starting < ending){\\n        swap(&s[starting++], &s[ending--]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid swap(char* a, char* b){\\n    char temp = *a;\\n    *a = *b;\\n    *b = temp;\\n}\\n\\nvoid reverseString(char* s, int sSize){\\n    int starting = 0, ending = sSize - 1;\\n    while (starting < ending){\\n        swap(&s[starting++], &s[ending--]);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2378221,
                "title": "c-solution-2-approaches-function-and-swapping",
                "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n\\t\\n\\t\\t// 1. by using inbuilt function\\n        reverse(s.begin(), s.end());\\n\\t\\t\\n\\t\\t// 2. by swappping\\n        int i = 0;\\n        int j = s.size() - 1;\\n        while(i < j){\\n            int temp = s[i];\\n            s[i] = s[j];\\n            s[j] = temp;\\n            i++;\\n            j--;\\n        }\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n\\t\\n\\t\\t// 1. by using inbuilt function\\n        reverse(s.begin(), s.end());\\n\\t\\t\\n\\t\\t// 2. by swappping\\n        int i = 0;\\n        int j = s.size() - 1;\\n        while(i < j){\\n            int temp = s[i];\\n            s[i] = s[j];\\n            s[j] = temp;\\n            i++;\\n            j--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1952125,
                "title": "c-recursive-solution-easy-to-understand",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvoid sol(vector<char>& s,int low,int high)\\n\\t\\t{\\n\\t\\tif(low>=high)return;\\n\\t\\tsol(s,low+1,high-1);\\n\\t\\tswap(s[low],s[high]);\\n\\t\\t}\\n\\t\\tvoid reverseString(vector<char>& s) {\\n\\t\\tint n=s.size()-1;\\n\\t\\tsol(s,0,n);\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvoid sol(vector<char>& s,int low,int high)\\n\\t\\t{\\n\\t\\tif(low>=high)return;\\n\\t\\tsol(s,low+1,high-1);\\n\\t\\tswap(s[low],s[high]);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1901962,
                "title": "javascript-python-visual-explanation",
                "content": "**Please dont downvote guys if cannot support,We are putting lot of effort in it \\uD83D\\uDE42**\\n```\\nHello guys \\uD83D\\uDE00 !\\n\\nGiven question:\\n    Write a function that reverses a string. The input string is given as an array of characters s.\\n\\n    You must do this by modifying the input array in-place with O(1) extra memory.\\n\\n\\nQuestion Explanation:\\n    basically, we need to reverse the string with constant space\\n\\n\\nExplanation:\\n    lets declare a variable called left and right.\\n    left = 0\\n    right = len(nums) - 1\\n    we will keep on looping until left is less than right.\\n\\n\\nBig O:\\n    n--> number of elements in the array\\n    Time Complexity: O(n) \\n    Space Complexity: O(1)\\n```\\n\\n![image](https://assets.leetcode.com/users/images/eb2044db-0a9b-4534-93c9-92029ca851dc_1648779427.3667967.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/d23bd408-512f-41ea-b0ca-535aad304f1b_1648779528.4045486.gif)\\n\\n\\n`Python`\\n\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        left=0\\n        right=len(s)-1\\n        while left < right:\\n            left_val=s[left]\\n            right_val=s[right]\\n            s[left],s[right]=right_val,left_val\\n            left+=1\\n            right-=1\\n        return s\\n```\\n\\n`Javascript`\\n\\n```\\nconst reverseString = (s) => {\\nlet left = 0;\\n  let right = s.length - 1;\\n  while (left < right) {\\n    const first = s[left];\\n    const last = s[right];\\n    [s[left], s[right]] = [last, first];\\n    left++;\\n    right--;\\n  }\\n  return s;\\n};\\n```\\n\\n`UPVOTE if you like \\uD83D\\uDE03 , If you have any question, feel free to ask.`\\n",
                "solutionTags": [
                    "Python",
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nHello guys \\uD83D\\uDE00 !\\n\\nGiven question:\\n    Write a function that reverses a string. The input string is given as an array of characters s.\\n\\n    You must do this by modifying the input array in-place with O(1) extra memory.\\n\\n\\nQuestion Explanation:\\n    basically, we need to reverse the string with constant space\\n\\n\\nExplanation:\\n    lets declare a variable called left and right.\\n    left = 0\\n    right = len(nums) - 1\\n    we will keep on looping until left is less than right.\\n\\n\\nBig O:\\n    n--> number of elements in the array\\n    Time Complexity: O(n) \\n    Space Complexity: O(1)\\n```\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        left=0\\n        right=len(s)-1\\n        while left < right:\\n            left_val=s[left]\\n            right_val=s[right]\\n            s[left],s[right]=right_val,left_val\\n            left+=1\\n            right-=1\\n        return s\\n```\n```\\nconst reverseString = (s) => {\\nlet left = 0;\\n  let right = s.length - 1;\\n  while (left < right) {\\n    const first = s[left];\\n    const last = s[right];\\n    [s[left], s[right]] = [last, first];\\n    left++;\\n    right--;\\n  }\\n  return s;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1764369,
                "title": "python-3-200ms-two-pointers-approach-2-solutions",
                "content": "***1 - Two Pointers (Start & End) :-***\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        st,e=0,len(s)-1\\n        while st<=e:\\n            s[st],s[e]=s[e],s[st]\\n            st+=1\\n            e-=1\\n```\\n\\n***2 - Same but One-Liner :-***\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        for i in range(len(s)//2): s[i], s[-i-1] = s[-i-1], s[i]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        st,e=0,len(s)-1\\n        while st<=e:\\n            s[st],s[e]=s[e],s[st]\\n            st+=1\\n            e-=1\\n```\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        for i in range(len(s)//2): s[i], s[-i-1] = s[-i-1], s[i]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1618141,
                "title": "using-recursion-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        rev(s, 0, s.size()-1);\\n    }\\n    void rev(vector<char>& s, int b, int e){  \\n        if(b>e) return;\\n        \\n        else{ \\n            swap(s[b],s[e]);\\n            return rev(s,b+1,e-1);\\n        }\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        rev(s, 0, s.size()-1);\\n    }\\n    void rev(vector<char>& s, int b, int e){  \\n        if(b>e) return;\\n        \\n        else{ \\n            swap(s[b],s[e]);\\n            return rev(s,b+1,e-1);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1615010,
                "title": "c-simple-code-full-explantion-with-comments-dry-run-constant-space-i-e-o-1-pass-94-43",
                "content": "Code with full explanation and for dry run see below -\\n```\\nclass Solution {\\npublic:\\n    //Runtime: 16 ms, faster than 94.43% of C++ online submissions for Reverse String.\\n    //Memory Usage: 23.2 MB, less than 76.23% of C++ online submissions for Reverse String.\\n    \\n\\t// Explanation-\\n    /* Basic question, but good one to do it in O(1) space\\n       Simply, we use two pointer approach for solving this,\\n       we declare two variables as low and high,\\n       and intilize low as 0 (i.e pointing first index)&\\n           high as size of string - 1 (basically, last index of string)\\n           \\n           Now, while low is less than high,(it is condition, it will clear in dry run\\n           we simply swap the characters present at low and high index,\\n           and move low as one step forward and for high we reduce it one step;\\n           \\n           see below dry run\\n    */\\n    void reverseString(vector<char>& s) {\\n        int n = s.size(); // give the size of array\\n        \\n        int low = 0; // low at first index\\n        int high = n - 1; // high at last index\\n        \\n        while(low < high) // while condition is satisfied\\n        {\\n            // simply swapping characters\\n\\t\\t\\t// other than that simply we can write also { swap(s[low], s[high]) }\\n            char temp = s[low];\\n            s[low] = s[high];\\n            s[high] = temp;\\n            \\n            low++; // moving low one step forwad\\n            high--; // reducing high by one step \\n        }\\n    }\\n    \\n    // we are done now\\n};\\n```\\n\\n**NOW, DRY RUN ON FIRST EXAMPLE**\\n\\n```\\nInput string , s = [\"h\",\"e\",\"l\",\"l\",\"o\"]\\nn = 5\\n\\nlow = 0,\\nhigh =  5 - 1 = 4 (n - 1)\\n\\n//looping starts\\nwhile (low < high)\\n{\\n      when\\n\\t  low = 0, \\n\\t  high = 4\\n\\t  swap(arr[0],arr[4])\\n\\t  so, string s becomes - s = [\"o\",\"e\",\"l\",\"l\",\"h\"]\\n\\t  \\n\\t  low++   --> low becomes 1\\n\\t  high--   --> high becomes 3\\n\\t  \\n\\t  condition satisfiesd low < high (i.e 1 < 3)\\n\\t   when\\n\\t  low = 1, \\n\\t  high = 3\\n\\t  swap(arr[1],arr[3])\\n\\t  so, string s becomes - s = [\"o\",\"l\",\"l\",\"e\",\"h\"]\\n\\t  \\n\\t   low++   --> low becomes 2\\n\\t   high--   --> high becomes 2\\n\\t  \\n\\t  condition not satisfied as \\n\\t  here, low becomes equal to high (2 == 2)\\n\\t  it is no more less than high\\n\\t  \\n\\t  so return final string\\n\\t  and becomes, s=  [\"o\",\"l\",\"l\",\"e\",\"h\"]\\n\\t  \\n\\t  // if u like this please give me a upvote\\n}\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Runtime: 16 ms, faster than 94.43% of C++ online submissions for Reverse String.\\n    //Memory Usage: 23.2 MB, less than 76.23% of C++ online submissions for Reverse String.\\n    \\n\\t// Explanation-\\n    /* Basic question, but good one to do it in O(1) space\\n       Simply, we use two pointer approach for solving this,\\n       we declare two variables as low and high,\\n       and intilize low as 0 (i.e pointing first index)&\\n           high as size of string - 1 (basically, last index of string)\\n           \\n           Now, while low is less than high,(it is condition, it will clear in dry run\\n           we simply swap the characters present at low and high index,\\n           and move low as one step forward and for high we reduce it one step;\\n           \\n           see below dry run\\n    */\\n    void reverseString(vector<char>& s) {\\n        int n = s.size(); // give the size of array\\n        \\n        int low = 0; // low at first index\\n        int high = n - 1; // high at last index\\n        \\n        while(low < high) // while condition is satisfied\\n        {\\n            // simply swapping characters\\n\\t\\t\\t// other than that simply we can write also { swap(s[low], s[high]) }\\n            char temp = s[low];\\n            s[low] = s[high];\\n            s[high] = temp;\\n            \\n            low++; // moving low one step forwad\\n            high--; // reducing high by one step \\n        }\\n    }\\n    \\n    // we are done now\\n};\\n```\n```\\nInput string , s = [\"h\",\"e\",\"l\",\"l\",\"o\"]\\nn = 5\\n\\nlow = 0,\\nhigh =  5 - 1 = 4 (n - 1)\\n\\n//looping starts\\nwhile (low < high)\\n{\\n      when\\n\\t  low = 0, \\n\\t  high = 4\\n\\t  swap(arr[0],arr[4])\\n\\t  so, string s becomes - s = [\"o\",\"e\",\"l\",\"l\",\"h\"]\\n\\t  \\n\\t  low++   --> low becomes 1\\n\\t  high--   --> high becomes 3\\n\\t  \\n\\t  condition satisfiesd low < high (i.e 1 < 3)\\n\\t   when\\n\\t  low = 1, \\n\\t  high = 3\\n\\t  swap(arr[1],arr[3])\\n\\t  so, string s becomes - s = [\"o\",\"l\",\"l\",\"e\",\"h\"]\\n\\t  \\n\\t   low++   --> low becomes 2\\n\\t   high--   --> high becomes 2\\n\\t  \\n\\t  condition not satisfied as \\n\\t  here, low becomes equal to high (2 == 2)\\n\\t  it is no more less than high\\n\\t  \\n\\t  so return final string\\n\\t  and becomes, s=  [\"o\",\"l\",\"l\",\"e\",\"h\"]\\n\\t  \\n\\t  // if u like this please give me a upvote\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1529891,
                "title": "solution-to-get-rejected-from-interview",
                "content": "\\n\\nclass Solution:\\n    \\n    def reverseString(self, s: List[str]) -> None:\\n        \\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \\n        \"\"\"\\n        \\n        s.reverse()\\n",
                "solutionTags": [],
                "code": "\\n\\nclass Solution:\\n    \\n    def reverseString(self, s: List[str]) -> None:\\n        \\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \\n        \"\"\"\\n        \\n        s.reverse()\\n",
                "codeTag": "Java"
            },
            {
                "id": 1137346,
                "title": "recursive-iterative-and-stl-solution",
                "content": "**Recursive 1**\\n```\\nclass Solution {\\npublic:\\n    void solve(vector<char>& s, int start, int end)\\n    {\\n        if(start>=end)\\n            return ;\\n        char temp=s[end];\\n        s[end]=s[start];\\n        s[start]=temp;\\n        solve(s,start+1,end-1);\\n    }\\n    void reverseString(vector<char>& s) {\\n        solve(s,0,s.size()-1);\\n        return ;\\n    }\\n};\\n```\\n**Recursive 2**\\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        if(s.size()==0)\\n            return;\\n        char temp=s[0];\\n        s.erase(s.begin()+0);\\n        reverseString(s);\\n        s.push_back(temp);\\n    }\\n};\\n```\\n**Iterative solution**\\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        char temp;\\n        int n=s.size();\\n        if(n==1)\\n            return ;\\n        for(int i=0;i<n/2;i++)\\n        {\\n            temp=s[i];\\n            s[i]=s[n-i-1];\\n            s[n-1-i]=temp;\\n        }\\n    }\\n};\\n```\\n**Stl Solution**\\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n         reverse(s.begin(),s.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<char>& s, int start, int end)\\n    {\\n        if(start>=end)\\n            return ;\\n        char temp=s[end];\\n        s[end]=s[start];\\n        s[start]=temp;\\n        solve(s,start+1,end-1);\\n    }\\n    void reverseString(vector<char>& s) {\\n        solve(s,0,s.size()-1);\\n        return ;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        if(s.size()==0)\\n            return;\\n        char temp=s[0];\\n        s.erase(s.begin()+0);\\n        reverseString(s);\\n        s.push_back(temp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        char temp;\\n        int n=s.size();\\n        if(n==1)\\n            return ;\\n        for(int i=0;i<n/2;i++)\\n        {\\n            temp=s[i];\\n            s[i]=s[n-i-1];\\n            s[n-1-i]=temp;\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n         reverse(s.begin(),s.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1084750,
                "title": "python-3-basic-2-pointer-solution",
                "content": "```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        left,right = 0,len(s)-1\\n        while left < right:\\n            s[left],s[right] = s[right],s[left]\\n            left += 1\\n            right -= 1\\n```\\nRun two pointers from both the ends and assign one to the other, and vice versa.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        left,right = 0,len(s)-1\\n        while left < right:\\n            s[left],s[right] = s[right],s[left]\\n            left += 1\\n            right -= 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1016564,
                "title": "100-faster-100-efficient",
                "content": "```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        for(int i=0;i<s.size()/2;i++){\\n            swap(s[i],s[s.size()-1-i]);\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        for(int i=0;i<s.size()/2;i++){\\n            swap(s[i],s[s.size()-1-i]);\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 883529,
                "title": "c-simple-and-short-solution-beats-97",
                "content": "```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int i;\\n        int j = s.size()-1;\\n        for(i = 0 ;i <j ;i++)\\n        {\\n            swap(s[i],s[j]);\\n            j--;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int i;\\n        int j = s.size()-1;\\n        for(i = 0 ;i <j ;i++)\\n        {\\n            swap(s[i],s[j]);\\n            j--;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 812518,
                "title": "ruby-without-using-reverse",
                "content": "```\\ndef reverse_string(s)\\n    (s.size/2).times { |i| s[i], s[-(i+1)] = s[-(i+1)], s[i] }\\n    s\\nend",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef reverse_string(s)\\n    (s.size/2).times { |i| s[i], s[-(i+1)] = s[-(i+1)], s[i] }\\n    s\\nend",
                "codeTag": "Python3"
            },
            {
                "id": 670913,
                "title": "javascript-2-liner-with-explanation-faster-97-less-than-88-mem",
                "content": "Ok I wasn\\'t going to post my solution because the problem was so easy, but i see all these others using two pointers, running the full length of the string/array, of using temp vars, etc.\\n\\nSo here it is, only extra space is the iteration variable i, and the runtime is n/2.  For odd size strings, the letter in the middle doesn\\'t need to be copied.\\n```\\nvar reverseString = function(s) {\\n    for (let i=0; i<s.length/2; i++)\\n        [s[i], s[s.length-1-i]] = [s[s.length-1-i], s[i]]\\n};\\n```\\nBtw, I could have made it more efficient by setting the stopping condition in the beginning of my for loop, so i would not have recalculated it every time and by calculating s.length-1-i once per loop, rather than twice.\\n```\\n  for (let i=0, j=s.length/2, lenMin1=s.length-1; i<j; i++,lenMin1--)\\n    [s[i], s[lenMin1]] = [s[lenMin1], s[i]]\\n```\\nRemember the first statement, runs at the beginning of the loop, the second runs at each iteration, and the last also.  Normally s.length is a simple lookup, but since i do /2, it\\'s an operation each time so better just done once, same with lenMin1.\\n\\nCheers!\\n\\nP.S. As one of the comments mentioned, today this runs a bit slower than when ran earlier.  Also it\\'s pretty random (assuming it\\'s the current server load).  So I just re-ran it, and it\\'s 70% faster, then on next run 94%.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar reverseString = function(s) {\\n    for (let i=0; i<s.length/2; i++)\\n        [s[i], s[s.length-1-i]] = [s[s.length-1-i], s[i]]\\n};\\n```\n```\\n  for (let i=0, j=s.length/2, lenMin1=s.length-1; i<j; i++,lenMin1--)\\n    [s[i], s[lenMin1]] = [s[lenMin1], s[i]]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 670430,
                "title": "easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int i=0, j=s.size()-1;\\n        while(i<j){\\n            char c=s[i];\\n            s[i]=s[j];\\n            s[j]=c;\\n            i++;\\n            j--;\\n        }\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int i=0, j=s.size()-1;\\n        while(i<j){\\n            char c=s[i];\\n            s[i]=s[j];\\n            s[j]=c;\\n            i++;\\n            j--;\\n        }\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 575577,
                "title": "python-inplace-oneliner",
                "content": "Obvious goal was to save memory so I may not use classic pythonic ways like \"[::-1]\", \"reverse\" and so on. Here is my memory-greedy approach:\\n\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        for i in range(len(s) // 2): s[i], s[-i-1] = s[-i-1], s[i]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        for i in range(len(s) // 2): s[i], s[-i-1] = s[-i-1], s[i]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 573784,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        for i in range(len(s) // 2):\\n            s[i] , s[~i] = s[~i], s[i]\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        for i in range(len(s) // 2):\\n            s[i] , s[~i] = s[~i], s[i]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 400259,
                "title": "python-recursive-solution",
                "content": "```\\nclass Solution(object):\\n    def reverseString(self, s):\\n        \"\"\"\\n        :type s: List[str]\\n        :rtype: None Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        end = len(s) - 1\\n        \\n        def recursiveReverse(s, index):\\n            \\n            if index < len(s)/2:\\n                s[index], s[end-index] = s[end-index],s[index]\\n                index =  index + 1\\n                recursiveReverse(s,index)\\n            else:\\n                return\\n        \\n        recursiveReverse(s,0)\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution(object):\\n    def reverseString(self, s):\\n        \"\"\"\\n        :type s: List[str]\\n        :rtype: None Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        end = len(s) - 1\\n        \\n        def recursiveReverse(s, index):\\n            \\n            if index < len(s)/2:\\n                s[index], s[end-index] = s[end-index],s[index]\\n                index =  index + 1\\n                recursiveReverse(s,index)\\n            else:\\n                return\\n        \\n        recursiveReverse(s,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 301526,
                "title": "simple-java-solution-beats-100",
                "content": "Thought I could explain both iterative and the recursive solution here. The iterative solution is straight-forward since we want to run to the mid of the array swapping the start and the end of the array. Here is the code for that.\\n\\n```\\nprivate void iterative(char[] s) {\\n\\tint i = 0;\\n\\tint j = s.length-1;\\n\\twhile(i < j) {\\n\\t\\tchar temp = s[i];\\n\\t\\ts[i] = s[j];\\n\\t\\ts[j] = temp;\\n\\t\\ti++;\\n\\t\\tj--;\\n\\t}        \\n}\\n```\\n\\nThe recursive solution may be slightly tricky if we don\\'t the follow the similar path as above. The idea is is to traverse to the mid of the array by incrementing the start and decreasing the end and swapping all the way.\\n\\t\\n\\t\\n\\t\\n    \\n    private void recursive(char[] arr, int s, int e) {\\n        if (s >= e) {\\n            return;\\n        }\\n        recursive(arr,s+1, e-1);\\n        char temp = arr[e];\\n        arr[e] = arr[s];\\n        arr[s] = temp;\\n    }",
                "solutionTags": [],
                "code": "```\\nprivate void iterative(char[] s) {\\n\\tint i = 0;\\n\\tint j = s.length-1;\\n\\twhile(i < j) {\\n\\t\\tchar temp = s[i];\\n\\t\\ts[i] = s[j];\\n\\t\\ts[j] = temp;\\n\\t\\ti++;\\n\\t\\tj--;\\n\\t}        \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 284962,
                "title": "javascript-99",
                "content": "```\\nvar reverseString = function(s) {\\n    if(s.length==1) return s;\\n    let p1 = Math.floor(s.length/2)-1;\\n    let p2 = s.length % 2 == 0 ? Math.floor(s.length/2) : Math.floor(s.length/2)+1;\\n    while(p1>=0){\\n        [s[p1], s[p2]] = [s[p2], s[p1]];\\n        p1--;\\n        p2++;\\n    }\\n    return s;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar reverseString = function(s) {\\n    if(s.length==1) return s;\\n    let p1 = Math.floor(s.length/2)-1;\\n    let p2 = s.length % 2 == 0 ? Math.floor(s.length/2) : Math.floor(s.length/2)+1;\\n    while(p1>=0){\\n        [s[p1], s[p2]] = [s[p2], s[p1]];\\n        p1--;\\n        p2++;\\n    }\\n    return s;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 260796,
                "title": "go-using-recursion",
                "content": "This question was posed in the context of recursion, so I solved for it without a loop. Its performance was not great.\\n\\n```\\nfunc reverseString(s []byte)  {\\n\\tif len(s) <= 1 {\\n\\t\\treturn\\n\\t}\\n\\n\\ts[0], s[len(s)-1] = s[len(s)-1], s[0]\\n\\treverseString(s[1:len(s)-1])    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc reverseString(s []byte)  {\\n\\tif len(s) <= 1 {\\n\\t\\treturn\\n\\t}\\n\\n\\ts[0], s[len(s)-1] = s[len(s)-1], s[0]\\n\\treverseString(s[1:len(s)-1])    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 80963,
                "title": "java-using-xor",
                "content": "```\\npublic class Solution {\\n    public String reverseString(String s) {\\n        if(s == null) return \"\";\\n        \\n        char[] rev = s.toCharArray();\\n        int i = 0, j = s.length() - 1;\\n        while(i < j) {\\n            rev[i] ^= rev[j];\\n            rev[j] ^= rev[i];\\n            rev[i++] ^= rev[j--];\\n        }\\n        \\n        return String.valueOf(rev);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public String reverseString(String s) {\\n        if(s == null) return \"\";\\n        \\n        char[] rev = s.toCharArray();\\n        int i = 0, j = s.length() - 1;\\n        while(i < j) {\\n            rev[i] ^= rev[j];\\n            rev[j] ^= rev[i];\\n            rev[i++] ^= rev[j--];\\n        }\\n        \\n        return String.valueOf(rev);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 81208,
                "title": "python-one-line-solution",
                "content": "\\n\\n\\n    return s[::-1]\\n\\n    return ''.join(reversed(list(s)))",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "\\n\\n\\n    return s[::-1]\\n\\n    return ''.join(reversed(list(s)))",
                "codeTag": "Unknown"
            },
            {
                "id": 3933321,
                "title": "3-lines-c-code",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int n= s.size();\\n        for(int i=0; i<n/2; i++){\\n            swap(s[i],s[n-i-1]);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int n= s.size();\\n        for(int i=0; i<n/2; i++){\\n            swap(s[i],s[n-i-1]);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3850987,
                "title": "python3-two-word-answer-not-a-single-line-beats-99-89",
                "content": "# Intuition\\njust make a copy of its own list\\n# Approach\\nReversing a list in place\\n\\n# Complexity\\n- Time complexity:\\nO[1]\\n\\n- Space complexity:\\nO[1]\\n\\n# Code\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        s[:] = s[::-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        s[:] = s[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3644079,
                "title": "344-reverse-string-100-easy-java-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        StringBuffer sb = new StringBuffer();\\n        sb.append(s);\\n        sb.reverse();\\n\\n        for (int i = 0; i < s.length; i++) {\\n            s[i] = sb.charAt(i);\\n        }\\n  }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        StringBuffer sb = new StringBuffer();\\n        sb.append(s);\\n        sb.reverse();\\n\\n        for (int i = 0; i < s.length; i++) {\\n            s[i] = sb.charAt(i);\\n        }\\n  }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3473499,
                "title": "simple-java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int size = s.length;\\n        for(int i = 0, j = size - 1; i < size/2; i++){\\n            swap(s, i, j--);\\n        }\\n    }\\n\\n    public void swap(char[] s, int i, int j){\\n        char t = s[i];\\n        s[i] = s[j];\\n        s[j] = t;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int size = s.length;\\n        for(int i = 0, j = size - 1; i < size/2; i++){\\n            swap(s, i, j--);\\n        }\\n    }\\n\\n    public void swap(char[] s, int i, int j){\\n        char t = s[i];\\n        s[i] = s[j];\\n        s[j] = t;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422735,
                "title": "java-easy-solution-using-recursion",
                "content": "\\n\\n# Approach\\n```\\nUsing Recursion\\n```\\nHope this helps!!\\nDo Upvote if you like it.\\n\\nThanks :)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        reverse(s,0,s.length-1);    \\n    }\\n\\n    static char[] reverse(char[] s, int start, int end){\\n        //when the character array is reversed (i.e. start and end pointers cross the mid) \\n        if(start>end){\\n            return s;\\n        }\\n\\n        //swapping character at start with character at end \\n        char temp= s[start];\\n        s[start]= s[end];\\n        s[end]= temp;\\n        \\n        //recalling the function with start+1 and end-1 as start and end value\\n        reverse( s, start+1, end-1);\\n        return s;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nUsing Recursion\\n```\n```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        reverse(s,0,s.length-1);    \\n    }\\n\\n    static char[] reverse(char[] s, int start, int end){\\n        //when the character array is reversed (i.e. start and end pointers cross the mid) \\n        if(start>end){\\n            return s;\\n        }\\n\\n        //swapping character at start with character at end \\n        char temp= s[start];\\n        s[start]= s[end];\\n        s[end]= temp;\\n        \\n        //recalling the function with start+1 and end-1 as start and end value\\n        reverse( s, start+1, end-1);\\n        return s;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3401429,
                "title": "easy-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public void reverseString(char[] s) \\n    {\\n         char temp;\\n         for(int i=0,j=s.length-1;i<s.length/2;i++,j--)\\n         {\\n            temp=s[i];\\n            s[i]=s[j];\\n            s[j]=temp;\\n         }   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public void reverseString(char[] s) \\n    {\\n         char temp;\\n         for(int i=0,j=s.length-1;i<s.length/2;i++,j--)\\n         {\\n            temp=s[i];\\n            s[i]=s[j];\\n            s[j]=temp;\\n         }   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396858,
                "title": "two-pointer-beginner-friendly-c-code",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nKeep \\'i\\' at first and \\'j\\' at last then swap them , as long as i<j or i==j(when the string will be of odd size, it will aslo be needed for the middle element).\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int i=0;\\n        int j=s.size()-1;\\n        while(i<=j){\\n            swap(s[i],s[j]);\\n            i++;\\n            j--;\\n        }\\n        return;\\n    }\\n};\\n```\\n# Please Upvote if you find it helpful \\u2B06\\uFE0F",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int i=0;\\n        int j=s.size()-1;\\n        while(i<=j){\\n            swap(s[i],s[j]);\\n            i++;\\n            j--;\\n        }\\n        return;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272407,
                "title": "java-solution-runtime-1-ms",
                "content": "\\n\\n# Approach\\n- Stores the reverse of the array s in array s1.(1st for loop)\\n- Stores the reversed array s1 in array s.(2nd for loop)\\n\\n\\n# Complexity\\n- Time complexity:\\nO(2n) = O(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int l=s.length;\\n        char letter;\\n        int c=0;\\n        char [] s1=new char[l];\\n        for(int i=l-1;i>=0;i--)\\n        {\\n            letter=s[i];\\n            s1[c]=s[i];\\n            c++;\\n        }\\n        for (int i=0;i<l;i++)\\n            s[i]=s1[i];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int l=s.length;\\n        char letter;\\n        int c=0;\\n        char [] s1=new char[l];\\n        for(int i=l-1;i>=0;i--)\\n        {\\n            letter=s[i];\\n            s1[c]=s[i];\\n            c++;\\n        }\\n        for (int i=0;i<l;i++)\\n            s[i]=s1[i];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3251934,
                "title": "java-easy-simple-solution",
                "content": "# Java\\n\\n# Code\\n```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        \\n        int l = s.length;\\n        char ch = \\' \\';\\n\\n        for (int i = 0; i < l / 2; i++) {\\n            ch = s[i];\\n        \\n            s[i] = s[l - (i+1)];\\n            s[l - (i+1)] = ch;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        \\n        int l = s.length;\\n        char ch = \\' \\';\\n\\n        for (int i = 0; i < l / 2; i++) {\\n            ch = s[i];\\n        \\n            s[i] = s[l - (i+1)];\\n            s[l - (i+1)] = ch;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3208173,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        # s[:]= s[::-1]\\n        start, end = 0, len(s)-1\\n        while(start<end):\\n            s[start], s[end] = s[end], s[start]\\n            start +=1\\n            end -=1\\n  \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        # s[:]= s[::-1]\\n        start, end = 0, len(s)-1\\n        while(start<end):\\n            s[start], s[end] = s[end], s[start]\\n            start +=1\\n            end -=1\\n  \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3126634,
                "title": "java-three-approach-recursive-solution-iterative-solution",
                "content": "\\n# Solution 1\\n```\\nclass Solution {        \\n    void swap(char[]arr, int a, int b){\\n        char temp=arr[a];\\n        arr[a]=arr[b];\\n        arr[b]=temp;\\n    }\\n    public void reverseString(char[] s) {\\n        int f=0;\\n        int l=s.length-1;\\n        while(l>f){\\n            swap(s, f, l);\\n            f++;\\n            l--;\\n        }\\n    }\\n}\\n```\\n\\n# Solution 2(Recursive solution)\\n```\\n\\nclass Solution {            \\n    static char[] swap(char[] s, int a,int b ){\\n        char temp=s[a];\\n        s[a]=s[b];\\n        s[b]=temp;\\n        return s;\\n    }\\n    void foo(char[] s, int low, int high){\\n        if(high-low+1<=1) return;\\n        swap(s, low, high);\\n        foo(s, low+1, high-1);\\n    }\\n    public void reverseString(char[] s) {\\n        foo(s, 0, s.length-1);\\n        \\n    }\\n}\\n\\n```\\n\\n# Solution 3\\n\\n```\\nclass Solution {         \\n    static char[] swap(char[] s, int a,int b ){\\n        char temp=s[a];\\n        s[a]=s[b];\\n        s[b]=temp;\\n        return s;\\n    }\\n    void foo(char[] s, int low, int high){\\n        while(high>low){\\n            swap(s, low, high);\\n            high--;\\n            low++;\\n        }\\n    }\\n    public void reverseString(char[] s) {\\n        foo(s, 0, s.length-1);\\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "String",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {        \\n    void swap(char[]arr, int a, int b){\\n        char temp=arr[a];\\n        arr[a]=arr[b];\\n        arr[b]=temp;\\n    }\\n    public void reverseString(char[] s) {\\n        int f=0;\\n        int l=s.length-1;\\n        while(l>f){\\n            swap(s, f, l);\\n            f++;\\n            l--;\\n        }\\n    }\\n}\\n```\n```\\n\\nclass Solution {            \\n    static char[] swap(char[] s, int a,int b ){\\n        char temp=s[a];\\n        s[a]=s[b];\\n        s[b]=temp;\\n        return s;\\n    }\\n    void foo(char[] s, int low, int high){\\n        if(high-low+1<=1) return;\\n        swap(s, low, high);\\n        foo(s, low+1, high-1);\\n    }\\n    public void reverseString(char[] s) {\\n        foo(s, 0, s.length-1);\\n        \\n    }\\n}\\n\\n```\n```\\nclass Solution {         \\n    static char[] swap(char[] s, int a,int b ){\\n        char temp=s[a];\\n        s[a]=s[b];\\n        s[b]=temp;\\n        return s;\\n    }\\n    void foo(char[] s, int low, int high){\\n        while(high>low){\\n            swap(s, low, high);\\n            high--;\\n            low++;\\n        }\\n    }\\n    public void reverseString(char[] s) {\\n        foo(s, 0, s.length-1);\\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3122269,
                "title": "2-approaches-using-1-pointer-and-2-pointers",
                "content": "# Approach 1 (Using 1 pointer)\\n<!-- Describe your approach to solving the problem. -->\\nIt uses a for loop to iterate through the string. It then swaps the first and last characters, then second and second-to-last, etc. until it reaches the middle of the string.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int n = s.length;\\n    for(int i=0; i<n/2;i++){\\n        char temp = s[n-i-1];\\n    s[n-i-1]=s[i];\\n    s[i]=temp;\\n    }\\n    }\\n}\\n```\\n\\n# Approach 2 (Two-pointers)\\n<!-- Describe your approach to solving the problem. -->\\nIt uses a while loop to swap the first and last characters of the string. It then increments i and decrements j, so that the next time through the loop, it will swap the second and second-to-last characters. This continues until i is greater than or equal to j.\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int i=0;\\n        int j=s.length-1;\\n        while(i<j){\\n            char temp = s[i];\\n            s[i]= s[j];\\n            s[j]=temp;\\n            i++;\\n            j--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int n = s.length;\\n    for(int i=0; i<n/2;i++){\\n        char temp = s[n-i-1];\\n    s[n-i-1]=s[i];\\n    s[i]=temp;\\n    }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int i=0;\\n        int j=s.length-1;\\n        while(i<j){\\n            char temp = s[i];\\n            s[i]= s[j];\\n            s[j]=temp;\\n            i++;\\n            j--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3102401,
                "title": "java-1sm",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int low = 0, high = s.length-1;\\n        while(low<=high){\\n            char temp = s[low];\\n            s[low] = s[high];\\n            s[high] = temp;\\n            low++;\\n            high--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int low = 0, high = s.length-1;\\n        while(low<=high){\\n            char temp = s[low];\\n            s[low] = s[high];\\n            s[high] = temp;\\n            low++;\\n            high--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3099243,
                "title": "c-4-approaches-recursion-two-pointers-stack-and-vector-1-line-solution-easy",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code - 1 - Using RECURSION\\n```\\nclass Solution {\\npublic:\\n    void reverse (string &str, int start, int end)\\n    {\\n        // base case - condition to stop recursion - when the string is completely swapped\\n        if (start > end)\\n        {\\n            return ; \\n        }\\n        \\n        // ek case solve krdo baaki recursion lagado \\n        swap(str[start], str[end]) ;\\n        start ++; \\n        end --;\\n\\n        // recursive call\\n        reverse(str, start , end) ;\\n    }\\n    void reverseString(vector<char>& s) {\\n        string str ;\\n        for (int i = 0 ; i < s.size() ; i++)\\n        {\\n            str += s[i] ;\\n        }\\n\\n        reverse (str, 0, str.length() - 1 ); \\n        for (int i = 0 ; i < s.size() ; i++)\\n        {\\n            s[i] = str[i] ; \\n        }\\n    }\\n};\\n```\\n---\\n# Complexity\\n- Time complexity:$$O(n)$$ - n is the length of the string \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$ - no additional space used swapping done in the same input string \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code - 2\\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int size=s.size();\\n        int start=0;\\n        int end=size-1;\\n        while(start<=end){\\n            swap(s[start], s[end]);\\n            start++;\\n            end--;     \\n        }\\n    }\\n};\\n```\\n---\\n# Complexity\\n- Time complexity:$$O(n)$$ - n is the length of the string \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$ - additional space used in creating stack and a temporary string.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code - 3 \\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        stack<char> temp ; \\n        for (int i = 0  ; i < s.size() ; i++)\\n        {\\n            temp.push(s[i]);\\n        }\\n        vector<char> str ; \\n        for (int i = 0 ; i< s.size() ; i++)\\n        {\\n            str.push_back(temp.top());\\n            temp.pop();\\n        }\\n        s = str ; \\n    }\\n};\\n```\\n---\\n# Code - 4\\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        reverse (s.begin() , s.end()); \\n    }\\n};\\n```\\n![815a317f-9cdf-46e2-a397-af8869dafa2e_1673498197.3721023 (1).png](https://assets.leetcode.com/users/images/e3bac8f4-dfdf-4da5-87b7-ff156d028603_1674674117.7121313.png)\\n",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void reverse (string &str, int start, int end)\\n    {\\n        // base case - condition to stop recursion - when the string is completely swapped\\n        if (start > end)\\n        {\\n            return ; \\n        }\\n        \\n        // ek case solve krdo baaki recursion lagado \\n        swap(str[start], str[end]) ;\\n        start ++; \\n        end --;\\n\\n        // recursive call\\n        reverse(str, start , end) ;\\n    }\\n    void reverseString(vector<char>& s) {\\n        string str ;\\n        for (int i = 0 ; i < s.size() ; i++)\\n        {\\n            str += s[i] ;\\n        }\\n\\n        reverse (str, 0, str.length() - 1 ); \\n        for (int i = 0 ; i < s.size() ; i++)\\n        {\\n            s[i] = str[i] ; \\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int size=s.size();\\n        int start=0;\\n        int end=size-1;\\n        while(start<=end){\\n            swap(s[start], s[end]);\\n            start++;\\n            end--;     \\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        stack<char> temp ; \\n        for (int i = 0  ; i < s.size() ; i++)\\n        {\\n            temp.push(s[i]);\\n        }\\n        vector<char> str ; \\n        for (int i = 0 ; i< s.size() ; i++)\\n        {\\n            str.push_back(temp.top());\\n            temp.pop();\\n        }\\n        s = str ; \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        reverse (s.begin() , s.end()); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3068220,
                "title": "java-0ms",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int low=0;\\n        int high=s.length-1;\\n        \\n        while (low<high){\\n            Character temp=s[low];\\n            s[low]=s[high];\\n            s[high]=temp;\\n            low++;high--;\\n            \\n        }\\n            \\n      \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int low=0;\\n        int high=s.length-1;\\n        \\n        while (low<high){\\n            Character temp=s[low];\\n            s[low]=s[high];\\n            s[high]=temp;\\n            low++;high--;\\n            \\n        }\\n            \\n      \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3046564,
                "title": "c-solution-easiest",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTwo Pointer\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTake one pointer from the start another from the end swap them and itrate forward and backward respectively until Both the pointers meet.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int i=0;\\n        int n=s.size()-1;\\n        while(i<n){\\n            swap(s[i],s[n]);\\n            i++;\\n            n--;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int i=0;\\n        int n=s.size()-1;\\n        while(i<n){\\n            swap(s[i],s[n]);\\n            i++;\\n            n--;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3027083,
                "title": "python3-two-pointers-approach-and-using-string-function",
                "content": "# Code1 Using Two Pointers\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        l,r=0,len(s)-1\\n        while l<r:\\n            s[l],s[r]=s[r],s[l]\\n            l+=1\\n            r-=1\\n```\\n# Code2 Using Function\\n```\\n\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        s.reverse()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        l,r=0,len(s)-1\\n        while l<r:\\n            s[l],s[r]=s[r],s[l]\\n            l+=1\\n            r-=1\\n```\n```\\n\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        s.reverse()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017968,
                "title": "c-solution-easy-and-simple-one-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        reverse(s.begin(),s.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        reverse(s.begin(),s.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2888083,
                "title": "c-easy-solution-simple-swapping",
                "content": "# Intuition\\nEasy to understand and two pointer approach.\\n\\n# Approach\\nA simple approach to run a loop which runs for n/2 times and for each iteration their is a swapping take place between the ith index  element and the element at (n-i-1)th index element.\\n\\n# Complexity\\n- Time complexity:\\no(n)\\n\\n- Space complexity:\\no(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        for(int i=0;i<s.size()/2;i++){\\n            swap(s[i],s[s.size()-i-1]);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        for(int i=0;i<s.size()/2;i++){\\n            swap(s[i],s[s.size()-i-1]);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2826849,
                "title": "easy-java-two-pointers-xor-reverse-solution",
                "content": "# Complexity\\n- Time complexity: **O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int start = 0;\\n        int end = s.length - 1;\\n\\n        while(start < end) {\\n            s[start] ^= s[end];\\n            s[end] ^= s[start];\\n            s[start++] ^= s[end--];\\n        }\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "String",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int start = 0;\\n        int end = s.length - 1;\\n\\n        while(start < end) {\\n            s[start] ^= s[end];\\n            s[end] ^= s[start];\\n            s[start++] ^= s[end--];\\n        }\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2799603,
                "title": "easy-clear-and-classic-solution-javascript",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {character[]} s\\n * @return {void} Do not return anything, modify s in-place instead.\\n */\\nvar reverseString = function(s) {\\n    let left = 0, right = s.length -1;\\n\\n    while( left <= right ) {\\n        let temp = s[right];\\n        s[right] = s[left]\\n        s[left] = temp\\n        left++;\\n        right--;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\n/**\\n * @param {character[]} s\\n * @return {void} Do not return anything, modify s in-place instead.\\n */\\nvar reverseString = function(s) {\\n    let left = 0, right = s.length -1;\\n\\n    while( left <= right ) {\\n        let temp = s[right];\\n        s[right] = s[left]\\n        s[left] = temp\\n        left++;\\n        right--;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2781972,
                "title": "java-2-liner-solution",
                "content": "\\n```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        for (int i = 0, j = s.length - 1; i < j; ++i, --j) {\\n            char t = s[i];\\n            s[i] = s[j];\\n            s[j] = t;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        for (int i = 0, j = s.length - 1; i < j; ++i, --j) {\\n            char t = s[i];\\n            s[i] = s[j];\\n            s[j] = t;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2736090,
                "title": "easy-c-two-pointer-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int start=0,end=s.size()-1;\\n        while(start<end){\\n            char temp=s[start];\\n            s[start++]=s[end];\\n            s[end--]=temp;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int start=0,end=s.size()-1;\\n        while(start<end){\\n            char temp=s[start];\\n            s[start++]=s[end];\\n            s[end--]=temp;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565421,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/reverse-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion, In-Place, $$\\mathcal{O}(N)$$ Space\n\n  \n**Approach 2:** Two Pointers, Iteration, $$\\mathcal{O}(1)$$ Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hukun01",
                        "content": "There are basically two ways to solve this problem. \\n\\nOne is to use a StringBuilder, another is to reverse the underlying char array. \\n\\nFor C/C++ programmers, they may want to modify the input string if it's not constant, so to achieve O(1) space.\\n\\nHowever, for Java programmers, I don't see any improvement beyond O(n) time and space. This is no different from reversing an integer array...What's the point here?"
                    },
                    {
                        "username": "Matt17283940",
                        "content": "Two pointers is O(1) space complexity, no new data structure created"
                    },
                    {
                        "username": "likeshkrishnakaranammuralidhar",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "[@ravitejaDev](/ravitejaDev) thanks a lot!"
                    },
                    {
                        "username": "ravitejaDev",
                        "content": "[@OMOH_PA](/OMOH_PA) within function it will be changing, but s given is from outside the function. As mentioned in the question, u need to do in-place instead of overwriting s within the function. which doesn't make any change to outside list. \nu can use s[:] = s[::-1] instead of just s = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "could any1 explain plz why \"s = s[::-1]\" not working...\nI mean if I print result of \ns = s[::-1] i'm gettting proper answer, but it does not work for the solution\n\n\ns =\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nExpected\n[\"o\",\"l\",\"l\",\"e\",\"h\"]\nStdout\n['o', 'l', 'l', 'e', 'h']\n"
                    },
                    {
                        "username": "hankerkuo",
                        "content": "When I try to run the code with default Testcase, this error appeared, wondering what\\'s the problem here.\\nTestcase and code are default settings (python). ![image](https://assets.leetcode.com/users/hankerkuo/image_1583373557.png)\\n"
                    },
                    {
                        "username": "Hemant069",
                        "content": "\\n s.reverse()"
                    },
                    {
                        "username": "troysleet",
                        "content": "[@ajaiverma](/ajaiverma) That\\'s helpful to know, thanks!"
                    },
                    {
                        "username": "ajaiverma",
                        "content": "[@sozani](/sozani) most of the time, using built in functions are not allowed in interview, you have to create you own algorithm to solve the problem."
                    },
                    {
                        "username": "sozani",
                        "content": "Why don't the most of people  use this approach although I used it?Is it wrong or more space complexity"
                    },
                    {
                        "username": "fuxinwei",
                        "content": "I test with Python solution `s = s[::-1]` but it always got wrong. Does someone know the reason?"
                    },
                    {
                        "username": "Supreeth_HR",
                        "content": "[@Sanchit33](/Sanchit33) works for list as well"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "[@Sanchit33](/Sanchit33) It works in Local environment"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "[@Sanchit33](/Sanchit33) try this s[:] = s[::-1]"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "This method only works for string"
                    },
                    {
                        "username": "ronilpatil",
                        "content": "Actually python create another reference in `s = s[ : : -1]` case, you want to modify in-place na ! Simply `s = s[ : : -1]` it will re-bind the name but `s[:]` will replace whatever previously inside the list. "
                    },
                    {
                        "username": "saugat263",
                        "content": "[@shivam1100](/shivam1100) hey shivam, can you explain how does python compiles and runs over here, i\\'m kinda confused"
                    },
                    {
                        "username": "shivam1100",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "bubbafat",
                        "content": "Even iterating over the array without updates times out."
                    },
                    {
                        "username": "hazemati",
                        "content": "So, just want to give some feedback on the C version of this. Usualliy when htis is asked, the size is not passed in, but it should be assumed that the string is null-terminated (thus the size can be gotten by using strlen."
                    },
                    {
                        "username": "Yodawgz0",
                        "content": "\\n###Runtime: 192 ms, faster than 98.57% of Python3 online submissions for Reverse String.\\n###Memory Usage: 19.1 MB, less than 6.54% of Python3 online submissions for Reverse String.\\nBut it is a memory hogger , as we are doubling the space requirement\\n\\n\\'\\'\\'\\n\\n    def reverseString(self, s: List[str]) -> None:\\n        s.extend(s[::-1])\\n        del s[:int(len(s)/2)]\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "navyaswarup2004",
                        "content": "Where is the print statement?\\n"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "not needed"
                    }
                ]
            },
            {
                "id": 1565227,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/reverse-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion, In-Place, $$\\mathcal{O}(N)$$ Space\n\n  \n**Approach 2:** Two Pointers, Iteration, $$\\mathcal{O}(1)$$ Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hukun01",
                        "content": "There are basically two ways to solve this problem. \\n\\nOne is to use a StringBuilder, another is to reverse the underlying char array. \\n\\nFor C/C++ programmers, they may want to modify the input string if it's not constant, so to achieve O(1) space.\\n\\nHowever, for Java programmers, I don't see any improvement beyond O(n) time and space. This is no different from reversing an integer array...What's the point here?"
                    },
                    {
                        "username": "Matt17283940",
                        "content": "Two pointers is O(1) space complexity, no new data structure created"
                    },
                    {
                        "username": "likeshkrishnakaranammuralidhar",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "[@ravitejaDev](/ravitejaDev) thanks a lot!"
                    },
                    {
                        "username": "ravitejaDev",
                        "content": "[@OMOH_PA](/OMOH_PA) within function it will be changing, but s given is from outside the function. As mentioned in the question, u need to do in-place instead of overwriting s within the function. which doesn't make any change to outside list. \nu can use s[:] = s[::-1] instead of just s = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "could any1 explain plz why \"s = s[::-1]\" not working...\nI mean if I print result of \ns = s[::-1] i'm gettting proper answer, but it does not work for the solution\n\n\ns =\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nExpected\n[\"o\",\"l\",\"l\",\"e\",\"h\"]\nStdout\n['o', 'l', 'l', 'e', 'h']\n"
                    },
                    {
                        "username": "hankerkuo",
                        "content": "When I try to run the code with default Testcase, this error appeared, wondering what\\'s the problem here.\\nTestcase and code are default settings (python). ![image](https://assets.leetcode.com/users/hankerkuo/image_1583373557.png)\\n"
                    },
                    {
                        "username": "Hemant069",
                        "content": "\\n s.reverse()"
                    },
                    {
                        "username": "troysleet",
                        "content": "[@ajaiverma](/ajaiverma) That\\'s helpful to know, thanks!"
                    },
                    {
                        "username": "ajaiverma",
                        "content": "[@sozani](/sozani) most of the time, using built in functions are not allowed in interview, you have to create you own algorithm to solve the problem."
                    },
                    {
                        "username": "sozani",
                        "content": "Why don't the most of people  use this approach although I used it?Is it wrong or more space complexity"
                    },
                    {
                        "username": "fuxinwei",
                        "content": "I test with Python solution `s = s[::-1]` but it always got wrong. Does someone know the reason?"
                    },
                    {
                        "username": "Supreeth_HR",
                        "content": "[@Sanchit33](/Sanchit33) works for list as well"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "[@Sanchit33](/Sanchit33) It works in Local environment"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "[@Sanchit33](/Sanchit33) try this s[:] = s[::-1]"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "This method only works for string"
                    },
                    {
                        "username": "ronilpatil",
                        "content": "Actually python create another reference in `s = s[ : : -1]` case, you want to modify in-place na ! Simply `s = s[ : : -1]` it will re-bind the name but `s[:]` will replace whatever previously inside the list. "
                    },
                    {
                        "username": "saugat263",
                        "content": "[@shivam1100](/shivam1100) hey shivam, can you explain how does python compiles and runs over here, i\\'m kinda confused"
                    },
                    {
                        "username": "shivam1100",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "bubbafat",
                        "content": "Even iterating over the array without updates times out."
                    },
                    {
                        "username": "hazemati",
                        "content": "So, just want to give some feedback on the C version of this. Usualliy when htis is asked, the size is not passed in, but it should be assumed that the string is null-terminated (thus the size can be gotten by using strlen."
                    },
                    {
                        "username": "Yodawgz0",
                        "content": "\\n###Runtime: 192 ms, faster than 98.57% of Python3 online submissions for Reverse String.\\n###Memory Usage: 19.1 MB, less than 6.54% of Python3 online submissions for Reverse String.\\nBut it is a memory hogger , as we are doubling the space requirement\\n\\n\\'\\'\\'\\n\\n    def reverseString(self, s: List[str]) -> None:\\n        s.extend(s[::-1])\\n        del s[:int(len(s)/2)]\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "navyaswarup2004",
                        "content": "Where is the print statement?\\n"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "not needed"
                    }
                ]
            },
            {
                "id": 1576342,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/reverse-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion, In-Place, $$\\mathcal{O}(N)$$ Space\n\n  \n**Approach 2:** Two Pointers, Iteration, $$\\mathcal{O}(1)$$ Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hukun01",
                        "content": "There are basically two ways to solve this problem. \\n\\nOne is to use a StringBuilder, another is to reverse the underlying char array. \\n\\nFor C/C++ programmers, they may want to modify the input string if it's not constant, so to achieve O(1) space.\\n\\nHowever, for Java programmers, I don't see any improvement beyond O(n) time and space. This is no different from reversing an integer array...What's the point here?"
                    },
                    {
                        "username": "Matt17283940",
                        "content": "Two pointers is O(1) space complexity, no new data structure created"
                    },
                    {
                        "username": "likeshkrishnakaranammuralidhar",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "[@ravitejaDev](/ravitejaDev) thanks a lot!"
                    },
                    {
                        "username": "ravitejaDev",
                        "content": "[@OMOH_PA](/OMOH_PA) within function it will be changing, but s given is from outside the function. As mentioned in the question, u need to do in-place instead of overwriting s within the function. which doesn't make any change to outside list. \nu can use s[:] = s[::-1] instead of just s = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "could any1 explain plz why \"s = s[::-1]\" not working...\nI mean if I print result of \ns = s[::-1] i'm gettting proper answer, but it does not work for the solution\n\n\ns =\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nExpected\n[\"o\",\"l\",\"l\",\"e\",\"h\"]\nStdout\n['o', 'l', 'l', 'e', 'h']\n"
                    },
                    {
                        "username": "hankerkuo",
                        "content": "When I try to run the code with default Testcase, this error appeared, wondering what\\'s the problem here.\\nTestcase and code are default settings (python). ![image](https://assets.leetcode.com/users/hankerkuo/image_1583373557.png)\\n"
                    },
                    {
                        "username": "Hemant069",
                        "content": "\\n s.reverse()"
                    },
                    {
                        "username": "troysleet",
                        "content": "[@ajaiverma](/ajaiverma) That\\'s helpful to know, thanks!"
                    },
                    {
                        "username": "ajaiverma",
                        "content": "[@sozani](/sozani) most of the time, using built in functions are not allowed in interview, you have to create you own algorithm to solve the problem."
                    },
                    {
                        "username": "sozani",
                        "content": "Why don't the most of people  use this approach although I used it?Is it wrong or more space complexity"
                    },
                    {
                        "username": "fuxinwei",
                        "content": "I test with Python solution `s = s[::-1]` but it always got wrong. Does someone know the reason?"
                    },
                    {
                        "username": "Supreeth_HR",
                        "content": "[@Sanchit33](/Sanchit33) works for list as well"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "[@Sanchit33](/Sanchit33) It works in Local environment"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "[@Sanchit33](/Sanchit33) try this s[:] = s[::-1]"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "This method only works for string"
                    },
                    {
                        "username": "ronilpatil",
                        "content": "Actually python create another reference in `s = s[ : : -1]` case, you want to modify in-place na ! Simply `s = s[ : : -1]` it will re-bind the name but `s[:]` will replace whatever previously inside the list. "
                    },
                    {
                        "username": "saugat263",
                        "content": "[@shivam1100](/shivam1100) hey shivam, can you explain how does python compiles and runs over here, i\\'m kinda confused"
                    },
                    {
                        "username": "shivam1100",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "bubbafat",
                        "content": "Even iterating over the array without updates times out."
                    },
                    {
                        "username": "hazemati",
                        "content": "So, just want to give some feedback on the C version of this. Usualliy when htis is asked, the size is not passed in, but it should be assumed that the string is null-terminated (thus the size can be gotten by using strlen."
                    },
                    {
                        "username": "Yodawgz0",
                        "content": "\\n###Runtime: 192 ms, faster than 98.57% of Python3 online submissions for Reverse String.\\n###Memory Usage: 19.1 MB, less than 6.54% of Python3 online submissions for Reverse String.\\nBut it is a memory hogger , as we are doubling the space requirement\\n\\n\\'\\'\\'\\n\\n    def reverseString(self, s: List[str]) -> None:\\n        s.extend(s[::-1])\\n        del s[:int(len(s)/2)]\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "navyaswarup2004",
                        "content": "Where is the print statement?\\n"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "not needed"
                    }
                ]
            },
            {
                "id": 1565778,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/reverse-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion, In-Place, $$\\mathcal{O}(N)$$ Space\n\n  \n**Approach 2:** Two Pointers, Iteration, $$\\mathcal{O}(1)$$ Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hukun01",
                        "content": "There are basically two ways to solve this problem. \\n\\nOne is to use a StringBuilder, another is to reverse the underlying char array. \\n\\nFor C/C++ programmers, they may want to modify the input string if it's not constant, so to achieve O(1) space.\\n\\nHowever, for Java programmers, I don't see any improvement beyond O(n) time and space. This is no different from reversing an integer array...What's the point here?"
                    },
                    {
                        "username": "Matt17283940",
                        "content": "Two pointers is O(1) space complexity, no new data structure created"
                    },
                    {
                        "username": "likeshkrishnakaranammuralidhar",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "[@ravitejaDev](/ravitejaDev) thanks a lot!"
                    },
                    {
                        "username": "ravitejaDev",
                        "content": "[@OMOH_PA](/OMOH_PA) within function it will be changing, but s given is from outside the function. As mentioned in the question, u need to do in-place instead of overwriting s within the function. which doesn't make any change to outside list. \nu can use s[:] = s[::-1] instead of just s = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "could any1 explain plz why \"s = s[::-1]\" not working...\nI mean if I print result of \ns = s[::-1] i'm gettting proper answer, but it does not work for the solution\n\n\ns =\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nExpected\n[\"o\",\"l\",\"l\",\"e\",\"h\"]\nStdout\n['o', 'l', 'l', 'e', 'h']\n"
                    },
                    {
                        "username": "hankerkuo",
                        "content": "When I try to run the code with default Testcase, this error appeared, wondering what\\'s the problem here.\\nTestcase and code are default settings (python). ![image](https://assets.leetcode.com/users/hankerkuo/image_1583373557.png)\\n"
                    },
                    {
                        "username": "Hemant069",
                        "content": "\\n s.reverse()"
                    },
                    {
                        "username": "troysleet",
                        "content": "[@ajaiverma](/ajaiverma) That\\'s helpful to know, thanks!"
                    },
                    {
                        "username": "ajaiverma",
                        "content": "[@sozani](/sozani) most of the time, using built in functions are not allowed in interview, you have to create you own algorithm to solve the problem."
                    },
                    {
                        "username": "sozani",
                        "content": "Why don't the most of people  use this approach although I used it?Is it wrong or more space complexity"
                    },
                    {
                        "username": "fuxinwei",
                        "content": "I test with Python solution `s = s[::-1]` but it always got wrong. Does someone know the reason?"
                    },
                    {
                        "username": "Supreeth_HR",
                        "content": "[@Sanchit33](/Sanchit33) works for list as well"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "[@Sanchit33](/Sanchit33) It works in Local environment"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "[@Sanchit33](/Sanchit33) try this s[:] = s[::-1]"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "This method only works for string"
                    },
                    {
                        "username": "ronilpatil",
                        "content": "Actually python create another reference in `s = s[ : : -1]` case, you want to modify in-place na ! Simply `s = s[ : : -1]` it will re-bind the name but `s[:]` will replace whatever previously inside the list. "
                    },
                    {
                        "username": "saugat263",
                        "content": "[@shivam1100](/shivam1100) hey shivam, can you explain how does python compiles and runs over here, i\\'m kinda confused"
                    },
                    {
                        "username": "shivam1100",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "bubbafat",
                        "content": "Even iterating over the array without updates times out."
                    },
                    {
                        "username": "hazemati",
                        "content": "So, just want to give some feedback on the C version of this. Usualliy when htis is asked, the size is not passed in, but it should be assumed that the string is null-terminated (thus the size can be gotten by using strlen."
                    },
                    {
                        "username": "Yodawgz0",
                        "content": "\\n###Runtime: 192 ms, faster than 98.57% of Python3 online submissions for Reverse String.\\n###Memory Usage: 19.1 MB, less than 6.54% of Python3 online submissions for Reverse String.\\nBut it is a memory hogger , as we are doubling the space requirement\\n\\n\\'\\'\\'\\n\\n    def reverseString(self, s: List[str]) -> None:\\n        s.extend(s[::-1])\\n        del s[:int(len(s)/2)]\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "navyaswarup2004",
                        "content": "Where is the print statement?\\n"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "not needed"
                    }
                ]
            },
            {
                "id": 1576863,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/reverse-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion, In-Place, $$\\mathcal{O}(N)$$ Space\n\n  \n**Approach 2:** Two Pointers, Iteration, $$\\mathcal{O}(1)$$ Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hukun01",
                        "content": "There are basically two ways to solve this problem. \\n\\nOne is to use a StringBuilder, another is to reverse the underlying char array. \\n\\nFor C/C++ programmers, they may want to modify the input string if it's not constant, so to achieve O(1) space.\\n\\nHowever, for Java programmers, I don't see any improvement beyond O(n) time and space. This is no different from reversing an integer array...What's the point here?"
                    },
                    {
                        "username": "Matt17283940",
                        "content": "Two pointers is O(1) space complexity, no new data structure created"
                    },
                    {
                        "username": "likeshkrishnakaranammuralidhar",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "[@ravitejaDev](/ravitejaDev) thanks a lot!"
                    },
                    {
                        "username": "ravitejaDev",
                        "content": "[@OMOH_PA](/OMOH_PA) within function it will be changing, but s given is from outside the function. As mentioned in the question, u need to do in-place instead of overwriting s within the function. which doesn't make any change to outside list. \nu can use s[:] = s[::-1] instead of just s = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "could any1 explain plz why \"s = s[::-1]\" not working...\nI mean if I print result of \ns = s[::-1] i'm gettting proper answer, but it does not work for the solution\n\n\ns =\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nExpected\n[\"o\",\"l\",\"l\",\"e\",\"h\"]\nStdout\n['o', 'l', 'l', 'e', 'h']\n"
                    },
                    {
                        "username": "hankerkuo",
                        "content": "When I try to run the code with default Testcase, this error appeared, wondering what\\'s the problem here.\\nTestcase and code are default settings (python). ![image](https://assets.leetcode.com/users/hankerkuo/image_1583373557.png)\\n"
                    },
                    {
                        "username": "Hemant069",
                        "content": "\\n s.reverse()"
                    },
                    {
                        "username": "troysleet",
                        "content": "[@ajaiverma](/ajaiverma) That\\'s helpful to know, thanks!"
                    },
                    {
                        "username": "ajaiverma",
                        "content": "[@sozani](/sozani) most of the time, using built in functions are not allowed in interview, you have to create you own algorithm to solve the problem."
                    },
                    {
                        "username": "sozani",
                        "content": "Why don't the most of people  use this approach although I used it?Is it wrong or more space complexity"
                    },
                    {
                        "username": "fuxinwei",
                        "content": "I test with Python solution `s = s[::-1]` but it always got wrong. Does someone know the reason?"
                    },
                    {
                        "username": "Supreeth_HR",
                        "content": "[@Sanchit33](/Sanchit33) works for list as well"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "[@Sanchit33](/Sanchit33) It works in Local environment"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "[@Sanchit33](/Sanchit33) try this s[:] = s[::-1]"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "This method only works for string"
                    },
                    {
                        "username": "ronilpatil",
                        "content": "Actually python create another reference in `s = s[ : : -1]` case, you want to modify in-place na ! Simply `s = s[ : : -1]` it will re-bind the name but `s[:]` will replace whatever previously inside the list. "
                    },
                    {
                        "username": "saugat263",
                        "content": "[@shivam1100](/shivam1100) hey shivam, can you explain how does python compiles and runs over here, i\\'m kinda confused"
                    },
                    {
                        "username": "shivam1100",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "bubbafat",
                        "content": "Even iterating over the array without updates times out."
                    },
                    {
                        "username": "hazemati",
                        "content": "So, just want to give some feedback on the C version of this. Usualliy when htis is asked, the size is not passed in, but it should be assumed that the string is null-terminated (thus the size can be gotten by using strlen."
                    },
                    {
                        "username": "Yodawgz0",
                        "content": "\\n###Runtime: 192 ms, faster than 98.57% of Python3 online submissions for Reverse String.\\n###Memory Usage: 19.1 MB, less than 6.54% of Python3 online submissions for Reverse String.\\nBut it is a memory hogger , as we are doubling the space requirement\\n\\n\\'\\'\\'\\n\\n    def reverseString(self, s: List[str]) -> None:\\n        s.extend(s[::-1])\\n        del s[:int(len(s)/2)]\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "navyaswarup2004",
                        "content": "Where is the print statement?\\n"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "not needed"
                    }
                ]
            },
            {
                "id": 1575420,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/reverse-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion, In-Place, $$\\mathcal{O}(N)$$ Space\n\n  \n**Approach 2:** Two Pointers, Iteration, $$\\mathcal{O}(1)$$ Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hukun01",
                        "content": "There are basically two ways to solve this problem. \\n\\nOne is to use a StringBuilder, another is to reverse the underlying char array. \\n\\nFor C/C++ programmers, they may want to modify the input string if it's not constant, so to achieve O(1) space.\\n\\nHowever, for Java programmers, I don't see any improvement beyond O(n) time and space. This is no different from reversing an integer array...What's the point here?"
                    },
                    {
                        "username": "Matt17283940",
                        "content": "Two pointers is O(1) space complexity, no new data structure created"
                    },
                    {
                        "username": "likeshkrishnakaranammuralidhar",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "[@ravitejaDev](/ravitejaDev) thanks a lot!"
                    },
                    {
                        "username": "ravitejaDev",
                        "content": "[@OMOH_PA](/OMOH_PA) within function it will be changing, but s given is from outside the function. As mentioned in the question, u need to do in-place instead of overwriting s within the function. which doesn't make any change to outside list. \nu can use s[:] = s[::-1] instead of just s = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "could any1 explain plz why \"s = s[::-1]\" not working...\nI mean if I print result of \ns = s[::-1] i'm gettting proper answer, but it does not work for the solution\n\n\ns =\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nExpected\n[\"o\",\"l\",\"l\",\"e\",\"h\"]\nStdout\n['o', 'l', 'l', 'e', 'h']\n"
                    },
                    {
                        "username": "hankerkuo",
                        "content": "When I try to run the code with default Testcase, this error appeared, wondering what\\'s the problem here.\\nTestcase and code are default settings (python). ![image](https://assets.leetcode.com/users/hankerkuo/image_1583373557.png)\\n"
                    },
                    {
                        "username": "Hemant069",
                        "content": "\\n s.reverse()"
                    },
                    {
                        "username": "troysleet",
                        "content": "[@ajaiverma](/ajaiverma) That\\'s helpful to know, thanks!"
                    },
                    {
                        "username": "ajaiverma",
                        "content": "[@sozani](/sozani) most of the time, using built in functions are not allowed in interview, you have to create you own algorithm to solve the problem."
                    },
                    {
                        "username": "sozani",
                        "content": "Why don't the most of people  use this approach although I used it?Is it wrong or more space complexity"
                    },
                    {
                        "username": "fuxinwei",
                        "content": "I test with Python solution `s = s[::-1]` but it always got wrong. Does someone know the reason?"
                    },
                    {
                        "username": "Supreeth_HR",
                        "content": "[@Sanchit33](/Sanchit33) works for list as well"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "[@Sanchit33](/Sanchit33) It works in Local environment"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "[@Sanchit33](/Sanchit33) try this s[:] = s[::-1]"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "This method only works for string"
                    },
                    {
                        "username": "ronilpatil",
                        "content": "Actually python create another reference in `s = s[ : : -1]` case, you want to modify in-place na ! Simply `s = s[ : : -1]` it will re-bind the name but `s[:]` will replace whatever previously inside the list. "
                    },
                    {
                        "username": "saugat263",
                        "content": "[@shivam1100](/shivam1100) hey shivam, can you explain how does python compiles and runs over here, i\\'m kinda confused"
                    },
                    {
                        "username": "shivam1100",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "bubbafat",
                        "content": "Even iterating over the array without updates times out."
                    },
                    {
                        "username": "hazemati",
                        "content": "So, just want to give some feedback on the C version of this. Usualliy when htis is asked, the size is not passed in, but it should be assumed that the string is null-terminated (thus the size can be gotten by using strlen."
                    },
                    {
                        "username": "Yodawgz0",
                        "content": "\\n###Runtime: 192 ms, faster than 98.57% of Python3 online submissions for Reverse String.\\n###Memory Usage: 19.1 MB, less than 6.54% of Python3 online submissions for Reverse String.\\nBut it is a memory hogger , as we are doubling the space requirement\\n\\n\\'\\'\\'\\n\\n    def reverseString(self, s: List[str]) -> None:\\n        s.extend(s[::-1])\\n        del s[:int(len(s)/2)]\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "navyaswarup2004",
                        "content": "Where is the print statement?\\n"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "not needed"
                    }
                ]
            },
            {
                "id": 1568172,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/reverse-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion, In-Place, $$\\mathcal{O}(N)$$ Space\n\n  \n**Approach 2:** Two Pointers, Iteration, $$\\mathcal{O}(1)$$ Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hukun01",
                        "content": "There are basically two ways to solve this problem. \\n\\nOne is to use a StringBuilder, another is to reverse the underlying char array. \\n\\nFor C/C++ programmers, they may want to modify the input string if it's not constant, so to achieve O(1) space.\\n\\nHowever, for Java programmers, I don't see any improvement beyond O(n) time and space. This is no different from reversing an integer array...What's the point here?"
                    },
                    {
                        "username": "Matt17283940",
                        "content": "Two pointers is O(1) space complexity, no new data structure created"
                    },
                    {
                        "username": "likeshkrishnakaranammuralidhar",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "[@ravitejaDev](/ravitejaDev) thanks a lot!"
                    },
                    {
                        "username": "ravitejaDev",
                        "content": "[@OMOH_PA](/OMOH_PA) within function it will be changing, but s given is from outside the function. As mentioned in the question, u need to do in-place instead of overwriting s within the function. which doesn't make any change to outside list. \nu can use s[:] = s[::-1] instead of just s = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "could any1 explain plz why \"s = s[::-1]\" not working...\nI mean if I print result of \ns = s[::-1] i'm gettting proper answer, but it does not work for the solution\n\n\ns =\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nExpected\n[\"o\",\"l\",\"l\",\"e\",\"h\"]\nStdout\n['o', 'l', 'l', 'e', 'h']\n"
                    },
                    {
                        "username": "hankerkuo",
                        "content": "When I try to run the code with default Testcase, this error appeared, wondering what\\'s the problem here.\\nTestcase and code are default settings (python). ![image](https://assets.leetcode.com/users/hankerkuo/image_1583373557.png)\\n"
                    },
                    {
                        "username": "Hemant069",
                        "content": "\\n s.reverse()"
                    },
                    {
                        "username": "troysleet",
                        "content": "[@ajaiverma](/ajaiverma) That\\'s helpful to know, thanks!"
                    },
                    {
                        "username": "ajaiverma",
                        "content": "[@sozani](/sozani) most of the time, using built in functions are not allowed in interview, you have to create you own algorithm to solve the problem."
                    },
                    {
                        "username": "sozani",
                        "content": "Why don't the most of people  use this approach although I used it?Is it wrong or more space complexity"
                    },
                    {
                        "username": "fuxinwei",
                        "content": "I test with Python solution `s = s[::-1]` but it always got wrong. Does someone know the reason?"
                    },
                    {
                        "username": "Supreeth_HR",
                        "content": "[@Sanchit33](/Sanchit33) works for list as well"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "[@Sanchit33](/Sanchit33) It works in Local environment"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "[@Sanchit33](/Sanchit33) try this s[:] = s[::-1]"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "This method only works for string"
                    },
                    {
                        "username": "ronilpatil",
                        "content": "Actually python create another reference in `s = s[ : : -1]` case, you want to modify in-place na ! Simply `s = s[ : : -1]` it will re-bind the name but `s[:]` will replace whatever previously inside the list. "
                    },
                    {
                        "username": "saugat263",
                        "content": "[@shivam1100](/shivam1100) hey shivam, can you explain how does python compiles and runs over here, i\\'m kinda confused"
                    },
                    {
                        "username": "shivam1100",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "bubbafat",
                        "content": "Even iterating over the array without updates times out."
                    },
                    {
                        "username": "hazemati",
                        "content": "So, just want to give some feedback on the C version of this. Usualliy when htis is asked, the size is not passed in, but it should be assumed that the string is null-terminated (thus the size can be gotten by using strlen."
                    },
                    {
                        "username": "Yodawgz0",
                        "content": "\\n###Runtime: 192 ms, faster than 98.57% of Python3 online submissions for Reverse String.\\n###Memory Usage: 19.1 MB, less than 6.54% of Python3 online submissions for Reverse String.\\nBut it is a memory hogger , as we are doubling the space requirement\\n\\n\\'\\'\\'\\n\\n    def reverseString(self, s: List[str]) -> None:\\n        s.extend(s[::-1])\\n        del s[:int(len(s)/2)]\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "navyaswarup2004",
                        "content": "Where is the print statement?\\n"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "not needed"
                    }
                ]
            },
            {
                "id": 1570092,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/reverse-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion, In-Place, $$\\mathcal{O}(N)$$ Space\n\n  \n**Approach 2:** Two Pointers, Iteration, $$\\mathcal{O}(1)$$ Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hukun01",
                        "content": "There are basically two ways to solve this problem. \\n\\nOne is to use a StringBuilder, another is to reverse the underlying char array. \\n\\nFor C/C++ programmers, they may want to modify the input string if it's not constant, so to achieve O(1) space.\\n\\nHowever, for Java programmers, I don't see any improvement beyond O(n) time and space. This is no different from reversing an integer array...What's the point here?"
                    },
                    {
                        "username": "Matt17283940",
                        "content": "Two pointers is O(1) space complexity, no new data structure created"
                    },
                    {
                        "username": "likeshkrishnakaranammuralidhar",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "[@ravitejaDev](/ravitejaDev) thanks a lot!"
                    },
                    {
                        "username": "ravitejaDev",
                        "content": "[@OMOH_PA](/OMOH_PA) within function it will be changing, but s given is from outside the function. As mentioned in the question, u need to do in-place instead of overwriting s within the function. which doesn't make any change to outside list. \nu can use s[:] = s[::-1] instead of just s = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "could any1 explain plz why \"s = s[::-1]\" not working...\nI mean if I print result of \ns = s[::-1] i'm gettting proper answer, but it does not work for the solution\n\n\ns =\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nExpected\n[\"o\",\"l\",\"l\",\"e\",\"h\"]\nStdout\n['o', 'l', 'l', 'e', 'h']\n"
                    },
                    {
                        "username": "hankerkuo",
                        "content": "When I try to run the code with default Testcase, this error appeared, wondering what\\'s the problem here.\\nTestcase and code are default settings (python). ![image](https://assets.leetcode.com/users/hankerkuo/image_1583373557.png)\\n"
                    },
                    {
                        "username": "Hemant069",
                        "content": "\\n s.reverse()"
                    },
                    {
                        "username": "troysleet",
                        "content": "[@ajaiverma](/ajaiverma) That\\'s helpful to know, thanks!"
                    },
                    {
                        "username": "ajaiverma",
                        "content": "[@sozani](/sozani) most of the time, using built in functions are not allowed in interview, you have to create you own algorithm to solve the problem."
                    },
                    {
                        "username": "sozani",
                        "content": "Why don't the most of people  use this approach although I used it?Is it wrong or more space complexity"
                    },
                    {
                        "username": "fuxinwei",
                        "content": "I test with Python solution `s = s[::-1]` but it always got wrong. Does someone know the reason?"
                    },
                    {
                        "username": "Supreeth_HR",
                        "content": "[@Sanchit33](/Sanchit33) works for list as well"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "[@Sanchit33](/Sanchit33) It works in Local environment"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "[@Sanchit33](/Sanchit33) try this s[:] = s[::-1]"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "This method only works for string"
                    },
                    {
                        "username": "ronilpatil",
                        "content": "Actually python create another reference in `s = s[ : : -1]` case, you want to modify in-place na ! Simply `s = s[ : : -1]` it will re-bind the name but `s[:]` will replace whatever previously inside the list. "
                    },
                    {
                        "username": "saugat263",
                        "content": "[@shivam1100](/shivam1100) hey shivam, can you explain how does python compiles and runs over here, i\\'m kinda confused"
                    },
                    {
                        "username": "shivam1100",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "bubbafat",
                        "content": "Even iterating over the array without updates times out."
                    },
                    {
                        "username": "hazemati",
                        "content": "So, just want to give some feedback on the C version of this. Usualliy when htis is asked, the size is not passed in, but it should be assumed that the string is null-terminated (thus the size can be gotten by using strlen."
                    },
                    {
                        "username": "Yodawgz0",
                        "content": "\\n###Runtime: 192 ms, faster than 98.57% of Python3 online submissions for Reverse String.\\n###Memory Usage: 19.1 MB, less than 6.54% of Python3 online submissions for Reverse String.\\nBut it is a memory hogger , as we are doubling the space requirement\\n\\n\\'\\'\\'\\n\\n    def reverseString(self, s: List[str]) -> None:\\n        s.extend(s[::-1])\\n        del s[:int(len(s)/2)]\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "navyaswarup2004",
                        "content": "Where is the print statement?\\n"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "not needed"
                    }
                ]
            },
            {
                "id": 1576630,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/reverse-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion, In-Place, $$\\mathcal{O}(N)$$ Space\n\n  \n**Approach 2:** Two Pointers, Iteration, $$\\mathcal{O}(1)$$ Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hukun01",
                        "content": "There are basically two ways to solve this problem. \\n\\nOne is to use a StringBuilder, another is to reverse the underlying char array. \\n\\nFor C/C++ programmers, they may want to modify the input string if it's not constant, so to achieve O(1) space.\\n\\nHowever, for Java programmers, I don't see any improvement beyond O(n) time and space. This is no different from reversing an integer array...What's the point here?"
                    },
                    {
                        "username": "Matt17283940",
                        "content": "Two pointers is O(1) space complexity, no new data structure created"
                    },
                    {
                        "username": "likeshkrishnakaranammuralidhar",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "[@ravitejaDev](/ravitejaDev) thanks a lot!"
                    },
                    {
                        "username": "ravitejaDev",
                        "content": "[@OMOH_PA](/OMOH_PA) within function it will be changing, but s given is from outside the function. As mentioned in the question, u need to do in-place instead of overwriting s within the function. which doesn't make any change to outside list. \nu can use s[:] = s[::-1] instead of just s = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "could any1 explain plz why \"s = s[::-1]\" not working...\nI mean if I print result of \ns = s[::-1] i'm gettting proper answer, but it does not work for the solution\n\n\ns =\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nExpected\n[\"o\",\"l\",\"l\",\"e\",\"h\"]\nStdout\n['o', 'l', 'l', 'e', 'h']\n"
                    },
                    {
                        "username": "hankerkuo",
                        "content": "When I try to run the code with default Testcase, this error appeared, wondering what\\'s the problem here.\\nTestcase and code are default settings (python). ![image](https://assets.leetcode.com/users/hankerkuo/image_1583373557.png)\\n"
                    },
                    {
                        "username": "Hemant069",
                        "content": "\\n s.reverse()"
                    },
                    {
                        "username": "troysleet",
                        "content": "[@ajaiverma](/ajaiverma) That\\'s helpful to know, thanks!"
                    },
                    {
                        "username": "ajaiverma",
                        "content": "[@sozani](/sozani) most of the time, using built in functions are not allowed in interview, you have to create you own algorithm to solve the problem."
                    },
                    {
                        "username": "sozani",
                        "content": "Why don't the most of people  use this approach although I used it?Is it wrong or more space complexity"
                    },
                    {
                        "username": "fuxinwei",
                        "content": "I test with Python solution `s = s[::-1]` but it always got wrong. Does someone know the reason?"
                    },
                    {
                        "username": "Supreeth_HR",
                        "content": "[@Sanchit33](/Sanchit33) works for list as well"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "[@Sanchit33](/Sanchit33) It works in Local environment"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "[@Sanchit33](/Sanchit33) try this s[:] = s[::-1]"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "This method only works for string"
                    },
                    {
                        "username": "ronilpatil",
                        "content": "Actually python create another reference in `s = s[ : : -1]` case, you want to modify in-place na ! Simply `s = s[ : : -1]` it will re-bind the name but `s[:]` will replace whatever previously inside the list. "
                    },
                    {
                        "username": "saugat263",
                        "content": "[@shivam1100](/shivam1100) hey shivam, can you explain how does python compiles and runs over here, i\\'m kinda confused"
                    },
                    {
                        "username": "shivam1100",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "bubbafat",
                        "content": "Even iterating over the array without updates times out."
                    },
                    {
                        "username": "hazemati",
                        "content": "So, just want to give some feedback on the C version of this. Usualliy when htis is asked, the size is not passed in, but it should be assumed that the string is null-terminated (thus the size can be gotten by using strlen."
                    },
                    {
                        "username": "Yodawgz0",
                        "content": "\\n###Runtime: 192 ms, faster than 98.57% of Python3 online submissions for Reverse String.\\n###Memory Usage: 19.1 MB, less than 6.54% of Python3 online submissions for Reverse String.\\nBut it is a memory hogger , as we are doubling the space requirement\\n\\n\\'\\'\\'\\n\\n    def reverseString(self, s: List[str]) -> None:\\n        s.extend(s[::-1])\\n        del s[:int(len(s)/2)]\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "navyaswarup2004",
                        "content": "Where is the print statement?\\n"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "not needed"
                    }
                ]
            },
            {
                "id": 1575562,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/reverse-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion, In-Place, $$\\mathcal{O}(N)$$ Space\n\n  \n**Approach 2:** Two Pointers, Iteration, $$\\mathcal{O}(1)$$ Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hukun01",
                        "content": "There are basically two ways to solve this problem. \\n\\nOne is to use a StringBuilder, another is to reverse the underlying char array. \\n\\nFor C/C++ programmers, they may want to modify the input string if it's not constant, so to achieve O(1) space.\\n\\nHowever, for Java programmers, I don't see any improvement beyond O(n) time and space. This is no different from reversing an integer array...What's the point here?"
                    },
                    {
                        "username": "Matt17283940",
                        "content": "Two pointers is O(1) space complexity, no new data structure created"
                    },
                    {
                        "username": "likeshkrishnakaranammuralidhar",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "[@ravitejaDev](/ravitejaDev) thanks a lot!"
                    },
                    {
                        "username": "ravitejaDev",
                        "content": "[@OMOH_PA](/OMOH_PA) within function it will be changing, but s given is from outside the function. As mentioned in the question, u need to do in-place instead of overwriting s within the function. which doesn't make any change to outside list. \nu can use s[:] = s[::-1] instead of just s = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "could any1 explain plz why \"s = s[::-1]\" not working...\nI mean if I print result of \ns = s[::-1] i'm gettting proper answer, but it does not work for the solution\n\n\ns =\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nExpected\n[\"o\",\"l\",\"l\",\"e\",\"h\"]\nStdout\n['o', 'l', 'l', 'e', 'h']\n"
                    },
                    {
                        "username": "hankerkuo",
                        "content": "When I try to run the code with default Testcase, this error appeared, wondering what\\'s the problem here.\\nTestcase and code are default settings (python). ![image](https://assets.leetcode.com/users/hankerkuo/image_1583373557.png)\\n"
                    },
                    {
                        "username": "Hemant069",
                        "content": "\\n s.reverse()"
                    },
                    {
                        "username": "troysleet",
                        "content": "[@ajaiverma](/ajaiverma) That\\'s helpful to know, thanks!"
                    },
                    {
                        "username": "ajaiverma",
                        "content": "[@sozani](/sozani) most of the time, using built in functions are not allowed in interview, you have to create you own algorithm to solve the problem."
                    },
                    {
                        "username": "sozani",
                        "content": "Why don't the most of people  use this approach although I used it?Is it wrong or more space complexity"
                    },
                    {
                        "username": "fuxinwei",
                        "content": "I test with Python solution `s = s[::-1]` but it always got wrong. Does someone know the reason?"
                    },
                    {
                        "username": "Supreeth_HR",
                        "content": "[@Sanchit33](/Sanchit33) works for list as well"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "[@Sanchit33](/Sanchit33) It works in Local environment"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "[@Sanchit33](/Sanchit33) try this s[:] = s[::-1]"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "This method only works for string"
                    },
                    {
                        "username": "ronilpatil",
                        "content": "Actually python create another reference in `s = s[ : : -1]` case, you want to modify in-place na ! Simply `s = s[ : : -1]` it will re-bind the name but `s[:]` will replace whatever previously inside the list. "
                    },
                    {
                        "username": "saugat263",
                        "content": "[@shivam1100](/shivam1100) hey shivam, can you explain how does python compiles and runs over here, i\\'m kinda confused"
                    },
                    {
                        "username": "shivam1100",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "bubbafat",
                        "content": "Even iterating over the array without updates times out."
                    },
                    {
                        "username": "hazemati",
                        "content": "So, just want to give some feedback on the C version of this. Usualliy when htis is asked, the size is not passed in, but it should be assumed that the string is null-terminated (thus the size can be gotten by using strlen."
                    },
                    {
                        "username": "Yodawgz0",
                        "content": "\\n###Runtime: 192 ms, faster than 98.57% of Python3 online submissions for Reverse String.\\n###Memory Usage: 19.1 MB, less than 6.54% of Python3 online submissions for Reverse String.\\nBut it is a memory hogger , as we are doubling the space requirement\\n\\n\\'\\'\\'\\n\\n    def reverseString(self, s: List[str]) -> None:\\n        s.extend(s[::-1])\\n        del s[:int(len(s)/2)]\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "navyaswarup2004",
                        "content": "Where is the print statement?\\n"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "not needed"
                    }
                ]
            },
            {
                "id": 1565421,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/reverse-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion, In-Place, $$\\mathcal{O}(N)$$ Space\n\n  \n**Approach 2:** Two Pointers, Iteration, $$\\mathcal{O}(1)$$ Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hukun01",
                        "content": "There are basically two ways to solve this problem. \\n\\nOne is to use a StringBuilder, another is to reverse the underlying char array. \\n\\nFor C/C++ programmers, they may want to modify the input string if it's not constant, so to achieve O(1) space.\\n\\nHowever, for Java programmers, I don't see any improvement beyond O(n) time and space. This is no different from reversing an integer array...What's the point here?"
                    },
                    {
                        "username": "Matt17283940",
                        "content": "Two pointers is O(1) space complexity, no new data structure created"
                    },
                    {
                        "username": "likeshkrishnakaranammuralidhar",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "[@ravitejaDev](/ravitejaDev) thanks a lot!"
                    },
                    {
                        "username": "ravitejaDev",
                        "content": "[@OMOH_PA](/OMOH_PA) within function it will be changing, but s given is from outside the function. As mentioned in the question, u need to do in-place instead of overwriting s within the function. which doesn't make any change to outside list. \nu can use s[:] = s[::-1] instead of just s = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "could any1 explain plz why \"s = s[::-1]\" not working...\nI mean if I print result of \ns = s[::-1] i'm gettting proper answer, but it does not work for the solution\n\n\ns =\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nExpected\n[\"o\",\"l\",\"l\",\"e\",\"h\"]\nStdout\n['o', 'l', 'l', 'e', 'h']\n"
                    },
                    {
                        "username": "hankerkuo",
                        "content": "When I try to run the code with default Testcase, this error appeared, wondering what\\'s the problem here.\\nTestcase and code are default settings (python). ![image](https://assets.leetcode.com/users/hankerkuo/image_1583373557.png)\\n"
                    },
                    {
                        "username": "Hemant069",
                        "content": "\\n s.reverse()"
                    },
                    {
                        "username": "troysleet",
                        "content": "[@ajaiverma](/ajaiverma) That\\'s helpful to know, thanks!"
                    },
                    {
                        "username": "ajaiverma",
                        "content": "[@sozani](/sozani) most of the time, using built in functions are not allowed in interview, you have to create you own algorithm to solve the problem."
                    },
                    {
                        "username": "sozani",
                        "content": "Why don't the most of people  use this approach although I used it?Is it wrong or more space complexity"
                    },
                    {
                        "username": "fuxinwei",
                        "content": "I test with Python solution `s = s[::-1]` but it always got wrong. Does someone know the reason?"
                    },
                    {
                        "username": "Supreeth_HR",
                        "content": "[@Sanchit33](/Sanchit33) works for list as well"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "[@Sanchit33](/Sanchit33) It works in Local environment"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "[@Sanchit33](/Sanchit33) try this s[:] = s[::-1]"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "This method only works for string"
                    },
                    {
                        "username": "ronilpatil",
                        "content": "Actually python create another reference in `s = s[ : : -1]` case, you want to modify in-place na ! Simply `s = s[ : : -1]` it will re-bind the name but `s[:]` will replace whatever previously inside the list. "
                    },
                    {
                        "username": "saugat263",
                        "content": "[@shivam1100](/shivam1100) hey shivam, can you explain how does python compiles and runs over here, i\\'m kinda confused"
                    },
                    {
                        "username": "shivam1100",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "bubbafat",
                        "content": "Even iterating over the array without updates times out."
                    },
                    {
                        "username": "hazemati",
                        "content": "So, just want to give some feedback on the C version of this. Usualliy when htis is asked, the size is not passed in, but it should be assumed that the string is null-terminated (thus the size can be gotten by using strlen."
                    },
                    {
                        "username": "Yodawgz0",
                        "content": "\\n###Runtime: 192 ms, faster than 98.57% of Python3 online submissions for Reverse String.\\n###Memory Usage: 19.1 MB, less than 6.54% of Python3 online submissions for Reverse String.\\nBut it is a memory hogger , as we are doubling the space requirement\\n\\n\\'\\'\\'\\n\\n    def reverseString(self, s: List[str]) -> None:\\n        s.extend(s[::-1])\\n        del s[:int(len(s)/2)]\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "navyaswarup2004",
                        "content": "Where is the print statement?\\n"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "not needed"
                    }
                ]
            },
            {
                "id": 1565227,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/reverse-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion, In-Place, $$\\mathcal{O}(N)$$ Space\n\n  \n**Approach 2:** Two Pointers, Iteration, $$\\mathcal{O}(1)$$ Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hukun01",
                        "content": "There are basically two ways to solve this problem. \\n\\nOne is to use a StringBuilder, another is to reverse the underlying char array. \\n\\nFor C/C++ programmers, they may want to modify the input string if it's not constant, so to achieve O(1) space.\\n\\nHowever, for Java programmers, I don't see any improvement beyond O(n) time and space. This is no different from reversing an integer array...What's the point here?"
                    },
                    {
                        "username": "Matt17283940",
                        "content": "Two pointers is O(1) space complexity, no new data structure created"
                    },
                    {
                        "username": "likeshkrishnakaranammuralidhar",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "[@ravitejaDev](/ravitejaDev) thanks a lot!"
                    },
                    {
                        "username": "ravitejaDev",
                        "content": "[@OMOH_PA](/OMOH_PA) within function it will be changing, but s given is from outside the function. As mentioned in the question, u need to do in-place instead of overwriting s within the function. which doesn't make any change to outside list. \nu can use s[:] = s[::-1] instead of just s = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "could any1 explain plz why \"s = s[::-1]\" not working...\nI mean if I print result of \ns = s[::-1] i'm gettting proper answer, but it does not work for the solution\n\n\ns =\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nExpected\n[\"o\",\"l\",\"l\",\"e\",\"h\"]\nStdout\n['o', 'l', 'l', 'e', 'h']\n"
                    },
                    {
                        "username": "hankerkuo",
                        "content": "When I try to run the code with default Testcase, this error appeared, wondering what\\'s the problem here.\\nTestcase and code are default settings (python). ![image](https://assets.leetcode.com/users/hankerkuo/image_1583373557.png)\\n"
                    },
                    {
                        "username": "Hemant069",
                        "content": "\\n s.reverse()"
                    },
                    {
                        "username": "troysleet",
                        "content": "[@ajaiverma](/ajaiverma) That\\'s helpful to know, thanks!"
                    },
                    {
                        "username": "ajaiverma",
                        "content": "[@sozani](/sozani) most of the time, using built in functions are not allowed in interview, you have to create you own algorithm to solve the problem."
                    },
                    {
                        "username": "sozani",
                        "content": "Why don't the most of people  use this approach although I used it?Is it wrong or more space complexity"
                    },
                    {
                        "username": "fuxinwei",
                        "content": "I test with Python solution `s = s[::-1]` but it always got wrong. Does someone know the reason?"
                    },
                    {
                        "username": "Supreeth_HR",
                        "content": "[@Sanchit33](/Sanchit33) works for list as well"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "[@Sanchit33](/Sanchit33) It works in Local environment"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "[@Sanchit33](/Sanchit33) try this s[:] = s[::-1]"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "This method only works for string"
                    },
                    {
                        "username": "ronilpatil",
                        "content": "Actually python create another reference in `s = s[ : : -1]` case, you want to modify in-place na ! Simply `s = s[ : : -1]` it will re-bind the name but `s[:]` will replace whatever previously inside the list. "
                    },
                    {
                        "username": "saugat263",
                        "content": "[@shivam1100](/shivam1100) hey shivam, can you explain how does python compiles and runs over here, i\\'m kinda confused"
                    },
                    {
                        "username": "shivam1100",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "bubbafat",
                        "content": "Even iterating over the array without updates times out."
                    },
                    {
                        "username": "hazemati",
                        "content": "So, just want to give some feedback on the C version of this. Usualliy when htis is asked, the size is not passed in, but it should be assumed that the string is null-terminated (thus the size can be gotten by using strlen."
                    },
                    {
                        "username": "Yodawgz0",
                        "content": "\\n###Runtime: 192 ms, faster than 98.57% of Python3 online submissions for Reverse String.\\n###Memory Usage: 19.1 MB, less than 6.54% of Python3 online submissions for Reverse String.\\nBut it is a memory hogger , as we are doubling the space requirement\\n\\n\\'\\'\\'\\n\\n    def reverseString(self, s: List[str]) -> None:\\n        s.extend(s[::-1])\\n        del s[:int(len(s)/2)]\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "navyaswarup2004",
                        "content": "Where is the print statement?\\n"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "not needed"
                    }
                ]
            },
            {
                "id": 1576342,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/reverse-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion, In-Place, $$\\mathcal{O}(N)$$ Space\n\n  \n**Approach 2:** Two Pointers, Iteration, $$\\mathcal{O}(1)$$ Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hukun01",
                        "content": "There are basically two ways to solve this problem. \\n\\nOne is to use a StringBuilder, another is to reverse the underlying char array. \\n\\nFor C/C++ programmers, they may want to modify the input string if it's not constant, so to achieve O(1) space.\\n\\nHowever, for Java programmers, I don't see any improvement beyond O(n) time and space. This is no different from reversing an integer array...What's the point here?"
                    },
                    {
                        "username": "Matt17283940",
                        "content": "Two pointers is O(1) space complexity, no new data structure created"
                    },
                    {
                        "username": "likeshkrishnakaranammuralidhar",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "[@ravitejaDev](/ravitejaDev) thanks a lot!"
                    },
                    {
                        "username": "ravitejaDev",
                        "content": "[@OMOH_PA](/OMOH_PA) within function it will be changing, but s given is from outside the function. As mentioned in the question, u need to do in-place instead of overwriting s within the function. which doesn't make any change to outside list. \nu can use s[:] = s[::-1] instead of just s = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "could any1 explain plz why \"s = s[::-1]\" not working...\nI mean if I print result of \ns = s[::-1] i'm gettting proper answer, but it does not work for the solution\n\n\ns =\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nExpected\n[\"o\",\"l\",\"l\",\"e\",\"h\"]\nStdout\n['o', 'l', 'l', 'e', 'h']\n"
                    },
                    {
                        "username": "hankerkuo",
                        "content": "When I try to run the code with default Testcase, this error appeared, wondering what\\'s the problem here.\\nTestcase and code are default settings (python). ![image](https://assets.leetcode.com/users/hankerkuo/image_1583373557.png)\\n"
                    },
                    {
                        "username": "Hemant069",
                        "content": "\\n s.reverse()"
                    },
                    {
                        "username": "troysleet",
                        "content": "[@ajaiverma](/ajaiverma) That\\'s helpful to know, thanks!"
                    },
                    {
                        "username": "ajaiverma",
                        "content": "[@sozani](/sozani) most of the time, using built in functions are not allowed in interview, you have to create you own algorithm to solve the problem."
                    },
                    {
                        "username": "sozani",
                        "content": "Why don't the most of people  use this approach although I used it?Is it wrong or more space complexity"
                    },
                    {
                        "username": "fuxinwei",
                        "content": "I test with Python solution `s = s[::-1]` but it always got wrong. Does someone know the reason?"
                    },
                    {
                        "username": "Supreeth_HR",
                        "content": "[@Sanchit33](/Sanchit33) works for list as well"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "[@Sanchit33](/Sanchit33) It works in Local environment"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "[@Sanchit33](/Sanchit33) try this s[:] = s[::-1]"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "This method only works for string"
                    },
                    {
                        "username": "ronilpatil",
                        "content": "Actually python create another reference in `s = s[ : : -1]` case, you want to modify in-place na ! Simply `s = s[ : : -1]` it will re-bind the name but `s[:]` will replace whatever previously inside the list. "
                    },
                    {
                        "username": "saugat263",
                        "content": "[@shivam1100](/shivam1100) hey shivam, can you explain how does python compiles and runs over here, i\\'m kinda confused"
                    },
                    {
                        "username": "shivam1100",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "bubbafat",
                        "content": "Even iterating over the array without updates times out."
                    },
                    {
                        "username": "hazemati",
                        "content": "So, just want to give some feedback on the C version of this. Usualliy when htis is asked, the size is not passed in, but it should be assumed that the string is null-terminated (thus the size can be gotten by using strlen."
                    },
                    {
                        "username": "Yodawgz0",
                        "content": "\\n###Runtime: 192 ms, faster than 98.57% of Python3 online submissions for Reverse String.\\n###Memory Usage: 19.1 MB, less than 6.54% of Python3 online submissions for Reverse String.\\nBut it is a memory hogger , as we are doubling the space requirement\\n\\n\\'\\'\\'\\n\\n    def reverseString(self, s: List[str]) -> None:\\n        s.extend(s[::-1])\\n        del s[:int(len(s)/2)]\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "navyaswarup2004",
                        "content": "Where is the print statement?\\n"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "not needed"
                    }
                ]
            },
            {
                "id": 1565778,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/reverse-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion, In-Place, $$\\mathcal{O}(N)$$ Space\n\n  \n**Approach 2:** Two Pointers, Iteration, $$\\mathcal{O}(1)$$ Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hukun01",
                        "content": "There are basically two ways to solve this problem. \\n\\nOne is to use a StringBuilder, another is to reverse the underlying char array. \\n\\nFor C/C++ programmers, they may want to modify the input string if it's not constant, so to achieve O(1) space.\\n\\nHowever, for Java programmers, I don't see any improvement beyond O(n) time and space. This is no different from reversing an integer array...What's the point here?"
                    },
                    {
                        "username": "Matt17283940",
                        "content": "Two pointers is O(1) space complexity, no new data structure created"
                    },
                    {
                        "username": "likeshkrishnakaranammuralidhar",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "[@ravitejaDev](/ravitejaDev) thanks a lot!"
                    },
                    {
                        "username": "ravitejaDev",
                        "content": "[@OMOH_PA](/OMOH_PA) within function it will be changing, but s given is from outside the function. As mentioned in the question, u need to do in-place instead of overwriting s within the function. which doesn't make any change to outside list. \nu can use s[:] = s[::-1] instead of just s = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "could any1 explain plz why \"s = s[::-1]\" not working...\nI mean if I print result of \ns = s[::-1] i'm gettting proper answer, but it does not work for the solution\n\n\ns =\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nExpected\n[\"o\",\"l\",\"l\",\"e\",\"h\"]\nStdout\n['o', 'l', 'l', 'e', 'h']\n"
                    },
                    {
                        "username": "hankerkuo",
                        "content": "When I try to run the code with default Testcase, this error appeared, wondering what\\'s the problem here.\\nTestcase and code are default settings (python). ![image](https://assets.leetcode.com/users/hankerkuo/image_1583373557.png)\\n"
                    },
                    {
                        "username": "Hemant069",
                        "content": "\\n s.reverse()"
                    },
                    {
                        "username": "troysleet",
                        "content": "[@ajaiverma](/ajaiverma) That\\'s helpful to know, thanks!"
                    },
                    {
                        "username": "ajaiverma",
                        "content": "[@sozani](/sozani) most of the time, using built in functions are not allowed in interview, you have to create you own algorithm to solve the problem."
                    },
                    {
                        "username": "sozani",
                        "content": "Why don't the most of people  use this approach although I used it?Is it wrong or more space complexity"
                    },
                    {
                        "username": "fuxinwei",
                        "content": "I test with Python solution `s = s[::-1]` but it always got wrong. Does someone know the reason?"
                    },
                    {
                        "username": "Supreeth_HR",
                        "content": "[@Sanchit33](/Sanchit33) works for list as well"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "[@Sanchit33](/Sanchit33) It works in Local environment"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "[@Sanchit33](/Sanchit33) try this s[:] = s[::-1]"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "This method only works for string"
                    },
                    {
                        "username": "ronilpatil",
                        "content": "Actually python create another reference in `s = s[ : : -1]` case, you want to modify in-place na ! Simply `s = s[ : : -1]` it will re-bind the name but `s[:]` will replace whatever previously inside the list. "
                    },
                    {
                        "username": "saugat263",
                        "content": "[@shivam1100](/shivam1100) hey shivam, can you explain how does python compiles and runs over here, i\\'m kinda confused"
                    },
                    {
                        "username": "shivam1100",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "bubbafat",
                        "content": "Even iterating over the array without updates times out."
                    },
                    {
                        "username": "hazemati",
                        "content": "So, just want to give some feedback on the C version of this. Usualliy when htis is asked, the size is not passed in, but it should be assumed that the string is null-terminated (thus the size can be gotten by using strlen."
                    },
                    {
                        "username": "Yodawgz0",
                        "content": "\\n###Runtime: 192 ms, faster than 98.57% of Python3 online submissions for Reverse String.\\n###Memory Usage: 19.1 MB, less than 6.54% of Python3 online submissions for Reverse String.\\nBut it is a memory hogger , as we are doubling the space requirement\\n\\n\\'\\'\\'\\n\\n    def reverseString(self, s: List[str]) -> None:\\n        s.extend(s[::-1])\\n        del s[:int(len(s)/2)]\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "navyaswarup2004",
                        "content": "Where is the print statement?\\n"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "not needed"
                    }
                ]
            },
            {
                "id": 1576863,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/reverse-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion, In-Place, $$\\mathcal{O}(N)$$ Space\n\n  \n**Approach 2:** Two Pointers, Iteration, $$\\mathcal{O}(1)$$ Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hukun01",
                        "content": "There are basically two ways to solve this problem. \\n\\nOne is to use a StringBuilder, another is to reverse the underlying char array. \\n\\nFor C/C++ programmers, they may want to modify the input string if it's not constant, so to achieve O(1) space.\\n\\nHowever, for Java programmers, I don't see any improvement beyond O(n) time and space. This is no different from reversing an integer array...What's the point here?"
                    },
                    {
                        "username": "Matt17283940",
                        "content": "Two pointers is O(1) space complexity, no new data structure created"
                    },
                    {
                        "username": "likeshkrishnakaranammuralidhar",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "[@ravitejaDev](/ravitejaDev) thanks a lot!"
                    },
                    {
                        "username": "ravitejaDev",
                        "content": "[@OMOH_PA](/OMOH_PA) within function it will be changing, but s given is from outside the function. As mentioned in the question, u need to do in-place instead of overwriting s within the function. which doesn't make any change to outside list. \nu can use s[:] = s[::-1] instead of just s = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "could any1 explain plz why \"s = s[::-1]\" not working...\nI mean if I print result of \ns = s[::-1] i'm gettting proper answer, but it does not work for the solution\n\n\ns =\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nExpected\n[\"o\",\"l\",\"l\",\"e\",\"h\"]\nStdout\n['o', 'l', 'l', 'e', 'h']\n"
                    },
                    {
                        "username": "hankerkuo",
                        "content": "When I try to run the code with default Testcase, this error appeared, wondering what\\'s the problem here.\\nTestcase and code are default settings (python). ![image](https://assets.leetcode.com/users/hankerkuo/image_1583373557.png)\\n"
                    },
                    {
                        "username": "Hemant069",
                        "content": "\\n s.reverse()"
                    },
                    {
                        "username": "troysleet",
                        "content": "[@ajaiverma](/ajaiverma) That\\'s helpful to know, thanks!"
                    },
                    {
                        "username": "ajaiverma",
                        "content": "[@sozani](/sozani) most of the time, using built in functions are not allowed in interview, you have to create you own algorithm to solve the problem."
                    },
                    {
                        "username": "sozani",
                        "content": "Why don't the most of people  use this approach although I used it?Is it wrong or more space complexity"
                    },
                    {
                        "username": "fuxinwei",
                        "content": "I test with Python solution `s = s[::-1]` but it always got wrong. Does someone know the reason?"
                    },
                    {
                        "username": "Supreeth_HR",
                        "content": "[@Sanchit33](/Sanchit33) works for list as well"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "[@Sanchit33](/Sanchit33) It works in Local environment"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "[@Sanchit33](/Sanchit33) try this s[:] = s[::-1]"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "This method only works for string"
                    },
                    {
                        "username": "ronilpatil",
                        "content": "Actually python create another reference in `s = s[ : : -1]` case, you want to modify in-place na ! Simply `s = s[ : : -1]` it will re-bind the name but `s[:]` will replace whatever previously inside the list. "
                    },
                    {
                        "username": "saugat263",
                        "content": "[@shivam1100](/shivam1100) hey shivam, can you explain how does python compiles and runs over here, i\\'m kinda confused"
                    },
                    {
                        "username": "shivam1100",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "bubbafat",
                        "content": "Even iterating over the array without updates times out."
                    },
                    {
                        "username": "hazemati",
                        "content": "So, just want to give some feedback on the C version of this. Usualliy when htis is asked, the size is not passed in, but it should be assumed that the string is null-terminated (thus the size can be gotten by using strlen."
                    },
                    {
                        "username": "Yodawgz0",
                        "content": "\\n###Runtime: 192 ms, faster than 98.57% of Python3 online submissions for Reverse String.\\n###Memory Usage: 19.1 MB, less than 6.54% of Python3 online submissions for Reverse String.\\nBut it is a memory hogger , as we are doubling the space requirement\\n\\n\\'\\'\\'\\n\\n    def reverseString(self, s: List[str]) -> None:\\n        s.extend(s[::-1])\\n        del s[:int(len(s)/2)]\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "navyaswarup2004",
                        "content": "Where is the print statement?\\n"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "not needed"
                    }
                ]
            },
            {
                "id": 1575420,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/reverse-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion, In-Place, $$\\mathcal{O}(N)$$ Space\n\n  \n**Approach 2:** Two Pointers, Iteration, $$\\mathcal{O}(1)$$ Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hukun01",
                        "content": "There are basically two ways to solve this problem. \\n\\nOne is to use a StringBuilder, another is to reverse the underlying char array. \\n\\nFor C/C++ programmers, they may want to modify the input string if it's not constant, so to achieve O(1) space.\\n\\nHowever, for Java programmers, I don't see any improvement beyond O(n) time and space. This is no different from reversing an integer array...What's the point here?"
                    },
                    {
                        "username": "Matt17283940",
                        "content": "Two pointers is O(1) space complexity, no new data structure created"
                    },
                    {
                        "username": "likeshkrishnakaranammuralidhar",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "[@ravitejaDev](/ravitejaDev) thanks a lot!"
                    },
                    {
                        "username": "ravitejaDev",
                        "content": "[@OMOH_PA](/OMOH_PA) within function it will be changing, but s given is from outside the function. As mentioned in the question, u need to do in-place instead of overwriting s within the function. which doesn't make any change to outside list. \nu can use s[:] = s[::-1] instead of just s = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "could any1 explain plz why \"s = s[::-1]\" not working...\nI mean if I print result of \ns = s[::-1] i'm gettting proper answer, but it does not work for the solution\n\n\ns =\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nExpected\n[\"o\",\"l\",\"l\",\"e\",\"h\"]\nStdout\n['o', 'l', 'l', 'e', 'h']\n"
                    },
                    {
                        "username": "hankerkuo",
                        "content": "When I try to run the code with default Testcase, this error appeared, wondering what\\'s the problem here.\\nTestcase and code are default settings (python). ![image](https://assets.leetcode.com/users/hankerkuo/image_1583373557.png)\\n"
                    },
                    {
                        "username": "Hemant069",
                        "content": "\\n s.reverse()"
                    },
                    {
                        "username": "troysleet",
                        "content": "[@ajaiverma](/ajaiverma) That\\'s helpful to know, thanks!"
                    },
                    {
                        "username": "ajaiverma",
                        "content": "[@sozani](/sozani) most of the time, using built in functions are not allowed in interview, you have to create you own algorithm to solve the problem."
                    },
                    {
                        "username": "sozani",
                        "content": "Why don't the most of people  use this approach although I used it?Is it wrong or more space complexity"
                    },
                    {
                        "username": "fuxinwei",
                        "content": "I test with Python solution `s = s[::-1]` but it always got wrong. Does someone know the reason?"
                    },
                    {
                        "username": "Supreeth_HR",
                        "content": "[@Sanchit33](/Sanchit33) works for list as well"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "[@Sanchit33](/Sanchit33) It works in Local environment"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "[@Sanchit33](/Sanchit33) try this s[:] = s[::-1]"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "This method only works for string"
                    },
                    {
                        "username": "ronilpatil",
                        "content": "Actually python create another reference in `s = s[ : : -1]` case, you want to modify in-place na ! Simply `s = s[ : : -1]` it will re-bind the name but `s[:]` will replace whatever previously inside the list. "
                    },
                    {
                        "username": "saugat263",
                        "content": "[@shivam1100](/shivam1100) hey shivam, can you explain how does python compiles and runs over here, i\\'m kinda confused"
                    },
                    {
                        "username": "shivam1100",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "bubbafat",
                        "content": "Even iterating over the array without updates times out."
                    },
                    {
                        "username": "hazemati",
                        "content": "So, just want to give some feedback on the C version of this. Usualliy when htis is asked, the size is not passed in, but it should be assumed that the string is null-terminated (thus the size can be gotten by using strlen."
                    },
                    {
                        "username": "Yodawgz0",
                        "content": "\\n###Runtime: 192 ms, faster than 98.57% of Python3 online submissions for Reverse String.\\n###Memory Usage: 19.1 MB, less than 6.54% of Python3 online submissions for Reverse String.\\nBut it is a memory hogger , as we are doubling the space requirement\\n\\n\\'\\'\\'\\n\\n    def reverseString(self, s: List[str]) -> None:\\n        s.extend(s[::-1])\\n        del s[:int(len(s)/2)]\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "navyaswarup2004",
                        "content": "Where is the print statement?\\n"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "not needed"
                    }
                ]
            },
            {
                "id": 1568172,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/reverse-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion, In-Place, $$\\mathcal{O}(N)$$ Space\n\n  \n**Approach 2:** Two Pointers, Iteration, $$\\mathcal{O}(1)$$ Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hukun01",
                        "content": "There are basically two ways to solve this problem. \\n\\nOne is to use a StringBuilder, another is to reverse the underlying char array. \\n\\nFor C/C++ programmers, they may want to modify the input string if it's not constant, so to achieve O(1) space.\\n\\nHowever, for Java programmers, I don't see any improvement beyond O(n) time and space. This is no different from reversing an integer array...What's the point here?"
                    },
                    {
                        "username": "Matt17283940",
                        "content": "Two pointers is O(1) space complexity, no new data structure created"
                    },
                    {
                        "username": "likeshkrishnakaranammuralidhar",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "[@ravitejaDev](/ravitejaDev) thanks a lot!"
                    },
                    {
                        "username": "ravitejaDev",
                        "content": "[@OMOH_PA](/OMOH_PA) within function it will be changing, but s given is from outside the function. As mentioned in the question, u need to do in-place instead of overwriting s within the function. which doesn't make any change to outside list. \nu can use s[:] = s[::-1] instead of just s = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "could any1 explain plz why \"s = s[::-1]\" not working...\nI mean if I print result of \ns = s[::-1] i'm gettting proper answer, but it does not work for the solution\n\n\ns =\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nExpected\n[\"o\",\"l\",\"l\",\"e\",\"h\"]\nStdout\n['o', 'l', 'l', 'e', 'h']\n"
                    },
                    {
                        "username": "hankerkuo",
                        "content": "When I try to run the code with default Testcase, this error appeared, wondering what\\'s the problem here.\\nTestcase and code are default settings (python). ![image](https://assets.leetcode.com/users/hankerkuo/image_1583373557.png)\\n"
                    },
                    {
                        "username": "Hemant069",
                        "content": "\\n s.reverse()"
                    },
                    {
                        "username": "troysleet",
                        "content": "[@ajaiverma](/ajaiverma) That\\'s helpful to know, thanks!"
                    },
                    {
                        "username": "ajaiverma",
                        "content": "[@sozani](/sozani) most of the time, using built in functions are not allowed in interview, you have to create you own algorithm to solve the problem."
                    },
                    {
                        "username": "sozani",
                        "content": "Why don't the most of people  use this approach although I used it?Is it wrong or more space complexity"
                    },
                    {
                        "username": "fuxinwei",
                        "content": "I test with Python solution `s = s[::-1]` but it always got wrong. Does someone know the reason?"
                    },
                    {
                        "username": "Supreeth_HR",
                        "content": "[@Sanchit33](/Sanchit33) works for list as well"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "[@Sanchit33](/Sanchit33) It works in Local environment"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "[@Sanchit33](/Sanchit33) try this s[:] = s[::-1]"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "This method only works for string"
                    },
                    {
                        "username": "ronilpatil",
                        "content": "Actually python create another reference in `s = s[ : : -1]` case, you want to modify in-place na ! Simply `s = s[ : : -1]` it will re-bind the name but `s[:]` will replace whatever previously inside the list. "
                    },
                    {
                        "username": "saugat263",
                        "content": "[@shivam1100](/shivam1100) hey shivam, can you explain how does python compiles and runs over here, i\\'m kinda confused"
                    },
                    {
                        "username": "shivam1100",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "bubbafat",
                        "content": "Even iterating over the array without updates times out."
                    },
                    {
                        "username": "hazemati",
                        "content": "So, just want to give some feedback on the C version of this. Usualliy when htis is asked, the size is not passed in, but it should be assumed that the string is null-terminated (thus the size can be gotten by using strlen."
                    },
                    {
                        "username": "Yodawgz0",
                        "content": "\\n###Runtime: 192 ms, faster than 98.57% of Python3 online submissions for Reverse String.\\n###Memory Usage: 19.1 MB, less than 6.54% of Python3 online submissions for Reverse String.\\nBut it is a memory hogger , as we are doubling the space requirement\\n\\n\\'\\'\\'\\n\\n    def reverseString(self, s: List[str]) -> None:\\n        s.extend(s[::-1])\\n        del s[:int(len(s)/2)]\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "navyaswarup2004",
                        "content": "Where is the print statement?\\n"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "not needed"
                    }
                ]
            },
            {
                "id": 1570092,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/reverse-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion, In-Place, $$\\mathcal{O}(N)$$ Space\n\n  \n**Approach 2:** Two Pointers, Iteration, $$\\mathcal{O}(1)$$ Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hukun01",
                        "content": "There are basically two ways to solve this problem. \\n\\nOne is to use a StringBuilder, another is to reverse the underlying char array. \\n\\nFor C/C++ programmers, they may want to modify the input string if it's not constant, so to achieve O(1) space.\\n\\nHowever, for Java programmers, I don't see any improvement beyond O(n) time and space. This is no different from reversing an integer array...What's the point here?"
                    },
                    {
                        "username": "Matt17283940",
                        "content": "Two pointers is O(1) space complexity, no new data structure created"
                    },
                    {
                        "username": "likeshkrishnakaranammuralidhar",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "[@ravitejaDev](/ravitejaDev) thanks a lot!"
                    },
                    {
                        "username": "ravitejaDev",
                        "content": "[@OMOH_PA](/OMOH_PA) within function it will be changing, but s given is from outside the function. As mentioned in the question, u need to do in-place instead of overwriting s within the function. which doesn't make any change to outside list. \nu can use s[:] = s[::-1] instead of just s = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "could any1 explain plz why \"s = s[::-1]\" not working...\nI mean if I print result of \ns = s[::-1] i'm gettting proper answer, but it does not work for the solution\n\n\ns =\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nExpected\n[\"o\",\"l\",\"l\",\"e\",\"h\"]\nStdout\n['o', 'l', 'l', 'e', 'h']\n"
                    },
                    {
                        "username": "hankerkuo",
                        "content": "When I try to run the code with default Testcase, this error appeared, wondering what\\'s the problem here.\\nTestcase and code are default settings (python). ![image](https://assets.leetcode.com/users/hankerkuo/image_1583373557.png)\\n"
                    },
                    {
                        "username": "Hemant069",
                        "content": "\\n s.reverse()"
                    },
                    {
                        "username": "troysleet",
                        "content": "[@ajaiverma](/ajaiverma) That\\'s helpful to know, thanks!"
                    },
                    {
                        "username": "ajaiverma",
                        "content": "[@sozani](/sozani) most of the time, using built in functions are not allowed in interview, you have to create you own algorithm to solve the problem."
                    },
                    {
                        "username": "sozani",
                        "content": "Why don't the most of people  use this approach although I used it?Is it wrong or more space complexity"
                    },
                    {
                        "username": "fuxinwei",
                        "content": "I test with Python solution `s = s[::-1]` but it always got wrong. Does someone know the reason?"
                    },
                    {
                        "username": "Supreeth_HR",
                        "content": "[@Sanchit33](/Sanchit33) works for list as well"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "[@Sanchit33](/Sanchit33) It works in Local environment"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "[@Sanchit33](/Sanchit33) try this s[:] = s[::-1]"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "This method only works for string"
                    },
                    {
                        "username": "ronilpatil",
                        "content": "Actually python create another reference in `s = s[ : : -1]` case, you want to modify in-place na ! Simply `s = s[ : : -1]` it will re-bind the name but `s[:]` will replace whatever previously inside the list. "
                    },
                    {
                        "username": "saugat263",
                        "content": "[@shivam1100](/shivam1100) hey shivam, can you explain how does python compiles and runs over here, i\\'m kinda confused"
                    },
                    {
                        "username": "shivam1100",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "bubbafat",
                        "content": "Even iterating over the array without updates times out."
                    },
                    {
                        "username": "hazemati",
                        "content": "So, just want to give some feedback on the C version of this. Usualliy when htis is asked, the size is not passed in, but it should be assumed that the string is null-terminated (thus the size can be gotten by using strlen."
                    },
                    {
                        "username": "Yodawgz0",
                        "content": "\\n###Runtime: 192 ms, faster than 98.57% of Python3 online submissions for Reverse String.\\n###Memory Usage: 19.1 MB, less than 6.54% of Python3 online submissions for Reverse String.\\nBut it is a memory hogger , as we are doubling the space requirement\\n\\n\\'\\'\\'\\n\\n    def reverseString(self, s: List[str]) -> None:\\n        s.extend(s[::-1])\\n        del s[:int(len(s)/2)]\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "navyaswarup2004",
                        "content": "Where is the print statement?\\n"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "not needed"
                    }
                ]
            },
            {
                "id": 1576630,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/reverse-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion, In-Place, $$\\mathcal{O}(N)$$ Space\n\n  \n**Approach 2:** Two Pointers, Iteration, $$\\mathcal{O}(1)$$ Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hukun01",
                        "content": "There are basically two ways to solve this problem. \\n\\nOne is to use a StringBuilder, another is to reverse the underlying char array. \\n\\nFor C/C++ programmers, they may want to modify the input string if it's not constant, so to achieve O(1) space.\\n\\nHowever, for Java programmers, I don't see any improvement beyond O(n) time and space. This is no different from reversing an integer array...What's the point here?"
                    },
                    {
                        "username": "Matt17283940",
                        "content": "Two pointers is O(1) space complexity, no new data structure created"
                    },
                    {
                        "username": "likeshkrishnakaranammuralidhar",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "[@ravitejaDev](/ravitejaDev) thanks a lot!"
                    },
                    {
                        "username": "ravitejaDev",
                        "content": "[@OMOH_PA](/OMOH_PA) within function it will be changing, but s given is from outside the function. As mentioned in the question, u need to do in-place instead of overwriting s within the function. which doesn't make any change to outside list. \nu can use s[:] = s[::-1] instead of just s = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "could any1 explain plz why \"s = s[::-1]\" not working...\nI mean if I print result of \ns = s[::-1] i'm gettting proper answer, but it does not work for the solution\n\n\ns =\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nExpected\n[\"o\",\"l\",\"l\",\"e\",\"h\"]\nStdout\n['o', 'l', 'l', 'e', 'h']\n"
                    },
                    {
                        "username": "hankerkuo",
                        "content": "When I try to run the code with default Testcase, this error appeared, wondering what\\'s the problem here.\\nTestcase and code are default settings (python). ![image](https://assets.leetcode.com/users/hankerkuo/image_1583373557.png)\\n"
                    },
                    {
                        "username": "Hemant069",
                        "content": "\\n s.reverse()"
                    },
                    {
                        "username": "troysleet",
                        "content": "[@ajaiverma](/ajaiverma) That\\'s helpful to know, thanks!"
                    },
                    {
                        "username": "ajaiverma",
                        "content": "[@sozani](/sozani) most of the time, using built in functions are not allowed in interview, you have to create you own algorithm to solve the problem."
                    },
                    {
                        "username": "sozani",
                        "content": "Why don't the most of people  use this approach although I used it?Is it wrong or more space complexity"
                    },
                    {
                        "username": "fuxinwei",
                        "content": "I test with Python solution `s = s[::-1]` but it always got wrong. Does someone know the reason?"
                    },
                    {
                        "username": "Supreeth_HR",
                        "content": "[@Sanchit33](/Sanchit33) works for list as well"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "[@Sanchit33](/Sanchit33) It works in Local environment"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "[@Sanchit33](/Sanchit33) try this s[:] = s[::-1]"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "This method only works for string"
                    },
                    {
                        "username": "ronilpatil",
                        "content": "Actually python create another reference in `s = s[ : : -1]` case, you want to modify in-place na ! Simply `s = s[ : : -1]` it will re-bind the name but `s[:]` will replace whatever previously inside the list. "
                    },
                    {
                        "username": "saugat263",
                        "content": "[@shivam1100](/shivam1100) hey shivam, can you explain how does python compiles and runs over here, i\\'m kinda confused"
                    },
                    {
                        "username": "shivam1100",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "bubbafat",
                        "content": "Even iterating over the array without updates times out."
                    },
                    {
                        "username": "hazemati",
                        "content": "So, just want to give some feedback on the C version of this. Usualliy when htis is asked, the size is not passed in, but it should be assumed that the string is null-terminated (thus the size can be gotten by using strlen."
                    },
                    {
                        "username": "Yodawgz0",
                        "content": "\\n###Runtime: 192 ms, faster than 98.57% of Python3 online submissions for Reverse String.\\n###Memory Usage: 19.1 MB, less than 6.54% of Python3 online submissions for Reverse String.\\nBut it is a memory hogger , as we are doubling the space requirement\\n\\n\\'\\'\\'\\n\\n    def reverseString(self, s: List[str]) -> None:\\n        s.extend(s[::-1])\\n        del s[:int(len(s)/2)]\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "navyaswarup2004",
                        "content": "Where is the print statement?\\n"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "not needed"
                    }
                ]
            },
            {
                "id": 1575562,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/reverse-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion, In-Place, $$\\mathcal{O}(N)$$ Space\n\n  \n**Approach 2:** Two Pointers, Iteration, $$\\mathcal{O}(1)$$ Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hukun01",
                        "content": "There are basically two ways to solve this problem. \\n\\nOne is to use a StringBuilder, another is to reverse the underlying char array. \\n\\nFor C/C++ programmers, they may want to modify the input string if it's not constant, so to achieve O(1) space.\\n\\nHowever, for Java programmers, I don't see any improvement beyond O(n) time and space. This is no different from reversing an integer array...What's the point here?"
                    },
                    {
                        "username": "Matt17283940",
                        "content": "Two pointers is O(1) space complexity, no new data structure created"
                    },
                    {
                        "username": "likeshkrishnakaranammuralidhar",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "[@ravitejaDev](/ravitejaDev) thanks a lot!"
                    },
                    {
                        "username": "ravitejaDev",
                        "content": "[@OMOH_PA](/OMOH_PA) within function it will be changing, but s given is from outside the function. As mentioned in the question, u need to do in-place instead of overwriting s within the function. which doesn't make any change to outside list. \nu can use s[:] = s[::-1] instead of just s = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "could any1 explain plz why \"s = s[::-1]\" not working...\nI mean if I print result of \ns = s[::-1] i'm gettting proper answer, but it does not work for the solution\n\n\ns =\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nExpected\n[\"o\",\"l\",\"l\",\"e\",\"h\"]\nStdout\n['o', 'l', 'l', 'e', 'h']\n"
                    },
                    {
                        "username": "hankerkuo",
                        "content": "When I try to run the code with default Testcase, this error appeared, wondering what\\'s the problem here.\\nTestcase and code are default settings (python). ![image](https://assets.leetcode.com/users/hankerkuo/image_1583373557.png)\\n"
                    },
                    {
                        "username": "Hemant069",
                        "content": "\\n s.reverse()"
                    },
                    {
                        "username": "troysleet",
                        "content": "[@ajaiverma](/ajaiverma) That\\'s helpful to know, thanks!"
                    },
                    {
                        "username": "ajaiverma",
                        "content": "[@sozani](/sozani) most of the time, using built in functions are not allowed in interview, you have to create you own algorithm to solve the problem."
                    },
                    {
                        "username": "sozani",
                        "content": "Why don't the most of people  use this approach although I used it?Is it wrong or more space complexity"
                    },
                    {
                        "username": "fuxinwei",
                        "content": "I test with Python solution `s = s[::-1]` but it always got wrong. Does someone know the reason?"
                    },
                    {
                        "username": "Supreeth_HR",
                        "content": "[@Sanchit33](/Sanchit33) works for list as well"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "[@Sanchit33](/Sanchit33) It works in Local environment"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "[@Sanchit33](/Sanchit33) try this s[:] = s[::-1]"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "This method only works for string"
                    },
                    {
                        "username": "ronilpatil",
                        "content": "Actually python create another reference in `s = s[ : : -1]` case, you want to modify in-place na ! Simply `s = s[ : : -1]` it will re-bind the name but `s[:]` will replace whatever previously inside the list. "
                    },
                    {
                        "username": "saugat263",
                        "content": "[@shivam1100](/shivam1100) hey shivam, can you explain how does python compiles and runs over here, i\\'m kinda confused"
                    },
                    {
                        "username": "shivam1100",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "bubbafat",
                        "content": "Even iterating over the array without updates times out."
                    },
                    {
                        "username": "hazemati",
                        "content": "So, just want to give some feedback on the C version of this. Usualliy when htis is asked, the size is not passed in, but it should be assumed that the string is null-terminated (thus the size can be gotten by using strlen."
                    },
                    {
                        "username": "Yodawgz0",
                        "content": "\\n###Runtime: 192 ms, faster than 98.57% of Python3 online submissions for Reverse String.\\n###Memory Usage: 19.1 MB, less than 6.54% of Python3 online submissions for Reverse String.\\nBut it is a memory hogger , as we are doubling the space requirement\\n\\n\\'\\'\\'\\n\\n    def reverseString(self, s: List[str]) -> None:\\n        s.extend(s[::-1])\\n        del s[:int(len(s)/2)]\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "navyaswarup2004",
                        "content": "Where is the print statement?\\n"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "not needed"
                    }
                ]
            },
            {
                "id": 1575430,
                "content": [
                    {
                        "username": "faang_engineer",
                        "content": "Not able to understand problem statement"
                    },
                    {
                        "username": "faang_engineer",
                        "content": "Not able to understand problem statement"
                    },
                    {
                        "username": "SathvikSunny",
                        "content": "\\'\\'\\'\\ndef reverseString(self, s: List[str]) -> None:\\n        s.reverse()\\n\\'\\'\\'"
                    },
                    {
                        "username": "poojaagrwl13",
                        "content": "\\n\\t\\t\\tfor i in range(len(s)-1):\\n\\t\\t\\t\\tn = s.pop()\\n\\t\\t\\t\\ts.insert(i, n)"
                    },
                    {
                        "username": "chenpku",
                        "content": "Re: [Simple C++ solution](/topic/43298/simple-c-solution)\\n\\nWhen I run this code, I met with a strange error with on test case, which is\\n\\nInput:\\n\"Marge\\nlet's \\\\\"went.\\\\\" I await news telegram.\"\\nOutput:\\n\".margelet swen tiawa I \\\\\".tnew\\\\\" s'tel ,egraM\"\\nExpected:\\n\".margelet swen tiawa I \".tnew\" s'tel ,egraM\"\\n\\nI believe it's leet-code's problem?"
                    },
                    {
                        "username": "Mayur_2912",
                        "content": "In case of python we can simply use reverse() method.\\neg. \\n    s.reverse()"
                    },
                    {
                        "username": "abdrhxyii",
                        "content": "I tried my solution for this in my vs code it worked as expected but when I did the same in the leet code it gave an error, Why ? "
                    },
                    {
                        "username": "IamGirishReddy",
                        "content": "please give the code "
                    },
                    {
                        "username": "silent-killer",
                        "content": "def reverseString(self, s: List[str]) -> None:\\n        print(s.reverse())"
                    },
                    {
                        "username": "chellaprabu21",
                        "content": "func test(_ s: inout [Character]){\\n     s = s.reversed()\\n}"
                    },
                    {
                        "username": "AbdessamadJadid",
                        "content": "i solved the problem by using the Array.Reverse function."
                    },
                    {
                        "username": "faang_engineer",
                        "content": "Not able to understand problem statement"
                    }
                ]
            },
            {
                "id": 1575429,
                "content": [
                    {
                        "username": "faang_engineer",
                        "content": "Not able to understand problem statement"
                    },
                    {
                        "username": "faang_engineer",
                        "content": "Not able to understand problem statement"
                    },
                    {
                        "username": "SathvikSunny",
                        "content": "\\'\\'\\'\\ndef reverseString(self, s: List[str]) -> None:\\n        s.reverse()\\n\\'\\'\\'"
                    },
                    {
                        "username": "poojaagrwl13",
                        "content": "\\n\\t\\t\\tfor i in range(len(s)-1):\\n\\t\\t\\t\\tn = s.pop()\\n\\t\\t\\t\\ts.insert(i, n)"
                    },
                    {
                        "username": "chenpku",
                        "content": "Re: [Simple C++ solution](/topic/43298/simple-c-solution)\\n\\nWhen I run this code, I met with a strange error with on test case, which is\\n\\nInput:\\n\"Marge\\nlet's \\\\\"went.\\\\\" I await news telegram.\"\\nOutput:\\n\".margelet swen tiawa I \\\\\".tnew\\\\\" s'tel ,egraM\"\\nExpected:\\n\".margelet swen tiawa I \".tnew\" s'tel ,egraM\"\\n\\nI believe it's leet-code's problem?"
                    },
                    {
                        "username": "Mayur_2912",
                        "content": "In case of python we can simply use reverse() method.\\neg. \\n    s.reverse()"
                    },
                    {
                        "username": "abdrhxyii",
                        "content": "I tried my solution for this in my vs code it worked as expected but when I did the same in the leet code it gave an error, Why ? "
                    },
                    {
                        "username": "IamGirishReddy",
                        "content": "please give the code "
                    },
                    {
                        "username": "silent-killer",
                        "content": "def reverseString(self, s: List[str]) -> None:\\n        print(s.reverse())"
                    },
                    {
                        "username": "chellaprabu21",
                        "content": "func test(_ s: inout [Character]){\\n     s = s.reversed()\\n}"
                    },
                    {
                        "username": "AbdessamadJadid",
                        "content": "i solved the problem by using the Array.Reverse function."
                    },
                    {
                        "username": "faang_engineer",
                        "content": "Not able to understand problem statement"
                    }
                ]
            },
            {
                "id": 1573170,
                "content": [
                    {
                        "username": "faang_engineer",
                        "content": "Not able to understand problem statement"
                    },
                    {
                        "username": "faang_engineer",
                        "content": "Not able to understand problem statement"
                    },
                    {
                        "username": "SathvikSunny",
                        "content": "\\'\\'\\'\\ndef reverseString(self, s: List[str]) -> None:\\n        s.reverse()\\n\\'\\'\\'"
                    },
                    {
                        "username": "poojaagrwl13",
                        "content": "\\n\\t\\t\\tfor i in range(len(s)-1):\\n\\t\\t\\t\\tn = s.pop()\\n\\t\\t\\t\\ts.insert(i, n)"
                    },
                    {
                        "username": "chenpku",
                        "content": "Re: [Simple C++ solution](/topic/43298/simple-c-solution)\\n\\nWhen I run this code, I met with a strange error with on test case, which is\\n\\nInput:\\n\"Marge\\nlet's \\\\\"went.\\\\\" I await news telegram.\"\\nOutput:\\n\".margelet swen tiawa I \\\\\".tnew\\\\\" s'tel ,egraM\"\\nExpected:\\n\".margelet swen tiawa I \".tnew\" s'tel ,egraM\"\\n\\nI believe it's leet-code's problem?"
                    },
                    {
                        "username": "Mayur_2912",
                        "content": "In case of python we can simply use reverse() method.\\neg. \\n    s.reverse()"
                    },
                    {
                        "username": "abdrhxyii",
                        "content": "I tried my solution for this in my vs code it worked as expected but when I did the same in the leet code it gave an error, Why ? "
                    },
                    {
                        "username": "IamGirishReddy",
                        "content": "please give the code "
                    },
                    {
                        "username": "silent-killer",
                        "content": "def reverseString(self, s: List[str]) -> None:\\n        print(s.reverse())"
                    },
                    {
                        "username": "chellaprabu21",
                        "content": "func test(_ s: inout [Character]){\\n     s = s.reversed()\\n}"
                    },
                    {
                        "username": "AbdessamadJadid",
                        "content": "i solved the problem by using the Array.Reverse function."
                    },
                    {
                        "username": "faang_engineer",
                        "content": "Not able to understand problem statement"
                    }
                ]
            },
            {
                "id": 1573147,
                "content": [
                    {
                        "username": "faang_engineer",
                        "content": "Not able to understand problem statement"
                    },
                    {
                        "username": "faang_engineer",
                        "content": "Not able to understand problem statement"
                    },
                    {
                        "username": "SathvikSunny",
                        "content": "\\'\\'\\'\\ndef reverseString(self, s: List[str]) -> None:\\n        s.reverse()\\n\\'\\'\\'"
                    },
                    {
                        "username": "poojaagrwl13",
                        "content": "\\n\\t\\t\\tfor i in range(len(s)-1):\\n\\t\\t\\t\\tn = s.pop()\\n\\t\\t\\t\\ts.insert(i, n)"
                    },
                    {
                        "username": "chenpku",
                        "content": "Re: [Simple C++ solution](/topic/43298/simple-c-solution)\\n\\nWhen I run this code, I met with a strange error with on test case, which is\\n\\nInput:\\n\"Marge\\nlet's \\\\\"went.\\\\\" I await news telegram.\"\\nOutput:\\n\".margelet swen tiawa I \\\\\".tnew\\\\\" s'tel ,egraM\"\\nExpected:\\n\".margelet swen tiawa I \".tnew\" s'tel ,egraM\"\\n\\nI believe it's leet-code's problem?"
                    },
                    {
                        "username": "Mayur_2912",
                        "content": "In case of python we can simply use reverse() method.\\neg. \\n    s.reverse()"
                    },
                    {
                        "username": "abdrhxyii",
                        "content": "I tried my solution for this in my vs code it worked as expected but when I did the same in the leet code it gave an error, Why ? "
                    },
                    {
                        "username": "IamGirishReddy",
                        "content": "please give the code "
                    },
                    {
                        "username": "silent-killer",
                        "content": "def reverseString(self, s: List[str]) -> None:\\n        print(s.reverse())"
                    },
                    {
                        "username": "chellaprabu21",
                        "content": "func test(_ s: inout [Character]){\\n     s = s.reversed()\\n}"
                    },
                    {
                        "username": "AbdessamadJadid",
                        "content": "i solved the problem by using the Array.Reverse function."
                    },
                    {
                        "username": "faang_engineer",
                        "content": "Not able to understand problem statement"
                    }
                ]
            },
            {
                "id": 1569090,
                "content": [
                    {
                        "username": "faang_engineer",
                        "content": "Not able to understand problem statement"
                    },
                    {
                        "username": "faang_engineer",
                        "content": "Not able to understand problem statement"
                    },
                    {
                        "username": "SathvikSunny",
                        "content": "\\'\\'\\'\\ndef reverseString(self, s: List[str]) -> None:\\n        s.reverse()\\n\\'\\'\\'"
                    },
                    {
                        "username": "poojaagrwl13",
                        "content": "\\n\\t\\t\\tfor i in range(len(s)-1):\\n\\t\\t\\t\\tn = s.pop()\\n\\t\\t\\t\\ts.insert(i, n)"
                    },
                    {
                        "username": "chenpku",
                        "content": "Re: [Simple C++ solution](/topic/43298/simple-c-solution)\\n\\nWhen I run this code, I met with a strange error with on test case, which is\\n\\nInput:\\n\"Marge\\nlet's \\\\\"went.\\\\\" I await news telegram.\"\\nOutput:\\n\".margelet swen tiawa I \\\\\".tnew\\\\\" s'tel ,egraM\"\\nExpected:\\n\".margelet swen tiawa I \".tnew\" s'tel ,egraM\"\\n\\nI believe it's leet-code's problem?"
                    },
                    {
                        "username": "Mayur_2912",
                        "content": "In case of python we can simply use reverse() method.\\neg. \\n    s.reverse()"
                    },
                    {
                        "username": "abdrhxyii",
                        "content": "I tried my solution for this in my vs code it worked as expected but when I did the same in the leet code it gave an error, Why ? "
                    },
                    {
                        "username": "IamGirishReddy",
                        "content": "please give the code "
                    },
                    {
                        "username": "silent-killer",
                        "content": "def reverseString(self, s: List[str]) -> None:\\n        print(s.reverse())"
                    },
                    {
                        "username": "chellaprabu21",
                        "content": "func test(_ s: inout [Character]){\\n     s = s.reversed()\\n}"
                    },
                    {
                        "username": "AbdessamadJadid",
                        "content": "i solved the problem by using the Array.Reverse function."
                    },
                    {
                        "username": "faang_engineer",
                        "content": "Not able to understand problem statement"
                    }
                ]
            },
            {
                "id": 2041985,
                "content": [
                    {
                        "username": "faang_engineer",
                        "content": "Not able to understand problem statement"
                    },
                    {
                        "username": "faang_engineer",
                        "content": "Not able to understand problem statement"
                    },
                    {
                        "username": "SathvikSunny",
                        "content": "\\'\\'\\'\\ndef reverseString(self, s: List[str]) -> None:\\n        s.reverse()\\n\\'\\'\\'"
                    },
                    {
                        "username": "poojaagrwl13",
                        "content": "\\n\\t\\t\\tfor i in range(len(s)-1):\\n\\t\\t\\t\\tn = s.pop()\\n\\t\\t\\t\\ts.insert(i, n)"
                    },
                    {
                        "username": "chenpku",
                        "content": "Re: [Simple C++ solution](/topic/43298/simple-c-solution)\\n\\nWhen I run this code, I met with a strange error with on test case, which is\\n\\nInput:\\n\"Marge\\nlet's \\\\\"went.\\\\\" I await news telegram.\"\\nOutput:\\n\".margelet swen tiawa I \\\\\".tnew\\\\\" s'tel ,egraM\"\\nExpected:\\n\".margelet swen tiawa I \".tnew\" s'tel ,egraM\"\\n\\nI believe it's leet-code's problem?"
                    },
                    {
                        "username": "Mayur_2912",
                        "content": "In case of python we can simply use reverse() method.\\neg. \\n    s.reverse()"
                    },
                    {
                        "username": "abdrhxyii",
                        "content": "I tried my solution for this in my vs code it worked as expected but when I did the same in the leet code it gave an error, Why ? "
                    },
                    {
                        "username": "IamGirishReddy",
                        "content": "please give the code "
                    },
                    {
                        "username": "silent-killer",
                        "content": "def reverseString(self, s: List[str]) -> None:\\n        print(s.reverse())"
                    },
                    {
                        "username": "chellaprabu21",
                        "content": "func test(_ s: inout [Character]){\\n     s = s.reversed()\\n}"
                    },
                    {
                        "username": "AbdessamadJadid",
                        "content": "i solved the problem by using the Array.Reverse function."
                    },
                    {
                        "username": "faang_engineer",
                        "content": "Not able to understand problem statement"
                    }
                ]
            },
            {
                "id": 1576222,
                "content": [
                    {
                        "username": "faang_engineer",
                        "content": "Not able to understand problem statement"
                    },
                    {
                        "username": "faang_engineer",
                        "content": "Not able to understand problem statement"
                    },
                    {
                        "username": "SathvikSunny",
                        "content": "\\'\\'\\'\\ndef reverseString(self, s: List[str]) -> None:\\n        s.reverse()\\n\\'\\'\\'"
                    },
                    {
                        "username": "poojaagrwl13",
                        "content": "\\n\\t\\t\\tfor i in range(len(s)-1):\\n\\t\\t\\t\\tn = s.pop()\\n\\t\\t\\t\\ts.insert(i, n)"
                    },
                    {
                        "username": "chenpku",
                        "content": "Re: [Simple C++ solution](/topic/43298/simple-c-solution)\\n\\nWhen I run this code, I met with a strange error with on test case, which is\\n\\nInput:\\n\"Marge\\nlet's \\\\\"went.\\\\\" I await news telegram.\"\\nOutput:\\n\".margelet swen tiawa I \\\\\".tnew\\\\\" s'tel ,egraM\"\\nExpected:\\n\".margelet swen tiawa I \".tnew\" s'tel ,egraM\"\\n\\nI believe it's leet-code's problem?"
                    },
                    {
                        "username": "Mayur_2912",
                        "content": "In case of python we can simply use reverse() method.\\neg. \\n    s.reverse()"
                    },
                    {
                        "username": "abdrhxyii",
                        "content": "I tried my solution for this in my vs code it worked as expected but when I did the same in the leet code it gave an error, Why ? "
                    },
                    {
                        "username": "IamGirishReddy",
                        "content": "please give the code "
                    },
                    {
                        "username": "silent-killer",
                        "content": "def reverseString(self, s: List[str]) -> None:\\n        print(s.reverse())"
                    },
                    {
                        "username": "chellaprabu21",
                        "content": "func test(_ s: inout [Character]){\\n     s = s.reversed()\\n}"
                    },
                    {
                        "username": "AbdessamadJadid",
                        "content": "i solved the problem by using the Array.Reverse function."
                    },
                    {
                        "username": "faang_engineer",
                        "content": "Not able to understand problem statement"
                    }
                ]
            },
            {
                "id": 1576135,
                "content": [
                    {
                        "username": "faang_engineer",
                        "content": "Not able to understand problem statement"
                    },
                    {
                        "username": "faang_engineer",
                        "content": "Not able to understand problem statement"
                    },
                    {
                        "username": "SathvikSunny",
                        "content": "\\'\\'\\'\\ndef reverseString(self, s: List[str]) -> None:\\n        s.reverse()\\n\\'\\'\\'"
                    },
                    {
                        "username": "poojaagrwl13",
                        "content": "\\n\\t\\t\\tfor i in range(len(s)-1):\\n\\t\\t\\t\\tn = s.pop()\\n\\t\\t\\t\\ts.insert(i, n)"
                    },
                    {
                        "username": "chenpku",
                        "content": "Re: [Simple C++ solution](/topic/43298/simple-c-solution)\\n\\nWhen I run this code, I met with a strange error with on test case, which is\\n\\nInput:\\n\"Marge\\nlet's \\\\\"went.\\\\\" I await news telegram.\"\\nOutput:\\n\".margelet swen tiawa I \\\\\".tnew\\\\\" s'tel ,egraM\"\\nExpected:\\n\".margelet swen tiawa I \".tnew\" s'tel ,egraM\"\\n\\nI believe it's leet-code's problem?"
                    },
                    {
                        "username": "Mayur_2912",
                        "content": "In case of python we can simply use reverse() method.\\neg. \\n    s.reverse()"
                    },
                    {
                        "username": "abdrhxyii",
                        "content": "I tried my solution for this in my vs code it worked as expected but when I did the same in the leet code it gave an error, Why ? "
                    },
                    {
                        "username": "IamGirishReddy",
                        "content": "please give the code "
                    },
                    {
                        "username": "silent-killer",
                        "content": "def reverseString(self, s: List[str]) -> None:\\n        print(s.reverse())"
                    },
                    {
                        "username": "chellaprabu21",
                        "content": "func test(_ s: inout [Character]){\\n     s = s.reversed()\\n}"
                    },
                    {
                        "username": "AbdessamadJadid",
                        "content": "i solved the problem by using the Array.Reverse function."
                    },
                    {
                        "username": "faang_engineer",
                        "content": "Not able to understand problem statement"
                    }
                ]
            },
            {
                "id": 1576120,
                "content": [
                    {
                        "username": "faang_engineer",
                        "content": "Not able to understand problem statement"
                    },
                    {
                        "username": "faang_engineer",
                        "content": "Not able to understand problem statement"
                    },
                    {
                        "username": "SathvikSunny",
                        "content": "\\'\\'\\'\\ndef reverseString(self, s: List[str]) -> None:\\n        s.reverse()\\n\\'\\'\\'"
                    },
                    {
                        "username": "poojaagrwl13",
                        "content": "\\n\\t\\t\\tfor i in range(len(s)-1):\\n\\t\\t\\t\\tn = s.pop()\\n\\t\\t\\t\\ts.insert(i, n)"
                    },
                    {
                        "username": "chenpku",
                        "content": "Re: [Simple C++ solution](/topic/43298/simple-c-solution)\\n\\nWhen I run this code, I met with a strange error with on test case, which is\\n\\nInput:\\n\"Marge\\nlet's \\\\\"went.\\\\\" I await news telegram.\"\\nOutput:\\n\".margelet swen tiawa I \\\\\".tnew\\\\\" s'tel ,egraM\"\\nExpected:\\n\".margelet swen tiawa I \".tnew\" s'tel ,egraM\"\\n\\nI believe it's leet-code's problem?"
                    },
                    {
                        "username": "Mayur_2912",
                        "content": "In case of python we can simply use reverse() method.\\neg. \\n    s.reverse()"
                    },
                    {
                        "username": "abdrhxyii",
                        "content": "I tried my solution for this in my vs code it worked as expected but when I did the same in the leet code it gave an error, Why ? "
                    },
                    {
                        "username": "IamGirishReddy",
                        "content": "please give the code "
                    },
                    {
                        "username": "silent-killer",
                        "content": "def reverseString(self, s: List[str]) -> None:\\n        print(s.reverse())"
                    },
                    {
                        "username": "chellaprabu21",
                        "content": "func test(_ s: inout [Character]){\\n     s = s.reversed()\\n}"
                    },
                    {
                        "username": "AbdessamadJadid",
                        "content": "i solved the problem by using the Array.Reverse function."
                    },
                    {
                        "username": "faang_engineer",
                        "content": "Not able to understand problem statement"
                    }
                ]
            },
            {
                "id": 1575431,
                "content": [
                    {
                        "username": "faang_engineer",
                        "content": "Not able to understand problem statement"
                    },
                    {
                        "username": "faang_engineer",
                        "content": "Not able to understand problem statement"
                    },
                    {
                        "username": "SathvikSunny",
                        "content": "\\'\\'\\'\\ndef reverseString(self, s: List[str]) -> None:\\n        s.reverse()\\n\\'\\'\\'"
                    },
                    {
                        "username": "poojaagrwl13",
                        "content": "\\n\\t\\t\\tfor i in range(len(s)-1):\\n\\t\\t\\t\\tn = s.pop()\\n\\t\\t\\t\\ts.insert(i, n)"
                    },
                    {
                        "username": "chenpku",
                        "content": "Re: [Simple C++ solution](/topic/43298/simple-c-solution)\\n\\nWhen I run this code, I met with a strange error with on test case, which is\\n\\nInput:\\n\"Marge\\nlet's \\\\\"went.\\\\\" I await news telegram.\"\\nOutput:\\n\".margelet swen tiawa I \\\\\".tnew\\\\\" s'tel ,egraM\"\\nExpected:\\n\".margelet swen tiawa I \".tnew\" s'tel ,egraM\"\\n\\nI believe it's leet-code's problem?"
                    },
                    {
                        "username": "Mayur_2912",
                        "content": "In case of python we can simply use reverse() method.\\neg. \\n    s.reverse()"
                    },
                    {
                        "username": "abdrhxyii",
                        "content": "I tried my solution for this in my vs code it worked as expected but when I did the same in the leet code it gave an error, Why ? "
                    },
                    {
                        "username": "IamGirishReddy",
                        "content": "please give the code "
                    },
                    {
                        "username": "silent-killer",
                        "content": "def reverseString(self, s: List[str]) -> None:\\n        print(s.reverse())"
                    },
                    {
                        "username": "chellaprabu21",
                        "content": "func test(_ s: inout [Character]){\\n     s = s.reversed()\\n}"
                    },
                    {
                        "username": "AbdessamadJadid",
                        "content": "i solved the problem by using the Array.Reverse function."
                    },
                    {
                        "username": "faang_engineer",
                        "content": "Not able to understand problem statement"
                    }
                ]
            },
            {
                "id": 1575180,
                "content": [
                    {
                        "username": "baloo-the-bear",
                        "content": "A number of solutions possible for this. Question:\\n- is s.reverse() in Python not good enough answer for interview i.e. needs to be implemented?\\n- I tried \\n\\'\\'\\'\\ns = s[::-1] \\n\\'\\'\\'\\n\\nin python3 - and it does work reverse currectly. \\n>>> s\\n[\\'h\\', \\'e\\', \\'l\\', \\'l\\', \\'o\\']\\n>>> s = s[::-1]\\n>>> s\\n[\\'o\\', \\'l\\', \\'l\\', \\'e\\', \\'h\\']\\n>>> \\n\\nHowever leetcode gives that as an inorrect answer. Thoughts?\\n"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "s[:] = s[::-1] modifies the original string in place by reversing its content, while s = s[::-1] creates a new string object that contains the reversed elements of the original string."
                    },
                    {
                        "username": "enixzyrex",
                        "content": "Apparently this would create another reference of s\\ns = s[::-1]\\nwhereas this would modify it in place\\ns[:] = s[::-1]"
                    },
                    {
                        "username": "egek4",
                        "content": "reverse a string is misleading, i was expecting to use a StringBuilder etc."
                    },
                    {
                        "username": "mark30331",
                        "content": "...\\nwords= \"leetcodeisacommunityforcoders\"\\nprint(words[::-1])\\n\\n..."
                    },
                    {
                        "username": "gsethi2409",
                        "content": "[https://youtu.be/ynZoxE-k5-4](https://youtu.be/ynZoxE-k5-4)"
                    },
                    {
                        "username": "varunpne",
                        "content": "![image](https://assets.leetcode.com/users/varunpne/image_1584728434.png)\\n![image](https://assets.leetcode.com/users/varunpne/image_1584728468.png)\\n\\n\\nSo this happened !!!!"
                    },
                    {
                        "username": "jumshoos",
                        "content": "why this wont accept ?\\n\\n\\'\\'\\'\\ns = s[::-1]\\n\\'\\'\\'"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": " s[:] = s[::-1]"
                    },
                    {
                        "username": "jguan1",
                        "content": "The requirement is to do this in place, but so many approaches here have \"return\" statement. I wonder if the test cases might not be correctly designed. Any ideas?"
                    },
                    {
                        "username": "daralis",
                        "content": "\\n\\tpublic String reverseString(String s){\\n\\t\\treturn new StringBuffer(s).reverse().toString();\\n\\t}"
                    },
                    {
                        "username": "mlavergn",
                        "content": "There's no reason this string should fail:\\n\\n\"Snug & raw was I ere I saw war & guns.\"\\n\\nwhen returned as:\\n\\n\".snug & raw was I ere I saw war & gunS\"\\n\\nbut the evaluator for Golang escapes the result as:\\n\\n\".snug \\\\u0026 raw was I ere I saw war \\\\u0026 gunS\"\\n\\nI tried all the escaping mechanisms to get this to pass, but none helped. Looks like a Leetcode bug."
                    },
                    {
                        "username": "chenpku",
                        "content": "Re: [C++ two pointer.](/topic/57750/c-two-pointer)\\n\\nI got the following errors with myself's code. and I re-run your code and also got similar errors, which I think it's leet-code's problem?\\n\\nInput:\\n\"Marge\\nlet's \\\\\"went.\\\\\" I await news telegram.\"\\nOutput:\\n\".margelet swen tiawa I \\\\\".tnew\\\\\" s'tel ,egraM\"\\nExpected:\\n\".margelet swen tiawa I \".tnew\" s'tel ,egraM\""
                    }
                ]
            },
            {
                "id": 1574836,
                "content": [
                    {
                        "username": "baloo-the-bear",
                        "content": "A number of solutions possible for this. Question:\\n- is s.reverse() in Python not good enough answer for interview i.e. needs to be implemented?\\n- I tried \\n\\'\\'\\'\\ns = s[::-1] \\n\\'\\'\\'\\n\\nin python3 - and it does work reverse currectly. \\n>>> s\\n[\\'h\\', \\'e\\', \\'l\\', \\'l\\', \\'o\\']\\n>>> s = s[::-1]\\n>>> s\\n[\\'o\\', \\'l\\', \\'l\\', \\'e\\', \\'h\\']\\n>>> \\n\\nHowever leetcode gives that as an inorrect answer. Thoughts?\\n"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "s[:] = s[::-1] modifies the original string in place by reversing its content, while s = s[::-1] creates a new string object that contains the reversed elements of the original string."
                    },
                    {
                        "username": "enixzyrex",
                        "content": "Apparently this would create another reference of s\\ns = s[::-1]\\nwhereas this would modify it in place\\ns[:] = s[::-1]"
                    },
                    {
                        "username": "egek4",
                        "content": "reverse a string is misleading, i was expecting to use a StringBuilder etc."
                    },
                    {
                        "username": "mark30331",
                        "content": "...\\nwords= \"leetcodeisacommunityforcoders\"\\nprint(words[::-1])\\n\\n..."
                    },
                    {
                        "username": "gsethi2409",
                        "content": "[https://youtu.be/ynZoxE-k5-4](https://youtu.be/ynZoxE-k5-4)"
                    },
                    {
                        "username": "varunpne",
                        "content": "![image](https://assets.leetcode.com/users/varunpne/image_1584728434.png)\\n![image](https://assets.leetcode.com/users/varunpne/image_1584728468.png)\\n\\n\\nSo this happened !!!!"
                    },
                    {
                        "username": "jumshoos",
                        "content": "why this wont accept ?\\n\\n\\'\\'\\'\\ns = s[::-1]\\n\\'\\'\\'"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": " s[:] = s[::-1]"
                    },
                    {
                        "username": "jguan1",
                        "content": "The requirement is to do this in place, but so many approaches here have \"return\" statement. I wonder if the test cases might not be correctly designed. Any ideas?"
                    },
                    {
                        "username": "daralis",
                        "content": "\\n\\tpublic String reverseString(String s){\\n\\t\\treturn new StringBuffer(s).reverse().toString();\\n\\t}"
                    },
                    {
                        "username": "mlavergn",
                        "content": "There's no reason this string should fail:\\n\\n\"Snug & raw was I ere I saw war & guns.\"\\n\\nwhen returned as:\\n\\n\".snug & raw was I ere I saw war & gunS\"\\n\\nbut the evaluator for Golang escapes the result as:\\n\\n\".snug \\\\u0026 raw was I ere I saw war \\\\u0026 gunS\"\\n\\nI tried all the escaping mechanisms to get this to pass, but none helped. Looks like a Leetcode bug."
                    },
                    {
                        "username": "chenpku",
                        "content": "Re: [C++ two pointer.](/topic/57750/c-two-pointer)\\n\\nI got the following errors with myself's code. and I re-run your code and also got similar errors, which I think it's leet-code's problem?\\n\\nInput:\\n\"Marge\\nlet's \\\\\"went.\\\\\" I await news telegram.\"\\nOutput:\\n\".margelet swen tiawa I \\\\\".tnew\\\\\" s'tel ,egraM\"\\nExpected:\\n\".margelet swen tiawa I \".tnew\" s'tel ,egraM\""
                    }
                ]
            },
            {
                "id": 1574461,
                "content": [
                    {
                        "username": "baloo-the-bear",
                        "content": "A number of solutions possible for this. Question:\\n- is s.reverse() in Python not good enough answer for interview i.e. needs to be implemented?\\n- I tried \\n\\'\\'\\'\\ns = s[::-1] \\n\\'\\'\\'\\n\\nin python3 - and it does work reverse currectly. \\n>>> s\\n[\\'h\\', \\'e\\', \\'l\\', \\'l\\', \\'o\\']\\n>>> s = s[::-1]\\n>>> s\\n[\\'o\\', \\'l\\', \\'l\\', \\'e\\', \\'h\\']\\n>>> \\n\\nHowever leetcode gives that as an inorrect answer. Thoughts?\\n"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "s[:] = s[::-1] modifies the original string in place by reversing its content, while s = s[::-1] creates a new string object that contains the reversed elements of the original string."
                    },
                    {
                        "username": "enixzyrex",
                        "content": "Apparently this would create another reference of s\\ns = s[::-1]\\nwhereas this would modify it in place\\ns[:] = s[::-1]"
                    },
                    {
                        "username": "egek4",
                        "content": "reverse a string is misleading, i was expecting to use a StringBuilder etc."
                    },
                    {
                        "username": "mark30331",
                        "content": "...\\nwords= \"leetcodeisacommunityforcoders\"\\nprint(words[::-1])\\n\\n..."
                    },
                    {
                        "username": "gsethi2409",
                        "content": "[https://youtu.be/ynZoxE-k5-4](https://youtu.be/ynZoxE-k5-4)"
                    },
                    {
                        "username": "varunpne",
                        "content": "![image](https://assets.leetcode.com/users/varunpne/image_1584728434.png)\\n![image](https://assets.leetcode.com/users/varunpne/image_1584728468.png)\\n\\n\\nSo this happened !!!!"
                    },
                    {
                        "username": "jumshoos",
                        "content": "why this wont accept ?\\n\\n\\'\\'\\'\\ns = s[::-1]\\n\\'\\'\\'"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": " s[:] = s[::-1]"
                    },
                    {
                        "username": "jguan1",
                        "content": "The requirement is to do this in place, but so many approaches here have \"return\" statement. I wonder if the test cases might not be correctly designed. Any ideas?"
                    },
                    {
                        "username": "daralis",
                        "content": "\\n\\tpublic String reverseString(String s){\\n\\t\\treturn new StringBuffer(s).reverse().toString();\\n\\t}"
                    },
                    {
                        "username": "mlavergn",
                        "content": "There's no reason this string should fail:\\n\\n\"Snug & raw was I ere I saw war & guns.\"\\n\\nwhen returned as:\\n\\n\".snug & raw was I ere I saw war & gunS\"\\n\\nbut the evaluator for Golang escapes the result as:\\n\\n\".snug \\\\u0026 raw was I ere I saw war \\\\u0026 gunS\"\\n\\nI tried all the escaping mechanisms to get this to pass, but none helped. Looks like a Leetcode bug."
                    },
                    {
                        "username": "chenpku",
                        "content": "Re: [C++ two pointer.](/topic/57750/c-two-pointer)\\n\\nI got the following errors with myself's code. and I re-run your code and also got similar errors, which I think it's leet-code's problem?\\n\\nInput:\\n\"Marge\\nlet's \\\\\"went.\\\\\" I await news telegram.\"\\nOutput:\\n\".margelet swen tiawa I \\\\\".tnew\\\\\" s'tel ,egraM\"\\nExpected:\\n\".margelet swen tiawa I \".tnew\" s'tel ,egraM\""
                    }
                ]
            },
            {
                "id": 1573860,
                "content": [
                    {
                        "username": "baloo-the-bear",
                        "content": "A number of solutions possible for this. Question:\\n- is s.reverse() in Python not good enough answer for interview i.e. needs to be implemented?\\n- I tried \\n\\'\\'\\'\\ns = s[::-1] \\n\\'\\'\\'\\n\\nin python3 - and it does work reverse currectly. \\n>>> s\\n[\\'h\\', \\'e\\', \\'l\\', \\'l\\', \\'o\\']\\n>>> s = s[::-1]\\n>>> s\\n[\\'o\\', \\'l\\', \\'l\\', \\'e\\', \\'h\\']\\n>>> \\n\\nHowever leetcode gives that as an inorrect answer. Thoughts?\\n"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "s[:] = s[::-1] modifies the original string in place by reversing its content, while s = s[::-1] creates a new string object that contains the reversed elements of the original string."
                    },
                    {
                        "username": "enixzyrex",
                        "content": "Apparently this would create another reference of s\\ns = s[::-1]\\nwhereas this would modify it in place\\ns[:] = s[::-1]"
                    },
                    {
                        "username": "egek4",
                        "content": "reverse a string is misleading, i was expecting to use a StringBuilder etc."
                    },
                    {
                        "username": "mark30331",
                        "content": "...\\nwords= \"leetcodeisacommunityforcoders\"\\nprint(words[::-1])\\n\\n..."
                    },
                    {
                        "username": "gsethi2409",
                        "content": "[https://youtu.be/ynZoxE-k5-4](https://youtu.be/ynZoxE-k5-4)"
                    },
                    {
                        "username": "varunpne",
                        "content": "![image](https://assets.leetcode.com/users/varunpne/image_1584728434.png)\\n![image](https://assets.leetcode.com/users/varunpne/image_1584728468.png)\\n\\n\\nSo this happened !!!!"
                    },
                    {
                        "username": "jumshoos",
                        "content": "why this wont accept ?\\n\\n\\'\\'\\'\\ns = s[::-1]\\n\\'\\'\\'"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": " s[:] = s[::-1]"
                    },
                    {
                        "username": "jguan1",
                        "content": "The requirement is to do this in place, but so many approaches here have \"return\" statement. I wonder if the test cases might not be correctly designed. Any ideas?"
                    },
                    {
                        "username": "daralis",
                        "content": "\\n\\tpublic String reverseString(String s){\\n\\t\\treturn new StringBuffer(s).reverse().toString();\\n\\t}"
                    },
                    {
                        "username": "mlavergn",
                        "content": "There's no reason this string should fail:\\n\\n\"Snug & raw was I ere I saw war & guns.\"\\n\\nwhen returned as:\\n\\n\".snug & raw was I ere I saw war & gunS\"\\n\\nbut the evaluator for Golang escapes the result as:\\n\\n\".snug \\\\u0026 raw was I ere I saw war \\\\u0026 gunS\"\\n\\nI tried all the escaping mechanisms to get this to pass, but none helped. Looks like a Leetcode bug."
                    },
                    {
                        "username": "chenpku",
                        "content": "Re: [C++ two pointer.](/topic/57750/c-two-pointer)\\n\\nI got the following errors with myself's code. and I re-run your code and also got similar errors, which I think it's leet-code's problem?\\n\\nInput:\\n\"Marge\\nlet's \\\\\"went.\\\\\" I await news telegram.\"\\nOutput:\\n\".margelet swen tiawa I \\\\\".tnew\\\\\" s'tel ,egraM\"\\nExpected:\\n\".margelet swen tiawa I \".tnew\" s'tel ,egraM\""
                    }
                ]
            },
            {
                "id": 1573531,
                "content": [
                    {
                        "username": "baloo-the-bear",
                        "content": "A number of solutions possible for this. Question:\\n- is s.reverse() in Python not good enough answer for interview i.e. needs to be implemented?\\n- I tried \\n\\'\\'\\'\\ns = s[::-1] \\n\\'\\'\\'\\n\\nin python3 - and it does work reverse currectly. \\n>>> s\\n[\\'h\\', \\'e\\', \\'l\\', \\'l\\', \\'o\\']\\n>>> s = s[::-1]\\n>>> s\\n[\\'o\\', \\'l\\', \\'l\\', \\'e\\', \\'h\\']\\n>>> \\n\\nHowever leetcode gives that as an inorrect answer. Thoughts?\\n"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "s[:] = s[::-1] modifies the original string in place by reversing its content, while s = s[::-1] creates a new string object that contains the reversed elements of the original string."
                    },
                    {
                        "username": "enixzyrex",
                        "content": "Apparently this would create another reference of s\\ns = s[::-1]\\nwhereas this would modify it in place\\ns[:] = s[::-1]"
                    },
                    {
                        "username": "egek4",
                        "content": "reverse a string is misleading, i was expecting to use a StringBuilder etc."
                    },
                    {
                        "username": "mark30331",
                        "content": "...\\nwords= \"leetcodeisacommunityforcoders\"\\nprint(words[::-1])\\n\\n..."
                    },
                    {
                        "username": "gsethi2409",
                        "content": "[https://youtu.be/ynZoxE-k5-4](https://youtu.be/ynZoxE-k5-4)"
                    },
                    {
                        "username": "varunpne",
                        "content": "![image](https://assets.leetcode.com/users/varunpne/image_1584728434.png)\\n![image](https://assets.leetcode.com/users/varunpne/image_1584728468.png)\\n\\n\\nSo this happened !!!!"
                    },
                    {
                        "username": "jumshoos",
                        "content": "why this wont accept ?\\n\\n\\'\\'\\'\\ns = s[::-1]\\n\\'\\'\\'"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": " s[:] = s[::-1]"
                    },
                    {
                        "username": "jguan1",
                        "content": "The requirement is to do this in place, but so many approaches here have \"return\" statement. I wonder if the test cases might not be correctly designed. Any ideas?"
                    },
                    {
                        "username": "daralis",
                        "content": "\\n\\tpublic String reverseString(String s){\\n\\t\\treturn new StringBuffer(s).reverse().toString();\\n\\t}"
                    },
                    {
                        "username": "mlavergn",
                        "content": "There's no reason this string should fail:\\n\\n\"Snug & raw was I ere I saw war & guns.\"\\n\\nwhen returned as:\\n\\n\".snug & raw was I ere I saw war & gunS\"\\n\\nbut the evaluator for Golang escapes the result as:\\n\\n\".snug \\\\u0026 raw was I ere I saw war \\\\u0026 gunS\"\\n\\nI tried all the escaping mechanisms to get this to pass, but none helped. Looks like a Leetcode bug."
                    },
                    {
                        "username": "chenpku",
                        "content": "Re: [C++ two pointer.](/topic/57750/c-two-pointer)\\n\\nI got the following errors with myself's code. and I re-run your code and also got similar errors, which I think it's leet-code's problem?\\n\\nInput:\\n\"Marge\\nlet's \\\\\"went.\\\\\" I await news telegram.\"\\nOutput:\\n\".margelet swen tiawa I \\\\\".tnew\\\\\" s'tel ,egraM\"\\nExpected:\\n\".margelet swen tiawa I \".tnew\" s'tel ,egraM\""
                    }
                ]
            },
            {
                "id": 1573184,
                "content": [
                    {
                        "username": "baloo-the-bear",
                        "content": "A number of solutions possible for this. Question:\\n- is s.reverse() in Python not good enough answer for interview i.e. needs to be implemented?\\n- I tried \\n\\'\\'\\'\\ns = s[::-1] \\n\\'\\'\\'\\n\\nin python3 - and it does work reverse currectly. \\n>>> s\\n[\\'h\\', \\'e\\', \\'l\\', \\'l\\', \\'o\\']\\n>>> s = s[::-1]\\n>>> s\\n[\\'o\\', \\'l\\', \\'l\\', \\'e\\', \\'h\\']\\n>>> \\n\\nHowever leetcode gives that as an inorrect answer. Thoughts?\\n"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "s[:] = s[::-1] modifies the original string in place by reversing its content, while s = s[::-1] creates a new string object that contains the reversed elements of the original string."
                    },
                    {
                        "username": "enixzyrex",
                        "content": "Apparently this would create another reference of s\\ns = s[::-1]\\nwhereas this would modify it in place\\ns[:] = s[::-1]"
                    },
                    {
                        "username": "egek4",
                        "content": "reverse a string is misleading, i was expecting to use a StringBuilder etc."
                    },
                    {
                        "username": "mark30331",
                        "content": "...\\nwords= \"leetcodeisacommunityforcoders\"\\nprint(words[::-1])\\n\\n..."
                    },
                    {
                        "username": "gsethi2409",
                        "content": "[https://youtu.be/ynZoxE-k5-4](https://youtu.be/ynZoxE-k5-4)"
                    },
                    {
                        "username": "varunpne",
                        "content": "![image](https://assets.leetcode.com/users/varunpne/image_1584728434.png)\\n![image](https://assets.leetcode.com/users/varunpne/image_1584728468.png)\\n\\n\\nSo this happened !!!!"
                    },
                    {
                        "username": "jumshoos",
                        "content": "why this wont accept ?\\n\\n\\'\\'\\'\\ns = s[::-1]\\n\\'\\'\\'"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": " s[:] = s[::-1]"
                    },
                    {
                        "username": "jguan1",
                        "content": "The requirement is to do this in place, but so many approaches here have \"return\" statement. I wonder if the test cases might not be correctly designed. Any ideas?"
                    },
                    {
                        "username": "daralis",
                        "content": "\\n\\tpublic String reverseString(String s){\\n\\t\\treturn new StringBuffer(s).reverse().toString();\\n\\t}"
                    },
                    {
                        "username": "mlavergn",
                        "content": "There's no reason this string should fail:\\n\\n\"Snug & raw was I ere I saw war & guns.\"\\n\\nwhen returned as:\\n\\n\".snug & raw was I ere I saw war & gunS\"\\n\\nbut the evaluator for Golang escapes the result as:\\n\\n\".snug \\\\u0026 raw was I ere I saw war \\\\u0026 gunS\"\\n\\nI tried all the escaping mechanisms to get this to pass, but none helped. Looks like a Leetcode bug."
                    },
                    {
                        "username": "chenpku",
                        "content": "Re: [C++ two pointer.](/topic/57750/c-two-pointer)\\n\\nI got the following errors with myself's code. and I re-run your code and also got similar errors, which I think it's leet-code's problem?\\n\\nInput:\\n\"Marge\\nlet's \\\\\"went.\\\\\" I await news telegram.\"\\nOutput:\\n\".margelet swen tiawa I \\\\\".tnew\\\\\" s'tel ,egraM\"\\nExpected:\\n\".margelet swen tiawa I \".tnew\" s'tel ,egraM\""
                    }
                ]
            },
            {
                "id": 1572546,
                "content": [
                    {
                        "username": "baloo-the-bear",
                        "content": "A number of solutions possible for this. Question:\\n- is s.reverse() in Python not good enough answer for interview i.e. needs to be implemented?\\n- I tried \\n\\'\\'\\'\\ns = s[::-1] \\n\\'\\'\\'\\n\\nin python3 - and it does work reverse currectly. \\n>>> s\\n[\\'h\\', \\'e\\', \\'l\\', \\'l\\', \\'o\\']\\n>>> s = s[::-1]\\n>>> s\\n[\\'o\\', \\'l\\', \\'l\\', \\'e\\', \\'h\\']\\n>>> \\n\\nHowever leetcode gives that as an inorrect answer. Thoughts?\\n"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "s[:] = s[::-1] modifies the original string in place by reversing its content, while s = s[::-1] creates a new string object that contains the reversed elements of the original string."
                    },
                    {
                        "username": "enixzyrex",
                        "content": "Apparently this would create another reference of s\\ns = s[::-1]\\nwhereas this would modify it in place\\ns[:] = s[::-1]"
                    },
                    {
                        "username": "egek4",
                        "content": "reverse a string is misleading, i was expecting to use a StringBuilder etc."
                    },
                    {
                        "username": "mark30331",
                        "content": "...\\nwords= \"leetcodeisacommunityforcoders\"\\nprint(words[::-1])\\n\\n..."
                    },
                    {
                        "username": "gsethi2409",
                        "content": "[https://youtu.be/ynZoxE-k5-4](https://youtu.be/ynZoxE-k5-4)"
                    },
                    {
                        "username": "varunpne",
                        "content": "![image](https://assets.leetcode.com/users/varunpne/image_1584728434.png)\\n![image](https://assets.leetcode.com/users/varunpne/image_1584728468.png)\\n\\n\\nSo this happened !!!!"
                    },
                    {
                        "username": "jumshoos",
                        "content": "why this wont accept ?\\n\\n\\'\\'\\'\\ns = s[::-1]\\n\\'\\'\\'"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": " s[:] = s[::-1]"
                    },
                    {
                        "username": "jguan1",
                        "content": "The requirement is to do this in place, but so many approaches here have \"return\" statement. I wonder if the test cases might not be correctly designed. Any ideas?"
                    },
                    {
                        "username": "daralis",
                        "content": "\\n\\tpublic String reverseString(String s){\\n\\t\\treturn new StringBuffer(s).reverse().toString();\\n\\t}"
                    },
                    {
                        "username": "mlavergn",
                        "content": "There's no reason this string should fail:\\n\\n\"Snug & raw was I ere I saw war & guns.\"\\n\\nwhen returned as:\\n\\n\".snug & raw was I ere I saw war & gunS\"\\n\\nbut the evaluator for Golang escapes the result as:\\n\\n\".snug \\\\u0026 raw was I ere I saw war \\\\u0026 gunS\"\\n\\nI tried all the escaping mechanisms to get this to pass, but none helped. Looks like a Leetcode bug."
                    },
                    {
                        "username": "chenpku",
                        "content": "Re: [C++ two pointer.](/topic/57750/c-two-pointer)\\n\\nI got the following errors with myself's code. and I re-run your code and also got similar errors, which I think it's leet-code's problem?\\n\\nInput:\\n\"Marge\\nlet's \\\\\"went.\\\\\" I await news telegram.\"\\nOutput:\\n\".margelet swen tiawa I \\\\\".tnew\\\\\" s'tel ,egraM\"\\nExpected:\\n\".margelet swen tiawa I \".tnew\" s'tel ,egraM\""
                    }
                ]
            },
            {
                "id": 1572302,
                "content": [
                    {
                        "username": "baloo-the-bear",
                        "content": "A number of solutions possible for this. Question:\\n- is s.reverse() in Python not good enough answer for interview i.e. needs to be implemented?\\n- I tried \\n\\'\\'\\'\\ns = s[::-1] \\n\\'\\'\\'\\n\\nin python3 - and it does work reverse currectly. \\n>>> s\\n[\\'h\\', \\'e\\', \\'l\\', \\'l\\', \\'o\\']\\n>>> s = s[::-1]\\n>>> s\\n[\\'o\\', \\'l\\', \\'l\\', \\'e\\', \\'h\\']\\n>>> \\n\\nHowever leetcode gives that as an inorrect answer. Thoughts?\\n"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "s[:] = s[::-1] modifies the original string in place by reversing its content, while s = s[::-1] creates a new string object that contains the reversed elements of the original string."
                    },
                    {
                        "username": "enixzyrex",
                        "content": "Apparently this would create another reference of s\\ns = s[::-1]\\nwhereas this would modify it in place\\ns[:] = s[::-1]"
                    },
                    {
                        "username": "egek4",
                        "content": "reverse a string is misleading, i was expecting to use a StringBuilder etc."
                    },
                    {
                        "username": "mark30331",
                        "content": "...\\nwords= \"leetcodeisacommunityforcoders\"\\nprint(words[::-1])\\n\\n..."
                    },
                    {
                        "username": "gsethi2409",
                        "content": "[https://youtu.be/ynZoxE-k5-4](https://youtu.be/ynZoxE-k5-4)"
                    },
                    {
                        "username": "varunpne",
                        "content": "![image](https://assets.leetcode.com/users/varunpne/image_1584728434.png)\\n![image](https://assets.leetcode.com/users/varunpne/image_1584728468.png)\\n\\n\\nSo this happened !!!!"
                    },
                    {
                        "username": "jumshoos",
                        "content": "why this wont accept ?\\n\\n\\'\\'\\'\\ns = s[::-1]\\n\\'\\'\\'"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": " s[:] = s[::-1]"
                    },
                    {
                        "username": "jguan1",
                        "content": "The requirement is to do this in place, but so many approaches here have \"return\" statement. I wonder if the test cases might not be correctly designed. Any ideas?"
                    },
                    {
                        "username": "daralis",
                        "content": "\\n\\tpublic String reverseString(String s){\\n\\t\\treturn new StringBuffer(s).reverse().toString();\\n\\t}"
                    },
                    {
                        "username": "mlavergn",
                        "content": "There's no reason this string should fail:\\n\\n\"Snug & raw was I ere I saw war & guns.\"\\n\\nwhen returned as:\\n\\n\".snug & raw was I ere I saw war & gunS\"\\n\\nbut the evaluator for Golang escapes the result as:\\n\\n\".snug \\\\u0026 raw was I ere I saw war \\\\u0026 gunS\"\\n\\nI tried all the escaping mechanisms to get this to pass, but none helped. Looks like a Leetcode bug."
                    },
                    {
                        "username": "chenpku",
                        "content": "Re: [C++ two pointer.](/topic/57750/c-two-pointer)\\n\\nI got the following errors with myself's code. and I re-run your code and also got similar errors, which I think it's leet-code's problem?\\n\\nInput:\\n\"Marge\\nlet's \\\\\"went.\\\\\" I await news telegram.\"\\nOutput:\\n\".margelet swen tiawa I \\\\\".tnew\\\\\" s'tel ,egraM\"\\nExpected:\\n\".margelet swen tiawa I \".tnew\" s'tel ,egraM\""
                    }
                ]
            },
            {
                "id": 1571614,
                "content": [
                    {
                        "username": "baloo-the-bear",
                        "content": "A number of solutions possible for this. Question:\\n- is s.reverse() in Python not good enough answer for interview i.e. needs to be implemented?\\n- I tried \\n\\'\\'\\'\\ns = s[::-1] \\n\\'\\'\\'\\n\\nin python3 - and it does work reverse currectly. \\n>>> s\\n[\\'h\\', \\'e\\', \\'l\\', \\'l\\', \\'o\\']\\n>>> s = s[::-1]\\n>>> s\\n[\\'o\\', \\'l\\', \\'l\\', \\'e\\', \\'h\\']\\n>>> \\n\\nHowever leetcode gives that as an inorrect answer. Thoughts?\\n"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "s[:] = s[::-1] modifies the original string in place by reversing its content, while s = s[::-1] creates a new string object that contains the reversed elements of the original string."
                    },
                    {
                        "username": "enixzyrex",
                        "content": "Apparently this would create another reference of s\\ns = s[::-1]\\nwhereas this would modify it in place\\ns[:] = s[::-1]"
                    },
                    {
                        "username": "egek4",
                        "content": "reverse a string is misleading, i was expecting to use a StringBuilder etc."
                    },
                    {
                        "username": "mark30331",
                        "content": "...\\nwords= \"leetcodeisacommunityforcoders\"\\nprint(words[::-1])\\n\\n..."
                    },
                    {
                        "username": "gsethi2409",
                        "content": "[https://youtu.be/ynZoxE-k5-4](https://youtu.be/ynZoxE-k5-4)"
                    },
                    {
                        "username": "varunpne",
                        "content": "![image](https://assets.leetcode.com/users/varunpne/image_1584728434.png)\\n![image](https://assets.leetcode.com/users/varunpne/image_1584728468.png)\\n\\n\\nSo this happened !!!!"
                    },
                    {
                        "username": "jumshoos",
                        "content": "why this wont accept ?\\n\\n\\'\\'\\'\\ns = s[::-1]\\n\\'\\'\\'"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": " s[:] = s[::-1]"
                    },
                    {
                        "username": "jguan1",
                        "content": "The requirement is to do this in place, but so many approaches here have \"return\" statement. I wonder if the test cases might not be correctly designed. Any ideas?"
                    },
                    {
                        "username": "daralis",
                        "content": "\\n\\tpublic String reverseString(String s){\\n\\t\\treturn new StringBuffer(s).reverse().toString();\\n\\t}"
                    },
                    {
                        "username": "mlavergn",
                        "content": "There's no reason this string should fail:\\n\\n\"Snug & raw was I ere I saw war & guns.\"\\n\\nwhen returned as:\\n\\n\".snug & raw was I ere I saw war & gunS\"\\n\\nbut the evaluator for Golang escapes the result as:\\n\\n\".snug \\\\u0026 raw was I ere I saw war \\\\u0026 gunS\"\\n\\nI tried all the escaping mechanisms to get this to pass, but none helped. Looks like a Leetcode bug."
                    },
                    {
                        "username": "chenpku",
                        "content": "Re: [C++ two pointer.](/topic/57750/c-two-pointer)\\n\\nI got the following errors with myself's code. and I re-run your code and also got similar errors, which I think it's leet-code's problem?\\n\\nInput:\\n\"Marge\\nlet's \\\\\"went.\\\\\" I await news telegram.\"\\nOutput:\\n\".margelet swen tiawa I \\\\\".tnew\\\\\" s'tel ,egraM\"\\nExpected:\\n\".margelet swen tiawa I \".tnew\" s'tel ,egraM\""
                    }
                ]
            },
            {
                "id": 1571615,
                "content": [
                    {
                        "username": "baloo-the-bear",
                        "content": "A number of solutions possible for this. Question:\\n- is s.reverse() in Python not good enough answer for interview i.e. needs to be implemented?\\n- I tried \\n\\'\\'\\'\\ns = s[::-1] \\n\\'\\'\\'\\n\\nin python3 - and it does work reverse currectly. \\n>>> s\\n[\\'h\\', \\'e\\', \\'l\\', \\'l\\', \\'o\\']\\n>>> s = s[::-1]\\n>>> s\\n[\\'o\\', \\'l\\', \\'l\\', \\'e\\', \\'h\\']\\n>>> \\n\\nHowever leetcode gives that as an inorrect answer. Thoughts?\\n"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "s[:] = s[::-1] modifies the original string in place by reversing its content, while s = s[::-1] creates a new string object that contains the reversed elements of the original string."
                    },
                    {
                        "username": "enixzyrex",
                        "content": "Apparently this would create another reference of s\\ns = s[::-1]\\nwhereas this would modify it in place\\ns[:] = s[::-1]"
                    },
                    {
                        "username": "egek4",
                        "content": "reverse a string is misleading, i was expecting to use a StringBuilder etc."
                    },
                    {
                        "username": "mark30331",
                        "content": "...\\nwords= \"leetcodeisacommunityforcoders\"\\nprint(words[::-1])\\n\\n..."
                    },
                    {
                        "username": "gsethi2409",
                        "content": "[https://youtu.be/ynZoxE-k5-4](https://youtu.be/ynZoxE-k5-4)"
                    },
                    {
                        "username": "varunpne",
                        "content": "![image](https://assets.leetcode.com/users/varunpne/image_1584728434.png)\\n![image](https://assets.leetcode.com/users/varunpne/image_1584728468.png)\\n\\n\\nSo this happened !!!!"
                    },
                    {
                        "username": "jumshoos",
                        "content": "why this wont accept ?\\n\\n\\'\\'\\'\\ns = s[::-1]\\n\\'\\'\\'"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": " s[:] = s[::-1]"
                    },
                    {
                        "username": "jguan1",
                        "content": "The requirement is to do this in place, but so many approaches here have \"return\" statement. I wonder if the test cases might not be correctly designed. Any ideas?"
                    },
                    {
                        "username": "daralis",
                        "content": "\\n\\tpublic String reverseString(String s){\\n\\t\\treturn new StringBuffer(s).reverse().toString();\\n\\t}"
                    },
                    {
                        "username": "mlavergn",
                        "content": "There's no reason this string should fail:\\n\\n\"Snug & raw was I ere I saw war & guns.\"\\n\\nwhen returned as:\\n\\n\".snug & raw was I ere I saw war & gunS\"\\n\\nbut the evaluator for Golang escapes the result as:\\n\\n\".snug \\\\u0026 raw was I ere I saw war \\\\u0026 gunS\"\\n\\nI tried all the escaping mechanisms to get this to pass, but none helped. Looks like a Leetcode bug."
                    },
                    {
                        "username": "chenpku",
                        "content": "Re: [C++ two pointer.](/topic/57750/c-two-pointer)\\n\\nI got the following errors with myself's code. and I re-run your code and also got similar errors, which I think it's leet-code's problem?\\n\\nInput:\\n\"Marge\\nlet's \\\\\"went.\\\\\" I await news telegram.\"\\nOutput:\\n\".margelet swen tiawa I \\\\\".tnew\\\\\" s'tel ,egraM\"\\nExpected:\\n\".margelet swen tiawa I \".tnew\" s'tel ,egraM\""
                    }
                ]
            },
            {
                "id": 1571616,
                "content": [
                    {
                        "username": "weiliango",
                        "content": "return s[::-1]"
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "I read several answers, and I find most of us use swap to solve this problem. I have to say that string transfer to array and then swap is not a bad idea. However, if we can use stack to solve this problem, it may become much more easy.\\nFor stack, first you push string into stack, and then when you pop it, the first item you pop up is the last item you pushed in, which is the last item of the string. So after we pop up all the items, it is the reverse version of string.\\nI tried many times but I can't make an accept version and share the code to all of us. So I just post my idea and hope to discuss with you guys."
                    },
                    {
                        "username": "tahiraslammm",
                        "content": "\\ts.reverse()"
                    },
                    {
                        "username": "frostcs",
                        "content": "https://youtu.be/LdUnkfn1MII"
                    },
                    {
                        "username": "davidseek",
                        "content": "Hey friends,\\n\\nfor everyone having problem with this challenge,\\nI wrote a detailed explanation on how to tackle it in Swift:\\n\\nhttps://medium.com/@davidseek/leetcode-344-reverse-string-e66eb7aadf4d"
                    },
                    {
                        "username": "bao328",
                        "content": "return s[::-1]"
                    },
                    {
                        "username": "ramyadmz",
                        "content": "I saw it could be solved by in-place sorting. \\nSpecifically in Golang I saw  sort.SliceStable returns correct result but sort.Slice doesn\\'t. Wondering what is the reason?\\n\\n `func reverseString(s []byte)  {\\n    sort.SliceStable(s,func(i,j int)bool{\\n        return j<i\\n    })\\n}`\\n\\n `func reverseString(s []byte)  {\\n    sort.Slice(s,func(i,j int)bool{\\n        return j<i\\n    })\\n}`\\n"
                    },
                    {
                        "username": "StrongerProgrammer7",
                        "content": "Why this code(1) faster than other(2). ATTENTION !THIS IS SPOILER IF YOU DIDN\\'T DECIDED  , DON\\'T WATCH!\\ncode 1\\n  `let i = 0;\\n    let j= s.length-1;\\nvar temp =\"\";\\n    while(i<j)\\n    {\\n        temp = s[i];\\n        s[i] = s[j];\\n        s[j] = temp;\\n        i++;\\n        j--;\\n    }    `\\ncode 2\\n `if(s.length===1)\\n        return;\\n    let left = 0;\\n    let right = s.length-1;\\n    while(left <right)\\n    {\\n        let temp = s[left];\\n        s[left] = s[right];\\n        s[right] = temp;\\n        left++;\\n        right--;\\n    } `"
                    },
                    {
                        "username": "user1283Yf",
                        "content": "Why are my Stdout and Ouput results different? \\n[image](https://drive.google.com/file/d/1gyXByRoWT3axef7_4yFnx-p8AkKpQ8GA/view?usp=sharing)"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "Easiest Question of my life.\\nI can\\'t believe leetcode actually has this level of easy questions. I thought leetcode easy questions were supposed to be hard too..."
                    }
                ]
            },
            {
                "id": 1571617,
                "content": [
                    {
                        "username": "weiliango",
                        "content": "return s[::-1]"
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "I read several answers, and I find most of us use swap to solve this problem. I have to say that string transfer to array and then swap is not a bad idea. However, if we can use stack to solve this problem, it may become much more easy.\\nFor stack, first you push string into stack, and then when you pop it, the first item you pop up is the last item you pushed in, which is the last item of the string. So after we pop up all the items, it is the reverse version of string.\\nI tried many times but I can't make an accept version and share the code to all of us. So I just post my idea and hope to discuss with you guys."
                    },
                    {
                        "username": "tahiraslammm",
                        "content": "\\ts.reverse()"
                    },
                    {
                        "username": "frostcs",
                        "content": "https://youtu.be/LdUnkfn1MII"
                    },
                    {
                        "username": "davidseek",
                        "content": "Hey friends,\\n\\nfor everyone having problem with this challenge,\\nI wrote a detailed explanation on how to tackle it in Swift:\\n\\nhttps://medium.com/@davidseek/leetcode-344-reverse-string-e66eb7aadf4d"
                    },
                    {
                        "username": "bao328",
                        "content": "return s[::-1]"
                    },
                    {
                        "username": "ramyadmz",
                        "content": "I saw it could be solved by in-place sorting. \\nSpecifically in Golang I saw  sort.SliceStable returns correct result but sort.Slice doesn\\'t. Wondering what is the reason?\\n\\n `func reverseString(s []byte)  {\\n    sort.SliceStable(s,func(i,j int)bool{\\n        return j<i\\n    })\\n}`\\n\\n `func reverseString(s []byte)  {\\n    sort.Slice(s,func(i,j int)bool{\\n        return j<i\\n    })\\n}`\\n"
                    },
                    {
                        "username": "StrongerProgrammer7",
                        "content": "Why this code(1) faster than other(2). ATTENTION !THIS IS SPOILER IF YOU DIDN\\'T DECIDED  , DON\\'T WATCH!\\ncode 1\\n  `let i = 0;\\n    let j= s.length-1;\\nvar temp =\"\";\\n    while(i<j)\\n    {\\n        temp = s[i];\\n        s[i] = s[j];\\n        s[j] = temp;\\n        i++;\\n        j--;\\n    }    `\\ncode 2\\n `if(s.length===1)\\n        return;\\n    let left = 0;\\n    let right = s.length-1;\\n    while(left <right)\\n    {\\n        let temp = s[left];\\n        s[left] = s[right];\\n        s[right] = temp;\\n        left++;\\n        right--;\\n    } `"
                    },
                    {
                        "username": "user1283Yf",
                        "content": "Why are my Stdout and Ouput results different? \\n[image](https://drive.google.com/file/d/1gyXByRoWT3axef7_4yFnx-p8AkKpQ8GA/view?usp=sharing)"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "Easiest Question of my life.\\nI can\\'t believe leetcode actually has this level of easy questions. I thought leetcode easy questions were supposed to be hard too..."
                    }
                ]
            },
            {
                "id": 1570491,
                "content": [
                    {
                        "username": "weiliango",
                        "content": "return s[::-1]"
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "I read several answers, and I find most of us use swap to solve this problem. I have to say that string transfer to array and then swap is not a bad idea. However, if we can use stack to solve this problem, it may become much more easy.\\nFor stack, first you push string into stack, and then when you pop it, the first item you pop up is the last item you pushed in, which is the last item of the string. So after we pop up all the items, it is the reverse version of string.\\nI tried many times but I can't make an accept version and share the code to all of us. So I just post my idea and hope to discuss with you guys."
                    },
                    {
                        "username": "tahiraslammm",
                        "content": "\\ts.reverse()"
                    },
                    {
                        "username": "frostcs",
                        "content": "https://youtu.be/LdUnkfn1MII"
                    },
                    {
                        "username": "davidseek",
                        "content": "Hey friends,\\n\\nfor everyone having problem with this challenge,\\nI wrote a detailed explanation on how to tackle it in Swift:\\n\\nhttps://medium.com/@davidseek/leetcode-344-reverse-string-e66eb7aadf4d"
                    },
                    {
                        "username": "bao328",
                        "content": "return s[::-1]"
                    },
                    {
                        "username": "ramyadmz",
                        "content": "I saw it could be solved by in-place sorting. \\nSpecifically in Golang I saw  sort.SliceStable returns correct result but sort.Slice doesn\\'t. Wondering what is the reason?\\n\\n `func reverseString(s []byte)  {\\n    sort.SliceStable(s,func(i,j int)bool{\\n        return j<i\\n    })\\n}`\\n\\n `func reverseString(s []byte)  {\\n    sort.Slice(s,func(i,j int)bool{\\n        return j<i\\n    })\\n}`\\n"
                    },
                    {
                        "username": "StrongerProgrammer7",
                        "content": "Why this code(1) faster than other(2). ATTENTION !THIS IS SPOILER IF YOU DIDN\\'T DECIDED  , DON\\'T WATCH!\\ncode 1\\n  `let i = 0;\\n    let j= s.length-1;\\nvar temp =\"\";\\n    while(i<j)\\n    {\\n        temp = s[i];\\n        s[i] = s[j];\\n        s[j] = temp;\\n        i++;\\n        j--;\\n    }    `\\ncode 2\\n `if(s.length===1)\\n        return;\\n    let left = 0;\\n    let right = s.length-1;\\n    while(left <right)\\n    {\\n        let temp = s[left];\\n        s[left] = s[right];\\n        s[right] = temp;\\n        left++;\\n        right--;\\n    } `"
                    },
                    {
                        "username": "user1283Yf",
                        "content": "Why are my Stdout and Ouput results different? \\n[image](https://drive.google.com/file/d/1gyXByRoWT3axef7_4yFnx-p8AkKpQ8GA/view?usp=sharing)"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "Easiest Question of my life.\\nI can\\'t believe leetcode actually has this level of easy questions. I thought leetcode easy questions were supposed to be hard too..."
                    }
                ]
            },
            {
                "id": 1573868,
                "content": [
                    {
                        "username": "weiliango",
                        "content": "return s[::-1]"
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "I read several answers, and I find most of us use swap to solve this problem. I have to say that string transfer to array and then swap is not a bad idea. However, if we can use stack to solve this problem, it may become much more easy.\\nFor stack, first you push string into stack, and then when you pop it, the first item you pop up is the last item you pushed in, which is the last item of the string. So after we pop up all the items, it is the reverse version of string.\\nI tried many times but I can't make an accept version and share the code to all of us. So I just post my idea and hope to discuss with you guys."
                    },
                    {
                        "username": "tahiraslammm",
                        "content": "\\ts.reverse()"
                    },
                    {
                        "username": "frostcs",
                        "content": "https://youtu.be/LdUnkfn1MII"
                    },
                    {
                        "username": "davidseek",
                        "content": "Hey friends,\\n\\nfor everyone having problem with this challenge,\\nI wrote a detailed explanation on how to tackle it in Swift:\\n\\nhttps://medium.com/@davidseek/leetcode-344-reverse-string-e66eb7aadf4d"
                    },
                    {
                        "username": "bao328",
                        "content": "return s[::-1]"
                    },
                    {
                        "username": "ramyadmz",
                        "content": "I saw it could be solved by in-place sorting. \\nSpecifically in Golang I saw  sort.SliceStable returns correct result but sort.Slice doesn\\'t. Wondering what is the reason?\\n\\n `func reverseString(s []byte)  {\\n    sort.SliceStable(s,func(i,j int)bool{\\n        return j<i\\n    })\\n}`\\n\\n `func reverseString(s []byte)  {\\n    sort.Slice(s,func(i,j int)bool{\\n        return j<i\\n    })\\n}`\\n"
                    },
                    {
                        "username": "StrongerProgrammer7",
                        "content": "Why this code(1) faster than other(2). ATTENTION !THIS IS SPOILER IF YOU DIDN\\'T DECIDED  , DON\\'T WATCH!\\ncode 1\\n  `let i = 0;\\n    let j= s.length-1;\\nvar temp =\"\";\\n    while(i<j)\\n    {\\n        temp = s[i];\\n        s[i] = s[j];\\n        s[j] = temp;\\n        i++;\\n        j--;\\n    }    `\\ncode 2\\n `if(s.length===1)\\n        return;\\n    let left = 0;\\n    let right = s.length-1;\\n    while(left <right)\\n    {\\n        let temp = s[left];\\n        s[left] = s[right];\\n        s[right] = temp;\\n        left++;\\n        right--;\\n    } `"
                    },
                    {
                        "username": "user1283Yf",
                        "content": "Why are my Stdout and Ouput results different? \\n[image](https://drive.google.com/file/d/1gyXByRoWT3axef7_4yFnx-p8AkKpQ8GA/view?usp=sharing)"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "Easiest Question of my life.\\nI can\\'t believe leetcode actually has this level of easy questions. I thought leetcode easy questions were supposed to be hard too..."
                    }
                ]
            },
            {
                "id": 1573866,
                "content": [
                    {
                        "username": "weiliango",
                        "content": "return s[::-1]"
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "I read several answers, and I find most of us use swap to solve this problem. I have to say that string transfer to array and then swap is not a bad idea. However, if we can use stack to solve this problem, it may become much more easy.\\nFor stack, first you push string into stack, and then when you pop it, the first item you pop up is the last item you pushed in, which is the last item of the string. So after we pop up all the items, it is the reverse version of string.\\nI tried many times but I can't make an accept version and share the code to all of us. So I just post my idea and hope to discuss with you guys."
                    },
                    {
                        "username": "tahiraslammm",
                        "content": "\\ts.reverse()"
                    },
                    {
                        "username": "frostcs",
                        "content": "https://youtu.be/LdUnkfn1MII"
                    },
                    {
                        "username": "davidseek",
                        "content": "Hey friends,\\n\\nfor everyone having problem with this challenge,\\nI wrote a detailed explanation on how to tackle it in Swift:\\n\\nhttps://medium.com/@davidseek/leetcode-344-reverse-string-e66eb7aadf4d"
                    },
                    {
                        "username": "bao328",
                        "content": "return s[::-1]"
                    },
                    {
                        "username": "ramyadmz",
                        "content": "I saw it could be solved by in-place sorting. \\nSpecifically in Golang I saw  sort.SliceStable returns correct result but sort.Slice doesn\\'t. Wondering what is the reason?\\n\\n `func reverseString(s []byte)  {\\n    sort.SliceStable(s,func(i,j int)bool{\\n        return j<i\\n    })\\n}`\\n\\n `func reverseString(s []byte)  {\\n    sort.Slice(s,func(i,j int)bool{\\n        return j<i\\n    })\\n}`\\n"
                    },
                    {
                        "username": "StrongerProgrammer7",
                        "content": "Why this code(1) faster than other(2). ATTENTION !THIS IS SPOILER IF YOU DIDN\\'T DECIDED  , DON\\'T WATCH!\\ncode 1\\n  `let i = 0;\\n    let j= s.length-1;\\nvar temp =\"\";\\n    while(i<j)\\n    {\\n        temp = s[i];\\n        s[i] = s[j];\\n        s[j] = temp;\\n        i++;\\n        j--;\\n    }    `\\ncode 2\\n `if(s.length===1)\\n        return;\\n    let left = 0;\\n    let right = s.length-1;\\n    while(left <right)\\n    {\\n        let temp = s[left];\\n        s[left] = s[right];\\n        s[right] = temp;\\n        left++;\\n        right--;\\n    } `"
                    },
                    {
                        "username": "user1283Yf",
                        "content": "Why are my Stdout and Ouput results different? \\n[image](https://drive.google.com/file/d/1gyXByRoWT3axef7_4yFnx-p8AkKpQ8GA/view?usp=sharing)"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "Easiest Question of my life.\\nI can\\'t believe leetcode actually has this level of easy questions. I thought leetcode easy questions were supposed to be hard too..."
                    }
                ]
            },
            {
                "id": 1572133,
                "content": [
                    {
                        "username": "weiliango",
                        "content": "return s[::-1]"
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "I read several answers, and I find most of us use swap to solve this problem. I have to say that string transfer to array and then swap is not a bad idea. However, if we can use stack to solve this problem, it may become much more easy.\\nFor stack, first you push string into stack, and then when you pop it, the first item you pop up is the last item you pushed in, which is the last item of the string. So after we pop up all the items, it is the reverse version of string.\\nI tried many times but I can't make an accept version and share the code to all of us. So I just post my idea and hope to discuss with you guys."
                    },
                    {
                        "username": "tahiraslammm",
                        "content": "\\ts.reverse()"
                    },
                    {
                        "username": "frostcs",
                        "content": "https://youtu.be/LdUnkfn1MII"
                    },
                    {
                        "username": "davidseek",
                        "content": "Hey friends,\\n\\nfor everyone having problem with this challenge,\\nI wrote a detailed explanation on how to tackle it in Swift:\\n\\nhttps://medium.com/@davidseek/leetcode-344-reverse-string-e66eb7aadf4d"
                    },
                    {
                        "username": "bao328",
                        "content": "return s[::-1]"
                    },
                    {
                        "username": "ramyadmz",
                        "content": "I saw it could be solved by in-place sorting. \\nSpecifically in Golang I saw  sort.SliceStable returns correct result but sort.Slice doesn\\'t. Wondering what is the reason?\\n\\n `func reverseString(s []byte)  {\\n    sort.SliceStable(s,func(i,j int)bool{\\n        return j<i\\n    })\\n}`\\n\\n `func reverseString(s []byte)  {\\n    sort.Slice(s,func(i,j int)bool{\\n        return j<i\\n    })\\n}`\\n"
                    },
                    {
                        "username": "StrongerProgrammer7",
                        "content": "Why this code(1) faster than other(2). ATTENTION !THIS IS SPOILER IF YOU DIDN\\'T DECIDED  , DON\\'T WATCH!\\ncode 1\\n  `let i = 0;\\n    let j= s.length-1;\\nvar temp =\"\";\\n    while(i<j)\\n    {\\n        temp = s[i];\\n        s[i] = s[j];\\n        s[j] = temp;\\n        i++;\\n        j--;\\n    }    `\\ncode 2\\n `if(s.length===1)\\n        return;\\n    let left = 0;\\n    let right = s.length-1;\\n    while(left <right)\\n    {\\n        let temp = s[left];\\n        s[left] = s[right];\\n        s[right] = temp;\\n        left++;\\n        right--;\\n    } `"
                    },
                    {
                        "username": "user1283Yf",
                        "content": "Why are my Stdout and Ouput results different? \\n[image](https://drive.google.com/file/d/1gyXByRoWT3axef7_4yFnx-p8AkKpQ8GA/view?usp=sharing)"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "Easiest Question of my life.\\nI can\\'t believe leetcode actually has this level of easy questions. I thought leetcode easy questions were supposed to be hard too..."
                    }
                ]
            },
            {
                "id": 2068834,
                "content": [
                    {
                        "username": "weiliango",
                        "content": "return s[::-1]"
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "I read several answers, and I find most of us use swap to solve this problem. I have to say that string transfer to array and then swap is not a bad idea. However, if we can use stack to solve this problem, it may become much more easy.\\nFor stack, first you push string into stack, and then when you pop it, the first item you pop up is the last item you pushed in, which is the last item of the string. So after we pop up all the items, it is the reverse version of string.\\nI tried many times but I can't make an accept version and share the code to all of us. So I just post my idea and hope to discuss with you guys."
                    },
                    {
                        "username": "tahiraslammm",
                        "content": "\\ts.reverse()"
                    },
                    {
                        "username": "frostcs",
                        "content": "https://youtu.be/LdUnkfn1MII"
                    },
                    {
                        "username": "davidseek",
                        "content": "Hey friends,\\n\\nfor everyone having problem with this challenge,\\nI wrote a detailed explanation on how to tackle it in Swift:\\n\\nhttps://medium.com/@davidseek/leetcode-344-reverse-string-e66eb7aadf4d"
                    },
                    {
                        "username": "bao328",
                        "content": "return s[::-1]"
                    },
                    {
                        "username": "ramyadmz",
                        "content": "I saw it could be solved by in-place sorting. \\nSpecifically in Golang I saw  sort.SliceStable returns correct result but sort.Slice doesn\\'t. Wondering what is the reason?\\n\\n `func reverseString(s []byte)  {\\n    sort.SliceStable(s,func(i,j int)bool{\\n        return j<i\\n    })\\n}`\\n\\n `func reverseString(s []byte)  {\\n    sort.Slice(s,func(i,j int)bool{\\n        return j<i\\n    })\\n}`\\n"
                    },
                    {
                        "username": "StrongerProgrammer7",
                        "content": "Why this code(1) faster than other(2). ATTENTION !THIS IS SPOILER IF YOU DIDN\\'T DECIDED  , DON\\'T WATCH!\\ncode 1\\n  `let i = 0;\\n    let j= s.length-1;\\nvar temp =\"\";\\n    while(i<j)\\n    {\\n        temp = s[i];\\n        s[i] = s[j];\\n        s[j] = temp;\\n        i++;\\n        j--;\\n    }    `\\ncode 2\\n `if(s.length===1)\\n        return;\\n    let left = 0;\\n    let right = s.length-1;\\n    while(left <right)\\n    {\\n        let temp = s[left];\\n        s[left] = s[right];\\n        s[right] = temp;\\n        left++;\\n        right--;\\n    } `"
                    },
                    {
                        "username": "user1283Yf",
                        "content": "Why are my Stdout and Ouput results different? \\n[image](https://drive.google.com/file/d/1gyXByRoWT3axef7_4yFnx-p8AkKpQ8GA/view?usp=sharing)"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "Easiest Question of my life.\\nI can\\'t believe leetcode actually has this level of easy questions. I thought leetcode easy questions were supposed to be hard too..."
                    }
                ]
            },
            {
                "id": 2062752,
                "content": [
                    {
                        "username": "weiliango",
                        "content": "return s[::-1]"
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "I read several answers, and I find most of us use swap to solve this problem. I have to say that string transfer to array and then swap is not a bad idea. However, if we can use stack to solve this problem, it may become much more easy.\\nFor stack, first you push string into stack, and then when you pop it, the first item you pop up is the last item you pushed in, which is the last item of the string. So after we pop up all the items, it is the reverse version of string.\\nI tried many times but I can't make an accept version and share the code to all of us. So I just post my idea and hope to discuss with you guys."
                    },
                    {
                        "username": "tahiraslammm",
                        "content": "\\ts.reverse()"
                    },
                    {
                        "username": "frostcs",
                        "content": "https://youtu.be/LdUnkfn1MII"
                    },
                    {
                        "username": "davidseek",
                        "content": "Hey friends,\\n\\nfor everyone having problem with this challenge,\\nI wrote a detailed explanation on how to tackle it in Swift:\\n\\nhttps://medium.com/@davidseek/leetcode-344-reverse-string-e66eb7aadf4d"
                    },
                    {
                        "username": "bao328",
                        "content": "return s[::-1]"
                    },
                    {
                        "username": "ramyadmz",
                        "content": "I saw it could be solved by in-place sorting. \\nSpecifically in Golang I saw  sort.SliceStable returns correct result but sort.Slice doesn\\'t. Wondering what is the reason?\\n\\n `func reverseString(s []byte)  {\\n    sort.SliceStable(s,func(i,j int)bool{\\n        return j<i\\n    })\\n}`\\n\\n `func reverseString(s []byte)  {\\n    sort.Slice(s,func(i,j int)bool{\\n        return j<i\\n    })\\n}`\\n"
                    },
                    {
                        "username": "StrongerProgrammer7",
                        "content": "Why this code(1) faster than other(2). ATTENTION !THIS IS SPOILER IF YOU DIDN\\'T DECIDED  , DON\\'T WATCH!\\ncode 1\\n  `let i = 0;\\n    let j= s.length-1;\\nvar temp =\"\";\\n    while(i<j)\\n    {\\n        temp = s[i];\\n        s[i] = s[j];\\n        s[j] = temp;\\n        i++;\\n        j--;\\n    }    `\\ncode 2\\n `if(s.length===1)\\n        return;\\n    let left = 0;\\n    let right = s.length-1;\\n    while(left <right)\\n    {\\n        let temp = s[left];\\n        s[left] = s[right];\\n        s[right] = temp;\\n        left++;\\n        right--;\\n    } `"
                    },
                    {
                        "username": "user1283Yf",
                        "content": "Why are my Stdout and Ouput results different? \\n[image](https://drive.google.com/file/d/1gyXByRoWT3axef7_4yFnx-p8AkKpQ8GA/view?usp=sharing)"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "Easiest Question of my life.\\nI can\\'t believe leetcode actually has this level of easy questions. I thought leetcode easy questions were supposed to be hard too..."
                    }
                ]
            },
            {
                "id": 2051796,
                "content": [
                    {
                        "username": "weiliango",
                        "content": "return s[::-1]"
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "I read several answers, and I find most of us use swap to solve this problem. I have to say that string transfer to array and then swap is not a bad idea. However, if we can use stack to solve this problem, it may become much more easy.\\nFor stack, first you push string into stack, and then when you pop it, the first item you pop up is the last item you pushed in, which is the last item of the string. So after we pop up all the items, it is the reverse version of string.\\nI tried many times but I can't make an accept version and share the code to all of us. So I just post my idea and hope to discuss with you guys."
                    },
                    {
                        "username": "tahiraslammm",
                        "content": "\\ts.reverse()"
                    },
                    {
                        "username": "frostcs",
                        "content": "https://youtu.be/LdUnkfn1MII"
                    },
                    {
                        "username": "davidseek",
                        "content": "Hey friends,\\n\\nfor everyone having problem with this challenge,\\nI wrote a detailed explanation on how to tackle it in Swift:\\n\\nhttps://medium.com/@davidseek/leetcode-344-reverse-string-e66eb7aadf4d"
                    },
                    {
                        "username": "bao328",
                        "content": "return s[::-1]"
                    },
                    {
                        "username": "ramyadmz",
                        "content": "I saw it could be solved by in-place sorting. \\nSpecifically in Golang I saw  sort.SliceStable returns correct result but sort.Slice doesn\\'t. Wondering what is the reason?\\n\\n `func reverseString(s []byte)  {\\n    sort.SliceStable(s,func(i,j int)bool{\\n        return j<i\\n    })\\n}`\\n\\n `func reverseString(s []byte)  {\\n    sort.Slice(s,func(i,j int)bool{\\n        return j<i\\n    })\\n}`\\n"
                    },
                    {
                        "username": "StrongerProgrammer7",
                        "content": "Why this code(1) faster than other(2). ATTENTION !THIS IS SPOILER IF YOU DIDN\\'T DECIDED  , DON\\'T WATCH!\\ncode 1\\n  `let i = 0;\\n    let j= s.length-1;\\nvar temp =\"\";\\n    while(i<j)\\n    {\\n        temp = s[i];\\n        s[i] = s[j];\\n        s[j] = temp;\\n        i++;\\n        j--;\\n    }    `\\ncode 2\\n `if(s.length===1)\\n        return;\\n    let left = 0;\\n    let right = s.length-1;\\n    while(left <right)\\n    {\\n        let temp = s[left];\\n        s[left] = s[right];\\n        s[right] = temp;\\n        left++;\\n        right--;\\n    } `"
                    },
                    {
                        "username": "user1283Yf",
                        "content": "Why are my Stdout and Ouput results different? \\n[image](https://drive.google.com/file/d/1gyXByRoWT3axef7_4yFnx-p8AkKpQ8GA/view?usp=sharing)"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "Easiest Question of my life.\\nI can\\'t believe leetcode actually has this level of easy questions. I thought leetcode easy questions were supposed to be hard too..."
                    }
                ]
            },
            {
                "id": 2049910,
                "content": [
                    {
                        "username": "weiliango",
                        "content": "return s[::-1]"
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "I read several answers, and I find most of us use swap to solve this problem. I have to say that string transfer to array and then swap is not a bad idea. However, if we can use stack to solve this problem, it may become much more easy.\\nFor stack, first you push string into stack, and then when you pop it, the first item you pop up is the last item you pushed in, which is the last item of the string. So after we pop up all the items, it is the reverse version of string.\\nI tried many times but I can't make an accept version and share the code to all of us. So I just post my idea and hope to discuss with you guys."
                    },
                    {
                        "username": "tahiraslammm",
                        "content": "\\ts.reverse()"
                    },
                    {
                        "username": "frostcs",
                        "content": "https://youtu.be/LdUnkfn1MII"
                    },
                    {
                        "username": "davidseek",
                        "content": "Hey friends,\\n\\nfor everyone having problem with this challenge,\\nI wrote a detailed explanation on how to tackle it in Swift:\\n\\nhttps://medium.com/@davidseek/leetcode-344-reverse-string-e66eb7aadf4d"
                    },
                    {
                        "username": "bao328",
                        "content": "return s[::-1]"
                    },
                    {
                        "username": "ramyadmz",
                        "content": "I saw it could be solved by in-place sorting. \\nSpecifically in Golang I saw  sort.SliceStable returns correct result but sort.Slice doesn\\'t. Wondering what is the reason?\\n\\n `func reverseString(s []byte)  {\\n    sort.SliceStable(s,func(i,j int)bool{\\n        return j<i\\n    })\\n}`\\n\\n `func reverseString(s []byte)  {\\n    sort.Slice(s,func(i,j int)bool{\\n        return j<i\\n    })\\n}`\\n"
                    },
                    {
                        "username": "StrongerProgrammer7",
                        "content": "Why this code(1) faster than other(2). ATTENTION !THIS IS SPOILER IF YOU DIDN\\'T DECIDED  , DON\\'T WATCH!\\ncode 1\\n  `let i = 0;\\n    let j= s.length-1;\\nvar temp =\"\";\\n    while(i<j)\\n    {\\n        temp = s[i];\\n        s[i] = s[j];\\n        s[j] = temp;\\n        i++;\\n        j--;\\n    }    `\\ncode 2\\n `if(s.length===1)\\n        return;\\n    let left = 0;\\n    let right = s.length-1;\\n    while(left <right)\\n    {\\n        let temp = s[left];\\n        s[left] = s[right];\\n        s[right] = temp;\\n        left++;\\n        right--;\\n    } `"
                    },
                    {
                        "username": "user1283Yf",
                        "content": "Why are my Stdout and Ouput results different? \\n[image](https://drive.google.com/file/d/1gyXByRoWT3axef7_4yFnx-p8AkKpQ8GA/view?usp=sharing)"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "Easiest Question of my life.\\nI can\\'t believe leetcode actually has this level of easy questions. I thought leetcode easy questions were supposed to be hard too..."
                    }
                ]
            },
            {
                "id": 2049754,
                "content": [
                    {
                        "username": "IamGirishReddy",
                        "content": " why am I getting output the same as input I tried with console.log I\\'m getting correct answer in my chrome console editor, please highlight my mistake Thank you in advance  `/**\\n * @param {character[]} s\\n * @return {void} Do not return anything, modify s in-place instead.\\n */\\nvar reverseString = function(s) {\\n    var temp = s;\\n    s=[];\\n    for(let i=temp.length-1;i>=0;i--){\\n        s.push(temp[i]);\\n       \\n    } \\n}; `"
                    },
                    {
                        "username": "user7408ET",
                        "content": "why i See\\no\\nl\\nl\\nl\\no\\n\\n=(((so sad"
                    },
                    {
                        "username": "juansymontano",
                        "content": "\"s.reverse()\"\\n\\ninterviewer: \"implement your own function, how about recursion\"\\n\\n*sweats*\\n\\nThis problem is a litmus test of whether or not a programmer will be replaced by chatgpt. This is not a test of our syntax."
                    },
                    {
                        "username": "charlie_599",
                        "content": "can someone tell me more optimised solution to this \\n\\n\\n`your inline code...your inline code...`\\nclass Solution {\\n    void swap(int i, int j,char[]s){\\n        char temp= s[i];\\n        s[i]=s[j];\\n        s[j]=temp; \\n    }\\n    public void reverseString(char[] s) {\\n        \\n        for(int i=0; i<(s.length)/2; i++){\\n            swap(i,s.length-1-i,s);\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "critango",
                        "content": "In Ruby, you can get the same output just joining the array into a string, then reversing the string, and splitting it back to an array. However the solution is not accepted. Does that violate the in-place rule or something? It seems more efficient to split.reverse.join... could someone elaborate?"
                    },
                    {
                        "username": "RajeshKumarThankaraj",
                        "content": "return s.reverse()\\n\\nIs this not the right solution in JavaScript? why people are doing it differently?"
                    },
                    {
                        "username": "ivozayas",
                        "content": "I tried my code on VS and it works, but here it throws the following error: \"Runtime Error\\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc\" "
                    },
                    {
                        "username": "xenojohn",
                        "content": "Doesn\\'t this problem become impossible for languages that have immutable strings?"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "[@xenojohn](/xenojohn) Oh, my bad, I missed reading the question while replying to you. My solution was the same when I solved it lol \\n```\\n        n=(len(s)//2)\\n        for i in range(n):\\n            (s[i],s[-i-1])=(s[-1-i], s[i])\\n\\n        return s\\n\\n```"
                    },
                    {
                        "username": "xenojohn",
                        "content": "[@gdrag0n](/gdrag0n) Please look up string immutability. The problem says to to it in-place but you cannot modify the elements of a string in Python.\\n\\nHowever, the input is a list, in this case you can and you don\\'t need to use fancy list comprehensions if you want to learn something:\\n\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        l = len(s)\\n\\n        for i in range(l // 2):\\n            s[i], s[l - i - 1] = s[l - i - 1], s[i]\\n        \\n        return s\\n```"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "[@xenojohn](/xenojohn) well then you\\'re stating the obvious. i\\'m addressing the part where you said the problem is impossible just \\'cause they\\'re immutable. if you want to change the order, convert it into a list and proceed, otherwise string manipulation is the way string questions are solved"
                    },
                    {
                        "username": "xenojohn",
                        "content": "[@gdrag0n](/gdrag0n) i know that there are lots of solutions to this. but s[::-1] creates a new string. Strings in Python are immutable, therefore you cannot modify them directly, but rather reassign values to them"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "Don\\'t need to change element positions, just manipulate the string. In py, for eg, using s[::-1] reverses the string"
                    },
                    {
                        "username": "ziadabdalla105",
                        "content": " \\nWhy is this not working here? it works on vscode\\n\\n`\\nvar reverseString = function(s) {\\n    let lastLetter = s.indexOf(s[s.length - 1])\\n\\n    let firstLetter = s.indexOf(s[0])\\n\\n    let arr = []\\n\\n    for(let i = lastLetter; i >= firstLetter; i--){\\n\\n    arr.push(s[i])\\n\\n    }\\n\\n    return arr\\n};\\n`"
                    },
                    {
                        "username": "yeedaKing",
                        "content": " `class Solution(object):\\n\\n    def reverseString(self, s):\\n        if len(s) == 1: return s\\n        else:\\n            return self.reverseString(s[1:]) + [s[0]]`\\n\\nwhy won\\'t this work for the case [\"h\",\"e\",\"l\",\"l\",\"o\"]?  I checked the input on Python IDLE, and it works fine.  What is wrong?"
                    },
                    {
                        "username": "chanputhi9899",
                        "content": "I also got the same error with this code"
                    }
                ]
            },
            {
                "id": 2049490,
                "content": [
                    {
                        "username": "IamGirishReddy",
                        "content": " why am I getting output the same as input I tried with console.log I\\'m getting correct answer in my chrome console editor, please highlight my mistake Thank you in advance  `/**\\n * @param {character[]} s\\n * @return {void} Do not return anything, modify s in-place instead.\\n */\\nvar reverseString = function(s) {\\n    var temp = s;\\n    s=[];\\n    for(let i=temp.length-1;i>=0;i--){\\n        s.push(temp[i]);\\n       \\n    } \\n}; `"
                    },
                    {
                        "username": "user7408ET",
                        "content": "why i See\\no\\nl\\nl\\nl\\no\\n\\n=(((so sad"
                    },
                    {
                        "username": "juansymontano",
                        "content": "\"s.reverse()\"\\n\\ninterviewer: \"implement your own function, how about recursion\"\\n\\n*sweats*\\n\\nThis problem is a litmus test of whether or not a programmer will be replaced by chatgpt. This is not a test of our syntax."
                    },
                    {
                        "username": "charlie_599",
                        "content": "can someone tell me more optimised solution to this \\n\\n\\n`your inline code...your inline code...`\\nclass Solution {\\n    void swap(int i, int j,char[]s){\\n        char temp= s[i];\\n        s[i]=s[j];\\n        s[j]=temp; \\n    }\\n    public void reverseString(char[] s) {\\n        \\n        for(int i=0; i<(s.length)/2; i++){\\n            swap(i,s.length-1-i,s);\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "critango",
                        "content": "In Ruby, you can get the same output just joining the array into a string, then reversing the string, and splitting it back to an array. However the solution is not accepted. Does that violate the in-place rule or something? It seems more efficient to split.reverse.join... could someone elaborate?"
                    },
                    {
                        "username": "RajeshKumarThankaraj",
                        "content": "return s.reverse()\\n\\nIs this not the right solution in JavaScript? why people are doing it differently?"
                    },
                    {
                        "username": "ivozayas",
                        "content": "I tried my code on VS and it works, but here it throws the following error: \"Runtime Error\\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc\" "
                    },
                    {
                        "username": "xenojohn",
                        "content": "Doesn\\'t this problem become impossible for languages that have immutable strings?"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "[@xenojohn](/xenojohn) Oh, my bad, I missed reading the question while replying to you. My solution was the same when I solved it lol \\n```\\n        n=(len(s)//2)\\n        for i in range(n):\\n            (s[i],s[-i-1])=(s[-1-i], s[i])\\n\\n        return s\\n\\n```"
                    },
                    {
                        "username": "xenojohn",
                        "content": "[@gdrag0n](/gdrag0n) Please look up string immutability. The problem says to to it in-place but you cannot modify the elements of a string in Python.\\n\\nHowever, the input is a list, in this case you can and you don\\'t need to use fancy list comprehensions if you want to learn something:\\n\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        l = len(s)\\n\\n        for i in range(l // 2):\\n            s[i], s[l - i - 1] = s[l - i - 1], s[i]\\n        \\n        return s\\n```"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "[@xenojohn](/xenojohn) well then you\\'re stating the obvious. i\\'m addressing the part where you said the problem is impossible just \\'cause they\\'re immutable. if you want to change the order, convert it into a list and proceed, otherwise string manipulation is the way string questions are solved"
                    },
                    {
                        "username": "xenojohn",
                        "content": "[@gdrag0n](/gdrag0n) i know that there are lots of solutions to this. but s[::-1] creates a new string. Strings in Python are immutable, therefore you cannot modify them directly, but rather reassign values to them"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "Don\\'t need to change element positions, just manipulate the string. In py, for eg, using s[::-1] reverses the string"
                    },
                    {
                        "username": "ziadabdalla105",
                        "content": " \\nWhy is this not working here? it works on vscode\\n\\n`\\nvar reverseString = function(s) {\\n    let lastLetter = s.indexOf(s[s.length - 1])\\n\\n    let firstLetter = s.indexOf(s[0])\\n\\n    let arr = []\\n\\n    for(let i = lastLetter; i >= firstLetter; i--){\\n\\n    arr.push(s[i])\\n\\n    }\\n\\n    return arr\\n};\\n`"
                    },
                    {
                        "username": "yeedaKing",
                        "content": " `class Solution(object):\\n\\n    def reverseString(self, s):\\n        if len(s) == 1: return s\\n        else:\\n            return self.reverseString(s[1:]) + [s[0]]`\\n\\nwhy won\\'t this work for the case [\"h\",\"e\",\"l\",\"l\",\"o\"]?  I checked the input on Python IDLE, and it works fine.  What is wrong?"
                    },
                    {
                        "username": "chanputhi9899",
                        "content": "I also got the same error with this code"
                    }
                ]
            },
            {
                "id": 2022019,
                "content": [
                    {
                        "username": "IamGirishReddy",
                        "content": " why am I getting output the same as input I tried with console.log I\\'m getting correct answer in my chrome console editor, please highlight my mistake Thank you in advance  `/**\\n * @param {character[]} s\\n * @return {void} Do not return anything, modify s in-place instead.\\n */\\nvar reverseString = function(s) {\\n    var temp = s;\\n    s=[];\\n    for(let i=temp.length-1;i>=0;i--){\\n        s.push(temp[i]);\\n       \\n    } \\n}; `"
                    },
                    {
                        "username": "user7408ET",
                        "content": "why i See\\no\\nl\\nl\\nl\\no\\n\\n=(((so sad"
                    },
                    {
                        "username": "juansymontano",
                        "content": "\"s.reverse()\"\\n\\ninterviewer: \"implement your own function, how about recursion\"\\n\\n*sweats*\\n\\nThis problem is a litmus test of whether or not a programmer will be replaced by chatgpt. This is not a test of our syntax."
                    },
                    {
                        "username": "charlie_599",
                        "content": "can someone tell me more optimised solution to this \\n\\n\\n`your inline code...your inline code...`\\nclass Solution {\\n    void swap(int i, int j,char[]s){\\n        char temp= s[i];\\n        s[i]=s[j];\\n        s[j]=temp; \\n    }\\n    public void reverseString(char[] s) {\\n        \\n        for(int i=0; i<(s.length)/2; i++){\\n            swap(i,s.length-1-i,s);\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "critango",
                        "content": "In Ruby, you can get the same output just joining the array into a string, then reversing the string, and splitting it back to an array. However the solution is not accepted. Does that violate the in-place rule or something? It seems more efficient to split.reverse.join... could someone elaborate?"
                    },
                    {
                        "username": "RajeshKumarThankaraj",
                        "content": "return s.reverse()\\n\\nIs this not the right solution in JavaScript? why people are doing it differently?"
                    },
                    {
                        "username": "ivozayas",
                        "content": "I tried my code on VS and it works, but here it throws the following error: \"Runtime Error\\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc\" "
                    },
                    {
                        "username": "xenojohn",
                        "content": "Doesn\\'t this problem become impossible for languages that have immutable strings?"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "[@xenojohn](/xenojohn) Oh, my bad, I missed reading the question while replying to you. My solution was the same when I solved it lol \\n```\\n        n=(len(s)//2)\\n        for i in range(n):\\n            (s[i],s[-i-1])=(s[-1-i], s[i])\\n\\n        return s\\n\\n```"
                    },
                    {
                        "username": "xenojohn",
                        "content": "[@gdrag0n](/gdrag0n) Please look up string immutability. The problem says to to it in-place but you cannot modify the elements of a string in Python.\\n\\nHowever, the input is a list, in this case you can and you don\\'t need to use fancy list comprehensions if you want to learn something:\\n\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        l = len(s)\\n\\n        for i in range(l // 2):\\n            s[i], s[l - i - 1] = s[l - i - 1], s[i]\\n        \\n        return s\\n```"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "[@xenojohn](/xenojohn) well then you\\'re stating the obvious. i\\'m addressing the part where you said the problem is impossible just \\'cause they\\'re immutable. if you want to change the order, convert it into a list and proceed, otherwise string manipulation is the way string questions are solved"
                    },
                    {
                        "username": "xenojohn",
                        "content": "[@gdrag0n](/gdrag0n) i know that there are lots of solutions to this. but s[::-1] creates a new string. Strings in Python are immutable, therefore you cannot modify them directly, but rather reassign values to them"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "Don\\'t need to change element positions, just manipulate the string. In py, for eg, using s[::-1] reverses the string"
                    },
                    {
                        "username": "ziadabdalla105",
                        "content": " \\nWhy is this not working here? it works on vscode\\n\\n`\\nvar reverseString = function(s) {\\n    let lastLetter = s.indexOf(s[s.length - 1])\\n\\n    let firstLetter = s.indexOf(s[0])\\n\\n    let arr = []\\n\\n    for(let i = lastLetter; i >= firstLetter; i--){\\n\\n    arr.push(s[i])\\n\\n    }\\n\\n    return arr\\n};\\n`"
                    },
                    {
                        "username": "yeedaKing",
                        "content": " `class Solution(object):\\n\\n    def reverseString(self, s):\\n        if len(s) == 1: return s\\n        else:\\n            return self.reverseString(s[1:]) + [s[0]]`\\n\\nwhy won\\'t this work for the case [\"h\",\"e\",\"l\",\"l\",\"o\"]?  I checked the input on Python IDLE, and it works fine.  What is wrong?"
                    },
                    {
                        "username": "chanputhi9899",
                        "content": "I also got the same error with this code"
                    }
                ]
            },
            {
                "id": 1957394,
                "content": [
                    {
                        "username": "IamGirishReddy",
                        "content": " why am I getting output the same as input I tried with console.log I\\'m getting correct answer in my chrome console editor, please highlight my mistake Thank you in advance  `/**\\n * @param {character[]} s\\n * @return {void} Do not return anything, modify s in-place instead.\\n */\\nvar reverseString = function(s) {\\n    var temp = s;\\n    s=[];\\n    for(let i=temp.length-1;i>=0;i--){\\n        s.push(temp[i]);\\n       \\n    } \\n}; `"
                    },
                    {
                        "username": "user7408ET",
                        "content": "why i See\\no\\nl\\nl\\nl\\no\\n\\n=(((so sad"
                    },
                    {
                        "username": "juansymontano",
                        "content": "\"s.reverse()\"\\n\\ninterviewer: \"implement your own function, how about recursion\"\\n\\n*sweats*\\n\\nThis problem is a litmus test of whether or not a programmer will be replaced by chatgpt. This is not a test of our syntax."
                    },
                    {
                        "username": "charlie_599",
                        "content": "can someone tell me more optimised solution to this \\n\\n\\n`your inline code...your inline code...`\\nclass Solution {\\n    void swap(int i, int j,char[]s){\\n        char temp= s[i];\\n        s[i]=s[j];\\n        s[j]=temp; \\n    }\\n    public void reverseString(char[] s) {\\n        \\n        for(int i=0; i<(s.length)/2; i++){\\n            swap(i,s.length-1-i,s);\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "critango",
                        "content": "In Ruby, you can get the same output just joining the array into a string, then reversing the string, and splitting it back to an array. However the solution is not accepted. Does that violate the in-place rule or something? It seems more efficient to split.reverse.join... could someone elaborate?"
                    },
                    {
                        "username": "RajeshKumarThankaraj",
                        "content": "return s.reverse()\\n\\nIs this not the right solution in JavaScript? why people are doing it differently?"
                    },
                    {
                        "username": "ivozayas",
                        "content": "I tried my code on VS and it works, but here it throws the following error: \"Runtime Error\\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc\" "
                    },
                    {
                        "username": "xenojohn",
                        "content": "Doesn\\'t this problem become impossible for languages that have immutable strings?"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "[@xenojohn](/xenojohn) Oh, my bad, I missed reading the question while replying to you. My solution was the same when I solved it lol \\n```\\n        n=(len(s)//2)\\n        for i in range(n):\\n            (s[i],s[-i-1])=(s[-1-i], s[i])\\n\\n        return s\\n\\n```"
                    },
                    {
                        "username": "xenojohn",
                        "content": "[@gdrag0n](/gdrag0n) Please look up string immutability. The problem says to to it in-place but you cannot modify the elements of a string in Python.\\n\\nHowever, the input is a list, in this case you can and you don\\'t need to use fancy list comprehensions if you want to learn something:\\n\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        l = len(s)\\n\\n        for i in range(l // 2):\\n            s[i], s[l - i - 1] = s[l - i - 1], s[i]\\n        \\n        return s\\n```"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "[@xenojohn](/xenojohn) well then you\\'re stating the obvious. i\\'m addressing the part where you said the problem is impossible just \\'cause they\\'re immutable. if you want to change the order, convert it into a list and proceed, otherwise string manipulation is the way string questions are solved"
                    },
                    {
                        "username": "xenojohn",
                        "content": "[@gdrag0n](/gdrag0n) i know that there are lots of solutions to this. but s[::-1] creates a new string. Strings in Python are immutable, therefore you cannot modify them directly, but rather reassign values to them"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "Don\\'t need to change element positions, just manipulate the string. In py, for eg, using s[::-1] reverses the string"
                    },
                    {
                        "username": "ziadabdalla105",
                        "content": " \\nWhy is this not working here? it works on vscode\\n\\n`\\nvar reverseString = function(s) {\\n    let lastLetter = s.indexOf(s[s.length - 1])\\n\\n    let firstLetter = s.indexOf(s[0])\\n\\n    let arr = []\\n\\n    for(let i = lastLetter; i >= firstLetter; i--){\\n\\n    arr.push(s[i])\\n\\n    }\\n\\n    return arr\\n};\\n`"
                    },
                    {
                        "username": "yeedaKing",
                        "content": " `class Solution(object):\\n\\n    def reverseString(self, s):\\n        if len(s) == 1: return s\\n        else:\\n            return self.reverseString(s[1:]) + [s[0]]`\\n\\nwhy won\\'t this work for the case [\"h\",\"e\",\"l\",\"l\",\"o\"]?  I checked the input on Python IDLE, and it works fine.  What is wrong?"
                    },
                    {
                        "username": "chanputhi9899",
                        "content": "I also got the same error with this code"
                    }
                ]
            },
            {
                "id": 1948552,
                "content": [
                    {
                        "username": "IamGirishReddy",
                        "content": " why am I getting output the same as input I tried with console.log I\\'m getting correct answer in my chrome console editor, please highlight my mistake Thank you in advance  `/**\\n * @param {character[]} s\\n * @return {void} Do not return anything, modify s in-place instead.\\n */\\nvar reverseString = function(s) {\\n    var temp = s;\\n    s=[];\\n    for(let i=temp.length-1;i>=0;i--){\\n        s.push(temp[i]);\\n       \\n    } \\n}; `"
                    },
                    {
                        "username": "user7408ET",
                        "content": "why i See\\no\\nl\\nl\\nl\\no\\n\\n=(((so sad"
                    },
                    {
                        "username": "juansymontano",
                        "content": "\"s.reverse()\"\\n\\ninterviewer: \"implement your own function, how about recursion\"\\n\\n*sweats*\\n\\nThis problem is a litmus test of whether or not a programmer will be replaced by chatgpt. This is not a test of our syntax."
                    },
                    {
                        "username": "charlie_599",
                        "content": "can someone tell me more optimised solution to this \\n\\n\\n`your inline code...your inline code...`\\nclass Solution {\\n    void swap(int i, int j,char[]s){\\n        char temp= s[i];\\n        s[i]=s[j];\\n        s[j]=temp; \\n    }\\n    public void reverseString(char[] s) {\\n        \\n        for(int i=0; i<(s.length)/2; i++){\\n            swap(i,s.length-1-i,s);\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "critango",
                        "content": "In Ruby, you can get the same output just joining the array into a string, then reversing the string, and splitting it back to an array. However the solution is not accepted. Does that violate the in-place rule or something? It seems more efficient to split.reverse.join... could someone elaborate?"
                    },
                    {
                        "username": "RajeshKumarThankaraj",
                        "content": "return s.reverse()\\n\\nIs this not the right solution in JavaScript? why people are doing it differently?"
                    },
                    {
                        "username": "ivozayas",
                        "content": "I tried my code on VS and it works, but here it throws the following error: \"Runtime Error\\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc\" "
                    },
                    {
                        "username": "xenojohn",
                        "content": "Doesn\\'t this problem become impossible for languages that have immutable strings?"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "[@xenojohn](/xenojohn) Oh, my bad, I missed reading the question while replying to you. My solution was the same when I solved it lol \\n```\\n        n=(len(s)//2)\\n        for i in range(n):\\n            (s[i],s[-i-1])=(s[-1-i], s[i])\\n\\n        return s\\n\\n```"
                    },
                    {
                        "username": "xenojohn",
                        "content": "[@gdrag0n](/gdrag0n) Please look up string immutability. The problem says to to it in-place but you cannot modify the elements of a string in Python.\\n\\nHowever, the input is a list, in this case you can and you don\\'t need to use fancy list comprehensions if you want to learn something:\\n\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        l = len(s)\\n\\n        for i in range(l // 2):\\n            s[i], s[l - i - 1] = s[l - i - 1], s[i]\\n        \\n        return s\\n```"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "[@xenojohn](/xenojohn) well then you\\'re stating the obvious. i\\'m addressing the part where you said the problem is impossible just \\'cause they\\'re immutable. if you want to change the order, convert it into a list and proceed, otherwise string manipulation is the way string questions are solved"
                    },
                    {
                        "username": "xenojohn",
                        "content": "[@gdrag0n](/gdrag0n) i know that there are lots of solutions to this. but s[::-1] creates a new string. Strings in Python are immutable, therefore you cannot modify them directly, but rather reassign values to them"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "Don\\'t need to change element positions, just manipulate the string. In py, for eg, using s[::-1] reverses the string"
                    },
                    {
                        "username": "ziadabdalla105",
                        "content": " \\nWhy is this not working here? it works on vscode\\n\\n`\\nvar reverseString = function(s) {\\n    let lastLetter = s.indexOf(s[s.length - 1])\\n\\n    let firstLetter = s.indexOf(s[0])\\n\\n    let arr = []\\n\\n    for(let i = lastLetter; i >= firstLetter; i--){\\n\\n    arr.push(s[i])\\n\\n    }\\n\\n    return arr\\n};\\n`"
                    },
                    {
                        "username": "yeedaKing",
                        "content": " `class Solution(object):\\n\\n    def reverseString(self, s):\\n        if len(s) == 1: return s\\n        else:\\n            return self.reverseString(s[1:]) + [s[0]]`\\n\\nwhy won\\'t this work for the case [\"h\",\"e\",\"l\",\"l\",\"o\"]?  I checked the input on Python IDLE, and it works fine.  What is wrong?"
                    },
                    {
                        "username": "chanputhi9899",
                        "content": "I also got the same error with this code"
                    }
                ]
            },
            {
                "id": 1935915,
                "content": [
                    {
                        "username": "IamGirishReddy",
                        "content": " why am I getting output the same as input I tried with console.log I\\'m getting correct answer in my chrome console editor, please highlight my mistake Thank you in advance  `/**\\n * @param {character[]} s\\n * @return {void} Do not return anything, modify s in-place instead.\\n */\\nvar reverseString = function(s) {\\n    var temp = s;\\n    s=[];\\n    for(let i=temp.length-1;i>=0;i--){\\n        s.push(temp[i]);\\n       \\n    } \\n}; `"
                    },
                    {
                        "username": "user7408ET",
                        "content": "why i See\\no\\nl\\nl\\nl\\no\\n\\n=(((so sad"
                    },
                    {
                        "username": "juansymontano",
                        "content": "\"s.reverse()\"\\n\\ninterviewer: \"implement your own function, how about recursion\"\\n\\n*sweats*\\n\\nThis problem is a litmus test of whether or not a programmer will be replaced by chatgpt. This is not a test of our syntax."
                    },
                    {
                        "username": "charlie_599",
                        "content": "can someone tell me more optimised solution to this \\n\\n\\n`your inline code...your inline code...`\\nclass Solution {\\n    void swap(int i, int j,char[]s){\\n        char temp= s[i];\\n        s[i]=s[j];\\n        s[j]=temp; \\n    }\\n    public void reverseString(char[] s) {\\n        \\n        for(int i=0; i<(s.length)/2; i++){\\n            swap(i,s.length-1-i,s);\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "critango",
                        "content": "In Ruby, you can get the same output just joining the array into a string, then reversing the string, and splitting it back to an array. However the solution is not accepted. Does that violate the in-place rule or something? It seems more efficient to split.reverse.join... could someone elaborate?"
                    },
                    {
                        "username": "RajeshKumarThankaraj",
                        "content": "return s.reverse()\\n\\nIs this not the right solution in JavaScript? why people are doing it differently?"
                    },
                    {
                        "username": "ivozayas",
                        "content": "I tried my code on VS and it works, but here it throws the following error: \"Runtime Error\\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc\" "
                    },
                    {
                        "username": "xenojohn",
                        "content": "Doesn\\'t this problem become impossible for languages that have immutable strings?"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "[@xenojohn](/xenojohn) Oh, my bad, I missed reading the question while replying to you. My solution was the same when I solved it lol \\n```\\n        n=(len(s)//2)\\n        for i in range(n):\\n            (s[i],s[-i-1])=(s[-1-i], s[i])\\n\\n        return s\\n\\n```"
                    },
                    {
                        "username": "xenojohn",
                        "content": "[@gdrag0n](/gdrag0n) Please look up string immutability. The problem says to to it in-place but you cannot modify the elements of a string in Python.\\n\\nHowever, the input is a list, in this case you can and you don\\'t need to use fancy list comprehensions if you want to learn something:\\n\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        l = len(s)\\n\\n        for i in range(l // 2):\\n            s[i], s[l - i - 1] = s[l - i - 1], s[i]\\n        \\n        return s\\n```"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "[@xenojohn](/xenojohn) well then you\\'re stating the obvious. i\\'m addressing the part where you said the problem is impossible just \\'cause they\\'re immutable. if you want to change the order, convert it into a list and proceed, otherwise string manipulation is the way string questions are solved"
                    },
                    {
                        "username": "xenojohn",
                        "content": "[@gdrag0n](/gdrag0n) i know that there are lots of solutions to this. but s[::-1] creates a new string. Strings in Python are immutable, therefore you cannot modify them directly, but rather reassign values to them"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "Don\\'t need to change element positions, just manipulate the string. In py, for eg, using s[::-1] reverses the string"
                    },
                    {
                        "username": "ziadabdalla105",
                        "content": " \\nWhy is this not working here? it works on vscode\\n\\n`\\nvar reverseString = function(s) {\\n    let lastLetter = s.indexOf(s[s.length - 1])\\n\\n    let firstLetter = s.indexOf(s[0])\\n\\n    let arr = []\\n\\n    for(let i = lastLetter; i >= firstLetter; i--){\\n\\n    arr.push(s[i])\\n\\n    }\\n\\n    return arr\\n};\\n`"
                    },
                    {
                        "username": "yeedaKing",
                        "content": " `class Solution(object):\\n\\n    def reverseString(self, s):\\n        if len(s) == 1: return s\\n        else:\\n            return self.reverseString(s[1:]) + [s[0]]`\\n\\nwhy won\\'t this work for the case [\"h\",\"e\",\"l\",\"l\",\"o\"]?  I checked the input on Python IDLE, and it works fine.  What is wrong?"
                    },
                    {
                        "username": "chanputhi9899",
                        "content": "I also got the same error with this code"
                    }
                ]
            },
            {
                "id": 1934812,
                "content": [
                    {
                        "username": "IamGirishReddy",
                        "content": " why am I getting output the same as input I tried with console.log I\\'m getting correct answer in my chrome console editor, please highlight my mistake Thank you in advance  `/**\\n * @param {character[]} s\\n * @return {void} Do not return anything, modify s in-place instead.\\n */\\nvar reverseString = function(s) {\\n    var temp = s;\\n    s=[];\\n    for(let i=temp.length-1;i>=0;i--){\\n        s.push(temp[i]);\\n       \\n    } \\n}; `"
                    },
                    {
                        "username": "user7408ET",
                        "content": "why i See\\no\\nl\\nl\\nl\\no\\n\\n=(((so sad"
                    },
                    {
                        "username": "juansymontano",
                        "content": "\"s.reverse()\"\\n\\ninterviewer: \"implement your own function, how about recursion\"\\n\\n*sweats*\\n\\nThis problem is a litmus test of whether or not a programmer will be replaced by chatgpt. This is not a test of our syntax."
                    },
                    {
                        "username": "charlie_599",
                        "content": "can someone tell me more optimised solution to this \\n\\n\\n`your inline code...your inline code...`\\nclass Solution {\\n    void swap(int i, int j,char[]s){\\n        char temp= s[i];\\n        s[i]=s[j];\\n        s[j]=temp; \\n    }\\n    public void reverseString(char[] s) {\\n        \\n        for(int i=0; i<(s.length)/2; i++){\\n            swap(i,s.length-1-i,s);\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "critango",
                        "content": "In Ruby, you can get the same output just joining the array into a string, then reversing the string, and splitting it back to an array. However the solution is not accepted. Does that violate the in-place rule or something? It seems more efficient to split.reverse.join... could someone elaborate?"
                    },
                    {
                        "username": "RajeshKumarThankaraj",
                        "content": "return s.reverse()\\n\\nIs this not the right solution in JavaScript? why people are doing it differently?"
                    },
                    {
                        "username": "ivozayas",
                        "content": "I tried my code on VS and it works, but here it throws the following error: \"Runtime Error\\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc\" "
                    },
                    {
                        "username": "xenojohn",
                        "content": "Doesn\\'t this problem become impossible for languages that have immutable strings?"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "[@xenojohn](/xenojohn) Oh, my bad, I missed reading the question while replying to you. My solution was the same when I solved it lol \\n```\\n        n=(len(s)//2)\\n        for i in range(n):\\n            (s[i],s[-i-1])=(s[-1-i], s[i])\\n\\n        return s\\n\\n```"
                    },
                    {
                        "username": "xenojohn",
                        "content": "[@gdrag0n](/gdrag0n) Please look up string immutability. The problem says to to it in-place but you cannot modify the elements of a string in Python.\\n\\nHowever, the input is a list, in this case you can and you don\\'t need to use fancy list comprehensions if you want to learn something:\\n\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        l = len(s)\\n\\n        for i in range(l // 2):\\n            s[i], s[l - i - 1] = s[l - i - 1], s[i]\\n        \\n        return s\\n```"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "[@xenojohn](/xenojohn) well then you\\'re stating the obvious. i\\'m addressing the part where you said the problem is impossible just \\'cause they\\'re immutable. if you want to change the order, convert it into a list and proceed, otherwise string manipulation is the way string questions are solved"
                    },
                    {
                        "username": "xenojohn",
                        "content": "[@gdrag0n](/gdrag0n) i know that there are lots of solutions to this. but s[::-1] creates a new string. Strings in Python are immutable, therefore you cannot modify them directly, but rather reassign values to them"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "Don\\'t need to change element positions, just manipulate the string. In py, for eg, using s[::-1] reverses the string"
                    },
                    {
                        "username": "ziadabdalla105",
                        "content": " \\nWhy is this not working here? it works on vscode\\n\\n`\\nvar reverseString = function(s) {\\n    let lastLetter = s.indexOf(s[s.length - 1])\\n\\n    let firstLetter = s.indexOf(s[0])\\n\\n    let arr = []\\n\\n    for(let i = lastLetter; i >= firstLetter; i--){\\n\\n    arr.push(s[i])\\n\\n    }\\n\\n    return arr\\n};\\n`"
                    },
                    {
                        "username": "yeedaKing",
                        "content": " `class Solution(object):\\n\\n    def reverseString(self, s):\\n        if len(s) == 1: return s\\n        else:\\n            return self.reverseString(s[1:]) + [s[0]]`\\n\\nwhy won\\'t this work for the case [\"h\",\"e\",\"l\",\"l\",\"o\"]?  I checked the input on Python IDLE, and it works fine.  What is wrong?"
                    },
                    {
                        "username": "chanputhi9899",
                        "content": "I also got the same error with this code"
                    }
                ]
            },
            {
                "id": 1922181,
                "content": [
                    {
                        "username": "IamGirishReddy",
                        "content": " why am I getting output the same as input I tried with console.log I\\'m getting correct answer in my chrome console editor, please highlight my mistake Thank you in advance  `/**\\n * @param {character[]} s\\n * @return {void} Do not return anything, modify s in-place instead.\\n */\\nvar reverseString = function(s) {\\n    var temp = s;\\n    s=[];\\n    for(let i=temp.length-1;i>=0;i--){\\n        s.push(temp[i]);\\n       \\n    } \\n}; `"
                    },
                    {
                        "username": "user7408ET",
                        "content": "why i See\\no\\nl\\nl\\nl\\no\\n\\n=(((so sad"
                    },
                    {
                        "username": "juansymontano",
                        "content": "\"s.reverse()\"\\n\\ninterviewer: \"implement your own function, how about recursion\"\\n\\n*sweats*\\n\\nThis problem is a litmus test of whether or not a programmer will be replaced by chatgpt. This is not a test of our syntax."
                    },
                    {
                        "username": "charlie_599",
                        "content": "can someone tell me more optimised solution to this \\n\\n\\n`your inline code...your inline code...`\\nclass Solution {\\n    void swap(int i, int j,char[]s){\\n        char temp= s[i];\\n        s[i]=s[j];\\n        s[j]=temp; \\n    }\\n    public void reverseString(char[] s) {\\n        \\n        for(int i=0; i<(s.length)/2; i++){\\n            swap(i,s.length-1-i,s);\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "critango",
                        "content": "In Ruby, you can get the same output just joining the array into a string, then reversing the string, and splitting it back to an array. However the solution is not accepted. Does that violate the in-place rule or something? It seems more efficient to split.reverse.join... could someone elaborate?"
                    },
                    {
                        "username": "RajeshKumarThankaraj",
                        "content": "return s.reverse()\\n\\nIs this not the right solution in JavaScript? why people are doing it differently?"
                    },
                    {
                        "username": "ivozayas",
                        "content": "I tried my code on VS and it works, but here it throws the following error: \"Runtime Error\\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc\" "
                    },
                    {
                        "username": "xenojohn",
                        "content": "Doesn\\'t this problem become impossible for languages that have immutable strings?"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "[@xenojohn](/xenojohn) Oh, my bad, I missed reading the question while replying to you. My solution was the same when I solved it lol \\n```\\n        n=(len(s)//2)\\n        for i in range(n):\\n            (s[i],s[-i-1])=(s[-1-i], s[i])\\n\\n        return s\\n\\n```"
                    },
                    {
                        "username": "xenojohn",
                        "content": "[@gdrag0n](/gdrag0n) Please look up string immutability. The problem says to to it in-place but you cannot modify the elements of a string in Python.\\n\\nHowever, the input is a list, in this case you can and you don\\'t need to use fancy list comprehensions if you want to learn something:\\n\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        l = len(s)\\n\\n        for i in range(l // 2):\\n            s[i], s[l - i - 1] = s[l - i - 1], s[i]\\n        \\n        return s\\n```"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "[@xenojohn](/xenojohn) well then you\\'re stating the obvious. i\\'m addressing the part where you said the problem is impossible just \\'cause they\\'re immutable. if you want to change the order, convert it into a list and proceed, otherwise string manipulation is the way string questions are solved"
                    },
                    {
                        "username": "xenojohn",
                        "content": "[@gdrag0n](/gdrag0n) i know that there are lots of solutions to this. but s[::-1] creates a new string. Strings in Python are immutable, therefore you cannot modify them directly, but rather reassign values to them"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "Don\\'t need to change element positions, just manipulate the string. In py, for eg, using s[::-1] reverses the string"
                    },
                    {
                        "username": "ziadabdalla105",
                        "content": " \\nWhy is this not working here? it works on vscode\\n\\n`\\nvar reverseString = function(s) {\\n    let lastLetter = s.indexOf(s[s.length - 1])\\n\\n    let firstLetter = s.indexOf(s[0])\\n\\n    let arr = []\\n\\n    for(let i = lastLetter; i >= firstLetter; i--){\\n\\n    arr.push(s[i])\\n\\n    }\\n\\n    return arr\\n};\\n`"
                    },
                    {
                        "username": "yeedaKing",
                        "content": " `class Solution(object):\\n\\n    def reverseString(self, s):\\n        if len(s) == 1: return s\\n        else:\\n            return self.reverseString(s[1:]) + [s[0]]`\\n\\nwhy won\\'t this work for the case [\"h\",\"e\",\"l\",\"l\",\"o\"]?  I checked the input on Python IDLE, and it works fine.  What is wrong?"
                    },
                    {
                        "username": "chanputhi9899",
                        "content": "I also got the same error with this code"
                    }
                ]
            },
            {
                "id": 1896485,
                "content": [
                    {
                        "username": "IamGirishReddy",
                        "content": " why am I getting output the same as input I tried with console.log I\\'m getting correct answer in my chrome console editor, please highlight my mistake Thank you in advance  `/**\\n * @param {character[]} s\\n * @return {void} Do not return anything, modify s in-place instead.\\n */\\nvar reverseString = function(s) {\\n    var temp = s;\\n    s=[];\\n    for(let i=temp.length-1;i>=0;i--){\\n        s.push(temp[i]);\\n       \\n    } \\n}; `"
                    },
                    {
                        "username": "user7408ET",
                        "content": "why i See\\no\\nl\\nl\\nl\\no\\n\\n=(((so sad"
                    },
                    {
                        "username": "juansymontano",
                        "content": "\"s.reverse()\"\\n\\ninterviewer: \"implement your own function, how about recursion\"\\n\\n*sweats*\\n\\nThis problem is a litmus test of whether or not a programmer will be replaced by chatgpt. This is not a test of our syntax."
                    },
                    {
                        "username": "charlie_599",
                        "content": "can someone tell me more optimised solution to this \\n\\n\\n`your inline code...your inline code...`\\nclass Solution {\\n    void swap(int i, int j,char[]s){\\n        char temp= s[i];\\n        s[i]=s[j];\\n        s[j]=temp; \\n    }\\n    public void reverseString(char[] s) {\\n        \\n        for(int i=0; i<(s.length)/2; i++){\\n            swap(i,s.length-1-i,s);\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "critango",
                        "content": "In Ruby, you can get the same output just joining the array into a string, then reversing the string, and splitting it back to an array. However the solution is not accepted. Does that violate the in-place rule or something? It seems more efficient to split.reverse.join... could someone elaborate?"
                    },
                    {
                        "username": "RajeshKumarThankaraj",
                        "content": "return s.reverse()\\n\\nIs this not the right solution in JavaScript? why people are doing it differently?"
                    },
                    {
                        "username": "ivozayas",
                        "content": "I tried my code on VS and it works, but here it throws the following error: \"Runtime Error\\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc\" "
                    },
                    {
                        "username": "xenojohn",
                        "content": "Doesn\\'t this problem become impossible for languages that have immutable strings?"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "[@xenojohn](/xenojohn) Oh, my bad, I missed reading the question while replying to you. My solution was the same when I solved it lol \\n```\\n        n=(len(s)//2)\\n        for i in range(n):\\n            (s[i],s[-i-1])=(s[-1-i], s[i])\\n\\n        return s\\n\\n```"
                    },
                    {
                        "username": "xenojohn",
                        "content": "[@gdrag0n](/gdrag0n) Please look up string immutability. The problem says to to it in-place but you cannot modify the elements of a string in Python.\\n\\nHowever, the input is a list, in this case you can and you don\\'t need to use fancy list comprehensions if you want to learn something:\\n\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        l = len(s)\\n\\n        for i in range(l // 2):\\n            s[i], s[l - i - 1] = s[l - i - 1], s[i]\\n        \\n        return s\\n```"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "[@xenojohn](/xenojohn) well then you\\'re stating the obvious. i\\'m addressing the part where you said the problem is impossible just \\'cause they\\'re immutable. if you want to change the order, convert it into a list and proceed, otherwise string manipulation is the way string questions are solved"
                    },
                    {
                        "username": "xenojohn",
                        "content": "[@gdrag0n](/gdrag0n) i know that there are lots of solutions to this. but s[::-1] creates a new string. Strings in Python are immutable, therefore you cannot modify them directly, but rather reassign values to them"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "Don\\'t need to change element positions, just manipulate the string. In py, for eg, using s[::-1] reverses the string"
                    },
                    {
                        "username": "ziadabdalla105",
                        "content": " \\nWhy is this not working here? it works on vscode\\n\\n`\\nvar reverseString = function(s) {\\n    let lastLetter = s.indexOf(s[s.length - 1])\\n\\n    let firstLetter = s.indexOf(s[0])\\n\\n    let arr = []\\n\\n    for(let i = lastLetter; i >= firstLetter; i--){\\n\\n    arr.push(s[i])\\n\\n    }\\n\\n    return arr\\n};\\n`"
                    },
                    {
                        "username": "yeedaKing",
                        "content": " `class Solution(object):\\n\\n    def reverseString(self, s):\\n        if len(s) == 1: return s\\n        else:\\n            return self.reverseString(s[1:]) + [s[0]]`\\n\\nwhy won\\'t this work for the case [\"h\",\"e\",\"l\",\"l\",\"o\"]?  I checked the input on Python IDLE, and it works fine.  What is wrong?"
                    },
                    {
                        "username": "chanputhi9899",
                        "content": "I also got the same error with this code"
                    }
                ]
            },
            {
                "id": 1895520,
                "content": [
                    {
                        "username": "IamGirishReddy",
                        "content": " why am I getting output the same as input I tried with console.log I\\'m getting correct answer in my chrome console editor, please highlight my mistake Thank you in advance  `/**\\n * @param {character[]} s\\n * @return {void} Do not return anything, modify s in-place instead.\\n */\\nvar reverseString = function(s) {\\n    var temp = s;\\n    s=[];\\n    for(let i=temp.length-1;i>=0;i--){\\n        s.push(temp[i]);\\n       \\n    } \\n}; `"
                    },
                    {
                        "username": "user7408ET",
                        "content": "why i See\\no\\nl\\nl\\nl\\no\\n\\n=(((so sad"
                    },
                    {
                        "username": "juansymontano",
                        "content": "\"s.reverse()\"\\n\\ninterviewer: \"implement your own function, how about recursion\"\\n\\n*sweats*\\n\\nThis problem is a litmus test of whether or not a programmer will be replaced by chatgpt. This is not a test of our syntax."
                    },
                    {
                        "username": "charlie_599",
                        "content": "can someone tell me more optimised solution to this \\n\\n\\n`your inline code...your inline code...`\\nclass Solution {\\n    void swap(int i, int j,char[]s){\\n        char temp= s[i];\\n        s[i]=s[j];\\n        s[j]=temp; \\n    }\\n    public void reverseString(char[] s) {\\n        \\n        for(int i=0; i<(s.length)/2; i++){\\n            swap(i,s.length-1-i,s);\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "critango",
                        "content": "In Ruby, you can get the same output just joining the array into a string, then reversing the string, and splitting it back to an array. However the solution is not accepted. Does that violate the in-place rule or something? It seems more efficient to split.reverse.join... could someone elaborate?"
                    },
                    {
                        "username": "RajeshKumarThankaraj",
                        "content": "return s.reverse()\\n\\nIs this not the right solution in JavaScript? why people are doing it differently?"
                    },
                    {
                        "username": "ivozayas",
                        "content": "I tried my code on VS and it works, but here it throws the following error: \"Runtime Error\\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc\" "
                    },
                    {
                        "username": "xenojohn",
                        "content": "Doesn\\'t this problem become impossible for languages that have immutable strings?"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "[@xenojohn](/xenojohn) Oh, my bad, I missed reading the question while replying to you. My solution was the same when I solved it lol \\n```\\n        n=(len(s)//2)\\n        for i in range(n):\\n            (s[i],s[-i-1])=(s[-1-i], s[i])\\n\\n        return s\\n\\n```"
                    },
                    {
                        "username": "xenojohn",
                        "content": "[@gdrag0n](/gdrag0n) Please look up string immutability. The problem says to to it in-place but you cannot modify the elements of a string in Python.\\n\\nHowever, the input is a list, in this case you can and you don\\'t need to use fancy list comprehensions if you want to learn something:\\n\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        l = len(s)\\n\\n        for i in range(l // 2):\\n            s[i], s[l - i - 1] = s[l - i - 1], s[i]\\n        \\n        return s\\n```"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "[@xenojohn](/xenojohn) well then you\\'re stating the obvious. i\\'m addressing the part where you said the problem is impossible just \\'cause they\\'re immutable. if you want to change the order, convert it into a list and proceed, otherwise string manipulation is the way string questions are solved"
                    },
                    {
                        "username": "xenojohn",
                        "content": "[@gdrag0n](/gdrag0n) i know that there are lots of solutions to this. but s[::-1] creates a new string. Strings in Python are immutable, therefore you cannot modify them directly, but rather reassign values to them"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "Don\\'t need to change element positions, just manipulate the string. In py, for eg, using s[::-1] reverses the string"
                    },
                    {
                        "username": "ziadabdalla105",
                        "content": " \\nWhy is this not working here? it works on vscode\\n\\n`\\nvar reverseString = function(s) {\\n    let lastLetter = s.indexOf(s[s.length - 1])\\n\\n    let firstLetter = s.indexOf(s[0])\\n\\n    let arr = []\\n\\n    for(let i = lastLetter; i >= firstLetter; i--){\\n\\n    arr.push(s[i])\\n\\n    }\\n\\n    return arr\\n};\\n`"
                    },
                    {
                        "username": "yeedaKing",
                        "content": " `class Solution(object):\\n\\n    def reverseString(self, s):\\n        if len(s) == 1: return s\\n        else:\\n            return self.reverseString(s[1:]) + [s[0]]`\\n\\nwhy won\\'t this work for the case [\"h\",\"e\",\"l\",\"l\",\"o\"]?  I checked the input on Python IDLE, and it works fine.  What is wrong?"
                    },
                    {
                        "username": "chanputhi9899",
                        "content": "I also got the same error with this code"
                    }
                ]
            },
            {
                "id": 1862312,
                "content": [
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "Hi, I was wondering if I could actually use a different solution than the built-in functions so I tried to code a small alghorithm using something like a binary search and I came up to the one you can find below in the comments. Don\\'t actually know if its the best sol you can come up with, but  it was worh a try for a junior like me :)"
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "`\n    \n class Solution:\n        \n        def reverseString(self, s: List[str]) -> None:\n            \n            left = 0\n            right = len(s) - 1\n\n            while left <= right:\n\n                s[left], s[right] = s[right], s[left]\n                left += 1\n                right -= 1\n`"
                    },
                    {
                        "username": "Msey",
                        "content": "s[i] ^= s[s.Length - 1 - i];\\ns[s.Length - 1 - i] ^= s[i];\\ns[i] ^= s[s.Length - 1 - i];\\n\\nThe end"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "We can use recursion here."
                    },
                    {
                        "username": "alikhanarman786",
                        "content": "java solution: \\n\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int start = 0 , end = s.length-1;\\n        char temp;\\n        while(start<=end){\\n            if(s[start] != s[end]){\\n                temp = s[start];\\n                s[start] = s[end];\\n                s[end] = temp;\\n            }\\n            start++;\\n            end--;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        int n = s.length;\\n        char b[] = new char[n];\\n        int j=n-1;\\n        for(int i=0;i<n;i++){\\n            b[i]=s[i];\\n        }\\n        for(int i=0;i<n;i++){\\n          //  b[i]=s[i];\\n          \\n            s[i]=b[j];\\n            j--;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "Easiest and effective way to do it\\n\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int j =1;\\n       for(int i=0;i<s.length/2;i++){\\n           char temp = s[s.length-j];\\n           s[s.length-j] = s[i];\\n           s[i] = temp;\\n           j++;\\n       }\\n    }\\n}"
                    },
                    {
                        "username": "kk_205",
                        "content": "I   didn\\'t  get , when question says that input is given  in the array  form then why it  takes argument as a string only ??\\n I am beginner can anybody explain it?"
                    },
                    {
                        "username": "kk_205",
                        "content": "\"You must do this by modifying the input array in-place with O(1) extra memory.\"    what does it mean \" in place\" ??? plzz"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "https://leetcode.com/problems/reverse-string/solutions/3071840/4-line-easy-solution-o-n-complexity/"
                    },
                    {
                        "username": "31703it",
                        "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n         int beg=0,end=s.size()-1,temp;\\n    while(beg<end)\\n    {\\n        temp=s[beg];\\n        s[beg]=s[end];\\n        s[end]=temp;\\n        beg++;\\n        end--;\\n    }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1856884,
                "content": [
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "Hi, I was wondering if I could actually use a different solution than the built-in functions so I tried to code a small alghorithm using something like a binary search and I came up to the one you can find below in the comments. Don\\'t actually know if its the best sol you can come up with, but  it was worh a try for a junior like me :)"
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "`\n    \n class Solution:\n        \n        def reverseString(self, s: List[str]) -> None:\n            \n            left = 0\n            right = len(s) - 1\n\n            while left <= right:\n\n                s[left], s[right] = s[right], s[left]\n                left += 1\n                right -= 1\n`"
                    },
                    {
                        "username": "Msey",
                        "content": "s[i] ^= s[s.Length - 1 - i];\\ns[s.Length - 1 - i] ^= s[i];\\ns[i] ^= s[s.Length - 1 - i];\\n\\nThe end"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "We can use recursion here."
                    },
                    {
                        "username": "alikhanarman786",
                        "content": "java solution: \\n\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int start = 0 , end = s.length-1;\\n        char temp;\\n        while(start<=end){\\n            if(s[start] != s[end]){\\n                temp = s[start];\\n                s[start] = s[end];\\n                s[end] = temp;\\n            }\\n            start++;\\n            end--;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        int n = s.length;\\n        char b[] = new char[n];\\n        int j=n-1;\\n        for(int i=0;i<n;i++){\\n            b[i]=s[i];\\n        }\\n        for(int i=0;i<n;i++){\\n          //  b[i]=s[i];\\n          \\n            s[i]=b[j];\\n            j--;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "Easiest and effective way to do it\\n\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int j =1;\\n       for(int i=0;i<s.length/2;i++){\\n           char temp = s[s.length-j];\\n           s[s.length-j] = s[i];\\n           s[i] = temp;\\n           j++;\\n       }\\n    }\\n}"
                    },
                    {
                        "username": "kk_205",
                        "content": "I   didn\\'t  get , when question says that input is given  in the array  form then why it  takes argument as a string only ??\\n I am beginner can anybody explain it?"
                    },
                    {
                        "username": "kk_205",
                        "content": "\"You must do this by modifying the input array in-place with O(1) extra memory.\"    what does it mean \" in place\" ??? plzz"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "https://leetcode.com/problems/reverse-string/solutions/3071840/4-line-easy-solution-o-n-complexity/"
                    },
                    {
                        "username": "31703it",
                        "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n         int beg=0,end=s.size()-1,temp;\\n    while(beg<end)\\n    {\\n        temp=s[beg];\\n        s[beg]=s[end];\\n        s[end]=temp;\\n        beg++;\\n        end--;\\n    }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1847072,
                "content": [
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "Hi, I was wondering if I could actually use a different solution than the built-in functions so I tried to code a small alghorithm using something like a binary search and I came up to the one you can find below in the comments. Don\\'t actually know if its the best sol you can come up with, but  it was worh a try for a junior like me :)"
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "`\n    \n class Solution:\n        \n        def reverseString(self, s: List[str]) -> None:\n            \n            left = 0\n            right = len(s) - 1\n\n            while left <= right:\n\n                s[left], s[right] = s[right], s[left]\n                left += 1\n                right -= 1\n`"
                    },
                    {
                        "username": "Msey",
                        "content": "s[i] ^= s[s.Length - 1 - i];\\ns[s.Length - 1 - i] ^= s[i];\\ns[i] ^= s[s.Length - 1 - i];\\n\\nThe end"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "We can use recursion here."
                    },
                    {
                        "username": "alikhanarman786",
                        "content": "java solution: \\n\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int start = 0 , end = s.length-1;\\n        char temp;\\n        while(start<=end){\\n            if(s[start] != s[end]){\\n                temp = s[start];\\n                s[start] = s[end];\\n                s[end] = temp;\\n            }\\n            start++;\\n            end--;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        int n = s.length;\\n        char b[] = new char[n];\\n        int j=n-1;\\n        for(int i=0;i<n;i++){\\n            b[i]=s[i];\\n        }\\n        for(int i=0;i<n;i++){\\n          //  b[i]=s[i];\\n          \\n            s[i]=b[j];\\n            j--;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "Easiest and effective way to do it\\n\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int j =1;\\n       for(int i=0;i<s.length/2;i++){\\n           char temp = s[s.length-j];\\n           s[s.length-j] = s[i];\\n           s[i] = temp;\\n           j++;\\n       }\\n    }\\n}"
                    },
                    {
                        "username": "kk_205",
                        "content": "I   didn\\'t  get , when question says that input is given  in the array  form then why it  takes argument as a string only ??\\n I am beginner can anybody explain it?"
                    },
                    {
                        "username": "kk_205",
                        "content": "\"You must do this by modifying the input array in-place with O(1) extra memory.\"    what does it mean \" in place\" ??? plzz"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "https://leetcode.com/problems/reverse-string/solutions/3071840/4-line-easy-solution-o-n-complexity/"
                    },
                    {
                        "username": "31703it",
                        "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n         int beg=0,end=s.size()-1,temp;\\n    while(beg<end)\\n    {\\n        temp=s[beg];\\n        s[beg]=s[end];\\n        s[end]=temp;\\n        beg++;\\n        end--;\\n    }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1836960,
                "content": [
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "Hi, I was wondering if I could actually use a different solution than the built-in functions so I tried to code a small alghorithm using something like a binary search and I came up to the one you can find below in the comments. Don\\'t actually know if its the best sol you can come up with, but  it was worh a try for a junior like me :)"
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "`\n    \n class Solution:\n        \n        def reverseString(self, s: List[str]) -> None:\n            \n            left = 0\n            right = len(s) - 1\n\n            while left <= right:\n\n                s[left], s[right] = s[right], s[left]\n                left += 1\n                right -= 1\n`"
                    },
                    {
                        "username": "Msey",
                        "content": "s[i] ^= s[s.Length - 1 - i];\\ns[s.Length - 1 - i] ^= s[i];\\ns[i] ^= s[s.Length - 1 - i];\\n\\nThe end"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "We can use recursion here."
                    },
                    {
                        "username": "alikhanarman786",
                        "content": "java solution: \\n\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int start = 0 , end = s.length-1;\\n        char temp;\\n        while(start<=end){\\n            if(s[start] != s[end]){\\n                temp = s[start];\\n                s[start] = s[end];\\n                s[end] = temp;\\n            }\\n            start++;\\n            end--;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        int n = s.length;\\n        char b[] = new char[n];\\n        int j=n-1;\\n        for(int i=0;i<n;i++){\\n            b[i]=s[i];\\n        }\\n        for(int i=0;i<n;i++){\\n          //  b[i]=s[i];\\n          \\n            s[i]=b[j];\\n            j--;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "Easiest and effective way to do it\\n\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int j =1;\\n       for(int i=0;i<s.length/2;i++){\\n           char temp = s[s.length-j];\\n           s[s.length-j] = s[i];\\n           s[i] = temp;\\n           j++;\\n       }\\n    }\\n}"
                    },
                    {
                        "username": "kk_205",
                        "content": "I   didn\\'t  get , when question says that input is given  in the array  form then why it  takes argument as a string only ??\\n I am beginner can anybody explain it?"
                    },
                    {
                        "username": "kk_205",
                        "content": "\"You must do this by modifying the input array in-place with O(1) extra memory.\"    what does it mean \" in place\" ??? plzz"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "https://leetcode.com/problems/reverse-string/solutions/3071840/4-line-easy-solution-o-n-complexity/"
                    },
                    {
                        "username": "31703it",
                        "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n         int beg=0,end=s.size()-1,temp;\\n    while(beg<end)\\n    {\\n        temp=s[beg];\\n        s[beg]=s[end];\\n        s[end]=temp;\\n        beg++;\\n        end--;\\n    }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1798962,
                "content": [
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "Hi, I was wondering if I could actually use a different solution than the built-in functions so I tried to code a small alghorithm using something like a binary search and I came up to the one you can find below in the comments. Don\\'t actually know if its the best sol you can come up with, but  it was worh a try for a junior like me :)"
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "`\n    \n class Solution:\n        \n        def reverseString(self, s: List[str]) -> None:\n            \n            left = 0\n            right = len(s) - 1\n\n            while left <= right:\n\n                s[left], s[right] = s[right], s[left]\n                left += 1\n                right -= 1\n`"
                    },
                    {
                        "username": "Msey",
                        "content": "s[i] ^= s[s.Length - 1 - i];\\ns[s.Length - 1 - i] ^= s[i];\\ns[i] ^= s[s.Length - 1 - i];\\n\\nThe end"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "We can use recursion here."
                    },
                    {
                        "username": "alikhanarman786",
                        "content": "java solution: \\n\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int start = 0 , end = s.length-1;\\n        char temp;\\n        while(start<=end){\\n            if(s[start] != s[end]){\\n                temp = s[start];\\n                s[start] = s[end];\\n                s[end] = temp;\\n            }\\n            start++;\\n            end--;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        int n = s.length;\\n        char b[] = new char[n];\\n        int j=n-1;\\n        for(int i=0;i<n;i++){\\n            b[i]=s[i];\\n        }\\n        for(int i=0;i<n;i++){\\n          //  b[i]=s[i];\\n          \\n            s[i]=b[j];\\n            j--;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "Easiest and effective way to do it\\n\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int j =1;\\n       for(int i=0;i<s.length/2;i++){\\n           char temp = s[s.length-j];\\n           s[s.length-j] = s[i];\\n           s[i] = temp;\\n           j++;\\n       }\\n    }\\n}"
                    },
                    {
                        "username": "kk_205",
                        "content": "I   didn\\'t  get , when question says that input is given  in the array  form then why it  takes argument as a string only ??\\n I am beginner can anybody explain it?"
                    },
                    {
                        "username": "kk_205",
                        "content": "\"You must do this by modifying the input array in-place with O(1) extra memory.\"    what does it mean \" in place\" ??? plzz"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "https://leetcode.com/problems/reverse-string/solutions/3071840/4-line-easy-solution-o-n-complexity/"
                    },
                    {
                        "username": "31703it",
                        "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n         int beg=0,end=s.size()-1,temp;\\n    while(beg<end)\\n    {\\n        temp=s[beg];\\n        s[beg]=s[end];\\n        s[end]=temp;\\n        beg++;\\n        end--;\\n    }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1786932,
                "content": [
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "Hi, I was wondering if I could actually use a different solution than the built-in functions so I tried to code a small alghorithm using something like a binary search and I came up to the one you can find below in the comments. Don\\'t actually know if its the best sol you can come up with, but  it was worh a try for a junior like me :)"
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "`\n    \n class Solution:\n        \n        def reverseString(self, s: List[str]) -> None:\n            \n            left = 0\n            right = len(s) - 1\n\n            while left <= right:\n\n                s[left], s[right] = s[right], s[left]\n                left += 1\n                right -= 1\n`"
                    },
                    {
                        "username": "Msey",
                        "content": "s[i] ^= s[s.Length - 1 - i];\\ns[s.Length - 1 - i] ^= s[i];\\ns[i] ^= s[s.Length - 1 - i];\\n\\nThe end"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "We can use recursion here."
                    },
                    {
                        "username": "alikhanarman786",
                        "content": "java solution: \\n\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int start = 0 , end = s.length-1;\\n        char temp;\\n        while(start<=end){\\n            if(s[start] != s[end]){\\n                temp = s[start];\\n                s[start] = s[end];\\n                s[end] = temp;\\n            }\\n            start++;\\n            end--;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        int n = s.length;\\n        char b[] = new char[n];\\n        int j=n-1;\\n        for(int i=0;i<n;i++){\\n            b[i]=s[i];\\n        }\\n        for(int i=0;i<n;i++){\\n          //  b[i]=s[i];\\n          \\n            s[i]=b[j];\\n            j--;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "Easiest and effective way to do it\\n\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int j =1;\\n       for(int i=0;i<s.length/2;i++){\\n           char temp = s[s.length-j];\\n           s[s.length-j] = s[i];\\n           s[i] = temp;\\n           j++;\\n       }\\n    }\\n}"
                    },
                    {
                        "username": "kk_205",
                        "content": "I   didn\\'t  get , when question says that input is given  in the array  form then why it  takes argument as a string only ??\\n I am beginner can anybody explain it?"
                    },
                    {
                        "username": "kk_205",
                        "content": "\"You must do this by modifying the input array in-place with O(1) extra memory.\"    what does it mean \" in place\" ??? plzz"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "https://leetcode.com/problems/reverse-string/solutions/3071840/4-line-easy-solution-o-n-complexity/"
                    },
                    {
                        "username": "31703it",
                        "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n         int beg=0,end=s.size()-1,temp;\\n    while(beg<end)\\n    {\\n        temp=s[beg];\\n        s[beg]=s[end];\\n        s[end]=temp;\\n        beg++;\\n        end--;\\n    }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1770922,
                "content": [
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "Hi, I was wondering if I could actually use a different solution than the built-in functions so I tried to code a small alghorithm using something like a binary search and I came up to the one you can find below in the comments. Don\\'t actually know if its the best sol you can come up with, but  it was worh a try for a junior like me :)"
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "`\n    \n class Solution:\n        \n        def reverseString(self, s: List[str]) -> None:\n            \n            left = 0\n            right = len(s) - 1\n\n            while left <= right:\n\n                s[left], s[right] = s[right], s[left]\n                left += 1\n                right -= 1\n`"
                    },
                    {
                        "username": "Msey",
                        "content": "s[i] ^= s[s.Length - 1 - i];\\ns[s.Length - 1 - i] ^= s[i];\\ns[i] ^= s[s.Length - 1 - i];\\n\\nThe end"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "We can use recursion here."
                    },
                    {
                        "username": "alikhanarman786",
                        "content": "java solution: \\n\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int start = 0 , end = s.length-1;\\n        char temp;\\n        while(start<=end){\\n            if(s[start] != s[end]){\\n                temp = s[start];\\n                s[start] = s[end];\\n                s[end] = temp;\\n            }\\n            start++;\\n            end--;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        int n = s.length;\\n        char b[] = new char[n];\\n        int j=n-1;\\n        for(int i=0;i<n;i++){\\n            b[i]=s[i];\\n        }\\n        for(int i=0;i<n;i++){\\n          //  b[i]=s[i];\\n          \\n            s[i]=b[j];\\n            j--;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "Easiest and effective way to do it\\n\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int j =1;\\n       for(int i=0;i<s.length/2;i++){\\n           char temp = s[s.length-j];\\n           s[s.length-j] = s[i];\\n           s[i] = temp;\\n           j++;\\n       }\\n    }\\n}"
                    },
                    {
                        "username": "kk_205",
                        "content": "I   didn\\'t  get , when question says that input is given  in the array  form then why it  takes argument as a string only ??\\n I am beginner can anybody explain it?"
                    },
                    {
                        "username": "kk_205",
                        "content": "\"You must do this by modifying the input array in-place with O(1) extra memory.\"    what does it mean \" in place\" ??? plzz"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "https://leetcode.com/problems/reverse-string/solutions/3071840/4-line-easy-solution-o-n-complexity/"
                    },
                    {
                        "username": "31703it",
                        "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n         int beg=0,end=s.size()-1,temp;\\n    while(beg<end)\\n    {\\n        temp=s[beg];\\n        s[beg]=s[end];\\n        s[end]=temp;\\n        beg++;\\n        end--;\\n    }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1765338,
                "content": [
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "Hi, I was wondering if I could actually use a different solution than the built-in functions so I tried to code a small alghorithm using something like a binary search and I came up to the one you can find below in the comments. Don\\'t actually know if its the best sol you can come up with, but  it was worh a try for a junior like me :)"
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "`\n    \n class Solution:\n        \n        def reverseString(self, s: List[str]) -> None:\n            \n            left = 0\n            right = len(s) - 1\n\n            while left <= right:\n\n                s[left], s[right] = s[right], s[left]\n                left += 1\n                right -= 1\n`"
                    },
                    {
                        "username": "Msey",
                        "content": "s[i] ^= s[s.Length - 1 - i];\\ns[s.Length - 1 - i] ^= s[i];\\ns[i] ^= s[s.Length - 1 - i];\\n\\nThe end"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "We can use recursion here."
                    },
                    {
                        "username": "alikhanarman786",
                        "content": "java solution: \\n\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int start = 0 , end = s.length-1;\\n        char temp;\\n        while(start<=end){\\n            if(s[start] != s[end]){\\n                temp = s[start];\\n                s[start] = s[end];\\n                s[end] = temp;\\n            }\\n            start++;\\n            end--;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        int n = s.length;\\n        char b[] = new char[n];\\n        int j=n-1;\\n        for(int i=0;i<n;i++){\\n            b[i]=s[i];\\n        }\\n        for(int i=0;i<n;i++){\\n          //  b[i]=s[i];\\n          \\n            s[i]=b[j];\\n            j--;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "Easiest and effective way to do it\\n\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int j =1;\\n       for(int i=0;i<s.length/2;i++){\\n           char temp = s[s.length-j];\\n           s[s.length-j] = s[i];\\n           s[i] = temp;\\n           j++;\\n       }\\n    }\\n}"
                    },
                    {
                        "username": "kk_205",
                        "content": "I   didn\\'t  get , when question says that input is given  in the array  form then why it  takes argument as a string only ??\\n I am beginner can anybody explain it?"
                    },
                    {
                        "username": "kk_205",
                        "content": "\"You must do this by modifying the input array in-place with O(1) extra memory.\"    what does it mean \" in place\" ??? plzz"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "https://leetcode.com/problems/reverse-string/solutions/3071840/4-line-easy-solution-o-n-complexity/"
                    },
                    {
                        "username": "31703it",
                        "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n         int beg=0,end=s.size()-1,temp;\\n    while(beg<end)\\n    {\\n        temp=s[beg];\\n        s[beg]=s[end];\\n        s[end]=temp;\\n        beg++;\\n        end--;\\n    }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1764680,
                "content": [
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "Hi, I was wondering if I could actually use a different solution than the built-in functions so I tried to code a small alghorithm using something like a binary search and I came up to the one you can find below in the comments. Don\\'t actually know if its the best sol you can come up with, but  it was worh a try for a junior like me :)"
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "`\n    \n class Solution:\n        \n        def reverseString(self, s: List[str]) -> None:\n            \n            left = 0\n            right = len(s) - 1\n\n            while left <= right:\n\n                s[left], s[right] = s[right], s[left]\n                left += 1\n                right -= 1\n`"
                    },
                    {
                        "username": "Msey",
                        "content": "s[i] ^= s[s.Length - 1 - i];\\ns[s.Length - 1 - i] ^= s[i];\\ns[i] ^= s[s.Length - 1 - i];\\n\\nThe end"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "We can use recursion here."
                    },
                    {
                        "username": "alikhanarman786",
                        "content": "java solution: \\n\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int start = 0 , end = s.length-1;\\n        char temp;\\n        while(start<=end){\\n            if(s[start] != s[end]){\\n                temp = s[start];\\n                s[start] = s[end];\\n                s[end] = temp;\\n            }\\n            start++;\\n            end--;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        int n = s.length;\\n        char b[] = new char[n];\\n        int j=n-1;\\n        for(int i=0;i<n;i++){\\n            b[i]=s[i];\\n        }\\n        for(int i=0;i<n;i++){\\n          //  b[i]=s[i];\\n          \\n            s[i]=b[j];\\n            j--;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "Easiest and effective way to do it\\n\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int j =1;\\n       for(int i=0;i<s.length/2;i++){\\n           char temp = s[s.length-j];\\n           s[s.length-j] = s[i];\\n           s[i] = temp;\\n           j++;\\n       }\\n    }\\n}"
                    },
                    {
                        "username": "kk_205",
                        "content": "I   didn\\'t  get , when question says that input is given  in the array  form then why it  takes argument as a string only ??\\n I am beginner can anybody explain it?"
                    },
                    {
                        "username": "kk_205",
                        "content": "\"You must do this by modifying the input array in-place with O(1) extra memory.\"    what does it mean \" in place\" ??? plzz"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "https://leetcode.com/problems/reverse-string/solutions/3071840/4-line-easy-solution-o-n-complexity/"
                    },
                    {
                        "username": "31703it",
                        "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n         int beg=0,end=s.size()-1,temp;\\n    while(beg<end)\\n    {\\n        temp=s[beg];\\n        s[beg]=s[end];\\n        s[end]=temp;\\n        beg++;\\n        end--;\\n    }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1763718,
                "content": [
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "Hi, I was wondering if I could actually use a different solution than the built-in functions so I tried to code a small alghorithm using something like a binary search and I came up to the one you can find below in the comments. Don\\'t actually know if its the best sol you can come up with, but  it was worh a try for a junior like me :)"
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "`\n    \n class Solution:\n        \n        def reverseString(self, s: List[str]) -> None:\n            \n            left = 0\n            right = len(s) - 1\n\n            while left <= right:\n\n                s[left], s[right] = s[right], s[left]\n                left += 1\n                right -= 1\n`"
                    },
                    {
                        "username": "Msey",
                        "content": "s[i] ^= s[s.Length - 1 - i];\\ns[s.Length - 1 - i] ^= s[i];\\ns[i] ^= s[s.Length - 1 - i];\\n\\nThe end"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "We can use recursion here."
                    },
                    {
                        "username": "alikhanarman786",
                        "content": "java solution: \\n\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int start = 0 , end = s.length-1;\\n        char temp;\\n        while(start<=end){\\n            if(s[start] != s[end]){\\n                temp = s[start];\\n                s[start] = s[end];\\n                s[end] = temp;\\n            }\\n            start++;\\n            end--;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        int n = s.length;\\n        char b[] = new char[n];\\n        int j=n-1;\\n        for(int i=0;i<n;i++){\\n            b[i]=s[i];\\n        }\\n        for(int i=0;i<n;i++){\\n          //  b[i]=s[i];\\n          \\n            s[i]=b[j];\\n            j--;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "Easiest and effective way to do it\\n\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int j =1;\\n       for(int i=0;i<s.length/2;i++){\\n           char temp = s[s.length-j];\\n           s[s.length-j] = s[i];\\n           s[i] = temp;\\n           j++;\\n       }\\n    }\\n}"
                    },
                    {
                        "username": "kk_205",
                        "content": "I   didn\\'t  get , when question says that input is given  in the array  form then why it  takes argument as a string only ??\\n I am beginner can anybody explain it?"
                    },
                    {
                        "username": "kk_205",
                        "content": "\"You must do this by modifying the input array in-place with O(1) extra memory.\"    what does it mean \" in place\" ??? plzz"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "https://leetcode.com/problems/reverse-string/solutions/3071840/4-line-easy-solution-o-n-complexity/"
                    },
                    {
                        "username": "31703it",
                        "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n         int beg=0,end=s.size()-1,temp;\\n    while(beg<end)\\n    {\\n        temp=s[beg];\\n        s[beg]=s[end];\\n        s[end]=temp;\\n        beg++;\\n        end--;\\n    }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1760161,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/reverse-string/solutions/3057671/js-linear-time-constant-space-explanation/\\n\\nLinear time with space efficient solution using two pointer and swapping values untill we reach middle of an array\\n"
                    },
                    {
                        "username": "ankit_k84",
                        "content": "any simple solution without swap?"
                    },
                    {
                        "username": "hongbinhe-leetcode",
                        "content": " `\nclass Solution\n{\npublic:\n  void reverseString(vector<char> &s)\n  {\n    for (int i = 0, j = s.size() - 1; i < s.size() / 2; i++, j--)\n    {\n      swap(s[i], s[j]);\n    }\n  }\n}; // time complexity: O(n), space complexity: O(1)\n`"
                    },
                    {
                        "username": "STALKER__404",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        int b = 0, k = s.length- 1 ;\\n        char temp;\\n            \\n        while(b<=k){\\n            temp = s[b];\\n            s[b] = s[k];\\n            s[k] = temp;\\n            ++b;\\n            --k;\\n        }\\n\\n        System.out.println(Arrays.toString(s));\\n\\n    }\\n}"
                    },
                    {
                        "username": "INTROVERTcoder",
                        "content": "i just wrote the simple for loop condition from int i=s.size()-1 to 0  and cout<<s[i];\\nbut than also it is showing wrong result and showing the similar string as input ..?\\nplss help whats wrong is doing i am "
                    },
                    {
                        "username": "danvac",
                        "content": "why i can\\'t use erase()?"
                    },
                    {
                        "username": "adsy",
                        "content": "I strongly believe that there are many incorrect test cases for this problem.\\n"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "class Solution(object):\\n    def reverseString(self, s):\\n        return s.reverse()"
                    },
                    {
                        "username": "305057174a",
                        "content": "why this is rejected?i can run this code on my PyCharm\\n\\nfrom typing import List\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        b=reversed(s)\\n        return list(b)"
                    },
                    {
                        "username": "Ahmed777Khalil",
                        "content": "    public void ReverseString(char[] s) {\\n        Array.Reverse(s);\\n    }"
                    }
                ]
            },
            {
                "id": 1759002,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/reverse-string/solutions/3057671/js-linear-time-constant-space-explanation/\\n\\nLinear time with space efficient solution using two pointer and swapping values untill we reach middle of an array\\n"
                    },
                    {
                        "username": "ankit_k84",
                        "content": "any simple solution without swap?"
                    },
                    {
                        "username": "hongbinhe-leetcode",
                        "content": " `\nclass Solution\n{\npublic:\n  void reverseString(vector<char> &s)\n  {\n    for (int i = 0, j = s.size() - 1; i < s.size() / 2; i++, j--)\n    {\n      swap(s[i], s[j]);\n    }\n  }\n}; // time complexity: O(n), space complexity: O(1)\n`"
                    },
                    {
                        "username": "STALKER__404",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        int b = 0, k = s.length- 1 ;\\n        char temp;\\n            \\n        while(b<=k){\\n            temp = s[b];\\n            s[b] = s[k];\\n            s[k] = temp;\\n            ++b;\\n            --k;\\n        }\\n\\n        System.out.println(Arrays.toString(s));\\n\\n    }\\n}"
                    },
                    {
                        "username": "INTROVERTcoder",
                        "content": "i just wrote the simple for loop condition from int i=s.size()-1 to 0  and cout<<s[i];\\nbut than also it is showing wrong result and showing the similar string as input ..?\\nplss help whats wrong is doing i am "
                    },
                    {
                        "username": "danvac",
                        "content": "why i can\\'t use erase()?"
                    },
                    {
                        "username": "adsy",
                        "content": "I strongly believe that there are many incorrect test cases for this problem.\\n"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "class Solution(object):\\n    def reverseString(self, s):\\n        return s.reverse()"
                    },
                    {
                        "username": "305057174a",
                        "content": "why this is rejected?i can run this code on my PyCharm\\n\\nfrom typing import List\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        b=reversed(s)\\n        return list(b)"
                    },
                    {
                        "username": "Ahmed777Khalil",
                        "content": "    public void ReverseString(char[] s) {\\n        Array.Reverse(s);\\n    }"
                    }
                ]
            },
            {
                "id": 1753705,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/reverse-string/solutions/3057671/js-linear-time-constant-space-explanation/\\n\\nLinear time with space efficient solution using two pointer and swapping values untill we reach middle of an array\\n"
                    },
                    {
                        "username": "ankit_k84",
                        "content": "any simple solution without swap?"
                    },
                    {
                        "username": "hongbinhe-leetcode",
                        "content": " `\nclass Solution\n{\npublic:\n  void reverseString(vector<char> &s)\n  {\n    for (int i = 0, j = s.size() - 1; i < s.size() / 2; i++, j--)\n    {\n      swap(s[i], s[j]);\n    }\n  }\n}; // time complexity: O(n), space complexity: O(1)\n`"
                    },
                    {
                        "username": "STALKER__404",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        int b = 0, k = s.length- 1 ;\\n        char temp;\\n            \\n        while(b<=k){\\n            temp = s[b];\\n            s[b] = s[k];\\n            s[k] = temp;\\n            ++b;\\n            --k;\\n        }\\n\\n        System.out.println(Arrays.toString(s));\\n\\n    }\\n}"
                    },
                    {
                        "username": "INTROVERTcoder",
                        "content": "i just wrote the simple for loop condition from int i=s.size()-1 to 0  and cout<<s[i];\\nbut than also it is showing wrong result and showing the similar string as input ..?\\nplss help whats wrong is doing i am "
                    },
                    {
                        "username": "danvac",
                        "content": "why i can\\'t use erase()?"
                    },
                    {
                        "username": "adsy",
                        "content": "I strongly believe that there are many incorrect test cases for this problem.\\n"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "class Solution(object):\\n    def reverseString(self, s):\\n        return s.reverse()"
                    },
                    {
                        "username": "305057174a",
                        "content": "why this is rejected?i can run this code on my PyCharm\\n\\nfrom typing import List\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        b=reversed(s)\\n        return list(b)"
                    },
                    {
                        "username": "Ahmed777Khalil",
                        "content": "    public void ReverseString(char[] s) {\\n        Array.Reverse(s);\\n    }"
                    }
                ]
            },
            {
                "id": 1750046,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/reverse-string/solutions/3057671/js-linear-time-constant-space-explanation/\\n\\nLinear time with space efficient solution using two pointer and swapping values untill we reach middle of an array\\n"
                    },
                    {
                        "username": "ankit_k84",
                        "content": "any simple solution without swap?"
                    },
                    {
                        "username": "hongbinhe-leetcode",
                        "content": " `\nclass Solution\n{\npublic:\n  void reverseString(vector<char> &s)\n  {\n    for (int i = 0, j = s.size() - 1; i < s.size() / 2; i++, j--)\n    {\n      swap(s[i], s[j]);\n    }\n  }\n}; // time complexity: O(n), space complexity: O(1)\n`"
                    },
                    {
                        "username": "STALKER__404",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        int b = 0, k = s.length- 1 ;\\n        char temp;\\n            \\n        while(b<=k){\\n            temp = s[b];\\n            s[b] = s[k];\\n            s[k] = temp;\\n            ++b;\\n            --k;\\n        }\\n\\n        System.out.println(Arrays.toString(s));\\n\\n    }\\n}"
                    },
                    {
                        "username": "INTROVERTcoder",
                        "content": "i just wrote the simple for loop condition from int i=s.size()-1 to 0  and cout<<s[i];\\nbut than also it is showing wrong result and showing the similar string as input ..?\\nplss help whats wrong is doing i am "
                    },
                    {
                        "username": "danvac",
                        "content": "why i can\\'t use erase()?"
                    },
                    {
                        "username": "adsy",
                        "content": "I strongly believe that there are many incorrect test cases for this problem.\\n"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "class Solution(object):\\n    def reverseString(self, s):\\n        return s.reverse()"
                    },
                    {
                        "username": "305057174a",
                        "content": "why this is rejected?i can run this code on my PyCharm\\n\\nfrom typing import List\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        b=reversed(s)\\n        return list(b)"
                    },
                    {
                        "username": "Ahmed777Khalil",
                        "content": "    public void ReverseString(char[] s) {\\n        Array.Reverse(s);\\n    }"
                    }
                ]
            },
            {
                "id": 1749277,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/reverse-string/solutions/3057671/js-linear-time-constant-space-explanation/\\n\\nLinear time with space efficient solution using two pointer and swapping values untill we reach middle of an array\\n"
                    },
                    {
                        "username": "ankit_k84",
                        "content": "any simple solution without swap?"
                    },
                    {
                        "username": "hongbinhe-leetcode",
                        "content": " `\nclass Solution\n{\npublic:\n  void reverseString(vector<char> &s)\n  {\n    for (int i = 0, j = s.size() - 1; i < s.size() / 2; i++, j--)\n    {\n      swap(s[i], s[j]);\n    }\n  }\n}; // time complexity: O(n), space complexity: O(1)\n`"
                    },
                    {
                        "username": "STALKER__404",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        int b = 0, k = s.length- 1 ;\\n        char temp;\\n            \\n        while(b<=k){\\n            temp = s[b];\\n            s[b] = s[k];\\n            s[k] = temp;\\n            ++b;\\n            --k;\\n        }\\n\\n        System.out.println(Arrays.toString(s));\\n\\n    }\\n}"
                    },
                    {
                        "username": "INTROVERTcoder",
                        "content": "i just wrote the simple for loop condition from int i=s.size()-1 to 0  and cout<<s[i];\\nbut than also it is showing wrong result and showing the similar string as input ..?\\nplss help whats wrong is doing i am "
                    },
                    {
                        "username": "danvac",
                        "content": "why i can\\'t use erase()?"
                    },
                    {
                        "username": "adsy",
                        "content": "I strongly believe that there are many incorrect test cases for this problem.\\n"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "class Solution(object):\\n    def reverseString(self, s):\\n        return s.reverse()"
                    },
                    {
                        "username": "305057174a",
                        "content": "why this is rejected?i can run this code on my PyCharm\\n\\nfrom typing import List\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        b=reversed(s)\\n        return list(b)"
                    },
                    {
                        "username": "Ahmed777Khalil",
                        "content": "    public void ReverseString(char[] s) {\\n        Array.Reverse(s);\\n    }"
                    }
                ]
            },
            {
                "id": 1748502,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/reverse-string/solutions/3057671/js-linear-time-constant-space-explanation/\\n\\nLinear time with space efficient solution using two pointer and swapping values untill we reach middle of an array\\n"
                    },
                    {
                        "username": "ankit_k84",
                        "content": "any simple solution without swap?"
                    },
                    {
                        "username": "hongbinhe-leetcode",
                        "content": " `\nclass Solution\n{\npublic:\n  void reverseString(vector<char> &s)\n  {\n    for (int i = 0, j = s.size() - 1; i < s.size() / 2; i++, j--)\n    {\n      swap(s[i], s[j]);\n    }\n  }\n}; // time complexity: O(n), space complexity: O(1)\n`"
                    },
                    {
                        "username": "STALKER__404",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        int b = 0, k = s.length- 1 ;\\n        char temp;\\n            \\n        while(b<=k){\\n            temp = s[b];\\n            s[b] = s[k];\\n            s[k] = temp;\\n            ++b;\\n            --k;\\n        }\\n\\n        System.out.println(Arrays.toString(s));\\n\\n    }\\n}"
                    },
                    {
                        "username": "INTROVERTcoder",
                        "content": "i just wrote the simple for loop condition from int i=s.size()-1 to 0  and cout<<s[i];\\nbut than also it is showing wrong result and showing the similar string as input ..?\\nplss help whats wrong is doing i am "
                    },
                    {
                        "username": "danvac",
                        "content": "why i can\\'t use erase()?"
                    },
                    {
                        "username": "adsy",
                        "content": "I strongly believe that there are many incorrect test cases for this problem.\\n"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "class Solution(object):\\n    def reverseString(self, s):\\n        return s.reverse()"
                    },
                    {
                        "username": "305057174a",
                        "content": "why this is rejected?i can run this code on my PyCharm\\n\\nfrom typing import List\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        b=reversed(s)\\n        return list(b)"
                    },
                    {
                        "username": "Ahmed777Khalil",
                        "content": "    public void ReverseString(char[] s) {\\n        Array.Reverse(s);\\n    }"
                    }
                ]
            },
            {
                "id": 1740392,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/reverse-string/solutions/3057671/js-linear-time-constant-space-explanation/\\n\\nLinear time with space efficient solution using two pointer and swapping values untill we reach middle of an array\\n"
                    },
                    {
                        "username": "ankit_k84",
                        "content": "any simple solution without swap?"
                    },
                    {
                        "username": "hongbinhe-leetcode",
                        "content": " `\nclass Solution\n{\npublic:\n  void reverseString(vector<char> &s)\n  {\n    for (int i = 0, j = s.size() - 1; i < s.size() / 2; i++, j--)\n    {\n      swap(s[i], s[j]);\n    }\n  }\n}; // time complexity: O(n), space complexity: O(1)\n`"
                    },
                    {
                        "username": "STALKER__404",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        int b = 0, k = s.length- 1 ;\\n        char temp;\\n            \\n        while(b<=k){\\n            temp = s[b];\\n            s[b] = s[k];\\n            s[k] = temp;\\n            ++b;\\n            --k;\\n        }\\n\\n        System.out.println(Arrays.toString(s));\\n\\n    }\\n}"
                    },
                    {
                        "username": "INTROVERTcoder",
                        "content": "i just wrote the simple for loop condition from int i=s.size()-1 to 0  and cout<<s[i];\\nbut than also it is showing wrong result and showing the similar string as input ..?\\nplss help whats wrong is doing i am "
                    },
                    {
                        "username": "danvac",
                        "content": "why i can\\'t use erase()?"
                    },
                    {
                        "username": "adsy",
                        "content": "I strongly believe that there are many incorrect test cases for this problem.\\n"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "class Solution(object):\\n    def reverseString(self, s):\\n        return s.reverse()"
                    },
                    {
                        "username": "305057174a",
                        "content": "why this is rejected?i can run this code on my PyCharm\\n\\nfrom typing import List\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        b=reversed(s)\\n        return list(b)"
                    },
                    {
                        "username": "Ahmed777Khalil",
                        "content": "    public void ReverseString(char[] s) {\\n        Array.Reverse(s);\\n    }"
                    }
                ]
            },
            {
                "id": 1734151,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/reverse-string/solutions/3057671/js-linear-time-constant-space-explanation/\\n\\nLinear time with space efficient solution using two pointer and swapping values untill we reach middle of an array\\n"
                    },
                    {
                        "username": "ankit_k84",
                        "content": "any simple solution without swap?"
                    },
                    {
                        "username": "hongbinhe-leetcode",
                        "content": " `\nclass Solution\n{\npublic:\n  void reverseString(vector<char> &s)\n  {\n    for (int i = 0, j = s.size() - 1; i < s.size() / 2; i++, j--)\n    {\n      swap(s[i], s[j]);\n    }\n  }\n}; // time complexity: O(n), space complexity: O(1)\n`"
                    },
                    {
                        "username": "STALKER__404",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        int b = 0, k = s.length- 1 ;\\n        char temp;\\n            \\n        while(b<=k){\\n            temp = s[b];\\n            s[b] = s[k];\\n            s[k] = temp;\\n            ++b;\\n            --k;\\n        }\\n\\n        System.out.println(Arrays.toString(s));\\n\\n    }\\n}"
                    },
                    {
                        "username": "INTROVERTcoder",
                        "content": "i just wrote the simple for loop condition from int i=s.size()-1 to 0  and cout<<s[i];\\nbut than also it is showing wrong result and showing the similar string as input ..?\\nplss help whats wrong is doing i am "
                    },
                    {
                        "username": "danvac",
                        "content": "why i can\\'t use erase()?"
                    },
                    {
                        "username": "adsy",
                        "content": "I strongly believe that there are many incorrect test cases for this problem.\\n"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "class Solution(object):\\n    def reverseString(self, s):\\n        return s.reverse()"
                    },
                    {
                        "username": "305057174a",
                        "content": "why this is rejected?i can run this code on my PyCharm\\n\\nfrom typing import List\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        b=reversed(s)\\n        return list(b)"
                    },
                    {
                        "username": "Ahmed777Khalil",
                        "content": "    public void ReverseString(char[] s) {\\n        Array.Reverse(s);\\n    }"
                    }
                ]
            },
            {
                "id": 1734015,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/reverse-string/solutions/3057671/js-linear-time-constant-space-explanation/\\n\\nLinear time with space efficient solution using two pointer and swapping values untill we reach middle of an array\\n"
                    },
                    {
                        "username": "ankit_k84",
                        "content": "any simple solution without swap?"
                    },
                    {
                        "username": "hongbinhe-leetcode",
                        "content": " `\nclass Solution\n{\npublic:\n  void reverseString(vector<char> &s)\n  {\n    for (int i = 0, j = s.size() - 1; i < s.size() / 2; i++, j--)\n    {\n      swap(s[i], s[j]);\n    }\n  }\n}; // time complexity: O(n), space complexity: O(1)\n`"
                    },
                    {
                        "username": "STALKER__404",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        int b = 0, k = s.length- 1 ;\\n        char temp;\\n            \\n        while(b<=k){\\n            temp = s[b];\\n            s[b] = s[k];\\n            s[k] = temp;\\n            ++b;\\n            --k;\\n        }\\n\\n        System.out.println(Arrays.toString(s));\\n\\n    }\\n}"
                    },
                    {
                        "username": "INTROVERTcoder",
                        "content": "i just wrote the simple for loop condition from int i=s.size()-1 to 0  and cout<<s[i];\\nbut than also it is showing wrong result and showing the similar string as input ..?\\nplss help whats wrong is doing i am "
                    },
                    {
                        "username": "danvac",
                        "content": "why i can\\'t use erase()?"
                    },
                    {
                        "username": "adsy",
                        "content": "I strongly believe that there are many incorrect test cases for this problem.\\n"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "class Solution(object):\\n    def reverseString(self, s):\\n        return s.reverse()"
                    },
                    {
                        "username": "305057174a",
                        "content": "why this is rejected?i can run this code on my PyCharm\\n\\nfrom typing import List\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        b=reversed(s)\\n        return list(b)"
                    },
                    {
                        "username": "Ahmed777Khalil",
                        "content": "    public void ReverseString(char[] s) {\\n        Array.Reverse(s);\\n    }"
                    }
                ]
            },
            {
                "id": 1731977,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/reverse-string/solutions/3057671/js-linear-time-constant-space-explanation/\\n\\nLinear time with space efficient solution using two pointer and swapping values untill we reach middle of an array\\n"
                    },
                    {
                        "username": "ankit_k84",
                        "content": "any simple solution without swap?"
                    },
                    {
                        "username": "hongbinhe-leetcode",
                        "content": " `\nclass Solution\n{\npublic:\n  void reverseString(vector<char> &s)\n  {\n    for (int i = 0, j = s.size() - 1; i < s.size() / 2; i++, j--)\n    {\n      swap(s[i], s[j]);\n    }\n  }\n}; // time complexity: O(n), space complexity: O(1)\n`"
                    },
                    {
                        "username": "STALKER__404",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        int b = 0, k = s.length- 1 ;\\n        char temp;\\n            \\n        while(b<=k){\\n            temp = s[b];\\n            s[b] = s[k];\\n            s[k] = temp;\\n            ++b;\\n            --k;\\n        }\\n\\n        System.out.println(Arrays.toString(s));\\n\\n    }\\n}"
                    },
                    {
                        "username": "INTROVERTcoder",
                        "content": "i just wrote the simple for loop condition from int i=s.size()-1 to 0  and cout<<s[i];\\nbut than also it is showing wrong result and showing the similar string as input ..?\\nplss help whats wrong is doing i am "
                    },
                    {
                        "username": "danvac",
                        "content": "why i can\\'t use erase()?"
                    },
                    {
                        "username": "adsy",
                        "content": "I strongly believe that there are many incorrect test cases for this problem.\\n"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "class Solution(object):\\n    def reverseString(self, s):\\n        return s.reverse()"
                    },
                    {
                        "username": "305057174a",
                        "content": "why this is rejected?i can run this code on my PyCharm\\n\\nfrom typing import List\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        b=reversed(s)\\n        return list(b)"
                    },
                    {
                        "username": "Ahmed777Khalil",
                        "content": "    public void ReverseString(char[] s) {\\n        Array.Reverse(s);\\n    }"
                    }
                ]
            },
            {
                "id": 1729931,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/344_reverse_string.cpp"
                    },
                    {
                        "username": "Teja767",
                        "content": "we can update the given list using the python inbuild reverse funtion\\nlist.reverse()"
                    },
                    {
                        "username": "deleted_user",
                        "content": "This is my first Question on leetCode\\nI understood how the input is taken it is very different from other platforms\\nI love the interface and overall experience"
                    },
                    {
                        "username": "sarvagya_jha",
                        "content": "int start=0;\\nint e=s.size()-1;\\nwhile(start<=e){\\n     swap(s[start++],s[e--]);\\n}"
                    },
                    {
                        "username": "mohamed_aichaoui",
                        "content": "easy one"
                    },
                    {
                        "username": "Sanjaykumar702",
                        "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int n = s.size();\\n        int start = 0;\\n        int end = n-1;\\n        int mid= start + (end-start)/2;\\n        for (int i=0; i<=mid; i++){\\n            swap(s[start], s[end]);\\n            start++;\\n            end--;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "alphacz",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        char[] result= new char[s.length];\\n        int j=0;\\n        for(int i=s.length;i<s.length;i--)\\n        {\\n            s[i]=result[j];\\n            j++;\\n        }\\n          return  result;\\n      \\n    }\\n}  \\n\\nLine 10: error: incompatible types: unexpected return value\\n       return  result; \\ncan anybody explain whats wrong with my solution\\n\\n"
                    },
                    {
                        "username": "MehulJ0806",
                        "content": "Do a in-place changes in array s itself.\\n"
                    },
                    {
                        "username": "karimomaya",
                        "content": "Simplest Javascript Solution\\n\\n\\n `\\nvar reverseString = function(s) {\\n    let start = 0;\\n    let end = s.length-1;\\n    \\n    \\n    while(start<end) {\\n        let temp = s[start];\\n        s[start++] = s[end];\\n        s[end--] = temp;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "chetanpatil04102001",
                        "content": "class Solution {\\nprivate:\\n   void solve(vector<char>& s, int i,int n){\\n       if(i>=n/2) return ;\\n       swap(s[i],s[n-i-1]);\\n       solve(s,i+1,n);\\n   }\\n\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int i = 0;\\n        int  n = s.size();\\n        solve(s,i,n);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "saurabh_kumar10",
                        "content": "first make two pointer first pointer stand at 0th index and 2nd pointer stand at the last index, so you just have to swap these pointers till they do not cross each other.\\n\\nComplexity\\nTime complexity:\\no(N)\\n\\nSpace complexity:\\no (1)\\n\\ncode:\\nvoid reverseString(vector<char>& s) {\\n        int i=0;\\n        int j=s.size()-1;\\n        while(i<j){\\n            swap(s[i++],s[j--]);\\n        }\\n    }"
                    }
                ]
            },
            {
                "id": 1728178,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/344_reverse_string.cpp"
                    },
                    {
                        "username": "Teja767",
                        "content": "we can update the given list using the python inbuild reverse funtion\\nlist.reverse()"
                    },
                    {
                        "username": "deleted_user",
                        "content": "This is my first Question on leetCode\\nI understood how the input is taken it is very different from other platforms\\nI love the interface and overall experience"
                    },
                    {
                        "username": "sarvagya_jha",
                        "content": "int start=0;\\nint e=s.size()-1;\\nwhile(start<=e){\\n     swap(s[start++],s[e--]);\\n}"
                    },
                    {
                        "username": "mohamed_aichaoui",
                        "content": "easy one"
                    },
                    {
                        "username": "Sanjaykumar702",
                        "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int n = s.size();\\n        int start = 0;\\n        int end = n-1;\\n        int mid= start + (end-start)/2;\\n        for (int i=0; i<=mid; i++){\\n            swap(s[start], s[end]);\\n            start++;\\n            end--;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "alphacz",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        char[] result= new char[s.length];\\n        int j=0;\\n        for(int i=s.length;i<s.length;i--)\\n        {\\n            s[i]=result[j];\\n            j++;\\n        }\\n          return  result;\\n      \\n    }\\n}  \\n\\nLine 10: error: incompatible types: unexpected return value\\n       return  result; \\ncan anybody explain whats wrong with my solution\\n\\n"
                    },
                    {
                        "username": "MehulJ0806",
                        "content": "Do a in-place changes in array s itself.\\n"
                    },
                    {
                        "username": "karimomaya",
                        "content": "Simplest Javascript Solution\\n\\n\\n `\\nvar reverseString = function(s) {\\n    let start = 0;\\n    let end = s.length-1;\\n    \\n    \\n    while(start<end) {\\n        let temp = s[start];\\n        s[start++] = s[end];\\n        s[end--] = temp;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "chetanpatil04102001",
                        "content": "class Solution {\\nprivate:\\n   void solve(vector<char>& s, int i,int n){\\n       if(i>=n/2) return ;\\n       swap(s[i],s[n-i-1]);\\n       solve(s,i+1,n);\\n   }\\n\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int i = 0;\\n        int  n = s.size();\\n        solve(s,i,n);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "saurabh_kumar10",
                        "content": "first make two pointer first pointer stand at 0th index and 2nd pointer stand at the last index, so you just have to swap these pointers till they do not cross each other.\\n\\nComplexity\\nTime complexity:\\no(N)\\n\\nSpace complexity:\\no (1)\\n\\ncode:\\nvoid reverseString(vector<char>& s) {\\n        int i=0;\\n        int j=s.size()-1;\\n        while(i<j){\\n            swap(s[i++],s[j--]);\\n        }\\n    }"
                    }
                ]
            },
            {
                "id": 1725537,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/344_reverse_string.cpp"
                    },
                    {
                        "username": "Teja767",
                        "content": "we can update the given list using the python inbuild reverse funtion\\nlist.reverse()"
                    },
                    {
                        "username": "deleted_user",
                        "content": "This is my first Question on leetCode\\nI understood how the input is taken it is very different from other platforms\\nI love the interface and overall experience"
                    },
                    {
                        "username": "sarvagya_jha",
                        "content": "int start=0;\\nint e=s.size()-1;\\nwhile(start<=e){\\n     swap(s[start++],s[e--]);\\n}"
                    },
                    {
                        "username": "mohamed_aichaoui",
                        "content": "easy one"
                    },
                    {
                        "username": "Sanjaykumar702",
                        "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int n = s.size();\\n        int start = 0;\\n        int end = n-1;\\n        int mid= start + (end-start)/2;\\n        for (int i=0; i<=mid; i++){\\n            swap(s[start], s[end]);\\n            start++;\\n            end--;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "alphacz",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        char[] result= new char[s.length];\\n        int j=0;\\n        for(int i=s.length;i<s.length;i--)\\n        {\\n            s[i]=result[j];\\n            j++;\\n        }\\n          return  result;\\n      \\n    }\\n}  \\n\\nLine 10: error: incompatible types: unexpected return value\\n       return  result; \\ncan anybody explain whats wrong with my solution\\n\\n"
                    },
                    {
                        "username": "MehulJ0806",
                        "content": "Do a in-place changes in array s itself.\\n"
                    },
                    {
                        "username": "karimomaya",
                        "content": "Simplest Javascript Solution\\n\\n\\n `\\nvar reverseString = function(s) {\\n    let start = 0;\\n    let end = s.length-1;\\n    \\n    \\n    while(start<end) {\\n        let temp = s[start];\\n        s[start++] = s[end];\\n        s[end--] = temp;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "chetanpatil04102001",
                        "content": "class Solution {\\nprivate:\\n   void solve(vector<char>& s, int i,int n){\\n       if(i>=n/2) return ;\\n       swap(s[i],s[n-i-1]);\\n       solve(s,i+1,n);\\n   }\\n\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int i = 0;\\n        int  n = s.size();\\n        solve(s,i,n);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "saurabh_kumar10",
                        "content": "first make two pointer first pointer stand at 0th index and 2nd pointer stand at the last index, so you just have to swap these pointers till they do not cross each other.\\n\\nComplexity\\nTime complexity:\\no(N)\\n\\nSpace complexity:\\no (1)\\n\\ncode:\\nvoid reverseString(vector<char>& s) {\\n        int i=0;\\n        int j=s.size()-1;\\n        while(i<j){\\n            swap(s[i++],s[j--]);\\n        }\\n    }"
                    }
                ]
            },
            {
                "id": 1724436,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/344_reverse_string.cpp"
                    },
                    {
                        "username": "Teja767",
                        "content": "we can update the given list using the python inbuild reverse funtion\\nlist.reverse()"
                    },
                    {
                        "username": "deleted_user",
                        "content": "This is my first Question on leetCode\\nI understood how the input is taken it is very different from other platforms\\nI love the interface and overall experience"
                    },
                    {
                        "username": "sarvagya_jha",
                        "content": "int start=0;\\nint e=s.size()-1;\\nwhile(start<=e){\\n     swap(s[start++],s[e--]);\\n}"
                    },
                    {
                        "username": "mohamed_aichaoui",
                        "content": "easy one"
                    },
                    {
                        "username": "Sanjaykumar702",
                        "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int n = s.size();\\n        int start = 0;\\n        int end = n-1;\\n        int mid= start + (end-start)/2;\\n        for (int i=0; i<=mid; i++){\\n            swap(s[start], s[end]);\\n            start++;\\n            end--;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "alphacz",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        char[] result= new char[s.length];\\n        int j=0;\\n        for(int i=s.length;i<s.length;i--)\\n        {\\n            s[i]=result[j];\\n            j++;\\n        }\\n          return  result;\\n      \\n    }\\n}  \\n\\nLine 10: error: incompatible types: unexpected return value\\n       return  result; \\ncan anybody explain whats wrong with my solution\\n\\n"
                    },
                    {
                        "username": "MehulJ0806",
                        "content": "Do a in-place changes in array s itself.\\n"
                    },
                    {
                        "username": "karimomaya",
                        "content": "Simplest Javascript Solution\\n\\n\\n `\\nvar reverseString = function(s) {\\n    let start = 0;\\n    let end = s.length-1;\\n    \\n    \\n    while(start<end) {\\n        let temp = s[start];\\n        s[start++] = s[end];\\n        s[end--] = temp;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "chetanpatil04102001",
                        "content": "class Solution {\\nprivate:\\n   void solve(vector<char>& s, int i,int n){\\n       if(i>=n/2) return ;\\n       swap(s[i],s[n-i-1]);\\n       solve(s,i+1,n);\\n   }\\n\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int i = 0;\\n        int  n = s.size();\\n        solve(s,i,n);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "saurabh_kumar10",
                        "content": "first make two pointer first pointer stand at 0th index and 2nd pointer stand at the last index, so you just have to swap these pointers till they do not cross each other.\\n\\nComplexity\\nTime complexity:\\no(N)\\n\\nSpace complexity:\\no (1)\\n\\ncode:\\nvoid reverseString(vector<char>& s) {\\n        int i=0;\\n        int j=s.size()-1;\\n        while(i<j){\\n            swap(s[i++],s[j--]);\\n        }\\n    }"
                    }
                ]
            },
            {
                "id": 1722368,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/344_reverse_string.cpp"
                    },
                    {
                        "username": "Teja767",
                        "content": "we can update the given list using the python inbuild reverse funtion\\nlist.reverse()"
                    },
                    {
                        "username": "deleted_user",
                        "content": "This is my first Question on leetCode\\nI understood how the input is taken it is very different from other platforms\\nI love the interface and overall experience"
                    },
                    {
                        "username": "sarvagya_jha",
                        "content": "int start=0;\\nint e=s.size()-1;\\nwhile(start<=e){\\n     swap(s[start++],s[e--]);\\n}"
                    },
                    {
                        "username": "mohamed_aichaoui",
                        "content": "easy one"
                    },
                    {
                        "username": "Sanjaykumar702",
                        "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int n = s.size();\\n        int start = 0;\\n        int end = n-1;\\n        int mid= start + (end-start)/2;\\n        for (int i=0; i<=mid; i++){\\n            swap(s[start], s[end]);\\n            start++;\\n            end--;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "alphacz",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        char[] result= new char[s.length];\\n        int j=0;\\n        for(int i=s.length;i<s.length;i--)\\n        {\\n            s[i]=result[j];\\n            j++;\\n        }\\n          return  result;\\n      \\n    }\\n}  \\n\\nLine 10: error: incompatible types: unexpected return value\\n       return  result; \\ncan anybody explain whats wrong with my solution\\n\\n"
                    },
                    {
                        "username": "MehulJ0806",
                        "content": "Do a in-place changes in array s itself.\\n"
                    },
                    {
                        "username": "karimomaya",
                        "content": "Simplest Javascript Solution\\n\\n\\n `\\nvar reverseString = function(s) {\\n    let start = 0;\\n    let end = s.length-1;\\n    \\n    \\n    while(start<end) {\\n        let temp = s[start];\\n        s[start++] = s[end];\\n        s[end--] = temp;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "chetanpatil04102001",
                        "content": "class Solution {\\nprivate:\\n   void solve(vector<char>& s, int i,int n){\\n       if(i>=n/2) return ;\\n       swap(s[i],s[n-i-1]);\\n       solve(s,i+1,n);\\n   }\\n\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int i = 0;\\n        int  n = s.size();\\n        solve(s,i,n);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "saurabh_kumar10",
                        "content": "first make two pointer first pointer stand at 0th index and 2nd pointer stand at the last index, so you just have to swap these pointers till they do not cross each other.\\n\\nComplexity\\nTime complexity:\\no(N)\\n\\nSpace complexity:\\no (1)\\n\\ncode:\\nvoid reverseString(vector<char>& s) {\\n        int i=0;\\n        int j=s.size()-1;\\n        while(i<j){\\n            swap(s[i++],s[j--]);\\n        }\\n    }"
                    }
                ]
            },
            {
                "id": 1719522,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/344_reverse_string.cpp"
                    },
                    {
                        "username": "Teja767",
                        "content": "we can update the given list using the python inbuild reverse funtion\\nlist.reverse()"
                    },
                    {
                        "username": "deleted_user",
                        "content": "This is my first Question on leetCode\\nI understood how the input is taken it is very different from other platforms\\nI love the interface and overall experience"
                    },
                    {
                        "username": "sarvagya_jha",
                        "content": "int start=0;\\nint e=s.size()-1;\\nwhile(start<=e){\\n     swap(s[start++],s[e--]);\\n}"
                    },
                    {
                        "username": "mohamed_aichaoui",
                        "content": "easy one"
                    },
                    {
                        "username": "Sanjaykumar702",
                        "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int n = s.size();\\n        int start = 0;\\n        int end = n-1;\\n        int mid= start + (end-start)/2;\\n        for (int i=0; i<=mid; i++){\\n            swap(s[start], s[end]);\\n            start++;\\n            end--;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "alphacz",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        char[] result= new char[s.length];\\n        int j=0;\\n        for(int i=s.length;i<s.length;i--)\\n        {\\n            s[i]=result[j];\\n            j++;\\n        }\\n          return  result;\\n      \\n    }\\n}  \\n\\nLine 10: error: incompatible types: unexpected return value\\n       return  result; \\ncan anybody explain whats wrong with my solution\\n\\n"
                    },
                    {
                        "username": "MehulJ0806",
                        "content": "Do a in-place changes in array s itself.\\n"
                    },
                    {
                        "username": "karimomaya",
                        "content": "Simplest Javascript Solution\\n\\n\\n `\\nvar reverseString = function(s) {\\n    let start = 0;\\n    let end = s.length-1;\\n    \\n    \\n    while(start<end) {\\n        let temp = s[start];\\n        s[start++] = s[end];\\n        s[end--] = temp;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "chetanpatil04102001",
                        "content": "class Solution {\\nprivate:\\n   void solve(vector<char>& s, int i,int n){\\n       if(i>=n/2) return ;\\n       swap(s[i],s[n-i-1]);\\n       solve(s,i+1,n);\\n   }\\n\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int i = 0;\\n        int  n = s.size();\\n        solve(s,i,n);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "saurabh_kumar10",
                        "content": "first make two pointer first pointer stand at 0th index and 2nd pointer stand at the last index, so you just have to swap these pointers till they do not cross each other.\\n\\nComplexity\\nTime complexity:\\no(N)\\n\\nSpace complexity:\\no (1)\\n\\ncode:\\nvoid reverseString(vector<char>& s) {\\n        int i=0;\\n        int j=s.size()-1;\\n        while(i<j){\\n            swap(s[i++],s[j--]);\\n        }\\n    }"
                    }
                ]
            },
            {
                "id": 1714318,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/344_reverse_string.cpp"
                    },
                    {
                        "username": "Teja767",
                        "content": "we can update the given list using the python inbuild reverse funtion\\nlist.reverse()"
                    },
                    {
                        "username": "deleted_user",
                        "content": "This is my first Question on leetCode\\nI understood how the input is taken it is very different from other platforms\\nI love the interface and overall experience"
                    },
                    {
                        "username": "sarvagya_jha",
                        "content": "int start=0;\\nint e=s.size()-1;\\nwhile(start<=e){\\n     swap(s[start++],s[e--]);\\n}"
                    },
                    {
                        "username": "mohamed_aichaoui",
                        "content": "easy one"
                    },
                    {
                        "username": "Sanjaykumar702",
                        "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int n = s.size();\\n        int start = 0;\\n        int end = n-1;\\n        int mid= start + (end-start)/2;\\n        for (int i=0; i<=mid; i++){\\n            swap(s[start], s[end]);\\n            start++;\\n            end--;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "alphacz",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        char[] result= new char[s.length];\\n        int j=0;\\n        for(int i=s.length;i<s.length;i--)\\n        {\\n            s[i]=result[j];\\n            j++;\\n        }\\n          return  result;\\n      \\n    }\\n}  \\n\\nLine 10: error: incompatible types: unexpected return value\\n       return  result; \\ncan anybody explain whats wrong with my solution\\n\\n"
                    },
                    {
                        "username": "MehulJ0806",
                        "content": "Do a in-place changes in array s itself.\\n"
                    },
                    {
                        "username": "karimomaya",
                        "content": "Simplest Javascript Solution\\n\\n\\n `\\nvar reverseString = function(s) {\\n    let start = 0;\\n    let end = s.length-1;\\n    \\n    \\n    while(start<end) {\\n        let temp = s[start];\\n        s[start++] = s[end];\\n        s[end--] = temp;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "chetanpatil04102001",
                        "content": "class Solution {\\nprivate:\\n   void solve(vector<char>& s, int i,int n){\\n       if(i>=n/2) return ;\\n       swap(s[i],s[n-i-1]);\\n       solve(s,i+1,n);\\n   }\\n\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int i = 0;\\n        int  n = s.size();\\n        solve(s,i,n);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "saurabh_kumar10",
                        "content": "first make two pointer first pointer stand at 0th index and 2nd pointer stand at the last index, so you just have to swap these pointers till they do not cross each other.\\n\\nComplexity\\nTime complexity:\\no(N)\\n\\nSpace complexity:\\no (1)\\n\\ncode:\\nvoid reverseString(vector<char>& s) {\\n        int i=0;\\n        int j=s.size()-1;\\n        while(i<j){\\n            swap(s[i++],s[j--]);\\n        }\\n    }"
                    }
                ]
            },
            {
                "id": 1710659,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/344_reverse_string.cpp"
                    },
                    {
                        "username": "Teja767",
                        "content": "we can update the given list using the python inbuild reverse funtion\\nlist.reverse()"
                    },
                    {
                        "username": "deleted_user",
                        "content": "This is my first Question on leetCode\\nI understood how the input is taken it is very different from other platforms\\nI love the interface and overall experience"
                    },
                    {
                        "username": "sarvagya_jha",
                        "content": "int start=0;\\nint e=s.size()-1;\\nwhile(start<=e){\\n     swap(s[start++],s[e--]);\\n}"
                    },
                    {
                        "username": "mohamed_aichaoui",
                        "content": "easy one"
                    },
                    {
                        "username": "Sanjaykumar702",
                        "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int n = s.size();\\n        int start = 0;\\n        int end = n-1;\\n        int mid= start + (end-start)/2;\\n        for (int i=0; i<=mid; i++){\\n            swap(s[start], s[end]);\\n            start++;\\n            end--;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "alphacz",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        char[] result= new char[s.length];\\n        int j=0;\\n        for(int i=s.length;i<s.length;i--)\\n        {\\n            s[i]=result[j];\\n            j++;\\n        }\\n          return  result;\\n      \\n    }\\n}  \\n\\nLine 10: error: incompatible types: unexpected return value\\n       return  result; \\ncan anybody explain whats wrong with my solution\\n\\n"
                    },
                    {
                        "username": "MehulJ0806",
                        "content": "Do a in-place changes in array s itself.\\n"
                    },
                    {
                        "username": "karimomaya",
                        "content": "Simplest Javascript Solution\\n\\n\\n `\\nvar reverseString = function(s) {\\n    let start = 0;\\n    let end = s.length-1;\\n    \\n    \\n    while(start<end) {\\n        let temp = s[start];\\n        s[start++] = s[end];\\n        s[end--] = temp;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "chetanpatil04102001",
                        "content": "class Solution {\\nprivate:\\n   void solve(vector<char>& s, int i,int n){\\n       if(i>=n/2) return ;\\n       swap(s[i],s[n-i-1]);\\n       solve(s,i+1,n);\\n   }\\n\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int i = 0;\\n        int  n = s.size();\\n        solve(s,i,n);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "saurabh_kumar10",
                        "content": "first make two pointer first pointer stand at 0th index and 2nd pointer stand at the last index, so you just have to swap these pointers till they do not cross each other.\\n\\nComplexity\\nTime complexity:\\no(N)\\n\\nSpace complexity:\\no (1)\\n\\ncode:\\nvoid reverseString(vector<char>& s) {\\n        int i=0;\\n        int j=s.size()-1;\\n        while(i<j){\\n            swap(s[i++],s[j--]);\\n        }\\n    }"
                    }
                ]
            },
            {
                "id": 1709776,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/344_reverse_string.cpp"
                    },
                    {
                        "username": "Teja767",
                        "content": "we can update the given list using the python inbuild reverse funtion\\nlist.reverse()"
                    },
                    {
                        "username": "deleted_user",
                        "content": "This is my first Question on leetCode\\nI understood how the input is taken it is very different from other platforms\\nI love the interface and overall experience"
                    },
                    {
                        "username": "sarvagya_jha",
                        "content": "int start=0;\\nint e=s.size()-1;\\nwhile(start<=e){\\n     swap(s[start++],s[e--]);\\n}"
                    },
                    {
                        "username": "mohamed_aichaoui",
                        "content": "easy one"
                    },
                    {
                        "username": "Sanjaykumar702",
                        "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int n = s.size();\\n        int start = 0;\\n        int end = n-1;\\n        int mid= start + (end-start)/2;\\n        for (int i=0; i<=mid; i++){\\n            swap(s[start], s[end]);\\n            start++;\\n            end--;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "alphacz",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        char[] result= new char[s.length];\\n        int j=0;\\n        for(int i=s.length;i<s.length;i--)\\n        {\\n            s[i]=result[j];\\n            j++;\\n        }\\n          return  result;\\n      \\n    }\\n}  \\n\\nLine 10: error: incompatible types: unexpected return value\\n       return  result; \\ncan anybody explain whats wrong with my solution\\n\\n"
                    },
                    {
                        "username": "MehulJ0806",
                        "content": "Do a in-place changes in array s itself.\\n"
                    },
                    {
                        "username": "karimomaya",
                        "content": "Simplest Javascript Solution\\n\\n\\n `\\nvar reverseString = function(s) {\\n    let start = 0;\\n    let end = s.length-1;\\n    \\n    \\n    while(start<end) {\\n        let temp = s[start];\\n        s[start++] = s[end];\\n        s[end--] = temp;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "chetanpatil04102001",
                        "content": "class Solution {\\nprivate:\\n   void solve(vector<char>& s, int i,int n){\\n       if(i>=n/2) return ;\\n       swap(s[i],s[n-i-1]);\\n       solve(s,i+1,n);\\n   }\\n\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int i = 0;\\n        int  n = s.size();\\n        solve(s,i,n);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "saurabh_kumar10",
                        "content": "first make two pointer first pointer stand at 0th index and 2nd pointer stand at the last index, so you just have to swap these pointers till they do not cross each other.\\n\\nComplexity\\nTime complexity:\\no(N)\\n\\nSpace complexity:\\no (1)\\n\\ncode:\\nvoid reverseString(vector<char>& s) {\\n        int i=0;\\n        int j=s.size()-1;\\n        while(i<j){\\n            swap(s[i++],s[j--]);\\n        }\\n    }"
                    }
                ]
            },
            {
                "id": 1696468,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/344_reverse_string.cpp"
                    },
                    {
                        "username": "Teja767",
                        "content": "we can update the given list using the python inbuild reverse funtion\\nlist.reverse()"
                    },
                    {
                        "username": "deleted_user",
                        "content": "This is my first Question on leetCode\\nI understood how the input is taken it is very different from other platforms\\nI love the interface and overall experience"
                    },
                    {
                        "username": "sarvagya_jha",
                        "content": "int start=0;\\nint e=s.size()-1;\\nwhile(start<=e){\\n     swap(s[start++],s[e--]);\\n}"
                    },
                    {
                        "username": "mohamed_aichaoui",
                        "content": "easy one"
                    },
                    {
                        "username": "Sanjaykumar702",
                        "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int n = s.size();\\n        int start = 0;\\n        int end = n-1;\\n        int mid= start + (end-start)/2;\\n        for (int i=0; i<=mid; i++){\\n            swap(s[start], s[end]);\\n            start++;\\n            end--;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "alphacz",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        char[] result= new char[s.length];\\n        int j=0;\\n        for(int i=s.length;i<s.length;i--)\\n        {\\n            s[i]=result[j];\\n            j++;\\n        }\\n          return  result;\\n      \\n    }\\n}  \\n\\nLine 10: error: incompatible types: unexpected return value\\n       return  result; \\ncan anybody explain whats wrong with my solution\\n\\n"
                    },
                    {
                        "username": "MehulJ0806",
                        "content": "Do a in-place changes in array s itself.\\n"
                    },
                    {
                        "username": "karimomaya",
                        "content": "Simplest Javascript Solution\\n\\n\\n `\\nvar reverseString = function(s) {\\n    let start = 0;\\n    let end = s.length-1;\\n    \\n    \\n    while(start<end) {\\n        let temp = s[start];\\n        s[start++] = s[end];\\n        s[end--] = temp;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "chetanpatil04102001",
                        "content": "class Solution {\\nprivate:\\n   void solve(vector<char>& s, int i,int n){\\n       if(i>=n/2) return ;\\n       swap(s[i],s[n-i-1]);\\n       solve(s,i+1,n);\\n   }\\n\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int i = 0;\\n        int  n = s.size();\\n        solve(s,i,n);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "saurabh_kumar10",
                        "content": "first make two pointer first pointer stand at 0th index and 2nd pointer stand at the last index, so you just have to swap these pointers till they do not cross each other.\\n\\nComplexity\\nTime complexity:\\no(N)\\n\\nSpace complexity:\\no (1)\\n\\ncode:\\nvoid reverseString(vector<char>& s) {\\n        int i=0;\\n        int j=s.size()-1;\\n        while(i<j){\\n            swap(s[i++],s[j--]);\\n        }\\n    }"
                    }
                ]
            },
            {
                "id": 1695343,
                "content": [
                    {
                        "username": "KoalaKeys",
                        "content": "This needs to be changed for python. In python strings are immutable so you cannot \"modify\" a string in-place."
                    },
                    {
                        "username": "suraj_achievers",
                        "content": "1st starting point =0(let) and end point lenth-1(let integer type).\\nand start a  loop till staring point is lessthen endpoint,\\nthen swap string increement and decrement\\n"
                    },
                    {
                        "username": "oppoa5sraj",
                        "content": "how can we implement this question using stack ? \\nAny reccommendation"
                    },
                    {
                        "username": "rishipurwar1",
                        "content": "Here is my solution for this problem but it\\'s not passing the test cases. Anyone please help me?\\n\\n```\\nvar reverseString = function(s) {\\n    if (s.length <= 1) return s;\\n    return reverseString(s.splice(1)) + s[0];\\n};\\n```"
                    },
                    {
                        "username": "uz-java",
                        "content": "Java\\n ```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n            for (int i = 0; i < s.length/2; i++) {\\n            char a=s[i];\\n            s[i]=s[s.length-i-1];\\n            s[s.length-i-1]=a;\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "uz-java",
                        "content": "Java   \\n`class Solution {\\n    public void reverseString(char[] s) {\\n            for (int i = 0; i < s.length/2; i++) {\\n            char a=s[i];\\n            s[i]=s[s.length-i-1];\\n            s[s.length-i-1]=a;\\n        }\\n    }\\n} `"
                    },
                    {
                        "username": "saksham4554",
                        "content": "simple and slick answer for this problem is (if u are using python only other language just get lost)\n `class Solution:\n    def reverseString(self, s: List[str]) -> None:\n        \"\"\"\n        Do not return anything, modify s in-place instead.\n        \"\"\"\n        s.reverse()\n        \n`"
                    },
                    {
                        "username": "Odegaa",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        char[] chars = new char[s.length];\\n        Stack<Character> stack = new Stack<>();\\n        for (char c : s) {\\n            stack.push(c);\\n        }\\n        for (char i = 0; i < s.length; i++) {\\n            chars[i] = stack.pop();\\n        }\\n        System.out.println(Arrays.toString(chars));\\n    }\\n}\\n\\n\\nWHYYY???? Java?????"
                    },
                    {
                        "username": "Shivam_Singh_786",
                        "content": "def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        l, r = 0,len(s) - 1\\n        while l < r:\\n            s[l], s[r] = s[r], s[l]\\n            l, r =l + 1, r -1"
                    },
                    {
                        "username": "wkwanyuen",
                        "content": "def test(s):\\n    reversed = \"\"\\n    for i in range(len(s)-1,-1,-1):\\n        reversed += s[i]\\n    return reversed\\n\\ni want to know why my solution not working in leetcode but work fine in ide"
                    }
                ]
            },
            {
                "id": 1686999,
                "content": [
                    {
                        "username": "KoalaKeys",
                        "content": "This needs to be changed for python. In python strings are immutable so you cannot \"modify\" a string in-place."
                    },
                    {
                        "username": "suraj_achievers",
                        "content": "1st starting point =0(let) and end point lenth-1(let integer type).\\nand start a  loop till staring point is lessthen endpoint,\\nthen swap string increement and decrement\\n"
                    },
                    {
                        "username": "oppoa5sraj",
                        "content": "how can we implement this question using stack ? \\nAny reccommendation"
                    },
                    {
                        "username": "rishipurwar1",
                        "content": "Here is my solution for this problem but it\\'s not passing the test cases. Anyone please help me?\\n\\n```\\nvar reverseString = function(s) {\\n    if (s.length <= 1) return s;\\n    return reverseString(s.splice(1)) + s[0];\\n};\\n```"
                    },
                    {
                        "username": "uz-java",
                        "content": "Java\\n ```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n            for (int i = 0; i < s.length/2; i++) {\\n            char a=s[i];\\n            s[i]=s[s.length-i-1];\\n            s[s.length-i-1]=a;\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "uz-java",
                        "content": "Java   \\n`class Solution {\\n    public void reverseString(char[] s) {\\n            for (int i = 0; i < s.length/2; i++) {\\n            char a=s[i];\\n            s[i]=s[s.length-i-1];\\n            s[s.length-i-1]=a;\\n        }\\n    }\\n} `"
                    },
                    {
                        "username": "saksham4554",
                        "content": "simple and slick answer for this problem is (if u are using python only other language just get lost)\n `class Solution:\n    def reverseString(self, s: List[str]) -> None:\n        \"\"\"\n        Do not return anything, modify s in-place instead.\n        \"\"\"\n        s.reverse()\n        \n`"
                    },
                    {
                        "username": "Odegaa",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        char[] chars = new char[s.length];\\n        Stack<Character> stack = new Stack<>();\\n        for (char c : s) {\\n            stack.push(c);\\n        }\\n        for (char i = 0; i < s.length; i++) {\\n            chars[i] = stack.pop();\\n        }\\n        System.out.println(Arrays.toString(chars));\\n    }\\n}\\n\\n\\nWHYYY???? Java?????"
                    },
                    {
                        "username": "Shivam_Singh_786",
                        "content": "def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        l, r = 0,len(s) - 1\\n        while l < r:\\n            s[l], s[r] = s[r], s[l]\\n            l, r =l + 1, r -1"
                    },
                    {
                        "username": "wkwanyuen",
                        "content": "def test(s):\\n    reversed = \"\"\\n    for i in range(len(s)-1,-1,-1):\\n        reversed += s[i]\\n    return reversed\\n\\ni want to know why my solution not working in leetcode but work fine in ide"
                    }
                ]
            },
            {
                "id": 1685417,
                "content": [
                    {
                        "username": "KoalaKeys",
                        "content": "This needs to be changed for python. In python strings are immutable so you cannot \"modify\" a string in-place."
                    },
                    {
                        "username": "suraj_achievers",
                        "content": "1st starting point =0(let) and end point lenth-1(let integer type).\\nand start a  loop till staring point is lessthen endpoint,\\nthen swap string increement and decrement\\n"
                    },
                    {
                        "username": "oppoa5sraj",
                        "content": "how can we implement this question using stack ? \\nAny reccommendation"
                    },
                    {
                        "username": "rishipurwar1",
                        "content": "Here is my solution for this problem but it\\'s not passing the test cases. Anyone please help me?\\n\\n```\\nvar reverseString = function(s) {\\n    if (s.length <= 1) return s;\\n    return reverseString(s.splice(1)) + s[0];\\n};\\n```"
                    },
                    {
                        "username": "uz-java",
                        "content": "Java\\n ```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n            for (int i = 0; i < s.length/2; i++) {\\n            char a=s[i];\\n            s[i]=s[s.length-i-1];\\n            s[s.length-i-1]=a;\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "uz-java",
                        "content": "Java   \\n`class Solution {\\n    public void reverseString(char[] s) {\\n            for (int i = 0; i < s.length/2; i++) {\\n            char a=s[i];\\n            s[i]=s[s.length-i-1];\\n            s[s.length-i-1]=a;\\n        }\\n    }\\n} `"
                    },
                    {
                        "username": "saksham4554",
                        "content": "simple and slick answer for this problem is (if u are using python only other language just get lost)\n `class Solution:\n    def reverseString(self, s: List[str]) -> None:\n        \"\"\"\n        Do not return anything, modify s in-place instead.\n        \"\"\"\n        s.reverse()\n        \n`"
                    },
                    {
                        "username": "Odegaa",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        char[] chars = new char[s.length];\\n        Stack<Character> stack = new Stack<>();\\n        for (char c : s) {\\n            stack.push(c);\\n        }\\n        for (char i = 0; i < s.length; i++) {\\n            chars[i] = stack.pop();\\n        }\\n        System.out.println(Arrays.toString(chars));\\n    }\\n}\\n\\n\\nWHYYY???? Java?????"
                    },
                    {
                        "username": "Shivam_Singh_786",
                        "content": "def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        l, r = 0,len(s) - 1\\n        while l < r:\\n            s[l], s[r] = s[r], s[l]\\n            l, r =l + 1, r -1"
                    },
                    {
                        "username": "wkwanyuen",
                        "content": "def test(s):\\n    reversed = \"\"\\n    for i in range(len(s)-1,-1,-1):\\n        reversed += s[i]\\n    return reversed\\n\\ni want to know why my solution not working in leetcode but work fine in ide"
                    }
                ]
            },
            {
                "id": 1679540,
                "content": [
                    {
                        "username": "KoalaKeys",
                        "content": "This needs to be changed for python. In python strings are immutable so you cannot \"modify\" a string in-place."
                    },
                    {
                        "username": "suraj_achievers",
                        "content": "1st starting point =0(let) and end point lenth-1(let integer type).\\nand start a  loop till staring point is lessthen endpoint,\\nthen swap string increement and decrement\\n"
                    },
                    {
                        "username": "oppoa5sraj",
                        "content": "how can we implement this question using stack ? \\nAny reccommendation"
                    },
                    {
                        "username": "rishipurwar1",
                        "content": "Here is my solution for this problem but it\\'s not passing the test cases. Anyone please help me?\\n\\n```\\nvar reverseString = function(s) {\\n    if (s.length <= 1) return s;\\n    return reverseString(s.splice(1)) + s[0];\\n};\\n```"
                    },
                    {
                        "username": "uz-java",
                        "content": "Java\\n ```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n            for (int i = 0; i < s.length/2; i++) {\\n            char a=s[i];\\n            s[i]=s[s.length-i-1];\\n            s[s.length-i-1]=a;\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "uz-java",
                        "content": "Java   \\n`class Solution {\\n    public void reverseString(char[] s) {\\n            for (int i = 0; i < s.length/2; i++) {\\n            char a=s[i];\\n            s[i]=s[s.length-i-1];\\n            s[s.length-i-1]=a;\\n        }\\n    }\\n} `"
                    },
                    {
                        "username": "saksham4554",
                        "content": "simple and slick answer for this problem is (if u are using python only other language just get lost)\n `class Solution:\n    def reverseString(self, s: List[str]) -> None:\n        \"\"\"\n        Do not return anything, modify s in-place instead.\n        \"\"\"\n        s.reverse()\n        \n`"
                    },
                    {
                        "username": "Odegaa",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        char[] chars = new char[s.length];\\n        Stack<Character> stack = new Stack<>();\\n        for (char c : s) {\\n            stack.push(c);\\n        }\\n        for (char i = 0; i < s.length; i++) {\\n            chars[i] = stack.pop();\\n        }\\n        System.out.println(Arrays.toString(chars));\\n    }\\n}\\n\\n\\nWHYYY???? Java?????"
                    },
                    {
                        "username": "Shivam_Singh_786",
                        "content": "def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        l, r = 0,len(s) - 1\\n        while l < r:\\n            s[l], s[r] = s[r], s[l]\\n            l, r =l + 1, r -1"
                    },
                    {
                        "username": "wkwanyuen",
                        "content": "def test(s):\\n    reversed = \"\"\\n    for i in range(len(s)-1,-1,-1):\\n        reversed += s[i]\\n    return reversed\\n\\ni want to know why my solution not working in leetcode but work fine in ide"
                    }
                ]
            },
            {
                "id": 1673323,
                "content": [
                    {
                        "username": "KoalaKeys",
                        "content": "This needs to be changed for python. In python strings are immutable so you cannot \"modify\" a string in-place."
                    },
                    {
                        "username": "suraj_achievers",
                        "content": "1st starting point =0(let) and end point lenth-1(let integer type).\\nand start a  loop till staring point is lessthen endpoint,\\nthen swap string increement and decrement\\n"
                    },
                    {
                        "username": "oppoa5sraj",
                        "content": "how can we implement this question using stack ? \\nAny reccommendation"
                    },
                    {
                        "username": "rishipurwar1",
                        "content": "Here is my solution for this problem but it\\'s not passing the test cases. Anyone please help me?\\n\\n```\\nvar reverseString = function(s) {\\n    if (s.length <= 1) return s;\\n    return reverseString(s.splice(1)) + s[0];\\n};\\n```"
                    },
                    {
                        "username": "uz-java",
                        "content": "Java\\n ```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n            for (int i = 0; i < s.length/2; i++) {\\n            char a=s[i];\\n            s[i]=s[s.length-i-1];\\n            s[s.length-i-1]=a;\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "uz-java",
                        "content": "Java   \\n`class Solution {\\n    public void reverseString(char[] s) {\\n            for (int i = 0; i < s.length/2; i++) {\\n            char a=s[i];\\n            s[i]=s[s.length-i-1];\\n            s[s.length-i-1]=a;\\n        }\\n    }\\n} `"
                    },
                    {
                        "username": "saksham4554",
                        "content": "simple and slick answer for this problem is (if u are using python only other language just get lost)\n `class Solution:\n    def reverseString(self, s: List[str]) -> None:\n        \"\"\"\n        Do not return anything, modify s in-place instead.\n        \"\"\"\n        s.reverse()\n        \n`"
                    },
                    {
                        "username": "Odegaa",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        char[] chars = new char[s.length];\\n        Stack<Character> stack = new Stack<>();\\n        for (char c : s) {\\n            stack.push(c);\\n        }\\n        for (char i = 0; i < s.length; i++) {\\n            chars[i] = stack.pop();\\n        }\\n        System.out.println(Arrays.toString(chars));\\n    }\\n}\\n\\n\\nWHYYY???? Java?????"
                    },
                    {
                        "username": "Shivam_Singh_786",
                        "content": "def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        l, r = 0,len(s) - 1\\n        while l < r:\\n            s[l], s[r] = s[r], s[l]\\n            l, r =l + 1, r -1"
                    },
                    {
                        "username": "wkwanyuen",
                        "content": "def test(s):\\n    reversed = \"\"\\n    for i in range(len(s)-1,-1,-1):\\n        reversed += s[i]\\n    return reversed\\n\\ni want to know why my solution not working in leetcode but work fine in ide"
                    }
                ]
            },
            {
                "id": 1673315,
                "content": [
                    {
                        "username": "KoalaKeys",
                        "content": "This needs to be changed for python. In python strings are immutable so you cannot \"modify\" a string in-place."
                    },
                    {
                        "username": "suraj_achievers",
                        "content": "1st starting point =0(let) and end point lenth-1(let integer type).\\nand start a  loop till staring point is lessthen endpoint,\\nthen swap string increement and decrement\\n"
                    },
                    {
                        "username": "oppoa5sraj",
                        "content": "how can we implement this question using stack ? \\nAny reccommendation"
                    },
                    {
                        "username": "rishipurwar1",
                        "content": "Here is my solution for this problem but it\\'s not passing the test cases. Anyone please help me?\\n\\n```\\nvar reverseString = function(s) {\\n    if (s.length <= 1) return s;\\n    return reverseString(s.splice(1)) + s[0];\\n};\\n```"
                    },
                    {
                        "username": "uz-java",
                        "content": "Java\\n ```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n            for (int i = 0; i < s.length/2; i++) {\\n            char a=s[i];\\n            s[i]=s[s.length-i-1];\\n            s[s.length-i-1]=a;\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "uz-java",
                        "content": "Java   \\n`class Solution {\\n    public void reverseString(char[] s) {\\n            for (int i = 0; i < s.length/2; i++) {\\n            char a=s[i];\\n            s[i]=s[s.length-i-1];\\n            s[s.length-i-1]=a;\\n        }\\n    }\\n} `"
                    },
                    {
                        "username": "saksham4554",
                        "content": "simple and slick answer for this problem is (if u are using python only other language just get lost)\n `class Solution:\n    def reverseString(self, s: List[str]) -> None:\n        \"\"\"\n        Do not return anything, modify s in-place instead.\n        \"\"\"\n        s.reverse()\n        \n`"
                    },
                    {
                        "username": "Odegaa",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        char[] chars = new char[s.length];\\n        Stack<Character> stack = new Stack<>();\\n        for (char c : s) {\\n            stack.push(c);\\n        }\\n        for (char i = 0; i < s.length; i++) {\\n            chars[i] = stack.pop();\\n        }\\n        System.out.println(Arrays.toString(chars));\\n    }\\n}\\n\\n\\nWHYYY???? Java?????"
                    },
                    {
                        "username": "Shivam_Singh_786",
                        "content": "def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        l, r = 0,len(s) - 1\\n        while l < r:\\n            s[l], s[r] = s[r], s[l]\\n            l, r =l + 1, r -1"
                    },
                    {
                        "username": "wkwanyuen",
                        "content": "def test(s):\\n    reversed = \"\"\\n    for i in range(len(s)-1,-1,-1):\\n        reversed += s[i]\\n    return reversed\\n\\ni want to know why my solution not working in leetcode but work fine in ide"
                    }
                ]
            },
            {
                "id": 1667248,
                "content": [
                    {
                        "username": "KoalaKeys",
                        "content": "This needs to be changed for python. In python strings are immutable so you cannot \"modify\" a string in-place."
                    },
                    {
                        "username": "suraj_achievers",
                        "content": "1st starting point =0(let) and end point lenth-1(let integer type).\\nand start a  loop till staring point is lessthen endpoint,\\nthen swap string increement and decrement\\n"
                    },
                    {
                        "username": "oppoa5sraj",
                        "content": "how can we implement this question using stack ? \\nAny reccommendation"
                    },
                    {
                        "username": "rishipurwar1",
                        "content": "Here is my solution for this problem but it\\'s not passing the test cases. Anyone please help me?\\n\\n```\\nvar reverseString = function(s) {\\n    if (s.length <= 1) return s;\\n    return reverseString(s.splice(1)) + s[0];\\n};\\n```"
                    },
                    {
                        "username": "uz-java",
                        "content": "Java\\n ```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n            for (int i = 0; i < s.length/2; i++) {\\n            char a=s[i];\\n            s[i]=s[s.length-i-1];\\n            s[s.length-i-1]=a;\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "uz-java",
                        "content": "Java   \\n`class Solution {\\n    public void reverseString(char[] s) {\\n            for (int i = 0; i < s.length/2; i++) {\\n            char a=s[i];\\n            s[i]=s[s.length-i-1];\\n            s[s.length-i-1]=a;\\n        }\\n    }\\n} `"
                    },
                    {
                        "username": "saksham4554",
                        "content": "simple and slick answer for this problem is (if u are using python only other language just get lost)\n `class Solution:\n    def reverseString(self, s: List[str]) -> None:\n        \"\"\"\n        Do not return anything, modify s in-place instead.\n        \"\"\"\n        s.reverse()\n        \n`"
                    },
                    {
                        "username": "Odegaa",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        char[] chars = new char[s.length];\\n        Stack<Character> stack = new Stack<>();\\n        for (char c : s) {\\n            stack.push(c);\\n        }\\n        for (char i = 0; i < s.length; i++) {\\n            chars[i] = stack.pop();\\n        }\\n        System.out.println(Arrays.toString(chars));\\n    }\\n}\\n\\n\\nWHYYY???? Java?????"
                    },
                    {
                        "username": "Shivam_Singh_786",
                        "content": "def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        l, r = 0,len(s) - 1\\n        while l < r:\\n            s[l], s[r] = s[r], s[l]\\n            l, r =l + 1, r -1"
                    },
                    {
                        "username": "wkwanyuen",
                        "content": "def test(s):\\n    reversed = \"\"\\n    for i in range(len(s)-1,-1,-1):\\n        reversed += s[i]\\n    return reversed\\n\\ni want to know why my solution not working in leetcode but work fine in ide"
                    }
                ]
            },
            {
                "id": 1664982,
                "content": [
                    {
                        "username": "KoalaKeys",
                        "content": "This needs to be changed for python. In python strings are immutable so you cannot \"modify\" a string in-place."
                    },
                    {
                        "username": "suraj_achievers",
                        "content": "1st starting point =0(let) and end point lenth-1(let integer type).\\nand start a  loop till staring point is lessthen endpoint,\\nthen swap string increement and decrement\\n"
                    },
                    {
                        "username": "oppoa5sraj",
                        "content": "how can we implement this question using stack ? \\nAny reccommendation"
                    },
                    {
                        "username": "rishipurwar1",
                        "content": "Here is my solution for this problem but it\\'s not passing the test cases. Anyone please help me?\\n\\n```\\nvar reverseString = function(s) {\\n    if (s.length <= 1) return s;\\n    return reverseString(s.splice(1)) + s[0];\\n};\\n```"
                    },
                    {
                        "username": "uz-java",
                        "content": "Java\\n ```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n            for (int i = 0; i < s.length/2; i++) {\\n            char a=s[i];\\n            s[i]=s[s.length-i-1];\\n            s[s.length-i-1]=a;\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "uz-java",
                        "content": "Java   \\n`class Solution {\\n    public void reverseString(char[] s) {\\n            for (int i = 0; i < s.length/2; i++) {\\n            char a=s[i];\\n            s[i]=s[s.length-i-1];\\n            s[s.length-i-1]=a;\\n        }\\n    }\\n} `"
                    },
                    {
                        "username": "saksham4554",
                        "content": "simple and slick answer for this problem is (if u are using python only other language just get lost)\n `class Solution:\n    def reverseString(self, s: List[str]) -> None:\n        \"\"\"\n        Do not return anything, modify s in-place instead.\n        \"\"\"\n        s.reverse()\n        \n`"
                    },
                    {
                        "username": "Odegaa",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        char[] chars = new char[s.length];\\n        Stack<Character> stack = new Stack<>();\\n        for (char c : s) {\\n            stack.push(c);\\n        }\\n        for (char i = 0; i < s.length; i++) {\\n            chars[i] = stack.pop();\\n        }\\n        System.out.println(Arrays.toString(chars));\\n    }\\n}\\n\\n\\nWHYYY???? Java?????"
                    },
                    {
                        "username": "Shivam_Singh_786",
                        "content": "def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        l, r = 0,len(s) - 1\\n        while l < r:\\n            s[l], s[r] = s[r], s[l]\\n            l, r =l + 1, r -1"
                    },
                    {
                        "username": "wkwanyuen",
                        "content": "def test(s):\\n    reversed = \"\"\\n    for i in range(len(s)-1,-1,-1):\\n        reversed += s[i]\\n    return reversed\\n\\ni want to know why my solution not working in leetcode but work fine in ide"
                    }
                ]
            },
            {
                "id": 1655758,
                "content": [
                    {
                        "username": "KoalaKeys",
                        "content": "This needs to be changed for python. In python strings are immutable so you cannot \"modify\" a string in-place."
                    },
                    {
                        "username": "suraj_achievers",
                        "content": "1st starting point =0(let) and end point lenth-1(let integer type).\\nand start a  loop till staring point is lessthen endpoint,\\nthen swap string increement and decrement\\n"
                    },
                    {
                        "username": "oppoa5sraj",
                        "content": "how can we implement this question using stack ? \\nAny reccommendation"
                    },
                    {
                        "username": "rishipurwar1",
                        "content": "Here is my solution for this problem but it\\'s not passing the test cases. Anyone please help me?\\n\\n```\\nvar reverseString = function(s) {\\n    if (s.length <= 1) return s;\\n    return reverseString(s.splice(1)) + s[0];\\n};\\n```"
                    },
                    {
                        "username": "uz-java",
                        "content": "Java\\n ```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n            for (int i = 0; i < s.length/2; i++) {\\n            char a=s[i];\\n            s[i]=s[s.length-i-1];\\n            s[s.length-i-1]=a;\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "uz-java",
                        "content": "Java   \\n`class Solution {\\n    public void reverseString(char[] s) {\\n            for (int i = 0; i < s.length/2; i++) {\\n            char a=s[i];\\n            s[i]=s[s.length-i-1];\\n            s[s.length-i-1]=a;\\n        }\\n    }\\n} `"
                    },
                    {
                        "username": "saksham4554",
                        "content": "simple and slick answer for this problem is (if u are using python only other language just get lost)\n `class Solution:\n    def reverseString(self, s: List[str]) -> None:\n        \"\"\"\n        Do not return anything, modify s in-place instead.\n        \"\"\"\n        s.reverse()\n        \n`"
                    },
                    {
                        "username": "Odegaa",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        char[] chars = new char[s.length];\\n        Stack<Character> stack = new Stack<>();\\n        for (char c : s) {\\n            stack.push(c);\\n        }\\n        for (char i = 0; i < s.length; i++) {\\n            chars[i] = stack.pop();\\n        }\\n        System.out.println(Arrays.toString(chars));\\n    }\\n}\\n\\n\\nWHYYY???? Java?????"
                    },
                    {
                        "username": "Shivam_Singh_786",
                        "content": "def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        l, r = 0,len(s) - 1\\n        while l < r:\\n            s[l], s[r] = s[r], s[l]\\n            l, r =l + 1, r -1"
                    },
                    {
                        "username": "wkwanyuen",
                        "content": "def test(s):\\n    reversed = \"\"\\n    for i in range(len(s)-1,-1,-1):\\n        reversed += s[i]\\n    return reversed\\n\\ni want to know why my solution not working in leetcode but work fine in ide"
                    }
                ]
            },
            {
                "id": 1642440,
                "content": [
                    {
                        "username": "KoalaKeys",
                        "content": "This needs to be changed for python. In python strings are immutable so you cannot \"modify\" a string in-place."
                    },
                    {
                        "username": "suraj_achievers",
                        "content": "1st starting point =0(let) and end point lenth-1(let integer type).\\nand start a  loop till staring point is lessthen endpoint,\\nthen swap string increement and decrement\\n"
                    },
                    {
                        "username": "oppoa5sraj",
                        "content": "how can we implement this question using stack ? \\nAny reccommendation"
                    },
                    {
                        "username": "rishipurwar1",
                        "content": "Here is my solution for this problem but it\\'s not passing the test cases. Anyone please help me?\\n\\n```\\nvar reverseString = function(s) {\\n    if (s.length <= 1) return s;\\n    return reverseString(s.splice(1)) + s[0];\\n};\\n```"
                    },
                    {
                        "username": "uz-java",
                        "content": "Java\\n ```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n            for (int i = 0; i < s.length/2; i++) {\\n            char a=s[i];\\n            s[i]=s[s.length-i-1];\\n            s[s.length-i-1]=a;\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "uz-java",
                        "content": "Java   \\n`class Solution {\\n    public void reverseString(char[] s) {\\n            for (int i = 0; i < s.length/2; i++) {\\n            char a=s[i];\\n            s[i]=s[s.length-i-1];\\n            s[s.length-i-1]=a;\\n        }\\n    }\\n} `"
                    },
                    {
                        "username": "saksham4554",
                        "content": "simple and slick answer for this problem is (if u are using python only other language just get lost)\n `class Solution:\n    def reverseString(self, s: List[str]) -> None:\n        \"\"\"\n        Do not return anything, modify s in-place instead.\n        \"\"\"\n        s.reverse()\n        \n`"
                    },
                    {
                        "username": "Odegaa",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        char[] chars = new char[s.length];\\n        Stack<Character> stack = new Stack<>();\\n        for (char c : s) {\\n            stack.push(c);\\n        }\\n        for (char i = 0; i < s.length; i++) {\\n            chars[i] = stack.pop();\\n        }\\n        System.out.println(Arrays.toString(chars));\\n    }\\n}\\n\\n\\nWHYYY???? Java?????"
                    },
                    {
                        "username": "Shivam_Singh_786",
                        "content": "def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        l, r = 0,len(s) - 1\\n        while l < r:\\n            s[l], s[r] = s[r], s[l]\\n            l, r =l + 1, r -1"
                    },
                    {
                        "username": "wkwanyuen",
                        "content": "def test(s):\\n    reversed = \"\"\\n    for i in range(len(s)-1,-1,-1):\\n        reversed += s[i]\\n    return reversed\\n\\ni want to know why my solution not working in leetcode but work fine in ide"
                    }
                ]
            }
        ]
    }
]